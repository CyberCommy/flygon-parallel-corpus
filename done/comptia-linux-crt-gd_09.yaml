- en: Creating, Monitoring, Killing, and Restarting Processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked in detail at file management. Then, we covered
    how to create a file at the shell. Furthermore, we saw the various permissions
    for a file, and we learned how to change them. Following this, we moved onto directories
    inside a Linux environment. Finally, we worked with pipes and redirects, within
    the context of the shell environment. Also, we took a look at another powerful
    command—the `tee` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to explore various techniques that can be used
    for managing various processes. First, we will investigate processes in real time
    using a very popular command—the `ps` command. This `ps` command was briefly covered
    in [Chapter 2](part0026.html#OPEK0-43f6e611c18f4c7abc8a9e3790317ae8), *Booting
    the System*, in the *The boot process – explained* section. In this chapter, we
    place more emphasis on the `ps` command, exploring more options that can be passed,
    thereby exposing vital information. After this, we venture into methods of managing
    daemons; first, we start off with the very popular `top` command. This method
    of handling processes is widely used throughout the Linux community. This is mainly
    because the `top` command gives real-time statistics for various daemons. In addition
    to this, we can also control daemon behavior. Following this, we move onto another
    common method for managing processes: the `service` command. Finally, we cover
    the latest method for daemon management; namely, the `systemctl` command. This
    was covered in [Chapter 2](part0026.html#OPEK0-43f6e611c18f4c7abc8a9e3790317ae8),
    *Booting the System*, in the *The boot process: Explained* section. In this chapter,
    we go into more depth on common practices used for daemon management, using the
    `systemctl` command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ps` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing and managing processes using the `top` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing processes with the `service` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing processes with the `systemctl` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ps command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ps` command, which stands for **Process Status**, is one of the most popular
    commands used in today's environment. It displays the current processes running
    within a system; when we work within a Linux environment, we often overlook the
    underlying processes that make it all possible. All the information that the `ps`
    command displays comes from a very popular directory; namely, the `/proc` filesystem.
    The `/proc` filesystem is not actually a real filesystem, per say; it is in fact
    a virtual filesystem. It's loaded upon boot time, and you will find the `/proc` filesystem
    in almost every Linux distribution available today. Let's dive into the `ps` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, we can display any process that has started in the current shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the preceding output, we have not started any other process in the
    current shell, except for the `ps` command itself and the Bash shell. We can also
    list all of the processes currently present within a system, using the `ps` command;
    we would pass the `-A` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the `ps` command with either `-A` or `-e` parameter, it will only
    print out the process IDs and the name of each process. But wait, we can expand
    this output even further. We can pass `-a` along with `-u`. This will print out
    processes for the current user who opened the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00111.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To see all processes owned by the current user in the system, we pass the `-x`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also specify a user as part of the argument with `-u`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also see all the users in addition to the path to the executable for
    each daemon; we pass `-aux` or `aux-`; this is the **Berkeley Software Distribution**
    (**BSD**) syntax. The BSD is another flavor of Unix. Following is an example of
    the Linux syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! Based on the preceding output, we can see various user accounts. Some
    of the accounts are actual system accounts, such as the `dbus` account. We can
    also specify a user account ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to this, it is also possible to display processes that are owned
    by a particular group. Yes! It''s possible by passing either the group name or
    ID. If we''re passing the group name then we use `-g`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To pass the group ID, we pass the `-G` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Great job! We can also search for a process by specifying the **process ID**
    (**PID**). We pass `-f` that will print a long listing along with the `-p` option,
    which expects a numerical value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly enough, we can even specify multiple processes on the same line;
    we separate the processes by a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Great job! It is also possible to find a command by specifying the process
    ID by passing the `-o` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Based on the preceding output, only the actual executable for the respective
    PID is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to get memory and CPU information using the `ps` command;
    we pass the `-e` option along with the `-o` option. We then need to pass the column
    names that interest us. Here is how we accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! Based on the preceding output, we've specified `pid,ppid,cmd,%mem,%cpu`.
    In addition to this, the `--sort` option was added. This looks for the processes
    that have used up most of the system RAM and displays those first starting from
    highest to lowest. In addition, we've added the `head` command; this will only
    display the top portion of the content.
  prefs: []
  type: TYPE_NORMAL
- en: 'We specified that we would only like to see the first 14 lines. But wait, the
    output from the `ps` command isn''t refreshed in real time; we can use yet another
    popular command to see the output refresh in real time instead of us having to
    rerun the command. We use the `watch` command to accomplish this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of running the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00112.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Based on the preceding screenshot, we have sorted the output to view the processes
    that are taking up most of the CPU within the system. We can view the output of
    the `ps` command in a hierarchical view; we would add the `-f` and `--forest`
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The kill command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `kill` command is used for terminating processes. We can leverage the `ps`
    command, which we just covered, to identify a process, then call the `kill` command
    to end the process. Here is how we stop a process using the `kill` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome job! We used the `9` number, which means to send a `SIGKILL`. To see
    the various signals we can pass, we can use the `-l` option with the `kill` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To stop a process using the signal name, we pass the `-s` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Caution should be taken whenever stopping a process with the `SIGTERM` while
    calling the `kill` command.
  prefs: []
  type: TYPE_NORMAL
- en: The pstree command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is also another flavor of the `ps` command that can be used to view processes
    within a system—the `pstree` command. This will present all processes in a hierarchical
    layout. This is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00113.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Based on the preceding screenshot, some processes are parent processes: they
    have child processes. We can also highlight a specific process by passing the
    `-h` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also display only the processes specific to a user; we pass `username`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00114.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Based on the preceding screenshot, we can see the user parent process is `gdm-x-session`;
    this then has child processes, starting with `Xorg` and moving down the tree.
  prefs: []
  type: TYPE_NORMAL
- en: The pgrep command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Process Grep**, commonly known as `pgrep`, is another popular method
    used for finding process IDs at the shell. If we know the process name, then we
    can specify it with the `pgrep` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the preceding command, we can see the PID for `rsyslogd`. We can also
    find processes for a particular user. To do this, we pass the `-u` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Awesome job!
  prefs: []
  type: TYPE_NORMAL
- en: The pkill command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `pkill` command is another known method used for terminating processes.
    It enables us to use the process name when terminating a given process. In its
    simplest form, it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Awesome job! Based on the preceding code output, we can see the effectiveness
    of the `pkill` command.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing and managing processes using the top command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `top` command, which means *table of processes*, is similar in nature to
    Windows task manager. You will find a wide variety of Linux distributions that
    support the `top` command. The `top` command is essentially used to derive the
    system''s CPU and memory utilization. The output is structured by creating a list
    of running processes selected by user-specified criteria; the output is in real
    time. The PID for each process is listed in the first column. Let''s fire it up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To the far right, there is a `COMMAND` column; this shows the executable. We
    can filter which user we would like to be displayed and their corresponding processes;
    we pass the `-u` option with `top`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the preceding output, only the user `philip` is displayed with the
    processes. We can view the absolute path for all processes by pressing *C* inside
    the `top` command. Here is a screenshot of what you get when *C* is pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00115.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Awesome job! Now we can see the location for each process. We can also change
    how often the output is refreshed; the default is every three seconds. We press
    the *D* key from within the `top` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00116.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Based on the preceding screenshot, when the *D* key is pressed, a new line
    appears: `Change delay from 3.0 to`. This prompts us to specify a number. I''ll
    type `2` here so the updates will refresh every two seconds. Now, when I press
    *D *once again, we will notice the difference in the prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00117.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Great job! To see help with `top`, we can press *H*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00118.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can change how the memory is displayed inside in the `top` utility; depending
    on the current memory output, the display will toggle when we press *M*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the preceding screenshot, the section for the memory is hidden. When
    we press the *M* key once again, this will change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00119.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Awesome! If we press the *M* key once again, we will see a sort of graphical
    design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00120.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Great job! Now we have the nice bars indicating the memory usage for both RAM
    and swap. Similarly, we can change the display of the output by CPU; to do so,
    we press *T*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! When we press *T,* it will then turn the bars into a shaded output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00121.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition to this, the processes can also be displayed in a hierarchical
    output; we press *Shift* + *V*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00122.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To turn off the forest view, we simply toggle *Shift* + *V* once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00123.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also stop a process using the `top` command; we press *K*, which is
    for killing processes inside the `top` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00124.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Based on the preceding command, a new line appears: `PID to signal/kill [default
    pid = 1710]`, and we need to specify a process ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to specify the signal to send to the process; the default is `15/sigterm`.
    We'll accept the default; this will terminate the process without us having to
    exit the `top` utility.
  prefs: []
  type: TYPE_NORMAL
- en: Managing process(es) with the service command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `service` command initially was used to run SysVinit scripts on early Linux
    distributions prior to `systemd`. Depending on the what you''re trying to accomplish,
    the method you use to start, stop, or restart a service will depend upon whether
    your distribution uses `systemd` or `init`. Most Linux engineers prefer to use
    the `service` command as opposed to the newer methods of handling processes in
    system environments. Thus in most newer distributions the `service` command is
    supported. The syntax for the `service` command is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To view all services on a system running SysV scripts, we''ll use the CentOS
    6.5 system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The scripts that the `service` command reads start with `rc`. We can quickly
    view all related scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To control the status of a process, we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding command, this particular process is currently running. We
    can change this; let''s say we want to stop the `crond` process. We simply replace
    `status` with `stop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the preceding output, we run into a roadblock; this can easily be
    remedied by becoming the root user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome job! Now we can rerun the `service` command; this time using the `status`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And there we have it. The service has been stopped. To start backing up this
    process, we simply replace `stop` with `start`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s try to start the process once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Great job! If, for some reason, we have changes to the process and need to
    restart the process, then we can do it in a number of ways. We can stop the process
    and then start it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we can use the `restart` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we can use the `reload` option; this last option will reread the configuration
    files for any changes that have been made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Awesome job!
  prefs: []
  type: TYPE_NORMAL
- en: Managing process(es) with the systemctl command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On most new distributions that use system, we would manage processes using
    the `systemctl` command. The Linux developers have also left support for the `service`
    command; if we try to terminate a process using the `service` command, then we
    will see that it is actually going to redirect our request to the `systemctl`
    command. Let''s try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! Based on the output, we can see that the `service` command is in fact
    being redirected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s try using the newer approach for managing processes; we''ll use
    the `systemctl` command. The format is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this at the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To start a process using `systemctl`, we pass the `start` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check on the status for a process by passing the `status` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that the output from the `systemctl` command is much more intuitive
    than the older service command in early Linux distributions. We can also stop
    a process using the `systemctl` command; we pass the `stop` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we can restart or reload a process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the preceding output, when we passed the `restart` option, it simply
    started the process. The processes that `systemctl` handles are considered as
    units when using the `systemctl` command. We can view the units by passing `list-units`
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The various processes are stored in `/usr/lib/systemd/system`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are a wide variety of processes that are managed using
    the `systemctl` command.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dealt with various aspects relating to handling processes
    from within the shell. We started off with the `ps` command. The methods to expose
    processes currently running in the shell were shown. Next, we saw how to print
    all processes running on the system. This was followed up by exposing the commands
    used by each process. We then focused on filtering the output for a particular
    user, also by the user ID. After that, we touched on filtering for a process,
    also filtering by the process ID. In addition to this, we tackled filtering by
    groups. This was followed by changing the display into a forest layout.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we saw how to pull memory and CPU information; we called on the
    `watch` command to update the results in real time. Finally, we saw how to terminate
    a process using the `ps` command in combination with the `kill` command. Next,
    we touched on the `pstree` command; this presents the processes in a hierarchical
    format. We even manipulated its output to narrow in on a specific process; in
    addition, we also checked for a specific user's processes.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we touched on the `pgrep` command, also known as process grep.
    This is another method for finding a process ID; either a process name can be
    supplied, or we can specify the user whose processes we would like to be displayed.
    Following this, we touched on the `pkill` command; as the names suggests, it is
    used to terminate a process. We saw this in the demo. After that, we worked with
    the `top` command, using various techniques for manipulating the output of the
    results, and explored how the to terminate a process while inside the `top` command.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we worked with the `service` command; we talked about where we usually
    find it, and looked at its support in newer Linux distributions. Various demos
    were done using the `service` command. Finally, we worked with the `systemctl`
    command; this is by far the best method for managing processes in newer Linux
    distributions that use systems, as opposed to older Linux distributions that use
    SysVinit scripts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we go deeper into managing processes. There are times when
    we want to give preference to one process over another. This is the focus of the
    next chapter. This will not only enable you to manage your processes on your system
    but it will also give you an edge over others, thus taking you one step closer
    to certification. I hope to see you there.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which command prints processes that have been started in a new Terminal?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `pkill`
  prefs: []
  type: TYPE_NORMAL
- en: B. `chmod`
  prefs: []
  type: TYPE_NORMAL
- en: C. `ps`
  prefs: []
  type: TYPE_NORMAL
- en: D. `chage`
  prefs: []
  type: TYPE_NORMAL
- en: Which option with the `ps` command prints all processes running in a system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `-B`
  prefs: []
  type: TYPE_NORMAL
- en: B. `-b`
  prefs: []
  type: TYPE_NORMAL
- en: C. `-e`
  prefs: []
  type: TYPE_NORMAL
- en: D. `-x`
  prefs: []
  type: TYPE_NORMAL
- en: Which option with the `ps` command can be used to print the output in a hierarchical
    layout?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `-forest`
  prefs: []
  type: TYPE_NORMAL
- en: B. `--forest`
  prefs: []
  type: TYPE_NORMAL
- en: C. `--tree`
  prefs: []
  type: TYPE_NORMAL
- en: D. `-tree`
  prefs: []
  type: TYPE_NORMAL
- en: Which option with the `ps` command is used to specify a user process?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `-x`
  prefs: []
  type: TYPE_NORMAL
- en: B. `-a`
  prefs: []
  type: TYPE_NORMAL
- en: C. `-u`
  prefs: []
  type: TYPE_NORMAL
- en: D. `-d`
  prefs: []
  type: TYPE_NORMAL
- en: Which option with the `kill` command is used to display the various SIG terms?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `-`
  prefs: []
  type: TYPE_NORMAL
- en: B. `-l`
  prefs: []
  type: TYPE_NORMAL
- en: C. `-i`
  prefs: []
  type: TYPE_NORMAL
- en: D. `-d`
  prefs: []
  type: TYPE_NORMAL
- en: Which number is equivalent to `SIGKILL` when using the `kill` command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `8`
  prefs: []
  type: TYPE_NORMAL
- en: B. `10`
  prefs: []
  type: TYPE_NORMAL
- en: C. `7`
  prefs: []
  type: TYPE_NORMAL
- en: D. `9`
  prefs: []
  type: TYPE_NORMAL
- en: Which option with the `top` command can specify the user?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `-u`
  prefs: []
  type: TYPE_NORMAL
- en: B. `-p`
  prefs: []
  type: TYPE_NORMAL
- en: C. `-v`
  prefs: []
  type: TYPE_NORMAL
- en: D. `-a`
  prefs: []
  type: TYPE_NORMAL
- en: Which letter is used to set how often the results are refreshed inside the `top`
    utility?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `-a`
  prefs: []
  type: TYPE_NORMAL
- en: B. `b`
  prefs: []
  type: TYPE_NORMAL
- en: C. `d`
  prefs: []
  type: TYPE_NORMAL
- en: D. `e`
  prefs: []
  type: TYPE_NORMAL
- en: Which option can be used to reread a process configuration with the `service`
    command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `reboot`
  prefs: []
  type: TYPE_NORMAL
- en: B. `stop`
  prefs: []
  type: TYPE_NORMAL
- en: C. `status`
  prefs: []
  type: TYPE_NORMAL
- en: D. `reload`
  prefs: []
  type: TYPE_NORMAL
- en: In which directory are the units `/processes` located in a system that is managed
    by the `systemctl` command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `/var/lib/systemd`
  prefs: []
  type: TYPE_NORMAL
- en: B. `/usr/lib/systemd/system`
  prefs: []
  type: TYPE_NORMAL
- en: C. `/usr/systemd/system`
  prefs: []
  type: TYPE_NORMAL
- en: D. `/usr/system/systemd`
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more info about processes, see: [https://www.tutorialspoint.com.](https://www.tutorialspoint.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This website gives you a lot of useful tips for processes: [https://www.linux.com.](https://www.linux.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This last link gives you information in general that relates to various commands.
    You can post your questions there, and other community members will respond: [https://www.linuxquestions.org.](https://www.linuxquestions.org)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
