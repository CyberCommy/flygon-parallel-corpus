- en: Measuring Distance and Detecting Movement
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to our final core electronics-based chapter. In the previous chapter,
    we learned how to control three different forms of motors in complex ways. In
    this chapter, we will direct our attention to detecting movement and measuring
    the distance with our Raspberry Pi and electronics.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting movement is very useful for automation projects such as turning on
    lights when you walk into a room or building, an alarm system, building counters,
    or detecting revolutions of a shaft. We will be looking at two techniques for
    movement detection, including a **Passive Infrared** (**PIR**) sensor that uses
    heat detection to detect the presence of a person (or animal), and a digital Hall-effect
    sensor that detects the presence of a magnetic field (or, more liberally, we can
    say that the Hall-effect sensor can detect when a magnet moves past it).
  prefs: []
  type: TYPE_NORMAL
- en: Distance measurement is also useful for many projects, from collision detection
    circuits to measuring water tank levels. We will be looking at two forms of distance
    measurement, including the use of an ultrasonic sound sensor that can measure
    distances of around 2 centimeters to 4 meters, and also an analog Hall-effect
    sensor that can measure the proximity of a magnetic field down to millimeters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting movement with a PIR sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring distance with an ultrasonic sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting movement and distance with Hall-effect sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To perform the exercises in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi 4 Model B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raspbian OS Buster (with desktop and recommended software)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum Python version 3.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These requirements are what the code examples in this book are based on. It's
    reasonable to expect that the code examples should work without modification on
    Raspberry Pi 3 Model B or a different version of Raspbian OS as long as your Python
    version is 3.5 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: You will find this chapter's source code in the `chapter11` folder in the GitHub
    repository available at [https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to execute the following commands in a terminal to set up a virtual
    environment and install the Python libraries required for the code in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following dependencies are installed from `requirements.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PiGPIO**: The PiGPIO GPIO library ([https://pypi.org/project/pigpio](https://pypi.org/project/pigpio))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ADS1X15**: The ADS11x5 ADC library ([https://pypi.org/project/adafruit-circuitpython-ads1x15](https://pypi.org/project/adafruit-circuitpython-ads1x15))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The electronic components we will need for this chapter''s exercises are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 x 1kΩ resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x 2kΩ resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x HC-SR501 PIR sensor (datasheet: [https://www.alldatasheet.com/datasheet-pdf/pdf/1131987/ETC2/HC-SR501.html](https://www.alldatasheet.com/datasheet-pdf/pdf/1131987/ETC2/HC-SR501.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x A3144 Hall-effect sensor (non-latching) (datasheet: [https://www.alldatasheet.com/datasheet-pdf/pdf/55092/ALLEGRO/A3144.html](https://www.alldatasheet.com/datasheet-pdf/pdf/55092/ALLEGRO/A3144.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x AH3503 Hall-effect sensor (ratiometric) (datasheet: [https://www.alldatasheet.com/datasheet-pdf/pdf/1132644/AHNJ/AH3503.html](https://www.alldatasheet.com/datasheet-pdf/pdf/1132644/AHNJ/AH3503.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x HC-SR04 or HC-SR04P ultrasonic distance sensor (datasheet: [https://tinyurl.com/HCSR04DS](https://tinyurl.com/HCSR04DS))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A small magnet for use with the Hall-effect sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are two variations of the HC-SR04 available. The more common HC-SR04,
    which outputs 5-volt logic and the HC-SR04**P**, which can operate at between
    3 volts and 5.5 volts. Either module will be suitable for the exercise in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting movement with a PIR sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A PIR sensor is a device that can detect infrared light (heat) emitted by an
    object (for example, a person). We see these types of sensors all around us in
    applications such as security systems and automatic doors and lights that react
    to our presence. The *passive* in PIR means the sensor just detects movement.
    To detect *what* moved and *how*, you would need an active infrared device, such
    as a thermal camera.
  prefs: []
  type: TYPE_NORMAL
- en: PIR sensors come in a few different forms and varieties; however, their basic
    usage is the same – they act as a simple digital switch. When they do not detect
    movement, they output a digital `LOW`, and when movement is detected, they output
    a digital `HIGH`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shown in the following figure is the HC-SR501 PIR sensor module that we will
    be using for our example. Pictured are the top of the module, the underside, and
    a common schematic symbol for a PIR sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/15a71ea4-9918-4be8-a0fc-27240f8add81.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – HC-SR501 PIR sensor module
  prefs: []
  type: TYPE_NORMAL
- en: Some PIR sensors, including our HC-SR501, have an onboard setting and calibration
    adjustments on them. These adjustments are used to change the sensitivity range
    and triggering mode of the sensor. To use a PIR device without on-board calibration
    means we would need to handle sensitivity adjustments ourselves in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In regard to the HC-SR501, its terminals are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GND**: Connection to ground.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vcc**: Connection to a power source between 5 volts and 20 volts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data**: Digital output that we connect to a GPIO pin. When the PIR detects
    movement, this pin goes `HIGH`; otherwise, it remains `LOW` in the absence of
    movement. The HC-SR501 outputs a 3.3-volt signal, even though it requires a 5-
    to 20-volt power source. As we will see next, the onboard *sensitivity adjust*, *timing
    adjust* trims, and *trigger mode* jumper influence how, when, and for how long
    this data pin remains `HIGH` when movement is detected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The HC-SR501 onboard settings are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sensitivity Adjust**: Changes the effective movement sensing range between
    about 3 meters to about 7 meters. Use a small screwdriver to rotate this setting''s
    dial.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time Delay Adjust**: How long the data terminal remains `HIGH` after movement
    is detected. The adjustment range is approximately 5 seconds to 300 seconds. Use
    a small screwdriver to rotate this setting''s dial.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trigger Mode Jumper**: In the presence of continued movement detection, this
    jumper setting means that after the time delay expires (as set by **Time Delay
    Adjust**), the data terminal will do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remain `HIGH`. This is the *repeatable* trigger setting, set by placing the
    jumper into the **H** position.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revert to `LOW`. This is the *single-shot* setting, set by placing the jumper
    into the **L** position.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best settings for your PIR will depend on how you intend to use it and the
    environment in which you deploy your sensor. My suggestion is to play around with
    the setting adjustments after you complete the circuit build and run the example
    code in the subsequent sections to get a feel for how changing the settings affects
    the operation of the sensor. Remember to consult the HC-SR501 datasheet for more
    information on the sensor and its onboard settings.
  prefs: []
  type: TYPE_NORMAL
- en: Let's wire up our PIR sensor and connect it to our Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the PIR sensor circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will connect our PIR sensor to our Raspberry Pi. The following
    is the schematic diagram of the circuit we are about to build. As you can see,
    it has relatively straightforward wiring from the perspective of the PIR sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a71c4b1a-0925-4a7a-871b-16feb2158fa8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – PIR sensor module circuit
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s connect it to our Raspberry Pi as illustrated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2ed19997-c875-442a-97a5-377aac349c70.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – PIR sensor circuit breadboard layout
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to follow to create your breadboard build. The step numbers
    match the numbers in black circles in *Figure 11.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect each terminal of your PIR sensor to your breadboard. You will need three
    male-to-male jumper cables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a 5-volt pin on your Raspberry Pi to the same breadboard row used by
    the PIR's Vcc terminal. PIR sensors only use a little current, so it will be okay
    to connect the 5-volt Vcc pin directly to your Raspberry Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a GND pin on your Raspberry Pi to the same breadboard row used by the
    PIR's GND terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect GPIO 21 on your Raspberry Pi to the same breadboard row used by the
    PIR's data terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**IMPORTANT**: Our reference HC-SR501 PIR sensor requires >4.5 volts for its
    power (Vcc), and outputs 3.3 volts on its Sig output pin. If you are using a different
    PIR sensor, then consult its datasheet and check the output pin voltage. If it
    is >3.3 volts, you will need to use a voltage divider or logic level shifter.
    We will cover this exact scenario in the next section when we couple a voltage
    divider with an HC-SR04 sensor to convert its 5-volt output into a Raspberry Pi-friendly
    3.3 volts.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have created your circuit, we will proceed and run our PIR example
    code, which will let us detect movement.
  prefs: []
  type: TYPE_NORMAL
- en: Running and exploring the PIR sensor code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code for out PIR circuit is found in the `chapter11/hc-sr501.py` file. Please
    review the source code before proceeding to get a broad understanding of what
    this file contains.
  prefs: []
  type: TYPE_NORMAL
- en: The HC-SR501 datasheet stipulates that the sensor needs around 1 minute after
    power-on to initialize and stabilize itself. If you try and use the sensor before
    it becomes stable, you may receive a few erroneous triggers when you start the
    program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `hc-sr501.py` file in a terminal. When the HC-SR501 detects movement,
    the program will print `Triggered` on the terminal, or `Not Triggered` when no
    movement is detected, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If your program is not responding as expected, try adjusting one or more of
    the **Sensitivity Adjustment**, **Time Delay Adjustment**, or **Trigger Mode Jumper**
    settings that we discussed earlier in the section titled *Detecting movement with
    a PIR sensor*.
  prefs: []
  type: TYPE_NORMAL
- en: You can consider the HC-SR501 as a basic switch. It's either on (`HIGH`) or
    off (`LOW`), just like a common push-button switch. In fact, our code is similar to
    the PiGPIO button example presented in the *Responding to a button press with
    PiGPIO* section back in [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml),* Getting
    Started with Python and IoT*. We'll just brush over the core code parts here;
    however, if you need a deeper explanation or a refresher, please revisit the PiGPIO
    sections in [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml), *Getting
    Started with Python and IoT.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss the example code. Firstly, we start on line 1 by setting up
    our GPIO pin as an input pin with pull-down enabled, while on line 2, we have
    debouncing enabled. Our HC-SR501 module won''t actually require the pull-down
    to be activated in code, nor will it require the debouncing; however, I''ve added
    it in for completeness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, on line 3, we define the `callback_handler()` function, which will get
    called whenever the GPIO pin changes its `HIGH`/`LOW` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, on line 4, we register our callback function. It''s the second parameter,
    `pigpio.EITHER_EDGE`, that causes `callback_handler()` to be called whenever GPIO
    changes to `HIGH` or `LOW`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For comparison, in [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml),
    *Getting Started with Python and IoT*, for our push-button example, this parameter
    was `pigpio.FALLING_EDGE`, meaning the callback only got called when the button
    was pressed, and not when it was released.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, a PIR sensor can only detect the proximity of an object – for
    example, is someone near our sensor? – but it cannot give us an indication of
    how far or near that object is.
  prefs: []
  type: TYPE_NORMAL
- en: We've now learned how to create and connect a simple PIR sensor circuit to our
    Raspberry Pi, and how to use it to detect movement in Python. Armed with this
    knowledge, you can now start building your own motion detection projects, such
    as turning things on and off when someone or some animal is detected, by combining
    the examples from [Chapter 7](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml), *Turning
    Things On and Off,* or as an important part of your own alarm and monitoring system.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at a sensor that is capable of estimating distance.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring distance with an ultrasonic sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to detect movement with a PIR sensor.
    As we discovered, our PIR sensor was a digital device that signaled movement detection
    by making its output a digital `HIGH`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to learn how to measure distance with our Raspberry Pi. There are
    a variety of sensors that are capable of performing this task, and they commonly
    either work with sound or light. Our example will be based around the popular HC-SR04
    ultrasonic distance sensor (it works on sound), as pictured in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dde3ee8c-3469-4a0d-824d-8b6fa7984f25.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – HC-SR04 ultrasonic distance sensor module
  prefs: []
  type: TYPE_NORMAL
- en: A place where you commonly find ultrasonic distance sensors is modern car bumper
    bars (they're often little round circles, which is a different form factor than
    the HC-SR04 pictured in the preceding figure). These sensors calculate the distance
    between your car and a nearby object and, for example, make a beeper inside your
    car beep faster and faster as you get closer and closer to the object
  prefs: []
  type: TYPE_NORMAL
- en: Another common application is for measuring liquid levels, such as in a water
    tank. In this scenario, a (waterproof) ultrasonic sensor measures the distance
    from, for example, the top of the tank to the water level (the sound pulse bounces
    off the water). The measured distance can then be translated into an estimate
    of how full the tank is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at our HC-SR04 sensor. The core specifications from
    the reference HC-SR04 datasheet are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Power voltage 5 volts (HC-SR04) or 3 volts to 5.5 volts (HC-SR04P)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logic voltage 5 volts (HC-SR04) or 3 volts to 5.5 volts (HC-SR04P)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working current 15 mA, resting current 2 mA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effective measurement range 2 cm–4 m, with an accuracy of +/- 0.3 cm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A trigger pulse width of 10 µs (10 microseconds). We'll revisit this pulse width
    and discuss it more in the section titled *HC-SR04 distance measurement process*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The SC-SR04 has two round cylinders. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**T** or **TX**: A transmitter that produces ultrasonic sound pulses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**R** or **RX**: A receiver that detects ultrasonic sound pulses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss how the transmitter and receiver pair work to measure distance
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HC-SR04 has four terminals, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vcc**: The power source (a Raspberry Pi 5-volt pin will be okay given the
    max current of 15 mA).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GND**: Connection to ground.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TRIG**: Trigger *input* terminal – when `HIGH`, the sensor sends out ultrasonic
    pulses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ECHO**: Echo *output* terminal – this pin goes `HIGH` when `TRIG` is made
    `HIGH`, then transitions to `LOW` when it detects an ultrasonic pulse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss the use of the `TRIG` and `ECHO` terminals in the section titled *HC-SR04
    distance measurement process.*
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the basic use of an ultrasonic distance sensor and the
    basic properties and layout of the HC-SR04, let's discuss how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How an ultrasonic distance sensor works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see how the transmitter (TX) and receiver (RX) work together to measure
    distance. The basic operating principle of an ultrasonic sensor is illustrated
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/04fb297a-ba3e-4828-bef7-85587791b615.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Ultrasonic distance sensor operation
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the sensor sends out an ultrasonic pulse from the transmitter (TX).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is an object in front of the sensor, this pulse is bounced off the
    object and returns to the sensor, and is detected by the receiver (RX).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By measuring the time between transmitting a pulse and receiving it back, we
    can calculate the distance between the sensor and the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this high-level understanding of how the sensor works, next, we will go
    deeper and discuss how to use the TRIG and ECHO terminals on the HC-SR04 together
    in a process to estimate distance.
  prefs: []
  type: TYPE_NORMAL
- en: HC-SR04 distance measurement process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will cover the process used to measure distance with the
    HC-SR04\. Don't get concerned if this does not make immediately sense. I've provided
    the details here as background material, as this is the logical process that is
    implemented by our example program to make the sensor work. You will also find
    the process documented in the sensor's datasheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'We measure distance with the HC-SR04 through the correct use and monitoring
    of the TRIG and ECHO pins. The process looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Pull the TRIG pin `HIGH` for 10 microseconds. Pulling TRIG `HIGH` also makes
    the ECHO pin `HIGH`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start a timer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wait for either of the following to happen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ECHO to go `LOW`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 38 milliseconds to elapse (from the datasheet, this is the time for >4 meters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop the timer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If 38 milliseconds have passed, we conclude that there is no object in front
    of the sensor (at least within the effective range of 2 centimeters to 4 meters). Otherwise,
    we take the elapsed time divided by 2 (because we want the time interval between
    the sensor and the object, not the sensor to the object and back to the sensor),
    and then using basic physics, calculate the distance between the sensor and the
    object using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8e34f8a8-c9d8-4330-ad69-d2bd3f0a2338.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*d* is the distance in meters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*v* is the velocity in meters per second, for which we use the speed of sound,
    which is approximately 343 meters per second at 20°C (68°F).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*t* is the time in seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HC-SR04 will only estimate distance. There are several parameters that influence
    its accuracy. Firstly, as hinted previously, the speed of sound varies in accordance
    with temperature. Secondly, the sensor has a resolution of ± 0.3 cm. Furthermore,
    the size of the object being measured, the angle of the object relative to the
    sensor, and even the material it is made of can all impact the ECHO timing result
    and thus the calculated distance.
  prefs: []
  type: TYPE_NORMAL
- en: With this basic understanding of how to use the HC-SR04 to estimate distance,
    let's build our circuit to connect an HC-SR04 to our Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Building the HC-SR04 circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s time to build our HC-SR04 circuit. A schematic of our circuit is shown
    in the following figure. This wiring will be suitable for both an HC-SR04 or HC-SR04P
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/03adb9b5-5121-4443-b68d-1260bd41e2f0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – HC-SR04 (5-volt logic ECHO pin) circuit
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, the HC-SR04 module (or an HC-SR04P wired like this to a 5-volt
    source) is a 5-volt logic module, and hence you will notice the voltage divider
    in the circuit created by the two resistors to convert 5 volts into 3.3 volts.
    If you need a refresher on voltage dividers, we covered them in detail in [Chapter
    6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml),* Electronics 101 for the Software
    Engineer*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build this circuit on our breadboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d7c2f5d8-4f07-4387-a2d7-ac26fbce53f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – HC-SR04 circuit breadboard layout (part 1 of 2)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to follow to create the first part of your breadboard build.
    The step numbers match the numbers in black circles in *Figure 11.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: Place a 1kΩ resistor (R1) into your breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a 2kΩ resistor (R2) into your breadboard. A leg of this second resistor
    shares the same row as a leg of the first resistor. In the illustration, this
    can be seen in row 21 on the right-hand side bank.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the left-hand side and right-hand side negative power rails together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a GND pin on your Raspberry Pi to the negative rail of the left-hand
    side power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the second leg 2kΩ resistor (R2) to the negative rail of the right-hand
    side power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the GND terminal on your HC-SR04 sensor to the negative rail of the
    right-hand side power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Vcc terminal on your HC-SR04 sensor to the positive rail of the
    right-hand side power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the R1 and R2 resistors are connected as shown in the preceding figure
    – that is, R1 (1kΩ) is connected to the ECHO pin on the HC-SR04\. The voltage
    divider created by R1 and R2 shifts an ECHO pin `HIGH` of 5 volts into ~3.3 volts.
    If you installed the resistors back to front, the 5 volts get shifted to ~1.67
    volts, which is not enough to register a logic `HIGH` on your Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have laid out our basic components and performed a few preliminary
    wiring connections, let''s complete our build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e2285741-5fdb-4ed7-ad55-da4add757bc9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – HC-SR04 circuit breadboard layout (part 2 of 2)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to follow. The step numbers match the numbers in black circles
    in *Figure 11.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect GPIO 20 on your Raspberry Pi to the Trig terminal on your HC-SR04 sensor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect GPIO 21 on your Raspberry Pi to the junction of the 1kΩ (R1) and 2kΩ
    (R2) resistors. This connection is shown in the illustration at hole F21.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Echo terminal of your HC-SR04 sensor to the 1kΩ resistor (R1). This
    connection is shown at hole J17.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the positive terminal of a 5-volt power source to the positive rail
    of the right-hand side power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the negative terminal of a 5-volt power source to the negative rail
    of the right-hand side power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As mentioned, our circuit build will work with both the HC-SR04 and HC-SR04P
    modules. If you do have the HC-SR04P module, there is a simpler wiring option
    available to you that you may like to try on your own. Since the HC-SR04P will
    work at 3.3 volts, here is what you can do:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect Vcc to a 3.3-volt power source or a 3.3-volt pin on your Raspberry Pi.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect the ECHO terminal directly to GPIO 21.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GND still connects to GND, and TRIG still connects directly to GPIO 20.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since this configuration is powered at 3.3 volts, the logic output on the ECHO
    terminal is also 3.3 volts and is therefore safe to connect directly to a Raspberry
    Pi GPIO pin.
  prefs: []
  type: TYPE_NORMAL
- en: Great! Now that our circuit is complete, next we will run our example program
    and use the HC-SR04 to measure distance and learn about the code that makes this
    happen.
  prefs: []
  type: TYPE_NORMAL
- en: Running and exploring the HC-SR04 example code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example code for the HC-SR04 can be found in the `chapter11/hc-sr04.py` file.
    Please review the source code before proceeding to get a broad understanding of
    what this file contains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place a solid object in front of the HC-SR04 (about 10 cm) and run the code
    in a terminal. As you move the object nearer or further from the sensor, the distance
    printed in the terminal will change, as indicated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let's review the code.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we define the `TRIG_GPIO` and `ECHO_GPIO` pins on line 1, and the `VELOCITY`
    constant for the speed of sound at line 2\. We're using 343 meters per second.
  prefs: []
  type: TYPE_NORMAL
- en: Our code is using 343 m/s for the speed of sound, while the datasheet suggests
    the value 340 m/s. You will also find other HC-SR04 examples and libraries that
    use slightly different values. These differences are one reason why different
    code samples and libraries may produce slightly different readings for the same
    sensor-to-object distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'On line 3, we define `TIMEOUT_SECS = 0.1`. The value of `0.1` is a number greater
    than 38 milliseconds (from the datasheet). Any time greater than this and we conclude
    that there is no object in front of our HC-SR04 sensor and return the `SENSOR_TIMEOUT` value, rather
    than a distance in the `get_distance_cms()` function, which we will come to shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, starting on line 4, we find several variables used to help measure the
    timing of the sensor''s ultrasonic pulse and if we have a successful reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`echo_callback` will contain a GPIO callback reference for later clean-up purposes,
    while `tick_start` and `tick_end` hold the start and end timings used to calculate
    the elapsed time for an ultrasonic pulse-echo. The term `tick` is used to be consistent
    with PiGPIO timing functions, which we will come to shortly. `reading_success` is
    `True` only when we have a distance reading before `TIMEOUT_SECS` elapses.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `trigger()` function shown on line 5 to start our distance measurement.
    We simply apply the process set out in the datasheet on line 6 – that is, we make
    the TRIG pin `HIGH` for 10 μs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get_distance_cms()` function shown at line 7 is our primary function that
    kicks off the distance measurement process by making a call to `trigger()`, before
    waiting from line 8 until we have either a successful reading (that is, `reading_success
    = True`) or `TIMEOUT_SECS` elapses, in which case, we return `SENSOR_TIMEOUT`.
    While we are waiting, a callback handler named `echo_handler()` is monitoring
    the `ECHO_GPIO` pin in the background for a successful read. We will discuss `echo_handler()` later
    in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have a successful reading, our function continues. On line 9, we take
    the `tick_start` and `tick_end` variables (which will now have values set by the
    echo callback handler) and calculate the elapsed time. Remember, we''re dividing
    the elapsed time at line 9 by 2 because we want the timing from the sensor to
    the object, *not* the complete ultrasonic pulse round trip from the sensor to
    the object, back to the sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It is on line 10 where we apply the formula, *d* = *v* × *t*, which we discussed
    previously, to work out the distance between the sensor and an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we encounter the `echo_handler()` function on line 11, which monitors
    the `ECHO_GPIO` pin for changes in state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Applying the process set out in the datasheet, we are capturing the time between
    sending a pulse at line 12 when `ECHO_GPIO` goes `HIGH` and receiving it back
    on line 13 when `ECHO_GPIO` goes `LOW`. If we have detected `ECHO_GPIO` as `LOW`
    before the timeout (back on line 8), we set `reading_success = True` so that `get_distance_cms()` knows
    we have a valid reading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we register the `echo_handler()` callback with PiGPIO on line 14\.
    The `pigpio.EITHER_EDGE` parameter means we want this callback to be called whenever
    `ECHO_GPIO` transitions to either a `HIGH` or `LOW` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Well done! You've just wired up, tested, and learned how to use the HC-SR04
    sensor together with PiGPIO to estimate distances. The circuit and code examples
    you have just learned could be adapted and used to measure water tank levels,
    or even as collision detection for a robot (a very common application of an HC-SR04
    in amateur robotics), or in any other project you dream up where distance plays
    a part.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will briefly explore Hall-effect sensors and learn how they can be
    used to detect movement and relative distances.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting movement and distance with Hall-effect sensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our final practical example in this chapter will illustrate the use of a Hall-effect
    sensor. Hall-effect sensors are simple components that detect the presence (or
    absence) of a magnetic field. In contrast to a PIR or distance sensor, you can
    use a Hall-effect sensor together with a magnet to monitor small-range – and even
    very rapid – movements. For example, you could attach a small magnet to the shaft
    of a DC motor and use a Hall-effect sensor to determine the motor's revolutions
    per minute.
  prefs: []
  type: TYPE_NORMAL
- en: Another common application of a Hall-effect sensor is in mobile phones and tablets.
    Some phone and tables covers and cases have a small magnet in them. As you open
    or close the case, your device detects the presence or absence of this magnet
    with a Hall-effect sensor and automatically turns on or off the display for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hall-effect sensors come in three types, described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Non-latching switch types (digital)**: They output a digital state (that
    is, `HIGH` or `LOW`) in the presence of magnetism and the opposite digital state
    in its absence. Whether the signal is `HIGH` or `LOW` in the presence of magnetism
    all depends on the sensor and whether it''s active `LOW` or active `HIGH` (please
    refer to [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml), *Electronics
    101 for the Software Engineer*, if you need a refresher on the concepts of active
    `LOW` and active `HIGH`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Latching switch types (digital)**: They output (and latch to) `LOW` (or `HIGH`)
    when one pole (for example, south) of a magnet is detected, and return to `HIGH`
    (or `LOW`) (unlatch) when the alternative pole (for example, north) is detected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ratiometric types (analog)**: They output a varying voltage depending on
    how close they are to a magnetic field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some readers may be familiar with a component called a r*eed switch*, which
    is a magnetically controlled switch. At a glance, they seem similar in basic principle
    and operation to a non-latching Hall-effect sensor. Here are the important differences
    – unlike a classic reed switch, Hall-effect sensors are a solid-state device (no
    moving parts), they can be switched/triggered very, very rapidly (thousands of
    times a second), and they require an appropriate circuit to make them work.
  prefs: []
  type: TYPE_NORMAL
- en: Our examples will use the A3144 (non-latching digital switch) and AH3503 (analog
    ratiometric) Hall-effect sensors. These specific parts have been chosen due to
    their availability and low cost; however, the general principles we will discuss
    will also be applicable to other Hall-effect sensors.
  prefs: []
  type: TYPE_NORMAL
- en: 'A picture of an A3144 Hall-effect sensor and common schematic symbols are shown
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6c43f66c-4239-47e0-8db7-0a951ebdb90e.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – Hall-effect sensor and symbols
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that the far-right symbol has four protruding outputs because
    some Hall-effect sensors do have four legs. You can expect the outputs of this
    symbol to be annotated in a schematic diagram appropriate for the sensor it refers
    to. We will be sticking to the three-legged type sensor and the corresponding
    three outputs symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The legs of our components are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vcc**: 5-volt source power.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GND**: Ground connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Out**: 5-volt signal output. Note that the A3144 is active `LOW`, meaning
    that in the presence of a magnetic field, the **Out** leg becomes `LOW`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Out** leg will behave differently depending on the type of Hall-effect
    sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Latching and non-latching switching types**: The **Out** leg will output
    either digital `LOW` or a digital `HIGH`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ratiometric type**: The output will be a varying voltage (that is, an analog
    output*). *Note that the range of varying voltage will not be the full range between
    0 to 5 volts, but more likely a range of only a few hundredths of a volt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand the leg configurations of a Hall-effect sensor, let's
    build our circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Hall-effect sensor circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be building the following circuit on our breadboards. Similar to our
    HC-SR04 example and circuit in *Figure 11.5*, we need to use a voltage divider
    since our Hall-effect sensor outputs 5-volt logic, which we need to shift down
    to 3.3 volts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/209e5779-2f47-45e4-a894-cd29d7db6ce6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – Hall-effect sensor circuit
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that the output of this circuit is dualistic and will depend
    on which sensor you are using:'
  prefs: []
  type: TYPE_NORMAL
- en: For a *non-latching switch* or *latching switch* type Hall-effect sensor, you
    will connect the circuit directly to GPIO 21 since the sensor will output a digital
    `HIGH`/`LOW` signal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a *ratiometric* type Hall-effect sensor, you will need to connect the sensor
    to your Raspberry Pi via your ADS1115 analog-to-digital converter since the sensor
    outputs a varying analog voltage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I have not included the ADS1115 wiring in *Figure 11.9* or in the following
    stepped breadboard layouts. We have already seen how to connect an analog output
    to our Raspberry Pi using the ADS1115 in previous chapters – refer to [Chapter
    5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting Your Raspberry Pi
    to the Physical World*, and/or [Chapter 9](a77d6d94-a71a-4d7e-a66f-7c552af5b051.xhtml),
    *Measuring Temperature, Humidity, and Light Levels*, for example circuits and
    code using the ADS1115.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s construct this circuit on our breadboard. This layout is for a *switching-type* Hall-effect
    sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c0b6ae7e-1802-49ff-b1a3-9b1cff719d69.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – Hall-effect sensor circuit breadboard layout
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to follow to complete your breadboard build. The step numbers
    match the numbers in black circles in *Figure 11.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: Place your A3144 Hall-effect sensor into your breadboard, paying careful attention
    to its orientation regarding its legs. Please refer to *Figure 11.8* if you need
    help identifying the component's legs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a 1kΩ resistor (R1) into your breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a 2kΩ resistor (R2) into your breadboard. A leg of this second resistor
    shares the same row as a leg of the first resistor. In the illustration, this
    can be seen in row 17 on the left-hand side bank.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a 5-volt pin from your Raspberry Pi to the positive rail of the left-hand
    side power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a GND pin from your Raspberry Pi to the negative rail of the left-hand
    side power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Hall-effect sensor's Vcc leg to the positive power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Hall-effect sensor's GND leg to the negative power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Hall-effect sensor's Out leg to the 1kΩ resistor (R1). In the illustration,
    this is shown at hole E13.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the junction of the 1kΩ (R1) and 2kΩ (R2) resistors to GPIO 21 on your
    Raspberry Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the left of the 2kΩ resistor (R2) to the negative power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To use the AH3503 ratiometric type Hall-effect sensor at *step 1* in this circuit,
    the wire at *step 9* will instead need to be connected to an input port (for example,
    A0) of an ADS1115 module.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have built our Hall-effect sensor circuit, get a magnet ready, as
    we're ready to run our example code and see how a magnet triggers the sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Running and exploring the Hall-effect sensor code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will find the code for Hall-effect sensors in the `chapter11/hall_effect_digital.py` file
    for switch and latching switch type Hall-effect sensors and the `chapter11/hall_effect_analog.py` file
    for ratiometric type Hall-effect sensors.
  prefs: []
  type: TYPE_NORMAL
- en: 'What you will find when you review these two files is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`chapter11/hall_effect_digital.py` is functionally identical to the PIR code
    example we covered previously in this chapter in the section titled *Running and
    exploring the PIR sensor code*. Both the PIR and non-latching/latching Hall-effect
    sensors are digital switches. The only difference is that our reference Hall-effect
    sensor is *active* `LOW`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chapter11/hall_effect_analog.py` is similar to other analog-to-digital examples
    we have seen using the ADS1115 ACD, including the circuit wiring and code from
    [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting Your Raspberry
    Pi to the Physical World.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The varying voltage range outputted by the AH3503 ratiometic Hall-effect sensor
    and measured by your ADC via the voltage divider is likely to be in the range
    of a few hundred millivolts.
  prefs: []
  type: TYPE_NORMAL
- en: As you run the example code, move a magnet past your Hall-effect sensor. The
    magnet will need to be close to the casing of the sensor; however, it will not
    need to physically touch the sensor. How *close* will all depend on the strength
    of your magnet.
  prefs: []
  type: TYPE_NORMAL
- en: If you cannot get your circuit and code to work, try rotating your magnet to
    reverse the north/south pole that passes past the sensor. Also note that for a
    *latching* type Hall-effect sensor, it is common for one pole of the magnet to *latch*
    (trigger) the sensor, while the opposite pole will *unlatch* (un-trigger) the
    sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the code similarities, we won't cover the code again here. However, I
    would like to say that at this point in the book, you now have both the digital
    and analog base circuits and code available for you to connect up and use any
    simple analog or digital component. As noted already in this chapter, just be
    wary of the voltages and currents needed to power the component, and especially
    what the output voltage is, because if it is more than 3.3 volts, you will need
    to use a voltage divider or level-shifter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at ways to detect movement and estimate distance
    with our Raspberry Pi. We learned how to use a PIR sensor to detect broad movements,
    and how a switch-type Hall-effect sensor can be used to detect the movement of
    a magnetic field. We also discovered how to use an ultrasonic range sensor to
    estimate absolute distance on a larger scale, and how to use a ratiometric-type
    Hall-effect sensor to measure relative distances on a small scale.
  prefs: []
  type: TYPE_NORMAL
- en: All our circuits and examples in this chapter have been *input* focused – telling
    our Raspberry Pi that some event has occurred, such as the detection of a person
    moving or that a distance is being measured.
  prefs: []
  type: TYPE_NORMAL
- en: You are in a great position now to combine input circuits such as those covered
    in this chapter (and also in [Chapter 9](a77d6d94-a71a-4d7e-a66f-7c552af5b051.xhtml), *Measuring
    Temperature, Humidity, and Light Levels*), with output-based circuits and examples
    from [Chapter 7](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml), *Turning Things
    On and Off*, [Chapter 8](d37dafc4-afc7-460c-b200-c2b6e19d0083.xhtml), *Lights,
    Indicators, and Displaying Information*, and [Chapter 10](8b0b4483-ccde-4a92-896b-039eb94d911a.xhtml),
    *Movement with Servos, Motors, and Steppers*, to create end-to-end projects that
    can both control and measure the environment!
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget about what we learned in [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml), *Getting
    Started with Python and IoT*, [Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml),
    *Networking with RESTful APIs and Web Sockets Using Flask,* and [Chapter 4](6947b564-6182-4ec9-998a-37f636c0bce6.xhtml),
    *Networking with MQTT, Python, and the Mosquitto MQTT Broker*. These three chapters
    provide you with the foundations for creating web interfaces and integration to
    external systems that can control and monitor the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the electronic and code examples presented so far in this book have
    evolved around a single sensor or actuator. In the next chapter, we will explore
    several Python-based design patterns that are useful when building more complex
    automation and IoT projects that involve multiple sensors and/or actuators that
    need to communicate with one another.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    of this chapter''s material. You will find the answers in the *Assessments* section
    of the book:'
  prefs: []
  type: TYPE_NORMAL
- en: Can a PIR sensor detect the direction that an object is moving?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some factors that can affect the measurement accuracy of an ultrasonic
    distance sensor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the output of a latching or non-latching Hall-effect sensor differ
    from the output of a ratiometric Hall-effect sensor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In relation to this PiGPIO function call, `callback = pi.callback(GPIO, pigpio.EITHER_EDGE,
    callback_handler)`, what does the `pigpio.EITHER_EDGE` parameter mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a 5-volt to 3.3-volt resistor-based voltage divider consisting of a 1k Ω
    and 2k Ω resistor, why is important to connect the two resistor values the correct
    way around in a circuit?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both the HC-SR04 ultrasonic distance sensor and the HC-SR501 PIR sensor were
    powered using 5 volts connected to their respective Vcc pins. Why did we use a
    voltage divider with the HC-SR04 to drop the output from 5 volts to 3.3 volts,
    but not with the HC-SR501?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
