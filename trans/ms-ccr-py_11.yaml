- en: Building Communication Channels with asyncio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Communication channels are a big part of applied concurrency in the field of
    computer science. In this chapter, we will cover the fundamental theories of transports,
    which are classes provided by the `asyncio` module in order to abstract various
    forms of communication channels. We will also cover an implementation of a simple
    echoing server-client logic in Python, in order to further illustrate the use
    of `asyncio` and concurrency in communication systems. The code for this example
    will serve as the foundation for an advanced example that will appear later in
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The fundamentals of communication channels and applying asynchronous programming
    to them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build an asynchronous server in Python by using `asyncio` and `aiohttp`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make requests to multiple servers asynchronously and handle asynchronous
    file reading and writing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a list of prerequisites for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that you have Python 3 installed on your computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that you have Telnet installed on your computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that you have the Python module `aiohttp` installed with your Python
    3 distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the GitHub repository at [https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will be working with the subfolder named `Chapter11`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out the following video to see the Code in Action: [http://bit.ly/2FMwKL8](http://bit.ly/2FMwKL8)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ecosystem of communication channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Communication channels are used to denote both the physical wiring connection
    between different systems and the logical communication of data that facilitates
    computer networks. In this chapter, we will only be concerned with the latter,
    as it is a problem that is related to computing and is more germane to the idea
    of asynchronous programming. In this section, we will be discussing the general
    structure of a communication channel, and two specific elements in that structure
    that are particularly relevant to asynchronous programming.
  prefs: []
  type: TYPE_NORMAL
- en: Communication protocol layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most data transmission processes that are done through communication channels
    are facilitated in the form of the **Open Systems Interconnection** (**OSI**)
    model protocol layers. The OSI model lays out the major layers and topics in an
    intersystem communication process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the general structure of an OSI model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8ddd0769-bc8d-4cf0-95ab-05baf817c9aa.png)'
  prefs: []
  type: TYPE_IMG
- en: OSI model structure
  prefs: []
  type: TYPE_NORMAL
- en: As indicated in the preceding diagram, there are seven main layers of communication
    in a data transmission process, with varying degrees of computing level. We will
    not be going into the details of the purposes and specific functions of each layer,
    but it is still important that you understand the general ideas behind the media
    and host layers.
  prefs: []
  type: TYPE_NORMAL
- en: The three bottom layers contain fairly low-level operations that interact with
    the underlying process of the communication channel. The operations in the physical
    and data link layers include coding schemes, access schemes, low-level error detection
    and correction, bit synchronization, and so on. These operations are used to implement
    and specify the logic of processing and preparing data before transferring it.
    The network layer, on the other hand, handles forwarding packets of data from
    one system (for example, the server) to another (for example, the client) in a
    computer network, via determining the address of the recipient and which path
    of data transfer to take.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the top layers deal with high-level data communication and
    manipulation. Among these layers, we will be focusing on the transport layer,
    as it is directly utilized by the `asyncio` module in implementing communication
    channels. This layer is often viewed as the conceptual transition between the
    media layers and the host layers (for example, the client and the server), responsible
    for sending data along end-to-end connections between different systems. Additionally,
    because packets of data (prepared by the network layer) might be lost or corrupted
    during transmission processes due to network errors, the transport layer is also
    in charge of detecting these errors via methods in error detection code.
  prefs: []
  type: TYPE_NORMAL
- en: The other host layers implement mechanisms for handling, interpreting, and providing
    the data sent from another system. After receiving data from the transport layer,
    the session layer handles the authentication, authorization, and session restoration
    processes. The presentation layer then translates the same data and reorganizes
    it into an interpretable representation. Finally, the application layer displays
    that data in user-friendly formats.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming for communication channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given the nature of asynchronous programming, it is no surprise that the programming
    model can provide functionalities that complement the process of facilitating
    communication channels efficiently. Using the topic of HTTP communication as an
    example, the server can asynchronously handle multiple clients at the same time;
    while it is waiting for a specific client to make an HTTP request, it can switch
    to another client and process that client''s request. Similarly, if a client needs
    to make HTTP requests to multiple servers, and has to wait for large responses
    from some servers, it can process the more lightweight responses, which have already
    been processed and were sent back to the client first. The following diagram shows
    an example of how servers and clients interact with each other asynchronously
    in HTTP requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d3a27a5c-2ea2-4165-ad7b-83439d70ec22.png)'
  prefs: []
  type: TYPE_IMG
- en: Asynchronous, interleaved HTTP requests
  prefs: []
  type: TYPE_NORMAL
- en: Transports and protocols in asyncio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `asyncio` module provides a number of different transport classes. In essence,
    these classes are the implementations of the functionalities of the transport
    layer that were discussed in the preceding section. You already know that the
    transport layer plays an integral role in communication channels; the transport
    classes, therefore, give `asyncio` (and consequently, the developers) more control
    over the process of implementing our own communication channels.
  prefs: []
  type: TYPE_NORMAL
- en: The `asyncio` module combines the abstract of transports with the implementation
    of an asynchronous program. Specifically, even though transports are the central
    elements of communication channels, in order to utilize the transport classes
    and other relevant communication channel tools, we need to initiate and call an
    event loop, which is an instance of the `asyncio.AbstractEventLoop` class. The
    event loop itself will then create the transports and manage the low-level communication
    procedures.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that a `transport` object in an established communication
    channel in `asyncio` is always associated with an instance of the `asyncio.Protocol`
    class. As the name suggests, the `Protocol` class specifies the underlying protocols
    that the communication channels use; for each connection made with another system,
    a new protocol object from this class will be created. While working closely with
    a `transport` object, a protocol object can call various methods from the `transport`
    object; this is the point where we can implement the specific inner workings of
    a communication channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, generally we need to focus on the implementation of an `asyncio.Protocol` subclass
    and its methods while building a connection channel. In other words, we use `asyncio.Protocol` as
    a parent class to derive a subclass that meets the needs of our communication
    channel. To do this, we overwrite the following methods from the `asyncio.Protocol`
    base class in our own custom protocol subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Protocol.connection_made(transport)`: This method is automatically called
    whenever a connection from another system is made. The `transport` argument holds
    the `transport` object that is associated with the connection. Again, each `transport`
    needs to be paired with a protocol; we generally store this `transport` object
    as an attribute of this specific protocol object in the `connection_made()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Protocol.data_received(data)`: This method is automatically called whenever
    the one system that we are connected to sends its data. Note that the `data` argument,
    which holds the sent information, is usually represented in bytes, so the `encode()`
    function of Python should be used before `data` is processed further.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let us consider the important methods from the transport classes from
    `asyncio`. All transport classes inherit from a parent transport class, called
    `asyncio.BaseTransport`, for which we have the following common methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BaseTransport.get_extra_info()`: This method returns, as the name suggests,
    additional channel-specific information for the calling `transport` object. The
    result can include information regarding the socket, the pipe, and the subprocess
    associated with that transport. Later in this chapter, we will be calling `BaseTransport.get_extra_info(''peername'')`,
    in order to obtain the remote address from which the transport traveled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BaseTransport.close()`: This method is used to close the calling `transport`
    object, after which the connections between different systems will be stopped.
    The corresponding protocol of the transport will automatically call its `connection_lost()`
    method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out of the many implementations of transport classes, we will focus on the `asyncio.WriteTransport`
    class, which again inherits the methods from the `BaseTransport` class, and additionally
    implements other methods that are used to facilitate write-only transport functionalities.
    Here, we will be using the `WriteTransport.write()` method, which will write the
    data that we would like to send to the other system that we communicate with via
    the `transport` object. As a part of the `asyncio` module, this method is not
    a blocking function; instead, it buffers and sends out the written data in an
    asynchronous way.
  prefs: []
  type: TYPE_NORMAL
- en: The big picture of asyncio's server client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have learned that asynchronous programming, and `asyncio` specifically,
    can drastically improve the execution of your communication channels. You have
    also seen the specific methods that you will need to use when implementing an
    asynchronous communication channel. Before we dive into a working example in Python,
    let us briefly discuss the big picture of what we are trying to accomplish – or,
    in other words, the general structure of our program.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, we need to implement a subclass of `asyncio.Protocol`
    to specify the underlying organization of our communication channel. Again, there
    is an event loop at the heart of each asynchronous program, so we also need to
    create a server outside of the context of the protocol class, and initiate that
    server inside of the event loop of our program. This process will set up the asynchronous
    architecture of our entire server, and can be done via the `asyncio.create_server()`
    method, which we will look at in our upcoming example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will run the event loop of our asynchronous program forever by
    using the `AbstractEventLoop.run_forever()` method. Similar to an actual, real-life
    server, we would like to keep our sever running until it encounters a problem,
    in which case we will close the server gracefully. The following diagram illustrates
    this whole process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5a5d7c16-ff13-4ee0-9eb3-9a55389b7bdb.png)'
  prefs: []
  type: TYPE_IMG
- en: Asynchronous program structure in communication channels
  prefs: []
  type: TYPE_NORMAL
- en: Python example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let us look at a specific Python example that implements a server that
    facilitates asynchronous communication. Download the code for this book from the
    GitHub page ([https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)),
    and navigate to the `Chapter11` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `Chapter11/example1.py` file, let''s look at the `EchoServerClientProtocol`
    class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, our `EchoServerClientProtocol` class is a subclass of `asyncio.Protocol`.
    As we discussed earlier, inside of this class, we need to implement the `connection_made(transport)`
    and `data_received(data)` methods. In the `connection_made()` method, we simply
    obtain the address of the connected system via the `get_extra_info()` method (with
    the `'peername'` argument), print a message out with that information, and finally
    store the `transport` object in an attribute of the class. In order to print out
    a similar message in the `data_received()` method, again we use the `decode()`
    method to obtain a string object from byte data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us move on to the main program of our script, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We are using the familiar `asyncio.get_event_loop()` function to create an event
    loop for our asynchronous program. Then, we create a server for our communication
    by having that event loop call the `create_server()` method; this method takes
    in a subclass from the `asyncio.Protocol` class, an address for our server (in
    this case, it is our local host: `127.0.0.1`), and finally, a port for that address
    (typically, `8888`).
  prefs: []
  type: TYPE_NORMAL
- en: Note that this method does not create the server itself; it only initiates the
    process of creating the server asynchronously, and returns a coroutine that will
    finish the process. For this reason, we need to store the returned coroutine from
    the method in a variable (`coro`, in our case) and have our event loop run that
    coroutine. After printing out a message using the `sockets` attribute of our server
    object, we will run the event loop forever, in order to keep the server running,
    except for the case of a `KeyboardInterrupt` exception being invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, at the end of our program, we will handle the house cleaning portion
    of the script, which is closing the server gracefully. This is typically done
    by having the server object call the `close()` method (to initiate the closing
    process of the server) and using the event loop to run the `wait_closed()` method on
    the server object, to make sure that the server is properly closed. Finally, we
    close the event loop.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Telnet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can run our sample Python program, we have to install the Telnet program,
    in order to correctly simulate a connection channel between a client and a server.
    Telnet is a program that provides Terminal commands that facilitate protocols
    for bidirectional, interactive, text-oriented communication. If you already have
    Telnet working on your computer, simply skip to the next section; otherwise, find
    the information appropriate to your system in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Windows systems, Telnet is already installed, but might not be enabled.
    To enable it, you can either utilize the Turn Windows features on or off window
    and make sure that the Telnet Client box is checked, or run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Linux systems typically come with Telnet preinstalled, so if you own a Linux
    system, simply move on to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In macOS systems, it is possible that Telnet has already been installed on
    your computer. If not, you will need to do it via the package management software
    Homebrew, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that macOS systems do have a preinstalled alternative to Telnet, called
    Netcat. If you do not want Telnet installed on your macOS computer, simply use
    the `nc` command instead of `telnet` in the following examples, and you will achieve
    the same effect.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating a connection channel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are multiple steps to running the following server example. First, we
    need to run the script to start the server, from which you will obtain the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the program will run until you invoke the *Ctrl* + *C* key combination.
    With the program still running in one Terminal (this is our server Terminal),
    open another Terminal and connect to the server (`127.0.0.1`) at the specified
    port (`8888`); this will server as our client Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you will see some changes in both the server and the client Terminals.
    Most likely, your client Terminal will have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is from the interface of the Telnet program, which indicates that we have
    successfully connected to our local server. The more interesting output is on
    our server Terminal, and it will be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Recall that this is an information message that we implemented in our `EchoServerClientProtocol`
    class—specifically in the `connection_made()` method. Again, as a connection between
    the server and a new client is made, this method will be called automatically,
    in order to initiate the communication. From the output message, we know that
    the client is making their requests from port `60332` of server `127.0.0.1` (which
    is the same as the running server, since they are both local).
  prefs: []
  type: TYPE_NORMAL
- en: Another feature that we implemented in the `EchoServerClientProtocol` class
    was in the `data_received()` method. Specifically, we print the decoded data that
    is sent from the client. To simulate this type of communication, simply type a
    message in your client Terminal and press the *Return* (*Enter,* for Windows)
    key. You will not see any changes in the client Terminal output, but the server
    Terminal should print out a message, as specified in the `data_received()` method
    of our protocol class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following is my server Terminal output when I send the message
    `Hello, World!` from my client Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `\r` and `\n` characters are simply the return characters included in the
    message string. With our current protocol, you can send multiple messages to the
    server, and can even have multiple clients send messages to the server. To implement
    this, simply open another Terminal and connect to the local server again. You
    will see from your server Terminal that a different client (from a different port)
    has made a connection to the server, while the original communication of our server
    with the old client is still being maintained. This is another result achieved
    from asynchronous programming, allowing multiple clients to communicate with the
    same server seamlessly, without using threading or multiprocessing.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages back to clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, in our current example, we are able to have our asynchronous server receive,
    read, and process messages from clients. However, in order for our communication
    channel to be useful, we would also like to send messages from the server to the
    clients. In this section, we will update our server to an echo server, which,
    by definition, will send any and all data that it receives from a specific client
    back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we will be using the `write()` method from the `asyncio.WriteTransport`
    class. Examine the `Chapter11/example2.py` file, in the `data_received()` method
    of the `EchoServerClientProtocol` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After receiving the data from the `transport` object and printing it out, we
    write a corresponding message to the `transport` object, which will go back to
    the original client. By running the `Chapter11/example2.py` script and simulating
    the same communication that we implemented in the last example with Telnet or
    Netcat, you will see that after typing a message in the client Terminal, the client
    receives an echoed message from the server. The following is my output after initiating
    the communication channel and typing in the `Hello, World!` message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In essence, this example illustrates the capability of a bidirectional communication
    channel that we can implement through a custom `asyncio.Protocol` class. While
    running a server, we can obtain data sent from various clients connected to the
    server, process the data, and finally send the desired result back to the appropriate
    clients.
  prefs: []
  type: TYPE_NORMAL
- en: Closing the transports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Occasionally, we will want to forcefully close a transport in a communication
    channel. For example, even with asynchronous programming and other forms of concurrency,
    it is possible for your server to be overwhelmed with constant communications
    from multiple clients. On the other hand, it is undesirable to have the server
    completely handle some of the sent requests and plainly reject the rest of the
    requests as soon as the server is at its maximum capacity.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, instead of keeping the communication open for each and every client connected
    to the server, we can specify in our protocol that each connection should be closed
    after a successful communication. We will do this by using the `BaseTransport.close()`
    method to forcefully close the calling `transport` object, which will stop the
    connection between the server and that specific client. Again, we are modifying
    the `data_received()` method of the `EchoServerClientProtocol` class in `Chapter11/example3.py`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script, try to connect to the specified server, and type in some messages,
    in order to see the changes that we implemented. With our current setup, after
    a client connects and sends a message to the server, it will receive an echoed
    message back, and its connection with the server will be closed. The following
    is the output (again, from the interface of the Telnet program) that I obtained
    after simulating this process with our current implementation of the protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Client-side communication with aiohttp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous sections, we covered examples of implementing asynchronous communication
    channels with the `asyncio` module, mostly from the perspective of the server
    side of the communication process. In other words, we have been considering handling
    and processing requests sent from external systems. This, however, is only one
    side of the equation, and we also have the client side of communication to explore.
    In this section, we will discuss applying asynchronous programming to make requests
    to servers.
  prefs: []
  type: TYPE_NORMAL
- en: As you have most likely guessed, the end goal of this process is to efficiently
    collect data from external systems by asynchronously making requests to those
    systems. We will be revisiting the concept of web scraping, which is the process
    of automating HTTP requests to various websites and extracting specific information
    from their HTML source code. If you have not read [Chapter 5](39ccf044-7fef-4716-acae-a8024f15d67a.xhtml),
    *Concurrent Web Requests*, I highly recommend going through it before proceeding
    with this section, as that chapter covers the foundational ideas of web scraping,
    and other relevant, important concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you will also be introduced to another module that supports
    asynchronous programming options: `aiohttp` (which stands for **Asynchronous I/O
    HTTP**). This module provides high-level functionalities that streamline HTTP
    communication procedures, and it also works seamlessly with the `asyncio` module,
    in order to facilitate asynchronous programming.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing aiohttp and aiofiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `aiohttp` module does not come preinstalled with your Python distribution;
    however, similarly to other packages, you can easily install the module by using
    the `pip` or `conda` commands. We will also be installing another module, `aiofiles`,
    which facilitates asynchronous file-writing. If you use `pip` as your package
    manager, simply run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''d like to use Anaconda, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As always, to confirm that you have successfully installed a package, open
    your Python interpreter and try to import the module. In this case, run the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There will be no error messages if the package has been successfully installed.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching a website's HTML code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s look at how to make a request and obtain the HTML source code
    from a single website with `aiohttp`. Note that even with only one task (a website),
    our application remains asynchronous, and the structure of an asynchronous program
    still needs to be implemented. Now, navigate to the `Chapter11/example4.py` file,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let's consider the `main()` coroutine first. We are initiating an instance from
    the `aiohttp.ClientSession` class within a context manager; note that we are also
    placing the `async` keyword in front of this declaration, since the whole context
    block itself will also be treated as a coroutine. Inside of this block, we are
    calling and waiting for the `get_html()` coroutine to process and return.
  prefs: []
  type: TYPE_NORMAL
- en: Turning our attention to the `get_html()` coroutine, we can see that it takes
    in a session object and a URL for the website that we want to extract the HTML
    source code from. Inside of this function, we make another context manager asynchronous,
    which is used to make a `GET` request and store the response from the server to
    the `res` variable. Finally, we return the HTML source code stored in the response;
    since the response is an object returned from the `aiohttp.ClientSession` class,
    its methods are asynchronous functions, and therefore we need to specify the `await`
    keyword when we call the `text()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you run the program, the entire HTML source code of Packt''s website will
    be printed out. For example, the following is a portion of my output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a5fb1256-d1a8-42fd-981b-6fe29204e1e1.png)'
  prefs: []
  type: TYPE_IMG
- en: HTML source code from aiohttp
  prefs: []
  type: TYPE_NORMAL
- en: Writing files asynchronously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time, we would like to collect data by making requests to multiple
    websites, and simply printing out the response HTML code is inappropriate (for
    many reasons); instead, we'd like to write the returned HTML code to output files.
    In essence, this process is asynchronous downloading, which is also implemented
    in the underlying architecture of popular download managers. To do this, we will
    use the `aiofiles` module, in combination with `aiohttp` and `asyncio`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the `Chapter11/example5.py` file. First, we will look at the `download_html()`
    coroutine, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is an updated version of the `get_html()` coroutine from the last example.
    Instead of using an `aiohttp.ClientSession` instance to make a `GET` request and
    print out the returned HTML code, now we write the HTML code to the file using
    the `aiofiles` module. For example, to facilitate asynchronous file writing, we
    use the asynchronous `open()` function from `aiofiles` to read in a file in a
    context manager. Furthermore, we read the returned HTML in chunks, asynchronously,
    using the `read()` function for the `content` attribute of the response object;
    this means that after reading `1024` bytes of the current response, the execution
    flow will be released back to the event loop, and the task-switching event will
    take place.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main()` coroutine and the main program of this example remain relatively
    the same as those in our last example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main()` coroutine takes in a URL and passes it to the `download_html()`
    coroutine, along with an `aiohttp.ClientSession` instance. Finally, in our main
    program, we create an event loop and pass each item in a specified list of URLs
    to the `main()` coroutine. After running the program, your output should look
    similar to the following, although the time it takes to run the program might
    vary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, a subfolder named `output` (inside of the `Chapter11` folder)
    will be filled with the downloaded HTML code from each website in our list of
    URLs. Again, these files were created and written asynchronously, via the functionalities
    of the `aiofiles` module, which we discussed earlier. As you can see, to compare
    the speed of this program and its corresponding synchronous version, we are also
    keeping track of the time it takes to run the entire program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, head to the `Chapter11/example6.py` file. This script contains the code
    of the synchronous version of our current program. Specifically, it makes HTTP
    `GET` requests to individual websites in order, and the process of file writing
    is also implemented sequentially. This script produced the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: While it achieved the same results (downloading the HTML code and writing it
    to files), our sequential program took significantly more time than its asynchronous
    counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are seven main layers of communication in a data transmission process,
    with varying degrees of computing level. The media layers contain fairly low-level
    operations that interact with the underlying process of the communication channel,
    while the host layers deals with high-level data communication and manipulation.
    Of the seven, the transport layer is often viewed as the conceptual transition
    between the media layers and the host layers, responsible for sending data along
    end-to-end connections between different systems. Asynchronous programming can
    provide functionalities that complement the process of efficiently facilitating
    communication channels.
  prefs: []
  type: TYPE_NORMAL
- en: Server-wise, the `asyncio` module combines the abstract of transports with the
    implementation of an asynchronous program. Specifically, via its `BaseTransport`
    and `BaseProtocol` classes, `asyncio` provides different ways to customize the
    underlying architecture of a communication channel. Together with the `aiohttp`
    module, `asyncio` offers efficiency and flexibility regarding client-side communication
    processes. The `aiofiles` module, which can work in conjunction with the other
    two asynchronous programming modules, can also help to facilitate asynchronous
    file reading and writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now explored three of the biggest, most important topics in concurrent
    programming: threading, multiprocessing, and asynchronous programming. We have
    shown how each of them can be applied to various programming problems and provide
    significant improvements in speed. In the next chapter of this book, we will start
    to discuss problems that concurrent programming commonly poses to developers and
    programmers, starting with deadlocks.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a communication channel? What is its connection to asynchronous programming?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the two main parts of the OSI model protocol layers? What purposes
    do each of them serve?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the transport layer? Why is it crucial to communication channels?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does `asyncio` facilitate the implementation of server-side communication
    channels?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does `asyncio` facilitate the implementation of client-side communication
    channels?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is `aiofiles`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*IoT Systems and Communication Channels* ([bridgera.com/iot-communication-channels/](https://bridgera.com/iot-communication-channels/)),
    by Bridgera'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Automate the boring stuff with Python: practical programming for total beginners*, No
    Starch Press, Al. Sweigart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Transports and protocols* ([docs.python.org/3/library/asyncio-protocol](https://docs.python.org/3/library/asyncio-protocol.html)), Python
    documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
