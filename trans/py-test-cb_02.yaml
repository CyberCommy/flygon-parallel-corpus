- en: Running Automated Test Suites with Nose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting nosy with testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding nose inside Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a nose extension to pick tests based on regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a nose extension to generate a CSV report
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a project-level script that lets you run different test suites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at several ways to utilize unittest in creating
    automated tests. Now, we will look at different ways to gather tests together
    and run them. Nose is a useful utility that was built to discover tests and run
    them. It is flexible, can be run from either the command-line or embedded inside
    scripts, and is extensible through plugin. Due to its embeddable nature and high-level
    tools, such as project scripts, it can be built with testing as an option.
  prefs: []
  type: TYPE_NORMAL
- en: What does nose offer that unittest does not? Key things include automatic test
    discovery and a useful plugin API. There are many nose plugins that provide everything
    from specially formatted test reports to integration with other tools. We will
    explore this in more detail in this chapter and in later parts of this book.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about nose refer to: [http://somethingaboutorange.com/mrl/projects/nose](http://somethingaboutorange.com/mrl/projects/nose).
  prefs: []
  type: TYPE_NORMAL
- en: We need to activate our virtual environment and then install nose for the recipes
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a virtual environment, activate it, and verify that the tools are working:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, use `pip install nose`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Getting nosy with testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nose automatically discovers tests when fed with a package, a module, or a file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the following steps, we will explore how nose automatically finds test
    cases and runs them:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `recipe11.py` to store all the code for this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a class to test. For this recipe, we will use a shopping cart application
    that lets us load items and then calculate the bill:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a test case that exercises the various parts of the shopping cart application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the command-line `nosetests` tool to run this recipe by filename and also
    by module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started off by creating a simple application that lets us load up a `ShoppingCart`
    with `Items`. This application lets us look up each item and its price. Finally,
    we can calculate the total billing amount including the sales tax.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we coded some test methods to exercise all these features using unittest.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we used the command-line `nosetests` tool, which discovers test cases
    and automatically runs them. This saved us from hand coding a test runner to load
    test suites.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Why is it so important to not write the test runner? What do we gain by using
    `nosetests`? After all, unittest gives us the ability to embed an auto-discovering
    test runner like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Would the same block of code work if the tests are spread across several modules?
    No, because `unittest.main()` only looks in the current module. To grow into multiple
    modules, we need to start loading tests using unittest's `loadTestsFromTestCase`
    method or other customized suites. It doesn't matter how we assemble suites. When
    we risk missing test cases, `nosetests` conveniently lets us search for all tests,
    or a subset of tests if needed.
  prefs: []
  type: TYPE_NORMAL
- en: A common situation on projects is to spread out test cases between lots of modules.
    Instead of writing one big test case, we typically break things up into smaller
    test cases based on various setups, scenarios, and other logical groupings. It's
    a common practice to split up test cases based on which module is being tested.
    The point is that manually loading all the test cases for a real-world test suite
    can become labor-intensive.
  prefs: []
  type: TYPE_NORMAL
- en: Nose is extensible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Auto-discovery of tests isn't the only reason to use nose. Later in this chapter,
    we will explore how we can write a plugin to customize what it discovers and also
    the output of a test run.
  prefs: []
  type: TYPE_NORMAL
- en: Nose is embeddable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the functionality nose provides can be utilized either by the command-line,
    or from inside a Python script. We will also explore this further in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Asserting **the **basics* recipe in [Chapter 1](part0025.html#NQU20-dd965cfd3480473da68e719fadb0727c), *Using
    Unittest to Develop Basic Tests*.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding nose inside Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's very convenient to embed nose inside a Python script. This lets us create
    higher-level test tools besides allowing the developer to add testing to an existing
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With these steps, we will explore using nose''s API inside a Python script
    to run some tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `recipe12.py` to contain the code from this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a class to test. For this recipe, we will use a shopping cart application
    that lets us load items and then calculate the bill:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a test case with several test methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Create a script named `recipe12_nose.py` to use nose's API to run tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the script runnable and use nose''s `run()` method to run selected arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test script from the command line and see the verbose output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the test running code, we are using `nose.run()`. With no arguments, it simply
    picks up on `sys.argv` and acts like the command-line `nosetests`. But in this
    recipe, we are plugging in the name of the current module along with increased
    verbosity.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unittest has `unittest.main()`, which discovers and runs test cases as well.
    How is this different? `unittest.main()` is geared to discover test cases in the
    same module where it is run. The `nose.run()` function is geared to let us pass
    in command-line arguments or load them programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, look at the following steps; we must complete them to turn up
    verbosity with unittest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We had to import the test cases, use a test loader to create a test suite, and
    then run it through `TextTestRunner`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do the same thing with nose, this is all we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is much more succinct. Any command-line options we could use with `nosetests` can be
    used here. This comes in handy when we use the the nose plugin, which we will
    explore in more detail in this chapter and throughout the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a nose extension to pick tests based on regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Out-of-the-box test tools such as nose are very useful. But eventually, we reach
    a point where the options don't match our needs. Nose has the powerful ability
    to code custom plugins, and this gives us the ability to fine-tune nose to meet
    our needs. This recipe will help us write a plugin that allows us to selectively
    choose test methods by matching their method names using a regular expression
    when we run `nosetests`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to have `easy_install` loaded in order to install the nose plugin that
    we are about to create. If you don't already have it, please visit [http://pypi.python.org/pypi/setuptools](http://pypi.python.org/pypi/setuptools)
    to download and install the package as indicated at the site.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have just installed it now, then you will have to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Rebuild your `virtualenv` used for running code samples in this book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reinstall `nose` using `pip`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the following steps, we will code a nose plugin that picks test methods
    to run by using a regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `recipe13.py` to store the code for this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a shopping cart application that we can build some tests around:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a test case that contains several test methods, including one that does
    not start with the word `test`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Run the module using `nosetests` from the command line, with `verbosity` turned
    on. How many test methods get run? How many test methods did we define?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Create a new file called `recipe13_plugin.py` to write a nose plugin for this
    recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Capture a handle to `sys.stderr` to support debugging and verbose output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a nose plugin named `RegexPicker` by subclassing `nose.plugins.Plugin`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Our nose plugin requires a class-level name. This is used to define the `with-<name>`
    command-line option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Override `Plugin.options` and add an option to provide the pattern on the command
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Override `Plugin.configuration` by having it fetch the pattern and verbosity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When we extend `Plugin`, we inherit some other features, such as `self.enabled`,
    which is switched on when `-with-<name>` is used with nose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Override `Plugin.wantedMethod` so that it accepts test methods that match our
    regular expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a test runner that programmatically tests our plugin by running the same
    test case that we ran earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Execute the test runner. Looking at the results in the following screenshot,
    how many test methods ran this time?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a `setup.py` script that allows us to install and register our plugin
    with `nosetests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Install our new plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Run `nosetests` using `--with-regexpicker` from the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing a nose plugin has some requirements. First of all, we need the class-level
    `name` attribute. It is used in several places, including defining the command-line
    switch to invoke our plugin, `--with-<name>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we write `options`. There is no requirement to override `Plugin.options`,
    but in this case we need a way to supply our plugin with the regular expression.
    To avoid destroying the useful machinery of `Plugin.options`, we call it first,
    and then add a line for our extra parameter using `parser.add_option`:'
  prefs: []
  type: TYPE_NORMAL
- en: The first, unnamed arguments are string versions of the parameter, and we can
    specify multiple ones. We could have had `-rp` and `-re-pattern` if we had wanted
    to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dest`: This is the name of the attribute that stores the results (see configure).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Action`: This specifies what to do with the value of the parameter (store,
    append, and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Default`: This specifies what value to store when none are provided (notice
    we use `test.*` to match standard unittest behavior).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Help`: This provides help info to print out on the command line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nose uses Python's `optparse.OptionParser` library to define options.
  prefs: []
  type: TYPE_NORMAL
- en: To find out more about Python's `optparse.OptionParser`, please refer to [http://docs.python.org/library/optparse.html](http://docs.python.org/library/optparse.html).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we write `configure`. There is also no requirement to override `Plugin.configure`.
    Because we had an extra option, `--pattern`, we need to harvest it. We also want
    to turn on a flag driven by `verbosity`, a standard nose option.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many things we can do when writing a nose plugin. In our case, we
    wanted to zero in on **test ****selection**. There are several ways to load tests,
    including by module, and filename. After loading, they are then run through a
    method where they are voted in or out. These voters are called `want*` methods
    and they include `wantModule`, `wantName`, `wantFunction`, and `wantMethod`, as
    well some others. We implemented `wantMethod` where we test `method.func_name`
    matches our pattern using Python''s `re` module. `want*` methods have three return
    value types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`True`: This test is wanted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`False`: This test is not wanted (and will not be considered by another plugin).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`None`: The plugin does not care whether another plugin (or nose) gets to choose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is succinctly achieved by not returning anything from the `want*` method.
  prefs: []
  type: TYPE_NORMAL
- en: '`wantMethod` only looks at functions defined inside classes. `nosetests` is
    geared to find tests by many different methods and is not confined to just searching
    subclasses of `unittest.TestCase`. If tests are found in the module, but not as
    class methods, then this pattern matching is not utilized. For this plugin to
    be more robust, we would need lot of different tests and probably need to override
    the other `want*` test selectors.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe just scratches the surface on plugin functionality. It focuses on
    the test selection process.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will explore generating a specialized report. This
    involves using other plugin hooks that gather information after each test is run
    as well as generating a report after the test suite is exhausted. Nose provides
    a robust set of hooks allowing detailed customization to meet our changing needs.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins should subclass `nose.plugins.Plugin`.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot of valuable machinery built into `Plugin`. Subclassing is the
    recommended means of developing a plugin. If you don't so this, you may have to
    add on methods and attributes you didn't realize were needed by nose (and that
    come for free when you subclass).
  prefs: []
  type: TYPE_NORMAL
- en: It's a good rule of thumb to subclass the parts of the nose API that we are
    plugging into instead of overriding.
  prefs: []
  type: TYPE_NORMAL
- en: The online documentation for the nose API is a little incomplete. It tends to
    assume too much knowledge. If we override and our plugin doesn't work correctly,
    it may be difficult to debug what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: Do not subclass `nose.plugins.IPluginInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: This class is used for documentation purposes only. It provides information
    about each of the hooks our plugin can access. But it is not designed for subclassing
    real plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a nose extension to generate a CSV report
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will help us write a plugin that generates a custom report listing
    successes and failures in a CSV file. It is used to demonstrate how to gather
    information after each test method completes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to have `easy_install` loaded in order to install the nose plugin we
    are about to create. If you don't already have it, please visit [http://pypi.python.org/pypi/setuptools](http://pypi.python.org/pypi/setuptools)
    to download and install the package as indicated on the site.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have just installed it now, then you will have to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Rebuild your `virtualenv` used for running code samples in this book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reinstall nose using `easy_install`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new file named `recipe14.py` to store the code for this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a shopping cart application that we can build some tests around:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a test case that contains several test methods, including one deliberately
    set to fail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Run the module using `nosetests` from the command line. Looking at the output
    in the following screenshot, does it appear that a CSV report exists?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Create a new file called `recipe14_plugin.py` to store our new nose plugin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a nose plugin named `CsvReport` by subclassing `nose.plugins.Plugin`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Our nose plugin requires a class-level `name`. This is used to define the `-with-<name>`
    command-line option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Override `Plugin.options` and add an option to provide the report''s filename
    on the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Override `Plugin.configuration` by having it fetch the filename from options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When we extend `Plugin`, we inherit some other features, such as `self.enabled`,
    which is switched on when `-with-<name>` is used with nose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Override `addSuccess`, `addFailure`, and `addError` to collect the results
    in an internal list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Override `finalize` to generate the CSV report:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a test runner that programmatically tests our plugin by running the same
    test case that we ran earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Execute the test runner. Looking at the output in the next screenshot, is there
    a test report now?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open up and view the report using your favorite spreadsheet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a `setup.py` script that allows us to install and register our plugin
    with `nosetests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Install our new plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Run `nosetests` using `--with-csv-report` from the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous screenshot, notice how we have the previous log file, `recipe14.csv`,
    and the new one, `log.csv`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing a nose plugin has some requirements. First of all, we need the class-level
    `name` attribute. It is used in several places including defining the command-line
    switch to invoke our plugin, `--with-<name>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we write `options`. There is no requirement to override `Plugin.options`.
    But in this case, we need a way to supply our plugin with the name of the CSV
    report it will write. To avoid destroying the useful machinery of `Plugin.options`,
    we call it first, and then add a line for our extra parameter using `parser.add_option`:'
  prefs: []
  type: TYPE_NORMAL
- en: The first, unnamed arguments are string versions of the parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dest`: This is the name of the attribute that stores the results (see configure)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`action`: This tells what to do with the value of the parameter (store, append,
    and so on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default`: This tells what value to store when none is provided'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`help`: This provides help info to print out on the command line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nose uses Python's `optparse.OptionParser` library to define options.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about `optparse.OptionParser`, visit [http://docs.python.org/optparse.html](http://docs.python.org/optparse.html).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we write `configure`. There is also no requirement to override `Plugin.configure`.
    Because we had an extra option, `--csv-file`, we need to harvest it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we want to capture the test case and the error report whenever
    a test method completes. To do this, we implement `addSuccess`, `addFailure`,
    and `addError`, because nose varies in what arguments are sent to these methods
    when called either programmatically or by the command-line, so we must use Python''s
    `*args`:'
  prefs: []
  type: TYPE_NORMAL
- en: The first slot of this tuple contains the `test`, an instance of `nose.case.Test`.
    Simply printing it is sufficient for our needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second slot of this tuple contains the `error`, an instance of the 3-tuple
    for `sys.exc_info()`. It is only included for `addFailure` and `addError`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No more slots of this tuple are documented on nose's website. We generally ignore
    them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe digs a little deeper into the plugin's functionality. It focuses
    on processing done after a test method succeeds, fails, or causes an error. In
    our case, we just gather the results to put into a report. We could do other things,
    such as capture stack traces, send email failures to the development team, or
    send a page to the QA team letting them know a test suite is complete.
  prefs: []
  type: TYPE_NORMAL
- en: For more details about writing a nose plugin, read the *Writing **a **nose **extension* recipe to
    pick tests based on regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a project-level script that lets you run different test suites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python, with its multi-paradigm nature, makes it easy to build applications
    and provide scripting support.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will help us explore building a project-level script that allows
    us to run different test suites. We will also show some extra command-line options
    to create hooks for packaging, publishing, registering, and writing automated
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a script called `recipe15.py` that parses a set of options using Python''s
    `getopt` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function that maps to `-test`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create stub functions that support `package`, `publish`, and `register`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function to auto-generate docs using Python''s `pydoc` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some code that defines debug levels and then parses options to allow the
    user to override:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some code that scans the command-line options for `-help` and, if it''s
    found, exits the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finish it by iterating through each of the command-line options and invoking
    the other functions based on which options are picked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `recipe15.py` script with `-help`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Create a new file called `recipe15_checkin.py` to create a new test suite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Reuse the test cases from the *Getting **nosy **with **testing* recipe to define
    a `check``in` test suite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Run the `recipe15.py` script, using `-test -package -publish -register -pydoc`.
    In the following screenshot, do you notice how it exercises each option in the
    same sequence as it was supplied on the command line?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Inspect the report generated in the `pydoc` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Create a new file named `recipe15_all.py` to define another new test suite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Reuse the test code from the earlier recipes of this chapter to define an `all`
    test suite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `recipe15.py` script with `-suite=recipe15_all`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This script uses Python''s `getopt` library, which is modeled after the C programming
    language''s `getopt()` function. This means we use the API to define a set of
    commands, and then we iterate over the options, calling the corresponding functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Visit [http://docs.python.org/library/getopt.html](http://docs.python.org/library/getopt.html)
    for more details on the `getopt` library.
  prefs: []
  type: TYPE_NORMAL
- en: '`usage`: This is a function that provides help to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`key`: The option definitions are included in the following block:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We parse everything in the arguments except the first, as this is the executable
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"ht"` defines short options: `-h` and `-t`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list defines long options. Those with `"="` accept an argument. Those without
    it are flags.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an option is received that isn't on the list, an exception is thrown; we
    print out `usage()` and then exit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Test`: This activates loggers, which can be very useful if our app uses Python''s
    `logging` library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Package`: This generates tarballs. We created a stub, but it can be handy
    to provide a shortcut by running `setup.py sdist|bdist`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Publish`: Its function is to push tarballs to the deployment site. We created
    a stub, but deploying it to an S3 site or somewhere else is useful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Register`: This is the register with PyPI. We created a stub, but it would
    be handy to provide a shortcut to running `setup.py register`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create_pydocs`: These are auto-generated docs. Generating HTML files based
    on code is very convenient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With each of these functions defined, we can iterate over the options that
    were parsed. For this script, there is a sequence as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether there is a debugging override. We default to `logging.INFO`, but
    provide the ability to switch to `logging.DEBUG`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether `-h` or `-help` was called. If so, print out the `usage()` information
    and then exit with no more parsing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, iterate over the options and call their corresponding functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To exercise things, we first called this script with the `-help` option. That
    printed out the command choices we had.
  prefs: []
  type: TYPE_NORMAL
- en: Then we called it with all the options to demonstrate the features. The script
    is coded to exercise a `check in` suite when we use `-test`. This short test suite
    simulates running a quicker test that's designed to see whether things look alright.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we called the script with `-suite=recipe15_all`. This test suite simulates
    running a more complete test suite that typically takes longer.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The features this script provides could easily be handled by commands that are
    already built. We looked at `nosetests` earlier in this chapter and saw how it
    can flexibly take arguments to pick tests.
  prefs: []
  type: TYPE_NORMAL
- en: Using `setup.py` to generate tarballs and register releases is also a commonly
    used feature in the Python community.
  prefs: []
  type: TYPE_NORMAL
- en: So, why write this script? Because we can tap all these features with a single
    command script, `setup.py` contains a prebuilt set of commands that involve bundling
    and uploading to the Python Project Index. Doing other tasks, such as generating
    **pydocs**, deploying to a location such as an Amazon S3 bucket, or any other
    system-level task, is not included. This script demonstrates how easy it is to
    wire in other command-line options and link them with the project management functions.
  prefs: []
  type: TYPE_NORMAL
- en: We can also conveniently embed the usage of `pydoc`. Basically, any Python library
    that serves project management needs can be embedded as well.
  prefs: []
  type: TYPE_NORMAL
- en: On an existing project, I developed a script to provide a unified way to embed
    version info into a templated `setup.py` as well as documentation generated by
    `pydoc`, `sphinx`, and `DocBook`. The script saved me from having to remember
    all the commands needed to manage the project.
  prefs: []
  type: TYPE_NORMAL
- en: Why didn't I extend `distutils` to create my own commands? It was a matter of
    taste. I preferred using `getopt` and working outside the framework of `distutils`
    instead of creating and registering new sub-commands.
  prefs: []
  type: TYPE_NORMAL
- en: Why use getopt instead of optparse?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has several options for handling command-line option parsing. `getopt`
    is possibly the simplest. It is meant to quickly allow defining short and long
    options, but it has limits. It requires custom coding help output, as we did with
    the usage function.
  prefs: []
  type: TYPE_NORMAL
- en: It also requires custom handling of the arguments. `optparse` provides more
    sophisticated options, such as better handling of arguments and auto-built help.
    But it also requires more code to get functional. `optparse` is also scheduled
    to be replaced by `argparse` in the future.
  prefs: []
  type: TYPE_NORMAL
- en: It is left as an exercise for you to write an alternative version of this script
    using `optparse`, to assess which one is a better solution.
  prefs: []
  type: TYPE_NORMAL
