- en: Advanced IoT Programming Concepts - Threads, AsyncIO, and Event Loops
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to detect movement with a PIR sensor,
    as well as measure distances and detect movement with ultrasonic sensors and Hall-effect
    sensors.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss alternative ways of *structuring* our Python
    programs when we are working with electronic sensors (input devices) and actuators
    (output devices). We will cover the classic event-loop approach to programming,
    before moving on to more advanced approaches, including the use of threads in
    Python, the publisher/subscriber model, and finally, asynchronous I/O programming
    with Python.
  prefs: []
  type: TYPE_NORMAL
- en: I guarantee you that there are many, many blog posts and tutorials across the
    internet covering these topics; however, what we will cover in this chapter will
    be uniquely focused on practical electronic interfacing. Our approach in this
    chapter will involve creating a simple circuit with a push-button, a potentiometer,
    and two LEDs that we will make flash at different rates, and presenting four different
    coding approaches to make the circuit work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Building and testing our circuit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring an event-loop approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring a threaded approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring a publisher-subscriber alternative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring an AsyncIO approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To perform the exercises in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi 4 Model B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raspbian OS Buster (with desktop and recommended software)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum Python version 3.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These requirements are what the code examples in this book are based on. It's
    reasonable to expect that the code examples should work without modification on
    Raspberry Pi 3 Model B or a different version of Raspbian OS as long as your Python
    version is 3.5 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: You will find this chapter's source code in the `chapter12` folder in the GitHub
    repository available at [https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to execute the following commands in a terminal to set up a virtual
    environment and install the Python libraries required for the code in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following dependencies are installed from `requirements.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PiGPIO**: The PiGPIO GPIO library ([https://pypi.org/project/pigpio](https://pypi.org/project/pigpio))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ADS1X15**: The ADS1x15 ADC library ([https://pypi.org/project/adafruit-circuitpython-ads1x15](https://pypi.org/project/adafruit-circuitpython-ads1x15))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PyPubSub**: In-process messaging and events ([https://pypi.org/project/PyPubSub](https://pypi.org/project/PyPubSub))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The electronic components we will need for this chapter''s exercises are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 2 x red LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 x 200 Ω resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x push-button switch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x ADS1115 module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x 10k Ω potentiometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To maximize your learning in this chapter, there are some assumptions made
    regarding pre-existing knowledge and experience:'
  prefs: []
  type: TYPE_NORMAL
- en: From an electronic interfacing perspective, I will assume that you have read the
    preceding 11 chapters of this book and are comfortable working with the PiGPIO
    and ADS1115 Python libraries featured throughout this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From a programming perspective, I am assuming existing knowledge of **Object-Oriented
    Programming** (**OOP**) techniques and how they are implemented in Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Familiarity with the concepts *event-loop*, *threads,* *publisher-subscriber,* and
    *synchronous versus asynchronous* paradigms will also be advantageous.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any of the preceding topics are unfamiliar, you will find many online tutorials
    available covering these topics in great detail. Please see the *Further reading*
    section at the end of the chapter for suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: Building and testing our circuit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m going to present the circuit and programs for this chapter in the form
    of a practical exercise. Let''s pretend for a moment that we have been asked to
    design and build a *gizmo* that has the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: It has two LEDs that blink.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A potentiometer is used to adjust the rate that the LED(s) blink.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the program starts, both LEDs will blink at the same rate determined by
    the position of the potentiometer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A blinking rate of 0 seconds means an LED is off, while the maximum blinking
    rate of 5 seconds means an LED is on for 5 seconds, then off for 5 seconds, before
    repeating the cycle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A push-button is used to select which LED changes its blinking rate when the
    potentiometer is adjusted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the push-button is pressed and held for 0.5 seconds, all LEDs synchronize
    to the same rate, determined by the potentiometer's position.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideally, the program code should easily scale to support more LEDs with minimal
    coding effort.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a scenario illustrating the gizmo''s use:'
  prefs: []
  type: TYPE_NORMAL
- en: After applying power (and the program starts), all LEDs start to blink at a
    rate of 2.5 seconds because the potentiometer's dial is at the midpoint (50%)
    of its rotation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user adjusts the potentiometer to make the *first* LED blink at a rate of
    4 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, the user briefly presses and releases the push-button so that the potentiometer
    will change the *second* LED's blinking rate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the user adjusts the potentiometer so that the *second* LED blinks at a
    rate of 0.5 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the user presses and holds the button down for 0.5 seconds to make
    both the *first* and *second* LED blink in unison at a rate of 0.5 seconds (the
    rate set by the potentiometer at *step 4*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now for the challenge I mentioned – before we get into this chapter's circuit
    and code, I challenge you to stop reading now and try to create a circuit and
    write a program that implements the preceding requirements.
  prefs: []
  type: TYPE_NORMAL
- en: You will find a short video demonstrating these requirements at [https://youtu.be/seKkF61OE8U](https://youtu.be/seKkF61OE8U).
  prefs: []
  type: TYPE_NORMAL
- en: I anticipate that you will encounter challenges and have questions about the
    best approach to take. There is no one best approach; however, by having your
    own implementation – whether it works or not – you will have something to compare and
    contrast with the four solutions that I will present during this chapter. I'm
    confident that if you have a go yourself first, then you will gain a deeper understanding
    and more insight. Hey, perhaps you'll create an even better solution!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need suggestions to help get you started, here they are:'
  prefs: []
  type: TYPE_NORMAL
- en: We first covered LEDs and push-buttons in [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml),
    *Getting Started with Python and IoT*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We first covered potentiometers and analog input using an ADS1115 module in [Chapter
    5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting Your Raspberry Pi
    to the Physical World*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you are ready, we will look at a circuit that fulfills the aforementioned
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Building the reference circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Figure 12.1* is a circuit that meets the requirements we just listed. It
    has a push-button, a potentiometer in the form of a voltage divider connected
    to an ADS1115 analog-to-digital converter, and two LEDs connected by current limiting
    resistors. Adding additional LEDs will be as simple as wiring more LED and resistors
    pairs between GND and a free GPIO pin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1ce6b28c-49d3-4bae-bfce-ee96b13a20ab.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Reference circuit schematic
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have not already created a similar circuit on your own, we will create
    this circuit now on your breadboard. We will build this circuit in three parts.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e0af2da2-7c85-476e-97eb-25ad65088378.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Reference circuit (part 1 of 3)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to follow to create the first part of our breadboard build
    where we place the components. The step numbers match the numbers in black circles
    in *Figure 12.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: Place the ADS1115 module into your breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the potentiometer into your breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place an LED into your breadboard, taking care to orientate the LED's legs as
    illustrated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a second LED into your breadboard, taking care to orientate the LED's
    legs as illustrated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a 200Ω resistor (R1) into your breadboard. One end of this resistor shares
    the same row as the anode leg of the LED placed in *step 3*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place another 200Ω resistor (R2) into your breadboard. One end of this resistor
    shares the same row as the anode leg of the second LED you placed in *step 5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the push-button into your breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have placed the components into the breadboard, let''s start wiring
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/332b67b8-0242-43a3-a206-485f0325e118.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Reference circuit (part 2 of 3)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to follow to continue with the second part of our breadboard
    build. The step numbers match the numbers in black circles in *Figure 12.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect a 3.3-volt pin from your Raspberry Pi to the positive rail of the left-hand
    side power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Vdd terminal of the ADS1115 to the positive rail of the left-hand
    side power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the GND terminal of the ADS1115 to the negative rail of the left-hand
    side power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the SCL terminal of the ADS1115 to the SCL pin on your Raspberry Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the SDA terminal of the ADS1115 to the SDA pin on your Raspberry Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a GND pin on your Raspberry Pi to the negative rail of the left-hand
    side power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect an outer terminal of the potentiometer to the positive rail of the left-hand
    side power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect another outer terminal of the potentiometer to the negative rail of
    the left-hand side power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the center terminal of the potentiometer to port A0 of the ADS1115.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you recall that the potentiometer in this configuration is creating a variable
    voltage divider? If not, you may want to revisit [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml),
    *Electronics 101 for the Software Engineer*. Furthermore, if you would like a
    detailed refresher on the ADS1115 module, please refer to [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml),
    *Connecting your Raspberry Pi to the Physical World*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue with our build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2c48c450-5450-4f1e-b387-70c8aaf5848a.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Reference circuit (part 3 of 3)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to follow to continue with the final part of our breadboard
    build. The step numbers match the numbers in black circles in *Figure 12.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect GPIO 26 from your Raspberry Pi to the 200 Ω resistor (R1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect GPIO 19 from your Raspberry Pi to the second 200 Ω resistor (R2).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect GPIO 21 from your Raspberry Pi to one leg of the push-button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the two cathode legs of the LEDs together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the cathode legs of the LEDs to the negative rail of the left-hand side
    power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the second leg of the push-button to the negative rail of the left-hand
    side power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have finished our circuit build, we are ready to run the sample
    code to make the circuit work.
  prefs: []
  type: TYPE_NORMAL
- en: Running the examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter comes with four different versions of code that can work with
    the circuit shown previously in *Figure 12.1.* You will find the code in the `chapter12`
    folder organized by version:'
  prefs: []
  type: TYPE_NORMAL
- en: '`chapter12/version1_eventloop` is an *event-loop*-based example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chapter12/version2_thread` is a *thread and callback*-based example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chapter12/version3_pubsub` is a *publisher-subscriber-*based example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chapter12/version4_asyncio` is an**Asynchronous IO** *(***AsyncIO***)*-based
    example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All versions are functionally equivalent; however, they differ in their code
    structure and design. We will discuss each version in greater detail after we
    test our circuit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to follow to run each version (starting with version 1)
    and test the circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: Change to the `version1_eventloop` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Briefly look over the `main.py` source file, and any additional Python files
    in the folder, to get a feel for what they contain and how the program is structured.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `main.py` in a terminal (remember to switch into the chapter's virtual environment
    first).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, if you receive errors regarding I2C or ADS11x5, remember that
    there is the i2cdetect tool, which can be used to confirm that an I2C device such
    as the ADS1115 is correctly connected and visible to your Raspberry Pi. Refer
    to [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting Your Raspberry
    Pi to the Physical World*, for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Turn the potentiometer dial and observe the *first* LED's blinking rate changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the button briefly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn the potentiometer dial and observe the *second* LED's blinking rate changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press and hold the button for 0.5 seconds, and observe that both LEDs now blink
    in unison at the same rate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is an example of the terminal output you will receive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Press *Ctrl *+ *C* in your terminal to exit the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *steps 1* through *8* for `version2_threads`, `version3_pubsub`, and
    `version4_asyncio`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have just tested and glanced at the source code of four different programs
    (perhaps five, if you challenged yourself to create your own) that all achieve
    exactly the same end result but in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to understand how these programs are built. Let's begin with the
    *event-loop* version of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the event-loop approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start our code exploration by discussing an event-loop-based approach
    to building the sample gizmo that we just tested in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: The code for the event-loop-based approach can be found in the `chapter12/version1_eventloop`
    folder. You will find one file named `main.py`. Please take the time now to stop
    and read through the code contained in `main.py` to get a basic understanding
    of how the program is structured and how it works. Alternatively, you could add
    breakpoints or insert `print()` statements into the code and run it again to understand
    how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How did it go, and what did you notice? If you thought *yuck* or got lost in
    the web of loops, `if` statements, and state variables, then well done! This means
    you have invested the time to consider this approach and how the code is constructed.
  prefs: []
  type: TYPE_NORMAL
- en: 'What I mean by an event-loop approach is demonstrated in the code by the `while
    True:` loop abbreviated on line 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Granted, I could have used functions and even external classes to reduce the
    quantity (and possibly enhance the readability) of the code within the `while`
    loop, however, the overall design paradigm remains the same – the body of the
    program control is sitting in a perpetual loop.
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with Arduino programming, you will be intimately familiar
    with this approach to programming. That's why I titled this section *event-loop*
    due to the similarity of approach and the popularity of the term. Notwithstanding,
    note that the term *event-loop* has a wider context within Python, as we will
    see when we look at the AsyncIO (version 4) of our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have realized that this event-loop approach to programming has been
    used by many of the examples throughout this book. Three examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When we wanted a timed event such as blinking an LED ([Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml),
    *Getting Started with Python and IoT*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polling the DHT 11 or DHT 22 temperature/humidity sensor ([Chapter 9](a77d6d94-a71a-4d7e-a66f-7c552af5b051.xhtml),
    *Measuring Temperature, Humidity, and Light Levels*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polling the ADS1115 analog-to-digital converter connected to a **Light-Dependent-Resistor**
    (**LDR**) (also [Chapter 9](a77d6d94-a71a-4d7e-a66f-7c552af5b051.xhtml), *Measuring
    Temperature, Humidity, and Light Levels*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this context, for a single focused example, event-loops make sense. They
    even make sense purely for convenience when you're hacking about and trying out
    new ideas and learning about a new actuator or sensor. However, as demonstrated
    by our `version1_eventloop/main.py` program, as soon as you add in multiple components
    (such as a potentiometer, two LEDs, and a push-button) and want to make them work
    together for a definite purpose, the code gets complex fast.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider the following code on line 3, which is responsible for
    blinking all the LEDs, and remember that this block of code is evaluated once
    per loop iteration and is responsible for blinking every LED:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare this to a vanilla alternative (similar to what we will see in other
    approaches), which at a moment''s glance is significantly easier to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you also consider the following block of code, starting on line 2, which
    is responsible for detecting button presses, then you find nearly 40 lines of
    code (in the actual `main.py` file) just to detect what the button is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You will count multiple variables at play – `button_pressed`, `button_held`,
    `was_pressed`, and `button_hold_timer` – that are all evaluated at every `while`
    loop iteration and are there primarily to detect a *button-hold* event. I'm sure
    you can appreciate that writing and debugging this code like this can be tedious
    and error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: We could have used a `PiGPIO` *callback* to handle button presses outside of
    the `while` loop, or even a GPIO Zero `Button` class. Both approaches would help
    reduce the complexity of the button-handling logic. Likewise, maybe we could have
    mixed in a GPIO Zero `LED` class to handle the LED blinking. However, if we did,
    our example would not be a purely event-loop-based example.
  prefs: []
  type: TYPE_NORMAL
- en: Now, I'm not saying that event-loops are a bad or wrong approach. They have
    their uses, they are needed, and, in essence, we create one every time we use
    a `while` loop or another looping construct – so the base ideal is everywhere,
    but it's just not an ideal approach to building complex programs, because this
    approach makes them harder to understand, maintain, and debug.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you find that your program is heading down this event-loop path, stop
    and reflect, because it might be time to consider refactoring your code to employ
    a different – and more maintainable – approach, such as a threaded/callback approach,
    which we will look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a threaded approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have explored an event-loop-based approach to creating our program,
    let's consider an alternative approach built using threads, callbacks, and OOP
    and see how this approach improves code readability and maintainability and promotes
    code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the *threaded*-based approach can be found in the `chapter12/version2_threads`
    folder. You will find four files – the main program, `main.py`, and three class
    definitions: `LED.py`, `BUTTON.py`, and `POT.py`.'
  prefs: []
  type: TYPE_NORMAL
- en: Please take the time now to stop and read through the code contained in `main.py` to
    get a basic understanding of how the program is structured and how it works. Then,
    proceed to review `LED.py`, `BUTTON.py`, and `POT.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'How did it go, and what did you notice? I''d guess that you found this version
    of the program (while reading through `main.py`) much quicker and easier to understand
    and noticed that there is no cumbersome and complex `while` loop, but instead
    a `pause()` call, which is necessary to stop our program from exiting, as summarized on
    line 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this program example, we have employed object-oriented techniques and componentized
    our program using three classes:'
  prefs: []
  type: TYPE_NORMAL
- en: A button class (`BUTTON.py`), which takes care of all the button logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A potentiometer class (`POT.py`), which takes care of all the potentiometer
    and analog-to-digital conversion logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A LED class (`LED.py`), which is responsible for making a *single* LED flash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using an OOP approach, our `main.py` code is greatly simplified. Its role
    is now to create and initialize class instances and house the callback handlers
    and logic that make our program work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following OOP approach for our push-button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Compared to the button-handing code from the event-loop example, this is greatly
    simplified and much more readable – it's pretty explicit where and how this code
    is responding to the button pressed at line 1 and button holds on line 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the `BUTTON` class, which is defined in the `BUTTON.py` file.
    This class is an enhancing wrapper around a PiGPIO callback function that turns
    the `HIGH`/`LOW` states of the button''s GPIO pin into `PRESSED`, `RELEASED`,
    and `HOLD` events, as summarized in the following code at line 1 in `BUTTON.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Compared to the button-handling code of the event-loop example, we did not introduce
    and interrogate multiple state variables to detect the button-hold event, but
    instead, this logic is reduced to a simple and linear approach at line 2.
  prefs: []
  type: TYPE_NORMAL
- en: Next, as we consider the `POT` class (defined in `POT.py`) and `LED` class (defined
    in `LED.py`), we will see threads come into our program.
  prefs: []
  type: TYPE_NORMAL
- en: Did you know that even in a multi-threaded Python program, only one thread is
    active at a time? While it seems counter-intuitive, it was a design decision known
    as the **Global Interpreter Lock** (**GIL**) made back when the Python language
    was first created. If you want to learn more about the GIL and the many other
    forms of achieving concurrency with Python, you will find resources in the *Further
    reading* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the thread run method for the `POT` class, which can be found
    in the `POT.py` source file, and illustrates, starting on line 1, the approach
    of intermediately polling the ADS1115 ADC to determine the potentiometer''s position.
    We''ve seen this polling example several times already throughout this book, starting
    back in [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting Your
    Raspberry Pi to the Physical World*, where we first discussed analog-to-digital
    conversion, the ADS1115 module, and potentiometers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The difference with our code here is that we are monitoring the ADC for voltage
    changes on line 2 (for example, when a user turns the potentiometer), and turning
    them into a callback on line 3, which you will have seen handled in `main.py`
    when you reviewed the source code in that file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now discuss how we are implementing the `version2` LED-related code. As
    you are aware, the basic code pattern for blinking an LED on and off at a defined
    rate involves a `while` loop and a `sleep` statement. This is the approach taken
    in the LED class, as seen in the `run()` method on line 3 in `LED.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: I am sure you will agree that this is easier to understand than the approach
    taken by the event-loop approach we discussed in the previous section. It is important
    to remember, however, that the event-loop approach was working with and altering
    the blinking rate of *all* LEDs together in a *single* block of code, and within
    a *single* thread – the program's main thread.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the two sleep approaches shown in the preceding code. While the first
    approach using `sleep(self.blink_rate_secs)` is common and tempting, the caveat
    is that it blocks the thread for the full duration of the sleep. As a result,
    the LED will not respond to rate changes immediately and will feel sluggish to
    a user when they turn the potentiometer. The second approach, commended `#Better
    approach`, alleviates this issue and allows the LED to respond to rate changes
    in (near) real time.
  prefs: []
  type: TYPE_NORMAL
- en: Our `version2` program example using the LED class with its own internal thread
    now means that we have multiple threads – one per LED – all making the LEDs blink
    independently to one another.
  prefs: []
  type: TYPE_NORMAL
- en: Can you think of any potential problems this may introduce? Okay, it might be
    obvious if you have read through the `version2` source files – it's the synchronization
    of all LEDs to blink at the same rate in unison when the button is held for 0.5
    seconds!
  prefs: []
  type: TYPE_NORMAL
- en: By introducing multiple threads, we have introduced multiple timers (that is,
    the `sleep()` statement), so each thread is blinking on its own independent schedule,
    and not from a common reference point in terms of a starting timebase.
  prefs: []
  type: TYPE_NORMAL
- en: This means that if we simply called `led.set_rate(n)` on multiple LEDs, while
    they would all blink on and off at the rate *n*, they would not necessarily blink
    in unison.
  prefs: []
  type: TYPE_NORMAL
- en: A simple solution to this issue is to synchronize the turning off of all LEDs
    before we start them blinking at the same rate. That is, we start them blinking
    from a common state (that is, off), and start them blinking together.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach is shown in the following code snippet starting at line 1 in
    `LED.py`. The core of the synchronization is achieved by the `led._thread.join()`
    statements on line 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is a good first pass at synchronization, and for practical purposes, it
    works well for our situation. As mentioned, all we are doing is ensuring our LEDs
    start blinking together from an off state at the same time (well, very, very,
    very close to the same time, subject to the time taken for Python to iterate through
    the `for` loops).
  prefs: []
  type: TYPE_NORMAL
- en: Try commenting out `led._thread.join()` and the embodying `for` loop on line
    2 in the preceding code and run the program. Make the LEDs blink at different
    rates, then try to synchronize them by holding down the button. Does it always
    work?
  prefs: []
  type: TYPE_NORMAL
- en: However, it must be noted that we are still dealing with multiple threads and
    independent timers to make our LEDs blink, so the potential for a time drift to
    occur is present. If this ever presented a practical issue, we would then need
    to explore alternative techniques to synchronize the time in each thread, or we
    could create and use a single class to manage multiple LEDs together (basically
    using the approach from the event-loop example, only refactoring it into a class
    and a thread).
  prefs: []
  type: TYPE_NORMAL
- en: The takeaway here regarding threads is that when you introduce threads to your
    applications, you can introduce timing issues that *may* be designed around or
    synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: If your first pass at a prototype or new program involves an event-loop-based
    approach (as I often do), then as you refactor that code out into classes and
    threads, always think about any timing and synchronizing issues that may arise.
    Discovering synchronization-related bugs by accident during testing (or worse,
    when in production) is frustrating as they can be hard to reliably replicate,
    and could result in the need for extensive rework.
  prefs: []
  type: TYPE_NORMAL
- en: We've just seen how to create our sample gizmo program using OOP techniques,
    threads, and callbacks. We've seen how this approach results in easier to read
    and maintain code, and we also discovered the additional requirement and effort
    needed to synchronize threaded code. Next, we will look at the third variation
    of our program, which is based around a publisher-subscriber model.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the publisher-subscriber alternative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen an approach to creating our program using threads, callbacks,
    and OOP techniques, let's consider a third approach using a *publisher-subscriber*
    model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the publisher-subscriber approach can be found in the `chapter12/version3_pubsub`
    folder. You will find four files – the main program, `main.py`, and three class
    definitions: `LED.py`, `BUTTON.py`, and `POT.py`.'
  prefs: []
  type: TYPE_NORMAL
- en: Please take the time now to stop and read through the code contained in `main.py` to
    get a basic understanding of how the program is structured and how it works. Then,
    proceed to review `LED.py`, `BUTTON.py`, and `POT.py`.
  prefs: []
  type: TYPE_NORMAL
- en: What you will have noticed is that the overall program structure (especially
    the class files) is very similar to the `version2` thread/callback example that
    we covered in the previous heading.
  prefs: []
  type: TYPE_NORMAL
- en: You may also have realized that this approach is very similar in concept to
    the publisher/subscribing method employed by MQTT, which we discussed in detail
    in [Chapter 4](6947b564-6182-4ec9-998a-37f636c0bce6.xhtml), *Networking with MQTT,
    Python, and the Mosquitto MQTT Broker*. The main difference is that in our current
    `version3` example, our publisher-subscribing context is confined just to our
    program run-time environment, not a network-distributed set of programs, which
    was the scenario for our MQTT examples.
  prefs: []
  type: TYPE_NORMAL
- en: I have implemented the publishing-subscribing layer in `version3` using the
    `PyPubSub` Python library, which is available from [pypi.org](https://pypi.org)
    and is installed using `pip`. We will not discuss this library in any detail,
    as the overall concepts and use of this type of library should already be familiar
    to you, and if not, I have no doubt that you will immediately understand what's
    going on once you review the `version3` source code files (if you have not already
    done so).
  prefs: []
  type: TYPE_NORMAL
- en: There are alternative PubSub libraries available for Python through PyPi.org.
    The choice to use `PyPubSub` for this example was due to the quality of its documentation
    and the examples provided there. You will find a link to this library in the *Technical
    requirements* section at the start of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the similarity of the `version2` (threaded approach) and `version3`
    (publisher-subscriber approach) examples, we will not discuss each code file in
    detail, other than to point out that the core differences:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `version2` (threaded), this is how our `led`, `button`, and `pot` class
    instances communicate with one another:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We registered callback handlers in `main.py` on the `button` and `pot` class
    instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`button` and `pot` send events (for example, a button press or potentiometer
    adjustment) via this callback mechanism.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We interacted with the LED class instances directly using the `set_rate()` instance
    method and the `set_rate_all()` class method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `version3 `(publisher-subscriber), here is the intra-class communication
    structure and design:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every class instance is very loosely coupled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no callbacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We do not interact with any class instances directly after they are created
    and registered with `PyPubSub`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All communication between classes and threads occurs using the messaging layer
    provided by `PyPubSub`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, to be honest, our gizmo program does not benefit from a publisher-subscriber
    approach. My personal preference is to adopt the callback version for a small
    program like this one. However, I have provided the publisher-subscriber alternative
    implementation as a point of reference so that you have this alternative to consider
    for your own needs.
  prefs: []
  type: TYPE_NORMAL
- en: Where a publisher-subscriber approach shines is in more complex programs where
    you have many components (and here I mean software components, not necessarily electronics
    components) that need to share data and can do so in an asynchronous PubSub-style
    nature.
  prefs: []
  type: TYPE_NORMAL
- en: We're presenting the coding and design approaches in this chapter in four very
    discrete and focused examples. In practice, however, it's common to combine these
    approaches (and other design patterns) in a hybrid and mixed fashion when creating
    your programs. Remember, the approach or combination of approaches to use is whatever
    makes the most sense for what you are trying to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: As we have just discussed, and you will have seen as you reviewed the `version3`
    code, a publisher-subscriber approach to our gizmo program is a simple variation
    of the thread and callback approach, where instead of using callbacks and interacting
    with class instances directly, we standardize all code communication to a messaging
    layer. Next, we will look at our final approach to coding our gizmo program, this
    time taking the AsyncIO approach.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring an AsyncIO approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we have seen three different programming approaches
    to achieving the same end goal. Our fourth and final approach will be built using
    the AsyncIO libraries offered by Python 3\. As we will see, this approach shares
    similarities and differences with our previous approaches, and also adds an extra
    dimension to our code and how it operates.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking from my own experience, this approach can feel complex, cumbersome,
    and confusing the first time you experience asynchronous programming in Python.
    Yes, there is a steep learning curve to asynchronous programming (and we can only
    barely scratch the surface in this section). However, as you learn to master the
    concepts and gain practical experience, you may start to discover that it is an
    elegant and graceful way to create programs!
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to asynchronous programming in Python, you will find curated
    tutorial links in the *Further reading* section to deepen your learning. It is
    my intention in this section to give you a simple working AsyncIO program that
    focuses on electronic interfacing, which you can use as a reference as you learn
    more about this style of programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the asynchronous-based approach can be found in the `chapter12/version4_asyncio`
    folder. You will find four files – the main program, `main.py`, and three class
    definitions: `LED.py`, `BUTTON.py`, and `POT.py`.'
  prefs: []
  type: TYPE_NORMAL
- en: Please take the time now to stop and read through the code contained in `main.py` to
    get a basic understanding of how the program is structured and how it works. Then
    proceed to review `LED.py`, `BUTTON.py`, and `POT.py`.
  prefs: []
  type: TYPE_NORMAL
- en: If you are also a JavaScript developer – particularly Node.js – you will already
    know that JavaScript is an asynchronous programming language; however, it looks
    and feels very different from what you are seeing in Python! I can assure you
    that the principles are the same. Here is a key reason why they feel very different
    – JavaScript is *asynchronous by default.* As any experienced Node.js developer
    knows, we often have to go to (often extreme) lengths in code to make parts of
    our code behave synchronously. The opposite is true for Python – it's *synchronous
    by default*, and we need to extend extra programming effort to make parts of our
    code behave asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you read through the source code files, I want you to think about our `version4`
    AsyncIO program as having elements of both the `version1` event-loop-based program
    and the `version2` threaded/callback program. Here is a summary of the key differences
    and similarities:'
  prefs: []
  type: TYPE_NORMAL
- en: The overall program structure is very similar to the `version2` thread/callback
    example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of `main.py`, we have a few new lines of code that we have not seen
    in this book before – for example, `loop = asyncio.get_event_loop()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like the `version2` program, we have used OOP techniques to factor our components
    into classes, which also have a `run()` method – but notice how there is no thread
    instance in these classes and no code related to starting a thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the class definition files, `LED.py`, `BUTTON.py`, and `POT.py`, we have
    the `async` and `await` keywords sprinkled around and in the `run()` function,
    and a delay of 0 seconds in the `while` loop – that is, `asyncio.sleep(0)` – so
    we're not really sleeping at all!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `BUTTON.py`, we are no longer using the PiGPIO callback to monitor a button
    being pressed, but instead polling the button GPIO in a `while` loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python 3 AsyncIO library has evolved significantly over time (and still
    is evolving), with new API conventions, the addition of higher-level functionality.
    and deprecated functions. Due to this evolution, code can get out of date with
    the latest API conventions quickly, and two code examples illustrating the same
    underlying concepts can be using seemingly different APIs. I highly recommend
    you glance through the latest Python AsyncIO library API documentation as it will
    give you hints and examples of newer versus older API practices, which may help
    you better interpret code examples.
  prefs: []
  type: TYPE_NORMAL
- en: I will explain how this program works by walking you through the high-level
    program flow in a simplified way. When you can grasp the general idea of what
    is happening, you are well on your way to understanding asynchronous programming
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: You will also find a file named `chapter12/version4_asyncio/main_py37.py`. This
    is a Python 3.7+ version of our program. It uses an API available since Python
    3.7\. If you look through this file, the differences are clearly commented.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the `main.py` file, we see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: An asynchronous program in Python evolves around the event-loop. We see this
    created at line 1 and started at line 5\. We'll come back to the registrations
    occurring in between at lines 2, 3, and 4 momentarily.
  prefs: []
  type: TYPE_NORMAL
- en: The overall principle of this asynchronous event-loop is similar to our version1
    event-loop example; however, the semantics are different. Both versions are single-threaded,
    and both sets of code do *go around in a loop*. In `version1`, this was very explicit
    because our main body of code was contained in an outer `while` loop. In our asynchronous
    `version4`, it's more implicit, and has a core difference – it's non-blocking
    *if programmed correctly*, and as we will see soon, this is the purpose of the
    `await asyncio.sleep()` calls in the class `run()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, we have registered our class `run()` methods with the loop on
    lines 2, 3, and 4\. After we start the event-loop on line 5, here is what happens
    in simplified terms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *first* LED''s `run()` function (shown in the following code) is called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It enters the `while` loop on line 1 and toggles the LED on or off from line
    2, depending on the blinking rate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, it gets to line 3, `await asyncio.sleep(0)`, and *yields* control. At
    this point, the `run()` method is effectively paused, and another `while` loop
    iteration does not start.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Control is passed over the *second* LED's `run()` function, and it runs through
    it's `while` loop once until it reaches `await asyncio.sleep(0)`. It then yields
    control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, the pot instance''s `run()` method (shown in the following code) gets
    a turn to run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `run()` method performs one iteration of the `while` loop until it reaches `await
    asyncio.sleep(0)`. It then yields control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Control is passed to the `button` instance''s `run()` method (partly shown
    in the following code), which has multiple `await asyncio.sleep(0)` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As soon as the button's `run()` method reaches any instance of `await asyncio.sleep(0)`,
    it yields control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, all our registered `run()` methods have had a chance to run, so the *first*
    LED's `run()` method will take control again and perform one `while` loop iteration
    until it reaches `await asyncio.sleep(0)`. Again, at this point it *yields* control
    and the *second* LED's `run()` method gets another turn to run...and the process
    continues over and over, with each `run()` method getting a turn to run in a round-robin
    fashion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s tie up a few loose ends where you will likely have questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What about the button's `run()` function with its many `await asyncio.sleep(0)`
    statements?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When control is yielded at any `await asyncio.sleep(0)` statement, the function
    yields at this point. The next time the `run()` button gets control, the code
    will continue from the next statement beneath the `await asyncio.sleep(0)` statement
    that yielded.
  prefs: []
  type: TYPE_NORMAL
- en: Why is the sleep delay 0 seconds?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Awaiting a zero-delay sleep is the simplest way to yield control (and please
    note that it is the `sleep()` function from the `asyncio` library, not the `sleep()`
    function from the `time` library). However, you can `await` any asynchronous method,
    but this is beyond the scope for our simple example.
  prefs: []
  type: TYPE_NORMAL
- en: I have used zero-second delays for this example for simplicity in explaining
    how the program works, but you can use non-zero delays. All this means is that
    the yielding `run()` function would sleep for this period – the event-loop will
    not give it a turn to run until this period expires.
  prefs: []
  type: TYPE_NORMAL
- en: What about the `async` and `await` keywords – how do I know where to use them?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This certainly comes with practice; however, here are the basic design rules:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are registering a function (for example, `run()`) with the event-loop,
    the function must start with the `async` keyword.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Any `async` function must contain at least one `await` statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing and learning asynchronous programs takes practice and experimentation.
    One of the initial design challenges you will face is knowing where to put `await`
    statements (and how many), and how long you should yield control for. I encourage
    you to play with the `version4` code base, add in your own debugging `print()` or
    logging statements, and just experiment and tinker until you get a feel for how
    it all fits together. At some point, you'll have that *aha* moment, and at that
    point, you have just opened the door to further explore the many advanced features
    offered by the Python AsyncIO libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how an asynchronous program is structured and behaves
    at runtime, I want to give you something to experiment with and ponder.
  prefs: []
  type: TYPE_NORMAL
- en: An asynchronous experiment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's try an experiment. Maybe you've wondered how `version4` (AsyncIO) is a
    bit like our `version1` (event-loop) code, only it's been refactored into classes
    just like the `version2` (threaded) code. So, couldn't we just refactor the code
    in the `version1 while` loop into classes, create and call a function them (for
    example, `run()`) in the `while` loop, and not bother with all the asynchronous
    stuff and its extra library and syntax?
  prefs: []
  type: TYPE_NORMAL
- en: Let's try. You will find a version just like this in the `chapter12/version5_eventloop2`
    folder. Try running this version, and see what happens. You'll find that the first
    LED blinks, the second one is always on, and that the button and potentiometer do
    not work.
  prefs: []
  type: TYPE_NORMAL
- en: Can you work out why?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the simple answer: in `main.py`, once the first LED''s `run()` function
    is called, we''re stuck in its `while` loop forever!'
  prefs: []
  type: TYPE_NORMAL
- en: The call to `sleep()` (from the `time` library) does not yield control; it just
    halts the LED's `run()` method for the duration before the next `while` loop iteration
    occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, this is an example of why we say synchronous programs are blocking (no
    yielding of control), and why asynchronous programs are non-blocking (they yield
    control and give other code a chance to run).
  prefs: []
  type: TYPE_NORMAL
- en: I hope you have enjoyed our exploration of four alternative ways of structuring
    electronic-interfacing programs – and one way we shouldn't. Let's conclude by
    recapping what we have learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at four different way of structuring a Python program
    that interface with electronics. We learned about an event-loop approach to programming,
    two variations on a thread-based approach – callbacks and a publisher-subscriber
    model – and finished by looking at how an AsyncIO approach to programming works.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the four examples we covered was very discrete and specific in its approach.
    While we briefly discussed the relative benefits and pitfalls of each approach
    along the way, it's worth remembering that in practice, your projects will likely
    use a mixture of these (and potentially other) approaches, depending on the programming
    and interfacing goals you are trying to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will turn our attention toward IoT platforms and present
    a discussion of the various options and alternatives that are available for building
    IoT programs.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    of this chapter''s material. You will find the answers in the *Assessments* section
    of the book:'
  prefs: []
  type: TYPE_NORMAL
- en: When is a publisher-subscriber model a good design approach?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Python GIL, and what implication does it present for classic threading?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is a pure event-loop usually a poor choice for complex applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is an event-loop approach a bad idea? Why or why not?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `thread.join()` function call?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have used a thread to poll your new analog component via an analog-to-digital
    converter. However, you find that your code behaves sluggishly to changes in the
    component. What could be the problem?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which is the superior approach to designing an IoT or electronic interfacing
    application in Python – using an event-loop, a thread/callback, the publisher-subscriber
    model, or an AsyncIO-based approach?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The [realpython.com](https://realpython.com) website has a range of excellent
    tutorials covering all things concurrency in Python, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the Python GIL? [https://realpython.com/python-gil](https://realpython.com/python-gil)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speed Up Your Python Program with Concurrency: [https://realpython.com/python-concurrency](https://realpython.com/python-concurrency)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Intro to Threading in Python: [https://realpython.com/intro-to-python-threading](https://realpython.com/intro-to-python-threading)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Async IO in Python: A Complete Walkthrough: [https://realpython.com/async-io-python](https://realpython.com/async-io-python)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are relevant links from the official Python (3.7) API documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: Threading: [https://docs.python.org/3.7/library/threading.html](https://docs.python.org/3.7/library/threading.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AsyncIO library: [https://docs.python.org/3.7/library/asyncio.htm](https://docs.python.org/3.7/library/asyncio.htm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing with AsyncIO: [https://docs.python.org/3.7/library/asyncio-dev.html](https://docs.python.org/3.7/library/asyncio-dev.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency in Python: [https://docs.python.org/3.7/library/concurrency.html](https://docs.python.org/3.7/library/concurrency.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
