- en: Integrating Automated Tests with Continuous Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating a continuous integration report for Jenkins with NoseXUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Jenkins to run Python tests upon commit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Jenkins to run Python tests when scheduled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a continuous integration report for TeamCity using teamcity-nose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring TeamCity to run Python tests upon commit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring TeamCity to run Python tests when scheduled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The classic software development process known as the waterfall model involves
    the following stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Requirements are collected and defined
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Designs are drafted to satisfy the requirements
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An implementation strategy is written to meet the design
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Coding is done
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The coded implementation is tested
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The system is integrated with other systems as well as future versions of that
    system
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the waterfall model, these steps are often spread across several months
    of work. What this means is that the final step of integration with external systems
    is done after several months and often takes a lot of effort. **Continuous integration
    (CI)** remedies the deficiencies of the waterfall model by introducing the concept
    of writing tests that exercise these points of integration and has them run automatically
    whenever the code is checked into the system. Teams that adopt CI often adopt
    a corresponding policy of immediately fixing the baseline if the test suite fails.
    This forces the team to keep their code working and integrated continuously, thus
    making this final step relatively cost-free. Teams that adopt a more agile approach
    work in much shorter cycles. Teams may work in coding sprints that may vary anywhere
    from the weekly to the monthly. Again, by having integrating test suites run with
    every check-in, the baseline is always kept functional; thus, it is ready for
    delivery at any time. This prevents the system from being in a nonworking state
    that is only brought into working state at the end of a sprint or at the end of
    a waterfall cycle. It opens the door to more code demonstrations for either the
    customer or management, in which feedback can be garnered and fed more proactively
    into development. This chapter is more focused on integrating automated tests
    with CI systems than with writing the tests. For that reason, we will reuse the
    following Shopping Cart application. Create a new file called `cart.py` and enter
    the following code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To exercise this simple application, the following simple set of unit tests
    will be used by various recipes in this chapter to demonstrate CI. Create another
    file called `tests.py` and enter the following test code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple set of tests doesn''t look very impressive, does it? In fact, it
    isn''t really integration testing like we were talking about earlier, but instead
    it appears to be basic unit testing, right? Absolutely! This chapter isn''t focusing
    on writing test code. So, if this book is about code recipes, why are we focusing
    on tools? Because there is more to making automated testing work with your team
    than writing tests. It''s important to become aware of the tools that take the
    concepts of automating tests and leverage them into our development cycles. CI
    products are a valuable tool, and we need to see how to link them with our test
    code, in turn allowing the whole team to come on board and make testing a first-class
    citizen of our development process. This chapter explores two powerful CI products:
    Jenkins and TeamCity.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jenkins** ([http://jenkins-ci.org/](http://jenkins-ci.org/)) is an open source
    product whose creation was led by a developer originally from Sun Microsystems,
    who left after Sun''s acquisition by Oracle. It has a strong developer community
    with many people providing patches, plugins, and improvements. It was originally
    called **Hudson**, but the development community voted to rename it to avoid legal
    entanglements. There is more history to the entire Hudson/Jenkins naming that
    can be read online, but it''s not relevant to the recipes in this book. **TeamCity**
    ([http://www.jetbrains.com/teamcity/](http://www.jetbrains.com/teamcity/)) is
    a product created by JetBrains, the same company that produces commercial products
    such as IntelliJ IDE, ReSharper, and the PyCharm IDE. The Professional Edition
    is a free version that will be used in this chapter to show another CI system.
    It has an enterprise version, a commercial upgrade, which you can evaluate for
    yourself.'
  prefs: []
  type: TYPE_NORMAL
- en: Generating a CI report for Jenkins using NoseXUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JUnit** ([http://junit.org](http://junit.org)) is a software industry leader
    in automated testing. It provides the ability to generate XML report files that
    are consumable by many tools. This extends to continuous tools like Jenkins. **NoseXUnit**
    ([http://nosexunit.sourceforge.net/](http://nosexunit.sourceforge.net/)) is a
    `nose` plugin that generates XML reports with Python test results in the same
    format. It works like JUnit with XML reporting but for PyUnit. Even though we
    aren''t building Java code, there is no requirement that states our CI server
    can''t be a Java-based system. As long as we can generate the right reports, those
    tools are candidates for usage. Considering that one of the most popular and well-supported
    CI systems is Jenkins, this type of plugin is very useful. With this recipe, we
    will explore generating consumable reports from simple Python testing.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps are needed to have all the components installed for this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Install `nose`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install NoseXUnit ([http://nosexunit.sourceforge.net/](http://nosexunit.sourceforge.net/))
    by typing `pip install nosexunit`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will show how to use the NoseXUnit plugin to generate an
    XML report in a Jenkins-compatible format:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Test the shopping cart application using `nosetests` and the NoseXUnit plugin
    by typing `nosetests tests.py --with-nosexunit`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00105.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the report found in `target/NoseXUnit/core/TEST-tests.xml` using an XML
    or text editor. The following screenshot shows the report displayed in Spring
    Tool Suite ([http://www.springsource.com/developer/sts](http://www.springsource.com/developer/sts)),
    an Eclipse derivative (this is by no means a recommendation). Many modern IDEs
    have built-in XML support as do other editors like Emacs, TextPad, and so on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00106.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NoseXUnit collects the outcome of each test and generates an XML report that
    has the same format as JUnit. The XML file isn''t designed to be human-consumable,
    but it''s not too hard to discern the results. When we ran `nosetests` earlier,
    how many test cases passed? What were the test method names? In this XML file,
    we can see the names of the four test cases. In fact, if this file is opened inside
    certain tools such as STS, it displays itself as a test outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00107.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We don''t have to use STS to do any of this. In fact, STS is a bit heavyweight
    for this simple task. Your favorite XML or text editor is fine to inspect the
    report. I just wanted to demonstrate how the output of this plugin works neatly
    with existing tools. By typing `nosetests help`, we can see all the options that
    `nose` has from all the installed plugins. This includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--core-target=CORE_TARGET`: Output folder for test reports (defaults to target/NoseXUnit/core)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--with-nosexunit`: Runs it through the plugin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Jenkins to run Python tests upon commit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jenkins can be configured to invoke our test suite upon commit. This is very
    useful, because we can gear it to track our changes. Teams that use CI systems
    usually adopt an attitude of addressing CI failures immediately in order to keep
    the baseline functional. Jenkins offers an almost unlimited number of features,
    such as retrieving the latest source from version control, packaging a release,
    running tests, and even analyzing source code. This recipe shows how to configure
    Jenkins to run our test suite against our Shopping Cart application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Download Jenkins from [http://mirrors.jenkins-ci.org/war/latest/jenkins.war](http://mirrors.jenkins-ci.org/war/latest/jenkins.war):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00108.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Start it up by running `java -jar jenkins.war`. It''s important that no other
    applications are listening on port `8080`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00109.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the console to confirm Jenkins is working:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00110.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on Manage Jenkins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Manage Plugins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Available tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the Git Plugin and click the checkbox next to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the bottom of the page, click on the Install button. Verify that the plugin
    has successfully installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate back to the dashboard screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Shut down Jenkins and start it back up again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Git source code control on your machine. You can visit [http://git-scm.com/](http://git-scm.com/)
    to find downloadable packages. It is also possible that your system may include
    package installation options like MacPorts or Homebrew for Macs, `yum` for Red
    Hat-based Linux distributions, and `apt-get` for Debian/Ubuntu systems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an empty folder for this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the folder for source code maintenance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the Shopping Cart application into the folder, add it, and commit the
    changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will show how to put our code under control and then run
    the test suite when we make any changes and commit them:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Jenkins console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on New Job.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `recipe46` as the Job name and pick build a free-style software project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on a.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Source Code Management section, pick Git. For the URL, enter `/tmp/recipe46/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Build Triggers section, pick Poll SCM and enter `* * * * *` into the
    schedule box, to trigger a poll once per minute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Build section, select Execute shell and enter the following ad hoc script,
    which loads the virtualenv and runs the test suite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You need to substitute the command to activate your own virtualenv, whether
    this is on Windows, Linux, or macOS, and then follow it with the command used
    to run the tests just like we did earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the Post-build Actions section, pick Publish JUnit test result report and
    enter `target/NoseXUnit/core/*.xml`, so that the test results are collected by
    Jenkins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Save to store all the job settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on Enable Auto Refresh. We should expect the first run to fail, because
    we haven''t added any tests yet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00111.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Copy the test suite into the controlled source folder, add it, and commit it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Watch to verify whether Jenkins launches a successful test run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00112.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Navigate to the test results page, where we can see that four of our tests were
    run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jenkins provides a powerful, flexible way to configure CI jobs. In this recipe,
    we configured it to poll our software confirmation management system once a minute.
    When it detects a change, it pulls a fresh copy of the software and runs our test
    script. By using the NoseXUnit plugin, we generated an artifact that was easy
    to harvest with Jenkins. With a handful of steps, we were able to configure a
    web page that monitors our source code.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jenkins has lots of options. If you examine the web interface, you can drill
    into output logs to see what actually happened. It also collects trends showing
    how long we have had success, when the last build failed, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Do I have to use git for source code management?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The answer is no. We used it in this recipe to show quickly how to install a
    Jenkins plugin from inside the web interface. To apply the plugin, we had to restart
    Jenkins. Subversion and CVS are supported out of the box. Jenkins also has plugins
    that support every major source code control system out there, so it should be
    easy to meet your needs. In fact, there is support for social coding sites like
    GitHub and BitKeeper. Instead of using the Git plugin, we could configure our
    Jenkins installation to watch a certain GitHub account for updates.
  prefs: []
  type: TYPE_NORMAL
- en: What is the format of polling?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We configured the polling with `* * * * *`, which means once a minute. This
    is based on the format used to configure crontab files. The columns from left
    to right are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MINUTE**: Minutes within the hour (0-59)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HOUR**: The hour of the day (0-23)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DOM**: The day of the month (1-31)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MONTH**: The month (1-12)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DOW:** The day of the week (0-7) where 0 and 7 are Sunday'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generating a CI report for Jenkins using NoseXUnit
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Jenkins to run Python tests when scheduled
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just explored how to configure Jenkins to run our test suite when we commit
    the code changes. Jenkins can also be configured to invoke our test suite at scheduled
    intervals. This is very useful, because we can gear it to make scheduled releases.
    Daily or weekly releases can provide potential customers with a nice release cadence.
    CI releases are usually understood to not necessarily be final, but instead provide
    bleeding-edge support in case new features need to be investigated early and integrated
    by the customer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps are used to set up Jenkins as well as a copy of our tests,
    so we can poll it at a scheduled interval:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up Jenkins as shown in the earlier recipe, *Configuring Jenkins to run Python
    tests upon commit*. This should include having set up the Git plugin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an empty folder for this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the folder for source code maintenance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the Shopping Cart application into the folder, add it, and commit the
    changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will let us explore creating a Jenkins job to run our automated
    test suite periodically:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Jenkins console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on New Job.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `recipe47` as the Job name and pick Build a free-style software project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Ok.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Source Code Management section, pick Git. For the URL, enter `/tmp/recipe47/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Build Triggers section, pick Build periodically and enter some time in
    the future. While writing this recipe for the book, the job was created around
    6:10 P.M., so entering `15 18 * * *` into the schedule box schedules the job five
    minutes into the future at 6:15 P.M.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Build section, select Execute shell and enter the following ad hoc script,
    which loads the virtualenv and runs the test suite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You need to replace this with the command used to activate your virtualenv,
    followed by the step to run the tests.
  prefs: []
  type: TYPE_NORMAL
- en: In the Post-build Actions section, pick Publish JUnit test result report and
    enter `target/NoseXUnit/core/*.xml`, so that test results are collected by Jenkins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Save to store all the job settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Enable Auto Refresh.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the test suite into the controlled source folder, add it, and commit it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Watch to verify whether Jenkins launches a successful test run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00113.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Navigate to the test results, and we can see that four of our tests were run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is very similar to the previous recipe, only this time we configured a
    polling interval for running our test suite instead of polling the version control
    system. It is useful to run a build once a day to make sure things are stable
    and working.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jenkins has lots of options. If you examine the web interface, you can drill
    into output logs to see what actually happened. It also collects trends showing
    how long we have had success, when the last build failed, and more. To be honest,
    Jenkins has so many plugins and options that an entire book could be devoted to
    exploring its features. This half of the chapter is merely an introduction to
    using it with some common jobs that are test-oriented.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins versus TeamCity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have explored using Jenkins. Later in this chapter, we will visit
    TeamCity. What are the differences? Why should we pick one or the other? Feature-wise,
    they both offer powerful choices. That is why they are both covered in this book.
    The key thing both provide is setting up jobs to run tests, as well as other things
    like packaging. A key difference is that Jenkins is an open source product and
    TeamCity is commercial. You or your company may prefer to have a paid company
    associated with the product ([http://www.jetbrains.com/](http://www.jetbrains.com/)),
    which is what TeamCity offers. This doesn't make the decision crystal clear because
    the principal developer of Jenkins currently works for CloudBees ([http://www.cloudbees.com/](http://www.cloudbees.com/)),
    which invests effort in Jenkins as well as products surrounding it. If commercial
    support isn't imperative, you may find the pace of development of Jenkins is faster
    and the number of plugins more diverse. The bottom line is that choosing the product
    that meets your CI needs requires a detailed analysis and simply can't be answered
    here.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generating a CI report for Jenkins using NoseXUnit
  prefs: []
  type: TYPE_NORMAL
- en: Generating a CI report for TeamCity using teamcity-nose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a `nose` plugin that automatically detects when tests are being run
    from inside TeamCity. This conveniently captures test results and communicates
    them with TeamCity. With this recipe, we will explore how to setup a CI job inside
    TeamCity that runs our tests and then manually invokes that job.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps are needed to get us prepared to run a TeamCity CI job:'
  prefs: []
  type: TYPE_NORMAL
- en: Install `nosetests`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install `teamcity-nose` by typing `pip install teamcity-nose`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download TeamCity using Wget ([http://download.jetbrains.com/teamcity/TeamCity-6.0.tar.gz](http://download.jetbrains.com/teamcity/TeamCity-6.0.tar.gz)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unpack the download.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the `TeamCity/bin` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start it up: `./runAll.sh start`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a browser to `http://localhost:8111`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If this is the first time you are starting TeamCity, accept the license agreement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an administrator account by picking a username and password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Git source code control on your machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an empty folder for this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the folder for source code maintenance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the shopping cart application and tests into the folder, add it, and commit
    the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps show how to configure a CI job in TeamCity:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the TeamCity console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath the Projects tab, click Create project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in `recipe48`, and then click Create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Add a build configuration for this project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `nose testing` for the name and then click VCS settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Create and attach new VCS root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `recipe48` in VCS root name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Git as the Type of VCS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `/tmp/recipe48` as the Fetch URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Test Connection to confirm the settings and then click Save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Add Build Step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Command Line for Runner type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select Custom script for Run type and enter the following script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You need to customize this with the command needed to activate your virtualenv.
  prefs: []
  type: TYPE_NORMAL
- en: Click on Save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go back to the project, and run it manually:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00114.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This plugin is designed not to be used in the classic style of being invoked
    by a command-line argument. Instead, it is manually run automatically whenever
    `nosetests` is executed, and it checks if there is a TeamCity-specific environment
    variable set. If so, it kicks in by printing out viewable results as well as sending
    back useful information to TeamCity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00115.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Otherwise, the plugin lets itself be bypassed and does nothing. If the plugin
    was NOT installed, the following screenshot would be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00116.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In turn, drilling into the details shows the following output with little detail.
    There are four periods, one for each test method, but we don''t know much more
    than that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00117.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This means no extra arguments are needed to use the TeamCity plugin, but running
    it from the command line, outside of TeamCity, causes no changes.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring TeamCity to run Python tests upon commit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TeamCity can be configured to invoke your test suite upon commit.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will help us prep TeamCity to run our test suite when the
    code changes are committed:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up TeamCity like in the previous recipe, and have it started up. You also
    need to have `git` installed, as mentioned earlier in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an empty folder for this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the folder for source code maintenance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the Shopping Cart application into the folder, add it, and commit the
    changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps will show us how to create a TeamCity job that polls version control
    to detect a change and then run a test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the TeamCity console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath the Projects tab, click Create project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in `recipe49`, and then click Create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Add a build configuration for this project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `nose testing` for the name and then click VCS settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Create and attach new VCS root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `recipe49` in VCS root name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Git as the Type of VCS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `**/**tmp/recipe49` as the Fetch URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Test Connection to confirm settings and then click Save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Add Build Step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Command Line for Runner type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select Custom script for Run type and enter the following script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You must replace this with the command to activate your own virtualenv and invoke
    `nosetests`.
  prefs: []
  type: TYPE_NORMAL
- en: Click on Save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Build Triggering.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Add new Trigger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick VCS Trigger from Trigger Type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top, it should display VCS Trigger will add build to the queue if VCS
    check-in is detected. Click Save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate back to Projects. There should be no jobs scheduled or results displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on Run. It should fail, because we haven''t added the tests to the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00118.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'From the command line, copy the test file into the repository. Then add it
    and commit it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Go back to the browser. It may take a minute for TeamCity to detect the change
    in the code and start another build job. It should automatically update the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00119.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we configured TeamCity to do a job for us tied to a specific
    trigger. The trigger is activated whenever a check-in is done to the software
    baseline. We had to take several steps to configure this, but it demonstrates
    the flexible power TeamCity offers. We also installed the `teamcity-nose` plugin,
    which gave us more details about the results.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TeamCity calls our `nose testing` job a build job. That is because running tests
    isn't the only thing TeamCity is used for. Instead, it's geared to build packages,
    deploy to sites, and any other action we may want it to do anytime a commit happens.
    This is why CI servers are sometimes called **build servers**. But if we start
    with simple jobs like testing the baseline, we are well on our way to discovering
    the other useful features TeamCity has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: What did teamcity-nose give us?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a `nose` plugin that provided us with a more detailed output. We didn't
    go into much detail in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generating a CI report for TeamCity using `teamcity-nose`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Jenkins to run Python tests upon commit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring TeamCity to run Python tests when scheduled
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TeamCity can be configured to invoke our test suite and collect results at a
    scheduled interval.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps will prepare us for this recipe by starting up TeamCity and having
    some code ready for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up TeamCity like we did earlier in this chapter and have it up and running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an empty folder for this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the folder for source code maintenance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the shopping cart application into the folder, add it, and commit the
    changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps show the details for configuring TeamCity to run our test suite
    on a scheduled basis:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the TeamCity console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath the Projects tab, click Create project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in `recipe50`, and then click Create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Add a build configuration for this project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `nose testing` for the name and then click VCS settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Create and attach new VCS root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `recipe50` in VCS root name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Git as the Type of VCS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `/tmp/recipe50` as the Fetch URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Test Connection to confirm settings and then click Save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Add Build Step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Command Line for Runner type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select Custom script for Run type and enter the following script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Replace this with your own steps to activate your virtualenv and then run the
    tests using `nosetests`.
  prefs: []
  type: TYPE_NORMAL
- en: Click on Save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Build Triggering.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Add new Trigger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Schedule Trigger from Trigger Type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick daily for frequency, and pick a time of about five minutes into the future.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deselect the option to Trigger build only if there are pending changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate back to Projects. There should be no jobs scheduled or results displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wait for the scheduled time to occur. The following screenshot shows the job
    when it is activated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00120.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the results summarized with our tests having
    passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00121.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Doesn't this look suspiciously similar to the previous recipe? Of course! We
    varied it a bit by creating a time-based trigger instead of a source-based trigger.
    The time trigger we picked is a daily, scheduled build at a set time. The point
    is to show a commonly used trigger rule. By seeing what is the same and what's
    different, we can start to see how to bend TeamCity to serve our needs. TeamCity
    has other triggers that are very useful, like triggering one job when another
    one completes. This lets us build lots of small, simple jobs, and chaining them
    together. We also installed the `teamcity-nose` plugin, which gave us more details
    in the results.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generating a CI report for TeamCity using `teamcity-nose`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Jenkins to run Python tests when scheduled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
