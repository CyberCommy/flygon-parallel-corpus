- en: Chapter 1. Getting Started – One Environment per Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is one aspect of the Python philosophy that always has been, and always
    will be, the most important in the entire language—readability, or Pythonic code.
    This book will help you master writing Python the way it was meant to be: readable,
    beautiful, explicit, and as simple as possible. In short, it will be Pythonic
    code. That is not to say that complicated subjects will not be covered. Naturally,
    they will, but whenever the philosophy of Python is at stake, you will be warned
    when and where the technique is justified.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the code within this book will function on both Python 2 and Python
    3, but the main target is Python 3\. There are three reasons for doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: Python 3 was released in 2008, which is a very long time in the rapidly changing
    software world. It's not a new thing anymore, it's stable, it's usable, and, most
    importantly, it's the future.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Development for Python 2 effectively stopped in 2009\. Certain features have
    been backported from Python 3 to Python 2, but any new development will be for
    Python 3 first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Python 3 has become mature. While I have to admit that Python 3.2 and older
    versions still had a few small issues that made it hard to write code that functions
    on both Python 2 and 3, Python 3.3 did improve greatly in that aspect, and I consider
    it mature. This is evidenced by the marginally modified syntax in Python 3.4 and
    3.5 and a lot of very useful features, which are covered in this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To summarize, Python 3 is an improvement over Python 2\. I have been a skeptic
    for a very long time myself, but I do not see any reason not to use Python 3 for
    new projects, and even porting existing projects to Python 3 is generally possible
    with only minor changes. With cool new features such as `async with` in Python
    3.5, you will want to upgrade just to try it.
  prefs: []
  type: TYPE_NORMAL
- en: This first chapter will show you how to properly set up an environment, create
    a new isolated environment, and make sure you get similar results when running
    the same code on different machines. Most Python programmers are already using
    `virtualenv` to create virtual Python environments, but the `venv` command, introduced
    in Python 3.3, is a very nice alternative. It is essentially a clone of the `virtualenv`
    package but is slightly simpler and bundled with Python. While its usage is mostly
    analogous to `virtualenv`, there are a few changes that are interesting to know.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, we will discuss the `pip` command. The `pip` command is automatically
    installed when using `venv` through the `ensurepip` package, a package introduced
    in Python 3.4\. This package automatically bootstraps `pip` into an existing Python
    library while maintaining independent versions of Python and `pip`. Before Python
    3.4, `venv` came without `pip` and had to be installed manually.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will discuss how packages created with `distutils` can be installed.
    While pure Python packages are generally easy to install, it can get challenging
    when C modules are involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics are covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a virtual Python environment using `venv`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrapping pip using `ensurepip`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing packages based on `distutils` (C/C++) with `pip`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a virtual Python environment using venv
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most Python programmers are already be familiar with `venv` or `virtualenv`,
    but even if you're not, it's never too late to start using it. The `venv` module
    is designed to isolate your Python environments so that you can install packages
    specific to your current project without polluting your global namespace. For
    example, having a filename such as `sys.py` in your current directory can seriously
    break your code if you expect to have the standard Python `sys` library—your local
    sys libraries will be imported before the global one, effectively hiding the system
    library. In addition, because the packages are installed locally, you don't need
    system (root/administrator) access to install them.
  prefs: []
  type: TYPE_NORMAL
- en: The result is that you can make sure you have exactly the same version of a
    package on both your local development machine and production machines without
    interfering with other packages. For example, there are many Django packages around
    that require specific versions of the Django project. Using `venv`, you can easily
    install Django 1.4 for project A and Django 1.8 for project B without them ever
    knowing that there are different versions installed in other environments. By
    default, the environments are even configured in such a way that the global packages
    are not visible. The benefit of this is that to get an exact list of all installed
    packages within the environment, simply a `pip freeze` will suffice. The downside
    is that some of the heavier packages (for example, `numpy`) will have to be installed
    in every separate environment. Needless to say, which choice is the best for your
    project depends on the project. For most projects, I would keep the default setting
    of not having the global packages, but when messing around with projects that
    have lots of C/C++ extensions, it would be convenient to simply enable the global
    site packages. The reason is simple; if you do not have a compiler available,
    installing the package locally can be difficult, while the global install has
    an executable for Windows or an installable package for Linux/Unix available.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `venv` module ([https://docs.python.org/3/library/venv.html](https://docs.python.org/3/library/venv.html))
    can be seen as a slightly simplified version of the `virtualenv` tool ([https://virtualenv.pypa.io/](https://virtualenv.pypa.io/)),
    which has been bundled with Python since version 3.3 (refer to PEP 0405 -- Python
    Virtual Environments: [https://www.python.org/dev/peps/pep-0405/](https://www.python.org/dev/peps/pep-0405/)).'
  prefs: []
  type: TYPE_NORMAL
- en: The `virtualenv` package can generally be used as a drop-in replacement for
    `venv`, which is especially relevant for older Python versions (below 3.3) that
    do not come bundled with `venv`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first venv
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating an environment is quite easy. The basic command comes down to `pyvenv
    PATH_TO_THE_NEW_VIRTUAL_ENVIRONMENT`, so let''s give it a try. Note that this
    command works on Linux, Unix, and Mac; the Windows command will follow shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some Ubuntu releases (notably 14.04 LTS) maim the Python installation by not
    including the full `pyvenv` package with `ensurepip`. The standard workaround
    is to call `pyvenv --without-pip test_env`, which requires a manual `pip` installation
    through the `get_pip.py` file available on the `pip` home page.
  prefs: []
  type: TYPE_NORMAL
- en: This creates an environment called `test_venv`, and the second line activates
    the environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows, everything is slightly different but similar overall. By default,
    the `pyvenv` command won''t be in your PATH, so running the command is slightly
    different. The three options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `Python\Tools\Scripts\` directory to your PATH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the module:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script directly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For convenience, I would recommend that you add the `Scripts` directory to your
    PATH anyhow, since many other applications/scripts (such as `pip`) will be installed
    there as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the full example for Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using Windows PowerShell, the environment can be activated by using `test_venv\Scripts\Activate.ps1`
    instead. Note that you really do need backslashes here.
  prefs: []
  type: TYPE_NORMAL
- en: venv arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have just created a plain and regular `venv`, but there are a few,
    really useful flags for customizing your `venv` specifically to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at the `venv` help:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `--system-site-packages` | It gives the virtual environment access to the
    `system-site-packages` directory |'
  prefs: []
  type: TYPE_TB
- en: '| `--symlinks` | Try to use `symlinks` rather than copies when symlinks are
    not the default for the platform |'
  prefs: []
  type: TYPE_TB
- en: '| `--copies` | Try to use copies rather than symlinks even when symlinks are
    the default for the platform |'
  prefs: []
  type: TYPE_TB
- en: '| `--clear` | Delete the contents of the environment directory, if it exists,
    before environment creation |'
  prefs: []
  type: TYPE_TB
- en: '| `--upgrade` | Upgrade the environment directory to use this version of Python,
    assuming that Python has been upgraded in-place |'
  prefs: []
  type: TYPE_TB
- en: '| `--without-pip` | This skips installing or upgrading pip in the virtual environment
    (`pip` is bootstrapped by default) |'
  prefs: []
  type: TYPE_TB
- en: The most important argument to note is `--system-site-packages`, which enables
    the global site packages within the environment. This means that if you have a
    package installed in your global Python version, it will be available within your
    environment as well. However, if you try to update it to a different version,
    it will be installed locally. Whenever possible, I would recommend disabling the
    `--system-site-packages` flag because it gives you a simple environment without
    too many variables. A simple update of the system packages could break your virtual
    environment otherwise, but worse, there is no way to know which packages are needed
    locally and which ones are just installed for other purposes.
  prefs: []
  type: TYPE_NORMAL
- en: To enable this for an existing environment, you can simply run the environment
    creation command again, but this time adding the `--system-site-packages` flag
    to enable the global site packages.
  prefs: []
  type: TYPE_NORMAL
- en: To disable it again, you can simply run the environment creation command without
    the flag. This will keep the locally (within the environment) installed packages
    available but will remove the global packages from your Python scope.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using `virtualenvwrapper`, this can also be done with the `toggleglobalsitepackages`
    command from within the activated environment.
  prefs: []
  type: TYPE_NORMAL
- en: The `--symlinks` and `--copies` arguments can generally be ignored, but it is
    important to know the difference. These arguments decide whether the files will
    be copied from the base python directory or whether they will be symlinked.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Symlinks are a Linux/Unix/Mac thing; instead of copying a file it creates a
    symbolic link that tells the system where to find the actual file.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `venv` will try to symlink the files, and if that fails, it will
    fall back to copying. Since Windows Vista and Python 3.2, this is also supported
    on Windows, so unless you're using a very old system, you will most likely be
    using symlinks in your environment. The benefit of symlinks is that it saves disk
    space and stays in sync with your Python installation. The downside is that if
    your system's Python version undergoes an upgrade, it can break the packages installed
    within your environment, but that can easily be fixed by reinstalling the packages
    using `pip`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `--upgrade` argument is useful if your system Python version has
    been upgraded in-place. The most common use case for this argument is for repairing
    broken environments after upgrading the system Python with a copied (as opposed
    to symlinked) environment.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between virtualenv and venv
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the `venv` module is essentially a simpler version of `virtualenv`, they
    are mostly the same, but some things are different. Also, since `virtualenv` is
    a package that is distributed separately from Python, it does have some advantages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the advantages of `venv` over `virtualenv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`venv` is distributed with Python 3.3 and above, so no separate install is
    needed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`venv` is simple and straightforward with no features besides the bare necessities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Advantages of `virtualenv` over `venv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`virtualenv` is distributed outside of Python, so it can be updated separately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`virtualenv` works on old Python versions, but Python 2.6 or a higher version
    is recommended. However, Python 2.5 support is possible with older versions (1.9.x
    or lower).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports convenient wrappers, such as `virtualenvwrapper` ([http://virtualenvwrapper.readthedocs.org/](http://virtualenvwrapper.readthedocs.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, if `venv` is enough for you, use it. If you are using an old Python
    version or want some extra convenience, such as `virtualenvwrapper`, use `virtualenv`
    instead. Both projects essentially do the same thing, and efforts have been made
    to easily switch between them. The biggest and most significant difference between
    the two is the wide variety of Python versions that `virtualenv` supports.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping pip using ensurepip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Slowly, the `pip` package manager has been replacing `easy_install` since its
    introduction in 2008\. Since Python 3.4, it has even become the default and is
    bundled with Python. Since Python 3.4 onward, it is installed by default within
    both the regular Python environment and that of `pyvenv`; before that, a manual
    install is required. To automatically install `pip` in Python 3.4 and above, the
    `ensurepip` library is used. This is a library that handles automatic installation
    and/or upgrades of `pip`, so it is at least as recent as the one bundled with
    `ensurepip`.
  prefs: []
  type: TYPE_NORMAL
- en: ensurepip usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The usage of `ensurepip` is fairly straightforward. Just run python `-m ensurepip`
    to guarantee a `pip` version or python `-m ensurepip --upgrade` to make sure that
    `pip` will be at least the version that is bundled with `ensurepip`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to installing the regular `pip` shortcut, this will also install
    the `pipX` and `pipX.Y` links, which allow you to select a specific Python version.
    When using Python 2 and Python 3 simultaneously, this allows you to install packages
    within Python 2 and Python 3 with `pip2` and `pip3`, respectively. This means
    that if you use python `-m ensurepip` on Python 3.5 you will get `pip`, `pip3`,
    and `pip3.5` commands installed in your environment.
  prefs: []
  type: TYPE_NORMAL
- en: Manual pip install
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ensurepip` package is great if you are using Python 3.4 or above. Below
    that, however, you need to install `pip` manually. Actually, this is surprisingly
    easy. It involves just two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the `get-pip.py` file: [https://bootstrap.pypa.io/get-pip.py](https://bootstrap.pypa.io/get-pip.py).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the `get-pip.py` file: python `get-pip.py`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the `ensurepip` command fails due to permission errors, it can be useful
    to supply the `--user` argument. This allows you to install `pip` inside the user
    `specific site packages` directory, so root/admin access is not required.
  prefs: []
  type: TYPE_NORMAL
- en: Installing C/C++ packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most Python packages are purely Python and blissfully easy to install, just
    as a simple `pip install packagename` does the trick. However, there are cases
    where compilation is involved and installation goes from a simple pip install
    to searching for hours to see which dependencies are needed to install a certain
    package.
  prefs: []
  type: TYPE_NORMAL
- en: The specific error message will differ as per the project and environment, but
    there is a common pattern in these errors, and understanding what you are looking
    at can help a lot when searching for a solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when installing `pillow` on a standard Ubuntu machine, you''ll
    get a few pages full of errors, warnings, and other messages that end like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon seeing messages like these, you might be tempted to search for one of
    the lines such as `x86_64-linux-gnu-gcc: error: build/temp.linux-x86_64-3.4/libImaging/Jpeg2KDecode.o:
    No such file or directory`. While this might give you some relevant results, most
    likely it will not. The trick with installations like these is to scroll up until
    you see messages about missing headers. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The key message here is that `Python.h` is missing. These are part of the Python
    headers and are needed for the compilation of most C/C++ packages within Python.
    Depending on the operating system, the solutions will vary—unfortunately. So,
    I recommend that you skip all parts of this paragraph that are not relevant for
    your case.
  prefs: []
  type: TYPE_NORMAL
- en: Debian and Ubuntu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Debian and Ubuntu, the package to be installed is `python3-dev` or `python2-dev`
    if you''re still using Python 2\. The command to execute is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this installs the development headers only. If you want the compiler
    and other headers bundled with the install, then the `build-dep` command is also
    very useful. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Red Hat, CentOS, and Fedora
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Red Hat, CentOS, and Fedora are rpm-based distros that use the `yum` package
    manager to install the requirements. Most development headers are available through
    `<package-name>-devel` and are easily installable as such. To install the Python
    3 development headers, use this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To make sure you have all the requirements such as development headers and
    compilers to build packages such as Python, the `yum-builddep` command is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: OS X
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The install procedure on OS X consists of three steps before the actual package
    can be installed.
  prefs: []
  type: TYPE_NORMAL
- en: First, you have to install Xcode. This can be done through the OS X App Store
    at [https://itunes.apple.com/en/app/xcode/id497799835?mt=12](https://itunes.apple.com/en/app/xcode/id497799835?mt=12).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you have to install the Xcode command-line tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you need to install the **Homebrew** package manager. The steps are
    available at [http://brew.sh/](http://brew.sh/), but the install command is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other package managers, such as `Macports`, are also possible, but `Homebrew`
    is currently the OS X package manager with the most active development and community.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all of these steps have been completed, you should have a working Homebrew
    installation. The working of `Homebrew` can be verified using the `brew doctor`
    command. If there are no major errors in the output, then you should be ready
    to install your first packages through brew. Now we simply need to install Python
    and we''re done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On Windows, manual compilation of C Python packages is generally a non-trivial
    task to say the least. Most packages have been written with Linux/Unix systems
    in mind (OS X falls under the Unix category), and Windows is a nice-to-have for
    developers. The result is that packages are difficult to compile on Windows because
    there are few people testing them and many of the libraries require manual installation,
    making it a very tedious task. So, unless you really have to, try and stay away
    from manually compiling Python packages on Windows. Most packages are available
    as installable binary downloads with a bit of searching, and there are alternatives
    such as Anaconda that include binary packages for most important C Python packages.
  prefs: []
  type: TYPE_NORMAL
- en: If you still feel inclined to manually compile C Python packages, then there
    is another option, and it is generally an easier alternative. The Cygwin project
    ([http://cygwin.com/](http://cygwin.com/)) attempts to make Linux applications
    run natively on Windows. This is generally an easier solution than making packages
    work with Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: If you do wish to take the Visual Studio path, I would like to point you towards
    [Chapter 14](ch14.html "Chapter 14. Extensions in C/C++, System Calls, and C/C++
    Libraries"), *Extensions in C/C++, System Calls, and C/C++ Libraries*, which covers
    manual writing of C/C++ extensions and some information on which Visual Studio
    versions you need for your Python version.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the inclusion of packages such as `pip` and `venv`, I feel that Python
    3 has become a complete package that should suit most people. Beyond legacy applications,
    there is no real reason not to choose Python 3 anymore. The initial Python 3 release
    in 2008 was definitely a bit raw compared to the well-rounded Python 2.6 version
    released the same year, but a lot has changed in that aspect. The last major Python
    2 release was Python 2.7, which was released in 2010; within the software world,
    that is a very, very long time. While Python 2.7 still receives maintenance, it
    will not receive any of the amazing new features that Python 3 is getting—features
    such as Unicode strings by default, `dict` generators ([Chapter 6](ch06.html "Chapter 6. Generators
    and Coroutines – Infinity, One Step at a Time"), *Generators and Coroutines –
    Infinity, One Step at a Time*), and `async` methods ([Chapter 7](ch07.html "Chapter 7. Async
    IO – Multithreading without Threads"), *Async IO – Multithreading without Threads*).
  prefs: []
  type: TYPE_NORMAL
- en: After finishing this chapter, you should be able to create a clean and recreatable
    virtual environment and know where to look if an installation of C/C++ packages
    fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the most important notes for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: For a clean and simple environment, use `venv`. If compatibility with Python
    2 is needed, use `virtualenv`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If C/C++ packages fail to install, look for the error about missing includes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next chapter covers the Python style guide, which rules are important, and
    why they matter. Readability is one of the most important aspects of the Python
    philosophy, and you will learn methods and styles for writing cleaner and more
    readable Python code.
  prefs: []
  type: TYPE_NORMAL
