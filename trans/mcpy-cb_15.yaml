- en: Coding on the Adafruit HalloWing Microcontroller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create a joke-telling machine. We will use the Adafruit
    HalloWing M0 Express board that comes with a full color TFT display and capacitive
    touch sensors. Each time you press the touch button, a new joke riddle will be
    presented. You can try and figure out the answer to the riddle and when you are
    ready, touch the button to show the answer to the riddle. Pressing the touch button
    again randomly selects a new riddle and starts another game.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will be a useful source of information and help you build projects
    that let you leverage the power of a full color screen with a good enough resolution
    to present multi-line text and full color graphical images.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following recipe in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Discovering I2C devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading data from the accelerometer using I2C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting board-flipping with the accelerometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling screen brightness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a bitmap image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing all image files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a joke-telling machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Adafruit HalloWing M0 Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Adafruit HalloWing is a microcontroller with a built-in 1.44 inch 128 x
    128 full-color TFT display. The software for displaying images fully supports
    displaying full color bitmap image files. With 8 MB storage on the device, this
    gives you plenty of space to store and display a large number of images. The board
    also comes equipped with a 3-axis accelerometer, light sensor, and 4 capacitive
    touchpads. The following screenshot shows the TFT screen displaying a bitmap image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/147b6ec4-61e4-4d56-a458-7865333945e9.png)'
  prefs: []
  type: TYPE_IMG
- en: The board can be powered by a portable power source. It supports both rechargeable
    lithium-ion polymer batteries and a USB portable power bank.
  prefs: []
  type: TYPE_NORMAL
- en: Where to buy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Adafruit HalloWing M0 Express board can be purchased directly from Adafruit
    ([https://www.adafruit.com/product/3900](https://www.adafruit.com/product/3900)).
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter can be found in the `Chapter15` folder of this
    book's GitHub repository, at [https://github.com/PacktPublishing/MicroPython-Cookbook](https://github.com/PacktPublishing/MicroPython-Cookbook).
  prefs: []
  type: TYPE_NORMAL
- en: This chapter uses the Adafruit HalloWing M0 Express board, loaded with the CircuitPython
    firmware. CircuitPython version 4.0.0-rc.1 was used for all the recipes in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You may download the firmware image from [https://circuitpython.org/board/hallowing_m0_express/](https://circuitpython.org/board/hallowing_m0_express/).
  prefs: []
  type: TYPE_NORMAL
- en: Many of the recipes in this chapter require a set of bitmap images to be transferred
    to the Adafruit HalloWing device. They can all be downloaded from the `Chapter15`
    folder in this book's GitHub repository. They should be saved in the top-level
    folder, along with your `main.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering I2C devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to scan for I2C devices connected to the bus using
    the `i2c` object. The I2C protocol supports multiple devices being connected to
    a single I2C connection. One of the first steps in connecting to a device is to
    scan and list all detected devices. This recipe will help you troubleshoot an
    I2C device to confirm that it is connected and can be found in scans. It can also
    help you build Python scripts that can automatically scan and detect multiple
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Adafruit HalloWing board to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to discover I2C devices:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The required libraries will have been imported. Run the following line of code
    to create the `i2c` object that will be used for scanning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines of code will keep looping until a lock is acquired on the
    I2C bus:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code performs a scan and lists all detected devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can perform the scan again and convert the returned device addresses into
    hex format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When this script is executed, it will print out the addresses of all discovered
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main function sets up the `i2c` object. The `try_lock` method is then repeatedly
    called until a lock is acquired. This lock is needed to perform a scan on the
    I2C bus. The `scan` method is then called, which returns a list of device addresses.
    Each address is then converted into hex notation and saved as a list of strings
    in the device's variable. Finally, the contents of this variable are output with
    a message, indicating that this is the list of devices that were discovered on
    the bus.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some I2C operation, such as scanning, require a lock. If you try and perform
    a scan without first acquiring a lock, you will get a runtime error indicating
    that this function requires a lock. In the next recipe, we will see that there
    are other operations that don't require a lock. The addresses of I2C are frequently
    referred to using hex notation, and this is the reason why we converted the value
    from an integer into a hex value.
  prefs: []
  type: TYPE_NORMAL
- en: The Adafruit HalloWing M0 Express board comes with one I2C device—an accelerometer—which
    should have the address `0x18`. Our scans confirm that. If you're not sure of
    the specific address value for your device, you can use the scan method to detect
    these values.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `scan` method can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/busio/I2C.html#busio.I2C.scan](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/busio/I2C.html#busio.I2C.scan).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on a project that uses the accelerometer on the Adafruit HalloWing
    board can be found at [https://learn.adafruit.com/hallowing-magic-9-ball/](https://learn.adafruit.com/hallowing-magic-9-ball/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading data from the accelerometer using I2C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to connect to the onboard accelerometer using
    the I2C protocol. Once we have an I2C object, we will use the Python `adafruit_lis3dh`
    library to create a `LIS3DH_I2C` object. This object will let us read live sensor
    data from the accelerometer. This recipe will help you whenever you want to create
    a project that uses board's orientation to create an interactive experience. You
    could, for example, create a project that reacts to the board being shaken by
    changing the image that's currently being displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Adafruit HalloWing device to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to read data from the accelerometer using I2C:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following block of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The required libraries have now been imported, and the accelerometer address
    has been defined in the `ACCEL_ADDRESS` constant. Run the following block of code
    to create an `i2c` object and use that object to create a `LIS3DH_I2C` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will fetch accelerometer orientation data and display
    its values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also access specific information, such as the *x* axis orientation data,
    using the following block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following loop is used to print the live accelerometer sensor data every
    0.1 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When this script is executed, it will print sensor data from the accelerometer
    every 0.1 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ACCEL_ADDRESS` constant contains the address for the accelerometer on the
    Adafruit HalloWing M0 Express board. Once we've created an `i2c` object, we take
    it and the `ACCEL_ADDRESS` to create a `LIS3DH_I2C` object, which we will save
    in a variable called `accel`. An infinite loop is started that reads the sensor
    data from the accelerometer on each iteration and prints them out. The loop then
    waits for a 0.1 second delay before starting the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The name of the accelerometer that's used on the Adafruit HalloWing device is
    called LIS3DH, which is why the Python library that knows how to speak to this
    device is called `adafruit_lis3dh`. This sensor can be used to detect both the
    orientation and acceleration of the board. In the next recipe, we will use this
    orientation data to detect when the board has been flipped over.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the LIS3DH accelerometer can be found at [https://www.st.com/en/mems-and-sensors/lis3dh.html](https://www.st.com/en/mems-and-sensors/lis3dh.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `LIS3DH_I2C` object can be found at [https://circuitpython.readthedocs.io/projects/lis3dh/en/latest/api.html#adafruit_lis3dh.LIS3DH_I2C](https://circuitpython.readthedocs.io/projects/lis3dh/en/latest/api.html#adafruit_lis3dh.LIS3DH_I2C).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting board-flipping with the accelerometer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to create a function that detects when the board
    is flipped over. To achieve this, we will use the orientation data that we fetched
    from the accelerometer. We will focus on the *z* axis data as this will indicate
    whether the board is facing up or facing down. The approach presented in this
    recipe can be useful to you whenever you are creating a project and want to find
    a more creative way of interacting with the project than just pushing buttons.
    This can create a fun level of interaction when someone discovers that all they
    have to do is flip over your board to interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Adafruit HalloWing device to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how you can detect board flipping with the accelerometer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the REPL to run the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The required libraries have been imported and constantly defined. Run the following
    block of code to create the `i2c` and `LIS3DH_I2C` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now inspect the *z* axis orientation data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Flip the board so that its display is face-down and then run the following
    block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The orientation value of the *z* axis will be a positive or negative number,
    depending on whether the board is face-up or face-down. Execute the following
    block of code to calculate this value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following block of code while you flip the board between face-down
    and face-up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When this script is executed, it will print whether the board is facing up or
    down every 0.1 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the `i2c` and `accel` variables are set up, we can then start accessing
    the orientation data from the accelerometer. When the board is facing up, the
    `z` value will be a negative number, and when the board is facing down, the `z`
    value will be a positive number. We can use this piece of information to calculate
    whether the board is facing up or down. An infinite loop is started and the variable
    face has `up` or `down` values saved to it, depending on the board's current orientation.
    This information is then printed while the loop waits for a 0.1 second delay before
    starting the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe showed you how you can use one piece of information from the accelerometer
    to detect a change in the physical orientation of the board. Once we've detected
    this change, we can make the script change its output, for example, whenever the
    board's face value changes. The accelerometer is also accurate enough to provide
    the angle the board is pointed at in reference to the *z* axis. We can use this
    information to change the behavior of our application, depending on how far the
    board is tilted in a certain direction.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on how accelerometers detect orientation can be found at [https://ieeexplore.ieee.org/document/1241424](https://ieeexplore.ieee.org/document/1241424).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `acceleration` attribute can be found at [https://circuitpython.readthedocs.io/projects/lis3dh/en/latest/api.html#adafruit_lis3dh.LIS3DH.acceleration](https://circuitpython.readthedocs.io/projects/lis3dh/en/latest/api.html#adafruit_lis3dh.LIS3DH.acceleration).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling screen brightness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to control the brightness level on the TFT display
    that comes with the Adafruit HalloWing device. The brightness can be set to the
    maximum level or to lower levels by providing a fractional value between 0 and
    1\. The brightness setting can also be used to turn off the display by setting
    the brightness level to 0\. This recipe can be useful to you in projects where
    you don't want the screen on all the time, and want to turn it on and off. It
    can also be helpful when you want to tweak the brightness levels of the backlight
    to a lower level to reduce power consumption.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Adafruit HalloWing device to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to control the Adafruit HalloWing device''s
    screen brightness:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The required libraries have been imported you can run the following block of
    code to set the brightness level to 50%:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will turn of the display by setting brightness
    to 0%:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now set the brightness to the maximum level with the following block
    of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function will take the brightness from the lowest level to the
    maximum level over 11 iterations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following block of code. You should see the display fade up to maximum
    brightness:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When this script is executed, it will fade the screen from black to full brightness,
    with a 0.1 second delay between each fade.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main function starts an infinite loop that repeatedly calls the `fade_in`
    function. Each call to the `fade_in` function will start a `for` loop that loops
    over 11 brightness values. The values vary, from the display being off to setting
    the display to its maximum brightness. The brightness level is calculated for
    each iteration and stored in the brightness variable. The value is printed and
    then applied to the brightness attribute on the `DISPLAY` object. A sleep of 0.1
    second is then applied before the next iteration of the fade in the loop is applied.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe demonstrates how easy it is to set the brightness level of the display.
    It also shows you how screen effects such as fading the screen in and out can
    also be implemented in Python. The brightness attribute can be particularly useful
    when you want to turn off the display by switching the backlight of the display
    off. You might create a battery-operated device that can use this technique to
    optimize power consumption.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: An example of controlling screen brightness can be found at [https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/OnDiskBitmap.html](https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/OnDiskBitmap.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details on the TFT display on the Adafruit HalloWing device can be found at
    [https://learn.adafruit.com/adafruit-hallowing?view=all#tft-2-18](https://learn.adafruit.com/adafruit-hallowing?view=all#tft-2-18).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a bitmap image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to create a function that receives the path to
    a bitmap image, takes this image, and displays it on the HalloWing screen. There
    are many different objects and options available for manipulating the contents
    of the screen. We will have to interact with a number of these different objects,
    even when we just want to show a single image. This recipe gives you an insight
    into what is involved in getting an image rendered on the board's screen. This
    recipe can be helpful if you are using the HalloWing device for projects that
    need to display different images and you want a straightforward way to change
    the currently displayed image.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Adafruit HalloWing device to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to display a bitmap image on the HalloWing
    device''s screen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following block of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The necessary objects from the `displayio` module have now been imported. Run
    the following block of code to open a file object as a binary stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use this file object to create our bitmap object and then prepare the
    `pixel_shader` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'These two objects are then used as arguments for creating a `TileGrid` object
    called `sprite`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code creates a group object and appends the `sprite`
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the following block of code to show this group on the display and
    call `wait_for_frame` to make the block of code wait until the display has been
    fully updated. Now, we will close the file object as it is no longer needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following block of code to define the `show_image` function and call
    it to show a different image on the display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When this script is executed, it will repeatedly change the image being displayed
    between two different bitmaps.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `show_image` function in this recipe does all the heavy lifting of displaying
    the bitmap on the screen. It receives one argument, which is the path to the bitmap
    file. This file is opened for reading and then used to create an `OnDiskBitmap`
    object called bitmap.
  prefs: []
  type: TYPE_NORMAL
- en: The `ColorConverter` object is used to create the `pixel_shader` variable. A
    `TileGrid` object is created and requires the bitmap to be displayed, as well
    as the pixel shader that will be used. Both of these arguments are provided and
    the new `TileGrid` object is saved in the sprite variable. The sprite variable
    cannot be given directly to the `DISPLAY` object, so we must create a `Group`
    object and append the sprite to it.
  prefs: []
  type: TYPE_NORMAL
- en: We can now call the show method on the `DISPLAY` object to show the `group`
    variable. The `wait_for_frame` method is called to make sure that the image is
    fully displayed on the screen before continuing. The main function starts an infinite
    loop that repeatedly calls `show_image` to continuously change the currently displayed
    image.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of different types of objects that need to be employed to display
    a bitmap image on the HalloWing device. Part of the reason for this is that each
    object provides a wide variety of flexibility in terms of how the image is displayed
    on the screen. You can, for example, control the *x* and *y* coordinates of an
    image or use other bitmap objects that don't come from files.
  prefs: []
  type: TYPE_NORMAL
- en: The display can display images with a resolution of up to 128 x 128, saved in
    the 24-bit pixel BMP file format. You can use the open source GIMP image editor
    to create these images.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create a new image in the GIMP application, you should set the correct
    resolution, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/71187889-9643-49fd-b1a2-31085a1b88a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you are ready to save the image, use the Export function in the file menu
    and save your image in BMP file format. When you do this, make sure you select
    the correct bits per pixel setting, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9f973955-24eb-4610-8356-4b5f357d9dbf.png)'
  prefs: []
  type: TYPE_IMG
- en: It's important to know that you can also use images of a smaller resolution,
    and that this will be automatically detected and correctly displayed on the screen.
    Smaller images also tend to be displayed on the screen faster.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Downloads for the GIMP image editor can be found at [https://www.gimp.org/](https://www.gimp.org/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `OnDiskBitmap` object can be found at [https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/OnDiskBitmap.html](https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/OnDiskBitmap.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing all image files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to list all the image files in a specific directory.
    In the joke-telling machine, we are creating each joke question and response as
    a pair of images. This recipe will allow you to list all your bitmap images on
    the board. We will then extend this functionality to filter the list further and
    have all the bitmap images of the joke questions at hand. This recipe can be useful
    in any project that you create where you want to retrieve a list of images to
    display or audio files or play in your project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Adafruit HalloWing device to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to list image files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the REPL to run the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now retrieved and output a sorted list of all the paths on the board''s
    root directory. We will use the following block of code to list only bitmap image
    files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can extend this further and only list joke question image files, as shown
    in the following block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will select the first question image and save it
    to a variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code can be used to calculate the name of a joke''s
    response image based on the question image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the following block of code to confirm that the calculated response
    image exists as a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When this script is executed, it will list all question images and calculate
    their related response images.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `get_questions` function in this recipe saves a sorted list of filenames
    in the `paths` variable. It then filters the listing to only include the question
    images by checking whether the `question.bmp` string appears in the filename.
    This filtered list is then returned by the function.
  prefs: []
  type: TYPE_NORMAL
- en: The main function calls the `get_questions` function and saves its results to
    the `questions` variable. Each question is looped through and has its response
    image calculated when we replace the `question.bmp` value with `response.bmp`
    in the filename. Both the question and response filenames are then printed before
    the next iteration of the loop commences.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A number of images will be used to create the joke-telling machine. We could
    have saved the names of the necessary images in the script itself, instead of
    directly listing them in the filesystem. But the approach taken in this recipe
    is better because it avoids us having to hardcode the image list directly in our
    application. This means that we can have 5 jokes or even 50 on the board without
    us having to change our application's code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time we start the joke-telling machine, it will automatically grab the
    latest listing of joke images. The following screenshot shows the joke question
    and the responses that will be used in the next recipe to create the joke-telling
    machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ae0c3e94-3e8b-43bf-b075-d12389207c90.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the filenames follow a simple naming convention to make it
    easy for you to see each question and response when they're viewed in an image
    viewer. This naming convention also makes it an easy process to calculate the
    related response image for a specific question image.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the BMP file format can be found at [https://www.fileformat.info/format/bmp/egff.htm](https://www.fileformat.info/format/bmp/egff.htm).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details on using bitmap images on the HalloWing device can be found at [https://learn.adafruit.com/hallowing-badge/hallowing-badge-and-image-player](https://learn.adafruit.com/hallowing-badge/hallowing-badge-and-image-player).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a joke-telling machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to list all the image files in a specific directory.
    In the joke-telling machine we are creating, each joke question and response will
    be provided as a pair of images. This recipe will show us how to list all our
    bitmap images on the board.
  prefs: []
  type: TYPE_NORMAL
- en: We will then extend this functionality to further filter the list so that we
    have all the bitmap images of the joke questions at hand. This recipe will help
    you if you want to create a project where you want to retrieve a list of images
    or audio files so that you can display or play them in your project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Adafruit HalloWing device to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to create a joke-telling machine:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now imported all the necessary modules. The following block of code
    will create a `TouchIn` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following block of code, we will check the status of the touchpad:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Touch the pad while executing the following block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will define the `wait_for_touch` function, which
    will keep looping until a touch event is detected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the following block of code to call `wait_for_touch`. After executing
    this function, wait a few moments before touching the pad to confirm that the
    function returns from its `while` loop once it detects the touch event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will save the list of question images in the `questions`
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the following block of code to randomly select a question from
    the questions list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: When this script is executed, it will start the joke-telling machine and let
    you see joke questions and responses on the display each time you press the touchpad.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `main` function creates a `TouchIn` object that's connected to the first
    touchpad connector on the board. The list of question images is retrieved by calling
    the `get_questions()` function and saving the returned list in the `questions`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: An infinite event loop is then started, which first selects a random question
    and calculates the associated response image for that question. The question image
    is then displayed on the screen by calling the `show_image` function. The `wait_for_touch`
    function is then called, which loops and checks for a touch event every 100 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Once a touch event is detected, the function is returned, and then the `show_image`
    function is called to show the response image. The `wait_for_touch` function is
    called again so that the user can see the response before deciding to load another
    question by pressing the touchpad. Once the touchpad is pressed, the current loop
    iteration ends and the process starts again with a new, randomly selected question.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The joke-telling machine is a fun way to use the input and output potential
    of this board. It uses the board's graphical display to show the different joke
    questions and responses, as well as the capacitive touch sensors as input to make
    the application load the next question or show the answer to a loaded question.
  prefs: []
  type: TYPE_NORMAL
- en: This base recipe can be extended in many ways. Since the board comes with four
    touchpads, you could create a simple menu system where people can choose from
    different categories of jokes. You could even create a project for digital dice
    by having images of the six sides of a die and showing a random side each time
    the touchpad is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `ColorConverter` object can be found at [https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/ColorConverter.html](https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/ColorConverter.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `TileGrid` object can be found at [https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/TileGrid.html](https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/TileGrid.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
