- en: Testing, Debugging, and Scheduling Concurrent Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the process of using concurrent Python programs
    on a higher level. First, you will learn about scheduling Python programs to be
    run concurrently at a later time—either once, or periodically. We will analyze APScheduler,
    a Python library that allows us to do this on a cross-platform basis. Furthermore,
    we will go over testing and debugging, which are essential yet are often overlooked
    components of programming. Given the complexities of concurrent programming, testing
    and debugging are even more difficult than in traditional applications. This chapter
    will cover a number of strategies for the effective testing and debugging of concurrent
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The APScheduler library and its usage in concurrently scheduling Python applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different testing techniques for Python programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging practices in Python programming, as well as concurrency-specific debugging
    techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a list of prerequisites for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that you have Python 3 installed on your computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that you have the `apscheduler` and `concurrencytest` libraries installed
    with your Python distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the GitHub repository at [https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During this chapter, we will be working with the subfolder named `Chapter19`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out the following video to see the Code in Action: [http://bit.ly/2OZdOZc](http://bit.ly/2OZdOZc)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling with APScheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**APScheduler** (short for **Advanced Python Scheduler**) is an external Python
    library that supports the scheduling of Python code to be executed later, either
    once or periodically. This library gives us high-level options to dynamically
    add/remove jobs to/from the job list so they can be scheduled and executed, as
    well as to decide how to distribute those jobs to different threads and processes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some might think of Celery ([http://www.celeryproject.org/](http://www.celeryproject.org/))
    as the go-to scheduling tool for Python. However, while Celery is a distributed
    task queue with basic scheduling capabilities, APScheduler is quite the opposite:
    a scheduler with basic task queuing options and advanced scheduling functionalities.
    Additionally, users of both tools have reported that APScheduler is easier to
    set up and implement.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing APScheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with most common Python external libraries, APScheduler can be installed
    via the package manager, `pip`, by running the following command in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to install this library, if the `pip` command does not work, is
    to manually download the source code from PyPI, which can be found at [pypi.org/project/APScheduler/](https://pypi.org/project/APScheduler/).
    The downloaded file can then be extracted and installed by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As always, to test whether your APScheduler distribution has been correctly
    installed, open a Python interpreter and try to import the library, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If no errors are returned, it means that the library has been completely installed
    and is ready to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Not a scheduling service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the term scheduler can be quite misleading to specific groups of developers,
    let's clarify the functionalities that APScheduler provides, as well as what it
    does not provide. First and foremost, the library can be used as a cross-platform
    scheduler that is also application-specific, as opposed to more common schedulers
    that are platform-specific, such as the cron daemon (for Linux systems) or the
    Windows task scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that APScheduler is not, in itself, a scheduling service
    that has a prebuilt GUI or command-line interface. It is still a Python library
    that has to be imported and utilized inside existing applications (that is why
    it is application-specific). However, as you will learn later on, APScheduler
    comes with numerous functionalities that can be leveraged to build an actual scheduling
    service.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the ability to schedule jobs (specifically, background ones) is
    essential for web applications nowadays, as they can include different but important
    functionalities, such as sending emails or backing up and synchronizing data.
    In that context, APScheduler is arguably the most common tool to schedule tasks
    for cloud applications that involve Python instructions, such as Heroku and PythonAnywhere.
  prefs: []
  type: TYPE_NORMAL
- en: APScheduler functionalities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s explore some of the most common functionalities provided by the APScheduler
    library. Execution-wise, it offers three different scheduling mechanisms, so that
    one can choose the mechanism that is most suitable for one''s applications (these
    mechanisms are also sometimes called event triggers):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cron-style scheduling**: This mechanism allows jobs to have prespecified
    start and end times'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interval-based execution**: This mechanism runs jobs at even intervals (for
    example, every two minutes, every day), with optional start and end times'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delayed execution**: This mechanism allows the application to wait for a
    specific period of time before executing items in the job list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, APScheduler allows us to store jobs to be executed in various backend
    systems, such as regular memory, MongoDB, Redis, RethinkDB, SPLAlchemy, or ZooKeeper.
    Whether it is a desktop program, a web application, or simply a Python script,
    APScheduler is most likely to be able to work with how scheduled jobs are stored.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to that, the library can also work seamlessly with common Python
    concurrency frameworks, such as AsyncIO, Gevent, Tornado, and Twisted. This means
    that the low-level code included in the APScheduler library contains instructions
    that can cohesively schedule and execute functions and programs implemented in
    these frameworks, making the library even more dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, APScheduler provides different options to actually execute the scheduled
    code, by specifying the appropriate executor(s). Specifically, one can simply
    execute jobs normally, in a blocking way or in the background. We also have the
    option to use a pool of threads or processes to distribute the work in a concurrent
    way. Later on, we will look at an example where we utilize a process pool to execute
    scheduled jobs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram maps out all of the major classes and functionalities
    included in APScheduler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d409ecad-f11f-446f-831b-fbcbcc1cc188.png)'
  prefs: []
  type: TYPE_IMG
- en: APScheduler—main classes and functionalities
  prefs: []
  type: TYPE_NORMAL
- en: APScheduler API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at how to actually integrate APScheduler into
    existing Python programs, by analyzing the different classes and methods provided
    by the library. We will also look at how jobs are distributed across different
    threads and processes, when we utilize a concurrent executor to run our scheduled
    jobs.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduler classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s look at the options available for our main scheduler, which is
    the most important component in the process of scheduling tasks to be executed
    at a later time:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BlockingScheduler`: This class should be used when the scheduler is intended
    to be the only task running in the process. As the name suggests, an instance
    of this class will block any other instructions in the same process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BackgroundScheduler`: As opposed to `BlockingScheduler`, this class allows
    scheduled jobs to be executed in the background, inside an existing application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, there are also scheduler classes to be used if your application
    utilizes specific concurrency frameworks: `AsyncIOScheduler` for the `asyncio`
    module; `GeventScheduler` for Gevent; `TornadoScheduler` for Tornado applications;
    `TwistedScheduler` for Twisted applications; and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Executor classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another important choice to be made during the process of scheduling jobs to
    be executed at a later time is: Which executor(s) should run the jobs? Generally,
    the default executor, `ThreadPoolExecutor`, which distributes the work across
    different threads in the same process, is recommended. However, as you have learned,
    if the scheduled jobs contain instructions that utilize CPU-intensive operations,
    then the workload should be distributed across multiple CPU cores, and `ProcessPoolExecutor`
    should be utilized.'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that these two executor classes interact with the `concurrent.futures`
    module that we discussed in earlier chapters, in order to facilitate concurrent
    execution. The default number of maximum workers for both executor classes is
    `10`, and can be changed upon initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Trigger keywords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last decision in the process of building a scheduler is how scheduled jobs
    should be executed in the future; this is the event-trigger option we mentioned
    earlier. APScheduler provides three different triggering mechanisms; the following
    keywords should be passed as an argument to the scheduler initializer, in order
    to specify the event trigger type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''date''`: This keyword is used when the job is to be run once, at a specific
    point in the future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''interval''`: This is keyword is used when the job is to be run at fixed
    intervals of time. We will be using this keyword in our examples later on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''cron''`: This keyword is used when the job is to be periodically run at
    a certain time of day.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, it is possible to mix and match multiple types of trigger. We
    also have the option to have scheduled jobs executed either when all registered
    triggers so specify, or when at least one of them does.
  prefs: []
  type: TYPE_NORMAL
- en: Common scheduler methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, let''s consider the methods that are commonly used when declaring
    a scheduler, in addition to the preceding classes and keywords. Specifically,
    the following methods are called by `scheduler` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add_executor()`: This method is called to register an executor to run jobs
    in the future. Specifically, we typically pass the string `''processpool''` to
    this method to have the jobs be distributed across multiple processes. Otherwise,
    as mentioned, as thread pool will be used a the default executor. This method
    also returns an executor object that can be manipulated further.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove_executor()`: This method is used on an executor object, to remove it
    from a scheduler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add_job()`: This method can be used to add an additional job to the job list,
    to be executed later. The method first takes in a callable that is the new job
    in the job list, and various other arguments that are used to specify how the
    job should be scheduled and executed. Similar to `add_executor()`, this method
    can return a `job` object that can be manipulated outside the method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove_job()`: Similarly, this method can be used on a `job` object, to remove
    it from a scheduler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start()`: This method starts scheduled jobs along with implemented executors,
    and begins to process the job list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shutdown()`: This method stops the calling scheduler object, along with its
    job list and implemented executors. If it is called when there are current jobs
    running, those jobs will not be interrupted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this subsection, we will look at how some of the APIs that we discussed are
    used in sample Python programs. Download the code for this book from the GitHub
    page, then go ahead and navigate to the `Chapter19` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking scheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s take a look at an example of a blocking scheduler in the `Chapter19/example1.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are implementing a scheduler for the `tick()` function specified
    in the preceding code, which simply prints out the current time at which it is
    executed. In our main function, we are using an instance from the `BlockingScheduler`
    class, imported from APScheduler, as our scheduler for this program. In addition
    to this, the aforementioned `add_job()` method is used to register `tick()` as
    a job to be executed later. Specifically, it should be executed periodically,
    at even intervals (specified by the `'interval'` string passed in)—particularly,
    every three seconds (specified by the argument `seconds=3`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that a blocking scheduler will block all other instructions in the same
    process that it runs in. To test this, we are also inserting a `print` statement,
    right after starting the scheduler, to see whether it will be executed. After
    running the script, your output should look similar to the following (except for
    the specific times that are being printed out):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this scheduler will run forever, unless it is stopped by a `KeyboardInterrupt`
    event or other potential exceptions, and the printing statement that we placed
    near the end of the main program will never be executed. For this reason, the
    `BlockingScheduler` class should only be used when it is intended to be the only
    task running in its process.
  prefs: []
  type: TYPE_NORMAL
- en: Background scheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will look at whether the use of the `BackgroundScheduler`
    class would help if we wanted to execute our scheduler in the background, concurrent
    with other tasks. The code for this example is included in the `Chapter19/example2.py`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The code in this example is almost identical to what we had previously. However,
    here, we are using the class for background schedulers, as well as printing out
    messages from the main program every two seconds, in an infinite `while` loop.
    Theoretically, if the `scheduler` object can indeed run the scheduled job in the
    background, our output will consist of a combination of print statements, in both
    the main program and the `tick()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is my output, after executing the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the scheduler will continue on forever, until an interruption from the
    keyboard is evoked. Here, we can see what we expected to see: print statements
    from the main program and the scheduled job are produced concurrently, indicating
    that the scheduler was indeed running in the background.'
  prefs: []
  type: TYPE_NORMAL
- en: Executor pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One additional functionality offered by APScheduler is the ability to distribute
    scheduled jobs to be executed across multiple CPU cores (or processes). In this
    example, you will learn how to do that with a background scheduler. Navigate to
    the `Chapter19/example3.py` file and inspect the included code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this program, the job that we would like to schedule (the `task()` function)
    prints out the identifier of the process that is running it at each call (using
    the `os.getpid()` method) and is designed to last for around four seconds. In
    the main program, we are using the same background scheduler we used in the last
    example, but we are specifying that scheduled jobs should be executed in a pool
    of processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that the default value of the number of processes in this pool is
    10, and can be changed to a different value. Next, as we add the job to the scheduler,
    we also have to specify that this job can be executed in more than one process
    instance (in this case, three instances); this allows our process pool executor
    to be utilized fully and efficiently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The first few lines of my output, after running the program, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the printed process identifiers, the scheduled job was being
    executed in different processes. You will also notice that the ID of the first
    process was `1213`, and, as soon as our scheduler started to use the process with
    the ID of `1222`, it then switched back to the `1213` process (notice the last
    few lines of the preceding output). This is because our process pool contains
    10 workers, and the `1222` process was the last element of the pool.
  prefs: []
  type: TYPE_NORMAL
- en: Running on the cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier, we mentioned that cloud services that host Python code, such as Heroku
    and PythonAnywhere, are some of the most common places to apply APScheduler''s
    functionalities. In this subsection, we will look at one example from the user
    guide on the Heroku website, which can be found in the `Chapter19/example4.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can see that this program uses decorators to register scheduled jobs for
    the scheduler. Specifically, when the `scheduled_job()` method is called by a
    `scheduler` object, that whole instruction can be used as a decorator for a function,
    to convert it to a scheduler job for that scheduler. You can also see an example
    of a `cron` scheduled job in the preceding code, which can be executed at specific
    times of day (in this case, it is every weekday at 5:00 p.m.).
  prefs: []
  type: TYPE_NORMAL
- en: As a final note on APScheduler, we have seen that instructions utilizing the
    library API are also Python code, and not a separate service in itself. However,
    considering how flexible the library is in providing different scheduling options
    and how pluggable its programs are in terms of working with external services
    (such as cloud-based ones), APScheduler is a valuable tool for scheduling Python
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and concurrency in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned previously, testing is an essential (yet often overlooked) component
    of software development specifically, and programming in general. The goal of
    testing is to evoke errors that would indicate the existence of bugs in our programs.
    This is to be contrasted with the process of debugging, which is used to identify
    the bugs themselves; we will discuss the topic of debugging in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: In the most general sense, testing is about determining whether specific functions
    and methods can perform and produce results that we intend them to; this is typically
    done by comparing the results that are produced. In other words, testing is collecting
    evidence as to the correctness of our programs.
  prefs: []
  type: TYPE_NORMAL
- en: However, testing cannot ensure that all potential defects and bugs in the program
    under consideration will be identified. Additionally, the test results are only
    as good as the tests themselves, and if the tests do not cover some specific potential
    bugs, then those bugs will most likely not be detected during the testing process.
  prefs: []
  type: TYPE_NORMAL
- en: Testing concurrent programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will consider two distinct topics of testing, with regard
    to concurrency: **testing concurrent programs** and **testing programs concurrently**.
    When it comes to testing concurrent programs, the general consensus is that it
    is extremely demanding and difficult to get right. As you saw in previous chapters,
    bugs such as deadlocks or race conditions can be quite subtle in a concurrent
    program, and can manifest themselves in many ways.'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, one distinct feature of concurrency is nondeterminism, which means
    that it is possible for a concurrency bug to be detected in one run of the test
    and become invisible in another. This is because a major component of concurrent
    programming is the scheduling of tasks, and, like the order in which different
    tasks are executed in a concurrent program, concurrency bugs can show and hide
    themselves in an unpredictable way. We call these tests non-reproducible, to indicate
    that we cannot reliably pass or fail a program with these tests in a consistent
    way.
  prefs: []
  type: TYPE_NORMAL
- en: With that said, there are some general strategies that can help us to navigate
    through the process of testing concurrent programs. In the following section,
    we will explore the various tools that can assist us with specific strategies
    for testing concurrent programs.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first strategy that we will consider is unit testing. The term indicates
    a method that tests for individual units of the program under consideration, where
    a unit is the smallest testable part of the program. For this reason, unit testing
    is not meant for testing a complete concurrent system. Specifically, it is recommended
    that you do not test a concurrent program as a whole, but that you break the program
    down into smaller components and test them separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, Python provides libraries that offer intuitive APIs to solve most
    common problems in programming; in this case, it is the `unittest` module. The
    module was originally inspired by the unit testing framework for the Java programming
    language JUnit; it also provides common unit testing functionalities in other
    languages. Let''s consider a quick example of how we can use `unittest` to test
    a Python function in the `Chapter19/example5.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we would like to test the `fib()` function that generates specific
    elements in the Fibonacci sequence (where an element is the sum of its two previous
    elements), whose starting values are `0` and `1`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's focus our attention on the `FibTest` class, which extends the `TestCase`
    class from the `unittest` module. This class contains different methods that test
    for specific cases of the results returned by the `fib()` function. Specifically,
    we have a method that looks at edge cases for this function, which are the first
    two elements of the sequence, and another method that tests for an arbitrary value
    in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the preceding script, your output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The output indicates that our tests passed without any errors. Additionally,
    as suggested by the class name, this class is an individual test case, which is
    a unit of testing. You can expand different test cases into a **test suite**,
    which is defined as a collection of test cases, test suites, or both. Test suites
    are generally used to combine tests that you would like to run together.
  prefs: []
  type: TYPE_NORMAL
- en: Static code analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another viable method to identify potential errors and bugs in your concurrent
    programs is to perform static code analysis. This method looks for patterns in
    the code itself, as opposed to executing some (or all) parts of the code. In other
    words, static code analysis inspects a program by visually looking at its structure,
    the use of variables and instructions, and how different parts of the program
    interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of using static code analysis is that we are not relying
    on just the execution of our programs and the results produced during that process
    (in other words, dynamic testing) to determine whether the programs are correctly
    designed. This method can detect errors and bugs that do not manifest themselves
    (easily, or at all) in implemented tests. For this reason, static code analysis
    should be combined with other testing methods, such as unit testing, to create
    a comprehensive testing process.
  prefs: []
  type: TYPE_NORMAL
- en: Static code analysis is often used to identify subtle errors or bugs, such as
    unused variables, empty catch blocks, or even unnecessary object creation. In
    terms of concurrent programming, the method can be used to analyze synchronization
    techniques used in a program. Specifically, static code analysis can look for
    the atomicity of shared resources in a program, then reveal any uncoordinated
    usage of non-atomic resources that could produce detrimental race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Various tools are available to facilitate static code analysis for Python programs,
    with one of the more common ones being PMD ([https://github.com/pmd/pmd](https://github.com/pmd/pmd)).
    With that said, the specific use of these tools is beyond the scope of this book,
    and we will not go into them further.
  prefs: []
  type: TYPE_NORMAL
- en: Testing programs concurrently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another aspect of combining testing and concurrent programming is performing
    tests in a concurrent way. This aspect of testing is more straightforward and
    intuitive than testing concurrent programs themselves. In this subsection, we
    will explore a library that can help us facilitate this process, `concurrencytest`,
    which can work seamlessly with test cases implemented with the preceding `unittest`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: '`concurrencytest` is designed as a `testtools` extension that implements concurrency
    in running test suites. It can be installed from PyPI, using `pip`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, `concurrencytest` is dependent on the `testtools` ([pypi.org/project/testtools/](https://pypi.org/project/testtools/))
    and `python-subunit` ([pypi.org/project/python-subunit/](https://pypi.org/project/python-subunit/))
    libraries, which are a test extension framework and a streamlining protocol for
    test results, respectively. These libraries can also be installed via `pip`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As always, to verify your installation, try to import the library in a Python
    interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Receiving no printed errors means that the library and its dependencies were
    installed successfully. Now, let''s look at how this library can help us to achieve
    better speed for our tests. Navigate to the `Chapter19/example6.py` file and consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The main goal of the examples in this section is testing the function that produces
    numbers in the Fibonacci sequence, specifically numbers with large indices. The
    `fib()` function that we have is similar to that of the previous example, although
    this one performs the calculation iteratively, without using recursion.
  prefs: []
  type: TYPE_NORMAL
- en: In our test case, aside from the two starting values, we are now testing numbers
    at indices 499,990, 499,995, and 500,000\. Since the resulting numbers are significantly
    large, we are only testing the last ten digits for each number (this is done via
    the `mod` attribute of the test class, specified in the initialization method).
    This testing process will be executed in one process, in a sequential way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the program, and your output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Again, the time specified in the output can vary from system to system. With
    that said, remember the amount of time that the program took, so that you can
    compare it with the speed of other programs that we will consider later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at how we can distribute the testing workload across multiple
    processes, with `concurrencytest`. Consider the `Chapter19/example7.py` file,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This version of the program is examining the same `fib()` function, using the
    same test case. However, in the main program, we are initializing an instance
    of the `ConcurrentTestSuite` class, from the `concurrencytest` library. This instance
    takes in a test suite, which was created using the `TestLoader()` API from the
    `unittest` module, and the `fork_for_tests()` function, with the parameter `4`,
    to specify that we want to utilize four separate processes to distribute the testing
    procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s run this program and compare its speed with that of our previous
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can see that a significant improvement in speed was achieved by this method
    of multiprocessing. However, this improvement does not fall around perfect scalability
    (discussed in [Chapter 16](132200fe-4caa-4848-9533-ce8c839af9af.xhtml), *Designing
    Lock-Based and Mutex-Free Concurrent Data Structures*); that is because there
    is significant overhead in creating concurrent test suites that can be executed
    across multiple processes.
  prefs: []
  type: TYPE_NORMAL
- en: One more thing that we should mention is that it is quite possible to achieve
    the same multiprocessing setup that we implemented here by using the traditional
    concurrent programming tools that we discussed in previous chapters, such as `concurrent.futures`
    or `multiprocessing`. With that said, the `concurrencytest` library, as we have
    seen, is able to eliminate significant boilerplate code, and thus provides an
    easy and fast API.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging concurrent programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last section, we will discuss the various advanced debugging strategies
    that can be used individually, or in combination with each other, to detect and
    pinpoint bugs in our programs. In general, the term **debugging** is used to denote
    the process in which programmers attempt to identify and resolve problems or defects
    that would otherwise cause the computer applications they reside in to produce
    incorrect results, or even stop functioning.
  prefs: []
  type: TYPE_NORMAL
- en: The strategies that we will discuss include general debugging strategies, as
    well as particular techniques used in debugging concurrent applications. A systematic
    application of these strategies would improve your debugging process, in terms
    of both effectiveness and speed.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging tools and techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s briefly look at some of the most common techniques and tools
    that can facilitate the debugging process in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Print debugging**: This is perhaps the most elementary and intuitive method
    of debugging. This method involves inserting print statements for the values of
    variables, or the states of functions, at various points in the execution of the
    considered program. Doing this allows us to keep track of how these values and
    states interact and change throughout the program, giving us insight into how
    particular errors or exceptions are raised.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logging**: In the field of computer science, logging is the process of recording
    various events that take place during the execution of a particular program. In
    essence, logging can be quite similar to print debugging; however, the former
    typically writes to a log file that can be viewed later on. Python offers excellent
    logging functionalities, included in the built-in `logging` module. Users can
    specify the level of importance for the logging process; for example, normally,
    one can log only important events and operations, but during debugging everything
    will be logged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tracing**: This is another form of keeping track of program execution. Tracing
    follows the actual low-level details of the program execution, as opposed to only
    changes in variables and functions. Tracing functionalities can be implemented
    via the `sys.settrace()` method in Python.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using a debugger**:Sometimes, the most powerful debugging options can be
    achieved via an automated debugger. The most popular debugger in the Python language
    is the Python debugger: `pdb`. This module provides an interactive debugging environment
    that implements useful functionalities, such as breakpoints, stepping through
    the source code, or inspecting the stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, the preceding strategies are applicable to both traditional and concurrent
    programs, and a combination of more than one of them can help programmers to obtain
    valuable information during the debugging process.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging and concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to the problem of testing concurrent programs, debugging, when applied
    to concurrency, can become increasingly complex and difficult. Again, this is
    due to the fact that shared resources can interact with (and be altered by) multiple
    agents, simultaneously. With that said, there are still strategies that can make
    the process of debugging concurrent programs more straightforward. These include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Minimization**:Concurrent applications are typically implemented in complex
    and interconnected systems. Debugging a whole system when an error occurs can
    be quite intimidating, and is not very feasible. The strategy is to isolate different
    parts of the system into individual, smaller programs, and identify the one that
    fails in the same way as for large systems. Here, we want to divide a large program
    into smaller and smaller parts, until they cannot be broken apart anymore. The
    original error can then be easily identified and efficiently fixed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single-threading and processing**:This method is similar to minimization,
    but focuses on only one aspect of concurrent programming: the interaction between
    different threads/processes. By eliminating the biggest aspect of concurrency
    in your concurrent programming, you can isolate errors to either the program logic
    itself (which can cause errors, even when running sequentially) or the interaction
    between threads/processes (which can result from the common concurrency bugs that
    we discussed in previous chapters).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manipulating scheduling to amplify potential bugs**: We have actually seen
    the application of this method in previous chapters. Some concurrency bugs do
    not manifest themselves often, if the threads/processes implemented in our program
    are not scheduled to execute in a specific way. For example, an existing race
    condition may not affect a shared resource if the interactions between it and
    other agents happen so fast that they do not overlap each other often. This leads
    to the fact that testing might not reveal a race condition, even though it actually
    exists in the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various methods can be implemented in Python so that incorrect values and operations
    resulting from concurrency bugs can be amplified. Two of the most common are fuzzing,
    achieved by inserting sleep functions between commands in thread/process instructions,
    and minimizing the system thread switching interval, achieved by using the `sys.setcheckinterval()`
    method (discussed in [Chapter 17](0c8ecb2f-a8ac-4196-9d1e-8b729ef5b67c.xhtml),
    *Memory Models and Operations on Atomic Types*). These methods disrupt the regular
    scheduling protocols of thread and process execution in Python in different ways,
    and can effectively reveal hidden concurrency bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we provided a high-level analysis of concurrent programs in
    Python, via scheduling, testing, and debugging. Scheduling can be done in Python
    via the APScheduler module, which provides powerful and flexible functionalities
    to specify how scheduled jobs should be executed later on in the future. Furthermore,
    the module allows scheduled jobs to be distributed and executed across different
    threads and processes, offering a concurrency improvement in testing speed.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency also introduces complex problems in terms of testing and debugging,
    resulting from simultaneous and parallel interactions between the agents in a
    program. However, these problems can be approached effectively, with methodical
    solutions and the appropriate tools.
  prefs: []
  type: TYPE_NORMAL
- en: This topic marks the end of our journey through *Mastering Concurrency in Python*.
    Throughout this book, we have considered and analyzed various elements of concurrent
    programming with the Python language in depth, such as threading, multiprocessing,
    and asynchronous programming. Powerful applications involving concurrency, such
    as context management, reduction operations, image processing, and network programming,
    were also discussed, in addition to the common problems faced by programmers working
    with concurrency in Python.
  prefs: []
  type: TYPE_NORMAL
- en: In the most general sense, this book serves as a guide to some of the more advanced
    concepts of concurrency; it is my hope that, through reading this book, you have
    had the chance to become well versed in the topic of concurrent programming.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is APScheduler? Why isn't it a scheduling service?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the main scheduling functionalities of APScheduler?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the differences between APScheduler and another scheduling tool in
    Python, Celery?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the purpose of testing in programming? How is it different in concurrent
    programming?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What methods of testing were discussed in this chapter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the purpose of debugging in programming? How is it different in concurrent
    programming?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What methods of debugging were discussed in this chapter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Advanced Python Scheduler* ([apscheduler.readthedocs.io/en/latest/index](https://apscheduler.readthedocs.io/en/latest/index.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Scheduled Jobs with Custom Clock Processes in Python with APScheduler* ([devcenter.heroku.com/articles/clock-processes-python](https://devcenter.heroku.com/articles/clock-processes-python))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Architecture of APScheduler*, Ju Lin ([enqueuezero.com/apscheduler](https://enqueuezero.com/apscheduler.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ', Alex. *APScheduler 3.0 released*, Alex Grönholm ([alextechrants.blogspot.com/2014/08/apscheduler-30-released](http://alextechrants.blogspot.com/2014/08/apscheduler-30-released.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Testing Your Code* (*The Hitchhiker''s Guide to Python*), Kenneth Reitz'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Python – concurrencytest: Running Concurrent Tests*, Corey Goldberg ([coreygoldberg.blogspot.com/2013/06/python-concurrencytest-running](http://coreygoldberg.blogspot.com/2013/06/python-concurrencytest-running.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting Started With Testing in Python*, Anthony Shaw ([realpython.com/python-testing/](https://realpython.com/python-testing/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Tracing python code*, Andrew Dalke ([dalkescientific.com/writings/diary/archive/2005/04/20/tracing_python_code](http://www.dalkescientific.com/writings/diary/archive/2005/04/20/tracing_python_code.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
