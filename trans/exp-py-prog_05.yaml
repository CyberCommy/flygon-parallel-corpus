- en: Chapter 5. Writing a Package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter focuses on a repeatable process to write and release Python packages.
    Its intentions are:'
  prefs: []
  type: TYPE_NORMAL
- en: To shorten the time needed to set up everything before starting the real work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To provide a standardized way to write packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To ease the use of a test-driven development approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To facilitate the releasing process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is organized into the following four parts:'
  prefs: []
  type: TYPE_NORMAL
- en: A **common** **pattern** for all packages that describes the similarities between
    all Python packages, and how `distutils` and `setuptools` play a central role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What **namespace packages** are and why they can be useful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to register and upload packages in the **Python Package Index** (**PyPI**)
    with emphasis on security and common pitfalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **stand-alone executables** as an alternative way to package and distribute
    Python applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python packaging can be a bit overwhelming at first. The main reason for that
    is the confusion about proper tools for creating Python packages. Anyway, once
    you create your first package, you will see that this is not as hard as it looks.
    Also, knowing proper, state-of-the art packaging tools helps a lot.
  prefs: []
  type: TYPE_NORMAL
- en: You should know how to create packages even if you are not interested in distributing
    your code as open source. Knowing how to make your own will give you more insight
    into the packaging ecosystem and will help you to work with third-party code available
    on PyPI that you are probably using.
  prefs: []
  type: TYPE_NORMAL
- en: Also, having your closed source project or its components available as source
    distribution packages can help you to deploy your code in different environments.
    Advantages of leveraging the Python packaging ecosystem in code deployment will
    be described in more detail in the next chapter. Here we will focus on proper
    tools and techniques to create such distributions.
  prefs: []
  type: TYPE_NORMAL
- en: The confusing state of Python packaging tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The state of Python packaging was very confusing for a long time and it took
    many years to bring organization to this topic. Everything started with the `distutils`
    package introduced in 1998 that was later enhanced by `setuptools` in 2003\. These
    two projects started a long and knotted story of forks, alternative projects,
    and complete rewrites that tried to once and for all fix Python's packaging ecosystem.
    Unfortunately, most of these attempts never succeeded. The effect was quite the
    opposite. Each new project that aimed to supersede `setuptools` or `distutils`
    only added up to the already huge confusion around packaging tools. Some of such
    forks were merged back to their ancestors (like `distribute` that was a fork of
    `setuptools`) but some were left abandoned (like `distutils2`).
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, this state is gradually changing. An organization called **Python
    Packaging Authority** (**PyPA**) was formed to bring back the order and organization
    to the packaging ecosystem. **Python Packaging User Guide** ([https://packaging.python.org](https://packaging.python.org)),
    maintained by PyPA, is the authoritative source of information about the latest
    packaging tools and best practices. Treat it as the best source of information
    about packaging and a complementary reading to this chapter. The guide also contains
    a detailed history of changes and new projects related to packaging, so it will
    be useful if you already know a bit but want to make sure you still use the proper
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Stay away from other popular Internet resources, such as **The Hitchhiker's
    Guide to Packaging**. It is old, not maintained, and mostly obsolete. It may be
    interesting only for historical reasons and the Python Packaging User Guide is
    in fact a fork of this old resource.
  prefs: []
  type: TYPE_NORMAL
- en: The current landscape of Python packaging thanks to PyPA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PyPA, besides providing an authoritative guide for packaging, also maintains
    packaging projects and the standardization process for new official aspects of
    packaging. All of PyPA''s projects can be found under a single organization on
    GitHub: [https://github.com/pypa](https://github.com/pypa).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of them were already mentioned in the book. The most notable are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pip`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`virtualenv`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`twine`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`warehouse`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that most of them were started outside of this organization and only moved
    under PyPA patronage as mature and widespread solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to PyPA engagement, the progressive abandoning of the eggs format in
    favor of wheels for built distributions is already happening. The future may bring
    us even more fresh breath. PyPA is actively working on `warehouse`, which aims
    to completely replace current PyPI implementations. This will be a huge step in
    packaging history because `pypi` is so old and neglected a project that only a
    few of us can imagine gradually improving it without a total rewrite.
  prefs: []
  type: TYPE_NORMAL
- en: Tool recommendations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python Packaging User Guide gives a few suggestions on recommended tools for
    working with packages. They can be generally divided into two groups: tools for
    installing packages and tools for package creation and distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Utilities from the first group recommended by PyPA were already mentioned in
    [Chapter 1](ch01.html "Chapter 1. Current Status of Python"), *Current Status
    of Python*, but let''s repeat them here for the sake of consistency:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `pip` for installing packages from PyPI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `virtualenv` or `venv` for application-level isolation of the Python environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Python Packaging User Guide recommendations of tools for package creation
    and distribution are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `setuptools` to define projects and create **source distributions**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use **wheels** in favor of **eggs** to create **built distributions**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `twine` to upload package distributions to PyPI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It should be obvious that the easiest way to organize the code of big applications
    is to split it into several packages. This makes the code simpler, and easier
    to understand, maintain, and change. It also maximizes the reusability of each
    package. They act like components.
  prefs: []
  type: TYPE_NORMAL
- en: setup.py
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The root directory of a package that has to be distributed contains a `setup.py`
    script. It defines all metadata as described in the `distutils` module, combined
    as arguments in a call to the standard `setup()` function. Despite `distutils`
    is a standard library module, it is recommended that you use the `setuptools`
    package instead, which provides several enhancements to the standard `distutils`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the minimum content for this file is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`name` gives the full name of the package. From there, the script provides
    several commands that can be listed with the `–-help-commands` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The actual list of commands is longer and can vary depending on the available
    `setuptools` extensions. It was truncated to show only those that are most important
    and relevant to this chapter. **Standard** **commands** are the built-in commands
    provided by `distutils`, whereas **extra** **commands** are the ones created by
    third-party packages such as `setuptools` or any other package that defines and
    registers a new command. One such extra command registered by another package
    is `bdist_wheel` provided by the `wheel` package.
  prefs: []
  type: TYPE_NORMAL
- en: setup.cfg
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `setup.cfg` file contains default options for commands of the `setup.py`
    script. This is very useful if the process for building and distributing the package
    is more complex and requires many optional arguments to be passed to the `setup.py`
    commands. This allows you to store such default parameters in code on a per-project
    basis. This will make your distribution flow independent from the project and
    also provide transparency about how your package was built and distributed to
    the users and other team members.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for the `setup.cfg` file is the same as provided by the built-in
    `configparser` module so it is similar to the popular Microsoft Windows INI files.
    Here is an example of the setup configuration file that provides some `global`,
    `sdist`, and `bdist_wheel` command defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This example configuration will ensure that source distributions will always
    be created with two formats (ZIP and TAR) and built wheel distributions will be
    created as universal wheels (Python version independent). Also, most of output
    will be suppressed on every command by the global `quiet` switch. Note that this
    is only for demonstration purposes and it may not be a reasonable choice to suppress
    the output for every command by default.
  prefs: []
  type: TYPE_NORMAL
- en: MANIFEST.in
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When building a distribution with `sdist` command, `distutils` browses the
    package directory looking for files to include in the archive. `distutils` will
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: All Python source files implied by the `py_modules`, `packages`, and `scripts`
    options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All C source files listed in the `ext_modules` option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Files that match the glob pattern `test/test*.py` are: `README`, `README.txt`,
    `setup.py`, and `setup.cfg`.'
  prefs: []
  type: TYPE_NORMAL
- en: Besides, if your package is under subversion or CVS, `sdist` will browse folders
    such as `.svn` to look for files to include. Integration with other version control
    systems is also possible through extensions. `sdist` builds a `MANIFEST` file
    that lists all files and includes them into the archive.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say you are not using these version control systems, and need to include
    more files. Now you can define a template called `MANIFEST.in` in the same directory
    as that of `setup.py` for the `MANIFEST` file, where you indicate to `sdist` which
    files to include.
  prefs: []
  type: TYPE_NORMAL
- en: 'This template defines one inclusion or exclusion rule per line, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The full list of the `MANIFEST.in` commands can be found in official `distutils`
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Most important metadata
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Besides the name and the version of the package being distributed, the most
    important arguments `setup` can receive are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`description`: This includes a few sentences to describe the package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long_description`: This includes a full description that can be in reStructuredText'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keywords`: This is a list of keywords that define the package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`author`: This is the author''s name or organization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`author_email`: This is the contact e-mail address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url`: This is the URL of the project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`license`: This is the license (GPL, LGPL, and so on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`packages`: This is a list of all names in the package; `setuptools` provides
    a small function called `find_packages` that calculates this'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`namespace_packages`: This is a list of namespaced packages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trove classifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PyPI and `distutils` provide a solution for categorizing applications with
    the set of classifiers called **trove classifiers**. All the classifiers form
    a tree-like structure. Each classifier is a form of string where every namespace
    is separated by the `::` substring. Their list is provided to the package definition
    as a `classifiers` argument to the `setup()` function. Here is an example list
    of classifiers for some project available on PyPI (here `solrq`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: They are completely optional in the package definition but provide a useful
    extension to the basic metadata available in the `setup()` interface. Among others,
    trove classifiers may provide information about supported Python versions or systems,
    the development stage of the project, or the license under which the code is released.
    Many PyPI users search and browse the available packages by categories so a proper
    classification helps packages to reach their target.
  prefs: []
  type: TYPE_NORMAL
- en: Trove classifiers serve an important role in the whole packaging ecosystem and
    should never be ignored. There is no organization that verifies packages classification,
    so it is your responsibility to provide proper classifiers for your packages and
    not introduce chaos to the whole package index.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing this book, there are 608 classifiers available on PyPI
    that are grouped into nine major categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Development status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intended audience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: License
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Natural language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Topic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New classifiers are added from time to time, so it is possible that these numbers
    will be different at the time you read it. The full list of currently available
    trove classifiers is available with the `setup.py register --list-classifiers`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Common patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating a package for distribution can be a tedious task for inexperienced
    developers. Most of the metadata that `setuptools` or `distuitls` accept in their
    `setup()` function call can be provided manually, ignoring the fact that this
    may be available in other parts of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: While this will definitely work, it is hard to maintain in the long term and
    leaves a place for future mistakes and inconsistencies. Both `setuptools` and
    `distutils` cannot automatically pick various metadata information from the project
    sources, so you need to provide them by yourself. There are some common patterns
    among the Python community for solving the most popular problems like dependency
    management, version/readme inclusion, and so on. It is worth knowing at least
    a few of them because they are so popular that they could be considered as packaging
    idioms.
  prefs: []
  type: TYPE_NORMAL
- en: Automated inclusion of version string from package
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The **PEP 440 (Version Identification and Dependency Specification)** document
    specifies a standard for version and dependency specification. It is a long document
    that covers accepted version specification schemes and how version matching and
    comparison in Python packaging tools should work. If you are using or plan to
    use a complex project version numbering scheme, then reading this document is
    obligatory. If you are using a simple scheme that consists of one, two, three,
    or more numbers separated by dots, then you can let go the reading of PEP 440\.
    If you don't know how to choose the proper versioning scheme, I greatly recommend
    following semantic versioning that was already mentioned in [Chapter 1](ch01.html
    "Chapter 1. Current Status of Python"), *Current Status of Python*.
  prefs: []
  type: TYPE_NORMAL
- en: The other problem is where to include that version specifier for a package or
    module. There is PEP 396 (Module Version Numbers), which deals exactly with this
    problem. Note that it is only informational and has *deferred* status, so it is
    not a part of the standards track. Anyway, it describes what seems to be a *de
    facto* standard now. According to PEP 396, if a package or module has a version
    specified, it should be included as a `__version__` attribute of a package root
    (`__init__.py`) or module file. Another de facto standard is to also include the
    `VERSION` attribute that contains the tuple of version parts. This helps users
    to write compatibility code because such version tuples can be easily compared
    if the versioning scheme is simple enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'So many packages available on PyPI follow both standards. Their `__init__.py`
    files contain version attributes that look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The other suggestion of deferred PEP 396 is that the version provided in the
    distutils'' `setup()` function should be derived from `__version__`, or vice versa.
    Python Packaging User Guide features multiple patterns for a single-sourcing project
    version and each of them has its own advantages and limitations. My personal favorite
    is rather long and is not included in the PyPA''s guide but has the advantage
    of limiting the complexity to `setup.py` script only. This boiler plate assumes
    that the version specifier is provided by the `VERSION` attribute of package''s
    `__init__` module and extracts this data for inclusion in the `setup()` call.
    Here is the excerpt from some imaginary package''s `setup.py` script that presents
    this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: README file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Python Packaging Index can display a project's readme or the value of `long_description`
    on the package page in PyPI portal. You can write this description using reStructuredText
    ([http://docutils.sourceforge.net/rst.html](http://docutils.sourceforge.net/rst.html))
    markup, so it will be formatted to HTML on upload. Unfortunately, only reStructuredText
    is currently available as a documentation markup on PyPI. This is unlikely to
    change in the near future. More likely, additional markup languages will be supported
    when we see the `warehouse` project replacing completely current PyPI implementations.
    Unfortunately, the final release of `warehouse` is still unknown.
  prefs: []
  type: TYPE_NORMAL
- en: Still, many developers want to use different markup languages for various reasons.
    The most popular choice is Markdown, which is the default markup language on GitHub—the
    place where most open source Python development currently happens. So, usually,
    GitHub and Markdown enthusiasts either ignore this problem or provide two independent
    documentation texts. Descriptions provided to PyPI are either short versions of
    what is available on the project's GitHub page or it is plain unformatted Markdown
    that does not present well on PyPI.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use something different than reStructuredText markup language
    for your project''s README, you can still provide it as a project description
    on the PyPI page in a readable form. The trick lies in using the `pypandoc` package
    to translate your other markup language into reStructuredText while uploading
    the package to Python Package Index. It is important to do it with a fallback
    to plain content of your readme file, so the installation won''t fail if the user
    has no `pypandoc` installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Managing dependencies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Many projects require some external packages to be installed and/or used. When
    the list of dependencies is very long there comes a question as to how to manage
    it. The answer in most cases is very simple. Do not over-engineer the problem.
    Keep it simple and provide the list of dependencies explicitly in your `setup.py`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Some Python developers like to use `requirements.txt` files for tracking lists
    of dependencies for their packages. In some situations, you might find a reason
    for doing that but in most cases this is a relic of times where the code of that
    project was not properly packaged. Anyway, even such notable projects as Celery
    still stick to this convention. So if you are not willing to change your habits
    or you are somehow forced to use requirement files, then at least do it properly.
    Here is one of the popular idioms for reading the list of dependencies from the
    `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The custom setup command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`distutils` allows you to create new commands. A new command can be registered
    with an entry point, which was introduced by `setuptools` as a simple way to define
    packages as plug-ins.'
  prefs: []
  type: TYPE_NORMAL
- en: An entry point is a named link to a class or a function that is made available
    through some APIs in `setuptools`. Any application can scan for all registered
    packages and use the linked code as a plug-in.
  prefs: []
  type: TYPE_NORMAL
- en: 'To link the new command, the `entry_points` metadata can be used in the setup
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: All named links are gathered in named sections. When `distutils` is loaded,
    it scans for links that were registered under `distutils.commands`.
  prefs: []
  type: TYPE_NORMAL
- en: This mechanism is used by numerous Python applications that provide extensibility.
  prefs: []
  type: TYPE_NORMAL
- en: Working with packages during development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working with `setuptools` is mostly about building and distributing packages.
    However, you still need to know how to use them to install packages directly from
    project sources. And the reason for that is simple. It is good to test if your
    packaging code works properly before submitting a package to PyPI. And the simplest
    way to test it is by installing it. If you will send a broken package to the repository,
    then in order to re-upload it, you need to increase the version number.
  prefs: []
  type: TYPE_NORMAL
- en: Testing if your code is packaged properly before the final distribution saves
    you from unnecessary version number inflation and obviously from wasted time.
    Also, installation directly from your own sources using `setuptools` may be essential
    when working on multiple related packages at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: setup.py install
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `install` command installs the package into Python environment. It will
    try to build the package if no previous build was made and then inject the result
    into the Python tree. When a source distribution is provided, it can be uncompressed
    in a temporary folder and then installed with this command. The `install` command
    will also install dependencies that are defined in the `install_requires` metadata.
    This is done by looking at the packages in the Python Package Index.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative to the bare `setup.py` script when installing a package is to
    use `pip`. Since it is a tool that is recommended by PyPA, you should use it even
    when installing a package in your local environment for development purposes.
    In order to install a package from local sources, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Uninstalling packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Amazingly, `setuptools` and `distutils` lack the `uninstall` command. Fortunately,
    it is possible to uninstall any Python package using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Uninstalling can be a dangerous operation when attempted on system-wide packages.
    This is another reason why it is so important to use virtual environments for
    any development.
  prefs: []
  type: TYPE_NORMAL
- en: setup.py develop or pip -e
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Packages installed with `setup.py install` are copied to the site-packages directory
    of your current environment. This means whenever you make a change to the sources
    of that package, you are required to re-install it. This is often a problem during
    intensive development because it is very easy to forget about the need to perform
    installation again. This is why `setuptools` provides an extra `develop` command
    that allows us to install packages in **development mode**. This command creates
    a special link to project sources in the deployment directory (site-packages)
    instead of copying the whole package there. Package sources can be edited without
    need of re-installation and it is available in `sys.path` as it were installed
    normally.
  prefs: []
  type: TYPE_NORMAL
- en: '`pip` also allows installing packages in such a mode. This installation option
    is called *editable mode* and can be enabled with the `-e` parameter in the `install`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Namespace packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The Zen of Python*, which you can read by writing `import this` in the interpreter
    session, says the following about namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Namespaces are one honking great idea—let''s do more of those!*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'And this can be understood in at least two ways. The first is a namespace in
    the context of the language. We all use namespaces without even knowing:'
  prefs: []
  type: TYPE_NORMAL
- en: The global namespace of a module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The local namespace of the function or method invocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The built-in name's namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other kind of namespaces can be provided at packaging levels. These are
    **namespaced packages**. This is often an overlooked feature that can be very
    useful in structuring the package ecosystem in your organization or in a very
    large project.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it useful?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Namespace packages can be understood as a way of grouping related packages or
    modules higher than a meta-package level, where each of these packages can be
    installed independently.
  prefs: []
  type: TYPE_NORMAL
- en: Namespace packages are especially useful if you have your application components
    developed, packaged, and versioned independently but you still want to access
    them from the same namespace. This helps to make clear to which organization or
    project every package belongs. For instance, for some imaginary Acme company,
    the common namespace could be `acme`. The result could lead to the creation of
    the general `acme` namespace package that will serve as a container for other
    packages from this organization. For example, if someone from Acme wants to contribute
    to this namespace with, for example, an SQL-related library, he can create a new
    `acme.sql` package that registers itself in `acme`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to know the difference between normal and namespace packages
    and what problems they solve. Normally (without namespace packages), you would
    create a package `acme` with an `sql` subpackage/submodule with the following
    file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever you want to add a new subpackage, let''s say `templating`, you are
    forced to include it in the source tree of `acme`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Such an approach makes independent development of `acme.sql` and `acme.templating`
    almost impossible. The `setup.py` script will also have to specify all dependencies
    for every subpackage, so it is impossible (or at least very hard) to have an installation
    of just some of the `acme` components optionally. Also, it is an unresolvable
    issue if some of the subpackages have conflicting requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'With namespace packages, you can store the source tree for each of these subpackages
    independently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also register them independently in PyPI or any package index you use.
    Users can choose which of the subpackages they want to install from the `acme`
    namespace but they never install the general `acme` package (it does not exist):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that independent source trees are not enough to create namespace packages
    in Python. You need a bit of additional work if you don't want your packages to
    overwrite each other. Also, proper handling may be different depending on the
    Python language version you target. Details of that are described in the next
    two sections.
  prefs: []
  type: TYPE_NORMAL
- en: PEP 420 – implicit namespace packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you use and target only Python 3, then there is good news for you. **PEP
    420 (Implicit Namespace Packages)** introduced a new way to define namespace packages.
    It is a part of the standards track and became an official part of the language
    since the 3.3 version. In short, every directory that contains Python packages
    or modules (including namespace packages too) is considered a namespace package
    if it does not contain the `__init__.py` file. So, the following are examples
    of file structures presented in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'They are enough to define that `acme` is a namespace package in Python 3.3
    and later. Minimal `setup.py` scripts using setup tools will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, `setuptools.find_packages()` does not support PEP 420 at the
    time of writing this book. Anyway, this may change in the future. Also, a requirement
    to explicitly define a list of packages seems to be a very small price for easy
    integration of namespace packages.
  prefs: []
  type: TYPE_NORMAL
- en: Namespace packages in previous Python versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no way to make the namespaces packages in PEP 420 layout to work in
    Python versions older than 3.3\. Still, this concept is very old and commonly
    used in such mature projects like Zope, so it is definitely possible to use them
    but without implicit definition. In older versions of Python, there are several
    ways to define that the package should be treated as a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest one is to create a file structure for each component that resembles
    an ordinary package layout without namespace packages and leave everything to
    `setuptools`. So, the example layout for `acme.sql` and `acme.templating` could
    be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that for both `acme.sql` and `acme.templating`, there is an additional
    source file `acme/__init__.py`. This must be left empty. The `acme` namespace
    package will be created if we provide this name as a value of the `namespace_packages`
    keyword argument of the `setuptools.setup()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Easiest does not mean best. `setuptools`, in order to register a new namespace,
    will call for the `pkg_resources.declare_namespace()` function in your `__init__.py`
    file. It will happen even if the `__init__.py` file is empty. Anyway, as the official
    documentation says, it is your own responsibility to declare namespaces in the
    `__init__.py` file, and this implicit behavior of `setuptools` may be dropped
    in the future. In order to be safe and "future-proof", you need to add the following
    line to the file `acme/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Uploading a package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packages will be useless without an organized way to store, upload, and download
    them. Python Packaging Index is the main source of open source packages in the
    Python community. Anyone can freely upload new packages and the only requirement
    is to register on the PyPI site—[https://pypi.python.org/pypi](https://pypi.python.org/pypi).
  prefs: []
  type: TYPE_NORMAL
- en: You are not limited, of course, to only this index and all packaging tools support
    the usage of alternative package repositories. This is especially useful for distributing
    closed source code among internal organizations or for deployment purposes. Details
    of such packaging usage with instructions on how to create your own package index
    will be explained in the next chapter. Here we focus only on open-source uploads
    to PyPI with only a little mention on how to specify alternative repositories.
  prefs: []
  type: TYPE_NORMAL
- en: PyPI – Python Package Index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python Package Index is, as already mentioned, the official source of open source
    package distributions. Downloading from it does not require any account or permission.
    The only thing you need is a package manager that can download new distributions
    from PyPI. Your preferred choice should be `pip`.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading to PyPI – or other package index
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Anyone can register and upload packages to PyPI provided that he or she has
    an account registered. Packages are bound to the user, so, by default, only the
    user that registered the name of the package is its admin and can upload new distributions.
    This could be a problem for bigger projects, so there is an option to design other
    users as package maintainers so that they are able to upload new distributions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to upload a package is to use the `upload` command of the `setup.py`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `<dist-commands>` is a list of commands that creates distribution to
    upload. Only distributions created during the same `setup.py` execution will be
    uploaded to the repository. So, if you would upload source distribution, built
    distribution, and wheel package at once, then you need to issue the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When uploading using `setup.py`, you cannot reuse already built distributions
    and are forced to rebuild them on every upload. This might make some sense but
    can be inconvenient for large or complex projects in which creation of the distribution
    may actually take a considerable amount of time. Another problem of `setup.py
    upload` is that it can use plaintext HTTP or unverified HTTPS connection on some
    Python versions. This is why `twine` is recommended as a secure replacement for
    `setup.py upload`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Twine is the utility for interacting with PyPI that currently serves only one
    purpose—securely uploading packages to the repository. It supports any packaging
    format and always ensures that the connection is secure. It also allows you to
    upload files that were already created, so you are able to test distributions
    before the release. An example usage of `twine` still requires invoking `setup.py`
    for building distributions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have not yet registered this package, then the upload will fail because
    you need to register it first. This can also be done using `twine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: .pypirc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`.pypirc` is a configuration file that stores information about Python packages
    repositories. It should be located in your home directory. The format for this
    file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `distutils` section should have the `index-servers` variable that lists
    all sections describing all the available repositories and credentials to them.
    There are only three variables that can be modified for each repository section:'
  prefs: []
  type: TYPE_NORMAL
- en: '`repository`: This is the URL of the package repository (it defaults to [https://www.python.org/pypi](https://www.python.org/pypi))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username`: This is the username for authorization in the given repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password`: This is the user password for authorization in plaintext'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that storing your repository password in plaintext may not be the wisest
    security choice. You can always leave it blank and you will be prompted for it
    whenever it is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The `.pypirc` file should be respected by every packaging tool built for Python.
    While this may not be true for every packaging-related utility out there, it is
    supported by the most important ones such as `pip`, `twine`, `distutils`, and
    `setuptools`.
  prefs: []
  type: TYPE_NORMAL
- en: Source packages versus built packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are generally two types of distributions for Python packages:'
  prefs: []
  type: TYPE_NORMAL
- en: Source distributions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built (binary) distributions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source distributions are the simplest and most platform independent. For pure
    Python packages, it is a no-brainer. Such a distribution contains only Python
    sources and these should be already highly portable.
  prefs: []
  type: TYPE_NORMAL
- en: A more complex situation is when your package introduces some extensions written,
    for example, in C. Source distributions will still work provided that the package
    user has a proper development toolchain in his/her environment. This consists
    mostly of the compiler and proper C header files. For such cases, the built distribution
    format may be better suited because it may provide already built extensions for
    specific platforms.
  prefs: []
  type: TYPE_NORMAL
- en: sdist
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `sdist` command is the simplest command available. It creates a release
    tree where everything needed to run the package is copied. This tree is then archived
    in one or many archive files (often, it just creates one tarball). The archive
    is basically a copy of the source tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command is the easiest way to distribute a package from the target system
    independently. It creates a `dist` folder with the archives in it that can be
    distributed. To be able to use it, an extra argument has to be passed to `setup`
    to provide a version number. If you don''t give it a `version` value, it will
    use `version = 0.0.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This number is useful to upgrade an installation. Every time a package is released,
    the number is raised so that the target system knows it has changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the `sdist` command with this extra argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Under Windows, the archive will be a ZIP file.
  prefs: []
  type: TYPE_NORMAL
- en: The version is used to mark the name of the archive, which can be distributed
    and installed on any system that has Python. In the `sdist` distribution, if the
    package contains C libraries or extensions, the target system is responsible for
    compiling them. This is very common for Linux-based systems or Mac OS because
    they commonly provide a compiler, but it is less usual to have it under Windows.
    That's why a package should always be distributed with a prebuilt distribution
    as well, when it is intended to run under several platforms.
  prefs: []
  type: TYPE_NORMAL
- en: bdist and wheels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To be able to distribute a prebuilt distribution, `distutils` provides the
    `build` command, which compiles the package in four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`build_py`: This builds pure Python modules by byte-compiling them and copying
    them into the build folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`build_clib`: This builds C libraries, when the package contains any, using
    C compiler and creating a static library in the build folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`build_ext`: This builds C extensions and puts the result in the build folder
    like `build_clib`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`build_scripts`: This builds the modules that are marked as scripts. It also
    changes the interpreter path when the first line was set (`!#`) and fixes the
    file mode so that it is executable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these steps is a command that can be called independently. The result
    of the compilation process is a build folder that contains everything needed for
    the package to be installed. There's no cross-compiler option yet in the `distutils`
    package. This means that the result of the command is always specific to the system
    it was built on.
  prefs: []
  type: TYPE_NORMAL
- en: When some C extensions have to be created, the build process uses the system
    compiler and the Python header file (`Python.h`). This **include** file is available
    from the time Python was built from the sources. For a packaged distribution,
    an extra package for your system distribution is probably required. At least in
    popular Linux distributions, it is often named `python-dev`. It contains all the
    necessary header files for building Python extensions.
  prefs: []
  type: TYPE_NORMAL
- en: The C compiler used is the system compiler. For a Linux-based system or Mac
    OS X, this would be **gcc** or **clang** respectively. For Windows, Microsoft
    Visual C++ can be used (there's a free command-line version available) and the
    open-source project MinGW can be used as well. This can be configured in `distutils`.
  prefs: []
  type: TYPE_NORMAL
- en: The `build` command is used by the `bdist` command to build a binary distribution.
    It calls `build` and all the dependent commands, and then creates an archive in
    the same way as `sdist` does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a binary distribution for `acme.sql` under Mac OS X:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the newly created archive's name contains the name of the system
    and the distribution it was built under (*Mac OS X 10.3*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The same command called under Windows will create a specific distribution archive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If a package contains C code, apart from a source distribution, it's important
    to release as many different binary distributions as possible. At the very least,
    a Windows binary distribution is important for those who don't have a C compiler
    installed.
  prefs: []
  type: TYPE_NORMAL
- en: A binary release contains a tree that can be copied directly into the Python
    tree. It mainly contains a folder that is copied into Python's `site-packages`
    folder. It may also contain cached bytecode files (`*.pyc` files on Python 2 and
    `__pycache__/*.pyc` on Python 3).
  prefs: []
  type: TYPE_NORMAL
- en: 'The other kind of built distributions are "wheels" provided by the `wheel`
    package. When installed (for example, using `pip`), `wheel` adds a new `bdist_wheel`
    command to the `distutils`. It allows creating platform-specific distributions
    (currently only for Windows and Mac OS X) that provides alternatives to normal
    `bdist` distributions. It was designed to replace another distribution introduced
    earlier by `setuptools`—eggs. Eggs are now obsolete so won''t be featured here.
    The list of advantages of using wheels is quite long. Here are the ones that are
    mentioned in the Python Wheels page ([http://pythonwheels.com/](http://pythonwheels.com/)):'
  prefs: []
  type: TYPE_NORMAL
- en: Faster installation for pure python and native C extension packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoids arbitrary code execution for installation. (Avoids `setup.py`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation of a C extension does not require a compiler on Windows or OS X
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows better caching for testing and continuous integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates `.pyc` files as part of the installation to ensure they match the Python
    interpreter used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More consistent installs across platforms and machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: According to PyPA recommendation, wheels should be your default distribution
    format. Unfortunately, platform-specific wheels for Linux are not available yet
    so if you have to distribute packages with C extensions, then you need to create
    `sdist` distribution for Linux users.
  prefs: []
  type: TYPE_NORMAL
- en: Standalone executables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating standalone executables is a commonly overlooked topic in materials
    that cover packaging of Python code. This is mainly because Python lacks proper
    tools in its standard library that could allow programmers to create simple executables
    that could be run by users without the need to install the Python interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Compiled languages have a big advantage over Python in that they allow creation
    of an executable application for the given system architecture that could be run
    by users in a way that does not require them to have any knowledge of the underlying
    technology. Python code, when distributed as a package, requires the Python interpreter
    in order to be run. This creates a big inconvenience for users who do not have
    enough technical proficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Developer-friendly operating systems such as Mac OS X or most Linux distributions
    come with Python pre-installed. So, for their users, the Python-based application
    still could be distributed as a source package that relies on specific **interpreter
    directive** in the main script file, which is popularly called **shebang**. For
    most Python applications, this takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Such directive, when used as a first line of script, will mark it to be interpreted
    by default by the Python version for the given environment. This can, of course,
    take a more detailed form, which requires a specific Python version such as `python3.4`,
    `python3`, or `python2`. Note that this will work in most popular POSIX systems,
    but isn't portable at all by definition. This solution relies on the existence
    of specific Python versions and also availability of `env` executable exactly
    at `/usr/bin/env`. Both of these assumptions may fail on some operating systems.
    Also, shebangs will not work on Windows at all. Additionally, bootstrapping of
    the Python environment on Windows can be a challenge even for experienced developers,
    so you cannot expect that nontechnical users will be able to do that by themselves.
  prefs: []
  type: TYPE_NORMAL
- en: The other thing to consider is the simple user experience in the desktop environment.
    Users usually expect that applications can be run from the desktop by simply clicking
    on them. Not every desktop environment will support that with Python applications
    distributed as a source.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it would be best if we are able to create a binary distribution that
    would work as any other compiled executable. Fortunately, it is possible to create
    an executable that has both the Python interpreter and our project embedded. This
    allows users to open our application without caring about Python or any other
    dependency.
  prefs: []
  type: TYPE_NORMAL
- en: When are standalone executables useful?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Standalone executables are useful in situations where simplicity of user experience
    is more important than the user's ability to interfere with applications' code.
    Note that the fact that you are distributing application as executable only makes
    code reading or modification harder—not impossible. It is not a way to secure
    applications code and should only be used as a way to make interacting with an
    application simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Standalone executables should be a preferred way of distributing applications
    for nontechnical end users and also seems to be the only reasonable way of distributing
    a Python application for Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Standalone executables are usually a good choice for:'
  prefs: []
  type: TYPE_NORMAL
- en: Applications that depend on specific Python versions that may not be easily
    available on the target operating systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications that rely on modified precompiled CPython sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications with graphical interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Projects that have many binary extensions written in different languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Popular tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python does not have any built-in support for building standalone executables.
    Fortunately, there are some community projects solving that problem with varied
    success. The four most notable are:'
  prefs: []
  type: TYPE_NORMAL
- en: PyInstaller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cx_Freeze
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: py2exe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: py2app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each one of them is slightly different in use and also each one of them has
    slightly different limitations. Before choosing your tool, you need to decide
    which platform you want to target, because every packaging tool can support only
    a specific set of operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: The best case scenario is if you make such a decision at the very beginning
    of the project's life. None of these tools, of course, require deep interaction
    in your code, but if you start building standalone packages early, you can automate
    the whole process and save future integration time and costs. If you leave this
    for later, you may find yourself in a situation where the project is built in
    such a sophisticated way that none of the available tools will work. Providing
    a standalone executable for such a project will be problematic and will take a
    lot of your time.
  prefs: []
  type: TYPE_NORMAL
- en: PyInstaller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PyInstaller ([http://www.pyinstaller.org/](http://www.pyinstaller.org/)) is
    by far the most advanced program to freeze Python packages into standalone executables.
    It provides the most extensive multiplatform compatibility among every available
    solution at the moment, so it is the most recommended one. Platforms that PyInstaller
    supports are:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows (32-bit and 64-bit)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux (32-bit and 64-bit)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mac OS X (32-bit and 64-bit)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FreeBSD, Solaris, and AIX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supported versions of Python are Python 2.7 and Python 3.3, 3.4, and 3.5\. It
    is available on PyPI, so it can be installed in your working environment using
    `pip`. If you have problems installing it this way, you can always download the
    installer from the project's page.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, cross-platform building (cross-compilation) is not supported
    so if you want to build your standalone executable for a specific platform, then
    you need to perform building on that platform. This is not a big trouble today
    with the advent of many virtualization tools. If you don't have a specific system
    installed on your computer, you can always use Vagrant that will provide you with
    the desired operating system as a virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usage for simple applications is easy. Let''s assume our application is contained
    in the script named `myscript.py`. This is a simple "Hello world!" application.
    We want to create a standalone executable for Windows users and we had our sources
    located under `D://dev/app` in the filesystem. Our application can be bundled
    with the following short command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'PyInstaller''s standard output is quite long even for simple applications,
    so it was truncated in the preceding example for the sake of brevity. If run on
    Windows, the resulting structure of directories and files will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dist/myscript` directory contains the built application that can now be
    distributed to the users. Note that the whole directory must be distributed. It
    contains all additional files that are required to run our application (DLLs,
    compiled extension libraries, and so on). A more compact distribution can be obtained
    with the `--onefile` switch of the `pyinstaller` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When built with the `--onefile` option, the only file you need to distribute
    to other users is the single executable found in the `dist` directory (here, `myscript.exe`).
    For small applications, this is probably the preferred option.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the side effects of running the `pyinstaller` command is the creation
    of the `*.spec` file. This is an autogenerated Python module containing specification
    on how to create executables from your sources. For example, we already used this
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This `.spec` file contains all `pyinstaller` arguments specified earlier. This
    is very useful if you have performed a lot of customizations to your build because
    this can be used instead of building scripts that would have to store your configuration.
    Once created, you can use it as an argument to the `pyinstaller` command instead
    of your Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is a real Python module, so you can extend it and perform more
    complex customizations to the building procedure using a language that you already
    know. Customizing the `.spec` file is especially useful when you are targeting
    many different platforms. Also, not all of the `pyinstaller` options are available
    through the command-line arguments and can be used only when modifying `.spec`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: PyInstaller is an extensive tool, which by its usage is very simple for the
    great majority of programs. Anyway, the thorough reading of its documentation
    is recommended if you are interested in using it as a tool to distribute your
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: cx_Freeze
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'cx_Freeze ([http://cx-freeze.sourceforge.net/](http://cx-freeze.sourceforge.net/))
    is another tool for creating standalone executables. It is a simpler solution
    than PyInstaller, but also supports the three major platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mac OS X
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Same as PyInstaller, it does not allow us to perform cross-platform builds,
    so you need to create your executables on the same operating system you are distributing
    to. The major disadvantage of cx_Freeze is that it does not allow us to create
    real single-file executables. Applications built with it need to be distributed
    with related DLL files and libraries. Assuming that we have the same application
    as featured in the *PyInstaller* section, the example usage is very simple as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Resulting structure of files is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of providing the own format for build specification (like PyInstaller
    does), cx_Freeze extends the `distutils` package. This means you can configure
    how your standalone executable is built with the familiar `setup.py` script. This
    makes cx_Freeze very convenient if you already distribute your package using `setuptools`
    or `distutils` because additional integration requires only small changes to your
    `setup.py` script. Here is an example of such a `setup.py` script using `cx_Freeze.setup()`
    for creating standalone executables on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'With such a file, the new executable can be created using the new `build_exe`
    command added to the `setup.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage of cx_Freeze seems a bit easier than PyInstaller''s and `distutils`
    integration is a very useful feature. Unfortunately this project may cause some
    troubles for inexperienced developers:'
  prefs: []
  type: TYPE_NORMAL
- en: Installation using `pip` may be problematic under Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The official documentation is very brief and lacking in some places
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: py2exe and py2app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'py2exe ([http://www.py2exe.org/](http://www.py2exe.org/)) and py2app ([https://pythonhosted.org/py2app/](https://pythonhosted.org/py2app/))
    are two other programs that integrate with Python packaging either via `distutils`
    or `setuptools` in order to create standalone executables. Here they are mentioned
    together because they are very similar in both usage and their limitations. The
    major drawback of py2exe and py2app is that they target only a single platform:'
  prefs: []
  type: TYPE_NORMAL
- en: py2exe allows building Windows executables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: py2app allows building Mac OS X apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because the usage is very similar and requires only modification of the `setup.py`
    script, these packages seem to complement each other. The documentation of py2app
    projects the following example of the `setup.py` script that allows to build standalone
    executables with the right tool (either py2exe or py2app), depending on the platform
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: With such a script, you can build your Windows executable using the `python
    setup.py py2exe` command and Mac OS X app using `python setup.py py2app`. Cross
    compilation is of course not possible.
  prefs: []
  type: TYPE_NORMAL
- en: Despite some limitations and less elasticity than PyInstaller or cx_Freeze,
    it is good to know that there are always py2exe and py2app projects. In some cases,
    PyInstaller or cx_Freeze might fail to build executable for the project properly.
    In such situations, it is always worth checking whether other solutions can handle
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: Security of Python code in executable packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to know that standalone executables does not make application
    code secure by any means. It is not an easy task to decompile the embedded code
    from such executable files, but it is doable for sure. What is even more important
    is that the results of such de-compilation (if done with proper tools) might look
    strikingly similar to original sources.
  prefs: []
  type: TYPE_NORMAL
- en: This fact makes standalone Python executables not a viable solution for closed
    source projects where leaking of the application code could harm the organization.
    So, if your whole business can be copied simply by copying the source code of
    your application, then you should think of other ways to distribute the application.
    Maybe providing software as a service will be a better choice for you.
  prefs: []
  type: TYPE_NORMAL
- en: Making decompilation harder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As already said, there is no reliable way to secure applications from de-compilation
    with the tools available at the moment. Still, there are some ways to make this
    process harder. But harder does not mean less probable. For some of us, the most
    tempting challenges are the hardest ones. And we all know that the eventual prize
    in this challenge is very high: the code that you tried to secure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually the process of de-compilation consists of a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting the project's binary representation of bytecode from standalone executables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mapping of a binary representation to bytecode of a specific Python version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Translation of bytecode to AST.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recreation of sources directly from AST.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Providing the exact solutions for deterring developers from such reverse-engineering
    of standalone executables would be pointless for obvious reasons. So here are
    only some ideas for hampering of the de-compilation process or devaluating its
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing any code metadata available at runtime (docstrings), so the eventual
    results will be a bit less readable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying the bytecode values used by the CPython interpreter so that conversion
    from binary to bytecode and later to AST requires more effort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a version of CPython sources modified in such a complex way that even
    if decompiled sources of the application are available they are useless without
    decompiling the modified CPython binary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using obfuscation scripts on sources before bundling them into executables,
    which will make sources less valuable after the de-compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such solutions make the development process a lot harder. Some of the above
    ideas require a very deep understanding of Python runtime but each one of them
    is riddled with many pitfalls and disadvantages. Mostly, they only defer what
    is inevitable. Once your trick is broken, it renders all your additional efforts
    a waste of time and resources.
  prefs: []
  type: TYPE_NORMAL
- en: The only reliable way to not allow your closed code leak outside of your application
    is to not ship it directly to users in any form. And this is only true if other
    aspects of your organization's security stay airtight.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter described details of Python's packaging ecosystem. Now, after reading
    it, you should know which tools suit your packaging needs and also which types
    of distributions your project requires. You should also know the popular techniques
    for common problems and how to provide useful metadata to your project.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed the topic of standalone executables that are very useful,
    especially in distributing desktop applications.
  prefs: []
  type: TYPE_NORMAL
- en: Next chapter will extensively rely on what we have learned here to show how
    to efficiently deal with code deployments in a reliable and automated way.
  prefs: []
  type: TYPE_NORMAL
