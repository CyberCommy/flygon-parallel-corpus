- en: High-Level Customer Scenarios with Acceptance Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Pyccuracy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the basics with Pyccuracy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Pyccuracy to verify web app security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Robot Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a data-driven test suite with Robot Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a testable story using Robot Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tagging Robot Framework tests and running a subset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing web basics with Robot Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Robot Framework to verify web app security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a project-level script to run this chapter's acceptance tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Acceptance testing involves writing tests to prove that our code is, well, acceptable!
    However, what does this mean? The context implies acceptable from a customer's
    perspective. Customers are usually more interested in what the software does,
    not how it does it. This means that tests are aimed at inputs and outputs and
    tend to be at a higher level than unit testing. This has sometimes been called
    black box testing and is usually more system oriented. At the end of the day,
    it is often associated with testing that asserts whether or not the customer will
    accept the software.
  prefs: []
  type: TYPE_NORMAL
- en: There is an assumption among some developers that acceptance testing involves
    verifying the frontend of web applications. In fact, several testing tools, including
    Pyccuracy, are built on the sole premise of testing web applications. When viewed
    from the perspective of whether or not a customer will accept the software, this
    will quite literally fit into acceptable from a customer's perspective.
  prefs: []
  type: TYPE_NORMAL
- en: However, web testing isn't the only form of acceptance testing. Not all systems
    are web-based. If a subsystem is to be built by one team and handed off to another
    team that plans to build another layer on top of it, an acceptance test may be
    required before the second team will accept it.
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, we will dig into some recipes that involve both web and non-web
    application acceptance testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an e-store web application for testing, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that you have `mercurial` installed on your system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For macOS, use either MacPorts or Homebrew
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Ubuntu/Debian, use `sudo apt-get install mercurial`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For other systems, you will need to do extra research in installing `mercurial`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This also requires having compilable tools installed, such as `gcc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For Ubuntu, use `sudo apt-get install build-essential`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For other systems, you will need to do extra research in installing `gcc`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have other issues installing Satchmo in the following steps, visit the
    project site at [http://www.satchmoproject.com](http://www.satchmoproject.com)
    and possibly their support group at [http://groups.google.com/group/satchmo-users](http://groups.google.com/group/satchmo-users).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install Satchmo, an e-commerce website builder, by typing the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Install Python's `PIL` library for image processing with `pip install PIL`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit `<virtualenv root>/lib/python2.6/site-packages/django/contrib/admin/templates/admin/login.html`
    to add `id="login"` to the `Log in<input>` tag. This allows Pyccuracy to grab
    the `Log in` button and click it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the Satchmo script to create store application: `clonesatchmo.py`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted about creating a super-user, say `yes`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted, enter a `username`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted, enter an `e-mail address`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted, enter a `password`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go into store directory: `cd store`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start up the store app: `python manage.py runserver`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have issues installing Satchmo with these steps, visit the project site
    at [http://www.satchmoproject.com](http://www.satchmoproject.com) and possibly
    their support group at [https://groups.google.com/forum/#!forum/satchmo-users](https://groups.google.com/forum/#!forum/satchmo-users).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a non-web shopping cart application for testing, create `cart.py`
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This shopping cart has the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Is 1-based, meaning that the first item and price are at `[1]` not `[0]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Includes the ability to have multiples of the same item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will calculate total price and then add taxes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This application isn't complex. Maybe it doesn't look exactly at a system level,
    but it does provide an easy application to write acceptance tests against.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Pyccuracy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pyccuracy is a useful tool for writing web acceptance tests using a BDD-style
    language. This recipe shows all the steps needed to install it and set it up for
    later recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With these steps, we will install Pyccuracy and all the tools needed to run
    the scenarios later in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Install `Pyccuracy` by typing `pip install pyccuracy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download `selenium-server.jar` from [http://github.com/heynemann/pyccuracy/raw/master/lib/selenium-server.jar](http://github.com/heynemann/pyccuracy/raw/master/lib/selenium-server.jar).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start it up by typing `java -jar selenium-server.jar`. Note that if you don't
    have Java installed, you definitely need to download and install it as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install `lxml` by typing `pip install lxml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a simple test file called `recipe35.acc` and enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it by typing `pyccuracy_console -p test.acc`. The following screenshot
    shows it being run with Firefox (default for this system):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Run it again, using a different web browser such as Safari, by typing `pyccuracy_console
    -p test.acc -b safari`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00078.jpeg)At the time of writing, Selenium supports Firefox,
    Safari, Opera, and IE 7+, but not Chrome.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the folder where we ran the test, there should now be a `report.html` file.
    Open it up using a browser to view the results. Then, click on Expand All:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pyccuracy uses Selenium, a popular browser-driving application tester to run
    its scenarios. Pyccuracy provides an out-of-the-box **Domain Specific Language**
    (**DSL**) to write tests. The DSL provides the means to send commands to a test
    browser and also check the results, verifying web application behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Later on in this chapter, there are several recipes that show more details of
    Pyccuracy.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Testing the basics with Pyccuracy*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using Pyccuracy to verify web app security*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the basics with Pyccuracy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pyccuracy provides an easy-to-read set of operations to drive the frontend of
    a web application. This recipe shows how to use it to drive a shopping cart application
    and verify application functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If it isn''t already running, start up the Selenium server in another shell
    or window by typing `java -jar selenium-server.jar`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If the Satchmo store application isn't already running, start it up in another
    shell or window by typing python manage.py runserver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This must run inside the `virtualenv` environment.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With these steps, we will explore the basics of writing a Pyccuracy test:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `recipe36.acc`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a story for loading items into the shopping cart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a scenario where the empty cart is looked at in detail, with a confirmed
    balance of `$0.00`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add another scenario where a book is selected and two of them are added to
    the cart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the story by typing `pyccuracy_console -p recipe36.acc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pyccuracy has a lot of built-in actions based on driving the browser or reading
    the page. These actions are patterns used to parse the story file and generate
    commands sent to the Selenium server, which in turn drives the browser and then
    reads the results of the page.
  prefs: []
  type: TYPE_NORMAL
- en: The key is picking the right text to identify the element being actioned or
    read.
  prefs: []
  type: TYPE_NORMAL
- en: Web apps that are missing ID tags are much hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key is picking the right identifier and element type. With good identifiers,
    it is easy to do things like—*I **click **on **Cart **link*. Did you note the
    issue we had with drilling into the shopping cart table? The HTML `<table>` tag
    had no identifier, which made it impossible for us to pick. Instead, we had to
    look at the whole page and do a global search for some markup.
  prefs: []
  type: TYPE_NORMAL
- en: This makes it more difficult to read the test. A good solution is to alter the
    web app to include an ID in the `<table>` tag. Then, we narrow down our acceptance
    criteria to just the table. With this application it was okay, but with complex
    web applications, it will surely be much more difficult to find the exact bit
    of text we are looking for without good IDs.
  prefs: []
  type: TYPE_NORMAL
- en: This raises an interesting question—should an application be amended to support a test?
    Simply put, yes. It isn't a major upheaval to add some good identifiers to key
    HTML elements to support testing. It didn't involve major design changes to the
    application. The net result was easier to read test cases and better-automated
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: This begs another question—what if making the application more testable did
    involve major design changes? This can be viewed as a major interruption in work.
    Alternatively, maybe it's a strong hint that our design has components that are
    too tightly coupled or not cohesive enough.
  prefs: []
  type: TYPE_NORMAL
- en: In software development, **coupling** and **cohesiveness** are subjective terms
    that aren't very measurable. What can be said is that applications that don't
    lend themselves to testing are often monolithic, hard to maintain, and probably
    have circular dependencies, which implies that it will be much harder for us to
    make changes (as developers) to meet needs without impacting the entire system.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, all of this would be a big leap from our recipe's situation, where
    we simply lack an identifier for an HTML table. However, it's important to ask
    this question—what if we need more changes than something so small?
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Installing Pyccuracy*'
  prefs: []
  type: TYPE_NORMAL
- en: Using Pyccuracy to verify web app security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications often have login screens. Testing a secured web application requires
    us to capture the login process as a custom action. That way, we can reuse it
    repeatedly for as many scenarios as we need.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If it isn't already running, start up the Selenium server in another shell or
    window by typing `java -jar selenium-server.jar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the Satchmo store application isn't already running, start it up in another
    shell or window by typing python manage.py runserver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This must run inside the `virtualenv` environment.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the following steps, we will exercise a web application''s security and
    then see how to extend Pyccuracy by creating a custom action that does so:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `recipe37.acc` to put this recipe's scenario into.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a story for exercising Django''s admin application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a scenario that logs in to the admin application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a scenario that inspects the product catalog, using the custom login action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Create a matching file called `recipe37.py` containing a custom-defined action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Code the custom action of logging in to the admin action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the story by typing `pyccuracy_console -p recipe37.acc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first scenario shows the simple steps needed to exercise the login screen.
    After having proven that the login screen works, it becomes cumbersome to repeat
    this procedure for more scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: To handle this, we create a custom action in Python by extending `ActionBase`.
    Custom actions require a regular expression to define the DSL text. Next, we define
    an `execute` method to include a combination of application logic and Pyccuracy
    steps to execute. Essentially, we can define a set of steps to automatically execute
    actions and dynamically handle different situations.
  prefs: []
  type: TYPE_NORMAL
- en: In our situation, we coded it to handle whether or not the user was already
    logged in. With this custom action, we built the second scenario and handled logging
    in with a single statement, allowing us to move on and test the core part of our
    scenario.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Installing Pyccuracy*'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Robot Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Robot Framework is a useful framework for writing acceptance tests using the
    **keyword** approach. Keywords are shorthand commands that are provided by various
    libraries and can also be user defined. This easily supports BDD-style `Given`-`When`-`Then`
    keywords. It also opens the door to third-party libraries defining custom keywords
    to integrate with other test tools, such as Selenium. It also means that acceptance
    tests written using Robot Framework aren't confined to web applications.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows all the steps needed to install Robot Framework as well as
    the third-party Robot Framework Selenium library for use in later recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ensure that you activate your `virtualenv` sandbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install by typing `easy_install robotframework`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the time of writing, Robot Framework was not able to be installed using `pip`.
  prefs: []
  type: TYPE_NORMAL
- en: Using any type of window navigator, go to `<virtualenvroot>/build/robotframework/doc/quickstart`
    and open `quickstart.html` with your favorite browser. This is not only a guide
    but also a runnable test suite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Switch to your virtualenv''s build directory for Robot Framework: `cd<virtualenvroot>/build/robotframework/doc/quickstart`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the Quick Start manual through `pybot` to verify installation with `pybot
    quickstart.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00083.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Inspect the `report.html`, `log.html`, and `output.xml` files generated by the
    test run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the Robot Framework Selenium library to allow integration with Selenium
    by first downloading [http://robotframework-seleniumlibrary.googlecode.com/files/robotframework-seleniumlibrary-2.5.tar.gz](http://robotframework-seleniumlibrary.googlecode.com/files/robotframework-seleniumlibrary-2.5.tar.gz).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unpack the tarball.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the directory with `cd robotframework-seleniumlibrary-2.5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the package with `python setup.py install`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the demo directory with `cd demo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start up the demo web app with `python run demo.py demoapp start`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start up the Selenium server with `python run demo.py selenium start`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the demo tests with `pybot login_tests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00084.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Shut down the demo web app with `python run demo.py demoapp stop`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Shut down the Selenium server with `python run demo.py selenium stop`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inspect the `report.html`, `log.html`, `output.xml`, and `selenium_log.txt`
    files generated by the test run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this recipe, we have installed Robot Framework and one third-party library
    that integrates Robot Framework with Selenium.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more third-party libraries that provide enhanced functionality
    to Robot Framework. The options have enough potential to fill an entire book.
    So, we must narrow our focus to some of the core features provided by Robot Framework,
    including both web and non-web testing.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a data-driven test suite with Robot Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Robot Framework uses **keywords** to define tests, test steps, variables, and
    other testing components. Keywords are shorthand commands that are provided by
    various libraries and can also be custom-defined. This allows many different ways
    of writing and organizing tests.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll explore how to run the same test procedure with varying
    inputs and outputs. These can be described as data-driven tests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We first need to activate our `virtualenv` setup
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this recipe, we will use the shopping cart application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to install Robot Framework, as shown in the previous recipe
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will show us how to write a simple acceptance test using
    HTML tables:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `recipe39.html` to capture the tests and configurations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an HTML paragraph and table that contains a set of data-driven test cases,
    as shown in the following browser screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Add another HTML paragraph and table defining the custom keywords Adding items to cart
    and Add item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00086.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Create a new file called `recipe39.py` to contain Python code that is wired
    into our custom keywords.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an old-style Python class that implements the custom keywords needed
    for the scenarios:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It's important to define the class *old-**style*. If we define it as *new-**style*
    by subclassing `object`, Robot Framework's runner, `pybot`, won't find the methods
    and associate them with our HTML keywords.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a third HTML paragraph and table that loads our Python code to implement
    Add item to cart and Get total:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'View the HTML file in your favorite browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00088.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the HTML file through `pybot` to exercise the tests by typing `pybot recipe39.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00089.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can inspect `report.html` and `log.html` using your favorite browser for
    more details about the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Robot Framework uses HTML tables to define test components. The header row of
    the table identifies what type of component the table defines.
  prefs: []
  type: TYPE_NORMAL
- en: The first table we created was a set of test cases. Robot Framework spots this
    by seeing `Test Case` in the first cell of the header row. The rest of the header
    cells aren't parsed, which leaves us free to put in descriptive text. In this
    recipe, each of our test cases is defined with one-line. The second column has
    `Adding items to cart` on every row, which is a custom keyword defined in the
    second table. The rest of the columns are arguments for this custom keywords.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second table we wrote is used to define custom keywords. Robot Framework
    figures this out by seeing `Keyword` in the first cell of the header row. Our
    table defines two keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Adding items to cart`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first line defines the arguments by starting with `[Arguments]` and six
    input variables: `${item1}`, `${price1}`, `${item2}`, `${price2}`, `${tax}`, and
    `${total}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next set of lines are actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lines two and three use another custom keyword: `Add item` with two arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line four defines a new variable, `${calculated total}`, which is assigned the
    results of another keyword, `Get total` with one argument, `${tax},` that is defined
    in our Python module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last line uses a built-in keyword, `Should Be Equal`, to confirm that the
    output of `Get total` matches the original `${total}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Add item`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first line defines arguments by starting with `[Arguments]` and two input
    variables: `${description}` and `${price}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second line uses another keyword, `Add item to cart`, that is defined in
    our Python module, with two named arguments: `${description}` and `${price}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third table we made contains settings. This is identified by seeing `Setting`
    in the first cell of the header row. This table is used to import Python code
    that contains the final keywords using the built-in keyword `Library`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Robot Framework maps our keywords to our Python code by a very simple convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Get total ${tax}` maps to `get_total(self,tax)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Add item to cart ${description} ${price}` maps to `add_item_to_cart(self,
    description, price)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reason we need `add_item_to_cart` and couldn't have just written `add_item`
    to tie in to the `Add item` keyword is because Robot Framework uses named arguments
    when connecting to Python code. Since each usage of `Add item` in our tables had
    a different variable name, we needed a separate keyword with distinct arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Do I have to write HTML tables?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Robot Framework is driven by HTML tables, but it doesn't matter how the tables
    are generated. Many projects use tools like **reStructuredText** ([http://docutils.sourceforge.net/rst.html](http://docutils.sourceforge.net/rst.html))
    to write tables in a less verbose way, and then have a parser that converts it
    into HTML. A useful tool for converting `.rst` to HTML is **docutils** ([http://docutils.sourceforge.net/](http://docutils.sourceforge.net/)).
    It provides a convenient `rst2html.py` script that will convert all the `.rst`
    tables into HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the format of this book makes it hard to present `.rst` as either
    code or with a screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: What are the best ways to write the code that implements our custom keywords?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We wrote a chunk of Python code to tie in our custom keywords with the `ShoppingCart`
    application. It is important to make this as light as possible. *Why?* It's because
    when we deploy the actual application, this bridge shouldn't be a part of it.
    It may be tempting to use this bridge as an opportunity to bundle things up or
    to transform things, but this should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, it is better to include these functions in the software application
    itself. Then, this extra functionality becomes a part of the tested, deployed
    software functionality.
  prefs: []
  type: TYPE_NORMAL
- en: If we don't invest too heavily in the bridging code, it helps us avoid making
    the software dependent on the test framework. For some reason, if we ever decided
    to switch to something other than Robot Framework, we wouldn't be tied into that
    particular tool due to having too much invested in the bridging code.
  prefs: []
  type: TYPE_NORMAL
- en: Robot Framework variables are Unicode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another critical factor in making our Python code work is recognizing that the
    input values are Unicode strings. Since `ShoppingCart` is based on floating point
    values, we had to use Python's `float(input)` function to convert inputs, and
    `format(output, ".2f")` to convert outputs.
  prefs: []
  type: TYPE_NORMAL
- en: Does this contradict the previous section where we discussed keeping this bridge as light as possible?
    It doesn't. By using pure, built-in Python functions that have no side effects,
    we aren't getting in deep, and instead are only messaging the formats to line
    things up. If we started manipulating containers, or converting strings to lists,
    and vice versa, or even defining new classes, then that would definitely be getting
    too heavy for this bridge.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Installing Robot Framework*'
  prefs: []
  type: TYPE_NORMAL
- en: Writing a testable story with Robot Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed earlier in this chapter, Robot Framework lets us use custom-defined
    keywords.
  prefs: []
  type: TYPE_NORMAL
- en: This gives us the ability to structure keywords in any style. In this recipe,
    we will define custom keywords that implement the BDD-`Given`-`When`-`Then`-style
    of specification.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We first need to activate our `virtualenv` setup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this recipe, we will use the shopping cart application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to install Robot Framework, as shown in the previous sections
    of this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will explore how to write a BDD-`Given-When-Then`-style
    acceptance test:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `recipe40.html` to put our HTML tables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a story file in HTML with an opening statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00090.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Add a table with several scenarios used to exercise the shopping cart application
    with a series of `Given`-`When`-`Then` keywords:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00091.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Add a second table that defines all of our custom `Given-When-Then` custom
    keywords:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00092.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new file called `recipe40.py` to put Python code that links the custom
    keywords to the `ShoppingCart` application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It is critical that this class is implemented old-style. If implemented new-style
    by extending `object`, Robot Framework will not link the keywords.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a third table to our `recipe40.html` file to import our Python module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00093.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the story by typing `pybot recipe40.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Robot Framework uses HTML tables to define test components. The header row of
    the table identifies what type of component the table defines.
  prefs: []
  type: TYPE_NORMAL
- en: The first table we created was a set of test cases. Robot Framework spots this
    by seeing `Test Case` in the first cell of the header row. The rest of the header
    cells aren't parsed, which leaves us free to put in descriptive text.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, each of our test cases comprised several custom keywords using
    the `Given-When-Then`-style familiar to BDD testers. Many of these keywords have
    one or more arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The second table we wrote was used to define our custom `Given-When-Then`-keywords.
    Robot Framework figures this out by seeing `Keyword` in the first cell of the
    header row.
  prefs: []
  type: TYPE_NORMAL
- en: The third table we made contains settings. This is identified by seeing `Setting`
    in the first cell of the header row. This table is used to import Python code
    that contains the final keywords using the built-in keyword `Library`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important aspect of our custom keywords, in this recipe, is that we wrote
    them in a natural, flowing language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is broken up into four HTML cells in order to parameterize the inputs
    and make the keywords reusable for several test steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00095.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Robot Framework sees this as a custom keyword, `When``I``add``a`, with three
    arguments: `carton of milk`, `for`, and `2.50`.'
  prefs: []
  type: TYPE_NORMAL
- en: Later on, we fill in the actual steps involved with this keyword. In doing so,
    we are really only concerned with using `carton of milk` and `2.50`, but we still
    have to treat `for` like an input variable. We do this using a place holder variable,
    `${noop}`, which we will simply not use in any following keyword steps.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we call the throwaway variable, `${noop}`. We could have called
    it anything. We can also reuse it if we have more than one throwaway argument
    in the same keyword. This is because Robot Framework doesn't engage in strong
    type checks.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This entire chunk of HTML that we had to write starts to feel a bit heavy. As
    mentioned in the *Creating **a **data*-*driven **test **suite **with **Robot Framework*
    recipe, `.rst` is a great alternative. Unfortunately, writing this recipe using
    `.rst` is too wide for the format of this book. Refer to that recipe for more
    details about writing `.rst` and getting the tools to convert `.rst` to HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Given-When-Then results in duplicate rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's true that we had to define both `Then item` and `Add item`, which are basically
    the same, in order to support two different test scenarios. In other BDD tools,
    these would have been automatically spotted as the same clause. Robot Framework
    doesn't directly provide a BDD domain specific language, so we had to fill this
    in for ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: The most efficient way to handle this was to define `Then item` in detail with
    all the steps needed, and then code `And item` to just call `Then item`.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, `When I add a` and `And I add a` were implemented by calling `add
    item`. Since this clause was a simpler pass-through to our Python module, it wasn't
    necessary to chain them together like the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: Another option would be to investigate coding our own BDD plugin library to
    simplify all of this.
  prefs: []
  type: TYPE_NORMAL
- en: Do the try-except blocks violate the idea of keeping things light?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Creating **a **data*-*driven **test **suite **with Robot* *Framework*
    recipe, I mentioned that the code that bridges the HTML tables with the `ShoppingCart`
    application should be kept as light as possible and avoid transformations and
    other manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: It is quite possible to view trapping of an expected exception and returning
    a string as crossing this line. In our case, the solution was to define a single
    clause that could handle errors and legitimate values. The clause takes whatever
    is returned and verifies it using the built-in `Should Be Equal` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: If this wasn't the case, it may have been smoother to not have the try-expect
    block, and instead use the built-in `Run Keyword And Expect Error` keyword linked
    to another custom Python keyword. However, in this situation, I think the goal
    of keeping things light was satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Installing the Robot Framework*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a data-driven test suite with Robot Framework*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tagging Robot Framework tests and running a subset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Robot Framework provides a comprehensive way to capture test scenarios using
    table-driven structures. This includes the ability to add metadata in the form
    of tagging as well as documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Tagging allows including or excluding tags for testing. Documentation appears
    on the command line and also in the outcome reports. This recipe will demonstrate
    both of these keen features.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, HTML tables aren't the only way to define data tables with Robot Framework.
    In this recipe, we will explore using double-space-separated entries. While this
    isn't the only non-HTML way to write stories, it is the easiest non-HTML way to
    demonstrate that still fits within the font size limits of this book in printed
    form.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We first need to activate our `virtualenv` setup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file called `cart41.py` to put an alternate version of the shopping
    cart application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type in the following code that stores the cart to a database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This version of the shopping cart has two extra methods: `store` and `retrieve`.
    They don''t actually talk to a database, but instead create an empty `cart.db` file. *Why?*
    The purpose is to simulate interaction with a database. Later in the recipe, we
    will show how to tag test cases that involve this operation and easily exclude
    them from test runs.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to install Robot Framework, as shown in the earlier sections of
    this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will show how to write scenarios in a format other than
    HTML tables and also how to tag tests to allow picking and choosing which tests
    are run on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `recipe41.txt` using plain text and space-separated
    entries that has a couple of test cases: a simple one and another a more complex
    one with documentation and tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s important to note that two spaces at the minimum are required to identify
    breaks between one cell and the next. The line with `When I add a carton of milk
    for 2.50` actually has four cells of information: `| When I add a | carton of
    milk | for | 2.50 |`. There is actually a fifth, empty cell that prefixes this
    row indicated by the two-space indentation. It is necessary to mark this row as
    a step in test case `Simple check of adding one item` rather than another test
    case.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a table for custom keyword definitions using plain text and space-separated
    values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new file called `recipe41.py` that contains Python code that bridges
    some of the keywords with the shopping cart application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a last table to `recipe41.txt` that imports our Python code as a library
    to provide the last set of needed keywords:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test scenario as if we are on a machine that has database support by
    typing `pybot recipe41.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00096.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the test scenario, excluding tests that were tagged `database`, by typing
    `pybot -exclude database recipe41.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00097.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the test scenario, including tests that were tagged `database`, by typing
    `pybot -include database recipe41.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00098.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Look at `report.html`, and observe where the extra `[Documentation]` text appears
    as well as our `database` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00099.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we added an extra section to the second test case, including
    both documentation and a tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Tags are usable on the command line, as shown in the previous example. It provides
    a useful way to organize test cases. Test cases can have as many tags as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We showed earlier that this provides a convenient command-line option to include
    or exclude based on tags. Tags also provide useful documentation, and the previous
    screenshot of `report.html` shows that test results are also subtotaled by tag:'
  prefs: []
  type: TYPE_NORMAL
- en: Tags can be used to identify different layers of testing, such as smoke, integration,
    and customer-facing layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tags can also be used to mark subsystems such as databases, invoicing, customer-service,
    and billing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe demonstrates plain text formatting. Triple asterisks are used to
    surround header cells, and two spaces are used to designate a break between two
    cells.
  prefs: []
  type: TYPE_NORMAL
- en: It is debatable as to whether this is more difficult to read than HTML. It may
    not be as crisp as reading the HTML markup, but I personally preferred this to
    angle tax of reading HTML. It's possible to add more spaces so that the table's
    cells are clearer, but I didn't, because the font sizes of this book don't work
    very well with it.
  prefs: []
  type: TYPE_NORMAL
- en: What about documentation?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We also added a little bit of documentation for demonstration purposes. A piece
    of the text appears when `pybot` runs, and it also appears in the resulting artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Installing Robot Framework*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a data-driven test suite with Robot Framework*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Writing a testable story using Robot Framework*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing web basics with Robot Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web testing is a common style of acceptance testing, because the customer wants
    to know whether the system is acceptable, and this is a perfect way to demonstrate
    it.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous recipes, we have explored writing tests against non-web applications.
    In this recipe, let's see how to use a third-party Robot Framework plugin to use
    Selenium to test a shopping cart web application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We first need to activate our `virtualenv` setup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this recipe, we are using the Satchmo shopping cart web application. To
    start it, switch to the store directory and type python manage.py runserver. You
    can explore it by visiting http://localhost:8000.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, install Robot Framework and the third-party Selenium plugin, as shown
    in the *Installing **Robot **Framework* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the following steps, we will see how to get going with using some of the
    basic Robot commands for driving a web application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a plain text story file called `recipe42.txt`, with an opening description
    of the story:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a section for test cases, and add a scenario that verifies that there
    is an empty shopping cart and captures a screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Add another scenario that picks a book, adds two copies of the cart, and confirms
    the total cart value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a section of keywords and define a keyword for inspecting the raw HTML
    of the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`Get Source` is a Selenium Library keyword that fetches the raw HTML of the
    entire page. `Start Selenium Server` is another keyword to launch the Selenium
    server. A built-in `Sleep` call is included to avoid startup/shutdown timing issues,
    if this test happens before or after another one Selenium-based test suite.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a section that imports the Selenium library and also defines a setup and
    teardown process for launching and shutting down the browser for each test case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`Test Setup` is a built-in keyword that defines steps executed before each
    test case. In this case, it uses the Selenium library keyword `Open Browser` to
    launch a browser pointed at the Satchmo application. Test Teardown is a built-in
    keyword that executes at the end of each test and closes the browsers launched
    by this test. Suite Setup is a built-in keyword that is only run before any tests
    are executed, and Suite Teardown is only run after all the tests in this suite.
    In this case, we use it to start and stop the Selenium library.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the test suite by typing `pybot recipe42.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open `log.html` and observe the details, including the captured screenshots
    in each scenario. The following screenshot is just one of the many captured screenshots.
    Feel free to inspect the rest of the screenshots as well as the logs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00101.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Robot Framework provides a powerful environment to define tests through keywords.
    The Selenium plugin interfaces with Selenium and provides a whole set of keywords
    that are focused on manipulating web applications and reading and confirming their
    outputs.
  prefs: []
  type: TYPE_NORMAL
- en: An important part of web application testing is getting a hold of an element
    to manipulate it or test values. The most common way of doing this is by checking
    key attributes of the element, such as `id`, `name`, or `href`. For example, in
    our scenario, there is a button we need to click on to add the book to the cart.
    It can be identified by either the ID, `addcart`, or the displayed text, `Add
    to cart`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Robot Framework is free compared to other commercial frontend test solutions,
    it is important to realize that the effort in writing automated tests isn't free
    and effortless. It takes effort to make this an active part of frontend design.
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating tools like Robot and Selenium library early in the process of
    screen design will encourage good practices like tagging frames and elements so
    that they'll be testable early on. This is no different from attempting to write
    automated tests for a backend server system after it's already built. Both situations
    are much more costly, if they are introduced later. Making automated testing a
    part of backend systems early on encourages similar coding to support testability.
  prefs: []
  type: TYPE_NORMAL
- en: If we are looking at embracing acceptance testing late in our development cycle,
    or perhaps trying to test a system we inherited from another team, we need to
    include time to make changes to the web interface in order to add tags and identifiers
    to support writing the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Learn about timing configurations – they may be important!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the Satchmo shopping cart application didn't have any significant delays
    in the tests we wrote, it doesn't mean other applications won't. If your web application
    has certain parts that are noticeably slower, it is valuable to read the online
    documentation about configuring how long Selenium should wait for a response from
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Installing Robot Framework*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a data-driven test suite with Robot Framework*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Writing a testable story using Robot Framework*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Robot Framework to verify web app security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web applications often have some sort of security in place. This is often in
    the form of a login page. A well written test case should start a new browser
    session at the beginning and close it at the end. This results in the user logging
    in repeatedly for every test case.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explore writing code to log in to Satchmo's admin page,
    as provided by Django. Then, we will show how to capture this entire login procedure
    into a single keyword, allowing us to smoothly write a test that visits the product
    catalog without getting encumbered by logging in.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We first need to activate our `virtualenv` setup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this recipe, we are using the Satchmo shopping cart web application. To
    start it, switch to the store directory and type `python manage.py runserver`.
    You can explore it by visiting `http://localhost:8000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, install Robot Framework and the third-party Selenium plugin, as shown
    in the *Installing **Robot **Framework* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will highlight how to capture login steps and then encapsulate
    them in a single custom keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `recipe43.txt`, and write a test story for exercising
    Django''s admin interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a section for test cases, and write a test case that exercises the login
    page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Add another test case that inspects the product catalog and verifies a particular
    row of the table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a keyword section that captures the login procedure as a single keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For your own testing, put in the username and password you used when installing
    Satchmo. The `Start Selenium Server` keyword is another keyword to launch the
    Selenium server. A built-in Sleep call is included to avoid startup/shutdown timing
    issues if this test happens before or after another one Selenium-based test suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add a settings section that imports Selenium library and also starts
    and stops the Selenium server at the beginning and end of the test suite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test suite by typing `pybot recipe43.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00102.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first test case shows how we input username and password data and then submit
    the form. SeleniumLibrary allows us to pick a form by name, but in the event we
    don't identify it, it picks the first HTML form it finds. Since there is only
    one form on the login page, this works fine for us.
  prefs: []
  type: TYPE_NORMAL
- en: With the second test case, we want to navigate to the product catalog. Since
    it runs with a clean browser session, we are forced to deal with the login screen
    again. This means we need to include the same steps to log in again. For more
    comprehensive testing, we would probably write lots of test cases. *Why* *should*
    *we* *avoid* *copying* *and* pasting *the* *same* *login* *steps* *for* *every*
    *test* *case?* That's because it violates the **Don't Repeat Yourself** (**DRY**)
    principle. If the login page is modified, we might have to alter every instance.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we captured the login steps with `Given that I am logged in` keyword.
    This gives us a useful clause for many test cases, and lets us focus on the admin
    page.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we used some of Selenium library's table testing operations.
    We verified that a particular book exists both at the table level as well as the
    row level. We also verified the price of the book in that row.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we captured a screenshot of the product catalog. This screenshot gives
    us a quick, visual glance we can use to either manually confirm the product catalog,
    or use to plan our next test step.
  prefs: []
  type: TYPE_NORMAL
- en: Why not use a "remember me" option?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lots of websites include a "remember me" checkbox in order to save login credentials
    in a client-side cookie. The Django admin page doesn't have one, so why is this
    relevant*?* It's because many websites do, and we may be tempted to incorporate
    it into our tests to avoid logging in every time. Even if this option existed
    for the web app we want to test, it is not a good idea to use it. It creates a
    persistent state that can propagate from one test to the next. Different user
    accounts may have different roles, impacting what is visible. We may not know
    in what order test cases run and therefore have to add extra code to sniff what
    user we are logged in as.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, it is much easier and cleaner to *not* persist this information. Instead,
    explicitly logging in through a single keyword provides a clearer intent. This
    doesn't mean we shouldn't test and confirm the remember checkbox of our particular
    web application. On the contrary, we should actually test both good and bad accounts
    to ensure that the login screen works as expected. However, beyond that, it is
    best to not confuse future test cases with persisted results of the current test
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Shouldn't we refactor the first test scenario to use the keyword?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To uphold the DRY principle, we should have the login procedure in only one
    place inside our test story. However, for demonstration purposes, we coded it
    at the top, and then later copied the same code into a keyword. The best solution
    would be to encapsulate it into a single keyword that can be reused in either
    a test case or to define other custom keywords like `Given I am logged in`.
  prefs: []
  type: TYPE_NORMAL
- en: Would arguments make the login keyword more flexible?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Absolutely—in this test story, we hardcoded the username as well as the password.
    However, good testing of the login page would involve a data-driven table with
    lots of combinations of good and bad accounts along with valid and invalid passwords.
    This drives the need for some sort of login keyword that would accept username
    and password as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Installing Robot Framework*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using Pyccuracy to verify web app security*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a data-driven test suite with Robot Framework*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a project-level script to verify this chapter's acceptance tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have used `pyccuracy_console` and `pybot` to run various test recipes. However,
    management of a Python project involves more than just running tests. Things like
    packaging, registering with the Python Project Index, and pushing to deployment
    sites are important procedures to manage.
  prefs: []
  type: TYPE_NORMAL
- en: Building a command-line script to encapsulate all this is very convenient. With
    this recipe, we will run a script that runs all the tests covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We first need to activate our `virtualenv` setup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this recipe, we are using the Satchmo shopping cart web application. To
    start it, switch to the store directory and type `python manage.py runserver`.
    You can explore it by visiting `http://localhost:8000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, install Robot Framework and the third-party Selenium plugin, as shown
    in the *Installing **Robot **Framework* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This recipe assumes that all the various recipes from this chapter have been
    coded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With these steps, we will see how to programmatically run all the tests in
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `recipe44.py` to contain the code for this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a command-line script that defines several options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a method that starts Selenium, runs the Pyccuracy-based tests, and then
    shuts down Selenium:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a method that runs the Robot Framework tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a method to run both of these test methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some stubbed out methods for the other project functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some code that parses the options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script with the testing flag by typing `python``recipe44 -test`. In
    the following screenshot, we can see that all the Pyccuracy tests passed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00103.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the next screenshot, we can see that the Robot Framework tests passed as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00104.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use Python''s `getopt` module to define command-line options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This maps the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"h"`: `-h`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"help"`: `--help`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"test"`: `--test`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"package"`: `--package`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"publish"`: `--publish`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"register"`: `--register`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We scan the list of received arguments and call the appropriate functions.
    For our test functions, we used Python''s `subprocess` module to call `pyccuracy_console`.
    We could have done the same to call `pybot`, but Robot Framework provides a convenient
    API to call it directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This lets us use it inside our code.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To run these tests, we need Selenium running. Our Robot Framework tests are
    built to run Selenium on their own. Pyccuracy doesn't have such a feature, so
    it needed another means. In those recipes, we used `java -jar selenium-server.jar`.
    We could try to manage this, but it is easier to use Selenium library's API to
    start and stop Selenium.
  prefs: []
  type: TYPE_NORMAL
- en: This is where writing code in pure Python gives us the most options. We are
    able to empower Pyccuracy with parts of another library that was never intended
    to work with it.
  prefs: []
  type: TYPE_NORMAL
- en: Can we only use getopt?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python 2.7 introduces `argparse` as an alternative. Current documentation has
    no indication that `getopt` is deprecated, so it's safe to use it as we have just
    done. The `getopt` module is a nice, easy-to-use command-line parser.
  prefs: []
  type: TYPE_NORMAL
- en: What's wrong with using the various command-line tools?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is nothing wrong with using tools like `pyccuracy_console`, `pybot`, `nosetests`,
    and many other tools that come with the Python libraries. The purpose of this
    recipe is to offer a convenient, alternative approach that brings all these tools
    into one central script. By investing a little bit of time in this script, we
    don't have to remember how to use all these features; instead, we can develop
    our script to support the development workflow of our project.
  prefs: []
  type: TYPE_NORMAL
