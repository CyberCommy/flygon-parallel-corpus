- en: Chapter 6. Creating Reusable Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As well as being a good technique for writing programs for your own use, modular
    programming is also an excellent way of writing programs that can be used by other
    programmers. In this chapter, we will look at how to design and implement modules
    and packages that can be shared and reused in other programs. In particular, we
    will:'
  prefs: []
  type: TYPE_NORMAL
- en: See how modules and packages can be used as a way of sharing the code that you
    write
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how writing a module for reuse differs from writing a module for use as
    part of just one program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover what makes a module suitable for reuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at examples of successful reusable modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design a package to be reusable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a reusable package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by taking a look at how you can use modules and packages to share
    your code with other people.
  prefs: []
  type: TYPE_NORMAL
- en: Using modules and packages to share your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you write some Python source code, the code you create will perform
    a task of some sort. Maybe your code analyzes some data, stores some information
    into a file, or prompts the user to choose an item from a list. It doesn't matter
    what your code is—ultimately, your code does *something*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, this something is very specific. For example, you might have a function
    that calculates compound interest, generates a Venn diagram, or displays a warning
    message to the user. Once you''ve written this code, you can then use it wherever
    you want in your own program. This is the simply abstraction pattern that was
    described in the previous chapter: you separate *what* you want to do from *how*
    you do it.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you've written your function, you can then call it whenever you want to
    perform that task. For example, you can call your `display_warning()` function
    whenever you want to display a warning to the user, without worrying about the
    details of how the warning is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: However, this hypothetical `display_warning()` function isn't just useful in
    the program you are currently writing. Other programs may want to perform the
    same task—both programs that you write in the future and programs that other people
    may write. Rather than reinvent the wheel each time, it often makes sense to *reuse*
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: To reuse your code, you have to share it. Sometimes, you might share your code
    with yourself so that you can use it within a different program. At other times,
    you might share your code with other developers so that they can use it within
    their own programs.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you don't just share code with others for philanthropic reasons.
    In a larger organization, you are often required to share code to improve the
    productivity of your peers. Even if you work by yourself, you will benefit by
    using code other people have shared and, by sharing your own code, other people
    can help find bugs and fix problems that you're not able to fix yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of whether you share your code with yourself (in other projects)
    or with others (within your organization or in the wider development community),
    the basic process is the same. There are three main ways in which you can share
    your code:'
  prefs: []
  type: TYPE_NORMAL
- en: You can create a code snippet that is then copied and pasted into the new program.
    The code snippet might be stored in an application called a `Code Snippet Manager`
    or a folder of text files, or even published as part of a blog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can place the code you want to share into a module or package, and then
    import this module or package into the new program. The module or package can
    be physically copied into the new program's source code, it can be placed in your
    Python installation's `site-packages` directory, or you can modify `sys.path`
    to include the directory where the module or package can be found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alternatively, you can turn your code into a standalone program, and then call
    this program from other code using `os.system()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While all these options work, not all of them are ideal. Let''s take a closer
    look at each one:'
  prefs: []
  type: TYPE_NORMAL
- en: Code snippets are great for short pieces of code that form just part of a function.
    They're terrible, however, at keeping track of where that code ends up. Because
    you've copied and pasted the code into the middle of a new program, it is very
    easy to modify it as there's no easy way of distinguishing the pasted code from
    the rest of the program you've written. Also, if the original snippet needs to
    be modified, for example, to fix a bug, you'll have to find where you've used
    the snippet in your program and update it to match. All of this is rather messy
    and prone to errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The technique of importing modules or packages has the advantage of working
    well with larger chunks of code. The code you are sharing can include multiple
    functions and even be split across multiple source files using a Python package.
    You are also much less likely to accidentally modify an imported module as the
    source code is stored in a separate file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have copied the source module or package across to your new program,
    then you will need to manually update it if the original is changed. This is not
    ideal, but since you're replacing whole files, this isn't too difficult. On the
    other hand, if your new program uses a module stored elsewhere, then there's nothing
    to update—any changes made to the original module will immediately apply to any
    programs which use that module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, organizing your code into a standalone program means that your new
    program has to execute it. This can be done in the following way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is possible to run another Python program, wait for it to
    finish, and then check the returned status code to ensure that the program ran
    successfully. You can also pass parameters to the running program if you wish.
    However, the information you can pass to the program and receive back is extremely
    limited. This approach will work, for example, if you have a program that parses
    an XML file and saves a summary of this file into a different file on disk, but
    you can't directly pass Python data structures to another program for processing,
    and you can't receive Python data structures back again.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Actually, you *can* transmit Python data structures between running programs,
    but the process involved is so complicated that it isn't worth considering.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, snippets, module/package imports, and standalone programs form
    a kind of continuum: snippets are very small and fine-grained, module and package
    imports support larger chunks of code while still being easy to use and update,
    and standalone programs are large but limited in the way you can interact with
    them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of these three, using module and package imports to share code appears to hit
    the sweet spot: they can be used for large amounts of code, are easy to use and
    interact with, and are trivially easy to update when necessary. This makes modules
    and packages the ideal mechanism for sharing your Python source code—both with
    yourself, for use in future projects, and with other people.'
  prefs: []
  type: TYPE_NORMAL
- en: What makes a module reusable?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order for a module or package to be reusable, it has to meet the following
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: It must function as a standalone unit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your package is intended to be included as part of the source code for another
    system, you must use relative imports to load the other modules within your package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any external dependencies must be clearly noted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a module or package does not meet these three requirements, it would be very
    hard, if not impossible, to reuse it in other programs. Let's now take a closer
    look at each of these requirements in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Functioning as a standalone unit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that you decide to share a module named `encryption`, which performs
    text encryption using public/private key pairs. Another programmer then copies
    this module into their program. When they try to use it, however, their program
    crashes with the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `encryption` module may have been shared, but it was dependent on another
    module within the original program (`hash_utils.py`) that wasn't shared, and so
    the `encryption` module by itself is useless.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this problem is to combine the module you want to share with
    any other modules it may depend upon, putting the modules together into a package.
    You then share the package, rather than the individual module. The following illustration
    shows how this might be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Functioning as a standalone unit](graphics/B05012_6_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we have created a new package named `encryptionlib` and moved
    both the `encryption.py` and `hash_utils.py` files into this package. Of course,
    this requires you to refactor the rest of your program to allow for the new position
    of these modules, but it does then allow you to reuse your encryption logic in
    other programs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While it can be a nuisance having to refactor your program in this way, the
    result is almost always an improvement on your original program. Putting dependent
    modules together into a package helps to improve the overall organization of your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Using relative imports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Continuing with the example from the previous section, imagine that you want
    to use your new `encryptionlib` package as part of another program, but don''t
    want to make it publically available as a separate package. In this case, you
    can simply include the entire `encryptionlib` directory as part of your new system''s
    source code. When you do this, however, you can run into problems if your modules
    don''t use relative imports. For example, if your `encryption` module is dependent
    on the `hash_utils` module, then the `encryption` module is going to include an
    `import` statement referring to the `hash_utils` module. However, the resulting
    package cannot be reused if the `encryption` module imports `hash_utils` in any
    of the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: All of these import statements will fail because they assume that the `hash_utils.py`
    file is at a particular fixed point in your program's source code. Any assumption
    about the position of a dependent module within the program's source code will
    limit the reusability of the package as you can't then move the package to a different
    place and expect it to work. Given the requirements of the new project, you will
    often have to store packages and modules in a different place from where they
    were originally developed. For example, perhaps the `encryptionlib` package needs
    to be installed in a `thirdparty` package along with all the other reused libraries.
    Using absolute imports, your package will fail because the location of the modules
    within it will have changed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This doesn't apply if you publish your package and then install it into your
    Python `site-packages` directory. However, there are many situations where you
    don't want to install a reusable package inside the `site-packages` directory,
    and so you will need to be careful about relative imports.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, make sure that any `import` statements within a package
    that refer to other modules within the same package always use a relative import.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will allow your package to work no matter where in the Python source tree
    the package has been placed.
  prefs: []
  type: TYPE_NORMAL
- en: Noting external dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that our new `encryptionlib` package makes use of the `NumPy` library
    we encountered in the previous chapter. Perhaps `hash_utils` imports some functions
    from NumPy and uses them to quickly calculate a binary hash of a list of numbers.
    Even though NumPy was installed as part of the original program, you can''t assume
    that the same is true of the new program: if you were to install the `encryptionlib`
    package into a new program and run it, it would eventually fail with the following
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To prevent this from happening, it is important that anyone wanting to reuse
    your module is aware of the dependency on a third-party module and knows exactly
    what needs to be installed for your module or package to function. An ideal place
    to include this information is in the `README` file or other documentation for
    the module or package you are sharing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using an automated deployment system such as setuptools or pip, these
    tools have their own way of identifying your package's requirements. It is still
    a good idea, though, to list the requirements in your documentation so your users
    will be aware of them before the package is installed.
  prefs: []
  type: TYPE_NORMAL
- en: What makes a good reusable module?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we looked at the *minimum* requirements for a reusable
    module. Let's now examine the *ideal* requirements for reusability. What would
    a perfect reusable module look like?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three things that distinguish an excellent reusable module from a
    poor one:'
  prefs: []
  type: TYPE_NORMAL
- en: It attempts to solve a general problem (or range of problems), rather than just
    performing a specific task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It follows standard conventions that make it easier to use the module elsewhere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The module is clearly documented so that other people can easily understand
    and use it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a closer look at each of these points.
  prefs: []
  type: TYPE_NORMAL
- en: Solving a general problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often when you are programming, you will find that you need a specific task
    performed, and so you write a function to perform this task. For example, consider
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to convert from inches into centimeters, so you write an `inch_to_cm()`
    function to perform this task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You need to read a list of place names from a text file, which uses vertical
    bar characters (`|`) as delimiters between the fields:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To do this, you create a `load_placenames()` function that reads data from this
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to display the number of customers to a user:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Whether the message uses the word `customer` or `customers` depends on the number
    supplied. To handle this, you create a `pluralize_customers()` function that returns
    the appropriately pluralized version of the message depending on the number provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'In all of these examples, you are solving a specific problem. Quite frequently,
    functions like this will end up as part of a module, which you may want to reuse
    or share with others. However, these three functions, `inch_to_cm()`, `load_placenames()`,
    and `pluralize_customers()`, are all very specific to the problem you were trying
    to solve and so have limited applicability to new programs. All three are crying
    out to be made more general:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of the `inch_to_cm()` function, write a function that converts *any*
    imperial distance into metric, and then create another function that does the
    opposite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of writing a function that just loads place names, implement a `load_delimited_text()`
    function which works for any sort of delimited text file and doesn't assume particular
    column names or that the delimiter is a vertical bar character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead of pluralizing just customer names, write a more general `pluralize()`
    function that will pluralize the complete range of names you might need in your
    program. Because of the vagaries of the English language, you can''t just assume
    that all names can be pluralized by adding an *s* to the end; you''ll need a dictionary
    of exceptions such as person/people, axis/axes, and series/series, so that this
    function can handle the various sorts of names you might want to pluralize. To
    make this function even more useful, you can have it optionally accept the plural
    version of the name if it doesn''t know about the type of units you are pluralizing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: While these are just three specific examples, you can see that, by generalizing
    the code that you are sharing, you can make it apply to a much wider range of
    tasks. Often, there's very little more work involved in generalizing a function,
    but the result will be hugely appreciated by the people who use the code that
    you create.
  prefs: []
  type: TYPE_NORMAL
- en: Following standard conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While you can write code any way you like, if you want to share your code with
    others it makes sense to follow standard coding conventions. This makes it easier
    for others to use your code without having to remember your library's particular
    style.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a real-world example, consider the following snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet of code makes use of two libraries: the Shapely library, which
    performs computational geometry, and the OGR library, which reads and writes geospatial
    data. The Shapely library follows the standard Python conventions of using lowercase
    letters for function and method names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'While the details of these libraries are rather complex, the naming of these
    functions and methods is easy to remember and use. Compare this with the OGR library,
    however, which capitalizes the first letter of each function and method name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Using these two libraries together, you have to constantly remember that OGR
    capitalizes the first letter of each function and method name, while Shapely does
    not. This makes using OGR more awkward than it needs to be and leads to quite
    a few errors in the resulting code that then need to be fixed.
  prefs: []
  type: TYPE_NORMAL
- en: All of this could have been avoided if the OGR library had simply followed the
    same naming conventions as Shapely.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, for Python there is a document called the **Python Style Guide**
    ([https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/))
    that provides a clear set of recommendations for how to format and style your
    code. The use of lowercase letters for function and method names comes from this
    guide, as does a whole raft of other recommendations which most Python code also
    follows. Everything from how to name your variables to when to place whitespace
    around a parenthesis is described in this document.
  prefs: []
  type: TYPE_NORMAL
- en: While coding conventions are a matter of personal preference, and you certainly
    aren't required to slavishly follow the instructions in the Python Style Guide,
    doing so (at least in so far as it affects the users of your code) will make your
    reusable modules and packages easier for others to use—just like with the example
    of the OGR library, you don't want users to have to constantly remember an unusual
    naming style whenever someone wants to import and use your code.
  prefs: []
  type: TYPE_NORMAL
- en: Having clear documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even if you wrote the perfect module, solving a range of generalized problems
    and faithfully adhering to the Python Style Guide, your module would be useless
    if nobody knew how to use it. Unfortunately, as programmers, we are often too
    close to our code: it''s obvious to us how our code works, and so we fall into
    the trap of assuming it must be obvious to others, too. On top of this, programmers
    often *hate* writing documentation—we''d much rather write a thousand lines of
    well-crafted Python code than one paragraph describing how it works. As a result,
    documentation for the code we share is often written reluctantly, if at all.'
  prefs: []
  type: TYPE_NORMAL
- en: The thing is, a high-quality reusable module or package will *always* include
    documentation. This documentation will both explain what the module does and how
    it works, and include examples so that readers can immediately see how to use
    this module or package within their own programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an example of an excellently documented Python module or package, we need
    look no further than the **Pyth** **on Standard Library** ([https://docs.python.org/3/library/](https://docs.python.org/3/library/)).
    Every module is clearly documented, with detailed information and examples to
    help guide the programmer. For example, the following is an abbreviated version
    of the documentation for the `datetime.timedelta` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Having clear documentation](graphics/B05012_6_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Every module, class, function, and method is clearly documented, with examples
    and detailed notes to help the user of this module.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the developer of a reusable module, you aren''t expected to quite reach
    these heights. The Python Standard Library is a huge, collaborative effort, and
    no one person wrote all this documentation. But this is a good example of the
    *type* of documentation that you should be aiming for: comprehensive documentation
    with plenty of examples.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While you can create documentation in a word processor, or using a sophisticated
    documentation-generation system such as the Sphinx system used to build the Python
    documentation, there are two very easy ways in which you can write documentation
    with a minimum of fuss: by creating a README file, or by using docstrings.'
  prefs: []
  type: TYPE_NORMAL
- en: A `README` file is simply a text file that gets included with the various source
    files which make up your module or package. It would typically be named `README.txt`,
    and it is just an ordinary text file. You can create this file using the same
    editor that you use to edit your Python source code.
  prefs: []
  type: TYPE_NORMAL
- en: A README file can be as extensive or minimal as you want. It is often helpful
    to include information on how to install and use the module, any licensing issues,
    a few usage examples, and acknowledgements if your module or package includes
    code from someone else.
  prefs: []
  type: TYPE_NORMAL
- en: 'A docstring is a Python string that gets *attached* to a module or function.
    This is used specifically for documentation purposes, and there is a very special
    Python syntax for creating docstrings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In Python, you can use three quote characters to mark a string that goes across
    more than one line of the Python source file. These triple-quoted strings can
    be used in various places, including docstrings. If a module starts with a triple-quoted
    string, then this string is used as the documentation for the module as a whole.
    Similarly, if any function starts with a triple-quoted string, then this string
    is used as documentation for that function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The same applies to other definitions in Python, such as classes, methods, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings are typically used to describe what a module or function does, the
    parameters that are needed, and what information is returned. Any noteworthy aspects
    of the module or function should also be included, for example unexpected side
    effects, usage examples, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings (and README files) don't have to be very extensive. You don't want
    to spend hours writing documentation on some obscure function within a module
    that only three people are ever likely to use. But well-written docstrings and
    README files are a sign of an excellent and easy-to-use module or package.
  prefs: []
  type: TYPE_NORMAL
- en: Writing documentation is a skill; like all skills, you get better at it with
    practice. To create high-quality modules and packages that can be shared, you
    should get into the habit of creating docstrings and README files as well as following
    coding conventions and generalizing your code as much as possible, as we described
    in previous sections of this chapter. If you aim to produce high-quality reusable
    code from the outset, you'll find that it isn't that hard.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of reusable modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You don't have to look very far to find examples of reusable modules; the **Python
    Package Index** ([https://pypi.python.org/pypi](https://pypi.python.org/pypi))
    provides a huge repository of shared modules and packages. You can search for
    a package by name or keyword, or you can browse through the repository by topic,
    license, intended audience, development status, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the Python Package Index is huge, it is also extremely useful: all of
    the most successful packages and modules are included. Let''s look more closely
    at some of these more popular reusable packages.'
  prefs: []
  type: TYPE_NORMAL
- en: requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `requests` library ([http://docs.python-requests.org/en/master/](http://docs.python-requests.org/en/master/))
    is a Python package that makes it easy to send HTTP requests to remote servers
    and process the response. While the `urllib2` package included in the Python Standard
    Library does allow you to make HTTP requests, it is often difficult to use and
    fails in unexpected ways. The `requests` package is far easier to use and more
    reliable; as a result, it has become extremely popular.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code shows how the `requests` library allows you to send
    a complex HTTP request and easily process the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `requests` library automatically encodes the parameters that you want to
    send to the server, gracefully handles timeouts, and makes it easy to retrieve
    a JSON-format response.
  prefs: []
  type: TYPE_NORMAL
- en: The requests library is very easy to install (in most cases, you can simply
    use pip install requests). It has excellent documentation, including a user's
    guide, a community guide, and detailed API documentation, and it fully conforms
    with the Python Style Guide. It also provides a very general set of features,
    handling all sorts of communication with external web sites and systems via the
    HTTP protocol. With all these things going for it, it's no wonder that `requests`
    is the third most popular package in the entire Python Package Index.
  prefs: []
  type: TYPE_NORMAL
- en: python-dateutil
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `dateutil` package ([https://github.com/dateutil/dateutil](https://github.com/dateutil/dateutil))
    extends the `datetime` package included in the Python Standard Library, adding
    support for recurring dates, time zones, complex relative dates, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code calculates the date of Easter Friday in a much easier
    form than we used for the *happy hour* calculation in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`dateutil` provides excellent documentation with plenty of examples, is easy
    to install using `pip install python-dateutil`, follows the Python Style guide,
    and is extremely useful for solving a range of date- and time-related challenges.
    It is another example of a successful and popular package within the Python Package
    Index.'
  prefs: []
  type: TYPE_NORMAL
- en: lxml
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `lxml` toolkit ([http://lxml.de](http://lxml.de)) is an example of a highly
    successful Python package that acts as a wrapper for two existing C libraries.
    As the well-written web site says, `lxml` takes the pain out of reading and writing
    XML- and HTML-formatted documents. It has been modeled after an existing library
    in the Python Standard Library (`ElementTree`) but is much faster, has more features,
    and won't crash in unexpected ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code shows how `lxml` can be used to quickly generate
    XML-format data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print out an XML-formatted document with information about three
    classic movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Of course, `lxml` can do much more than this simple example shows. It can be
    used to parse documents as well as programmatically generate huge and complex
    XML files.
  prefs: []
  type: TYPE_NORMAL
- en: The `lxml` web site includes excellent documentation, including tutorials, information
    on how to install the package, and a complete API reference. For the particular
    tasks that it solves, `lxml` is extremely inviting and easy to use. It is no wonder
    that this is a highly popular package within the Python Package Index.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a reusable package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now take what we''ve learned and apply it to the design and implementation
    of a useful Python package. In the previous chapter, we looked at the concept
    of encapsulating a recipe using a Python module. Part of each recipe is the notion
    of an ingredient, which has three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the ingredient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much of the ingredient is needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The units in which the ingredient is measured
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we want to work with ingredients, we need to be able to handle units properly.
    For example, adding 1.5 kilograms to 750 grams involves more than adding the numbers
    1.5 and 750—you have to know how to *convert* these values from one unit to another.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of recipes, there are a number of rather unusual conversions that
    you need to support. For example, did you know that three teaspoons of sugar equals
    one tablespoon of sugar? To handle these types of conversions, let's write a unit
    conversion library.
  prefs: []
  type: TYPE_NORMAL
- en: Our unit converter will have to be aware of all the standard units used in cooking.
    These include cups, tablespoons, teaspoons, grams, ounces, pounds, and so on.
    Our unit converter will need some way of representing a quantity, such as 1.5
    kilograms, and of converting quantities from one unit to another.
  prefs: []
  type: TYPE_NORMAL
- en: As well as representing and converting quantities, we would like our library
    to be able to display quantities, automatically using the singular or plural version
    of the unit name as appropriate, for example, **6 cups**, **1 gallon**, **150
    grams**, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Since we're displaying quantities, it would also be helpful if our library could
    parse quantities. This way, the user could enter a value such as `3 tbsp` and
    our library would know that the user entered a quantity of three tablespoons.
  prefs: []
  type: TYPE_NORMAL
- en: The more we think about this library, the more it seems like a useful tool in
    its own right. We thought of this in connection with our recipe-handling program,
    but it seems that this could be an ideal candidate for a reusable module or package.
  prefs: []
  type: TYPE_NORMAL
- en: Following the guidelines we looked at earlier, let's consider how we can generalize
    our library as much as possible to make it more useful in other programs and to
    other programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than just thinking about the sorts of quantities you might find in a
    recipe, let's change the scope of our library to handle *any* type of quantity.
    It could handle weights, lengths, areas, volumes, and possibly even units of time,
    force, speed, and the like.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking of it like this, our library isn't so much a unit converter as a library
    that works with **quantities**. A quantity is a number and its associated units,
    for example, 150 millimeters, 1.5 ounces, or 5 acres. Our library, which we will
    call Quantities, will be a tool for parsing, displaying, and creating quantities,
    as well as converting quantities from one unit to another. As you can see, our
    initial concept for the library is now just one of the things that the library
    will be able to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now design our Quantities library in more detail. We''d like the user
    of our library to be able to create a new quantity very easily. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We also want to be able to parse a string into a quantity value, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We then want to be able to display a quantity in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We also want to be able to tell what kind of value a quantity is representing,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This will let us tell whether a quantity represents a weight, a length, or a
    distance, among others.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also retrieve the value and units for a quantity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need the ability to convert a quantity into a different unit. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we would like to be able to get a list of all the kinds of units that
    our library supports and the individual units of each kind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one final feature that our Quantities library will need to support:
    the ability to *localize* units and quantities. Unfortunately, the conversion
    values for certain quantities will vary depending on whether you are in the United
    States or elsewhere. For example, in the U.S. a teaspoon has a volume of approximately
    4.93 cubic centimeters, while in the rest of the world a teaspoon is considered
    to have a volume of 5 cubic centimeters. There are also naming conventions to
    deal with: in the U.S. the base unit of length in the metric system is referred
    to as a *meter*, while in the rest of the world the same unit is spelled *metre*.
    Our unit will have to handle both the different conversion values and the different
    naming conventions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we will need to support the notion of a **locale**. When our library
    is initialized, the caller will specify the locale under which our module should
    operate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will affect the conversion values and spelling used by the library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the complexity of our Quantities library, it doesn''t make sense to try
    and squeeze all this into a single module. Instead, we''ll break our library up
    into three separate modules: a `units` module which defines all the different
    type of units that we support, an `interface` module which implements the various
    public functions for our package, and a `quantity` module which encapsulates the
    concept of a quantity being a value and its associated unit.'
  prefs: []
  type: TYPE_NORMAL
- en: These three modules will be combined into a single Python package, which we
    will call `quantities`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we deliberately used the term *library* to refer to the system as
    we were designing it; this ensured that we didn't pre-empt our design by thinking
    of it as a single module or as a package. Only now is it clear that we are going
    to write a Python package. Often, something that you think of as a module will
    end up growing into a package. Occasionally the opposite happens. It's important
    to be flexible about this.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a good design for our Quantities library, what it will do,
    and how we'd like to structure it, let's start writing some code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a reusable package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section includes a lot of source code. Remember that you don't have to
    type it all in by hand; a complete copy of the `quantities` package is provided
    as part of the sample code that can be downloaded for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating the directory named `quantities` to hold our new package.
    Inside this directory, create a new file named `quantity.py`. This module will
    hold our implementation of a quantity—that is, a value together with its associated
    units.
  prefs: []
  type: TYPE_NORMAL
- en: While you don't need to understand object-oriented programming techniques to
    work through this book, this is the one place where we need to use object-oriented
    programming. This is because we want the user to be able to print a quantity directly,
    and the only way to do that in Python is to use objects. Don't worry, though—this
    code is very straightforward, and we'll take it one step at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `quantity.py` module, enter the following Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: What we are doing here is defining a new type of object called a `Quantity`.
    The second line looks very much like a function definition, only we are defining
    a special type of function, called a **method**, and giving it a special name,
    `__init__`. This method is used to initialize a new object when it is created.
    The `self` parameter refers to the object that is being created; as you can see,
    our `__init__` function takes two additional parameters named `value` and `units`,
    and stores these two values into `self.value` and `self.units`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our new `Quantity` object defined, we can create new objects and retrieve
    their values. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates a new object using the `Quantity` class, passing `1`
    for the `value` parameter and `"inch"` for the `units` parameter. The `__init__`
    method then stores these within the `value` and `units` attributes within the
    object. As you can see in the second line, it's easy to retrieve these attributes
    when we need them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve almost completed our implementation of the `quantity.py` module. There''s
    just one more thing to do: in order to be able to print a `Quantity` value, we
    need to add another method to our `Quantity` class; this one will be called `__str__`
    and will be used whenever we need to print a quantity. To do this, add the following
    Python code to the end of your `quantity.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that the `def` statement is indented to the same level as the `def
    __init__()` statement earlier so that it''s part of the class we''re creating.
    This will allow us to do things such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The Python `print()` function calls the specially named `__str__` method to
    get the text to display for a quantity. Our `__str__` method returns the value
    and the units, separated by a single space, which makes for a nicely formatted
    summary of the quantity.
  prefs: []
  type: TYPE_NORMAL
- en: This completes our `quantity.py` module. As you can see, working with objects
    wasn't as difficult as it might seem.
  prefs: []
  type: TYPE_NORMAL
- en: Our next task is to collect all the information we need to store about the various
    units that our package will support. Because there is a lot of information here,
    we'll put this into a module by itself, which we will call `units.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `units.py` module within your `quantities` package, and start by
    entering the following into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `UNITS` dictionary will map the kind of unit to a list of the units defined
    for that kind. For example, all units of length would go into the `UNITS['length']`
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each unit, we will store the information about that unit in the form of
    a dictionary with the following entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Dictionary entry | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | The name for this unit, for example, `inch`. |'
  prefs: []
  type: TYPE_TB
- en: '| `abbreviation` | The official abbreviation for this unit, for example, `in`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `plural` | The plural name for this unit. This is the name to use when there
    is more than one of this unit, for example, `inches`. |'
  prefs: []
  type: TYPE_TB
- en: '| `num_units` | The number of units needed to convert between these units and
    others of the same type. For example, if the `centimeter` unit had a `num_units`
    value of `1`, then the `inch` unit would have a `num_units` value of `2.54` because
    1 inch equals 2.54 centimeters. |'
  prefs: []
  type: TYPE_TB
- en: 'As we discussed in the previous section, we need to be able to localize our
    various units and quantities. To allow for this, all of these dictionary entries
    can either have a single value or a dictionary mapping each locale to a value.
    For example, the `liter` unit might be defined using the following Python dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to have a different spelling for the word `liter` in different
    locales. Other units might have different numbers of units or different abbreviations,
    depending on the locale selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how we''re going to store our various unit definitions, let''s
    implement the next part of our `units.py` module. To avoid having to repetitively
    type lots of unit dictionaries, we''re going to create a few helper functions.
    Add the following to the end of your module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This function will return a dictionary mapping the `us` and `international`
    locales to the given values, making it easier to create a locale-specific dictionary
    entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following function to your module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This complex-looking function creates the dictionary entry for a single unit.
    It uses the special `*args` parameter form to accept a variable number of parameters;
    the caller can provide either an abbreviation, a name, and the number of units,
    or else the abbreviation, the name, the plural name, and the number of units.
    If the plural name is not provided, it is calculated automatically by adding `s`
    to the end of the unit's singular name.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the logic here allows for the possibility of the name being a dictionary
    of locale-specific names; if the name is localized, then the plural name will
    also be calculated on a locale-by-locale basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we define a simple helper function that makes it easier to define
    a list of units all at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'With all these helper functions in place, it will be quite easy for us to add
    our various units to the `UNITS` dictionary. Add the following code to the end
    of your module; this defines the various weight-based units that our package will
    support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add some length-based units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we've use the `by_locale()` function to create different versions
    of the unit name and plural name based on the user's current locale. We also supply
    the plural name for the `inch` and `foot` units as these can't be calculated by
    adding an `s` to the singular version of the name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add some area-based units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll define some volume-based units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: For the `"cup"` unit, we are localizing the number of units rather than the
    name. This is because in the US a cup is considered to be `236.588` mls, while
    elsewhere in the world a cup is measured as 250 mls.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These unit listings have been abbreviated to keep the code listing to a reasonable
    size. The version of the `quantities` package included in the sample code for
    this chapter has a more comprehensive list of units.
  prefs: []
  type: TYPE_NORMAL
- en: 'This completes our unit definitions. To make it easy for our code to use these
    various units, we''re going to add two extra functions to the end of our `units.py`
    module. First off is a function to choose the appropriate localized version of
    a value from a unit''s dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we check to see if `value` is a dictionary; if so, we return
    the entry within that dictionary for the supplied `locale`. Otherwise, we return
    `value` directly. We'll use this function whenever we need to retrieve a name,
    plural name, abbreviation, or value from a unit's dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second function we are going to need is a function to search through the
    various units stored in the `UNITS` global variable. We want to be able to find
    a unit based on its singular or plural name, or its abbreviation, allowing for
    the spelling specific to the current locale. To do this, add the following code
    to the end of the `units.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we use `s.lower()` to convert the string to lowercase before checking
    it. This ensures that we find the `inch` unit, for example, even if the user spelled
    it as `Inch` or `INCH`. Upon completion, our `find_units()` function returns the
    kind of unit and the unit dictionary for the found unit, or `(None, None)` if
    the unit can't be found.
  prefs: []
  type: TYPE_NORMAL
- en: This completes the `units.py` module. Let's now create the `interface.py` module,
    which will hold the public interface to our `quantities` package.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could put all this code directly in the package initialization file, `__init__.py`,
    but this can be a bit confusing as many programmers don't expect to find code
    within an `__init__.py` file. Instead, we'll define all our public functions in
    the `interface.py` module, and import the contents of this module into `__init__.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `interface.py` module, placing it into the `quantities` package
    directory alongside `units.py` and `quantities.py`. Then, add the following `import`
    statements to the top of this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are using a relative import statement to load the `UNITS`
    global variable and the `localize()` and `find_unit()` functions from our `units.py`
    module. We then use another relative import to load the `Quantity` class which
    we defined in our `quantity.py` module. This makes these important functions,
    classes, and variables available for our code to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to implement the various functions we identified in the previous
    section of this chapter. We''ll start with `init()`, which initializes the entire
    quantities package. Add the following to the end of your `interface.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The caller will provide the name of a locale (which should be a string containing
    either `us` or `international` as these are the two locales we are supporting),
    which we store into a private global variable named `_locale`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function we want to implement is `new()`. This lets the user define
    a new quantity by supplying a value and the name of the desired units. We''ll
    use the `find_unit()` function to make sure the unit exists, and then create and
    return a new `Quantity` object with the supplied value and units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Because the name of the unit can vary depending on the locale, we use the `_locale`
    private global variable to help find the unit with the supplied name, plural name,
    or abbreviation. Once a unit has been found, we use the official name of that
    unit to create a new `Quantity` object, which we then return to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'As well as creating a new quantity by supplying the value and units, we also
    need to implement a `parse()` function that converts a string into a `Quantity`
    object. Let''s do this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We split the string at the first space, converting the first part into a floating-point
    number and searching for a unit with a name or abbreviation equal to the second
    part of the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we need to write some functions to return information about a quantity.
    Let''s just go ahead and implement these functions by adding the following code
    to the end of your `interface.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: These functions allow the user of our package to identify the kind of units
    associated with a given quantity (for example, length, weight, or volume), and
    to retrieve a quantity's value and units.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the user could also retrieve these last two values by accessing the
    attributes within the `Quantity` object directly, for example, `print(q.value)`.
    We can't stop the user from doing this but, because we're not implementing this
    as an object-oriented package, we don't want to encourage it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are almost there. Our next function will convert a quantity from one unit
    to another, returning a `ValueError` if the conversion is impossible. Here is
    the necessary code to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The final two functions we need to implement return a list of the different
    kinds of unit we support and a list of the individual units of a given kind. Here
    are the final two functions for our `interface.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve finished implementing the `interface.py` module, there is only
    one last thing to do: create the package initialization file for our `quantities`
    package, `__init__.py`, and enter the following into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This makes all of the functions we defined in the `interface.py` module available
    to users of our package.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our reusable package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve written the code (or alternatively, downloaded it), let''s
    take a look at how this package works. In a terminal window, set the current directory
    to the folder containing your `quantities` package directory, and type `python`
    to start the Python interpreter. Then, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: If you haven't made any mistakes in typing in the source code, the interpreter
    should come back without any errors. If you have made any typos, you'll need to
    fix them before you can proceed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have to initialize our `quantities` package by supplying the locale
    we want to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If you are in the United States, feel free to replace the value `international`
    with `us` so that you get localized spelling and units for your country.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple quantity, and then ask the Python interpreter to display
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the international spelling for the word `kilometer` is automatically
    used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try converting this unit into inches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'There are other functions we haven''t tested yet, but already we can see that
    our `quantities` package solves a very general problem, conforms to the Python
    Style guide, and is easy to use. It isn''t quite an ideal reusable module, but
    it''s close. Here are a few things we could do to improve it:'
  prefs: []
  type: TYPE_NORMAL
- en: Restructure our package to be more object-oriented. For example, instead of
    calling `quantities.convert(q, "inch")`, users could simply say `q.convert("inch")`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve the implementation of the `__str__()` function so that the unit name
    is displayed as a plural if the value is greater than one. Also, change the code
    to avoid floating-point rounding issues, which can produce odd results when printing
    out certain quantity values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add functions (or methods) to add, subtract, multiply, and divide quantities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add docstrings to our package source code, and then use a tool such as **Sphinx**
    ([http://www.sphinx-doc.org](http://www.sphinx-doc.org)) to convert the docstrings
    into API documentation for our package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upload the source code for the `quantities` package to **GitHub** ([https://github.com](https://github.com))
    to make it easier to obtain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a web site (possibly as a simple README file within the GitHub repository)
    so that people can find out more about this package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Submit the package to the PyPI so that people can find it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feel free to extend the `quantities` package and submit it if you want; this
    is only an example for this book, but it certainly has potential as a general-purpose
    (and popular) reusable Python package.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the concept of a reusable module or package. We
    saw how reusable packages and modules can be used to share code with other people.
    We learned that a reusable module or package needs to function as a standalone
    unit, should ideally use relative imports, and should note any external dependencies
    it may have. Ideally, a reusable package or module will also solve a general problem
    rather than a specific one, follow standard Python coding conventions, and have
    good documentation. We then looked at some examples of good reusable modules,
    before writing one of our own.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at some of the more advanced aspects of working
    with modules and packages in Python.
  prefs: []
  type: TYPE_NORMAL
