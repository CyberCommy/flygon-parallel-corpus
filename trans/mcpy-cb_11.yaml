- en: Interacting with the Filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover a number of recipes, all relating to interacting
    with the filesystem. The first recipe will touch on how to remount the filesystem
    on devices that require this before you can modify any files using your Python
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Then, recipes on listing, removing, and creating files will be covered. Also,
    more advanced topics, such as calculating disk usage, will be covered. The recipes
    in this chapter will give you the tools you need to add filesystem interaction
    to your embedded projects. This can come in handy when you want to log sensor
    data to a file, or when you want your code to read and load a set of files into
    a data structure. It can also be helpful when you have to list a set of images
    to be displayed in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Remounting the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading a file's contents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a file's contents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating disk usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter can be found in the `Chapter11` folder in this
    book's GitHub repository, available at [https://github.com/PacktPublishing/MicroPython-Cookbook](https://github.com/PacktPublishing/MicroPython-Cookbook).
  prefs: []
  type: TYPE_NORMAL
- en: CircuitPython 3.1.2 was used for all the recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Remounting the filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to remount the filesystem so that it can have
    data written to it from your Python scripts. Some boards, such as Circuit Playground
    Express, will expose the connected device as a USB drive by default to make it
    easy to edit and save your code. The trade-off of this approach, however, is that
    your Python code cannot write or change any of the contents on the board's storage. On
    these boards, you must remount the filesystem to allow your script to write data
    to its filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this recipe, you'll know how to allow data to be written to the
    filesystem, and how to revert changes, which will become essential for certain
    projects. If, for example, you wanted to use Circuit Playground Express to record
    temperature readings to a log file, you would need to utilize this type of approach.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to remount the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The Python code was able to open a file for reading. However, if you try and
    open a file to write, as shown in the following code block, you will get an `OSError` instance
    because the filesystem is in read-only mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We will now create a script that will remount the filesystem to allow the reading
    and writing of data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code should be saved into the `boot.py` file. If the file doesn''t
    exist, then you will have to create it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Eject the `CIRCUITPY` drive from your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unplug the board from your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reconnect the board to your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL to confirm that your code can write
    data to a file on the board''s storage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code, when run in the REPL, will remove the `boot.py`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To apply these changes to the boot process, eject the `CIRCUITPY` drive from
    your computer again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unplug the board from your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reconnect the board to your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should be able to edit and save the contents of the `main.py` file, just
    like you did previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Circuit Playground Express provides you with a way to enable reading and writing
    to the storage from your Python scripts. We put the code in the `boot.py` file
    as this script will be run early on in the boot process, before the `main.py` file
    (which will include our main code base).
  prefs: []
  type: TYPE_NORMAL
- en: In the `boot.py` script, we import the `storage` module and then calls its `remount`
    function with the second argument set as `False`, indicating that the filesystem
    should be mounted in read and write mode. Whenever we make changes to the `boot.py`
    file, whether it is creating or removing the file, we must do a hard reset on
    the board by unplugging and reconnecting the board for the changes to take effect.
    As shown in this recipe, the simplest way to revert this change is to delete the
    `boot.py` file from the REPL.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally speaking, only boards that offer the USB-drive editing feature will
    require this extra step of remounting the filesystem. For example, the ESP8266
    does not have the USB drive feature, and so it doesn't require this step. It's
    also important to note that once you enable writing to the filesystem from your
    code, you won't be able to edit your `main.py` file in your text editor. Whenever
    you want to go back to editing your code, you will have to remove the `boot.py`
    file. If your project only needs read-only access to the filesystem, to do things
    such as listing files and reading a file's contents, then you can run it safely
    in either mode.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `mount` function can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/storage/__init__.html#storage.mount](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/storage/__init__.html#storage.mount).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on writing to the filesystem can be found at [https://learn.adafruit.com/cpu-temperature-logging-with-circuit-python/writing-to-the-filesystem](https://learn.adafruit.com/cpu-temperature-logging-with-circuit-python/writing-to-the-filesystem).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how you can list files and directories in MicroPython.
    We will also show the techniques that you can use to filter a listing so that
    it only includes files or only includes directories. Once you have the ability
    to interact with the filesystem in this way, you can use it in your own projects,
    where your code will accept a dynamic list of files on the board that doesn't
    need to be hardcoded in your program. In this way, the files might represent a
    set of configurable audio files that you want to play, or a collection of images
    that you will display on an attached screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to list files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following block of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A listing of all the files and directories in the top-level folder will have
    been generated. The following block of code will generate the same listing, but
    a sorted one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also list files in a specific directory, as shown in the following block
    of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will check and show that the `lib` path is not
    a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now confirm that `main.py` is detected as a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code defines and calls the `isfile` function on two
    paths to verify their type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will list all the files in the root path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will list all the directories in the root path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When executed, this script will print out the sorted listing of files and directories
    in the root path.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After importing the `os` module, a function called `isfile` is defined that
    will return `True` or `False`, depending on whether the provided path is a file
    or a directory. The `main` function is defined and called, after which it will
    generate a list of path names. The first list will retrieve the sorted list of
    paths and then filter the list so that only files are retained. This list is then
    printed. The same approach is then taken to get a list of directories and print
    them out.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe has introduced a number of techniques that can come in handy when
    dealing with files. It showed that file listings are not returned in alphabetical
    order by default, so if this is needed, the built-in `sorted` function can be
    used to sort the list of files. It also defines a function called `isfile` to
    inspect whether a specific path is a file. You could create an equivalent `isdir`
    function if so desired. This recipe also showed a simple approach of using list
    comprehensions to filter out the default listing to generate filtered lists of
    paths that contain only certain types of entries, such as files or directories.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `listdir` function can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.listdir](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.listdir).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `stat` function can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.stat](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.stat).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `isfile` function can be found at [https://docs.python.org/3/library/os.path.html#os.path.isfile](https://docs.python.org/3/library/os.path.html#os.path.isfile).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how you can remove files and directories in MicroPython.
    There are separate functions for deleting a file and deleting a directory. We
    will show you how to call these different functions for each type of path. Then,
    we will show you how you can create a generic function that can automatically
    remove either type of path.
  prefs: []
  type: TYPE_NORMAL
- en: There are many situations in the projects that you create where you need to
    resort to deleting files. You might create a project that logs data to a file.
    Log rotation is a mechanism that lets you create new log files periodically and
    remove old ones automatically. You will need functions that delete files in order
    to implement log rotation. The issue of removing files to conserve space becomes
    even more important in many MicroPython-embedded projects because you are often
    dealing with limited storage capacity on these boards.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe. Make sure that you've completed the *Remounting the
    filesystem* recipe of this chapter, as you'll need write access to the storage
    system in order to remove files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to remove files:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `hi.txt` in the root path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the REPL to run the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `hi.txt` file has now been deleted from the board''s filesystem. Run the
    following block of code. It should go through an exception because the file does
    not exist anymore:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Create a directory called `mydir` in the root path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following block of code will delete the `mydir` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code defines the `isfile` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now define a function called `any_remove` that will remove any type
    of path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Create a file called `hi.txt` and a directory called `mydir`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding block of code has now deleted this file and directory using the
    same function call.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `any_remove` function that is defined first takes the path and sets a variable
    called `func`. This variable will store the callable that needs to be called to
    delete the provided path. The type of the path is checked and `func` is set as
    either `os.remove` or `os.rmdir`, depending on the type of path that's provided.
    This function is then called with the provided path to perform the actual deletion.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe has introduced a technique that you can use to create a convenience
    function that accepts any type of path and will call the correct underlying function
    to remove it. One thing to keep in mind is that you can only delete a directory
    that is empty. The functions and examples in this recipe support deleting directories
    that are empty, but will fail if called with a directory that has files inside
    it. You could extend the `delete` function to do recursive directory listings
    and then delete all the subfolders and directories.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `remove` function can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.remove](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.remove).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `rmdir` function can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.rmdir](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.rmdir).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to create a directory in MicroPython. We will
    also show you how to create a function that can be called multiple times with
    the same path and will only create a directory if the directory doesn't exist
    yet. Then, we will define a function to behave just like the `makedirs` function,
    which is a part of the Python standard library but is not included in MicroPython.
  prefs: []
  type: TYPE_NORMAL
- en: These set of features can be useful whenever you need to create a project that
    might necessitate the creation a specific directory tree and then populate it
    with a certain set of files. It also helps to have access to these functions when
    you are working on a board such as the ESP8266, which will only let you create
    the directories you need through the REPL and your Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe. Make sure that you've completed the *Remounting the
    filesystem* recipe in this chapter since write access to the storage system is
    needed for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to create a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A directory called `mydir` has now been created. When you run the following
    block of code, an exception will be raised because the directory already exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will define a function that returns `True` or `False`,
    depending on whether a path exists or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will call the `exists` function on two different
    paths to verify it is working correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now define a function called `mkdir_safe`, which will only make directories
    when they don''t exist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will call the `mkdir_safe` function multiple times
    on the same path, with no exceptions being thrown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now define a function that will recursively create directories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding block of code, when executed, will create three directories in
    the correct order, from top to bottom.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, three different functions were defined and used, each one performing
    a specific function. The `exists` function checks whether a path exists and returns
    `True` or `False`. This check attempted to call the `stat` function on a path
    and catches any `OSError` that might be raised. If the path exists, this exception
    won't be raised and a `True` value is returned; otherwise, a `False` value is
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: The next function, `mkdir_safe`, simply checks if a path exists and only calls
    the `mkdir` function on paths that don't exist. Finally, the `makedirs` function
    is defined, which receives a path with multiple levels. The path is split into
    its separate pieces, and then the list of paths to be created is saved in a list
    in the correct order, from the highest path to the lowest path. Each path is looped
    through and created by calling the `mkdir` function.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe introduced three generic functions, each of which serve a specific
    purpose. By creating pieces of code in this fashion, it makes it easier to take
    pieces of one project and incorporate them into others. Two of the defined functions—`exists`
    and `makedirs`—are a part of the Python standard library, but are not found in
    MicroPython. This recipe demonstrates that, in many cases, even when there is
    some function in the Python standard library that you miss, you can frequently
    create your own implementation in MicroPython.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `mkdir` function can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.mkdir](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.mkdir).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `makedirs` function can be found at [https://docs.python.org/3/library/os.html#os.makedirs](https://docs.python.org/3/library/os.html#os.makedirs).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `exists` function can be found at [https://docs.python.org/3/library/os.path.html#os.path.exists](https://docs.python.org/3/library/os.path.html#os.path.exists).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading a file's contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to read the contents of a file into variables
    in your scripts. This recipe will cover ways of reading in file contents as a
    string, as well as reading it in as a byte object. Many projects that you create
    will often need to open different data files, such as audio files, images, and
    text files. This recipe will provide you with the basic building blocks so that
    you can facilitate these interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to read a file''s contents:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `hi.txt` in the root path with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the following block of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of the file called `hi.txt` are read into a variable called `data`,
    which is then displayed as output. The following block of code also reads the
    file''s contents into a variable, but uses the `with` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to read the file''s contents into a variable with a single line
    of code, as shown in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the following block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The preceding block of code, when executed, will read the file's contents as
    a `bytes` object instead of a string.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we have explored four different ways of reading data from a
    file. The first method uses the `open` function to get a file object. Then, data
    is read from this file object and closed. We can then improve upon this older
    style of file handling, as shown in the second example, by using the `with` statement,
    which will automatically close the file once we exit the `with` block. The third
    example opens and reads the contents all in one line. The `open` function accepts
    the file mode since it's the second argument. If we pass it the `rb` value, then
    it will open the file for reading in binary mode. This will then result in a bytes
    object being returned, instead of a string.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to choose the correct method of reading file data, depending on
    the data you expect to interact with. If your data files are plain text files,
    then the default text mode will suffice. However, if you're reading raw audio
    data in the `.wav` file format, which you will need to do to read in the data
    as binary data, exceptions may occur because the data might not be able to be
    decoded into strings.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `open` function can be found at [https://docs.python.org/3/library/functions.html#open](https://docs.python.org/3/library/functions.html#open).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `with` statement can be found at [https://docs.python.org/3/reference/compound_stmts.html#with](https://docs.python.org/3/reference/compound_stmts.html#with).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a file's contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to write data to an output file. We will cover
    how to write strings, as well as bytes, to a file. We will then define a type
    of object to make it easier to perform these common operations of writing text
    and binary data to files. If you want to create a project that saves sensor data
    to a log file or records some user-generated data to the board's storage, then
    you will need to use many of the techniques we'll describe in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe. Make sure that you've completed the *Remounting the
    filesystem* recipe in this chapter as this recipe needs write access to the storage
    system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to write a file''s contents:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the REPL to run the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The text reading `hi there` has been written to a file called `hi.txt` using
    the file object''s `write` method. The number of bytes written is then returned
    and displayed. The following block of code will take a bytes object and give it
    to the `write` method so that it can write the data to the provided file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will define a `Path` class with two methods. One
    method will initialize new objects, while the other will generate a representation
    of the object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the following block, we will have a `Path` class with two additional
    methods so that we can write text and binary data to a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the following block of code into a file called `pathlib.py` so that it
    can be imported:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: When this script gets executed, it will write the text `hi there` message into
    the `hi.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we started off by showing the two most straightforward ways
    of writing bytes and text data to files. Then, we created a class called `Path`,
    which we build in two stages. The first version lets us create `Path` objects
    that keep track of their path and return a human-readable representation when
    requested.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we added helper methods to assist in writing text data or binary data.
    The name of the class and its methods follow the same naming and functionality
    as the `Path` object in the Python `pathlib` module, which comes with the standard
    library. The final code block shows a simple example of importing the `pathlib`
    module and calling its `write_text` method to save some text to a file.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might find yourself in a situation in some projects where you have to interact
    with files, their paths, and have to write and read data frequently. In these
    situations, it can be very helpful to be equipped with a class that simplifies
    your access to files. The `Path` object that was defined in this recipe is great
    for this purpose. We have also followed the same naming and functionality of a
    module that is part of Python's standard library. This will make our code more
    readable and portable when we want to run it on a computer that has a full Python
    installation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `write_bytes` method can be found at [https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_bytes](https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_bytes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `write_text` method can be found at [https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_text](https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_text).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating disk usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to check a number of figures related to the storage
    system. We will retrieve the filesystem's block size, the total number of blocks,
    and the number of free blocks. We can then use these figures to calculate a number
    of useful figures, such as the total disk capacity and how much space is used
    and free on the disk.
  prefs: []
  type: TYPE_NORMAL
- en: We'll then package all this code into a function to make it easier to call whenever
    we need access to this information. You can use the techniques shown in this recipe
    to achieve a number of things in your projects. For example, you could use it
    to find out how much total storage is available on the device since this varies
    between different boards. You can even use it to decide if the disk is getting
    too full and whether your script should delete some old log files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to calculate disk usage:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now retrieved all the key filesystem information, but it is presented
    as a tuple, which makes it difficult to know which figure relates to what. In
    the following block of code, we will assign the values we care about to more human-readable
    variable names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have this key information in human-readable variables, we can proceed
    with the following block of code to calculate the main values we are interested
    in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will wrap all this logic into a single function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function will format the values, represented as bytes, in a more
    human-readable fashion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create a function that prints a number of key figures related to
    total disk size and usage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: When this script gets executed, it will print out details on the free, used,
    and total disk space.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `statvfs` function returns a number of key figures relating to the filesystem
    that is on the board. We care about three values in this tuple, which map to the
    `block_size`, `total_blocks`, and `free_blocks` variables. We can multiply these
    values together to calculate the amount of free, used, and total disk space in
    terms of bytes. Then, the `format_size` function is defined to convert bytes values
    into `KiB`, add a thousand separator, and right-align the values. The `print_stats`
    function simply combines all this code by getting the filesystem's `stats` and
    calling the `format_size` function on each value.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Circuit Playground Express comes with 2 MB of flash storage, which can be seen
    in the output of this recipe. MicroPython uses the FAT format for its filesystem.
    One thing that you can experiment with is adding a number of files on the board
    and then rerunning the script to see the changes in filesystem usage. Keep in
    mind that for you to see these changes reflected on a number of boards, you will
    have to eject the USB device and plug it back in to get the latest filesystem
    usage figures.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `statvfs` function can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.statvfs](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.statvfs).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details on the information returned by `statvfs` can be found at [http://man7.org/linux/man-pages/man3/statvfs.3.html](http://man7.org/linux/man-pages/man3/statvfs.3.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
