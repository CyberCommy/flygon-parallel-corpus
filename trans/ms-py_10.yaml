- en: Chapter 10. Testing and Logging – Preparing for Bugs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When programming, most developers plan a bit and immediately continue writing
    code. After all, we all expect to write bug-free code! Unfortunately, we don't.
    At some point, an incorrect assumption, a misinterpretation, or just a silly mistake
    is bound to happen. Debugging (covered in [Chapter 11](ch11.html "Chapter 11. Debugging
    – Solving the Bugs"), *Debugging – Solving the Bugs*) will always be required
    at some point, but there are several methods that you can use to prevent bugs
    or, at the very least, make it much easier to solve them when they do occur.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent bugs from occurring in the first place, test-driven development or,
    at the very least, functional/regression/unit tests are very useful. The standard
    Python installation alone offers several options such as the `doctest`, `unittest`,
    and `test` modules. The `doctest` module allows you to combine tests with example
    documentation. The `unittest` module allows you to easily write regression tests.
    The `test` module is meant for internal usage only, so unless you are planning
    to modify the Python core, you probably won't need this one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test modules we will discuss in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`doctest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`py.test` (and why it''s more convenient than `unittest`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unittest.mock`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `py.test` module has roughly the same purpose as the `unittest` module,
    but it's much more convenient to use and has a few extra options.
  prefs: []
  type: TYPE_NORMAL
- en: After learning how to avoid the bugs, it's time to take a look at logging so
    that we can inspect what is happening in our program and why. The logging module
    in Python is highly configurable and can be adjusted for just about any use case.
    If you've ever written Java code, you should feel right at home with the `logging`
    module, as its design is largely based on the `log4j` module and is very similar
    in both implementation and naming. The latter makes it a bit of an odd module
    in Python as well, as it is one of the few modules that do not follow the `pep8`
    naming standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will explain the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Combining documentation with tests using `doctest`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regression and unit tests using `py.test` and `unittest`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with fake objects using `unittest.mock`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `logging` module effectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining `logging` and `py.test`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using examples as tests with doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `doctest` module is one of the most useful modules within Python. It allows
    you to combine documenting your code with tests to make sure that it keeps working
    as it is supposed to.
  prefs: []
  type: TYPE_NORMAL
- en: A simple doctest example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with a quick example: a function that squares the input. The following
    example is a fully functional command-line application, containing not only code
    but also functioning tests. The first few tests cover how the function is supposed
    to behave when executing normally, followed by a few tests to demonstrate the
    expected errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be executed as any Python script, but the regular command won''t give
    any output as all tests are successful. The `doctest.testmod` function takes verbosity
    parameters, luckily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, since it uses the Google syntax (as discussed in [Chapter 9](ch09.html
    "Chapter 9. Documentation – How to Use Sphinx and reStructuredText"), *Documentation
    – How to Use Sphinx and reStructuredText*, the documentation chapter), we can
    generate pretty documentation using Sphinx:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A simple doctest example](images/4711_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: However, the code is not always correct, of course. What would happen if we
    modify the code so that the tests do not pass anymore?
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, instead of `n * n`, we use `n ** 2`. Both square a number right?
    So the results must be identical. Right? These are the types of assumptions that
    create bugs, and the types of assumptions that are trivial to catch using a few
    basic tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'So let''s execute the test again and see what happens this time. For brevity,
    we will skip the verbosity flag this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The only modification we made to the code was replacing `n * n` with `n ** 2`,
    which translates to the power function. Since multiplication is not the same as
    taking the power of a number, the results are slightly different but similar enough
    in practice that most programmers wouldn't notice the difference.
  prefs: []
  type: TYPE_NORMAL
- en: The only difference caused by the code change was that we now have a different
    exception—an innocent mistake, only breaking the tests in this case. But it shows
    how useful these tests are. When rewriting code, an incorrect assumption is easily
    made, and that is where tests are most useful—knowing you are breaking code as
    soon as you break it instead of finding out months later.
  prefs: []
  type: TYPE_NORMAL
- en: Writing doctests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perhaps, you have noticed from the preceding examples that the syntax is very
    similar to the regular Python console, and that is exactly the point. The `doctest`
    input is nothing more than the output of a regular Python shell session. This
    is what makes testing with this module so intuitive; simply write the code in
    the Python console and copy the output into a docstring to get tests. Here is
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That's why this is probably the easiest way to test code. With almost no effort,
    you can check whether your code is working as you would expect it, add tests,
    and add documentation at the same time. Simply copy the output from the interpreter
    to your function or class documentation and you have functioning doctests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with pure documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The docstrings in functions, classes, and modules are usually the most obvious
    way to add doctests to your code, but they are not the only way. The Sphinx documentation,
    as we discussed in the previous chapter, also supports the `doctest` module. You
    might remember that when creating the Sphinx project, we enabled the `doctest`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This flag enables the `sphinx.ext.doctest` extension in Sphinx, which tells
    Sphinx to run those tests as well. Since not all the examples in the code are
    useful, let''s see whether we can split them between the ones that are actually
    useful and the ones that are only relevant for documentation. Moreover, to see
    the results, we will add an error to the documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**square.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**square.rst**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to execute the tests. In the case of Sphinx, there is a specific
    command for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, we are getting an error for the incomplete `doctest`, but beyond
    that, all tests executed correctly. To make sure that the tests know what `square`
    is, we had to add the `testsetup` directive, and this still generates a pretty
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing with pure documentation](images/4711_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The doctest flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `doctest` module features several option flags. They affect how `doctest`
    processes the tests. These option flags can be passed globally using your test
    suite, through command-line parameters while running the tests, and through inline
    commands. For this book, I have globally enabled the following option flags through
    a `pytest.ini` file (we will cover more about `py.test` later in this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Without these option flags, some of the examples in this book will not function
    properly. This is because they have to be reformatted to fit. The next few paragraphs
    will cover the following option flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DONT_ACCEPT_TRUE_FOR_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NORMALIZE_WHITESPACE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ELLIPSIS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several other option flags available with varying degrees of usefulness,
    but these are better left to the Python documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/doctest.html#option-flags](https://docs.python.org/3/library/doctest.html#option-flags)'
  prefs: []
  type: TYPE_NORMAL
- en: True and False versus 1 and 0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Having `True` evaluating to `1` and `False` evaluating to `0` is useful in
    most cases, but it can give unexpected results. To demonstrate the difference,
    we have these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the results of the `DONT_ACCEPT_TRUE_FOR_1` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `DONT_ACCEPT_TRUE_FOR_1` flag makes `doctest` reject `1`
    as a valid response for `True` as well as `0` for `False`.
  prefs: []
  type: TYPE_NORMAL
- en: Normalizing whitespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since doctests are used for both documentation and test purposes, it is pretty
    much a requirement to keep them readable. Without normalizing whitespace, this
    can be tricky, however. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'While not all that bad, this output isn''t the best for readability. With whitespace
    normalizing, here is what we can do instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Formatting the output in this manner is both more readable and convenient for
    keeping your line length less.
  prefs: []
  type: TYPE_NORMAL
- en: Ellipsis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ELLIPSIS` flag is very useful but also a bit dangerous, as it can easily
    lead to incorrect matches. It makes `...` match any substring, which is very useful
    for exceptions but dangerous in other cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: These cases are not too useful in real scenarios, but they demonstrate how the
    `ELLIPSIS` option flag functions. They also indicate the danger. Both `[1, 2,
    3, 4]` and `[1, 0, ... , 4]` match the `[1, ..., 4]` test, which is probably unintentional,
    so be very careful while using `ELLIPSIS`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more useful case is when documenting class instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Without the `ELLIPSIS` flag, the memory address (the `0x...` part) would never
    be what you expect. Let''s demonstrate an actual run in a normal CPython instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Doctest quirks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The three option flags discussed earlier take care of quite a few quirks found
    in doctests, but there are several more cases that require care. In these cases,
    you just need to be a bit careful and work around the limitations of the `doctest`
    module. The `doctest` module effectively uses the representation string, and those
    are not always consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important cases are floating-point inaccuracies, dictionaries, and
    random values, such as timers. The following example will fail most of the time
    because certain types in Python have no consistent ordering and depend on external
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: All the problems have several possible solutions, which differ mostly in style
    and your personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: Testing dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The problem with dictionaries is that they are internally implemented as hash
    tables, resulting in an effectively random representation order. Since the `doctest`
    system requires a representation string that is identical in meaning (save for
    certain `doctest` flags, of course) to the `docstring`, this does not work. Naturally,
    there are several workaround options available and all have some advantages and
    disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is using the `pprint` library to format it in a pretty way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Since the `pprint` library always sorts the items before outputting, this solves
    the problem with random representation orders. However, it does require an extra
    import and function call, which some people prefer to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option is manual sorting of the items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The downside here is that it is not visible from the output that `data` is a
    dictionary, which makes the output less readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, comparing the `dict` with a different `dict` comprised of the same
    elements works as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A perfectly okay solution, of course! But `True` is not really the clearest
    output, especially if the comparison doesn''t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the other options presented previously show both the expected
    value and the returned value correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Personally, out of the solutions presented, I would recommend using `pprint`,
    as I find it the most readable solution, but all the solutions have some merits
    to them.
  prefs: []
  type: TYPE_NORMAL
- en: Testing floating-point numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the same reason as a floating-point comparison can be problematic (that
    is, `1/3 == 0.333`), a representation string comparison is also problematic. The
    easiest solution is to simply add some rounding/clipping to your code, but the
    `ELLIPSIS` flag is also an option here. Here is a list of several solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When the `ELLIPSIS` option flag is enabled globally anyhow, that would be the
    most obvious solution. In other cases, I recommend one of the alternative solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Times and durations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For timings, the problems that you will encounter are quite similar to the
    floating-point issues. When measuring the duration execution time of a code snippet,
    there will always be some variation present. That''s why the most stable solution
    for tests, including time, is limiting the precision, although even that is no
    guarantee. Regardless, the simplest solution checks whether the delta between
    the two times is smaller than a certain number, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `timedelta` objects, however, it''s slightly more complicated. Yet,
    this is where the `ELLIPSIS` flag definitely comes in handy again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The alternative to the `ELLIPSIS` option flag would be comparing the days, hours,
    minutes, and microseconds in `timedelta` separately.
  prefs: []
  type: TYPE_NORMAL
- en: In a later paragraph, we will see a completely stable solution for problems
    like these using mock objects. For doctests, however, that is generally overkill.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with py.test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `py.test` tool makes it very easy to write tests and run them. There are
    a few other options such as `nose` and the bundled `unittest` module available,
    but the `py.test` library offers a very good combination of usability and active
    development. In the past, I was an avid `nose` user but have since switched to
    `py.test` as it tends to be easier to use and has better community support, in
    my experience at least. Regardless, `nose` is still a good choice, and if you're
    already using it, there is little reason to switch and rewrite all of your tests.
    When writing tests for a new project, however, `py.test` can be much more convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will run the doctests from the previously discussed `square.py` file
    using `py.test`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, start by installing `py.test`, of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can do a test run, so let''s give the doctests we have in `square.py`
    a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The difference between the unittest and py.test output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have the doctests in `square.py`. Let's create a new class called `cube`
    and create a proper set of tests outside of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we have the code of `cube.py`, similar to `square.py` but minus
    the doctests, since we don''t need them anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s start with the `unittest` example, `test_cube.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be executed by executing the file itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it can be done through the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This one is through `py.test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We even have `nose`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As long as all the results are successful, the differences between `unittest`
    and `py.test` are slim. In the case of `unittest` and `nose`, the results are
    identical. This time around, however, we are going to break the code to show the
    difference when it actually matters. Instead of the `cube` code, we will add the
    `square` code. So returning `n ** 2` instead of `n ** 3` from `square`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we have the regular `unittest` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Not all that bad, as per each test returns a nice stack trace that includes
    the values and everything. Yet, we can observe a small difference here when compared
    with the `py.test` run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In small cases such as these, the difference is not all that apparent, but when
    testing complicated code with large stack traces, it becomes even more useful.
    However, for me personally, seeing the surrounding test code is a big advantage.
    In the example that was just discussed, the `self.assertEqual(...)` line shows
    the entire test, but in many other cases, you will need more information. The
    difference between the regular `unittest` module and the `py.test` module is that
    you can see the entire function with all of the code and the output. Later in
    this chapter, we will see how powerful this can be when writing more advanced
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To truly appreciate the `py.test` output, we need to enable colors as well.
    The colors depend on your local color schemes, of course, but it''s useful to
    see them side by side at least once, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The difference between the unittest and py.test output](images/4711_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Perhaps you are wondering now, "Is that all?" The only difference between `py.test`
    and `unittest` is a bit of color and a slightly different output? Well, far from
    it, there are many other differences, but this alone is enough reason to give
    it a try.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between unittest and py.test tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The improved output does help a bit, but the combination of improved output
    and a much easier way to write tests is what makes `py.test` so useful. There
    are quite a few methods for making the tests simpler and more legible, and in
    many cases, you can choose which you prefer. As always, readability counts, so
    choose wisely and try not to over-engineer the solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying assertions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Where the unittest library requires the usage of `self.assertEqual` to compare
    variables, `py.test` uses some magic to allow for simpler tests using regular
    `assert` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following test file contains both styles of tests, so they can be compared
    easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'So what did we do? Well, we simply replaced `self.assertEqual` with `assert
    ... == ...` and `with self.assertRaises` with `with pytest.raises`. A minor improvement
    indeed, but the actual benefit is seen in the failure output. The first two use
    the `unittest` style and the latter two use the `py.test` style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, in addition to seeing the values that were compared, we can actually
    see the function that was called and which input parameters it received. With
    the static numbers that we have here, it may not be that useful, but it is invaluable
    when using variables, as we'll see in the next paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding tests are all stored in a class. With `py.test`, that's completely
    optional, however. If readability or inheritance makes it useful to encapsulate
    the tests in a class, then feel free to do so, but as far as `py.test` is concerned,
    there is no advantage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard `py.test` behavior works for most test cases, but it may not be
    enough for some custom types. For example, let''s say that we have a `Spam` object
    with a `count` attribute that should be compared with the `count` attribute on
    another object. This part can easily be achieved by implementing the `__eq__`
    method on `Spam`, but it does not improve clarity. Since `count` is the attribute
    that we compare, it would be useful if the tests show `count` when errors are
    displayed. First is the class with two tests, one working and one broken to demonstrate
    the regular output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**test_spam.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the regular `py.test` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The default test output is still usable since the function is fairly straightforward,
    and the value for `count` is visible due to it being available in the constructor.
    However, it would have been more useful if we could explicitly see the value of
    `count`. By adding a `pytest_assertrepr_compare` function to the `conftest.py`
    file, we can modify the behavior of the `assert` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: That's a special file for `py.test` that can be used to override or extend `py.test`.
    Note that this file will automatically be loaded by every test run in that directory,
    so we need to test the types of both the left-hand side and the right-hand side
    of the operator. In this case, it's `a` and `b`.
  prefs: []
  type: TYPE_NORMAL
- en: '**conftest.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function will be used as the output for our test. So when it
    fails, this time we get our own, slightly more useful, output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we could have easily changed the `__repr__` function of `Spam`
    as well, but there are many cases where modifying the `py.test` output can be
    useful. Similar to this, there is specific support for many types, such as sets,
    dictionaries, and texts.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterizing tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we have specified every test separately, but we can simplify tests
    a lot by parameterizing them. Both the square and cube tests were very similar;
    a certain input gave a certain output. This is something that can easily be verified
    using a loop, of course, but using a loop in a test has a pretty big downside.
    It will be executed as a single test. This means that it will fail in its entirety
    if a single test iteration of the loop fails, and that is a problem. Instead of
    having an output for every version, you will get it only once, while they actually
    might be separate bugs. That''s where parameters help. You can simply create a
    list of parameters and the expected data and make it run the test function for
    every parameter separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs the following, as you might have already expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: With the parameterized tests, we can see the parameters clearly, which means
    we can see all inputs and outputs without any extra effort.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the list of tests dynamically at runtime is also possible with a
    global function. Similar to the `pytest_assertrepr_compare` function that we added
    to `conftest.py` earlier, we can add a `pytest_generate_tests` function, which
    generates tests.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the `pytest_generate_tests` function can be useful only to test a subset
    of options depending on the configuration options. If possible, however, I recommend
    trying to configure selective tests using fixtures instead, as they are somewhat
    more explicit. The problem with functions such as `pytest_generate_tests` is that
    they are global and don't discriminate between specific tests, resulting in strange
    behavior if you are not expecting that.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic arguments using fixtures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The fixture system is one of the most magical features of `py.test`. It magically
    executes a fixture function with the same name as your arguments. Because of this,
    the naming of the arguments becomes very important, as they can easily collide
    with other fixtures. To prevent collisions, the scope is set to `function` by
    default. However, `class`, `module`, and `session` are also valid options for
    the scope. There are several fixtures available by default, some of which you
    will use often, and others most likely never. A complete list can always be generated
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The standard fixtures are quite well documented, but a few examples never hurt.
    The next paragraphs demonstrate fixture usage.
  prefs: []
  type: TYPE_NORMAL
- en: Cache
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The cache fixture is as simple as it is useful; there is a `get` function and
    a `set` function, and it remains between sessions. This test, for example, will
    allow five executions and raise an error every time after that. While it is not
    the most useful and elaborate example, it does show how the `cache` function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default value (`0` in this case) is required for the `cache.get` function.
  prefs: []
  type: TYPE_NORMAL
- en: The cache can be cleared through the `--cache-clear` command-line parameter,
    and all caches can be shown through `--cache-show`.
  prefs: []
  type: TYPE_NORMAL
- en: Custom fixtures
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bundled fixtures are quite useful, but within most projects, you will need to
    create your own fixtures to make things easier. Fixtures make it trivial to repeat
    code that is needed more often. You are most likely wondering how this is different
    from a regular function, context wrapper, or something else, but the special thing
    about fixtures is that they themselves can accept fixtures as well. So, if your
    function needs the `pytestconfig` variables, it can ask for it without needing
    to modify the calling functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use cases for fixtures strongly depend on the projects, and because of
    that, it is difficult to generate a universally useful example, but a theoretical
    one is of course an option. The basic premise is simple enough, though: a function
    with the `pytest.fixture` decorator, which returns a value that will be passed
    along as an argument. Also, the function can take parameters and fixtures just
    as any test can. The only notable variation is `pytest.yield_fixture`. This fixture
    variation has one small difference; the actual test will be executed at the `yield`
    (more than one `yield` results in errors) and the code before/after functions
    as setup/teardown code. The most basic example of a `fixture` with `yield_fixture`
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'These fixtures take no parameters and simply pass a parameter to the `py.test`
    functions. A more useful example would be setting up a database connection and
    executing a query in a transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Naturally, instead of using the `:memory:` database in `sqlite3`, we can use
    a different database name (or several) as well.
  prefs: []
  type: TYPE_NORMAL
- en: Print statements and logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Even though print statements are generally not the most optimal way to debug
    code, I admit that it is still my default method of debugging. This means that
    when running and trying tests, I will include many print statements. However,
    let''s see what happens when we try this with `py.test`. Here is the testing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the actual output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: So, all of our print statements and logging got trashed? Well, not really. In
    this case, `py.test` assumed that it wouldn't be relevant to you, so it ignored
    the output. But what about the same test with an error?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: And the output with the error?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Wow! Do you see that? The `stdout`, `stderr`, and logging with a level of `WARNING`
    or higher do get output now. `DEBUG` and `INFO` still won't be visible, but we'll
    see more about that later in this chapter, in the logging section.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most powerful features of `py.test` is the plugin system. Within
    `py.test`, nearly everything can be modified using the available hooks, the result
    of which is that writing plugins is almost simple. Actually, you already wrote
    a few plugins in the previous paragraphs without realizing it. By packaging `conftest.py`
    in a different package or directory, it becomes a `py.test` plugin. We will explain
    more about packaging in [Chapter 15](ch15.html "Chapter 15. Packaging – Creating
    Your Own Libraries or Applications"), *Packaging – Creating Your Own Libraries
    or Applications*. Generally, it won't be required to write your own plugin because
    the odds are that the plugins you seek are already available. A small list of
    plugins can be found on the `py.test` website at [https://pytest.org/latest/plugins.html](https://pytest.org/latest/plugins.html),
    and a longer list can be found through the Python package index at [https://pypi.python.org/pypi?%3Aaction=search&term=pytest-](https://pypi.python.org/pypi?%3Aaction=search&term=pytest-).
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `py.test` does cover quite a bit of the desirable features, so
    you can easily do without plugins, but within the packages that I write myself,
    I generally default to the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pytest-cov`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-pep8`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-flakes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using these plugins, it becomes much easier to maintain the code quality
    of your project. In order to understand why, we will take a closer look at these
    packages in the following paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: pytest-cov
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using the `pytest-cov` package, you can see whether your code is properly covered
    by tests or not. Internally, it uses the `coverage` package to detect how much
    of the code is being tested. To demonstrate the principle, we will check the coverage
    of a `cube_root` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Make sure you have `pytest-cov` installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, let''s create a `.coveragerc` file with some useful defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `cube_root.py` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `test_cube_root.py` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s see what happens when we run this with the `--cov-report=html` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'What happened here? It looks like we forgot to test some part of the code:
    line `14` and the branch that goes from line `11` to line `14`. This output isn''t
    all that readable, and that''s why we specified the HTML output as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![pytest-cov](images/4711_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Perfect! So now we know. We forgot to test for values smaller than `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The yellow line indicates that only one part of the branch was executed (`(n
    >= 0) == True`) and not the other (`(n >= 0) == False`), this occurs with `if`
    statements, loops, and other things where at least one of the branches is not
    covered. For example, if a loop over an empty array is an impossible scenario,
    then the test can be partially skipped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'But since we know the problem, that is, the missing test for `ValueError`,
    let''s add the test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we run the test again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect! 100% coverage without a problem, and the HTML output is also exactly
    what we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![pytest-cov](images/4711_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: But what if the code was slightly different? Instead of raising a `ValueError`
    for values below `0`, what if we just raise a `NotImplementedError`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'And remove the extra test as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'You might wonder why we get 100% test coverage now though we actually didn''t
    cover `NotImplementedError`. This is because we added `raise NotImplementedError`
    to the ignore list in the `.coveragerc` file. This also gives us a different result
    in the HTML output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![pytest-cov](images/4711_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Even if we add the test for `NotImplementedError` in the test file, the coverage
    report will still ignore the line.
  prefs: []
  type: TYPE_NORMAL
- en: pytest-pep8 and pytest-flakes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Pyflakes and pep8 are code quality testing tools that are very useful for making
    your code readable and pep8 compliant. The `pytest-pep8` and `pytest-flakes` modules
    automatically execute these checks before running the actual tests. To install
    them, simply execute this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, you''ll be able to run both of them like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Configuring plugins
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To make sure that all the plugins get executed and to configure them, simply
    add the settings to the `pytest.ini` file. The following example can be a reasonable
    default for development, but for production releases, you will probably want to
    care of the `UnusedImport` warnings.
  prefs: []
  type: TYPE_NORMAL
- en: '**pytest.ini:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When debugging to find out why a test is failing, it can be useful to simply
    look at the first test that fails. The `py.test` module offers both a `-x` flag
    to stop after the first failure and `--maxfail=n` to stop after *n* failures.
  prefs: []
  type: TYPE_NORMAL
- en: Mock objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When writing tests, this regularly occurs: you are testing not only your own
    code but also the interaction with external resources, such as hardware, databases,
    web hosts, servers, and others. Some of these can be run safely, but certain tests
    are too slow, too dangerous, or even impossible to run. In those cases, mock objects
    are your friends; they can be used to fake anything, so you can be certain that
    your code still returns the expected results without having any variation from
    external factors.'
  prefs: []
  type: TYPE_NORMAL
- en: Using unittest.mock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `unittest.mock` library provides two base objects, `Mock` and `MagicMock`,
    to easily mock any external resources. The `Mock` object is just a general generic
    mock object and `MagicMock` is mostly the same, but it has all the magic methods
    such as `__contains__` and `__len__` defined. In addition to this, it can make
    your life even easier. This is because in addition to creating mock objects manually,
    it is possible to patch objects directly using the `patch` decorator/context manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function uses `random` to return `True` or `False` given governed
    by a certain probability distribution. Due to the random nature of a function
    like this, it is notoriously difficult to test, but not with `unittest.mock`.
    With the use of `unittest.mock,` it''s easy to get repeatable results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Wonderful, isn''t it? Without having to modify the original code, we can make
    sure that `random.random` now returns `0.1` instead of some random number. For
    completeness, the version that uses a context manager is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The possibilities with mock objects are nearly endless. They vary from raising
    exceptions on access to faking entire APIs and returning different results on
    multiple calls. For example, let''s fake deleting a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Quite a bit of magic in this example! The `side_effect` parameter tells mock
    to return those values in that sequence, making sure that the first call to `os.path.exists`
    returns `True` and the other two return `False`. The `mock.patch` without arguments
    simply returns a callable that does nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Using py.test monkeypatch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `monkeypatch` object in `py.test` is a fixture that allows mocking as well.
    While it may seem useless after seeing the possibilities with `unittest.mock`,
    in summary, it''s not. Some of the functionality does overlap, but while `unittest.mock`
    focuses on controlling and recording the actions of an object, the `monkeypatch`
    fixture focuses on simple and temporary environmental changes. Some examples of
    these are given in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting and deleting attributes using `monkeypatch.setattr` and `monkeypatch.delattr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting and deleting dictionary items using `monkeypatch.setitem` and `monkeypatch.delitem`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting and deleting environment variables using `monkeypatch.setenv` and `monkeypatch.delenv`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting an extra path to `sys.path` before all others using `monkeypatch.syspath_prepend`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the directory using `monkeypatch.chdir`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To undo all modifications, simply use `monkeypatch.undo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say that for a certain test, we need to work from a different
    directory. With mock, your options would be to mock pretty much all file functions,
    including the `os.path` functions, and even in that case, you will probably forget
    about a few. So, it''s definitely not useful in this case. Another option would
    be to put the entire test into a `try…finally` block and just do an `os.chdir`
    before and after the testing code. This is quite a good and safe solution, but
    it''s a bit of extra work, so let''s compare the two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: They effectively do the same, but one needs four lines of code whereas the other
    needs eight. All of these can easily be worked around with a few extra lines of
    code, of course, but the simpler the code is, the fewer mistakes you can make
    and the more readable it is.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python logging module is one of those modules that are extremely useful,
    but it tends to be very difficult to use correctly. The result is often that people
    just disable logging completely and use print statements instead. This is insightful
    but a waste of the very extensive logging system in Python. If you've written
    Java code before, you might be familiar with the Log4j Java library. The Python
    logging module is largely and primarily based on that library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important objects of the logging module are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logger**: the actual logging interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handler**: This processes the log statements and outputs them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Formatter**: This formats the input data into a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filter**: This allows filtering of certain messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Within these objects, you can set the logging levels to one of the default
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CRITICAL: 50`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ERROR: 40`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WARNING: 30`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INFO: 20`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEBUG: 10`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NOTSET: 0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The numbers are the numeric values of these log levels. While you can generally
    ignore them, the order is obviously important while setting the minimum level.
    Also, when defining custom levels, you will have to overwrite existing levels
    if they have the same numeric value.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several ways to configure the logging system, ranging from pure code
    to JSON files or even remote configuration. The examples will use parts of the
    logging module later discussed in this chapter, but the usage of the config system
    is all that matters here. If you are not interested in the internal workings of
    the logging module, you should be able to get by with just this paragraph of the
    logging section.
  prefs: []
  type: TYPE_NORMAL
- en: Basic logging configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most basic logging configuration is, of course, no configuration, but that
    will not get you much useful output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'With the default log level, you will only see a warning and up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick and easy start for a configuration is `basicConfig`. I recommend using
    this if you just need some quick logging for a script you''re writing, but not
    for a full-blown application. While you can configure pretty much anything you
    wish, once you get a more complicated setup, there are usually more convenient
    options. We will talk more about that in later paragraphs, but first, we have
    a `basicConfig` that configures our logger to display some more information, including
    the logger name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We test the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the following output on our screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the output in the `debug.log` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This configuration shows how log outputs can be configured with separate configurations,
    log levels, and, if you choose so, formatting. It tends to become unreadable though,
    which is why it's usually a better idea to use `basicConfig` only for simple configurations
    that don't involve multiple handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `dictconfig` makes it possible to name all parts so that they can be reused
    easily, for example, a single formatter for multiple loggers and handlers. So
    let''s rewrite our previous configuration using `dictconfig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The nice thing about the dictionary configuration is that it's very easy to
    extend and/or overwrite the logging configuration. For example, if you want to
    change the formatter for all of your logging, you can simply change the `standard`
    formatter or even loop through `handlers`.
  prefs: []
  type: TYPE_NORMAL
- en: JSON configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since `dictconfig` takes any type of dictionary, it is actually quite simple
    to implement a different type of reader employing JSON or YAML files. This is
    especially useful as they tend to be a bit friendlier towards non-Python programmers.
    As opposed to Python files, they are easily readable and writable from outside
    of Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we have a `log_config.json` file such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We can simply use this code to read the config:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Ini file configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The file configuration is probably the most readable format for non-programmers.
    It uses the `ini-style` configuration format and uses the `configparser` module
    internally. The downside is that it is perhaps a little verbose, but it is clear
    enough and makes it easy to combine several configuration files without us having
    to worry too much about overwriting other configurations. Having said that, if
    `dictConfig` is an option, then it is most likely a better option. This is because
    `fileConfig` is slightly limited and awkward at times. Just look at the handlers
    as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading the files is extremely easy though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: One thing to make note of, however, is that if you look carefully, you will
    see that this config is slightly different from the other configs. With `fileConfig`
    you can't just use keyword arguments alone. The `args` is required for both `FileHandler`
    and `StreamHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: The network configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The network configuration is both very convenient and a bit dangerous, because
    it allows you to configure your logger on the fly while your application/script
    is still running. The dangerous part is that the config is (partially) read by
    using the `eval` function, which allows people to potentially execute code within
    your application remotely. Even though `logging.config.listen` only listens to
    local connections, it can still be dangerous if you execute the code on a shared/unsafe
    host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, since version Python 3.4, it is possible to add a `verify` parameter,
    which is a function that will be executed to convert the input into the output.
    The default is obviously something along the lines of `lambda config: config,`
    but it can be configured to return just about anything.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To prove this point through an example, we need two scripts. One script will
    continuously print a few messages to the loggers and the other will change the
    logging configuration. We will start with the same test code that we had before
    but keep it running in an endless loop with a `sleep` in between:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now comes the code that will send the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s see the output. After the first execution of the loop, we will
    execute the second script to read the logging configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be wondering where the rest of the output is. There is none. The
    `debug.log` file has been filled with messages like these, however:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'So what happened? This is where we see the pitfalls of custom loggers and configuration
    after using the loggers. The `logging.config.listen` function will modify the
    root logger as requested, but since the other loggers (`some` and `some.other`)
    weren''t specified, they weren''t modified. We modify the configuration to include
    them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: You will probably notice that we didn't add any handlers to the `some` logger.
    That's because the handler is already present—at the root level. However, without
    manually telling the logging module that the logger is there, it won't send it
    to the handler anymore. This is not problematic generally, but it's a dangerous
    pitfall when modifying logging configurations at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative way to configure it without having this propagation issue is
    by disabling propagation altogether, but that will create an entirely new logger
    and will forget any configuration added to the root. So, if you have a handler
    for the error level at the root that gets sent to your error reporting system,
    it won''t arrive anymore. In this case, however, the config is slightly clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Logger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main object that you will be using all the time with the `logging` module
    is the `Logger` object. This object contains all the APIs that you will need to
    do the actual logging. Most are simple enough but some require attention.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, loggers inherit the parent settings by default. As we have seen
    previously with the propagate setting, by default, all settings will propagate
    from the parent. This is really useful when incorporating loggers within your
    files. Assuming your modules are using sane names and import paths, I recommend
    the following style of naming your loggers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'By using this style, your loggers will get names such as `main_module.sub_module.ClassName`.
    Not only does this make your logs easier to read, but also it is easily possible
    to enable or disable logging per module with the propagation of log settings.
    To create a new log file that logs everything from `main_module.sub_module`, we
    can simply do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can configure it using your chosen configuration option,
    of course. The relevant point is that with sub-loggers, you have very fine-grained
    control over your loggers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This includes increasing the log level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The usage of the `Logger` object is mostly identical to that of the bare `logging`
    module, but `Logger` actually supports a bit more. This is because the bare `logging`
    module just calls the functions on the root logger. It has a few very useful properties,
    although most of these are undocumented in the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Propagate`: Whether to pass events to this logger or to the handlers of the
    parent loggers. Without this, a log message to `main_module.sub_module` won''t
    be logged by `main_module`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `handle` method will keep looking for parent handlers as long as those loggers
    have `propagate` set to `true`, which is the default.
  prefs: []
  type: TYPE_NORMAL
- en: '`Filters`: These are the filters attached to the logger. They can be added
    through `addFilter` and `removeFilter`, To see whether a message will be filtered,
    the `filter` method can be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Disabled`: By setting this property, it''s possible to disable a certain logger.
    The regular API only allows disabling of all loggers below a certain level. This
    offers some fine-grained control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Handlers`: These are the handlers attached to the logger. They can be added
    through `addHandler` and `removeHandler`. The existence of any (inherited) handlers
    can be checked through the `hasHandlers` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Level`: This is really an internal one as it simply has a numeric value and
    not a name. But beyond that, it doesn''t take inheritance into account, so it''s
    better to avoid the property and use the `getEffectiveLevel` function instead.
    To check whether the setting is enabled for a `DEBUG` for example, you can simply
    do `logger.isEnabledFor(logging.DEBUG)`. Setting the property is possible through
    the `setLevel` function, of course.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Name`: As this property''s name says, it is very useful for your own reference,
    of course.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that you know about the properties, it is time to discuss the logging functions
    themselves. The functions you will use most often are the `log`, `debug`, `info`,
    `warning`, `error`, and `critical` log functions. They can be used quite simply,
    but they support string formatting as well, which is very useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: You might wonder why we don't simply use the regular string formatting with
    `%` or `string.format` instead. The reason is that when parameters are used instead
    of preformatted strings, the handler gets them as parameters. The result is that
    you can group log messages by the original string, which is what tools such as
    sentry ([https://github.com/getsentry/sentry](https://github.com/getsentry/sentry))
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is more to it, however. In terms of parameters, `*args` are only for
    string formatting, but it''s possible to add extra parameters to a log object
    using the `extra` keyword parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'These `extra` parameters can be used in the logging formatter to display extra
    information just like the standard formatting options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'However, one of the most useful features is the support for exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in a stack trace for the exception, but it will not kill the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter showed us how to write `doctests`, make use of the shortcuts provided
    by `py.test`, and use the `logging` module. With testing, there is never a one-size-fits-all
    solution. While the `doctest` system is very useful in many cases for providing
    both documentation and tests at the same time, in many functions, there are edge
    cases that simply don't matter for documentation, but still need to be tested.
    This is where regular unit tests come in and where `py.test` helps a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Because the `py.test` library is always evolving, this chapter cannot fully
    cover everything you will need, but it should provide you with enough of a basis
    to be able to use it effectively and extend it where needed.
  prefs: []
  type: TYPE_NORMAL
- en: The logging module is extremely useful but it's also a pain if configured incorrectly.
    Unfortunately, the right configuration can be a bit obscure when multiple modules
    are trying to configure logging simultaneously. The usage of the logging system
    should be clear enough for most of the common use cases now, and as long as you
    keep the `propagate` parameter in check, you should be fine when implementing
    a logging system.
  prefs: []
  type: TYPE_NORMAL
- en: Next up is debugging, where testing helps prevent bugs. We will see how to solve
    them effectively. In addition, the logging that we added in this chapter will
    help a lot in that area.
  prefs: []
  type: TYPE_NORMAL
