- en: Chapter 8. Metaclasses – Making Classes (Not Instances) Smarter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapters have already shown us how to modify classes and functions
    using decorators. But that's not the only option to modify or extend a class.
    An even more advanced technique of modifying your classes before creation is the
    usage of **metaclasses**. The name already gives a hint to what it could be; a
    metaclass is a class containing meta information about a class.
  prefs: []
  type: TYPE_NORMAL
- en: The basic premise of a metaclass is a class that generates another class for
    you at definition time, so generally you wouldn't use it to change the class instances
    but only the class definitions. By changing the class definitions, it is possible
    to automatically add some properties to a class, validate whether certain properties
    are set, change inheritance, automatically register the class at a manager, and
    do many other things.
  prefs: []
  type: TYPE_NORMAL
- en: Although metaclasses are generally considered to be a more powerful technique
    than (class) decorators, effectively they don't differ too much in possibilities.
    The choice usually comes down to either convenience or personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic dynamic class creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metaclasses with arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internals of class creation, the order of operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract base classes, examples and inner workings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic plugin system using metaclasses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing definition order of class attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically creating classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metaclasses are the factories that create new classes in Python. In fact, even
    though you may not be aware of it, Python will always execute the `type` metaclass
    whenever you create a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating classes in a procedural way, the `type` metaclass is used as
    a function. This function takes three arguments: `name`, `bases`, and `dict`.
    The name will become the `__name__` attribute, the `bases` is the list of inherited
    base classes and will be stored in `__bases__` and `dict` is the namespace dictionary
    that contains all variables and will be stored in `__dict__`.'
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that the `type()` function has another use as well. Given
    the arguments documented earlier, it creates a class given those specifications.
    Given a single argument with the instance of a class, it will return the class
    as well but from the instance. Your next question might be, "What happens if I
    call `type()` on a class definition instead of a class instance?" Well, that returns
    the metaclass for the class which is `type` by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s clarify this using a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding two definitions of `Spam` are completely identical; they both
    create a class with an instantiated property of `eggs` and `object` as a base.
    Let''s test if this actually works as you would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the results for the two are the same. When creating a class, Python
    silently adds the `type` metaclass and `custom` metaclasses are simply classes
    that inherit `type`. A simple class definition has a silent metaclass making a
    simple definition such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Essentially identical to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This raises the question that if every class is created by a (silent) metaclass,
    what is the metaclass of `type`? This is actually a recursive definition; the
    metaclass of `type` is `type`. This is the essence of what a custom metaclass
    is: a class that inherits type to allow class modification without needing to
    modify the class definition itself.'
  prefs: []
  type: TYPE_NORMAL
- en: A basic metaclass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since metaclasses can modify any class attribute, you can do absolutely anything
    you wish. Before we continue with more advanced metaclasses, let''s look at a
    basic example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, everything about the class definition can easily be modified
    using metaclasses. This makes it both a very powerful and a very dangerous tool,
    as you can easily cause very unexpected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Arguments to metaclasses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The possibility of adding arguments to a metaclass is a little-known feature,
    but very useful nonetheless. In many cases, simply adding attributes or methods
    to a class definition is enough to detect what to do, but there are cases where
    it is useful to be more specific.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This simplistic example may not be useful but the possibilities are. The only
    thing you need to keep in mind is that both the `__new__` and `__init__` methods
    need to be extended for this to work.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing metaclass attributes through classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using metaclasses, it might be confusing to note that the class actually
    does more than simply construct the class, it actually inherits the class during
    the creation. To illustrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen in the preceding example, these methods are only available for
    the `class` objects and not the instances. The `spam` attribute and the `eggs`
    method are not accessible through the instance while they are accessible through
    the class. I personally don't see any useful cases for this behavior but it is
    definitely noteworthy.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes using collections.abc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The abstract base classes module is one of the most useful and most used examples
    of metaclasses in Python, as it makes it easy to ensure that a class adheres to
    a certain interface without a lot of manual checks. We have already seen some
    examples of abstract base classes in the previous chapters, but now we will look
    at the inner workings of these and the more advanced features, such as custom
    ABCs.
  prefs: []
  type: TYPE_NORMAL
- en: Internal workings of the abstract classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s demonstrate the usage of the regular abstract base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the abstract base class blocks us from instantiating the classes
    until all the abstract methods have been inherited. In addition to the regular
    methods, `property`, `staticmethod`, and `classmethod` are also supported.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So what does Python do internally? You could, of course, read the `abc.py` source
    code but I think a simple explanation would be better.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, `abc.abstractmethod` sets the `__isabstractmethod__` property on the
    function to `True`. So if you don''t want to use the decorator, you can simply
    emulate the behavior by doing something along the lines of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After that, the `abc.ABCMeta` metaclass walks through all the items in a namespace
    and looks for objects where the `__isabstractmethod__` attribute evaluates to
    `True`. In addition to that, it walks through all bases and checks the `__abstractmethods__`
    set for every base class, in case the class inherits an `abstract` class. All
    the items where `__isabstractmethod__` still evaluates to `True` get added to
    the `__abstractmethods__` set which is stored in the class as `frozenset`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we don't use `abc.abstractproperty`, `abc.abstractclassmethod`, and
    `abc.abstractstaticmethod`. Since Python 3.3 these have been deprecated as the
    `classmethod`, `staticmethod`, and `property` decorators are recognized by `abc.abstractmethod`
    so a simple `property` decorator followed by a `abc.abstractmethod` is recognized
    as well. Take care when ordering the decorators; `abc.abstractmethod` needs to
    be the innermost decorator for this to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next question now is about where the actual checks come in; the checks
    to see if the classes are completely implemented. This actually functions through
    a few Python internals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily emulate the same behavior with a `metaclass` ourselves, but it
    should be noted that `abc.ABCMeta` actually does more, which we will demonstrate
    in the next section. To mimic the behavior of the built-in abstract base class
    support, take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The actual implementation is a bit more complicated as it still needs to take
    care of the old style classes and the `property`, `classmethod`, and `staticmethod`
    types of methods. Additionally, it features caching, but this code covers the
    most useful part of the implementation. One of the most important tricks to note
    here is that the actual check is executed by decorating the `__new__` function
    of the actual class. This method is only executed once within a class so we can
    avoid the overhead of these checks for multiple instantiations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The actual implementation of the abstract methods can be found by looking for
    `__isabstractmethod__` in the Python source code in the following files: `Objects/descrobject.c`,
    `Objects/funcobject.c`, and `Objects/object.c`. The Python part of the implementation
    can be found in `Lib/abc.py`.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom type checks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Defining your own interfaces using abstract base classes is great, of course.
    But it can also be very convenient to tell Python what your class actually resembles
    and what kind of types are similar. For that, `abc.ABCMeta` offers a register
    function which allows you to specify which types are similar. For example, a custom
    list that sees the list type as similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As demonstrated with the last four lines, this is a one-way relationship. The
    other way around would generally be easy enough to realize through inheriting
    list, but that won't work in this case. `abc.ABCMeta` refuses to create inheritance
    cycles.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To be able to handle cases like these, there is another useful feature in `abc.ABCMeta`.
    When subclassing `abc.ABCMeta`, the `__subclasshook__` method can be extended
    to customize the behavior of `issubclass` and with that, `isinstance`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `__subclasshook__` should return `True`, `False`, or `NotImplemented`, which
    would result in `issubclass` returning `True`, `False`, or the usual behavior
    when `NotImplemented` is raised.
  prefs: []
  type: TYPE_NORMAL
- en: Using abc.ABC before Python 3.4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `abc.ABC` class we have used in this paragraph is only available in Python
    versions 3.4 and higher, but it''s trivial to implement it in older versions.
    It''s little more than syntactic sugar for `metaclass=abc.ABCMeta`. To implement
    it yourself, you can simply use the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Automatically registering a plugin system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most common uses of metaclasses is to have classes automatically
    register themselves as plugins/handlers. Examples of these can be seen in many
    projects, such as web frameworks. Those codebases are too extensive to usefully
    explain here though. Hence, we''ll show a simpler example showing the power of
    metaclasses as a self-registering `plugin` system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This example is a tad simplistic of course, but it's the basis for many plugin
    systems. Which is a very important thing to note while implementing systems like
    these; however, while metaclasses run at definition time, the module still needs
    to be imported to work. There are several options to do this; loading on-demand
    through the `get` method has my vote as that also doesn't add load time if the
    plugin is not used.
  prefs: []
  type: TYPE_NORMAL
- en: The following examples will use the following file structure to get reproducible
    results. All files will be contained in a plugins directory.
  prefs: []
  type: TYPE_NORMAL
- en: The `__init__.py` file is used to create shortcuts, so a simple import plugins
    will result in having `plugins.Plugins` available, instead of requiring importing
    `plugins.base` explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `base.py` file containing the `Plugins` collection and the `Plugin` base
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And two simple plugins, `spam.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And `eggs.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Importing plugins on-demand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first of the solutions for the import problem is simply taking care of it
    in the `get` method of the `Plugins` metaclass. Whenever the plugin is not found
    in the registry, it should automatically load the module from the `plugins` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of this approach are that not only the plugins don't explicitly
    need to be preloaded but also that the plugins are only loaded when the need is
    there. Unused plugins are not touched, so this method can help in reducing your
    applications' load times.
  prefs: []
  type: TYPE_NORMAL
- en: The downside is that the code will not be run or tested, so it might be completely
    broken and you won't know about it until it is finally loaded. Solutions for this
    problem will be covered in the testing chapter, [Chapter 10](ch10.html "Chapter 10. Testing
    and Logging – Preparing for Bugs"), *Testing and Logging – Preparing for Bugs*.
    The other problem is that if the code self-registers itself into other parts of
    an application then that code won't be executed either.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modifying the `Plugins.get` method, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following when executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this approach only results in running `import` once. The second
    time, the plugin will be available in the plugins dictionary so no loading will
    be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Importing plugins through configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While only loading the needed plugins is generally a better idea, there is something
    to be said to preload the plugins you will likely need. As explicit is better
    than implicit, an explicit list of plugins to load is generally a good solution.
    The added advantages of this method are that firstly you are able to make the
    registration a bit more advanced as you are guaranteed that it is run and secondly
    you can load plugins from multiple packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of importing in the `get` method, we will add a `load` method this
    time; a `load` method that imports all the given module names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Which can be called using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A fairly simple and straightforward system to load the plugins based on settings,
    this can easily be combined with any type of settings system to fill the `load`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Importing plugins through the file system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever possible, it is best to avoid having systems depend on automatic detection
    of modules on a filesystem as it goes directly against `PEP8`. Specifically, "explicit
    is better than implicit". While these systems can work fine in specific cases,
    they often make debugging much more difficult. Similar automatic import systems
    in Django have caused me a fair share of headaches as they tend to obfuscate the
    errors. Having said that, automatic plugin loading based on all the files in a
    plugins directory is still a possibility warranting a demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If possible, I would try to avoid using a fully automatic import system as it's
    very prone to accidental errors and can make debugging more difficult, not to
    mention that the import order cannot easily be controlled this way. To make this
    system a bit smarter (even importing packages outside of your Python path), you
    can create a plugin loader using the abstract base classes in `importlib.abc`.
    Note that you will most likely still need to list the directories through `os.listdir`
    or `os.walk` though.
  prefs: []
  type: TYPE_NORMAL
- en: Order of operations when instantiating classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The order of operations during class instantiation is very important to keep
    in mind when debugging issues with dynamically created and/or modified classes.
    The instantiation of a class happens in the following order.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the metaclass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The metaclass comes from either the explicitly given metaclass on the class
    or `bases`, or by using the default `type` metaclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'For every class, the class itself and the bases, the first matching of the
    following will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly given metaclass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit metaclass from bases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if no metaclass is found that is a subtype of all the candidate metaclasses,
    a `TypeError` will be raised. This scenario is not that likely to occur but certainly
    a possibility when using multiple inheritance/mixins with metaclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The class namespace is prepared through the metaclass selected previously. If
    the metaclass has a `__prepare__` method, it will be called `namespace = metaclass`.`__prepare__(names,
    bases, **kwargs)`, where `**kwargs` originates from the class definition. If no
    `__prepare__` method is available, the result will be `namespace = dict()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are multiple ways of achieving custom namespaces, as we saw
    in the previous paragraph, the `type()` function call also takes a `dict` argument
    which can be used to alter the namespace as well.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the class body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The body of the class is executed very similarly to normal code execution with
    one key difference, the separate namespace. Since a class has a separate namespace,
    which shouldn''t pollute the `globals()/locals()` namespaces, it is executed within
    that context. The resulting call looks something like this: `exec(body, globals(),
    namespace)` where `namespace` is the previously produced namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the class object (not instance)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have all the components ready, the actual class object can be produced.
    This is done through the `class_ = metaclass(name, bases, namespace, **kwargs)`
    call. This is, as you can see, actually identical to the `type()` call previously
    discussed. `**kwargs` here are the same as the ones passed to the `__prepare__`
    method earlier.
  prefs: []
  type: TYPE_NORMAL
- en: It might be useful to note that this is also the object that will be referenced
    from the `super()` call without arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the class decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the class object is actually done already, the class decorators will
    be executed. Since this is only executed after everything else in the class object
    has already been constructed, it becomes difficult to modify class attributes,
    such as which classes are being inherited, and the name of the class. By modifying
    the `__class__` object you can still modify or overwrite these, but it is, at
    the very least, more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the class instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the class object produced previously, we can now finally create the actual
    instances as you normally would with a class. It should be noted that this step
    and the class decorators steps, unlike the earlier steps, are the only ones that
    are executed every time you instantiate a class. The steps before these two are
    only executed once per class definition.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enough theory! Let''s illustrate the creation and instantiation of the class
    objects so we can check the order of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The example clearly shows the creation order of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the namespace through `__prepare__`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the class body using `__new__`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initializing the metaclass using `__init__` (note that this is not the class
    `__init__`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initializing the class through the class decorator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initializing the class through the class `__init__` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One thing we can note from this is that the class decorators are executed each
    and every time the class is actually instantiated and not before that. This can
    be both an advantage and a disadvantage of course, but if you wish to build a
    register of all subclasses, it is definitely more convenient to use a metaclass
    since the decorator will not register until you instantiate the class.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, having the power to modify the namespace before actually
    creating the class object (not the instance) can be very powerful as well. It
    can be convenient for sharing a certain scope between several class objects for
    example, or for easily ensuring that certain items are always available in the
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: Storing class attributes in definition order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are cases where the definition order makes a difference. For example,
    let's assume we are creating a class that represents a CSV (Comma Separated Values)
    format. The CSV format expects the fields to have a particular order. In some
    cases this will be indicated by a header but it's still useful to have a consistent
    field order. Similar systems are using in ORM systems such as SQLAlchemy to store
    the column order for table definitions and for the input field order within forms
    in Django.
  prefs: []
  type: TYPE_NORMAL
- en: The classic solution without metaclasses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An easy way to store the order of the fields is by giving the field instances
    a special `__init__` method which increments for every definition, so the fields
    have an incrementing index property. This solution can be considered the classic
    solution as it also works in Python 2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For convenience, and to make things prettier, we have added the `FieldsMeta`
    class. It is not strictly required here, but it automatically takes care of filling
    in the name if needed, and adds the `fields` list which contains a sorted list
    of fields.
  prefs: []
  type: TYPE_NORMAL
- en: Using metaclasses to get a sorted namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous solution is a bit more straightforward and supports Python 2 as
    well, but with Python 3 we have more options. As you have seen in the previous
    paragraphs, since Python 3 we have the `__prepare__` method, which returns the
    namespace. From the previous chapters you might also remember `collections.OrderedDict`,
    so let's see what happens when we combine them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the fields are indeed in the order we defined them. `Spam` first
    and `eggs` after that. Since the class namespace is now a `collections.OrderedDict`
    instance, we know that the order is guaranteed. Instead of the regular not predetermined
    order of the Python `dict`. This demonstrates how convenient metaclasses can be
    to extend your classes in a generic way. Another big advantage of metaclasses,
    instead of a custom `__init__` method, is that the users won't lose the functionality
    if they forget to call the parent `__init__` method. The metaclass will always
    be executed, unless a different metaclass is added, that is.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python metaclass system is something every Python programmer uses all the
    time, perhaps without even knowing about it. Every class should be created through
    some (subclass of) `type`, which allows for endless customization and magic. Instead
    of statically defining your class, you can now have it created as you normally
    would and dynamically add, modify, or remove attributes from your class during
    definition; very magical but very useful. The magic component, however, is also
    the reason it should be used with a lot of caution. While metaclasses can be used
    to make your life much easier, they are also amongst the easiest ways of producing
    completely incomprehensible code.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless, there are some great use-cases for metaclasses and many libraries
    such as `SQLAlchemy` and `Django` use metaclasses to make your code work much
    easier and arguably better. Actually comprehending the magic that is used inside
    is generally not needed for the usage of these libraries, which makes the cases
    defendable. The question becomes whether a much better experience for beginners
    is worth some dark magic internally, and looking at the success of these libraries,
    I would say yes in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'To conclude, when thinking about using metaclasses, keep in mind what Tim Peters
    once said: "Metaclasses are deeper magic than 99% of users should ever worry about.
    If you wonder whether you need them, you don''t."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will continue with a solution to remove some of the magic that metaclasses
    generate: documentation. The next chapter will show us how your code can be documented,
    how that documentation can be tested, and most importantly, how the documentation
    can be made smarter by annotating types in your documentation.'
  prefs: []
  type: TYPE_NORMAL
