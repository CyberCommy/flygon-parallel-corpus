- en: Chapter 8. Testing and Deploying Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will delve further into the concept of sharing modules.
    Before you can share a module or package, you need to test it to ensure that it
    is working properly. You also need to prepare your code and know how to deploy
    it. To learn these things, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: See how unit tests can be used to ensure that your module or package is working
    properly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to prepare a module or package for publication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find out how GitHub can be used to share your code with others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine the steps involved in submitting your code to the Python Package Index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover how to use pip to install and use packages written by other people
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing modules and packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testing is a normal part of programming: you test your code to verify that
    it works and identify any bugs or other problems, which you can then fix. Then,
    you test some more, until you are happy that your code is working correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All too often, however, programmers just do **ad hoc testing**: they fire up
    the Python interactive interpreter, import their module or package, and make various
    calls to see what happens. In the previous chapter, we looked at a form of ad
    hoc testing using the `importlib.reload()` function to support RAD development
    of your code.'
  prefs: []
  type: TYPE_NORMAL
- en: Ad hoc testing is useful, but it isn't the only form of testing. If you are
    sharing your modules and packages with others, you will want your code to be bug-free,
    and ad-hoc testing can't guarantee this. A much better and more systematic approach
    is to create a series of **unit tests** for your module or package. Unit tests
    are snippets of Python code which test various aspects of your code. Because the
    testing is done by a Python program, you can simply run the program whenever you
    want to test your code, and you can be sure that everything is being tested each
    time you run the test. Unit tests are a great way of making sure bugs don't creep
    into your code as you make changes, and you can run them whenever you want to
    share your code to make sure it's working as you expect.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unit tests aren't the only sort of programmatic testing you can do. **Integration
    tests** combine various modules and systems to make sure they work together correctly,
    and **GUI tests** are used to ensure that a program's user interface is working
    as it should.Unit tests are, however, the most useful for testing modules and
    packages, and this is the type of testing we will focus on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a very simple example of a unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `assert` statement checks the expression that follows it. If this expression
    does not evaluate to `True`, then an `AssertionError` will be raised. This makes
    it easy for you to check that a given function is returning the results you expect;
    in this example, we are checking that the `math.floor()` function is correctly
    returning the largest integer less than or equal to the given floating-point number.
  prefs: []
  type: TYPE_NORMAL
- en: Because a module or package is ultimately just a collection of Python functions
    (or methods, which are just functions grouped into classes), it is quite possible
    to write a series of `assert` statements that call your functions and check that
    the returned values are what you would expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, this is a simplification: often the results of calling one function
    will affect the output of another function, and your functions can sometimes perform
    quite complex actions such as communicating with a remote API or storing data
    into a file on disk. In many cases, though, you can still use a series of `assert`
    statements to verify that your modules and packages are working the way you would
    expect.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing with the unittest Standard Library module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While you could put your `assert` statements into a Python script and run them,
    a better approach is to use the `unittest` module from the Python Standard Library.
    This module allows you to group your unit tests into **test cases**, run additional
    code before and after the tests are run, and access a whole raft of different
    types of `assert` statements to make your testing easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can use the `unittest` module to implement a series of unit
    tests for the `quantities` package we implemented in [Chapter 6](ch06.html "Chapter 6. Creating
    Reusable Modules"), *Creating Reusable Modules*. Place a copy of this package
    into a convenient directory and create a new Python source file named `test_quantities.py`
    in the same directory. Then, add the following code to this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that you don't need to type this program in by hand. All of these source
    files, including a complete copy of the `quantities` package, are available as
    part of the sample code which can be downloaded for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a closer look at what this code does. First off, the `TestQuantities`
    class is used to hold a number of related unit tests. You would normally define
    a separate `unittest.TestCase` subclass for each of the major groups of unit tests
    that you need to perform. Within our `TestQuantities` class, we define a `setUp()`
    method which contains code that needs to be executed before our tests are run.
    If we wanted to, we could also define a `tearDown()` method that would be executed
    after the tests have been completed.
  prefs: []
  type: TYPE_NORMAL
- en: We then define two unit tests, which we have called `test_new()` and `test_convert()`.
    These test the `quantities.new()` and `quantities.convert()` functions, respectively.
    You would typically have a separate unit test for each piece of functionality
    that you need to test. You can call your unit tests anything you like, so long
    as the method name starts with `test`.
  prefs: []
  type: TYPE_NORMAL
- en: Within our `test_new()` unit test, we create a new quantity and then call the
    `self.assertEqual()` method to ensure that the expected quantity was created.
    As you can see, we're not just limited to using the built-in `assert` statement;
    there are dozens of different `assertXXX()` methods that you can call to test
    your code in various ways. All of these will raise an `AssertionError` if the
    assertion fails.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of our testing script calls `unittest.main()` when the script
    is executed. This function looks for any `unittest.TestCase` sub-classes that
    you have defined and runs each test case in turn. For each test case, the `setUp()`
    method is called if it exists, followed by the various `testXXX()` methods that
    you have defined, and finally, the `teardown()` method is called if it exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try running our unit test. Open up a terminal or command-line window,
    use the `cd` command to set the current directory to the directory holding your
    `test_quantities.py` script, and try typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'All going well, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the `unittest` module doesn''t show you much about the tests that
    have been run, other than that it ran your unit tests without any problems. If
    you want more detail, you can increase the **verbosity** of your tests, for example
    by adding a parameter to the `unittest.main()` statement in your test script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the `-v` command-line option to achieve the same
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Designing your unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The aim of unit testing is to check that your code is working. A good rule of
    thumb is to have a separate test case for each publicly accessible module within
    your package and a separate unit test for each feature provided by that module.
    The unit test code should aim to test at least the usual operation of the feature
    to make sure it works. If you wish, you can also choose to write additional testing
    code within your unit tests, or even additional unit tests, to check for particular
    **edge cases** in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a concrete example, in the `test_convert()` method we wrote in the previous
    section, you might want to add code to check that a suitable exception is raised
    if the user tries to convert a distance into a weight. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The question is: how many edge cases should you test for? There are potentially
    hundreds of different ways in which someone can use your module incorrectly. Should
    you write unit tests for each of these?'
  prefs: []
  type: TYPE_NORMAL
- en: In general, no. It isn't worth your while trying to test every possible edge
    case. Certainly, you may wish to test a few of the main possibilities, just to
    make sure your module is able to handle the most obvious errors, but beyond this,
    writing additional tests probably isn't worth the effort.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Coverage** is a measure of how much of your code is being tested by your
    unit tests. To understand how this works, consider the following Python function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have added line numbers to the start of each line to help us calculate the
    code coverage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, imagine that we create the following unit test code for our `calc_score()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How much of the `calc_score()` function has our unit test covered? Our first
    `assert` statement is calling `calc_score()` with `x` `as` `1` and `y` `as` `5`.
    If you follow the line numbers, you'll see that calling this function with this
    set of parameters will cause lines 1, 2, 3, and 9 to be executed. Similarly, the
    second `assert` statement calls `calc_score()` with `x` `as` `2` and `y` `as`
    `10`, causing lines 1, 4, 5, and 9 to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: In total, these two assert statements caused lines 1, 2, 3, 4, 5, and 9 to be
    executed. Ignoring the blank line, our test did not include lines 6 and 7\. Thus,
    our unit test has covered six of the eight lines in our function, giving us a
    code coverage value of 6/8 = 75%.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are looking at **statement coverage** here. There are other, more complicated,
    ways of measuring code coverage which we won't get into here.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, you won't calculate code coverage by hand. There are some excellent
    tools that will calculate code coverage for your Python testing code. Take a look,
    for example, at the `coverage` package ([https://pypi.python.org/pypi/coverage](https://pypi.python.org/pypi/coverage)).
  prefs: []
  type: TYPE_NORMAL
- en: The basic concept of code coverage is that you want your tests to cover *all*
    your code. Whether or not you use a tool such as `coverage` to measure code coverage,
    it's a good idea to write your unit tests to include as close to 100% of your
    code as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we are looking at the idea of testing Python code, it is worth mentioning
    the concept of **test-driven development**. Using test-driven development, you
    first choose what you want your module or package to do, and then you write unit
    tests to ensure that the module or package works the way you want it to—*before
    you write it*. In this way, the unit tests act as a kind of specification for
    the module or package; they tell you what your code should do, and your task is
    then to write the code so that it passes all the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven development can be a useful way of implementing your modules and
    packages. Whether or not you use it, of course, is up to you—but if you have the
    discipline to write the unit tests first, test-driven development can be a great
    way of making sure you've implemented your code correctly, and your modules continue
    to do what you expect them to as your code grows and changes over time.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your module or package calls an external API or performs some other complex,
    expensive, or time-consuming operation, you may want to investigate the `unittest.mock`
    package in the Python Standard Library. **Mocking** is the process of replacing
    some functionality in your program with a dummy function that immediately returns
    suitable data for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking is a complicated process, and it can take some doing to get it right,
    but the technique is absolutely worthwhile if you want to run unit tests over
    code that would otherwise be too slow, cost money each time you ran it, or depends
    on external systems to operate.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests for your modules and packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have been introduced to the concept of unit testing, taken a look
    at how the `unittest` standard library module works, and looked at some of the
    more complicated but important aspects of writing unit tests, let's now see how
    unit tests can be used to assist with the development and testing of your modules
    and packages.
  prefs: []
  type: TYPE_NORMAL
- en: First off, you should aim to write unit tests for at least the main functions
    defined by your module or package. Start by testing the most important functions,
    and add tests for the more obvious error conditions to make sure errors are being
    handled correctly. You can always add extra tests for the more obscure parts of
    your code later.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are writing unit tests for a single module, you should place your test
    code in a separate Python script, named, for example, `tests.py`, and place this
    in the same directory as your module. The following image shows a good way of
    organizing your code when writing a single module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing unit tests for your modules and packages](graphics/B05012_8_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you have multiple modules in the same directory, you can either combine the
    unit tests for all the modules into the `tests.py` script, or else rename it to
    something like `test_my_module.py` to make it clear which module is being tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a package, make sure you place the `tests.py` script in the directory that
    contains the package, not inside the package itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing unit tests for your modules and packages](graphics/B05012_8_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you place the `test.py` script inside the package directory, you are likely
    to encounter problems when your unit tests attempt to import the package.
  prefs: []
  type: TYPE_NORMAL
- en: Your `tests.py` script should define a `unittest.TestCase` object for each publicly
    accessible module in your package, and each of these objects should have a `testXXX()`
    method for each function or major piece of functionality defined within the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing this allows you to test your module or package simply by executing the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You should run your unit tests whenever you want to check that your module is
    working, and in particular before uploading or sharing your module or package
    with other people.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a module or package for publication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 6](ch06.html "Chapter 6. Creating Reusable Modules"), *Creating
    Reusable Modules*, we looked at a number of things that make a module or package
    suitable for reuse:'
  prefs: []
  type: TYPE_NORMAL
- en: It must function as a standalone unit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A package should ideally use relative imports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any external dependencies in your module or package must be clearly noted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also identified three things that help to create an excellent reusable module
    or package:'
  prefs: []
  type: TYPE_NORMAL
- en: It should solve a general problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your code should follow standard coding conventions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your module or package should be clearly documented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first step in preparing your module or package for publication is to ensure
    that you've followed at least the first three of these, and, ideally, all six
    of these guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: The second step is to make sure that you've written at least a few unit tests
    and your module or package passes all of these. Finally, you will need to decide
    *how* you want to publish your code.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to share your code with friends or work colleagues or write a blog
    post along with a link to your code, then the easiest way to do so is to upload
    it to a source code repository such as GitHub. We will take a look at how this
    is done in the next section. Unless you make it private, your code can be accessed
    by anyone who has the correct link. People can view your source code (including
    the documentation) online, download your module or package for use in their own
    programs, and "fork" your code, creating their own private copy which they can
    then modify.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to share your code with a wider audience, the best approach is to
    submit it to the **Python Package Index** (**PyPI**). This will mean that others
    can find your module or package by searching through the PyPI index and anyone
    can install it using **pip**, the Python Package Manager. Later sections of this
    chapter will describe how to submit your module or package to PyPI and how pip
    can be used to download and work with modules and packages.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading your work to GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitHub ([https://github.com/](https://github.com/)) is a popular web-based system
    for storing and managing source code. While there are several alternatives, GitHub
    is particularly popular with people writing and sharing open source Python code,
    and this is the source code management system that we will use in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Before delving into the specifics of GitHub, let's start by looking at how source
    code management systems work in general and why you might want to use one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you are writing a complex module and have opened your module in
    a text editor to make a few changes. While making these changes, you accidentally
    select 100 lines of code and press the *Delete* key. Before you realize what you''ve
    done, you save and close the file. Too late: those 100 lines of text are gone.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you might (and hopefully will) have a backup system in place which
    keeps regular backups of your source files. But if you had made changes to some
    of the missing code in the past few minutes, you are likely to have lost those
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: Now consider a situation where you've shared a module or package with a colleague,
    and they decide to make a few changes. Perhaps there's a bug that needed fixing
    or a new feature they wanted to add. They change your code and send it back to
    you with a note describing what they've done. Unfortunately, unless you compare
    each line in the original and modified versions of your source files, you can't
    be sure exactly what your colleague has done to your files.
  prefs: []
  type: TYPE_NORMAL
- en: A source code management system solves these types of problems. Instead of just
    having a copy of your module or package sitting in a directory on your hard disk,
    you create a **repository** within a source code management system such as GitHub,
    and **commit** your source code to this repository. Then, as you make changes
    to your files, fixing bugs and adding features, you commit each change that you
    make back to the repository. The source code repository keeps track of every change
    you have made, allowing you to see exactly what has been changed over time and,
    where necessary, undoing changes that were made previously.
  prefs: []
  type: TYPE_NORMAL
- en: You aren't limited to having just one person work on a module or package. People
    can **fork** your source code repository, creating their own private copy of it,
    and then use this private copy to fix bugs and add new features. Once they've
    done this, they can send you a **pull request** which includes the changes they
    have made. You can then decide whether or not to merge those changes into your
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t worry too much about these details, though—source code management is
    a complex topic, and there are lots of sophisticated tricks you can perform using
    tools such as GitHub to manage your source code. The important thing to remember
    is that you create a repository to hold the master copy of the source code for
    your module or package, commit your code into this repository, and then continue
    to commit each time you fix a bug or add a new feature. The following illustration
    summarizes this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Uploading your work to GitHub](graphics/B05012_8_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The trick with a source management system is to commit regularly—every time
    you add a new feature or fix a bug, you should immediately commit your changes.
    This way, the difference between one version and the next in the repository is
    only the code which adds that one feature or fixes that one problem. If you make
    a number of changes to your source code before committing, the repository will
    be a lot less useful.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen how source code management systems work, let's implement
    a real example to see how to use GitHub for managing your source code. First off,
    go to the main GitHub site ([https://github.com/](https://github.com/)). If you
    don't have an account with GitHub, you will need to sign up, choosing a unique
    username, as well as supplying a contact e-mail address and password. If you have
    used GitHub before, you can sign in with the username and password you have already
    set up.
  prefs: []
  type: TYPE_NORMAL
- en: Note that it's free to sign up and use GitHub; the only limitation is that every
    repository you create will be public, so anyone who wishes to can see your source
    code. You can set up private repositories if you want, but these do incur a monthly
    charge. However, since we are using GitHub to share our code with others, having
    a private repository doesn't make any sense. You'd only need a private (paid)
    repository if you wanted to share your code with a select group of people while
    preventing anyone else from accessing it. If you're in the position of having
    to do this, though, paying for a private repository is the least of your concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have signed in to GitHub, your next task is to install the command-line
    tools for **Git**. Git is the underlying source code management toolkit used by
    GitHub; you'll use the `git` command to work with your GitHub repository from
    the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the required software, go to [https://git-scm.com/downloads](https://git-scm.com/downloads)
    and download an installer for your particular operating system. Once this has
    finished downloading, run the installer and follow the instructions as it installs
    the `git` command-line tools. When this is finished, open a terminal or command-line
    window, and try typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: All going well, you should see the version number of the `git` command-line
    tools you have installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these prerequisites out of the way, let''s use GitHub to create an example
    repository. Go back to the [https://github.com/](https://github.com/) web page
    and click on the **+ New Repository** button highlighted in green. You will be
    asked to enter the details of the repository you want to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Uploading your work to GitHub](graphics/B05012_8_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To set up your repository, enter `test-package` for the repository's name, and
    choose **Python** from the **Add .gitignore** drop-down menu. A `.gitignore` file
    is used to exclude certain files from the repository; using a `.gitignore` file
    for Python means that the temporary files Python creates won't be included in
    the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, click on the **Create repository** button to create the new repository.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure you don't select the **Initialize this repository with a README**
    option. You don't want a README file created at this stage; the reason for this
    will become clear shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the repository has been created on GitHub, our next task is to **clone**
    a copy of that repository onto your computer''s hard disk. To do this, create
    a new directory named `test-package` to hold your local copy of the repository,
    open up a terminal or command-line window, and use the `cd` command to move to
    your new `test-package` directory. Then, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you replace both instances of `<username>` in the preceding command
    with your GitHub username. You will be prompted to enter your GitHub password
    to authenticate yourself, and a copy of the repository will be saved into your
    new directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the repository is currently empty, you won''t see anything in your
    directory. However, there are some hidden files that `git` uses to keep track
    of your local copy of the repository. To see these hidden files, you can use the
    `ls` command from a terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `.git` directory holds information about your new GitHub repository, while
    the `.gitignore` file contains the instructions you asked GitHub to set up for
    you to ignore the Python temporary files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an (initially empty) repository, let''s create some files
    in it. The first thing we need to do is choose a unique name for our package.
    Because our package is going to be submitted to the Python Package Index, the
    name must be truly unique. To achieve this, we''ll use your GitHub username as
    the basis for our package name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For example, since my GitHub username is "erikwestra", the name I would use
    for this package would be `erikwestra-test-package`. Make sure you select a name
    based on your GitHub username, to make sure that the package name is truly unique.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a name for our package, let''s create a README file describing
    this package. Create a new text file named `README.rst` in your `test-package`
    directory, and place the following into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you replace each occurrence of `<username>` with your GitHub username.
    This text file is in **reStructuredText format**. reStructuredText is a formatting
    language used by PyPI to display formatted text.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While GitHub can support reStructuredText, by default it uses a different text
    format called **Markdown**. Markdown and reStructuredText are two competing formats,
    and unfortunately, PyPI requires reStructuredText, while GitHub by default uses
    Markdown. This is why we told GitHub not to create a README file when we set up
    the repository; if we had done this, it would have been in the wrong format.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user views your repository on GitHub, they will see the contents of
    this file neatly formatted according to the reStructuredText rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Uploading your work to GitHub](graphics/B05012_8_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to learn more about reStructuredText, you can read all about it
    at [http://docutils.sourceforge.net/rst.html](http://docutils.sourceforge.net/rst.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have set up the README file for our package, let''s create the
    package itself. Create another directory inside `test-package` named `<username>_test_package`,
    replacing `<username>` with your GitHub username, and place an empty package initialization
    file (`__init__.py`) inside this directory. Then, create another file inside the
    `<username>_test_package` directory named `test.py`, and enter the following into
    this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is just an example, of course. Calling the `test.run()` function will cause
    ten random names to be displayed. More interesting is the fact that we have now
    defined the initial contents for our test package. However, all we've done is
    created some files on our local computer; this doesn't affect GitHub at all, and
    if you reload your repository page in GitHub, none of your new files will show
    up.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have our changes take effect, we need to **commit** our changes to the repository.
    We''ll start by taking a look at how our local copy differs from the one in the
    repository. To do this, go back to your terminal window, `cd` into the `test-package`
    directory, and type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The description can be a bit confusing, but it''s not too tricky. Basically,
    GitHub is telling you that there''s a new file, `README.rst`, and a new directory,
    named `<username>_test_package`, which it doesn''t know about (or, in GitHub parlance,
    is "untracked"). Let''s add these new entries to our repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure you replace `<username>` with your GitHub username. If you now type
    `git status`, you''ll see that the files we created have been added to our local
    copy of the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Whenever you add a new directory or file to your project, you will need to use
    the `git add` command to add it to the repository. At any time, you can see if
    you've missed any files by typing the `git status` command and looking for "untracked"
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve included our new files, let''s commit our changes to the repository.
    Type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This commits a new change to your local copy of the repository. The `-a` option
    tells GitHub to automatically include any changed files, and the `-m` option lets
    you enter a brief message, describing the changes you have made. In this case,
    our commit message is set to the value "`Initial commit.`".
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve committed our change, we need to upload from our local computer
    to the GitHub repository. To do this, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You will be prompted to enter your GitHub password to authenticate yourself,
    and the changes you have committed will be stored into your repository on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GitHub separates the `commit` command from the `push` command because you might
    need to make several commits as you make changes to your program, without necessarily
    being online at the time. For example, if you are on a long plane trip, you could
    work on your code locally, committing each change as you went along and then pushing
    all your changes at once when you land and have Internet access again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that your changes have been pushed to the server, you can reload the page
    on GitHub, and your newly created package will appear in the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Uploading your work to GitHub](graphics/B05012_8_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will also see the contents of your `README.rst` file displayed below the
    list of files, describing your new package and how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever you make changes to your package, make sure you run through the following
    steps to save your changes into the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `git status` command to see what's changed. If you've added any files
    that need to be included in the repository, use `git add` to add them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `git commit -a -m '<commit message>'` command to commit your changes
    to your local copy of the GitHub repository. Make sure you enter a suitable commit
    message to describe the change you have made.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you are ready to do so, use the `git push` command to send your committed
    changes to GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's a lot more to using GitHub, of course, and a great many commands and
    options that you will no doubt want to explore once you get into it—but this is
    enough to get you started.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've set up a GitHub repository for your Python module or package, it
    will be easy to share your code with someone else. All you need to do is share
    a link to your GitHub repository, and the other person can download the files
    they want.
  prefs: []
  type: TYPE_NORMAL
- en: To make this process even easier and make your packages searchable so that they
    can be found by a wider audience, you should consider submitting your package
    to the Python Package Index. We'll look at the steps involved in doing this next.
  prefs: []
  type: TYPE_NORMAL
- en: Submitting to the Python Package Index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To submit your Python package to the Python Package Index, you first have to
    sign up for a free account at [https://pypi.python.org/pypi](https://pypi.python.org/pypi).
    Click on the **Register** link in the box in the upper-right hand corner of the
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Submitting to the Python Package Index](graphics/B05012_8_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will need to choose a username and password, as well as supply an e-mail
    address. Remember the username and password you enter as you'll need it shortly.
    When you submit the form, you'll be sent an e-mail with a link which you need
    to click on to complete your registration.
  prefs: []
  type: TYPE_NORMAL
- en: There are two files you will need to add to your project before you can submit
    it to PyPI, a `setup.py` script, which is used to bundle and upload your package,
    and a `LICENSE.txt` file, which describes the license under which your package
    can be used. Let's add these two files now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file inside your `test-package` directory named `setup.py`, and enter
    the following into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you replace each occurrence of `<username>` with your GitHub username,
    and also replace `<your name>` and `<your email address>` with the relevant values.
    Because this is just a test, we are using the name `<username>-test-package` for
    this package; for a real project, we would use a much more meaningful (but still
    unique) name for our package.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that this version of the `setup.py` script is using the **Distutils**
    package. Distutils is part of the Python Standard Library and is a straightforward
    way of creating and distributing your code. There is an alternative library called
    **Setuptools**, which many people prefer as it is a more modern library with more
    features and is often seen as the successor to Distutils. However, Setuptools
    is not currently part of the Python Standard Library. Since it is easier to use
    and has all the features we need, we are using Distutils here to keep this process
    as simple as possible. If you are familiar with using it, feel free to use Setuptools
    instead of Distutils as the two are identical for what we are doing here.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to create a new text file named `LICENSE.txt`. This file will
    hold the software license under which you are releasing your package. It is important
    to include a license so that people know exactly what they can and can't do with
    your code; you can't submit a package without supplying a license.
  prefs: []
  type: TYPE_NORMAL
- en: While you can put anything you like into the `LICENSE.txt` file, you should
    generally use one of the existing software licenses. For example, you might like
    to use the MIT license available at [https://opensource.org/licenses/MIT](https://opensource.org/licenses/MIT)—this
    license makes your code available for others to use for any purpose, while ensuring
    that you can't be held liable for any problems that may occur from its use.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these two files in place, you can finally submit your new package to the
    Python Package Index. To do this, type the following command into your terminal
    or command-line window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will attempt to register your new package with the Python Package
    Index. You''ll be asked to enter your PyPI username and password, and given the
    opportunity to store these so you don''t have to re-enter them each time. Once
    the package has been successfully registered, you can upload the package contents
    by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see a couple of warnings, which you can safely ignore, before your
    package is uploaded to PyPI. If you then go to the PyPI web site, you will see
    your new package listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Submitting to the Python Package Index](graphics/B05012_8_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the **Home Page** link points to your project's page on GitHub,
    and there is a direct download link for version 1.0 of your package. Unfortunately,
    however, this download link doesn't work yet because you haven't told GitHub what
    version 1.0 of your package looks like. To do this, you have to create a **tag**
    in GitHub which corresponds to version 1.0 of your system; GitHub will then create
    a downloadable version of your package that matches that tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you create your 1.0 release, you should commit the changes you have
    made to the repository. This is good practice anyway, so let''s see how this is
    done: start by typing `git status` to see which files have been added or changed,
    then use `git add` to add each of the untracked files in turn. Once this has been
    done, type `git commit -a -m ''Preparing for PyPI submission''` to commit your
    changes to the repository. Finally, type `git push` to send your committed changes
    to GitHub.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all this has been done, you can create the tag that corresponds to version
    1.0 of your package by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure you replace `<username>` with your GitHub username so that the package
    name is correct. Finally, use the following variant of the `git push` command
    to copy the newly-created tag to the GitHub server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Once again, you will be asked to enter your GitHub password. When this command
    finishes, you will have a version 1.0 release of your package available for download
    at `https://github.com/<username>/test-package/tarball/1.0`, where `<username>`
    is your GitHub username. If you now go to PyPI and look for your test package,
    you will be able to click on the **Download URL** link to download a copy of your
    1.0 package.
  prefs: []
  type: TYPE_NORMAL
- en: If your new package appears in the Python Package Index, and you can successfully
    download the 1.0 version of your package by following the **Download** link, then
    you deserve a pat on the back. Congratulations! This is a complex process, but
    one that will give you the largest audience possible for your reusable modules
    and packages.
  prefs: []
  type: TYPE_NORMAL
- en: Using pip to download and install modules and packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In chapters 4 and 5 of this book, we used **pip**, the Python Package Manager,
    to install various libraries that we wanted to work with. As we learned in [Chapter
    7](ch07.html "Chapter 7. Advanced Module Techniques"), *Advanced Module Techniques*,
    pip normally installs a package into Python's `site-packages` directory. Since
    this directory is listed in the module search path, your newly installed module
    or package can then be imported and used in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now use pip to install the test package we created in the previous section.
    Since we know that our package has been given the name `<username>_test_package`,
    where `<username>` is your GitHub username, you can install this package directly
    into your `site-packages` directory by typing the following command into a terminal
    or command-line window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure you replace `<username>` with your GitHub username. Note that if
    you do not have permission to write to your Python installation''s `site-packages`
    directory, you may need to add `sudo` to the start of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you do this, you will be prompted to enter your administrator password before
    the `pip` command is run.
  prefs: []
  type: TYPE_NORMAL
- en: 'All going well, you should see various commands being run as your newly created
    package is downloaded and installed. Assuming this works successfully, you can
    then start your Python interpreter and access your new package just as if it were
    part of the Python Standard Library. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Of course, it's not just you who can do this. Other Python developers can also
    access your new package in exactly the same way. This makes it extremely easy
    for developers to download and use your package.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a few exceptions, you can use pip to install any package you want from
    the Python Package Index. By default, pip will install the latest available version
    of a package; to specify a particular version, you can supply a version number
    when you install the package, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install version 1.0 of your test package. If you have already installed
    a package and a newer version becomes available, you can upgrade your package
    to the newer version using the `--upgrade` command-line option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also obtain a list of the packages you have installed using the `list`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one more feature of pip that you should be aware of. Instead of installing
    each package individually, you can create a **requirements file** that lists all
    the packages you want, and have them installed all at once. A typical requirements
    file would look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The requirements file lists the various packages you want to have installed
    and their associated version number.
  prefs: []
  type: TYPE_NORMAL
- en: 'By convention, a requirements file is named `requirements.txt`, and is placed
    in your project''s top-level directory. Requirements files are extremely useful
    because they make it easy to recreate a Python development environment, including
    all the packages that your program depends upon, with just a single command. This
    is done in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Since the requirements file is stored alongside the program's source code, you
    would normally include the `requirements.txt` file in your source code repository.
    This means you can clone your repository to a new computer and, with a single
    command, reinstall all the modules and packages your program depends upon.
  prefs: []
  type: TYPE_NORMAL
- en: 'While you can create a requirements file by hand, you would normally use pip
    to create this file for you. After installing the required modules and packages,
    you can use the following command to create the `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The wonderful thing about this command is that you can re-run it any time your
    requirements change. If you find that your program needs to use a new module or
    package, you use `pip install` to install the new module or package, and then
    immediately call `pip freeze` to create an updated requirements file which includes
    the new dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more thing to be aware of when installing and working with modules
    and packages: sometimes, you will need to have *different* versions of a module
    or package installed. For example, perhaps you want to run a particular program
    that requires version 1.6 of the Django package but you only have version 1.4
    installed. If you update your copy of Django to version 1.6, you may break other
    programs that depend upon it.'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this situation, you may find it useful to set up a **virtual environment**
    on your computer. A virtual environment is like a separate Python installation
    with its own set of installed modules and packages. You can create a separate
    virtual environment for each project that you work on so that each project can
    have its own set of dependencies without interfering with the requirements of
    other projects you might install on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: When you want to use a particular virtual environment, you have to **activate**
    it. You can then use `pip install` to install the various packages you need into
    that environment, and run your program using the packages you have installed.
    When you want to finish working with that environment, you **deactivate** it.
    This lets you swap between virtual environments as necessary to work on your different
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual environments are a very powerful tool for working on projects with different,
    and possibly incompatible, package requirements. You can find out more about virtual
    environments at [http://docs.python-guide.org/en/latest/dev/virtualenvs/](http://docs.python-guide.org/en/latest/dev/virtualenvs/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the various ways in which you can test your
    Python modules and packages. We learned about unit testing and how the `unittest`
    package in the Python Standard Library makes it easier to write and use unit tests
    for the modules and packages that you develop. We saw how unit tests use the `assert`
    statement (or the various `assertXXX()` methods if you are using the `unittest.TestCase`
    class) to raise an `AssertionError` if a particular condition has not been met.
    By writing various unit tests, you can ensure that your modules and packages are
    working the way you expect them to.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at the process of preparing a module or package for publication,
    and saw how GitHub provides an excellent repository for storing and managing the
    source code for your modules and packages.
  prefs: []
  type: TYPE_NORMAL
- en: After creating our own test package, we worked through the process of submitting
    this package to the Python Package Index. Finally, we learned how to use pip,
    the Python Package Manager, to install a package from PyPI into your system's
    `site-packages` directory, before looking at the ways in which a requirements
    file or a virtual environment can be used to help manage your program's dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: In the final chapter of this book, we will see how modular programming acts
    more generally as the foundation for good programming techniques.
  prefs: []
  type: TYPE_NORMAL
