- en: Implementing Asynchronous Programming in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce you to the `asyncio` module in Python. It will cover
    the idea behind this new concurrency module, which utilizes event loops and coroutines
    and provides an API that is as readable as synchronous code. In this chapter,
    we will also discuss the implementation of asynchronous programming, in addition
    to threading and multiprocessing through the `concurrent.futures` module. During
    this process, we will cover the application of asynchronous programming via the
    most common uses of `asyncio`, including asynchronous input/output and avoiding
    blocking tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental elements of implementing asynchronous programming using `asyncio`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The framework for asynchronous programming provided by `asyncio`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `concurrent.futures` module and its usage, in respect to `asyncio`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the list a prerequisites for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that you have Python 3 installed on your computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the GitHub repository at [https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During this chapter, we will be working with the subfolder titled `Chapter10`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out the following video to see the Code in Action: [http://bit.ly/2TAtTrA](http://bit.ly/2TAtTrA)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The asyncio module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw in the previous chapter, the `asyncio` module provides an easy way
    to convert a sequential program to an asynchronous one. In this section, we will
    be discussing the general structure of an asynchronous program, and subsequently,
    how to implement the conversion from a sequential to an asynchronous program in
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines, event loops, and futures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few common elements that most asynchronous programs have, and coroutines,
    event loops, and futures are three of those elements. They are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event loops** are the main coordinators of tasks in an asynchronous program.
    An event loop keeps track of all of the tasks that are to be run asynchronously,
    and decides which of those tasks should be executed at a given moment. In other
    words, event loops handle the task switching aspect (or the execution flow) of
    asynchronous programming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coroutines** are a special type of function that wrap around specific tasks,
    so that they can be executed asynchronously. A coroutine is required in order
    to specify where in the function the task switching should take place; in other
    words, they specify when the function should give back the flow of execution to
    the event loop. The tasks for coroutines are typically either stored in a task
    queue or created inside the event loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Futures** are placeholders for the results returned from coroutines. These
    future objects are created as soon as coroutines are initiated in the event loop,
    so futures can represent actual results, pending results (if the coroutines have
    not finished executing), or even an exception (if that is what the coroutine will
    return).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An event loop, coroutines, and their corresponding futures, are the core elements
    of an asynchronous programming process. First, the event loop is started and interacts
    with its task queue, in order to obtain the first task. The coroutine for this
    task and its corresponding future are then created. When a task switching has
    to take place inside of that coroutine, the coroutine suspends, and the next coroutine
    is called; all data and the context from the first coroutine are also saved.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if that coroutine is blocking (for example, input/output processing or
    sleeping), the flow of execution is released back to the event loop, which will
    move on to the next item in the task queue. The event loop will initiate the last
    item in the task queue before it switches back to the first coroutine, and will
    proceed the execution from where it was last suspended.
  prefs: []
  type: TYPE_NORMAL
- en: 'As each task finishes executing, it will be dequeued from the task queue, its
    coroutine will be terminated, and the corresponding future will register the returned
    result from the coroutine. This process will go on until all tasks in the task
    queue are completely executed. The following diagram further illustrates the general
    structure of the asynchronous process described earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8e37c350-e34c-4f29-9459-8084491a0a3e.png)'
  prefs: []
  type: TYPE_IMG
- en: Asynchronous programming process
  prefs: []
  type: TYPE_NORMAL
- en: Asyncio API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the general structure of an asynchronous program in mind, let's consider
    the specific APIs that the `asyncio` module and Python provide for the implementation
    of asynchronous programs. The first foundation for this API is the `async` and
    `await` keywords that were added to Python 3.5\. These keywords are used to specify
    the main elements of an asynchronous program to Python.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, `async` is typically put in front of the `def` keyword when a
    function is declared. A function with the `async` keyword in front of it will
    be interpreted by Python as a coroutine. As we discussed, inside of each coroutine,
    there has to be a specification regarding when the task switching events will
    take place. The `await` keyword is then used to specify where and when, exactly,
    to give back the flow of execution to the event loop; this is typically done through
    waiting for another coroutine to produce a result (`await coroutine`) or through
    helper functions from the `asyncio` module, such as the `asyncio.sleep()` and
    `asyncio.wait()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the `async` and `await` keywords are actually provided
    by Python and are not managed by the `asyncio` module. This means that asynchronous
    programming can actually be implemented without `asyncio`, but, as you will see,
    `asyncio` provides a framework and infrastructure to streamline this process,
    and is therefore the primary tool in Python for the implementation of asynchronous
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, the most commonly used API from the `asyncio` module is event-loop-managing
    functionalities. With `asyncio`, you can start to manipulate your tasks and event
    loop with intuitive and easy function calls, without extensive boilerplate code.
    These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`asyncio.get_event_loop()`: This method returns the event loop for the current
    context, which is an `AbstractEventLoop` object. Most of the time, we do not need
    to worry about this class, as the `asyncio` module already provides a high-level
    API to manage our event loops.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AbstractEventLoop.create_task()`: This method is to be called by an event
    loop. It adds its input to the current task queue of the calling event loop; the
    input is typically a coroutine (that is, a function with the `async` keyword).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AbstractEventLoop.run_until_complete()`: This method is also to be called
    by an event loop. It takes in the main coroutine of an asynchronous program and
    executes it until the corresponding future of the coroutine is returned. While
    the method initiates the event loop execution, it also blocks all subsequent code
    following it, until all futures are complete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AbstractEventLoop.run_forever()`: This method is somewhat similar to `AbstractEventLoop.run_until_complete()`,
    except for the fact that, as suggested by the method name, the calling event loop
    will run forever, unless the `AbstractEventLoop.stop()` method is called. So,
    instead of exiting, the loop will continue to run, even upon obtaining the returned
    futures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AbstractEventLoop.stop()`: This method causes the calling event loop to stop
    executing and exit at the nearest appropriate opportunity, without causing the
    whole program to crash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Aside from these methods, we use a number of non-blocking functions to facilitate
    the task switching event. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`asyncio.sleep()`: While in itself a coroutine, this function creates an additional
    coroutine that completes after a given time (specified by the input, in seconds).
    It is typically used as `asyncio.sleep(0)`, to cause an immediate task switching
    event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asyncio.wait()`: This function is also a coroutine, and hence, it can be used
    to switch tasks. It takes in a sequence (usually a list) of futures and waits
    for them to complete their execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The asyncio framework in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have seen, `asyncio` provides a simple and intuitive way to implement
    the framework of an asynchronous program with Python's asynchronous programming
    keywords. With that, let's consider the process of applying the framework provided
    to a synchronous application in Python, and convert it to an asynchronous one.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronously counting down
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `Chapter10/example1.py` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The goal of this example is to illustrate the asynchronous nature of overlapping
    the processing and waiting time of independent tasks. To do this, we will be analyzing
    a countdown function (`count_down()`) that takes in a string and a delay time.
    It will then count down from three to one, in seconds, while printing out the
    time elapsed from the beginning of the function's execution and the input string
    (with the current countdown number).
  prefs: []
  type: TYPE_NORMAL
- en: 'In our main program, we will call the `count_down()` function on the letters
    `A`, `B`, and `C`, with different delay times. After running the script, your
    output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The numbers at the beginning of the lines indicate the total numbers of seconds
    elapsed from the beginning of the program. You can see that the program counted
    down for letter `A` first, with one-second intervals, and it moved on to letter
    `B`, with 0.8-second intervals, and finally, to letter `C`, with 0.5-second intervals.
    This is a purely sequential, synchronous program, since there is no overlapping
    between processing and waiting time. Additionally, it took approximately 6.9 seconds
    to run the program, which is the sum of the counting down time of all three letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Keeping the idea behind asynchronous programming in mind, we can see that it
    is actually possible for us to convert this program to an asynchronous one. Specifically,
    let's suppose that during the first second of the program, while we are waiting
    to count down the letter `A`, we can switch tasks to move to other letters. In
    fact, we will implement this setup for all of the letters inside the `count_down()`
    function (in other words, we will turn `count_down()` into a coroutine).
  prefs: []
  type: TYPE_NORMAL
- en: Theoretically, now that all counting down tasks are coroutines in an asynchronous
    program, we should achieve better execution time and responsiveness for our program.
    Since all three tasks are processed independently, the countdown messages should
    be printed out of order (jumping between different letters), and the asynchronous
    program should only take about the same time as the largest task takes (that is,
    three seconds for letter `A`).
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, let''s make our program asynchronous. To do this, we first need
    to make `count_down()` into a coroutine and specify a point inside the function
    to be a task switching event. In other words, we will add the keyword `async`
    in front of the function, and, instead of the `time.sleep()` function, we will
    be using the `asyncio.sleep()` function along with the `await` keyword; the rest
    of the function should remain the same. Our `count_down()` coroutine should now
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As for our main program, we will need to initialize and manage an event loop.
    Specifically, we will create an empty event loop with the `asyncio.get_event_loop()`
    method, add all of the three counting down tasks into the task queue with `AbstractEventLoop.create_task()`,
    and, finally, start running the event loop with `AbstractEventLoop.run_until_complete()`.
    Our main program should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete script can also be found in the code repository of the book, inside
    the `Chapter10` subfolder, named `example2.py`. After running the script, your
    output should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can see how having an asynchronous program can improve the execution
    time and responsiveness of our programs. Instead of executing individual tasks
    sequentially, our program now switches between different countdowns and overlaps
    their processing/waiting times. This, as we discussed, results in different letters
    being printed out in between each other, or simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of the program, instead of waiting for the whole first second
    to print out the first message `A = 3`, the program switches to the next task
    in the task queue (in this case, it is waiting for 0.8 seconds for the letter
    `B`). This process continues until 0.5 seconds have passed and `C = 3` is printed
    out, and 0.3 seconds later (at the time 0.8 seconds), `B = 3` is printed out.
    This all happens before `A = 3` is printed out.
  prefs: []
  type: TYPE_NORMAL
- en: 'This task-switching property of our asynchronous program makes it significantly
    more responsive. Instead of hanging for one second before the first message is
    printed, the program now only takes 0.5 seconds (the shortest waiting period)
    to print out its first message. As for the execution time, you can see that this
    time, it only takes three seconds, in total, to execute the whole program (instead
    of 6.9 seconds). This corresponds to what we speculated: that the execution time
    would be right around the time it takes to execute the largest task.'
  prefs: []
  type: TYPE_NORMAL
- en: A note about blocking functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you have seen, we have to replace our original `time.sleep()` function with
    its equivalent from the `asyncio` module. This is because `time.sleep()` is, by
    nature, a blocking function, which means that it cannot be used to implement a
    task switching event. To test this, in our `Chapter10/example2.py` file (our asynchronous
    program), we will replace the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will be replaced with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: After running this new script, your output will simply be the same as that of
    our original sequential, synchronous program. So, replacing `await asyncio.sleep()`
    with `time.sleep()` actually converts our program back to synchronous, ignoring
    the event loop that we implemented. What happened was, when our program proceeded
    to that line inside of the `count_down()` function, `time.sleep()` actually blocked
    and prevented the release of the execution flow, essentially rendering the whole
    program synchronous once again. Revert `time.sleep()` back to `await asyncio.sleep()`
    to fix this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates an example of the difference in execution
    time between blocking and non-blocking file handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/14eb98aa-5364-4486-8fba-75e4434c5293.png)'
  prefs: []
  type: TYPE_IMG
- en: Blocking versus non-blocking
  prefs: []
  type: TYPE_NORMAL
- en: 'This phenomenon raises an interesting issue: if a heavy, long-running task
    is blocking, then it is literally impossible to implement asynchronous programming
    with that task as a coroutine. So, if we really wanted to achieve what a blocking
    function returns in an asynchronous application, we would need to implement another
    version of that blocking function, which could be made into a coroutine and allow
    for task switching events to take place at at least one point inside the function.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, after implementing `asyncio` as one of the official features of Python,
    Python core developers have been on working to produce the coroutine version of
    the most commonly used Python blocking functions. This means that if you ever
    find blocking functions that prevent your program from being truly asynchronous,
    you will most likely be able to find the coroutine versions of those functions
    to implement in your program.
  prefs: []
  type: TYPE_NORMAL
- en: However, the fact that there are asynchronous versions of traditionally blocking
    functions in Python with potentially different APIs means that you will need to
    familiarize yourself with those APIs from separate functions. Another way to handle
    blocking functions without having to implement their coroutine versions is to
    use an executor to run the functions in separate threads or separate processes,
    to avoid blocking the thread of the main event loop.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous prime-checking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Moving on from our starting counting-down example, let''s reconsider the example
    from the previous chapter. As a refresher, the following is the code for the synchronous
    version of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we discussed in the last chapter, here, we have a simple prime-checking function, `is_prime(x)`,
    that prints out messages indicating whether the input integer that it takes in, `x`,
    is a prime number. In our main program, we call `is_prime()` on three prime numbers,
    in an order of decreasing magnitude sequentially. This setup again creates a significant
    period of time during which the program appears to be hanging while processing
    the large input, resulting in a low responsiveness for the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output produced by the program will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement asynchronous programming for this script, first, we will have
    to create our first main component: the event loop. To do this, instead of using
    the `''__main__''` scope, we will convert it to a separate function. This function
    and our `is_prime()` prime-checking function will be the coroutines in our final
    asynchronous program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to convert both the `is_prime()` and `main()` functions into coroutines;
    again, this means putting the `async` keyword in front of the `def` keyword, and
    the `await` keyword inside each function, to specify the task-switching event.
    For `main()`, we simply implement that event while waiting for the task queue
    by using `aysncio.wait()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Things are more complicated in the `is_prime()` function, as there is no clear
    point during which the execution flow should be released back to the event loop,
    like in our previous counting-down example. Recall that the goal of asynchronous
    programming is to achieve a better execution time and responsiveness, and to implement
    this, the task-switching event should take place during a heavy, long-running
    task. This requirement, however, is dependent on the specifics of your program—particularly,
    the coroutine, the task queue of the program, and the individual tasks in the
    queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the task queue of our program consists of three numbers: `9637529763296797`,
    `427920331`, and `157`; in order, we can consider them as a large task, a medium
    task, and a small task. To improve responsiveness, we would like to switch tasks
    during the large task, and not during the small task. This setup will allow the
    medium and small tasks to be started, processed, and maybe finished during the
    execution of the large task, even if the large task is in front in the task queue
    of the program.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will consider our `is_prime()` coroutine. After checking for some specific
    edge cases, it iterates in a `for` loop through every odd number under the square
    root of the input integer and tests for the divisibility of the input with regards
    to the current odd number in question. Inside this long-running `for` loop, then,
    is the perfect place to switch tasks—that is, to release the execution flow back
    to the event loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we still need to decide at which specific points in the `for` loop
    to implement the task-switching event. Again, taking into account the individual
    tasks in the task queue, we are looking for a point that is fairly common in the
    large task, not so common in the medium task, and non-existent in the small task.
    I have decided that this point is every 1,00,000-number period, which does satisfy
    our requirements, and I have used the `await asyncio.sleep(0)` command to facilitate
    the task-switching event, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in our main program (not to be confused with the `main()` coroutine),
    we create our event loop and use it to run our `main()` coroutine, until it completes
    its execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you saw in the previous chapter, better responsiveness was achieved through
    this asynchronous version of the script. Specifically, instead of appearing like
    it is hanging while processing the first large task, our program now prints out
    output messages for the other, smaller tasks, before it finishes executing the
    large task. Our end result will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Improvements from Python 3.7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of 2018, Python 3.7 has just come out, with several major new features, such
    as data classes, guaranteed ordered dictionaries, better timing precision, and
    so on. Asynchronous programming and the `asyncio` module received a number of
    important improvements.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, `async` and `await` are now officially reserved keywords in Python.
    While we have been calling them keywords, Python did not, in fact, treat these
    words as reserved keywords, up until now. This means that neither `async` nor
    `await` can be used to name variables or functions in a Python program. If you
    are using Python 3.7, fire up a Python interpreter and try to use these keywords
    for variable or function names, and you should receive the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'A major improvement in Python 3.7 comes with the `asyncio` module. Specifically,
    you might have noticed from our previous examples that the main program typically
    contains a fair amount of boilerplate code to initiate and run the event loop,
    which most likely remains the same in all asynchronous programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With `main()` being a coroutine in our program, `asyncio` allows us to simply
    run it in an event loop by using the `asyncio.run()` method. This eliminates significant
    boilerplate code in Python asynchronous programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can convert the preceding code to a more simplified version in Python
    3.7, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There are other improvements regarding asynchronous programming, in both performance
    and ease in usage, that were implemented in Python 3.7; however, we will not be
    discussing them in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Inherently blocking tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first example in this chapter, you saw that asynchronous programming
    can provide our Python programs with better execution time, but that is not always
    the case. Asynchronous programming alone can only provide improvements in speed
    if all processing tasks are non-blocking. However, similar to the comparison between
    concurrency and inherent sequentiality in programming tasks, some computing tasks
    in Python are inherently blocking, and therefore, they cannot be taken advantage
    of by asynchronous programming.
  prefs: []
  type: TYPE_NORMAL
- en: This means that if your asynchronous programming has inherently blocking tasks
    in some coroutines, the program will not gain any additional improvement in speed
    from the asynchronous architecture. While task-switching events still take place
    in those programs, which will improve the responsiveness of the programs, no instructions
    will be overlapping each other, and no additional speed will thus be gained. In
    fact, since there is considerable overhead regarding the implementation of asynchronous
    programming in Python, our programs might even take longer to finish their execution
    than the original, synchronous programs.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's look at a comparison in speed between the two versions of
    our prime-checking program. Since the primary processing portion of the program
    is the `is_prime()` coroutine, which solely consists of number crunching, we know
    that this coroutine contains blocking tasks. So, the asynchronous version is,
    in fact, expected to run more slowly than the synchronous version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the `Chapter10` subfolder of the code repository and take a look
    at the files `example3.py` and `example4.py`. These files contain the same code
    for the synchronous and asynchronous prime-checking programs that we have been
    seeing, but with the addition that we are also tracking how much time it takes
    to run the respective programs. The following is my output after running `example3.py`,
    the synchronous version of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows my output when running `example4.py`, the asynchronous
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: While the output that you receive might be different in the specific times it
    took to run either program, it should be the case that, as we discussed, the asynchronous
    program actually took longer to run than the synchronous (sequential) one. Again,
    this is because the number crunching tasks inside our `is_prime()` coroutine are
    blocking, and, instead of overlapping these tasks in order to gain additional
    speed, our asynchronous program simply switched between these tasks in its execution.
    In this case, only responsiveness is achieved through asynchronous programming.
  prefs: []
  type: TYPE_NORMAL
- en: However, this does not mean that if your program contains blocking functions,
    asynchronous programming is out of the question. As mentioned previously, all
    execution in an asynchronous program, if not specified otherwise, occurs entirely
    in the same thread and process, and blocking CPU-bound tasks can thus prevent
    program instructions from overlapping each other. However, this is not the case
    if the tasks are distributed to separate threads/processes. In other words, threading
    and multiprocessing can help asynchronous programs with blocking instructions
    to achieve better execution time.
  prefs: []
  type: TYPE_NORMAL
- en: concurrent.futures as a solution for blocking tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will be considering another way to implement threading/multiprocessing:
    the `concurrent.futures` module, which is designed to be a high-level interface
    for implementing asynchronous tasks. Specifically, the `concurrent.futures` module
    works seamlessly with the `asyncio` module, and, in addition, it provides an abstract
    class called `Executor`, which contains the skeleton of the two main classes that
    implement asynchronous threading and multiprocessing, respectively (as suggested
    by their names): `ThreadPoolExecutor` and `ProcessPoolExecutor`.'
  prefs: []
  type: TYPE_NORMAL
- en: Changes in the framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we jump into the API from `concurrent.futures`, let's discuss the theoretical
    basics of asynchronous threading/multiprocessing, and how it plays into the framework
    of the asynchronous programming that `asyncio` provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, we have three major elements in our ecosystem of asynchronous
    programming: the event loop, the coroutines, and their corresponding futures.
    We still need the event loop while utilizing threading/multiprocessing, to coordinate
    the tasks and handle their returned results (futures), so these elements typically
    remain consistent with single-threaded asynchronous programming.'
  prefs: []
  type: TYPE_NORMAL
- en: As for the coroutines, since the idea of combining asynchronous programming
    with threading and multiprocessing involves avoiding blocking tasks in the coroutines
    by executing them in separate threads and processes, the coroutines do not necessarily
    have to be interpreted as actual coroutines by Python anymore. Instead, they can
    simply be traditional Python functions.
  prefs: []
  type: TYPE_NORMAL
- en: One new element that we will need to implement is the executor that facilitates
    threading or multiprocessing; this can be an instance of the `ThreadPoolExecutor`
    class or the `ProcessPoolExecutor` class. Now, every time we add a task to our
    task queue in the event loop, we will also need to reference this executor, so
    that separate tasks will be executed in separated threads/processes. This is done
    through the `AbstractEventLoop.run_in_executor()` method, which takes in an executor,
    a coroutine (though, again, it does not have to be an actual coroutine), and arguments
    for the coroutines to be executed in separate threads/processes. We will see an
    example of this API in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Examples in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at a specific implementation of the `concurrent.futures` module.
    Recall that in this chapter's first example (the counting down example), the blocking
    `time.sleep()` function prevented our asynchronous program from becoming truly
    asynchronous, and had to be replaced with its non-blocking version, `asyncio.sleep()`.
    Now, we are executing the individual countdowns in separate threads or processes,
    which means that the blocking `time.sleep()` function will not pose any problems
    in terms of executing our program asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the `Chapter10/example5.py` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `count_down()` is declared as a typical, non-coroutine Python function.
    In `main()`, which remains a coroutine, we declare our task queue for the event
    loop. Again, we are using the `run_in_executor()` method during this process,
    instead of the `create_task()` method that is used in single-threaded asynchronous
    programming. In our main program, we also need to initiate an executor, which,
    in this case, is an instance of the `ThreadPoolExecutor` class from the `concurrent.futures`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: The decision between using threading and multiprocessing is, as we discussed
    in previous chapters, dependent on the nature of the program. Here, we need to
    share the `start` variable (holding the time at which the program starts to execute)
    among separate coroutines, so that they can perform the act of counting down;
    so, threading is chosen over multiprocessing.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the script, your output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This output is identical to the one that we obtained from the asynchronous program
    with pure `asyncio` support. So, even with a blocking processing function, we
    were able to make the execution of our program asynchronous, with threading implemented
    by the `concurrent.futures` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now apply the same concept to our prime-checking problem. We are first
    converting our `is_prime()` coroutine to its original, non-coroutine form, and
    executing it in separate processes again (which are more desirable than threads,
    as the `is_prime()` function is an intensive number-crunching task). An additional
    benefit of using the original version of `is_prime()` is that we will not have
    to perform a check of the task-switching condition that we have in our single-threaded
    asynchronous program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This will provide us with a significant speedup, as well. Let''s take a look
    at the `Chapter10/example6.py` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the script, I obtained the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, your execution time will most likely be different from mine, although
    the comparison between this and the other two versions of our prime-checking program
    should always be consistent: the original, synchronous version takes less time
    than the single-threaded asynchronous version, but more than the multiprocessing
    asynchronous version. In other words, by combining multiprocessing with asynchronous
    programming, we get the best of both worlds: the consistent responsiveness from
    asynchronous programming, and the improvement in speed from multiprocessing.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned about asynchronous programming, which is a model
    of programming that takes advantage of coordinating computing tasks to overlap
    the waiting and processing times. There are three main components to an asynchronous
    program: the event loop, the coroutines, and the futures. The event loop is in
    charge of scheduling and managing coroutines using its task queue. Coroutines
    are computing tasks that are to be executed asynchronously; each coroutine has
    to specify inside of its function exactly where it will give the execution flow
    back to the event loop (that is, the task-switching event). Futures are placeholder
    objects that contain the results obtained from the coroutines.'
  prefs: []
  type: TYPE_NORMAL
- en: The `asyncio` module, together with the Python keywords `async` and `await`,
    provides an easy-to-use API and an intuitive framework to implement asynchronous
    programs; additionally, this framework makes the asynchronous code just as readable
    as synchronous code, which is generally quite rare in asynchronous programming.
    However, we cannot apply single-threaded asynchronous programming on blocking
    computing tasks with the `asyncio` module alone. The solution to this is the `concurrent.futures`
    module, which provides a high-level API to implement asynchronous threading and
    multiprocessing, and can be used in addition to the `asyncio` module.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be discussing one of the most common applications
    of asynchronous programming, **Transmission Control Protocol** (**TCP**), as a
    means of server-client communication. You will learn about the basics of the concept,
    how it takes advantage of asynchronous programming, and how to implement it in
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is asynchronous programming? What advantages does it provide?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the main elements in an asynchronous program? How do they interact
    with each other?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the `async` and `await` keywords? What purposes do they serve?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What options does the `asyncio` module provide, in terms of the implementation
    of asynchronous programming?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the improvements in regards to asynchronous programming provided in
    Python 3.7?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are blocking functions? Why do they pose a problem for traditional asynchronous
    programming?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does `concurrent.futures` provide a solution to blocking functions for asynchronous
    programming? What options does it provide?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: Zaccone, Giancarlo. *Python Parallel Programming Cookbook*. Packt Publishing
    Ltd, 2015
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A guide to asynchronous programming in Python with asyncio* ([medium.freecodecamp.org/a-guide-to-asynchronous-programming-in-python-with-asyncio](https://medium.freecodecamp.org/a-guide-to-asynchronous-programming-in-python-with-asyncio-232e2afa44f6)), Mariia Yakimova'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*AsyncIO for the Working Python Developer* ([hackernoon.com/asyncio-for-the-working-python-developer](https://hackernoon.com/asyncio-for-the-working-python-developer-5c468e6e2e8e)), Yeray Diaz'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python Documentation. Tasks and coroutines. [docs.python.org/3/library/asyncio](https://docs.python.org/3/library/asyncio.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Modern Concurrency*, ([speakerdeck.com/pybay/2017-luciano-ramalho-modern-concurrency](https://speakerdeck.com/pybay/2017-luciano-ramalho-modern-concurrency)),
    PyBay 2017'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
