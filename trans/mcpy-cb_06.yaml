- en: Button Bash Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create a two-player game called Button Bash that you
    can play directly on Circuit Playground Express without a computer. Each player
    must press their push button as fast as they can. Each press of the button increases
    that player's score by one point. The players' current scores will be shown visually
    with the NeoPixels. The first player that reaches a score of 20 points wins the
    game.
  prefs: []
  type: TYPE_NORMAL
- en: To create this game, we will combine button input with light output through
    the NeoPixels and with audio output through the built-in speakers. This chapter
    contains a number of recipes, each showing different parts of the game, and we
    combine all of these pieces in the final recipe to produce the complete game.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class to detect a button state change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own Python modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding button interactions to the event loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a generator to get pixel colors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing scores with the ScoreBoard class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting winners with the ScoreBoard class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the ScoreBoard class to the event loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter can be found in the `Chapter06` folder in the
    GitHub repository, at [https://github.com/PacktPublishing/MicroPython-Cookbook](https://github.com/PacktPublishing/MicroPython-Cookbook).
  prefs: []
  type: TYPE_NORMAL
- en: Many of the recipes in this chapter require three audio files to be transferred
    to the Circuit Playground Express board. These files are called `start.wav`, `win1.wav`,
    and `win2.wav`. They can all be downloaded from the `Chapter06` folder in the
    GitHub repository. They should be saved in the top-level folder with your `main.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of the recipes in this chapter make use of the Circuit Playground Express
    library, which will typically get imported in the first line of the script, with
    the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This library will help us interact with the buttons, pixels, and speaker that
    come with the board.
  prefs: []
  type: TYPE_NORMAL
- en: Circuit Playground Express power
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The game that will be presented in this chapter can run directly on Circuit
    Playground Express, without a need for a connected computer. This is an excellent
    opportunity to introduce the options you have to make your project portable on
    this type of board. The board can receive power from a number of different portable
    sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll explore two different approaches to solving the problem of portable
    power. Each approach uses a different connector on the board. The first connector
    we will look at is the Micro B USB connector, which appears in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f18560bf-0456-41b2-91fc-66d55b9e8615.png)'
  prefs: []
  type: TYPE_IMG
- en: Courtesy of adafruit.com
  prefs: []
  type: TYPE_NORMAL
- en: 'This connector can be used to connect the board to a computer for power and
    to transfer your code and audio files onto the board. One approach is to attach
    a portable power bank to the board via USB. The following photograph shows the
    board being powered by one of these power banks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d1980cd1-2afe-44a9-ae6a-77e12bf84353.png)'
  prefs: []
  type: TYPE_IMG
- en: The benefit of this approach is that these power banks come in all different
    sizes and capacities, so you have plenty of options to choose the one that best
    meets your needs. They are rechargeable, making them reusable, and they can easily
    be purchased at most electronics retailers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second connector that we will look at is the JST battery input, which appears
    in the next photograph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1718da72-4ee5-42a7-96c1-0a2f95daa7ae.png)'
  prefs: []
  type: TYPE_IMG
- en: Courtesy of adafruit.com
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of portable battery sources that can be attached to this
    connector. Many of these battery holders are quite inexpensive, and they often
    support popular battery sizes, such as AAA batteries. Because the board has no
    built-in battery charging, you can safely use regular batteries or rechargeable
    batteries. The following photograph shows a battery holder with an on/off switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3135dd49-5835-4e6a-8969-faed1ad4cfbc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next photograph shows the same holder with the cover open, to provide a
    view of the three AAA batteries it uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1a4b85cd-4788-42e5-994e-9a3effd699f2.png)'
  prefs: []
  type: TYPE_IMG
- en: The battery holder shown in the previous photograph can be purchased for around
    $2 USD from [https://www.adafruit.com/product/727](https://www.adafruit.com/product/727).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class to detect a button state change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to define a class that, when instantiated,
    can keep track of the button press events of a specific button on the board. We
    will use this class in later recipes in this chapter, in order to create objects
    that will keep track of button presses on push buttons A and B.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to put common chunks of code into functions and classes,
    which will improve the code reuse in your projects. It can also help with large
    projects, in order to break up a lot of the logic into smaller, independent chunks
    of functions and classes. The implementation of this button event class will be
    kept generic on purpose, so that it can easily be reused in different projects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    that will be presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over the steps required in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage, we have defined our class and have given it a constructor. Run
    the next block of code to create your first instance of this class and to inspect
    its `name` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will access the attribute from the `cpx` library
    that will indicate whether the push button was pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following block of code while holding down push button A. It should
    show the state of the push button as `pressed`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file, and, when executed,
    it will repeatedly print a message whenever push button A is pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That's it for the coding part; now, let's see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ButtonEvent` class is defined to help us keep track of button presses with
    either push button A or push button B. When you instantiate the class, it expects
    one argument, which specifies the name of the button we are tracking. The name
    is saved to an attribute on the instance called `name`, and then the last variable
    is initialized with the value `False`. This variable will keep track of the last
    known value of the button state each time we check for a new event.
  prefs: []
  type: TYPE_NORMAL
- en: The `is_pressed` method is called each time we want to check whether a new button
    press event has occurred since the last time we checked. It first retrieves the
    current state of the physical push button, to find out whether it is pushed down.
    We check the value with its last known value to calculate whether a change has
    occurred; we keep this result in a variable called `changed`. We then save the
    current value for future reference. The method will then return a `True` value
    if the button state has changed and if it is currently being pushed down.
  prefs: []
  type: TYPE_NORMAL
- en: After the class definition, we create one instance of this class that will keep
    track of push button A. Then, an infinite loop is started that keeps checking
    for new button press events and prints a message each time one of them is detected.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we used the class once, to keep track of a single button; but
    because we haven't hardcoded any specific button values in the class definition
    itself, we can reuse this code to keep track of a number of different buttons.
    We can just as easily watch both push buttons for button press events. Many MicroPython
    boards let you attach many extra push buttons. This approach of making a generic
    class to watch buttons can be very useful in these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a bit of logic involved in keeping track of the previous button
    state, so that we can detect what we are interested in, which is new button press
    events. By keeping all this code in one contained class, we can make our code
    more readable and more manageable.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation for creating classes in Python can be found at [https://docs.python.org/3/tutorial/classes.html](https://docs.python.org/3/tutorial/classes.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the built-in `getattr` function can be found at [https://docs.python.org/3/library/functions.html#getattr](https://docs.python.org/3/library/functions.html#getattr).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own Python modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to take the code you create and put it into
    its own Python modules. We will take the code from the previous recipe, which
    helped us track button press events, and place it into its own dedicated module.
  prefs: []
  type: TYPE_NORMAL
- en: We will then import this newly created module into our main Python script and
    use its class definition to track button presses. This can be a very useful approach
    when you start working on large projects and want to split up your code into different
    modules. It can also be helpful when you find a useful module that you would like
    to incorporate into your own project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over the steps required for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code should be put into a new file called `button.py`; this will
    become the Python module that we can import in later steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage, we have been able to import a class from our new Python module.
    The next line of code will create a new object that we can use to detect new button
    press events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following block of code while you hold down push button A, and it should
    detect a button press event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file and, when executed,
    it will repeatedly print a message whenever push button A is pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our previous recipes, we got accustomed to working with the `main.py` file.
    Creating a new Python module is as simple as creating a new file and placing our
    code in it. We have taken the `ButtonEvent` class and placed it into its own Python
    module, called `button`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can import the class and create objects using that class. The rest of
    the code creates an object to monitor button presses and prints a message whenever
    they are detected.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you create your own custom Python module, it is important to be mindful
    of the name you give the module. The same naming restrictions for any Python module
    also apply to your MicroPython code. For example, you can't create a module that
    has space characters in it. You should also make sure not to name your module
    the same name as an existing MicroPython or CircuitPython module. Hence, you shouldn't
    call your module `board` or `math`, as these names are already taken.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to prevent this is by going into the REPL before you create
    your new module and trying to import a module by that name. If you get an `ImportError`,
    then you know that name is not in use.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation for creating Python modules can be found at [https://docs.python.org/3/tutorial/modules.html](https://docs.python.org/3/tutorial/modules.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A discussion on the benefits of using Python modules can be found at [https://realpython.com/python-modules-packages/](https://realpython.com/python-modules-packages/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding button interactions to the event loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will start to build our main event loop. Each player will
    be assigned a single push button to press during the game. Player 1 will be assigned
    push button A, and player 2 will be assigned push button B. The event loop will
    continually check each of these buttons, looking for new button press events. When
    a new push button event is detected, it will print a message.
  prefs: []
  type: TYPE_NORMAL
- en: This will be further expanded in the next recipes in this chapter, in order
    to add the rest of the Button Bash game's functionality. Event loops can be found
    in many types of software applications. Exploring their usage can help you whenever
    you have to make your own, or when you have to interact with a built-in event
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over the steps required for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the next block of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage, we have created two objects to monitor the two push buttons.
    Hold down push button A while you run the next block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file and, when executed,
    it will repeatedly print a message whenever push button A or push button B is
    pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, the `ButtonEvent` class is imported from the `button` module.
    A function called `main` is defined, which will contain the code for our main
    event loop. The last line of code calls the `main` function to start the execution
    of the main event loop. The main event loop first defines a dictionary that keeps
    track of each player's push button. It defines a mapping that player 1 will be
    assigned push button A and player 2 will be assigned push button B.
  prefs: []
  type: TYPE_NORMAL
- en: An infinite loop is started, which will loop through each of the `ButtonEvent`
    objects and check if a button press event has occurred. If a button press is detected,
    it will then print which player pressed a button.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As your code gets bigger, it's a good idea to put your main block of code into
    its own function, which you can call to start execution. As your program grows
    in size, it will make it easier to keep track of variables, as they will all be
    in the scope of this main function, instead of residing in the global namespace.
    This helps to reduce some ugly bugs that can appear with large blocks of code
    all sharing the same big global namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note in this recipe is the use of a dictionary to maintain
    the association of players and their buttons. The dictionary data structure is
    a very natural choice for this type of requirement. If we were using hardware
    that had more push buttons, we could just keep adding an item for each player
    to our data structure. It's always a good idea to make good use of data structures
    in your code; it makes debugging and software design much easier.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `tkinter` library that makes use of an event loop to respond
    to button press events can be found at [https://docs.python.org/3/library/tkinter.html#a-simple-hello-world-program](https://docs.python.org/3/library/tkinter.html#a-simple-hello-world-program).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A discussion on the main event loop of `tkinter` can be found at [https://gordonlesti.com/use-tkinter-without-mainloop/](https://gordonlesti.com/use-tkinter-without-mainloop/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a generator to get pixel colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will prepare the code that will be used to control the pixels
    in the game. There are 10 pixels on the board, so each player will be given 5,
    to indicate how many points they have so far. Now, each player gets a point each
    time they press their button and a score of 20 is needed to win the game. So,
    we have to present a score of 0 to 20, but with only 5 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: The way we will do that is to have the score on each pixel be represented by
    four colors. So, for the first four points, the first pixel would go through the
    colors yellow, dark orange, red, and magenta. Then, when you reach the score 5,
    the second pixel would light up yellow and go through the same cycle.
  prefs: []
  type: TYPE_NORMAL
- en: A generator will be used to get the list of colors and pixel positions that
    relate to each score for each player. Player 1 will use push button A and will
    have the five pixels next to this push button. These are pixels 0 to 4\. Player
    2 will use push button B and will have the five pixels next to that push button.
    These are pixels 5 to 9.
  prefs: []
  type: TYPE_NORMAL
- en: Both sets of pixels will start lighting up near the USB connector and will race
    towards the finish line, which will be the JST battery input. This makes the sequence
    0 to 4 for player 1 and 9 to 5 for player 2\. This recipe will cover an interesting
    use case for generators, which can come in handy in some projects, when you need
    to generate a sequence of values based on some involved logic.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over the steps required for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the REPL to run the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage, the first pixel should be lit up with the color yellow. In the
    next block of code, we will define the generator and call it to generate the list
    of positions and colors for both player 1 and player 2\. There are 21 items in
    the list. The first item, which represents score 0, is a special case where we
    want all the pixels to be off if no one has scored any points yet. The remaining
    20 items represent the scores 1 to 20:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `colors.py` file and can then be
    imported in the next recipes, in order to access the color data for the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, the `SEQUENCE` list represents the four colors that will be shown
    on each pixel to represent the player's score. The position and order of the five
    pixels that will be lit up for each player is then defined. The `generate_colors`
    generator is then defined. When called, it will produce a sequence of tuples,
    each containing the position and color of a specific score representation. This
    will be converted into a list for each player.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, we can take any score and immediately look up its associated color
    and pixel position. These colors and position values for each player and each
    score are stored in a dictionary called `COLORS` that can be used to look up these
    values by player, number, and score.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python **iterators** are a very powerful feature of the language. Generators
    are a type of iterator that let you implement some powerful solutions in a concise
    way. They are used in this recipe as a way to assist in building a list that has
    a special first case and two levels of nesting for the remaining values.
  prefs: []
  type: TYPE_NORMAL
- en: By putting all this logic in a generator, we can contain it in one place and
    then use it as a building block to make more complicated structures. In the case
    of this recipe, the single generator is being used to build the color lookup data
    for player 1 and player 2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on iterators can be found at [https://docs.python.org/3/tutorial/classes.html#iterators](https://docs.python.org/3/tutorial/classes.html#iterators).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on generators can be found at [https://docs.python.org/3/tutorial/classes.html#generators](https://docs.python.org/3/tutorial/classes.html#generators).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing scores with the ScoreBoard class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will prepare the code that will be used to keep track of
    each player's score and show their current score on the pixels. We will create
    a new class called `ScoreBoard` and put it into a new module called `score`.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you one way to implement a scoreboard functionality in
    a MicroPython-based game. This recipe will start with the initial logic of starting
    the game, keeping track of the score and then displaying the score on the pixels.
    In the next recipes, we will add more functionality to deal with incrementing
    the score and detecting when one of the players has won the game.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over the steps required for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: After running the previous code, you should hear the board play the game startup
    audio, which says `1 2 3 Go!`. Then, you should see the current score of player
    1 as the value `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code should be put into the `score.py` file, and then we can
    import it and use it elsewhere:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will import the `ScoreBoard` class from the `score` module,
    set the score of the first player to the value `3`, and then show this score on
    the pixels. The first pixel should turn on with the color red:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ScoreBoard` class is defined in the `score` module. When the class is first
    instantiated, it prepares the board to start a match of the game. It initializes
    the scores for players 1 and 2 to 0\. Then, it sets the brightness of the pixels
    and plays the audio clip to announce the start of the match to the players.
  prefs: []
  type: TYPE_NORMAL
- en: The `show` method expects one argument, which will be the number of the player
    to show the score for. Then, it gets the value of the player's score and uses
    it with the player number to look up the color and position of the pixel that
    must be set. This pixel then has its color set to the correct color.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have started to build the logic for showing the current scoreboard to our
    players. It's important to make a fun and responsive scoreboard in competitive
    games in which you want to keep the two players engaged in trying to beat one
    another.
  prefs: []
  type: TYPE_NORMAL
- en: The code to update the scoreboard has to be implemented in a fashion that performs
    well. If each update to the scoreboard is a sluggish process, the players will
    feel it and get frustrated at an application that doesn't feel responsive. All
    the code to get the color and position of the pixel to set is implemented in an
    efficient fashion to ensure its performance.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: An example of a MicroPython project that shows the scores of players in a game
    can be found at [https://tinkercademy.com/tutorials/flappy-bird/](https://tinkercademy.com/tutorials/flappy-bird/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of a battery operated MicroPython project to control NeoPixels can
    be found at [https://learn.adafruit.com/neopixel-coat-buttons](https://learn.adafruit.com/neopixel-coat-buttons).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting winners with the ScoreBoard class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will extend the `ScoreBoard` class to be able to update player
    scores and to detect when a player has won the game. Once one of the players has
    won the game, the board will announce which player has won the game by playing
    an audio clip with the announcement.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is the last piece to complete the logic in the `ScoreBoard` class.
    Once it's completed, we can combine it into the main event loop and complete the
    game in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over the steps required for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code should be put into the `score.py` file, and then we can
    import it and use it elsewhere:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will import the `ScoreBoard` class from the `score` module
    and print out the current scores of the players:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The next block of code will increment the score of player 1, causing the first
    pixel to light up yellow, and then print out the current score. The score should
    show that player 1 has a score of 1 point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ScoreBoard` class has an additional method added to it that will increment
    in the `score` data structure whenever one of the players has scored. The `scored`
    method receives one argument, the player number, and increments that player's
    score.
  prefs: []
  type: TYPE_NORMAL
- en: It then updates the pixels to show the latest score of the player, and then
    checks whether the player's score has reached 20 points. If the player has reached
    20 points, the board will then play an announcement announcing which player has
    won the game.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sound and light are a great way to interact with players in video games. Sound
    is used effectively in this class to both announce the start of the game and to
    announce its end. During the game play, light is used to motivate each player
    to bash their buttons faster, so that they can be the first to reach the finish
    line. Even though a lot is going on in this class, each method is only three to
    four lines long, making it easier to see what each piece is involved in. This
    is one way of breaking your code up into smaller chunks, by putting the different
    parts into different methods.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: A multiplayer game that uses Circuit Playground Express can be found at [https://learn.adafruit.com/circuit-playground-express-ir-zombie-game/](https://learn.adafruit.com/circuit-playground-express-ir-zombie-game/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A game implemented in CircuitPython can be found at [https://learn.adafruit.com/circuit-playground-treasure-hunt/](https://learn.adafruit.com/circuit-playground-treasure-hunt/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the ScoreBoard class to the event loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This final recipe of this chapter combines all the previous recipes in this
    chapter to create the final Button Bash game. We will upgrade the event loop by
    adding the `ScoreBoard` class that we implemented in the previous recipe. This
    is the last piece of the puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: The final result is a main loop with only six lines of code. We have been able
    to achieve this result by keeping a lot of the game logic in each of the three
    Python modules created in this chapter. You can use a similar approach in your
    own projects when you find the code base has become too big and concentrated in
    one file or one function.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over the steps required for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code should be put into the `main.py` file, and then you can
    start to play the Button Bash game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you have one of the portable power supplies mentioned at the start of this
    chapter, then you can disconnect the board from your computer and connect that
    power supply.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now take the game anywhere you like and play rounds between each player.
    To start the next match, press the reset button at the center of the board for
    a new round to begin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We first import the `ButtonEvent` and `ScoreBoard` objects; they are the two
    main objects that we will need to implement the remainder of the event loop. After
    we have created our button dictionary, we instantiate a new `ScoreBoard` object
    called `board`.
  prefs: []
  type: TYPE_NORMAL
- en: This will announce that the game has started, and then we will enter into the
    infinite loop that will keep checking for button press events. The moment one
    of these events is detected, it will call the `scored` method on the board object
    to increment that specific player's score. If any player has reached the final
    score, they will then be announced as the winner.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the basic version of the game working, there are many ways
    to change it and enhance it. We could create two modes of the game that can be
    selected with the slide switch. There could be an easy and hard mode, where one
    needs a score of 10 and the other needs 20\. When the board starts up, it checks
    the switch to load the correct parameters for colors and the final score.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could make a best of three mode, where the two players have to fight it
    out repeatedly for three rounds, and the one who gets the best of three wins.
    To see the game in action, take a look at the next photograph to see two players
    intensely battling away at Button Bash:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ff90c627-9968-4182-86ba-a0db4426b75f.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: A battery powered portable CircuitPython project that uses the NeoPixels can
    be found at [https://learn.adafruit.com/ufo-circuit-playground-express](https://learn.adafruit.com/ufo-circuit-playground-express).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basketball hoop game that uses the NeoPixels can be found at [https://learn.adafruit.com/neopixel-mini-basketball-hoop](https://learn.adafruit.com/neopixel-mini-basketball-hoop).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
