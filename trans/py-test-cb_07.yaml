- en: Measuring Your Success with Test Coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a network management application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and running coverage on your test suite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating an HTML report using coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating an XML report using coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting nosy with coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering out test noise from coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Letting Jenkins get nosy with coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the project-level script to provide coverage reports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Coverage** **analysis** is measuring which lines in a program are run and
    which lines aren''t. This type of analysis is also known as **code coverage**,
    or more simply **coverage**.'
  prefs: []
  type: TYPE_NORMAL
- en: A coverage analyzer can be used while running a system in production, but what
    are the pros and cons of this? What about using a coverage analyzer when running
    test suites? What benefits would this approach provide compared to checking systems
    in production?
  prefs: []
  type: TYPE_NORMAL
- en: Coverage helps us to see whether we are adequately testing our system. But it
    must be performed with a certain amount of skepticism. This is because, even if
    we achieve 100% coverage, meaning every line of our system was run, in no way
    does this guarantee us having no bugs. Testing can only uncover the presence of
    bugs. A quick example involves code we have written, and what it processes is
    the return value from a system call. What if there are three possible values,
    but we only handle two of them? We may write two test cases covering our handling
    of it, and this could certainly achieve 100% statement coverage. However, it doesn't
    mean we have handled the third possible return value, thus leaving us with a potentially
    undiscovered bug. 100% code coverage can also be obtained by condition coverage,
    but may not be achieved with statement coverage. The kind of coverage we are planning
    to target should be clear.
  prefs: []
  type: TYPE_NORMAL
- en: Another key point is that not all testing is aimed at fixing bugs. Another key
    purpose is to make sure that the application meets our customer's needs. This
    means that, even if we have 100% code coverage, we can't guarantee that we are
    covering all the scenarios expected by our users. This is the difference between
    *building it right* and *building the right thing*.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore various recipes to build a network management
    application, run coverage tools, and harvest the results. We will discuss how
    coverage can introduce noise and show us more than we need to know, and we'll introduce
    performance issues when it implements our code. We will also see how to trim out
    information we don't need to get a concise, targeted view of things.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter uses several third-party tools in many recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring Python** ([http://springpython.webfactional.com](http://springpython.webfactional.com))
    contains many useful abstractions. The one used in this chapter is its `DatabaseTemplate`,
    which provides easy ways to write SQL queries and updates without having to deal
    with Python''s verbose API. Install it by typing `pip install springpython`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the coverage tool by typing `pip install coverage`. This may fail because
    other plugins may install an older version of coverage. If so, uninstall coverage
    by typing `pip uninstall coverage`, and then install it again with `pip install
    coverage`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nose, a useful test runner, is covered in [Chapter 2](part0083.html#2F4UM0-dd965cfd3480473da68e719fadb0727c),
    *Running Automated Test Suites with Nose*. Refer to that chapter to see how to
    install nose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a network management application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we will build a very simple network management application,
    write different types of test, and check their coverage. This network management
    application is focused on digesting alarms, also referred to as **network** **events**.
    This is different from certain other network management tools that focus on gathering
    SNMP alarms from devices.
  prefs: []
  type: TYPE_NORMAL
- en: For reasons of simplicity, this correlation engine doesn't contain complex rules,
    but instead contains a simple mapping of network events onto equipment and customer
    service inventory. We'll explore this in the next few paragraphs as we dig through
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the following steps, we will build a simple network management application:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `network.py` to store the network application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a class definition to represent a network event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at few properties of `self`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hostname`: It is assumed that all network alarms originate from pieces of
    equipment that have a hostname.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`condition`: This indicates the type of alarm being generated. Two different
    alarm conditions can come from the same device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`severity`: `1` indicates a clear, green status, and `5` indicates a faulty,
    red status.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id`: This is the primary key value used when the event is stored in a database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new file called `network.sql` to contain the SQL code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a SQL script that sets up the database and adds the definition for storing
    network events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Code a high-level algorithm where events are assessed for their impact on equipment
    and customer services, and add it to `network.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `init` method contains some setup code for creating a `DatabaseTemplate`.
    This is a Spring Python utility class used for database operations. See [https://docs.spring.io/spring-python/1.2.x/sphinx/html/dao.html](https://docs.spring.io/spring-python/1.2.x/sphinx/html/dao.html)
    for more details. We are also using *SQLite3* as our database engine, since it
    is a standard part of Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process method contains some simple steps to process an incoming event:'
  prefs: []
  type: TYPE_NORMAL
- en: We first need to store the event in the `EVENTS` table. This includes evaluating
    whether or not it is an active event, meaning that it is actively impacting a
    piece of equipment.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we determine what equipment and what services the event impacts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we update the affected service by determining whether it causes any service
    outages or restorations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we update the affected equipment by determining whether it fails or clears
    a device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we return a tuple containing all the affected assets to support any
    screen interfaces that could be developed on top of this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implement the `store_event` algorithm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This method stores every event that is processed. This supports many things,
    including data mining and the post-mortem analysis of outages. It is also the
    authoritative place where other event-related data can point back using a foreign
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: The `store_event` method looks up the maximum primary key value from the `EVENTS`
    table.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: It increments it by `1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It assigns it to `event.id`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then inserts it into the `EVENTS` table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, it calls a method to evaluate whether or not the event should be added
    to the list of active events, or if it clears out existing active events. Active
    events are events that are actively causing a piece of equipment to be unclear.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it returns a tuple containing the event and whether or not it was classified
    as an active event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a more sophisticated system, some sort of partitioning solution needs to
    be implemented. Querying against a table containing millions of rows is very inefficient.
    However, this is for demonstration purposes only, so we will skip scaling as well
    as performance and security.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement a method to evaluate whether to add or remove active events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When a device fails, it sends a `severity 5` event. This is an active event,
    and in this method a row is inserted into the `ACTIVE_EVENTS` table with a foreign
    key pointing back to the `EVENTS` table. Then we return `True`, indicating that
    this is an active event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the table definition for `ACTIVE_EVENTS` to the SQL script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This table makes it easy to query what events are currently causing equipment
    failures.
  prefs: []
  type: TYPE_NORMAL
- en: Later, when the failing condition on the device clears, it sends a `severity
    1` event. This means that `severity 1` events are never active, since they aren't
    contributing  to a piece of equipment being down. In our previous method, we search
    for any active events that have the same hostname and condition, and delete them.
    Then we return `False`, indicating this is not an active event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a method that evaluates the services and pieces of equipment that are
    affected by the network event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We first query the `EQUIPMENT` table to see if `event.hostname` matches anything.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we join the `SERVICE` table to the `EQUIPMENT` table through a many-to-many
    relationship tracked by the `SERVICE_MAPPING` table. Any service that is related
    to the equipment that the event was reported on is captured.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we return a tuple containing both the list of equipment and list of
    services that are potentially impacted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Python provides a convenient query operation that returns a list of objects
    mapped to every row of the query. It also provides an out-of-the-box `DictionaryRowMapper`
    that converts each row into a Python dictionary, with the keys matching the column
    names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the table definitions to the SQL script for `EQUIPMENT`, `SERVICE`, and `SERVICE_MAPPING`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the `update_service` method, which stores or clears service-related events
    and then updates the service''s status based on the remaining active events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Service-related events are active events related to a service. A single event
    can be related to many services. For example, what if we were monitoring a wireless
    router that provided internet service to a lot of users, and it reported a critical
    error? This one event would be mapped as an impact to all the end users. When
    a new active event is processed, it is stored in `SERVICE_EVENTS` for each related
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Then, when a clearing event is processed, the previous service event must be
    deleted from the `SERVICE_EVENTS` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the table definition for `SERVICE_EVENTS` to the SQL script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It is important to recognize that deleting an entry from `SERVICE_EVENTS` doesn't
    mean that we delete the original event from the `EVENTS` table. Instead, we are
    merely indicating that the original active event is no longer active and it does
    not impact the related service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepend the entire SQL script with `DROP` statements, making it possible to
    run the script for several recipes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Append the SQL script used to set up the database with inserts to pre-load
    some equipment and services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, write a method that updates the equipment status based on the currently
    active events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we need to find the maximum severity from the list of active events for
    a given host name. If there are no active events, then Spring Python raises a
    DataAccessException and we translate that to a severity of 1.
  prefs: []
  type: TYPE_NORMAL
- en: We check whether this is different from the existing device's status. If so,
    we issue a SQL update. Finally, we return the record for the device, with its
    status updated appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This application uses a database-backed mechanism to process incoming network
    events, and checks them against the inventory of equipment and services to evaluate
    failures and restorations. Our application doesn't handle specialized devices
    or unusual types of service. This real-world complexity has been traded in for
    a relatively simple application that can be used to write various test recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Events typically map to a single piece of equipment and to zero or more services.
    A service can be thought of as a string of equipment used to provide a type of
    service to the customer. New failing events are considered active until a clearing
    event arrives. Active events, when aggregated against a piece of equipment, define
    its current status. Active events, when aggregated against a service, define the
    service's current status.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and running coverage on your test suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Install the coverage tool and run it against your test suite. Then you can view
    a report showing what lines were covered by the test suite.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the following steps, we will build some unittests and then run them through
    the coverage tool:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `recipe52.py` to contain our test code for this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a simple unit test that injects a single, alarming event into the system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Clear out any existing coverage report data using `coverage -e`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the test suite using the coverage tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Print out the report captured by the previous command by typing `coverage -r`.
    If the report shows several other modules listed from Python''s standard libraries,
    it''s a hint that you have an older version of the coverage tool installed. If
    so, uninstall the old version by typing `pip uninstall coverage` followed by reinstalling
    with `pip install coverage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00122.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Create another file called `recipe52b.py` to contain a different test suite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write another test suite that generates two faults and then clears them out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Run this test suite through the coverage tool using `coverage -x recipe52b.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Print out the report by typing `coverage -r`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00123.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The first test suite only injects a single alarm. We expect it to cause a service
    outage and take its related piece of equipment down. Since this would *not* exercise
    any event clearing logic, we certainly don't expect 100% code coverage.
  prefs: []
  type: TYPE_NORMAL
- en: In the report, we can see that it says `network.py` had 65 statements, and has
    executed 55 of them, resulting in 85% coverage. We also see that `recipe52.py`
    had 23 statements and executed all of them. This means all of our test code ran.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we realize that we are only testing the alarming part of the
    event correlator. To make this more effective, we should inject another alarm,
    followed by a couple of clears to make sure that everything clears out and the
    services return to operational status. This should result in 100% coverage in
    our simple application.
  prefs: []
  type: TYPE_NORMAL
- en: The second screenshot indeed shows that we have reached full coverage of `network.py`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We also see Spring Python reported as well. If we had used any other third-party
    libraries, then they would also appear. Is this right? It depends. The previous
    comments seem to indicate that we don't really care about coverage of Spring Python,
    but in other situations, we might be very interested. And how can the coverage
    tool know where to draw the line?
  prefs: []
  type: TYPE_NORMAL
- en: In later recipes, we will look into how to be more selective of what to measure
    so we can filter out the noise.
  prefs: []
  type: TYPE_NORMAL
- en: Why are there no asserts in unittest?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is true that unittest isn't adequate with regard to testing outcomes. To
    draw up this recipe, I visually inspected the output to see whether the network
    management application was performing as expected. But this is incomplete. A real
    production grade unit test needs to finish this with a set of assertions so that
    visual scanning is not needed.
  prefs: []
  type: TYPE_NORMAL
- en: So why didn't we code any? Because the focus of this recipe was on how to generate
    a coverage report and then use that information to enhance the testing. We covered
    both of these things. By thinking about what was and wasn't tested, we wrote a
    comprehensive test that shows services going into outage and back to operational
    status. We just didn't just confirm this automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Generating an HTML report using coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the coverage tool, generate an HTML visual coverage report. This is useful
    because we can drill into the source code and see what lines did not run in the
    test procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a coverage report without reading the source code is not very useful.
    It may be tempting to compare two different projects based on the coverage percentages.
    But unless the actual code is analyzed, this type of comparison can lead to faulty
    conclusions about the quality of the software.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With these steps, we will explore creating a nicely viewable HTML coverage
    report:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate coverage metrics by following the steps in the *Installing and running
    coverage* *on your test suite* recipe and only running the first test suite (which
    resulted in less than 100% coverage).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate an HTML report by typing `coverage.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `htmlcov/index.html` using your favorite browser and inspect the overall
    report:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00124.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on network, and scroll down to see where the event clearing logic didn''t
    run due to no clearing events being processed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00125.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The coverage tool has a built-in feature to generate an HTML report. This provides
    a powerful way to visually inspect the source code and see which lines were not
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: By looking at this report, we can clearly see that the lines that were not executed
    relate to the lack of clearing network events that are being processed. This tips
    us off about another test case, which involves clearing events that need to be
    drafted.
  prefs: []
  type: TYPE_NORMAL
- en: Generating an XML report using coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The coverage tool can generate an XML coverage report in Cobertura format ([http://cobertura.sourceforge.net/](http://cobertura.sourceforge.net/)).
    This is useful if we want to process the coverage information in another tool.
    In this recipe, we will see how to use the coverage command-line tool, and then
    view the XML report by hand.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to understand that reading a coverage report without reading
    the source code   is not very useful. It may be tempting to compare two different
    projects based on the coverage percentages. But unless the actual code is analyzed,
    this type of comparison can lead to  faulty conclusions about the quality of the
    software.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a project with 85% coverage may appear, on the surface, to be better
    tested than one with 60%. However, if the 60% application has much more thoroughly
    exhaustive scenarios—as they are only covering the core parts of the system that
    are in heavy use—then it may be much more stable than the 85% application.
  prefs: []
  type: TYPE_NORMAL
- en: Coverage analysis serves a useful purpose when comparing test results between
    iterations, and when we use it to decide which scenarios need to be added to our
    testing repertoire.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With these steps, we will discover how to create an XML report that is consumable
    by other tools, using the coverage tool:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate coverage metrics by following the steps in *Installing and running
    coverage* *on your test suite* recipe (mentioned in [Chapter 1](part0025.html#NQU20-dd965cfd3480473da68e719fadb0727c),
    *Using Unittest to Develop Basic* *Tests*) and only running the first test suite
    (which resulted in less than 100% coverage).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate an XML report by typing `coverage xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `coverage.xml` using your favorite text or XML editor. The format of the
    XML is the same as Cobertura—a Java code coverage analyzer. This means that many
    tools, such as Jenkins, can parse the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00126.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The coverage tool has a built-in feature that generates an XML report. This
    provides a powerful way to parse the output using some type of external tool.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous screenshot, I opened it using Spring Tool Suite (you can download
    it from [http://www.springsource.com/developer/sts)](http://www.springsource.com/developer/sts)),
    partly because I happen to use STS every day, but you can use any text or XML
    editor you like.
  prefs: []
  type: TYPE_NORMAL
- en: What use is an XML report?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XML is not the best way to communicate coverage information to users. *Generating
    an HTML* *report with coverage* is a more practical recipe when it comes to human
    users.
  prefs: []
  type: TYPE_NORMAL
- en: What if we want to capture a coverage report and publish it inside a continuous
    integration system such as Jenkins? All we need to do is install the Cobertura
    plugin (refer to [https://wiki.jenkins-ci.org/display/JENKINS/Cobertura+Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Cobertura+Plugin)),
    and this report becomes traceable. Jenkins can nicely monitor trends in coverage
    and give us more feedback as we develop our system.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Letting Jenkins get nosy with coverage*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Generating an HTML report using coverage*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting nosy with coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Install the coverage nose plugin, and run your test suite using nose. This provides
    a quick and convenient report using the ubiquitous nosetests tool. This recipe
    assumes you have already created the network management application as described
    in the *Building a network* *management application* section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With these steps, we will see how to combine the coverage tool with nose:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `recipe55.py` to store our test code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a test case that injects a faulty alarm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test module using the coverage plugin by typing `nosetests recipe55
    – with-coverage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00127.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The nose plugin for coverage invokes the coverage tool and provides a formatted
    report. For each module, it displays the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Total number of statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of missed statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Percentage of covered statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line numbers for the missed statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common behavior of nose is to alter `stdout`, disabling the `print` statements
    embedded in the test case.
  prefs: []
  type: TYPE_NORMAL
- en: Why use the nose plugin instead of the coverage tool directly?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The coverage tool works fine by itself, as was demonstrated in other recipes
    in this chapter. However, nose is a ubiquitous testing tool used by many developers.
    Providing a plugin makes it easy to support this vast community by empowering
    users to run the exact set of test plugins they want, with coverage being part
    of that test complement.
  prefs: []
  type: TYPE_NORMAL
- en: Why are SQLite3 and Spring Python included?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLite3 is a relational database library that is included with Python. It is
    file-based, which means that no separate processes are required to create and
    use a database. Details about Spring Python can be found in the earlier sections
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this recipe was to measure the coverage of our network management
    application and the corresponding test case. So why are these third-party libraries
    included? The coverage tool has no way of automatically knowing what we want and
    the things we don't want to see from a coverage perspective. To delve into this,
    refer to the next section, *Filtering out* *test noise from coverage*.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering out test noise from coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using command-line options, you can filter out counted lines. This recipe assumes
    you have already created the network management application as described in the
    *Building a network* *management application* section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With these steps, we will see how to filter out certain modules from being
    counted in our coverage report:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a test suite that exercises all the code functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Clear out any previous coverage data by running `coverage -e`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run it using `coverage -x recipe56.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Generate a console report using `coverage -r`. In the following screenshot,
    observe how Spring Python is included in the report and reduces the total metric
    to 73%:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00128.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Clean out coverage data by running `coverage -e`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the test again using `coverage run –source network.py,recipe56.py,recipe56.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Generate another console report using `coverage -r`. Notice in the next screenshot
    how Spring Python is no longer listed, bringing our total coverage back up to
    100%:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00129.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Clean out coverage data by running `coverage -e`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the test using `coverage -x recipe56.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Generate a console report using `coverage -r recipe56.py network.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00130.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coverage provides the ability to decide which files will be analyzed and what
    files will be reported. The steps in the previous section gather metrics several
    times, either by running coverage with a restricted set of source files (in order
    to filter out Spring Python), or by requesting an explicit set of modules in the
    report.
  prefs: []
  type: TYPE_NORMAL
- en: One question that arises from all this is, *What's the best choice?* For our
    test scenario, the two choices were equivalent. With approximately the same amount
    of typing, we filtered out Spring Python and got a report showing `network.py`
    and `recipe56.py` with 100% coverage either way. However, a real project with
    a lot of modules and possibly different teams working in different areas would
    probably do better by gathering all the metric data available and filtering at
    the report level.
  prefs: []
  type: TYPE_NORMAL
- en: This way, different reports on subsystems can be run as needed without having
    to keep recapturing metric data, and an overall report can still be run for the
    whole system coverage, all from the same gathered data.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The options used in the previous section were inclusive. We picked what was
    to be included. The coverage tool also comes with an `–omit` option. The challenge
    is that it's a file-based option, not module-based. It doesn't work to use `–omit
    springpython`. Instead, every file must be specified, and in this case that would
    have required four complete files to exclude it all.
  prefs: []
  type: TYPE_NORMAL
- en: To further complicate this, the full paths for the Spring Python files need
    to be included. This results in a very lengthy command, not providing much of
    a benefit over the ways we demonstrated.
  prefs: []
  type: TYPE_NORMAL
- en: In other situations, if the file to be excluded is local to where coverage is
    being run, then it might be more practical.
  prefs: []
  type: TYPE_NORMAL
- en: The coverage tool has other options not covered in this chapter, such as measuring
    branch coverage instead of statement coverage, excluding lines, and the ability
    to run in parallel to manage collecting metrics from multiple processes.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, the coverage tool has the ability to filter out individual
    lines. In my opinion, this sounds very much like trying to get the coverage report
    to meet some mandated percentage. The coverage tool is best used to work towards
    writing more comprehensive tests, fixing bugs, and improving development, and
    not towards building a better report.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Building a network management application* recipe earlier in the chapter
  prefs: []
  type: TYPE_NORMAL
- en: Letting Jenkins get nosy with coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configure Jenkins to run a test suite using nose, generating a coverage report.
    This recipe assumes you have already created the network management application
    as described in the *Building a network management application* section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If you have already downloaded Jenkins and used it for previous recipes, look
    for a `.jenkins` folder in your home directory and delete it, to avoid unexpected
    variances caused by this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Jenkins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the console to confirm that Jenkins is working:![](../images/00131.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Manage Jenkins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Manage Plugins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Available tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `Cobertura Plugin` and click the checkbox next to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `Git Plugin` and click the checkbox next to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the bottom of the page, click on the Install button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate back to the dashboard screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Shut down Jenkins and start it again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Git source code control on your machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an empty folder for this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the folder for source code maintenance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the network application and SQL script into the folder, add it, and commit
    the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With these steps, we will explore how to configure Jenkins to build a coverage
    report and serve it through Jenkins' interface.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `recipe57.py` to contain our test code for this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a test case that partially exercises the network management application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy it into the source code repository. Add it and commit the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Open the Jenkins console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on New Job.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `recipe57` as the Job Name and pick Build a free-style software project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Ok**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Source Code Management** section, select **Git**. For **URL**, enter
    `/tmp/ recipe57/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Build Triggers section, pick **Poll** **SCM** and enter `* * * * *` into
    the schedule box in order to trigger a poll once a minute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Build section, select **Execute** **Shell** and enter the following
    script, which loads virtualenv and runs the test suite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You need to include the step to activate your virtualenv and then run the coverage
    tool, as shown in the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: In the Post-build Actions section, pick **Publish Cobertura Coverage Report**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `coverage.xml` for **Cobertura xml report pattern**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Save** to store all job settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate back to the dashboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Enable Auto Refresh**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wait about a minute for the build job to run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00132.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on results (**#1** in the previous screenshot).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on **Coverage** **Report**. Observe the next screenshot where it reports
    89% coverage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00133.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on module `.` (dot) to see `network.py` and `recipe57.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on `recipe57.py` to see which lines were covered and which ones were missed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The coverage tool generates a useful XML file that the Jenkins Cobertura plugin
    can harvest. It's possible to just generate the HTML report and serve it up through
    Jenkins, but the XML file allows Jenkins to nicely chart the coverage trend. It
    also provides the means to drill-down and view the source code along with lines
    covered and missed.
  prefs: []
  type: TYPE_NORMAL
- en: We also integrated it with source control so that, as changes are committed
    to the repository, new jobs will be run.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's important not to get too wrapped up in coverage reports. The coverage tool
    is useful to track testing, but working purely to increase coverage doesn't guarantee
    building better code. It should be used as a tool to illuminate what test scenarios
    are missing instead of thinking about testing a missing line of code.
  prefs: []
  type: TYPE_NORMAL
- en: Nose doesn't directly support coverage's XML option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The nose plugin for the coverage tool doesn't include the ability to generate
    XML files. This is because the coverage plugin is part of nose and *not* part
    of the coverage project. It is not up to date with the latest features, including
    XML reports.
  prefs: []
  type: TYPE_NORMAL
- en: I asked Ned Batchelder, the creator of the coverage project, about this lack
    of XML support from nose. He recommended that I run `nosetests` inside `coverage`,
    as shown previously in the Jenkins job. It generates the same `.coverage` trace
    data file. It is easy to then execute `coverage` `xml` with the required arguments
    in order to get our desired report. In fact, we can use any of coverage's reporting
    features at this stage. Unfortunately, the coverage tool needs the explicit path
    to `nosetests`, and running inside Jenkins requires the path to be spelled out.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the project-level script to provide coverage reports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Update the project-level script to generate HTML, XML, and console coverage
    reports as runnable options.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Install coverage by typing `pip install coverage`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the network management application described in the *Building a network*
    *management application* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With these steps, we will explore how to use coverage programmatically in a
    project management script:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `recipe58.py` to store this command-line script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a script that uses `getopt` to parse command-line arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a test function that uses coverage''s API to gather metrics and then generate
    a console report, an HTML report, and an XML report, while also using nose''s
    API to run the tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some other stubbed out functions to simulate packaging, publishing, and
    registering this project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Add code that processes command-line arguments and calls the functions defined
    earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script using the `--test` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00134.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the HTML report using your favorite browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00135.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Inspect `recipe58.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The coverage API is easy to use as shown in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the test method, we create a `coverage()` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to call the `start` method to begin tracing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to exercise the main code. In this case, we are using the nose
    API. We will use it to run the various recipes coded in this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to stop coverage from tracing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have gathered metrics, we can generate a console report, an HTML
    report, and an XML report:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first report is a console report. The second report is an HTML report written
    into the `recipe58` subdirectory. The third report is an XML report in Cobertura
    format written to `recipe58.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many more options to fine-tune gathering as well as reporting. Just
    visit the online documentation at [http://nedbatchelder.com/code/coverage/api.html](http://nedbatchelder.com/code/coverage/api.html)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Can we only use getopt?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python 2.7 introduced `argparse` as an alternative to `getopt`. The current
    documentation gives no indication that `getopt` is deprecated, so it's safe to
    use as we have just done. The `getopt` module is a nice, easy-to-use command-line
    parser.
  prefs: []
  type: TYPE_NORMAL
