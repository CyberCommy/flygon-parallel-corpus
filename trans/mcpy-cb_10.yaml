- en: Controlling the ESP8266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will introduce the Adafruit Feather HUZZAH ESP8266 microcontroller.
    The ESP8266 is one of the most popular MicroPython hardware options when your
    embedded project needs to have support for internet connectivity. This connectivity
    is achieved using the board's built-in Wi-Fi capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will explore two main ways to get REPL access on the board: through
    a USB connection, and also wireless over Wi-Fi. We will also look at a number
    of recipes that cover different aspects of interacting with the Wi-Fi features
    on the board.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned all the core skills necessary
    so that you can get productive with this board and start building your own embedded
    projects using this versatile and inexpensive piece of internet-connected hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the REPL over a serial connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning for available Wi-Fi networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring settings for AP mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to an existing Wi-Fi network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the WebREPL over Wi-Fi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transferring files with the WebREPL CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the blue and red LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter can be found in the `Chapter10` folder of this
    book's GitHub repository, available at [https://github.com/PacktPublishing/MicroPython-Cookbook](https://github.com/PacktPublishing/MicroPython-Cookbook).
  prefs: []
  type: TYPE_NORMAL
- en: CircuitPython 3.1.2 was used for all the recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Adafruit Feather HUZZAH ESP8266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ESP8266 is an inexpensive microcontroller that's manufactured by Espressif
    Systems. It can run MicroPython and supports a full TCP/IP stack. Its built-in
    Wi-Fi supports 802.11b/g/n. The Adafruit Feather HUZZAH ESP8266 is a development
    board that comes with USB support for power and data connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The processor on this board runs at 80 MHz and comes with 4 MB of flash storage.
    The board comes with nine GPIO pins that can be connected to a number of other
    components. The board comes in a number of different versions. The following photo
    shows what this board looks like with the headers option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/829cc862-59b3-4010-8e2e-3a9d44794a1f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The board also comes in a stacking header configuration that makes it possible
    to plug in additional components on top of the board, such as OLED displays and
    buttons. These upgrades can be plugged right in, without the need for soldering
    or breadboards. The following photo shows this version of the board, which has
    a stacking header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5467a9e0-0c89-4df8-a997-137d53bf4b15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also make your projects portable by powering the board with a rechargeable
    lithium ion polymer battery. These batteries can be connected to the board using
    its JST connector. The following photo shows a board connected to a lithium ion
    polymer battery:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9967247a-f240-4e06-856a-6713b3559ad4.png)'
  prefs: []
  type: TYPE_IMG
- en: The board has a built-in LiPoly charger, which can show the charging status
    using the indicator LED. The battery can then be charged whenever the board is
    connected with the USB cable.
  prefs: []
  type: TYPE_NORMAL
- en: Where can you buy these?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter uses the Adafruit Feather HUZZAH ESP8266 microcontroller. We recommend
    purchasing the version with a stacking header. The Adafruit Assembled Feather
    HUZZAH ESP8266 Wi-Fi microcontroller with stacking headers can be purchased directly
    from Adafruit ([https://www.adafruit.com/product/3213](https://www.adafruit.com/product/3213)).
  prefs: []
  type: TYPE_NORMAL
- en: Using the REPL over a serial connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to get REPL access to the ESP8266 using a serial
    connection over USB. Even though the real power and excitement of this board comes
    from connecting to it wirelessly, the first thing we need to do is connect to
    it with a simple USB connection. Once this connection is set up, then you can
    proceed with the remaining recipes in this chapter, which set up your wireless
    settings so that you can unplug the board and interact with it completely wirelessly.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will help you get started with your own wireless embedded projects
    by setting up that initial connectivity to the board in order to establish wireless
    connectivity. It is also a valuable tool when you have a configured board that
    is facing connectivity issues and you want to get access to it to debug whatever
    Wi-Fi issues you might be facing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Either macOS or a Linux computer can be used for this recipe, and you need the
    screen command to be available. On macOS, the screen application is built-in and
    thus requires no installation. On Ubuntu Linux, the screen command can be installed
    with the apt `install screen` command.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to use the REPL over a serial connection:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the ESP8266 to your computer using a USB cable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Terminal application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On most Linux systems, the name of the device should be `/dev/ttyUSB0`. Confirm
    that this device exists by running the following command in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command should run successfully if the ESP8266 was successfully
    detected by the operating system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command to start a REPL session with the board:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will start the `screen` command and connect to a device
    called `/dev/ttyUSB0` at a baud rate of 115,200 bits per second. If the connection
    was established successfully, you should see a message such as the following in
    the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the following code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding block of code will import the `math` library and calculate the
    value of 8 to the power of 2.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ESP8266 exposes a serial device over the USB connection. This serial device
    can then be interacted with using a Terminal emulator-like `screen`. Once the
    screen is connected, you can then gain access to the REPL and start executing
    Python code on the board. Whenever you execute Python code in the REPL, the commands
    are sent to the board to be executed, and then the results of the commands are
    transmitted back to the Terminal emulator over the serial connection.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many excellent free Terminal emulators available on all major operating
    systems. `picocom` and `minicom` are popular alternatives to screen on Unix systems.
    On Windows, the Terminal emulator PuTTY can be used, while macOS has an application
    called CoolTerm that can be used for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on connecting to Adafruit Feather HUZZAH ESP8266 can be found
    at [https://learn.adafruit.com/adafruit-feather-huzzah-esp8266](https://learn.adafruit.com/adafruit-feather-huzzah-esp8266).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details on the `picocom` command can be found at [https://github.com/npat-efault/picocom](https://github.com/npat-efault/picocom).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning for available Wi-Fi networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to use the ESP8266 to list all Wi-Fi networks
    that are available and can be connected to. We will introduce the MicroPython
    network library and explore how to use its objects to initialize the onboard Wi-Fi
    hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Once these components have been set up, we can use them to run a scan for wireless
    networks and store the results of that scan for further inspection. This recipe
    can provide you with useful techniques so that you can test the Wi-Fi capabilities
    of your board. Usually, listing wireless networks is the first step that's needed
    before you can proceed and connect to them later.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to scan for available Wi-Fi networks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The network library has now been imported and a WLAN object has been created,
    which will provide a `station` interface. The following block of code will activate
    the `station` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will scan for all available wireless networks and
    store the results in the `networks` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will output the contents of the `networks` variable
    and show how many networks were found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once executed, the code will extract the names of wireless networks and store
    them in a variable called `names`, which is then inspected.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MicroPython provides a module called `network` that can be used to interact
    with the Wi-Fi hardware on the ESP8266\. The WLAN object is instantiated and provided
    with `network.STA_IF` for its first argument. This will return an object that
    is created as a `station` interface.
  prefs: []
  type: TYPE_NORMAL
- en: The `station` interfaces are needed when you want to connect the board to existing
    Wi-Fi networks. Before a scan can be performed, the station must be activated
    by calling the `active` method with the `True` value. Then, the `scan` method
    can be called on the station, which will scan for available networks. This method
    returns a list of tuples that we store in the `networks` variable.
  prefs: []
  type: TYPE_NORMAL
- en: We can then count the number of networks using the `len` function and loop through
    this list of tuples to extract the name of each network. The name, or **Service
    Set Identifier** (**SSID**), of each network will be stored in the first value
    of the tuple. This value is retrieved from each item in the `networks` variable
    using list comprehension, which we then save in the `names` variable.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe created a WLAN object as a `station` interface. In later recipes,
    we will learn how to create another type of WLAN object that can be used to configure
    the device as an AP. Besides using the `scan` method to get the names of the wireless
    networks, you can also inspect other details about each network, such as the channel
    it uses and the authentication mode it accepts.
  prefs: []
  type: TYPE_NORMAL
- en: It's very helpful that the `scan` method returns its results as a simple data
    structure that you can store and process in the rest of your program. This makes
    it possible to create projects that periodically scan the available networks and
    save the results to a log file.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `scan` method can be found at [https://docs.micropython.org/en/latest/library/network.html#network.AbstractNIC.scan](https://docs.micropython.org/en/latest/library/network.html#network.AbstractNIC.scan).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `active` method can be found at [https://docs.micropython.org/en/latest/library/network.html#network.AbstractNIC.active](https://docs.micropython.org/en/latest/library/network.html#network.AbstractNIC.active).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring settings for AP mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to configure the **access point** (**AP**) mode
    on the ESP8266\. Once configured, the board will become a Wi-Fi AP, and you can
    connect laptops and phones directly to the board using a standard Wi-Fi connection.
  prefs: []
  type: TYPE_NORMAL
- en: Wi-Fi is so ubiquitous that this feature becomes a very powerful way to offer
    connectivity. You can use the technique shown in this recipe to incorporate Wi-Fi
    AP functionality into your own projects. This lets you establish wireless connections
    between your board and a phone or laptop, even when there are no other access
    points available.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to configure the settings for AP mode:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following block of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `network` library has now been imported and a WLAN object has been created
    for AP mode. The following block of code will configure and activate the AP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Search and join the AP called `PyWifi` using a phone or laptop. The following
    output should appear in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect another device to the same AP. You should see details of the joined
    device in the REPL output, as shown in the following block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The board will also report devices that disconnect from the AP. Disconnect
    one of the connected devices from the AP—the following output should appear in
    the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will get details about the IP address and subnet mask of
    the AP.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MicroPython firmware provides functionality to create Wi-Fi access points
    using the ESP8266\. To use this functionally, we must first create a WLAN object
    and pass it the `network.AP_IF` value for its first argument. This will return
    an object that can be used to enable AP mode. The `config` method is then called,
    passing the desired name of the Wi-Fi network and the password that will be used
    for devices to connect to the AP.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the AP must be activated by calling the `active` method with the `True`
    value. The board is then ready to receive connections. As devices join and leave
    the network, these details will be automatically printed as output to the REPL
    session.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in this recipe, multiple devices can be connected to the board at
    the same time. You can use this recipe as a starting point to experiment with
    this feature. You can, for example, connect a laptop and mobile phone to the AP
    and attempt to ping different devices on the Wi-Fi network. You could even ping
    your mobile phone or the ESP8266 board from your laptop.
  prefs: []
  type: TYPE_NORMAL
- en: In later chapters, we'll learn how to run a web server on the board, and then
    you will be able to move beyond ping and interact with the board using your web
    browser over Wi-Fi.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `config` method can be found at [https://docs.micropython.org/en/latest/library/network.html#network.AbstractNIC.config](https://docs.micropython.org/en/latest/library/network.html#network.AbstractNIC.config).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `ifconfig` method can be found at [https://docs.micropython.org/en/latest/library/network.html#network.AbstractNIC.ifconfig](https://docs.micropython.org/en/latest/library/network.html#network.AbstractNIC.ifconfig).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to an existing Wi-Fi network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to connect the ESP8266 to an existing Wi-Fi network.
    There are many benefits to joining an existing Wi-Fi network. Doing so makes it
    possible to wirelessly access the board from different devices on your network.
    It also provides the board with internet connectivity through the Wi-Fi network's
    internet connection. You can use the approach shown in this recipe to connect
    your own embedded projects to different networks and help enable internet connectivity
    in these projects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to connect to an existing Wi-Fi network:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the REPL to run the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The WLAN object has now been created and activated. Use the following block
    of code to verify that the AP you want to connect to appears in the list of available
    networks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line of code will connect to the Wi-Fi AP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will return a Boolean value that will indicate
    whether we are currently connected to the AP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines of code will get details about our current network connection,
    including the board''s IP address, subnet mask, gateway, and DNS server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once run, this code will make the board disconnect from the AP.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MicroPython firmware has the ability to connect to existing Wi-Fi access
    points using the ESP8266\. To do this, you must create a WLAN object and pass
    it the `network.STA_IF` value for its first argument. This object is saved into
    a variable called `station` in this recipe. The `station` object is then activated
    by calling the `active` method with a `True` value. Once activated, the `connect`
    method can be called with the name of the AP to connect to and its associated
    password. Once called, the `connect` method will print out a lot of information
    as the connection proceeds.
  prefs: []
  type: TYPE_NORMAL
- en: We can then check whether or not we are connected at any time by calling the
    `isconnected` method on the station object. This will return the `True` value
    if we are connected, or the `False` value otherwise. Then, we can retrieve network
    details about our IP address and DNS server by calling the `ifconfig` method.
    Finally, the `active` method can be called with a `False` argument to make the
    board disconnect from the network.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is packed with a number of different methods regarding the WLAN
    object that can be called and used. It showed you how to list networks, connect
    to them, poll the connection status, get network information about our current
    network, and how to disconnect from the network.
  prefs: []
  type: TYPE_NORMAL
- en: Using these methods, you can create a program that periodically scans nearby
    networks looking for a specific network. Whenever it is found, you can connect
    to it automatically. You could also write a different script that keeps polling
    the status of your network connectivity and updates a status LED that turns on to
    indicate that the Wi-Fi is connected, and off for disconnected.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `connect` method can be found at [https://docs.micropython.org/en/latest/library/network.html#network.AbstractNIC.connect](https://docs.micropython.org/en/latest/library/network.html#network.AbstractNIC.connect).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `isconnected` method can be found at [https://docs.micropython.org/en/latest/library/network.html#network.AbstractNIC.isconnected](https://docs.micropython.org/en/latest/library/network.html#network.AbstractNIC.isconnected).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the WebREPL over Wi-Fi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to use the WebREPL feature that is available on
    the ESP8266 board with MicroPython. The WebREPL is a service that can be started
    on the board and lets computers on your network wirelessly access the REPL through
    a web browser. We have seen how to access the REPL using the serial connection
    in the *Using the REPL over a serial connection* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will equip you with the skills you need to get a REPL over Wi-Fi,
    making it possible to remotely debug and execute code on the board, even when
    you don't have a direct physical connection to it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe. You should follow the previous recipe, *Connecting to an existing
    Wi-Fi network*, before completing this recipe as you will use that recipe to connect
    the board to your network and get its IP address.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to use the WebREPL over Wi-Fi:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The WebREPL configuration wizard will now start, asking you a series of questions
    so that the service can be configured. Respond to the following question with
    the letter `E` to enable the service at boot-up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The next set of questions will ask you to enter and confirm the WebREPL password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Answer `y` (yes) for the next question so that the board can be rebooted and
    have the changes applied:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You can see from the preceding output that once the board is booted up, it will
    show that the WebREPL service has been started and the URL that can be used to
    access the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the WebREPL software from [https://github.com/micropython/webrepl](https://github.com/micropython/webrepl)
    by clicking on the Clone or download button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the downloaded `.zip` file into any folder on your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `webrepl.html` file in any modern web browser. You should see the
    following interface appear in your web browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/a36cc34c-8f7b-413d-a9fa-abcff78e24dd.png)'
  prefs: []
  type: TYPE_IMG
- en: Enter the URL of your device's WebREPL service in the text box next to the Connect
    button. In the previous screenshot, the IP address of the board was `10.0.0.38`,
    so it's given the URL `ws://10.0.0.38:8266`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, click on the Connect button and enter the WebREPL password when prompted.
    The following screenshot shows a WebREPL session where the `math` module is imported
    and the value of pi is displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/df9cdbce-06e5-4d30-b800-cbc427e40cfc.png)'
  prefs: []
  type: TYPE_IMG
- en: The WebREPL also has the ability to upload files to the board. You can take
    a Python script called `main.py` that you would like to be uploaded to the board
    and upload it using this feature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Browse... button under Send a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your `main.py` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Send to device button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows an example of a successful upload message that
    will appear after you upload a file to the board:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/8fc4762f-7697-48ce-a30f-36fb30f53a2e.png)'
  prefs: []
  type: TYPE_IMG
- en: The message on the screen confirms that the file was sent and reports the number
    of bytes that were transmitted.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MicroPython firmware comes with a built-in WebREPL server. Once you import
    the `webrepl_setup` module, it will start an interactive wizard that will let
    you enable the service. Set its password and configure it to run each time you
    boot up the board. Once this service runs, it exposes a WebSocket service that
    can receive connections from the WebREPL client running in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The WebREPL client doesn't need any special installation—it is just an HTML
    file that can be extracted locally to you computer and then opened in your web
    browser. Through this client, you can now specify the address of the board you
    want to connect to, and establish a connection to the board. Once connected, you
    will have an interactive REPL session in the web browser, as well as the ability
    to upload files to the board.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe focused on one of the WebREPL clients. The client that was shown
    in this recipe is intended to run in your web browser and make the process of
    working with your board over Wi-Fi an easy process. There is also a WebREPL client
    that can be run from the Terminal using a **command-line interface** (**CLI**)
    instead of the web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the web browser client, the CLI version is written completely in Python.
    This gives you a great opportunity to explore the internals of how WebREPL transfers
    files over web sockets. The CLI version will be explored in more depth in the
    next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on accessing the WebREPL can be found at [https://docs.micropython.org/en/latest/esp8266/tutorial/repl.html#webrepl-a-prompt-over-wifi](https://docs.micropython.org/en/latest/esp8266/tutorial/repl.html#webrepl-a-prompt-over-wifi).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A guide on connecting to the WebREPL can be found at [https://learn.adafruit.com/micropython-basics-esp8266-webrepl/](https://learn.adafruit.com/micropython-basics-esp8266-webrepl/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transferring files with the WebREPL CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how we can use the WebREPL CLI to transfer files from
    a computer to the ESP8266 over Wi-Fi. This is a very powerful way of transferring
    files to the board. Each time you make changes to your Python code and want to
    try the latest change, you have to upload the file to the board. Doing this with
    your web browser over and over again can become tedious.
  prefs: []
  type: TYPE_NORMAL
- en: 'The beauty of using the CLI interface is that most Terminals remember their
    last executed commands, so you can rerun the last command with two simple keystrokes:
    you just press the *up* arrow key and the *Enter* key. This will make your cycle
    of code, upload, and run much faster and more productive.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe. You should follow the previous recipe, *Using the WebREPL over Wi-Fi*,
    before tackling this recipe to ensure that the WebREPL is working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to transfer files with the WebREPL CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the WebREPL software from [https://github.com/micropython/webrepl](https://github.com/micropython/webrepl)
    by clicking on the Clone or download button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the downloaded `.zip` file into any folder on your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The extracted files will contain a script called `webrepl_cli.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a Terminal and change the working directory to the location of the `webrepl_cli.py`
    script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the following command in the Terminal to see the command''s options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to upload the `main.py` script to the board. You
    will need to enter the WebREPL password when prompted for it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command is very similar to the previous one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The main difference is that the password is provided in the command line as
    a command-line option.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe starts with a simple command-line invocation of the `webrepl_cli.py`
    script to show details regarding the command-line options. It's a good idea to
    start with this command to at least verify that Python is executing the script
    successfully and producing the output you would expect.
  prefs: []
  type: TYPE_NORMAL
- en: The next time the command is called, it is used to upload the `main.py` script
    to the board. This is definitely a viable way of uploading scripts. However, its
    main downside is that you have to enter the password each time you upload the
    script. This can be addressed as it was in the previous example, where the password
    is provided on the command line. With the final example, the command can be run
    repeatedly with just a few key strokes.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This command can be a real time-saver when you are repeatedly uploading scripts
    to your board. You can also take it and combine it with other command-line software
    that watches for changes in a specific folder. For example, you could have this
    command automatically upload any changes to `main.py` each time the file changes
    by combining these two pieces of software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that, as mentioned in this command''s documentation, file transferring
    is still in alpha stage and has some known issues. If you find that the script
    is getting stuck after a few uploads, the most effective way to address this is
    to do a hard reset. This can be done by running the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This can also be done by pressing the reset button on the board.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on performing hard resets can be found at [http://docs.micropython.org/en/v1.8.6/wipy/wipy/tutorial/reset.html](http://docs.micropython.org/en/v1.8.6/wipy/wipy/tutorial/reset.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on using the `webrepl_cli.py` file to upload files can be found
    at [https://micropython-on-esp8266-workshop.readthedocs.io/en/latest/basics.html#uploading-files](https://micropython-on-esp8266-workshop.readthedocs.io/en/latest/basics.html#uploading-files).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the blue and red LEDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ESP8266 comes with two LEDs: one that''s red, and another that''s blue.
    Both of these LEDs can be controlled from the scripts you load on the board. This
    recipe will show you how you can control each one, and will end with an animation
    that blinks the lights between red and blue.'
  prefs: []
  type: TYPE_NORMAL
- en: The techniques that are shown in this recipe can be used in your own projects
    whenever you want to signal some sort of status to your users. You might want
    to have a blinking blue light when you are scanning for a Wi-Fi network, or to
    light up the red light when your board has lost its network connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to control the blue and red LEDs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following block of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The red LED should now be turned on. Run the following block of code to turn
    the red LED off:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will turn on the blue LED:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will switch the blue LED off:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will create a light animation that switches between the red
    and blue light with a one second delay between each change.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, the `Pin` object is imported from the machine module. This object will
    let us directly connect to the **general-purpose input/output** (**GPIO**) pins
    that come with the ESP8266 board. The red LED is connected on pin number 0\. The
    `Pin` object that's assigned to the `red` variable is connected to the red LED.
    Once this object is created, setting its value to `0` turns the light on and setting
    its value to 1 turns the light off.
  prefs: []
  type: TYPE_NORMAL
- en: The `blue` variable is defined as the `Pin` object connected to GPIO pin 2,
    which maps to the blue LED. It can be turned on and off in the same way. The last
    part of this recipe is an infinite loop that first turns the blue LED on and the
    red LED off.
  prefs: []
  type: TYPE_NORMAL
- en: A sleep delay of 1 second is applied before the blue LED is switched off and
    the red LED is turned on. Another sleep delay of 1 second is applied before the
    loop starts again from the start, performing the same actions.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to control the two LEDs that come with the board.
    Additional LEDs can be connected to the other available GPIO pins and can be controlled
    in a similar fashion. The board comes with 9 available GPIO pins. Beyond simple
    single color LEDs, the same GPIO pins can be used to connect NeoPixels, which
    offer a full range of colors, as they combine different levels of red, green,
    and blue LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on interacting with pins and the GPIO can be found at [https://docs.micropython.org/en/latest/esp8266/quickref.html#pins-and-gpio](https://docs.micropython.org/en/latest/esp8266/quickref.html#pins-and-gpio).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tutorial on interacting with the GPIO pins can be found at [https://docs.micropython.org/en/latest/esp8266/tutorial/pins.html](https://docs.micropython.org/en/latest/esp8266/tutorial/pins.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
