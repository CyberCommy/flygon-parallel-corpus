- en: Chapter 9. Documentation – How to Use Sphinx and reStructuredText
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Documenting code can be both fun and useful! I will admit that many programmers
    have a strong dislike for documenting code and understandably so. Writing documentation
    can be a boring job and traditionally only others reap the benefits of that effort.
    The tools available for Python, however, make it almost trivial to generate useful
    and up-to-date documentation with little to no effort at all. Generating documentation
    has actually become so easy that I create and generate documentation before using
    a Python package. Assuming it wasn't available already, that is.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to simple text documentation explaining what a function does, it
    is also possible to add metadata, such as type hints. These type hints can be
    used to make the arguments and return types of a function or class clickable in
    the documentation. But more importantly, many modern IDEs and editors, such as
    VIM, have plugins available that parse the type hints and use them for intelligent
    auto-completion. So if you type `Spam.eggs`, your editor will automatically complete
    the specific attributes and methods of the eggs object; something that is traditionally
    only viable with statically typed languages such as Java, C, and C++.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explain the types of documentation available in Python and
    how easily a full set of documentation can be created. With the amazing tools
    that Python provides, you can have fully functioning documentation within minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The reStructuredText syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up documentation using Sphinx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sphinx style docstrings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google style docstrings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NumPy style docstrings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reStructuredText syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **reStructuredText** format (also known as **RST**, **ReST**, or **reST**)
    was developed in 2002 as a simple language that implements enough markup to be
    usable, but is simple enough to be readable as plain text. These two features
    make it readable enough to use in code, yet still versatile enough to generate
    pretty and useful documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The greatest thing about reStructuredText is that it is very intuitive. Even
    without knowing anything about the standard, you can easily write documentation
    in this style without ever knowing that it would be recognized as a language.
    However, more advanced techniques, such as images and links, do require some explanation.
  prefs: []
  type: TYPE_NORMAL
- en: Next to reStructuredText, there are also languages such as **Markdown** which
    are quite similar in usage. Within the Python community, reStructuredText has
    been the standard documentation language for over 10 years, making it the recommended
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To easily convert between formats such as reStructuredText and Markdown, use
    the Pandoc tool, available at [http://pandoc.org/](http://pandoc.org/).
  prefs: []
  type: TYPE_NORMAL
- en: The basic syntax reads just like text and the next few paragraphs will show
    some of the more advanced features. However, let us start with a simple example
    demonstrating how simple a reStructuredText file can be.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s how easy it is to convert the text of this chapter so far to reStructuredText.
    The following paragraphs will cover the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Inline markup (italic, bold, code, and links)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Headers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Advanced links
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Images
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Substitutions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Blocks containing code, math, and others
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting started with reStructuredText
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To quickly convert a reStructuredText file to HTML, we can use the `docutils`
    library. The `sphinx` library discussed later in this chapter actually uses the
    `docutils` library internally, but has some extra features that we won''t need
    initially. To get started, we just need to install `docutils`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After that we can easily convert reStructuredText into PDF, LaTeX, HTML, and
    other formats. For the examples in this paragraph, we''ll use the HTML format
    which is easily generated using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The basic components of reStructuredText are roles, which are used for inline
    modifications of the output and directives to generate markup blocks. Within pure
    reStructuredText, the directives are the most important, but we will see many
    uses for the roles in the section about Sphinx.
  prefs: []
  type: TYPE_NORMAL
- en: Inline markup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Inline markup** is the markup that is used within a regular line of text.
    Examples of these are emphasis, in-line code examples, links, images, and bullet
    lists.'
  prefs: []
  type: TYPE_NORMAL
- en: Emphasis, for example, can be added by encapsulating the words between one or
    two asterisk signs. This sentence for example could add a little bit of `*emphasis*`
    by adding a single asterisk on both sides or a lot of `**emphasis**` by adding
    two asterisks at both sides. There are many different inline markup directives
    so we will list only the most common ones. A full list can always be found through
    the reStructuredText homepage at `docutils.sourceforge.net`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Emphasis (italic) text: `*emphasis for this phrase*`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Extra emphasis (bold) text: `**extra emphasis for this phrase**`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For lists without numbers, a simple dash with spaces after it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The space after the dash is required for reStructuredText to recognize the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'For lists with numbers, the number followed by a period and a space:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For numbered lists, the period after the number is required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interpreted text: These are domain specific. Within Python documentation, the
    default role is code which means that surround text with back ticks will convert
    your code to use code tags. For example, ``if spam and eggs:``.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different roles can be set through either a role prefix or suffix depending
    on your preference. For example, `:math:`E=mc^2`` to show mathematical equations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inline literals: This is formatted with a mono-space font, which makes it ideal
    for inline code. Just add two back ticks to [PRE5].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'References: These can be created through a trailing underscore. They can point
    to headers, links, labels, and more. The next section will cover more about these,
    but the basic syntax is simply `reference_` or enclosed in back ticks when the
    reference contains spaces, ``some reference link`_`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To escape the preceding characters, the backslash can be used. So if you wish
    to have an asterisk with emphasis, it's possible to use `*\**`, quite similar
    to escaping in Python strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more available, but these are the ones you will use the most
    when writing reStructuredText.
  prefs: []
  type: TYPE_NORMAL
- en: Headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The headers are used to indicate the start of a document, section, chapter,
    or paragraph. It is therefore the first structure you need in a document. While
    not strictly needed, its usage is highly recommended as it serves several purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: The headers are consistently formatted according to their level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sphinx can generate a Table Of Contents (TOC) tree from the headers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All headers automatically function as labels, which means you can create links
    towards them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When creating headers, consistency is one of the few constraints; the character
    used is fairly arbitrary as is the amount of levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Personally, I default to a simple system with a fixed-size header, but I recommend
    at least following the default of the Python documentation in terms of the parts,
    chapters, sections, subsections, subsubsections, and paragraphs. Something along
    the lines of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Headers](images/4711_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'That is just the common usage of the headers, but the main idea of reStructuredText
    is that you can use just about anything that feels natural to you, which means
    that you can use any of the following characters: `= - ` : '' " ~ ^ _ * + # <>`.
    It also supports both underlines and overlines, so if you prefer that, they are
    options as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'While I try to keep the number of characters fixed to 78 characters as `PEP8`
    ([Chapter 2](ch02.html "Chapter 2. Pythonic Syntax, Common Pitfalls, and Style
    Guide"), *Pythonic Syntax, Common Pitfalls, and Style Guide*) recommends for Python,
    the number of characters used is mostly arbitrary, but it does have to be at least
    as long as the text of the header. This allows it to get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'But not this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The reStructuredText format has several styles of lists:'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerated
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bulleted
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Options
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Definitions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The simplest forms of lists were already displayed in the introduction section,
    but it's actually possible to use many different characters, such as letters,
    Roman numerals, and others, for enumeration. After demonstrating the basic list
    types, we will continue with the nesting of lists and structures which makes them
    even more powerful. Care must be taken with the amount of whitespace, as a space
    too many can cause a structure to be recognized as regular text instead of a structure.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerated list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Enumerated lists are convenient for all sorts of enumerations. The basic premise
    for enumerated lists is an alphanumeric character followed by a period, a right
    parenthesis, or parentheses on both sides. Additionally, the `#` character functions
    as an automatic enumeration. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is perhaps a bit simpler than you would expect. The reason is that
    it depends on the output format. These were generated with the HTML output format
    which has no support for parentheses. If you output LaTeX for example, the difference
    can be made visible. Following is the rendered HTML output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enumerated list](images/4711_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Bulleted list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the order of the list is not relevant and you simply need a list of items
    without enumeration, then the bulleted list is what you need. To create a simple
    list using bullets only, the bulleted items need to start with a `*`, `+`, `-`,
    `•`, `‣`, or `⁃`. This list is mostly arbitrary and can be modified by extending
    Sphinx or Docutils. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, with the HTML output again all bullets look identical. When
    generating documentation as LaTeX (and consecutively, PDF or Postscript), these
    can differ. Since web-based documentation is by far the most common output format
    for Sphinx, we default to that output instead. The rendered HTML output is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bulleted list](images/4711_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Option list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `option` list is one meant specifically for documenting the command line
    arguments of a program. The only special thing about the syntax is that the comma-space
    is recognized as a separator for options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Option list](images/4711_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Definition list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The definition list is a bit more obscure than the other types of lists, since
    the actual structure consists of whitespace only. It's therefore pretty straightforward
    to use, but not always as easy to identify in a file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Definition list](images/4711_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Nested lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nesting items is actually not limited to lists and can be done with multiple
    types of blocks, but the idea is the same. Just be careful to keep the indenting
    at the correct level. If you don't, it either won't be recognized as a separate
    level or you will get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Nested lists](images/4711_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Links, references, and labels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many types of links supported in reStructuredText, the simplest of
    which is just a link with the protocol such as [http://python.org](http://python.org),
    which will automatically be recognized by most parsers. However, custom labels
    are also an option by using the interpreted text syntax we saw earlier: ``Python
    <http://python.org>`_`.'
  prefs: []
  type: TYPE_NORMAL
- en: Both of these are nice for simple links, which won't be repeated too often,
    but generally it's more convenient to attach labels to links so they can be reused
    and don't clog up the text too much.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now compare it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Links, references, and labels](images/4711_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using labels, you can easily have a list of references at a designated location
    without making the actual text harder to read. These labels can be used for more
    than external links however; similar to the `GOTO` statements found in older programming
    languages, you can create labels and refer to them from other parts of the documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Within HTML or PDF output, this can be used to create a clickable link from
    anywhere in the text using the underscore links. Creating a clickable link to
    the label is as simple as having `label_` in the text. Note that reStructuredText
    ignores case differences so both uppercase and lowercase links work just fine.
    Even though it's not likely to make this mistake, having the same label in a single
    document with only case differences results in an error to make sure duplicates
    never occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage of references in conjunction with the headers works in a very natural
    way; you can just refer to them as you normally would and add an underscore to
    make it a link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Links, references, and labels](images/4711_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The image directive looks very similar to the label syntax. They''re actually
    a bit different but the pattern is quite similar. The image directive is just
    one of the many directives that is supported by reStructuredText. We will see
    more about that later on when we cover Sphinx and reStructuredText extensions.
    For the time being, it is enough to know that the directives start with two periods
    followed by a space, the name of the directive, and two colons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of the image, the directive is called `image` of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Scaled output as the actual image is much larger:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](images/4711_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the double colon after the directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how about specifying the size and other properties? The image directive
    has many other options (as do most other directives) which can be used: [http://docutils.sourceforge.net/docs/ref/rst/directives.html#images](http://docutils.sourceforge.net/docs/ref/rst/directives.html#images),
    they are mostly fairly obvious however. To specify the width and height or the
    scale (in percent) of the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](images/4711_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `scale` option uses the `width` and `height` options if available and falls
    back to the PIL (Python Imaging Library) or Pillow library to detect the image.
    If both width/height and PIL/Pillow are not available, the `scale` option will
    be ignored silently.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the `image` directive, there is also the `figure` directive.
    The difference is that `figure` adds a caption to the image. Beyond that, the
    usage is the same as `image`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](images/4711_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Substitutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing documentation, it often happens that constructs are being repeated,
    the links have their own labelling system but there are more ways within reStructuredText.
    The substitution definitions make it possible to shorten directives so they can
    easily be re-used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we have a logo that we use quite often within a bit of text.
    Instead of typing the entire `.. image:: <url>` it would be very handy to have
    a shorthand to make it easier. That''s where the substitutions are very useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Substitutions](images/4711_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'These substitutions can be used with many directives, though they are particularly
    useful for outputting a variable in many places of a document. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Substitutions](images/4711_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Blocks, code, math, comments, and quotes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When writing documentation, a common scenario is the need for blocks that contain
    different type of content, explanations with mathematical formulas, code examples,
    and more. The usage of these directives is similar to the image directive. Following
    is an example of a code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Blocks, code, math, comments, and quotes](images/4711_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Or math using LaTeX syntax, the fundamental theorem of calculus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Blocks, code, math, comments, and quotes](images/4711_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Commenting a bunch of text/commands is easily achieved by using the "empty"
    directive followed by an indent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Blocks, code, math, comments, and quotes](images/4711_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The simplest ones are the block quotes. A block quote requires nothing but just
    a simple bit of indentation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Blocks, code, math, comments, and quotes](images/4711_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: reStructuredText is both a very simple and a very extensive language; a large
    portion of the syntax comes naturally when writing plain-text notes. A full guide
    to all the intricacies, however, could fill a separate book. The previous demonstrations
    should have given enough of an introduction to do at least 90 percent of the work
    you will need when documenting your projects. Beyond that, Sphinx will help a
    lot as we will see in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: The Sphinx documentation generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Sphinx documentation generator was created in 2008 for the Python 2.6 release
    to replace the old LaTeX documentation for Python. It''s a generator that makes
    it almost trivial to generate documentation for programming projects, but even
    outside of the programming world it can be easily used. Within programming projects,
    there is specific support for the following domains (programming languages):'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Javascript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: reStructuredText
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outside of these languages, there are extensions available for many other languages
    such as CoffeeScript, MATLAB, PHP, Ruby Lisp, Go, and Scala. And if you're simply
    looking for snippet code highlighting, the Pygments highlighter which is used
    internally supports over 120 languages and is easily extendible for new languages
    if needed.
  prefs: []
  type: TYPE_NORMAL
- en: The most important advantage of Sphinx is that almost everything can be automatically
    generated from your source code. So the documentation is always up to date.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Sphinx
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we have to make sure we install Sphinx. Even though the Python
    core documentation is written using Sphinx, it is still a separately maintained
    project and must be installed separately. Luckily, that''s easy enough using pip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: After installing Sphinx, there are two ways of getting started with a project,
    the `sphinx-quickstart` script and the `sphinx-apidoc` script. If you want to
    create and customize an entire Sphinx project then `sphinx-quickstart` may be
    best as it assists you in configuring a fully featured Sphinx project. If you
    simply want API documentation for an existing project then `sphinx-apidoc` might
    be better suited since it takes a single command and no further input to create
    a project.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, both are valid options for creating Sphinx projects and personally
    I usually end up generating the initial configuration using `sphinx-quickstart`
    and call the `sphinx-apidoc` command every time I add a Python module to add the
    new module. Since `sphinx-apidoc` does not overwrite any files by default, it
    is a safe operation.
  prefs: []
  type: TYPE_NORMAL
- en: Using sphinx-quickstart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `sphinx-quickstart` script interactively asks you about the most important
    decisions in your Sphinx project. No need to worry if you've accidently made a
    typo however. Most of the configuration is stored in the `conf.py` directory so
    it's easy enough to edit the configuration later in case you still want to enable
    a certain module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usage is easy enough, as a default I would recommend using the following settings.
    The output uses the following conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: Inline comments start with `#`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User input lines start with `>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cropped output is indicated with `...` and all questions skipped in between
    use the default settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now populate your master file `docs/index.rst` and create other
    documentation source files. Use the Makefile to build the docs, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After running this, we should have a `docs` directory containing the Sphinx
    project. Let''s see what the command actually created for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `_build`, `_static`, and `_templates` directories are initially empty and
    can be ignored for now. The `_build` directory is used to output the generated
    documentation whereas the `_static` directory can be used to easily include custom
    CSS files and such. The `_templates` directory makes it possible to style the
    HTML output to your liking as well. Examples of these can be found in the Sphinx
    Git repository at [https://github.com/sphinx-doc/sphinx/tree/master/sphinx/themes](https://github.com/sphinx-doc/sphinx/tree/master/sphinx/themes).
  prefs: []
  type: TYPE_NORMAL
- en: '`Makefile` and `make.bat` can be used to generate the documentation output.
    `Makefile` can be used for any operating system that supports the make utility
    and `make.bat` is there to support Windows systems out of the box. Now let''s
    look at the `index.rst` source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We see the document title as expected, followed by `toctree` (table of contents
    tree; more about that later in this chapter), and the links to the indices and
    search. `toctree` automatically generates a tree out of the headers of all available
    documentation pages. The indices and tables are automatically generated Sphinx
    pages, which are very useful but nothing we need to worry about in terms of settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to generate the `HTML` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `make` html command generates the documentation for you and the result
    is placed in `_build/html/`. Just open `index.html` in your browser to see the
    results. You should have something looking similar to the following now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using sphinx-quickstart](images/4711_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With just that single command and by answering a few questions, we now have
    a documentation project with an index, search, and table of contents on all the
    pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the HTML output, there are quite a few other formats supported
    by default, although some require external libraries to actually work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Using sphinx-apidoc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `sphinx-apidoc` command is generally used together with `sphinx-quickstart`.
    It is possible to generate an entire project with the `--full` parameter but it's
    generally a better idea to generate the entire project using `sphinx-quickstart`
    and simply add the API documentation using `sphinx-apidoc`. To properly demonstrate
    the `sphinx-apidoc` command, we need some Python files, so we'll create two files
    within a project called `h09`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is `h09/spam.py` containing a class called `Spam` with some methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we have `h09/eggs.py` containing a `Eggs` class that inherits `Spam`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our source files, it''s time to generate the actual API documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This alone is not enough to include the API in the documentation. It needs
    to be added to `toctree`. Luckily, that''s as simple as adding modules to `toctree`
    in the `index.rst` file to look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `toctree` directive is discussed in further detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have to make sure that the modules can be imported, otherwise Sphinx
    won''t be able to read the Python files. To do that, we simply add the `h09` directory
    to `sys.path`; this can be put anywhere in the `conf.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to generate the documentation again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `docs/_build/index.html` file again. For the sake of brevity, the
    repeated parts of the document will be omitted from the screenshots. The cropped
    output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using sphinx-apidoc](images/4711_09_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: But it actually generated quite a bit more. When running the `sphinx-apidoc`
    command, it looks at all the Python modules in the specified directory recursively
    and generates a `rst` file for each of them. After generating all those separate
    files, it adds all those to a file called `modules.rst` which makes it easy to
    add them to your documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `modules.rst` file is really straight to the point; nothing more than a
    list of modules with the package name as the title really:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using sphinx-apidoc](images/4711_09_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`spam.rst` and `eggs.rst` are equally simple, but more important in terms of
    customization. Within those files it adds the automodule directive which imports
    the Python module and lists the methods. The methods that are listed can be configured
    and by default we already get pretty useful output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using sphinx-apidoc](images/4711_09_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pretty, isn't it? And all that can be generated from most Python projects with
    virtually no effort whatsoever. The nice things about this is that the documentation
    we added to `Eggs.regular_method` is immediately added here, the inherited base
    (`spam.Spam`) is a clickable link to the `spam.Spam` documentation page, and the
    `:func:` role makes `spam.Spam.regular_method` immediately clickable as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for the spam module is similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using sphinx-apidoc](images/4711_09_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: New files won't be added to your docs automatically. It is safe to rerun the
    `sphinx-apidoc` command to add the new files but it won't update your existing
    files. Even though the `--force` option can be used to force overwriting the files,
    within existing files I recommend manually editing them instead. As we will see
    in the next sections, there are quite a few reasons to manually modify the generated
    files after.
  prefs: []
  type: TYPE_NORMAL
- en: Sphinx directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sphinx adds a few directives on top of the default ones in reStructuredText
    and an easy API to add new directives yourself. Most of them are generally not
    that relevant to modify but, as one would expect, Sphinx has pretty good documentation
    in case you need to know more about them. There are a few very commonly used ones
    which we will discus however.
  prefs: []
  type: TYPE_NORMAL
- en: The table of contents tree directive (toctree)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is one of the most important directives in Sphinx; it generates `toctree`
    (table of contents tree). The `toctree` directive has a couple of options but
    the most important one is probably `maxdepth` which specifies how deep the tree
    needs to go. The top level of `toctree` has to be specified manually by specifying
    the files to be read, but beyond that every level within a document (section,
    chapter, paragraph, and so on) can be another level in `toctree`, depending on
    the depth of course. Even though the `maxdepth` option is optional, without it
    all the available levels will be shown, which is usually more than required. In
    most cases a `maxdepth` of 2 is a good default value which makes the basic example
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The items in `toctree` are the `.rst` files in the same directory without the
    extension. This can include subdirectories, in which case the directories are
    separated with a `.` (period):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Another very useful option is the `glob` option. It tells `toctree` to use
    the `glob` module in Python to automatically add all the documents matching a
    pattern. By simply adding a directory with a `glob` pattern, you can add all the
    files in that directory. This makes the `toctree` we had before as simple as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If for some reason the document title is not as you would have liked, you can
    easily change the title to something customized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Autodoc, documenting Python modules, classes, and functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most powerful feature of Sphinx is the possibility of automatically documenting
    your modules, classes, and functions. The `sphinx-apidoc` command has already
    generated some of these for us, so let's use those files for the `Spam` and `Eggs`
    classes to extend the documentation a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original result from `sphinx-apidoc` was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This renders as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Autodoc, documenting Python modules, classes, and functions](images/4711_09_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Eggs` class has only a single function right now. We can of course click
    towards the parent class with ease, but in many cases it''s useful to see all
    available functions in the class. So let''s add all the functions that are inherited
    from `Spam` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Autodoc, documenting Python modules, classes, and functions](images/4711_09_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Much more useful already, but we are still missing the hidden method. Let''s
    add the private members as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Autodoc, documenting Python modules, classes, and functions](images/4711_09_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now all the methods are shown, but what about the `members` option? Without
    the `members` option or the `*-members` options, no functions will be visible
    anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '`show-inheritance` is useful if you want to have the `Bases: ...` section so
    it is possible to click to the parent class.'
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, it is also possible to create classes manually. While this has little
    practical use, it does show the internal structure of Python classes within Sphinx.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a practical case however, if you are dynamically creating classes
    then `autodoc` will not always be able to document correctly and some additional
    help is required. There is more however, while it''s generally not that useful
    as you''re doing double work. In some cases, the `autodoc` extension won''t be
    able to correctly identify the members of your class. This is true in case of
    dynamic class/function generation, for example. For such cases, it can be useful
    to add some manual documentation to the module/class/function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Autodoc, documenting Python modules, classes, and functions](images/4711_09_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If at all possible, I would avoid this usage though. The biggest benefit of
    Sphinx is that it can automatically generate a large portion of your docs for
    you. By manually documenting, you may produce the one thing that's worse than
    no documentation, that is incorrect documentation. These statements are mainly
    useful for meta-documentation; documenting how a class might look instead of an
    actual example.
  prefs: []
  type: TYPE_NORMAL
- en: Sphinx roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen Sphinx directives, which are separate blocks. Now we will discuss
    Sphinx roles, which can be used in-line. A role allows you to tell Sphinx how
    to parse some input. Examples of these roles are links, math, code, and markup.
    But the most important ones are the roles within the Sphinx domains for referencing
    other classes, even for external projects. Within Sphinx, the default domain is
    the Python one so a role such as `:py:meth:` can be used as `:meth:` as well.
    These roles are really useful to link to different packages, modules, classes,
    methods, and other objects. The basic usage is simple enough. To link to a class,
    use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sphinx roles](images/4711_09_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The same goes for just about any other object, functions, exceptions, attributes,
    and so on. The Sphinx documentation offers a list of supported objects: [http://sphinx-doc.org/domains.html#cross-referencing-python-objects](http://sphinx-doc.org/domains.html#cross-referencing-python-objects).'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the nicer features of Sphinx is that this is actually possible across
    projects as well, adding a reference to the `int` object in the standard Python
    documentation is easily possible using `:obj:`int``. And adding references to
    your own projects on other sites is fairly trivial as well. Perhaps you remember
    the `intersphinx` question from the `sphinx-quickstart` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s what makes cross-referencing between external Sphinx documentation
    and your local one possible. With `intersphinx` you can add links between projects
    with virtually no effort whatsoever. The standard `intersphinx_mapping` in `conf.py`
    is a bit limited:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it can easily be extended to other documentation sites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can easily link to the documentation on the Sphinx homepage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sphinx roles](images/4711_09_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This links to [http://www.sphinx-doc.org/en/stable/ext/intersphinx.html](http://www.sphinx-doc.org/en/stable/ext/intersphinx.html).
  prefs: []
  type: TYPE_NORMAL
- en: Documenting code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are currently three different documentation styles supported by Sphinx:
    the original Sphinx style and the more recent NumPy and Google styles. The differences
    between them are mainly in style but it''s actually slightly more than that.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Sphinx style was developed using a bunch of reStructuredText roles, a very
    effective method but when used a lot it can be detrimental for readability. You
    can probably tell what the following does but it''s not the nicest syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The Google style was (as the name suggests) developed by Google. The goal was
    to have a simple/readable format which works both as in-code documentation and
    parse able for Sphinx. In my opinion, this comes closer to the original idea of
    reStructuredText, a format that''s very close to how you would document instinctively.
    This example has the same meaning as the Sphinx style example shown earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The NumPy style was created specifically for the NumPy project. The NumPy project
    has many functions with a huge amount of documentation and generally a lot of
    documentation per argument. It is slightly more verbose than the Google format
    but quite easy to read as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the future, with the Python 3.5 type hint annotations, at least the argument
    type part of these syntaxes might become useless. For the time being, Sphinx has
    no specific support for the annotations yet, so explicit type hinting through
    the docs must be used. But perhaps we can use the following soon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Documenting a class with the Sphinx style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, let''s look at the traditional style, the Sphinx style. While
    it''s easy to understand what all the parameters mean, it''s a bit verbose and
    not all that readable. Nonetheless, it''s pretty clear and definitely not a bad
    style to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Documenting a class with the Sphinx style](images/4711_09_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a very useful output indeed with documented functions, classes, and
    arguments. And more importantly, the types are documented as well, resulting in
    a clickable link towards the actual type. An added advantage of specifying the
    type is that many editors understand the documentation and will provide auto-completion
    based on the given types.
  prefs: []
  type: TYPE_NORMAL
- en: To explain what's actually happening here, Sphinx has a few roles within the
    docstrings that offer hints as to what we are documenting.
  prefs: []
  type: TYPE_NORMAL
- en: The `param` role paired with a name sets the documentation for the parameter
    with that name. The `type` role paired with a name tells Sphinx the data type
    of the parameter. Both the roles are optional and the parameter simply won't have
    any added documentation if they are omitted, but the `param` role is always required
    for any documentation to show. Simply adding the `type` role without the `param`
    role will result in no output whatsoever, so take note to always pair them.
  prefs: []
  type: TYPE_NORMAL
- en: The `returns` role is similar to the `param` role with regards to documenting.
    While the `param` role documents a parameter, the `returns` role documents the
    returned object. They are slightly different however. Opposed to the `param` role,
    the `returns` role is not dependent of the `rtype` role or vice versa. They both
    work independently of each other making it possible to use either or both of the
    roles.
  prefs: []
  type: TYPE_NORMAL
- en: The `rtype`, as you can expect, tells Sphinx (and several editors) what type
    of object is returned from the function.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting a class with the Google style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Google style is just a more legible version of the Sphinx style documentation.
    It doesn't actually support more or less but it's a lot more intuitive to use.
    The only thing to keep in mind is that it's a fairly recent feature of Sphinx.
    With the older versions, you were required to install the `sphinxcontrib-napoleon`
    package. These days it comes bundled with Sphinx but still needs to be enabled
    through the `conf.py` file. So, depending on the Sphinx version (Napoleon was
    added in Sphinx 1.3), you will need to add either `sphinx.ext.napoleon` or `sphinxcontrib.napoleon`
    to the extensions list in `conf.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have everything configured correctly, we can use both the Google and
    NumPy style. Here''s the Google style version of the `Spam` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This is easier on the eyes than the Sphinx style and has the same amount of
    possibilities. For longer argument documentation, it's less than convenient though.
    Just imagine how a multiline description of `amount` would look. That is why the
    NumPy style was developed, a lot of documentation for its arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting a class with the NumPy style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The NumPy style is meant for having a lot of documentation. Honestly, most
    people are too lazy for that, so for most projects it would not be a good fit.
    If you do plan to have extensive documentation of your functions and all their
    parameters, the NumPy style might be a good option for you. It''s a bit more verbose
    than the Google style but it''s very legible, especially with more detailed documentation.
    Just remember that, similar to the Google style, this requires the Napoleon extension
    for Sphinx, so make sure you have Sphinx 1.3 or above installed. Following is
    the NumPy version of the `Spam` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: While the NumPy style definitely isn't bad, it's just very verbose. This example
    alone is about 1.5 times as long as the alternatives. So, for longer and more
    detailed documentation it's a very good choice, but if you're planning to have
    short documentation anyhow, just use the Google style instead.
  prefs: []
  type: TYPE_NORMAL
- en: Which style to choose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For most projects, the Google style is the best choice since it is readable
    but not too verbose. If you are planning to use large amounts of documentation
    per parameter then the NumPy style might be a good option as well.
  prefs: []
  type: TYPE_NORMAL
- en: The only reason to choose the Sphinx style is legacy. Even though the Google
    style might be more legible, consistency is more important.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Documentation can help greatly in a project's popularity and bad documentation
    can kill productivity. I think there are few aspects of a library that have more
    impact on the usage by third parties than documentation. Thus in many cases, documentation
    is a more important factor in deciding the usage of a project than the actual
    code quality. That's why it is very important to always try to have some documentation
    available.
  prefs: []
  type: TYPE_NORMAL
- en: With Sphinx it is actually easy to generate documentation. With just a few minutes
    of your time, you can have a fully functioning website with documentation available,
    or a PDF, or ePub, or one of the many other output formats. There really is no
    excuse for having no documentation anymore. And even if you don't use the documentation
    that much yourself, offering type hints to your editor can help a lot in productivity
    as well. Making your editor smarter should always help in productivity. I for
    one have added type hints to several projects simply to increase my productivity.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will explain how code can be tested in Python and some part
    of the documentation will return there. Using `doctest`, it is possible to have
    example code, documentation, and tests in one.
  prefs: []
  type: TYPE_NORMAL
