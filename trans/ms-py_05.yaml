- en: Chapter 5. Decorators – Enabling Code Reuse by Decorating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you are going to learn about Python decorators. Decorators
    are essentially function/class wrappers that can be used to modify the input,
    output, or even the function/class itself before executing it. This type of wrapping
    can just as easily be achieved by having a separate function that calls the inner
    function, or via mixins. As is the case with many Python constructs, decorators
    are not the only way to reach the goal but are definitely convenient in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: While you can live perfectly without knowing too much about decorators, they
    give you a lot of "reuse power" and are therefore used heavily in framework libraries
    such as web frameworks. Python actually comes bundled with some useful decorators,
    most notably the `property` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are, however, some particularities to take note of: wrapping a function
    creates a new function and makes it harder to reach the inner function and its
    properties. One example of this is the `help(function)` functionality of Python;
    by default, you will lose function properties such as the help text and the module
    the function exists in.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will cover the usage of both function and class decorators as well
    as the intricate details you need to know when decorating functions within classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the topics covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Decorating functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorating class functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorating classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using classes as decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Useful decorators in the Python standard library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorating functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Essentially, a decorator is nothing more than a function or class wrapper.
    If we have a function called `spam` and a decorator called `eggs`, then the following
    would decorate `spam` with `eggs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the syntax easier to use, Python has a special syntax for this case.
    So, instead of adding a line such as the preceding one below the function, you
    can simply decorate a function using the `@` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The decorator simply receives the function and returns a—usually different—function.
    The simplest possible decorator is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the earlier example, we realize that this gets `spam` as the argument
    for `function` and returns that function again, effectively changing nothing.
    Most decorators nest functions, however. The following decorator will print all
    arguments sent to `spam` and pass them to `spam` unmodified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This should indicate how powerful decorators can be. By modifying `*args` and
    `**kwargs`, you can add, modify and remove arguments completely. Additionally,
    the return statement can be modified as well. Instead of `return function(...)`,
    you can return something completely different if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Why functools.wraps is important
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whenever you are writing a decorator, always be sure to add `functools.wraps`
    to wrap the inner function. Without wrapping it, you will lose all properties
    from the original function, which can lead to confusion. Take a look at the following
    code without `functools.wraps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our `spam` method has no documentation anymore and the name is gone. It
    has been renamed to `_eggs`. Since we are indeed calling `_eggs`, this is understandable,
    but it''s very inconvenient for code that relies on this information. Now we will
    try the same code with the minor difference; we will use `functools.wraps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Without any further changes, we now have documentation and the expected function
    name. The working of `functools.wraps` is nothing magical though; it simply copies
    and updates several attributes. Specifically, the following attributes are copied:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__doc__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__name__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__module__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__annotations__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__qualname__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, `__dict__` is updated using `_eggs.__dict__.update(spam.__dict__)`,
    and a new property called `__wrapped__` is added, which contains the original
    (`spam` in this case) function. The actual `wraps` function is available in the
    `functools.py` file of your Python distribution.
  prefs: []
  type: TYPE_NORMAL
- en: How are decorators useful?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use cases for decorators are plentiful, but some of the most useful cases
    are with debugging. More extensive examples of this will be covered in [Chapter
    11](ch11.html "Chapter 11. Debugging – Solving the Bugs"), *Debugging – Solving
    the Bugs* but I can give you a sneak preview of how to use decorators to keep
    track of what your code is doing.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume you have a bunch of functions that may or may not be called, and
    you're not entirely sure what kind of input and output each of these is getting.
    In this case, you could, of course, modify the function and add some print statements
    at the beginning and the end to print the output. This quickly gets tedious, however,
    and it's one of those cases where a simple decorator will make it easy to do the
    same thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we are using a very simple function, but we all know that
    in real life, we''re not always that lucky:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take our simple `spam` function and add some output so that we can see
    what happens internally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: While this works, wouldn't it be far nicer to have a little decorator that takes
    care of this problem?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a decorator that we can easily reuse for any function that prints
    the input, output, and function name. This type of decorator can also be very
    useful for logging applications, as we will see in [Chapter 10](ch10.html "Chapter 10. Testing
    and Logging – Preparing for Bugs"), *Testing and Logging – Preparing for Bugs*.
    It should be noted that you can use this example even if you are not able to modify
    the module containing the original code. We can wrap the function locally and
    even monkey-patch the module if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Naturally, monkey-patching is not a good idea in production code, but it can
    be very useful when debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization using decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Memoization is a simple trick for making some code run a bit faster. The basic
    trick here is to store a mapping of the input and expected output so that you
    have to calculate a value only once. One of the most common examples of this technique
    is when demonstrating the naïve (recursive) Fibonacci function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: While this example would work just fine without any memoization, for larger
    numbers, it would kill the system. For `n=2`, the function would execute `fibonacci(n
    - 1)` and `fibonacci(n - 2)` recursively, effectively giving an exponential time
    complexity. Also, effectively for `n=30`, the Fibonacci function is called 2,692,537
    times which is still doable nonetheless. At `n=40`, it is going to take you quite
    a very long time to calculate.
  prefs: []
  type: TYPE_NORMAL
- en: The memoized version, however, doesn't even break a sweat and only needs to
    execute `31` times for `n=30`.
  prefs: []
  type: TYPE_NORMAL
- en: This decorator also shows how a context can be attached to a function itself.
    In this case, the cache property becomes a property of the internal (wrapped `fibonacci`)
    function so that an extra `memoize` decorator for a different object won't clash
    with any of the other decorated functions.
  prefs: []
  type: TYPE_NORMAL
- en: Note, however, that implementing the memoization function yourself is generally
    not that useful anymore since Python introduced `lru_cache` (least recently used
    cache) in Python 3.2\. The `lru_cache` is similar to the preceding memoize function
    but a bit more advanced. It only maintains a fixed (`128` by default) cache size
    to save memory and uses some statistics to check whether the cache size should
    be increased.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how `lru_cache` works internally, we will calculate `fibonacci(100)`,
    which would keep our computer busy until the end of the universe without any caching.
    Moreover, to make sure that we can actually see how many times the `fibonacci`
    function is being called, we''ll add an extra decorator that keeps track of the
    count, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You might wonder why we need only 101 calls with a cache size of `3`. That's
    because we recursively require only `n - 1` and `n - 2`, so we have no need of
    a larger cache in this case. With others, it would still be useful though.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, this example shows the usage of two decorators for a single function.
    You can see these as the layers of an onion. The first one is the outer layer
    and it works towards the inside. When calling `fibonacci`, `lru_cache` will be
    called first because it's the first decorator in the list. Assuming there is no
    cache available yet, the `counter` decorator will be called. Within the counter,
    the actual `fibonacci` function will be called.
  prefs: []
  type: TYPE_NORMAL
- en: Returning the values works in the reverse order, of course; `fibonacci` returns
    its value to `counter`, which passes the value along to `lru_cache`.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators with (optional) arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous examples mostly used simple decorators without any arguments.
    As we have already seen with `lru_cache`, decorators can accept arguments as well
    since they are just regular functions, but this adds an extra layer to a decorator.
    This means that adding an argument can be as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Optional arguments are a different matter, however, because they make the extra
    function layer optional. With arguments, you need three layers, but without arguments,
    you need only two layers. Since decorators are essentially regular functions that
    return functions, the difference would be to return the sub-function or the sub-sub-function,
    based on the parameters. This leaves just one issue—detecting whether the parameter
    is a function or a regular parameter. To illustrate, with the parameters the actual
    call looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas the call without arguments would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To detect whether the decorator was called with a function or a regular argument
    as a parameter, we have several options, none of which are completely ideal in
    my opinion:'
  prefs: []
  type: TYPE_NORMAL
- en: Using keyword arguments for decorator arguments so that the regular argument
    will always be the function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting whether the first and only argument is callable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In my opinion, the first one—using keyword arguments—is the better of the two
    options because it is somewhat more explicit and leaves less room for confusion.
    The second option could be problematic if, for some reason, your argument is callable
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the first method, the normal (non-keyword) argument has to be the decorated
    function and the other two checks can still apply. We can still check whether
    the function is indeed callable and whether there is only a single argument available.
    Here is an example using a modified version of the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Whenever you have the choice available, I recommend that you either have a decorator
    with arguments or without them, instead of having optional arguments. However,
    if you have a really good reason for making the arguments optional, then you have
    a relatively safe method of making this possible.
  prefs: []
  type: TYPE_NORMAL
- en: Creating decorators using classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to how we create regular function decorators, it is also possible to
    create decorators using classes instead. After all, a function is just a callable
    object and a class can implement the callable interface as well. The following
    decorator works similarly to the `debug` decorator we used earlier, but uses a
    class instead of a regular function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The only notable difference between functions and classes is that `functools.wraps`
    is now replaced with `functools.update_wrapper` in the `__init__` method.
  prefs: []
  type: TYPE_NORMAL
- en: Decorating class functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Decorating class functions is very similar to regular functions, but you need
    to be aware of the required first argument, `self`—the class instance. You have
    most likely already used a few class function decorators. The `classmethod`, `staticmethod`,
    and `property` decorators for example, are used in many different projects. To
    explain how all this works, we will build our own versions of the `classmethod`,
    `staticmethod`, and `property` decorators. First, let''s look at a simple decorator
    for class functions to show the difference from regular decorators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As is the case with regular functions, the class function decorator now gets
    passed along `self` as the instance. Nothing unexpected!
  prefs: []
  type: TYPE_NORMAL
- en: Skipping the instance – classmethod and staticmethod
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The difference between a `classmethod` and a `staticmethod` is fairly simple.
    The `classmethod` passes a class object instead of a class instance (`self`),
    and `staticmethod` skips both the class and the instance entirely. This effectively
    makes `staticmethod` very similar to a regular function outside of a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we recreate `classmethod` and `staticmethod`, we need to take a look
    at the expected behavior of these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that calling `some_instancemethod` without an instance results in an error
    whereby `self` is missing. As expected (since we didn't instantiate the class
    in that case), for the version with the arguments, it seems to work but it is
    actually broken. This is because the first argument is now assumed to be `self`.
    This is obviously incorrect in this case, where you pass an integer, but if you
    had passed along some other class instance, this could be a source of very strange
    bugs. Both `classmethod` and `staticmethod` handle this correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can continue with decorators, you need to be aware of how Python
    descriptors function. Descriptors can be used to modify the binding behavior of
    object attributes. This means that if a descriptor is used as the value of an
    attribute, you can modify which value is being set, get, and deleted when these
    operations are called on the attribute. Here is a basic example of this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, whenever we set or get values from `more_spam`, it actually
    calls `__get__` or `__set__` on `MoreSpam`. A very useful feat for automatic conversions
    and type checking, the `property` decorator we will see in the next paragraph
    is just a more convenient implementation of this technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how descriptors work, we can continue with creating the `classmethod`
    and `staticmethod` decorators. For these two, we simply need to modify `__get__`
    instead of `__call__` so that we can control which type of instance (or none at
    all) is passed along:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `ClassMethod` decorator still features a sub-function to actually produce
    a working decorator. Looking at the function, you can most likely guess how it
    functions. Instead of passing `instance` as the first argument to `self.method`,
    it passes `cls`.
  prefs: []
  type: TYPE_NORMAL
- en: '`StaticMethod` is even simpler, because it completely ignores both the `instance`
    and the `cls`. It can just return the original method unmodified. Because it returns
    the original method without any modifications, we have no need for the `functools.wraps`
    call either.'
  prefs: []
  type: TYPE_NORMAL
- en: Properties – smart descriptor usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `property` decorator is probably the most used decorator in Python land.
    It allows you to add getters/setters to existing instance properties so that you
    can add validators and modify your values before setting them to your instance
    properties. The `property` decorator can be used both as an assignment and as
    a decorator. The following example shows both syntaxes so that we know what to
    expect from the `property` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `property` decorator works only if the class inherits `object`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to how we implemented the `classmethod` and `staticmethod` decorators,
    we need the Python descriptors again. This time, we require the full power of
    the descriptors, however—not just `__get__` but `__set__` and `__delete__` as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, most of the `Property` implementation is simply an implementation
    of the descriptor methods. The `getter`, `setter`, and `deleter` functions are
    simply shortcuts for making the usage of the decorator possible, which is why
    we have to `return self` if no `instance` is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, there are more methods of achieving this effect. In the previous
    paragraph, we saw the bare descriptor implementation, and in our previous example,
    we saw the property decorator. A somewhat more generic solution for a class is
    to implement `__getattr__` or `__getattribute__`. Here''s a simple demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `__getattr__` method looks for the key in `instance.__dict__` first and
    is called only if it does not exist. That's why we never see a `__getattr__` for
    the registry attribute. The `__getattribute__` method is called in all cases,
    which makes it a bit more dangerous to use. With the `__getattribute__` method,
    you will need a specific exclusion for `registry` since it will be executed recursively
    if you try to access `self.registry`.
  prefs: []
  type: TYPE_NORMAL
- en: There is rarely a need to look at descriptors, but they are used by several
    internal Python processes, such as the `super()` method when inheriting classes.
  prefs: []
  type: TYPE_NORMAL
- en: Decorating classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python 2.6 introduced the class decorator syntax. As is the case with the function
    decorator syntax, this is not really a new technique either. Even without the
    syntax, a class can be decorated simply by executing `DecoratedClass = decorator(RegularClass)`.
    After the previous paragraphs, you should be familiar with writing decorators.
    Class decorators are no different from regular ones, except for the fact that
    they take a class instead of a function. As is the case with functions, this happens
    at declaration time and *not* at instantiating/calling time.
  prefs: []
  type: TYPE_NORMAL
- en: Because there are quite a few alternative ways to modify how classes work, such
    as standard inheritance, mixins, and metaclasses (more about that in [Chapter
    8](ch08.html "Chapter 8. Metaclasses – Making Classes (Not Instances) Smarter"),
    *Metaclasses – Making Classes (Not Instances) Smarter*), class decorators are
    never strictly needed. This does not reduce their usefulness, but it does offer
    an explanation of why you will most likely not see too many examples of class
    decorating in the wild.
  prefs: []
  type: TYPE_NORMAL
- en: Singletons – classes with a single instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Singletons are classes that always allow only a single instance to exist. So,
    instead of getting an instance specifically for your call, you always get the
    same one. These can be very useful for things such as a database connection pool,
    where you don''t want to keep opening connections all of the time but want to
    reuse the original ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the `a is b` comparison, both objects have the same identity,
    so we can conclude that they are indeed the same object. As is the case with regular
    decorators, due to the `functools.wraps` functionality, we can still access the
    original class through `Spam.__wrapped__` if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `is` operator compares objects by identity, which is implemented as the
    memory address in CPython. If `a is b` returns `True`, we can conclude that both
    `a` and `b` are the same instance.
  prefs: []
  type: TYPE_NORMAL
- en: Total ordering – sortable classes the easy way
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At some point or the other, you have probably needed to sort data structures.
    While this is easily achievable using the key parameter to the `sorted` function,
    there is a more convenient way if you need to do this often—by implementing the
    `__gt__`, `__ge__`, `__lt__`, `__le__`, and `__eq__` functions. That seems a bit
    verbose, doesn''t it? If you want the best performance, it''s still a good idea,
    but if you can take a tiny performance hit and some slightly more complicated
    stack traces, then `total_ordering` might be a nice alternative. The `total_ordering`
    class decorator can implement all required sort functions based on a class that
    possesses an `__eq__` function and one of the comparison functions (`__lt__`,
    `__le__`, `__gt__`, or `__ge__`). This means you can seriously shorten your function
    definitions. Let''s compare the regular one and the one using the `total_ordering`
    decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you might be wondering, "Why isn''t there a class decorator to make a
    class sortable using a specified key property?" Well, that might indeed be a good
    idea for the `functools` library but it isn''t there yet. So let''s see how we
    would implement something like it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Certainly, this greatly simplifies the making of a sortable class. And if you
    would rather have your own key function instead of `getattr`, it's even easier.
    Simply replace the `getattr(self, attr)` call with `key_function(self)`, do that
    for `other` as well, and change the argument for the decorator to your function.
    You can even use that as the base function and implement `sort_by_attribute` by
    simply passing a wrapped `getattr` function.
  prefs: []
  type: TYPE_NORMAL
- en: Useful decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the ones already mentioned in this chapter, Python comes bundled
    with a few other useful decorators. There are some that aren't in the standard
    library (yet?).
  prefs: []
  type: TYPE_NORMAL
- en: Single dispatch – polymorphism in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you've used C++ or Java before, you're probably used to having ad hoc polymorphism
    available—different functions being called depending on the argument types. Python
    being a dynamically typed language, most people would not expect the possibility
    of a single dispatch pattern. Python, however, is a language that is not only
    dynamically typed but also strongly typed, which means we can rely on the type
    we receive.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A dynamically typed language does not require strict type definitions. On the
    other hand, a language such as C would require the following to declare an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Python simply accepts that your value has a type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As opposed to languages such as JavaScript and PHP, however, Python does very
    little implicit type conversion. In Python, the following will return an error,
    whereas JavaScript would execute it without any problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In Python, the result is a `TypeError`. In Javascript, it's `'spam5'`.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of single dispatch is that depending on the type you pass along, the
    correct function is called. Since `str + int` results in an error in Python, this
    can be very convenient to automatically convert your arguments before passing
    them to your function. This can be useful to separate the actual workings of your
    function from the type conversions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Python 3.4, there is a decorator that makes it easily possible to implement
    the single dispatch pattern in Python. For one of those cases that you need to
    handle a specific type different from the normal execution. Here is the basic
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: See how, depending on the type, the other functions were called? This pattern
    can be very useful for reducing the complexity of a single function that takes
    several types of argument.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When naming the functions, make sure that you do not overwrite the original
    `singledispatch` function. If we had named `str_printer` as just `printer`, it
    would overwrite the initial `printer` function. This would make it impossible
    to access the original `printer` function and make all `register` operations after
    that fail as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, a slightly more useful example—differentiating between a filename and
    a file handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: So now we have a single `write_as_json` function; it calls the right code depending
    on the type. If it's an `str` or `bytes` object, it will automatically open the
    file and call the regular version of `write_as_json`, which accepts file objects.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a decorator that does this is not that hard to do, of course, but it's
    still quite convenient to have it in the base library. It most certainly beats
    a couple of `isinstance` calls in your function. To see which function will be
    called, you can use the `write_as_json.dispatch` function with a specific type.
    When passing along an `str`, you will get the `write_as_json_filename` function.
    It should be noted that the name of the dispatched functions is completely arbitrary.
    They are accessible as regular functions, of course, but you can name them anything
    you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the registered types, you can access the registry, which is a dictionary,
    through `write_as_json.registry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Contextmanager, with statements made easy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the `contextmanager` class, we can make the creation of a context wrapper
    very easy. Context wrappers are used whenever you use a `with` statement. One
    example is the open function, which works as a context wrapper as well, allowing
    you to use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s just assume for now that the `open` function is not usable as a context
    manager and that we need to build our own function to do this. The standard method
    of creating a context manager is by creating a class that implements the `__enter__`
    and `__exit__` methods, but that''s a bit verbose. We can have it shorter and
    simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Simple, right? However, I should mention that for this specific case—the closing
    of objects—there is a dedicated function in `contextlib`, and it is even easier
    to use. Let''s demonstrate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: For a `file` object, this is of course not needed since it already functions
    as a context manager. However, some objects such as requests made by `urllib`
    don't support automatic closing in that manner and benefit from this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'But wait; there''s more! In addition to being usable in a `with` statement,
    the results of a `contextmanager` are actually usable as decorators since Python
    3.2\. In older Python versions, it was simply a small wrapper, but since Python
    3.2 it''s based on the `ContextDecorator` class, which makes it a decorator. The
    previous decorator isn''t really suitable for that task since it yields a result
    (more about that in [Chapter 6](ch06.html "Chapter 6. Generators and Coroutines
    – Infinity, One Step at a Time"), *Generators and Coroutines – Infinity, One Step
    at a Time*), but we can think of other functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: There are quite a few nice use cases for this, but at the very least, it's just
    a convenient way to wrap a function in a context without all the (nested) `with`
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: Validation, type checks, and conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While checking for types is usually not the best way to go in Python, at times
    it can be useful if you know that you will need a specific type (or something
    that can be cast to that type). To facilitate this, Python 3.5 introduces a type
    hinting system so that you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Python 3.5 is not that common yet, here''s a decorator that achieves
    the same with more advanced type checking. To allow for this type of checking,
    some magic has to be used, specifically the usage of the `inspect` module. Personally,
    I am not a great fan of inspecting code to perform tricks like these, as they
    are easy to break. This piece of code actually breaks when a regular decorator
    (one that doesn''t copy `argspec`) is used between the function and this decorator,
    but it''s a nice example nonetheless:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of the `inspect` magic, I''m still not sure whether I would recommend
    using the decorator like this. Instead, I would opt for a simpler version that
    uses no `inspect` whatsoever and simply parses the arguments from `kwargs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: However, as demonstrated, supporting both `args` and `kwargs` is not impossible
    as long as you keep in mind that `__signature__` is not copied by default. Without
    `__signature__`, the inspect module won't know which parameters are allowed and
    which aren't.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The missing `__signature__` issue is currently being discussed and might be
    solved in a future Python version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bugs.python.org/issue23764](http://bugs.python.org/issue23764).'
  prefs: []
  type: TYPE_NORMAL
- en: Useless warnings – how to ignore them
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generally when writing Python, warnings are very useful the first time when
    you''re actually writing the code. When executing it, however, it is not useful
    to get that same message every time you run your script/application. So, let''s
    create some code that allows easy hiding of the expected warnings, but not all
    of them so that we can easily catch new ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Using this method, we can catch the first (expected) warning and still see the
    second (not expected) warning.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter showed us some of the places where decorators can be used to make
    our code simpler and add some fairly complex behavior to very simple functions.
    Truthfully, most decorators are more complex than the regular function would have
    been by simply adding the functionality directly, but the added advantage of applying
    the same pattern to many functions and classes is generally well worth it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decorators have so many uses to make your functions and classes smarter and
    more convenient to use:'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Argument convenience (pre-filling or converting arguments)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output convenience (converting the output to a specific type)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most important takeaway of this chapter should be to never forget `functools.wraps`
    when wrapping a function. Debugging decorated functions can be rather difficult
    because of (unexpected) behavior modification, but losing attributes as well can
    make that problem much worse.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will show us how and when to use `generators` and `coroutines`.
    This chapter has already shown us the usage of the `with` statement slightly,
    but `generators` and `coroutines` go much further with this. We will still be
    using decorators often though, so make sure you have a good understanding of how
    they work.
  prefs: []
  type: TYPE_NORMAL
