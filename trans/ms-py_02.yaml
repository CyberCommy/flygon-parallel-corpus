- en: Chapter 2. Pythonic Syntax, Common Pitfalls, and Style Guide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The design and development of the Python programming language have always been
    in the hands of its original author, Guido van Rossum, in many cases lovingly
    referred to as the **Benevolent Dictator For Life** (**BDFL**). Even though van
    Rossum is thought to have a time machine (he has repeatedly answered feature requests
    with "I just implemented that last night": [http://www.catb.org/jargon/html/G/Guido.html](http://www.catb.org/jargon/html/G/Guido.html)),
    he is still just a human and needs help with the maintenance and development of
    Python. To facilitate that, the **Python Enhancement Proposal** (**PEP**) process
    has been developed. This process allows anyone to submit a PEP with a technical
    specification of the feature and a rationale to defend its usefulness. After a
    discussion on the Python mailing lists and possibly some improvements, the BDFL
    will make a decision to accept or reject the proposal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python style guide (`PEP 8`: [https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/))
    was once submitted as one of those PEPs, and it is has been accepted and improved
    regularly since. It has a lot of great and widely accepted conventions as well
    as a few disputed ones. Especially, the maximum line length of 79 characters is
    a topic of many discussions. Limiting a line to 79 characters does have some merits,
    however. In addition to this, while just the style guide itself does not make
    code Pythonic, as "The Zen of Python" (`PEP 20`: [https://www.python.org/dev/peps/pep-0020/](https://www.python.org/dev/peps/pep-0020/))
    elegantly says: "Beautiful is better than ugly." `PEP 8` defines how code should
    be formatted in an exact way, and `PEP 20` is more of a philosophy and mindset.'
  prefs: []
  type: TYPE_NORMAL
- en: The common pitfalls are a list of common mistakes made, varying from beginner
    mistakes to advanced ones. They range from passing a list or dictionary (which
    are mutable) as arguments to late-binding problems in closures. An even more important
    issue is how to work around circular imports in a clean way.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the techniques used in the examples in this chapter might be a bit too
    advanced for such an early chapter, but please don't worry. This chapter is about
    style and common pitfalls. The inner workings of the techniques used will be covered
    in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Code style (`PEP 8`, `pyflakes`, `flake8`, and more)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common pitfalls (lists as function arguments, pass by value versus pass by reference,
    and inheritance behavior)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The definition of Pythonic code is highly subjective and mainly reflects the
    opinion of this author. When working on a project, it is more important to stay
    consistent with the coding styles of that project than with the coding guidelines
    given by Python or this book.
  prefs: []
  type: TYPE_NORMAL
- en: Code style – or what is Pythonic code?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Pythonic code*—when you first hear of it, you might think it is a programming
    paradigm, similar to object-oriented or functional programming. While some of
    it could be considered as such, it is actually more of a design philosophy. Python
    leaves you free to choose to program in an object-oriented, procedural, functional,
    aspect-oriented or even logic-oriented way. These freedoms make Python a great
    language to write in, but as always, freedom has the drawback of requiring a lot
    of discipline to keep the code clean and readable. The `PEP8` standard tells us
    how to format code, but there is more to Pythonic code than syntax alone. That
    is what the Pythonic philosophy (`PEP20`) is all about, code that is:'
  prefs: []
  type: TYPE_NORMAL
- en: Clean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beautiful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of these sound like common sense, and I think they should be. There are
    cases however, where there is not a single obvious way to do it (unless you're
    Dutch, of course, as you'll read later in this chapter). That is the goal of this
    chapter—to learn what code is beautiful and why certain decisions have been made
    in the Python style guide.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some programmers once asked Guido van Rossum whether Python would ever support
    braces. Since that day, braces have been available through a `__future__` import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Formatting strings – printf-style or str.format?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has supported both `printf-style` (`%`) and `str.format` for a long time,
    so you are most likely familiar with both already.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within this book, `printf-style` formatting will be used for a few reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The most important reason is that it comes naturally to me. I have been using
    `printf` in many different programming languages for about 20 years now.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `printf` syntax is supported in most programming languages, which makes
    it familiar for a lot of people.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While only relevant for the purposes of the examples in this book, it takes
    up slightly less space, requiring less formatting changes. As opposed to monitors,
    books have not gotten wider over the years.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general most people recommend `str.format` these days, but it mainly comes
    down to preference. The `printf-style` is simpler, while the `str.format` method
    is more powerful.
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to learn more about how `printf-style` formatting can be replaced
    with `str.format` (or the other way around, of course), then I recommend the PyFormat
    site at [https://pyformat.info/](https://pyformat.info/).
  prefs: []
  type: TYPE_NORMAL
- en: PEP20, the Zen of Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the Pythonic philosophy can be explained through PEP20\. Python has
    a nice little Easter egg to always remind you of `PEP20`. Simply type `import
    this` in a Python console and you will get the `PEP20` lines. To quote `PEP20`:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Long time Pythoneer Tim Peters succinctly channels the BDFL''s guiding principles
    for Python''s design into 20 aphorisms, only 19 of which have been written down."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The next few paragraphs will explain the intentions of these 19 lines.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The examples within the PEP20 section are not necessarily all identical in working,
    but they do serve the same purpose. Many of the examples here are fictional and
    serve no purpose other than explaining the rationale of the paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: 'For clarity, let''s see the output of `import this` before we begin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Beautiful is better than ugly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While beauty is quite subjective, there are some Python style rules to adhere
    to: limiting line lengths, keeping statements on separate lines, splitting imports
    on separate lines, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, instead of a somewhat complex function such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Or this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Just do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Simpler, easier to read, and a bit more beautiful!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These examples are not identical in results. The first two return lists whereas
    the last returns a generator. Generators will be discussed more thoroughly in
    [Chapter 6](ch06.html "Chapter 6. Generators and Coroutines – Infinity, One Step
    at a Time"), *Generators and Coroutines – Infinity, One Step at a Time*.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit is better than implicit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imports, arguments, and variable names are just some of the many cases where
    explicit code is far easier to read at the cost of a little bit more effort and/or
    verbosity when writing the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: While this saves you some typing, it becomes quite difficult to see where `some_function`
    is defined. Is it defined in `foo`? In `bar`? Perhaps in both modules? There are
    editors with advanced introspection that can help you here, but why not keep it
    explicit so that everyone (even when simply viewing the code online) can see what
    it's doing?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The added benefit is that we can explicitly call the function from either `spam`
    or `eggs` here, and everyone will have a better idea what the code does.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same goes for functions with `*args` and `**kwargs`. They can be very useful
    at times, but they do have the downside of making it less obvious which arguments
    are valid for a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Documentation can obviously help for cases like these and I don't disagree with
    the usage of `*args` and `**kwargs` in general, but it is definitely a good idea
    to keep at least the most common arguments explicit. Even when it requires you
    to repeat the arguments for a parent class, it just makes the code that much clearer.
    When refactoring the parent class in future, you'll know whether there are subclasses
    that still use some parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Simple is better than complex
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*"Simple is better than complex. Complex is better than complicated."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The most important question to ask yourself when starting a new project is:
    how complex does it need to be?'
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's assume that we've written a small program and now we need
    to store a bit of data. What options do we have here?
  prefs: []
  type: TYPE_NORMAL
- en: A full database server, such as PostgreSQL or MySQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple file system database, such as SQLite or AnyDBM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flat file storage, such as CSV and TSV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structured storage, such as JSON, YAML, or XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serialized Python, such as Pickle or Marshal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of these options have their own use cases as well as advantages and disadvantages
    depending on the use case:'
  prefs: []
  type: TYPE_NORMAL
- en: Are you storing a lot of data? Then full database servers and flat file storage
    are generally the most convenient options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should it be easily portable to different systems without any package installation?
    That makes anything besides full database servers convenient options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we need to search the data? This is much easier using one of the database
    systems, both filesystem and full servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there other applications that need to be able to edit the data? That makes
    universal formats such as flat file storage and the structured storage convenient
    options, but excludes serialized Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Many questions! But the most important one is: how complex does it need to
    be? Storing data in a `pickle` file is something you can do in three lines, while
    connecting to a database (even with SQLite) will be more complicated and, in many
    cases, not needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Versus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: These examples are far from identical, of course, as one stores a complete data
    object whereas the other simply stores some key/value pairs within a SQLite database.
    That is not the point, however. The point is that the code is far more complex
    while it is actually less versatile in many cases. With proper libraries, this
    can be simplified, but the basic premise stays the same. Simple is better than
    complex and if the complexity is not needed, it's better to avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: Flat is better than nested
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nested code quickly becomes unreadable and hard to understand. There are no
    strict rules here, but generally when you have three levels of nested loops, it
    is time to refactor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just take a look the following example, which prints a list of two-dimensional
    matrices. While nothing is specifically wrong here, splitting it into a few more
    functions might make it easier to understand the purpose and easier to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The somewhat flatter version is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This example might be a bit convoluted, but the idea is sound. Having deeply
    nested code can easily become very unreadable.
  prefs: []
  type: TYPE_NORMAL
- en: Sparse is better than dense
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whitespace is generally a good thing. Yes, it will make your files longer and
    your code will take more space, but it can help a lot with readability if you
    split your code logically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'While technically correct, this is not all that readable. I''m certain that
    it would take me some effort to find out what the code actually does and what
    number it would print without trying it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Still, this is not the best code, but at least it's a bit more obvious what
    is happening in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Readability counts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Shorter does not always mean easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the short version has a certain beauty in conciseness, I personally
    find the following far more beautiful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Practicality beats purity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*"Special cases aren''t special enough to break the rules. Although practicality
    beats purity."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Breaking the rules can be tempting at times, but it tends to be a slippery slope.
    Naturally, this applies to all rules. If your quick fix is going to break the
    rules, you should really try to refactor it immediately. Chances are that you
    won't have the time to fix it later and will regret it.
  prefs: []
  type: TYPE_NORMAL
- en: No need to go overboard though. If the solution is good enough and refactoring
    would be much more work, then choosing the working method might be better. Even
    though all of these examples pertain to imports, this guideline applies to nearly
    all cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent long lines, imports can be made shorter by using a few methods,
    adding a backslash, adding parentheses, or just shortening the imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This case can easily be avoided by just following `PEP8` (one import per line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: But what about really long imports?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes… even though adding a backslash for imports is generally not recommended,
    there are some cases where it''s still the best option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Errors should never pass silently
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*"Errors should never pass silently. Unless explicitly silenced."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To paraphrase Jamie Zawinsky: Some people, when confronted with an error, think
    "I know, I''ll use a `try`/`except`/`pass` block." Now they have two problems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bare or too broad exception catching is already a bad idea. Not passing them
    along will make you (or some other person working on the code) wonder for ages
    what is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you really need to catch all errors, be very explicit about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Or even better, catch it specifically and add a sane default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is actually even more complicated. What about blocks of code that
    depend on whatever is happening within the exception? For example, consider the
    following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If `ValueError` is raised, which line is causing it? Is it `int(user_input)`,
    `do_some_processing(value)`, or `do_some_other_processing(value)`? With silent
    catching of the error, there is no way to know when regularly executing the code,
    and this can be quite dangerous. If for some reason the processing of the other
    functions changes, it becomes a problem to handle exceptions in this way. So,
    unless it was actually intended to behave like that, use this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the face of ambiguity, refuse the temptation to guess
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While guesses will work in many cases, they can bite you if you're not careful.
    As already demonstrated in the "explicit is better than implicit" paragraph, when
    having a few `from ... import *`, you cannot always be certain which module is
    providing you the variable you were expecting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ambiguity should generally be avoided, so guessing can be avoided. Clear and
    unambiguous code generates fewer bugs. A useful case where ambiguity is likely
    is function calling. Take, for example, the following two function calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'They could be the same, but they might also not be. It''s impossible to say
    without seeing the function. If the function were implemented in the following
    way, the results would be vastly different between the two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: I'm not saying you should use keyword arguments in all cases, but if there are
    many arguments involved and/or hard-to-identify parameters (such as numbers),
    it would be a good idea. Instead of using keyword arguments, you can choose logical
    variable names to pass the arguments as well, as long as the meaning is clearly
    conveyed from the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following is a similar call that uses custom variable names
    to convey the intent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: One obvious way to do it
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*"There should be one—and preferably only one—obvious way to do it. Although
    that way may not be obvious at first unless you''re Dutch."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In general, after thinking about a difficult problem for a while, you will find
    that there is one solution that is clearly preferable over the alternatives. There
    are cases where this is not the case, however, and in that case, it can be useful
    if you're Dutch. The joke here is that Guido van Rossum, the BDFL and original
    author of Python, is Dutch (as is yours truly).
  prefs: []
  type: TYPE_NORMAL
- en: Now is better than never
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*"Now is better than never. Although never is often better than *right* now."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It''s better to fix a problem right now than push it into the future. There
    are cases, however, where fixing it right away is not an option. In those cases,
    a good alternative can be to mark a function as deprecated instead so that there
    is no chance of accidentally forgetting the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Hard to explain, easy to explain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*"If the implementation is hard to explain, it''s a bad idea. If the implementation
    is easy to explain, it may be a good idea."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As always, keep things as simple as you can. While complicated code can be nice
    to test with, it is more prone to bugs. The simpler you can keep things, the better.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces are one honking great idea
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*"Namespaces are one honking great idea—let''s do more of those!"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Namespaces can make code a lot clearer to use. Naming them properly makes it
    even better. For example, what does the following line of code do?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Not too clear, right?
  prefs: []
  type: TYPE_NORMAL
- en: How about the version with the namespace?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: And now we do understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give an example of a namespace, the full length of which renders it impractical
    to use, we will take a look at the `User` class in Django. Within the Django framework,
    the `User` class is stored in `django.contrib.auth.models.User`. Many projects
    use the object in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'While this is fairly clear, it might make someone think that the `User` class
    is local to the current class. Doing the following instead lets people know that
    it is in a different module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This quickly clashes with other models'' imports though, so personally I would
    recommend the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another alternative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we should have some idea of what the Pythonic ideology is about. Creating
    code that is:'
  prefs: []
  type: TYPE_NORMAL
- en: Beautiful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unambiguous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit enough
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not completely void of whitespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let's move on to some more examples of how to create beautiful, readable,
    and simple code using the Python style guide.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining PEP8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous paragraphs have already shown a lot of examples using `PEP20` as
    a reference, but there are a few other important guidelines to note as well. The
    PEP8 style guide specifies the standard Python coding conventions. Simply following
    the PEP8 standard doesn't make your code Pythonic though, but it is most certainly
    a good start. Which style you use is really not that much of a concern as long
    as you are consistent. The only thing worse than not using a proper style guide
    is being inconsistent with it.
  prefs: []
  type: TYPE_NORMAL
- en: Duck typing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Duck typing is a method of handling variables by behavior. To quote Alex Martelli
    (one of my Python heroes, also nicknamed the MartelliBot by many):'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Don''t check whether it IS-a duck: check whether it QUACKS-like-a duck, WALKS-like-a
    duck, etc, etc, depending on exactly what subset of duck-like behaviour you need
    to play your language-games with. If the argument fails this specific-ducklyhood-subset-test,
    then you can shrug, ask "why a duck?"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In many cases, when people make a comparison such as `if spam != '':`, they
    are actually just looking for anything that is considered a true value. While
    you can compare the value to the string value `''`, you generally don't have to
    make it so specific. In many cases, simply doing `if spam:` is more than enough
    and actually functions better.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following lines of code use the value of `timestamp` to generate
    a filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Because it is named `timestamp`, one might be tempted to check whether it is
    actually a `date` or `datetime` object, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'While this is not inherently wrong, comparing types is considered a bad practice
    in Python, as there is oftentimes no need for it. In Python, duck typing is preferred
    instead. Just try converting it to a string and don''t care what it actually is.
    To illustrate how little difference this can make for the end result, see the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As you might expect, the result is identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The same goes for converting a number to a float or an integer; instead of enforcing
    a certain type, just require certain features. Need something that can pass as
    a number? Just try to convert to `int` or `float`. Need a `file` object? Why not
    just check whether there is a `read` method with `hasattr`?
  prefs: []
  type: TYPE_NORMAL
- en: 'So, don''t do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, just use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And instead of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Simply use the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Differences between value and identity comparisons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several methods of comparing objects in Python, the standard greater
    than and less than, equal and unequal. But there are actually a few more, and
    one of them is a bit special. That''s the identity comparison operator: instead
    of using `if spam == eggs`, you use `if spam is eggs`. The big difference is that
    one compares the value and the other compares the identity. This sounds a little
    vague, but it''s actually fairly simple. At least within the CPython implementation,
    the memory address is being compared, which means that it is one of the lightest
    lookups you can get. Whereas a value needs to make sure that the types are comparable
    and perhaps check the sub-values, the identity check just checks whether the unique
    identifier is the same.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you've ever written Java, you should be familiar with this principle. In
    Java, a regular string comparison (`spam == eggs`) will use the identity instead
    of the value. To compare the value, you need to use `spam.equals(eggs)` to get
    the correct results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'While the values are the same, the identities are different. The actual result
    from this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The catch is that Python keeps an internal array of integer objects for all
    integers between `-5` and `256`; that's why it works for `256` but not for `257`.
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder why anyone would ever want to use `is` instead of `==`. There
    are multiple valid answers; depending on the case, one is correct and the other
    isn't. But performance can also be a very important consideration. The basic guideline
    is that when comparing Python singletons such as `True`, `False`, and `None`,
    always compare using `is`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the performance consideration, think of the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: When doing `spam == eggs`, this will compare every item in both lists to each
    other, so effectively it is doing 1,000,000 comparisons internally. Compare this
    with only one simple identity check when using `spam is eggs`.
  prefs: []
  type: TYPE_NORMAL
- en: To look at what Python is actually doing internally with the `is` operator,
    you can use the `id` function. When executing `if spam is eggs`, Python will actually
    execute `if id(spam) == id(eggs)` internally.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Coming from other languages, one might be tempted to use `for` loops or even
    `while` loops to process the items of a `list`, `tuple`, `str`, and so on. While
    valid, it is more complex than needed. For example, consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'While this can be written even shorter, it''s generally not recommended, as
    it does not improve readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The last option might be clear to some but not all. Personally, I prefer to
    limit the usage of list comprehensions, dict comprehensions, and map and filter
    statements for when the result is actually being stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: But still, only if it doesn't hurt the readability of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this bit of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Instead of putting everything in the list comprehension, why not split it into
    a few functions?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: While this code is a bit longer, I would personally argue that it's more readable
    this way.
  prefs: []
  type: TYPE_NORMAL
- en: Maximum line length
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many Python programmers think 79 characters is too constricting and just keep
    the lines longer. While I am not going to argue for 79 characters specifically,
    setting a low and fixed limit such as 79 or 99 is a good idea. While monitors
    get wider and wider, limiting your lines can still help a lot with readability
    and it allows you to put multiple files next to each other. It's a regular occurrence
    for me to have four Python files opened next to each other. If the line width
    were more than 79 characters, that simply wouldn't fit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PEP8 guide tells us to use backslashes in cases where lines get too long.
    While I agree that backslashes are preferable over long lines, I still think they
    should be avoided if possible. Here''s an example from PEP8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using backslashes, I would reformat it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Or perhaps the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Not always an option, of course, but it's a good consideration to keep the code
    short and readable. It actually gives a bonus of adding more information to the
    code. If, instead of `filename_1`, you use a name that conveys the goal of the
    filename, it immediately becomes clearer what you are trying to do.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying code quality, pep8, pyflakes, and more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many tools for checking code quality in Python. The simplest ones,
    such as `pep8`, just validate a few simple `PEP8` errors. The more advanced ones,
    such as `pylint`, do advanced introspections to detect potential bugs in otherwise
    working code. A large portion of what `pylint` offers is a bit over the top for
    many projects, but still interesting to look at.
  prefs: []
  type: TYPE_NORMAL
- en: flake8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `flake8` tool combines pep8, pyflakes, and McCabe to set up a quality standard
    for code. The `flake8` tool is one of the most important packages for maintaining
    code quality in my packages. All the packages that I maintain have a 100% `flake8`
    compliance requirement. It does not promise readable code, but at least it requires
    a certain level of consistency, which is very important when writing on a project
    with multiple programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Pep8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One of the simplest tools used to check the quality of Python code is the `pep8`
    package. It doesn''t check everything that is in the PEP8 standard, but it goes
    a long way and is still updated regularly to add new checks. Some of the most
    important things checked by `pep8` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Indentation, while Python will not check how many spaces you use to indent,
    it does not help with the readability of your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing whitespace, such as `spam=123`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Too much whitespace, such as `def eggs(spam = 123):`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Too many or too few blank lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Too long lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntax and indentation errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorrect and/or superfluous comparisons (`not in`, `is not`, `if spam is True`,
    and type comparisons without `isinstance`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The conclusion is that the `pep8` tool helps a lot with testing whitespace and
    some of the more common styling issues, but it is still fairly limited.
  prefs: []
  type: TYPE_NORMAL
- en: pyflakes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is where pyflakes comes in. pyflakes is a bit more intelligent than `pep8`
    and warns you about style issues such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Unused imports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wildcard imports (`from module import *`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorrect `__future__` imports (after other imports)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But more importantly, it warns about potential bugs, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Redefinitions of names that were imported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage of undefined variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Referencing variables before assignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duplicate argument names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unused local variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last bit of PEP8 is covered by the pep8-naming package. It makes sure that
    your naming is close to the standard dictated by PEP8:'
  prefs: []
  type: TYPE_NORMAL
- en: Class names as *CapWord*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function, variable, and argument names all in lowercase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constants as full uppercase and being treated as constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first argument of instance methods and class methods as *self* and *cls*,
    respectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: McCabe
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Lastly, there is the McCabe complexity. It checks the complexity of code by
    looking at the **Abstract Syntax Tree** (**AST**). It finds out how many lines,
    levels, and statements are there and warns you if your code has more complexity
    than a preconfigured threshold. Generally, you will use McCabe through `flake8`,
    but a manual call is possible as well. Using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'McCabe will give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Your maximum threshold is configurable, of course, but the default is 10\. The
    McCabe test returns a number that is influenced by parameters such as the size
    of a function, the nested depths, and a few others. If your function reaches 10,
    it might be time to refactor the code.
  prefs: []
  type: TYPE_NORMAL
- en: flake8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All of this combined is `flake8`, a tool that combines these tools and outputs
    a single report. Some of the warnings generated by `flake8` might not fit your
    taste, so each and every one of the checks can be disabled, both per file and
    for the entire project if needed. For example, I personally disable `W391` for
    all my projects, which warns about blank lines at the end of a file. This is something
    I find useful while working on code so that I can easily jump to the end of the
    file and start writing code instead of having to append a few lines first.
  prefs: []
  type: TYPE_NORMAL
- en: In general, before committing your code and/or putting it online, just run `flake8`
    from your source directory to check everything recursively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a demonstration with some poorly formatted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'It results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Pylint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`pylint` is a far more advanced—and in some cases better—code quality checker.
    The power of `pylint` does come with a few drawbacks, however. Whereas `flake8`
    is a really fast, light, and safe quality check, `pylint` has far more advanced
    introspection and is much slower for this reason. In addition, `pylint` will most
    likely give you a large number of warnings, which are irrelevant or even wrong.
    This could be seen as a flaw in `pylint`, but it''s actually more of a restriction
    of passive code analysis. Tools such as `pychecker` actually load and execute
    your code. In many cases, this is safe, but there are cases where it is not. Just
    think of what could happen when executing a command that deletes files.'
  prefs: []
  type: TYPE_NORMAL
- en: While I have nothing against `pylint`, in general I find that most important
    problems are handled by `flake8`, and others can easily be avoided with some proper
    coding standards. It can be a very useful tool if configured correctly, but without
    configuration, it is very verbose.
  prefs: []
  type: TYPE_NORMAL
- en: Common pitfalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is a language meant to be clear and readable without any ambiguities
    and unexpected behaviors. Unfortunately, these goals are not achievable in all
    cases, and that is why Python does have a few corner cases where it might do something
    different than what you were expecting.
  prefs: []
  type: TYPE_NORMAL
- en: This section will show you some issues that you might encounter when writing
    Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Scope matters!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few cases in Python where you might not be using the scope that
    you are actually expecting. Some examples are when declaring a class and with
    function arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Function arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following example shows a case that breaks due to a careless choice in
    default parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'You would probably expect the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'But it''s actually this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The reason is that `list_` and `dict_` are actually shared between multiple
    calls. The only time this is actually useful is if you are doing something hacky,
    so please avoid using mutable objects as default parameters in a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The safe alternative of the same example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Class properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The problem also occurs when defining classes. It is very easy to mix class
    attributes and instance attributes. Especially when coming from other languages
    such as C#, this can be confusing. Let''s illustrate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the function arguments, the list and dictionaries are shared. So, the
    output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'A better alternative is to initialize the mutable objects within the `__init__`
    method of the class. This way, they are not shared between instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Another important thing to note when dealing with classes is that a class property
    will be inherited, and that''s where things might prove to be confusing. When
    inheriting, the original properties will stay (unless overwritten), even in subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: While this is to be expected due to inheritance, someone else using the class
    might not suspect the variable to change in the meantime. After all, we modified
    `A.spam`, not `B.spam`.
  prefs: []
  type: TYPE_NORMAL
- en: There are two easy ways to prevent this. It is obviously possible to simply
    set `spam` for every class separately. But the better solution is never to modify
    class properties. It's easy to forget that the property will change in multiple
    locations, and if it has to be modifiable anyway, it's usually better to put it
    in an instance variable instead.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying variables in the global scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common problem when accessing variables from the global scope is that setting
    a variable makes it local, even when accessing the global variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'But the following does not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that `spam += 1` actually translates to `spam = spam + 1`, and
    anything containing `spam =` makes the variable local to your scope. Since the
    local variable is being assigned at that point, it has no value yet and you are
    trying to use it. For these cases, there is the `global` statement, although I
    would really recommend that you avoid globals altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Overwriting and/or creating extra built-ins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it can be useful in some cases, generally you will want to avoid overwriting
    global functions. The `PEP8` convention for naming your functions—similar to built-in
    statements, functions, and variables—is to use a trailing underscore.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, do not use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'For lists and such, this is just a good convention. For statements such as
    `from`, `import`, and `with`, it''s a requirement. Forgetting about this can lead
    to very confusing errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'If you actually want to define a built-in that is available everywhere, it''s
    possible. For debugging purposes, I''ve been known to add this code to a project
    while developing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Much too hacky for production code, but it is still useful when working on a
    large project where you need print statements to debug. Alternative (and better)
    debugging solutions can be found in Chapter 11, *Debugging – Solving the Bugs*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Modifying while iterating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At one point or another, you will run into this problem: while iterating through
    mutable objects such as lists, dicts, or sets, you cannot modify them. All of
    these result in a `RuntimeError` telling you that you cannot modify the object
    during iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be avoided by copying the object. The most convenient option is by
    using the `list` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Catching exceptions – differences between Python 2 and 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With Python 3, catching an exception and storing it has been made more obvious
    with the `as` statement. The problem is that many people are still used to the
    `except Exception, variable` syntax, which doesn''t work anymore. Luckily, the
    Python 3 syntax has been backported to Python 2, so now you can use the following
    syntax everywhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Another important difference is that Python 3 makes this variable local to
    the exception scope. The result is that you need to declare the exception variable
    before the `try`/`except` block if you want to use it later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: You might expect that since we get an exception here, this works; but actually,
    it doesn't, because `exception` does not exist at the point of the `return` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Personally I would argue that the preceding code is broken in any case: what
    if there isn''t an exception somehow? It would have raised the same error. Luckily,
    the fix is simple; just write the value to a variable outside of the scope. One
    important thing to note here is that you explicitly need to save the variable
    to the parent scope. This code does not work either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We really need to save it explicitly because Python 3 automatically deletes
    anything saved with `as variable` at the end of the `except` statements. The reason
    for this is that exceptions in Python 3 contain a `__traceback__` attribute. Having
    this attribute makes it much more difficult for the garbage collector to handle
    as it introduces a recursive self-referencing cycle (*exception -> traceback ->
    exception -> traceback… ad nauseum*). To solve this, Python essentially does the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution is simple enough—luckily—but you should keep in mind that this
    can introduce memory leaks into your program. The Python garbage collector is
    smart enough to understand that the variables are not visible anymore and will
    delete it eventually, but it can take a lot more time. How the garbage collection
    actually works is covered in [Chapter 12](ch12.html "Chapter 12. Performance –
    Tracking and Reducing Your Memory and CPU Usage"), *Performance – Tracking and
    Reducing Your Memory and CPU Usage*. Here is the working version of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Late binding – be careful with closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Closures are a method of implementing local scopes in code. They make it possible
    to locally define variables without overriding variables in the parent (or global)
    scope and hide the variables from the outside scope later. The problem with closures
    in Python is that Python tries to bind its variables as late as possible for performance
    reasons. While generally useful, it does have some unexpected side effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The expected result? Should be something along the lines of this, right?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: No, unfortunately not. This is similar to how class inheritance works with properties.
    Due to late binding, the variable `i` gets called from the surrounding scope at
    call time, and not when it's actually defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'So what to do instead? As with the cases mentioned earlier, the variable needs
    to be made local. One alternative is to force immediate binding by currying the
    function with `partial`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: A better solution would be to avoid binding problems altogether by not introducing
    extra scopes (the `lambda`), that use external variables. If both `i` and `a`
    were specified as arguments to `lambda`, this will not be a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Circular imports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though Python is fairly tolerant towards circular imports, there are some
    cases where you will get errors.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume we have two files.
  prefs: []
  type: TYPE_NORMAL
- en: '`eggs.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '`spam.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `spam.py` will result in a circular `import` error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: There are a few ways to work around this. Restructuring the code is usually
    the best to go around, but the best solution depends on the problem. In the preceding
    case, it can be solved easily. Just use module imports instead of function imports
    (which I recommend regardless of circular imports).
  prefs: []
  type: TYPE_NORMAL
- en: '`eggs.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '`spam.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: An alternative solution is to move the imports within the functions so that
    they occur at runtime. This is not the prettiest solution but it does the trick
    in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: '`eggs.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '`spam.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Lastly there is the solution of moving the imports below the code that actually
    uses them. This is generally not recommended because it can make it non-obvious
    where the imports are, but I still find it preferable to having the `import` within
    the function calls.
  prefs: []
  type: TYPE_NORMAL
- en: '`eggs.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '`spam.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: And yes, there are still other solutions such as dynamic imports. One example
    of this is how the Django `ForeignKey` fields support strings instead of actual
    classes. But those are generally a really bad idea to use since they will be checked
    only at runtime. Because of this, bugs will introduce themselves only when executing
    any code that uses it instead of when modifying the code. So please try to avoid
    these whenever possible, or make sure you add proper automated tests to prevent
    unexpected bugs. Especially when they cause circular imports internally, they
    become an enormous pain to debug.
  prefs: []
  type: TYPE_NORMAL
- en: Import collisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One problem that can be extremely confusing is having colliding imports—multiple
    packages/modules with the same name. I have had more than a few bug reports on
    my packages where, for example, people tried to use my `numpy-stl` project, which
    resides in a package named `stl` from a test file named `stl.py`. The result:
    it was importing itself instead of the `stl` package. While this case is difficult
    to avoid, at least within packages, a relative import is generally a better option.
    This is because it also tells other programmers that the import comes from the
    local scope instead of another package. So, instead of writing `import spam`,
    write `from . import spam`. This way, the code will always load from the current
    package instead of any global package that happens to have the same name.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this there is also the problem of packages being incompatible
    with each other. Common names might be used by several packages, so be careful
    when installing those packages. When in doubt, just create a new virtual environment
    and try again. Doing this can save you a lot of debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter showed us what the Pythonic philosophy is all about and explained
    to us what the Zen of Python is all about. While code style is highly personal,
    Python has a few, very helpful guidelines that at least keep people mostly on
    the same page and style. In the end, we are all consenting adults; everyone has
    the right to write code as he/she sees fit. But I do request you. Please read
    through the style guides and try to adhere to them unless you have a really good
    reason not to.
  prefs: []
  type: TYPE_NORMAL
- en: With all that power comes great responsibility, and so do a few pitfalls, though
    there aren't too many. Some are tricky enough to fool me regularly and I've been
    writing Python for a long time! Python improves all the time though. Many pitfalls
    have been taken care of since Python 2, but some will always remain. For example,
    recursive imports and definitions can easily bite you in most languages that support
    them, but that doesn't mean we'll stop trying to improve Python.
  prefs: []
  type: TYPE_NORMAL
- en: A good example of the improvements in Python over the years is the collections
    module. It contains many useful collections that have been added by users because
    there was a need. Most of them are actually implemented in pure Python, and because
    of that, they are easy enough to be read by anyone. Understanding might take a
    bit more effort, but I truly believe that if you make it to the end of this book,
    you will have no problem understanding what the collections do. Fully understanding
    how the internals work is something I cannot promise though; some parts of that
    go more towards generic computer science than Python mastery.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will show you some of the collections available in Python and
    how they are constructed internally. Even though you are undoubtedly familiar
    with collections such as lists and dictionaries, you might not be aware of the
    performance characteristics involved with some of the operations. If some of the
    examples in this chapter were less than clear, you don't have to worry. The next
    chapter will at least revisit some of them, and more will come in later chapters.
  prefs: []
  type: TYPE_NORMAL
