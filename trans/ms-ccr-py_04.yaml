- en: Using the with Statement in Threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `with` statement in Python sometimes causes confusion for novice and experienced
    Python programmers alike. This chapter explains in depth the idea behind the `with`
    statement as a context manager and its usage in concurrent and parallel programming,
    specifically regarding the use of locks while synchronizing threads. This chapter
    also provides specific examples of how the `with` statement is most commonly used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of context management and the options that the `with` statement
    provides as a context manager, specifically in concurrent and parallel programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The syntax of the `with` statement and how to use it effectively and efficiently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different ways of using the `with` statement in concurrent programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a list of prerequisites for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Python 3 must be installed on your computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the GitHub repository at [https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During this chapter, we will be working with the subfolder named `Chapter04`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out the following video to see the Code in Action: [http://bit.ly/2DSGLEZ](http://bit.ly/2DSGLEZ)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Context management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The new `with` statement was first introduced in Python 2.5 and has been in
    use for quite some time. However, there still seems to be confusion regarding
    its usage, even for experienced Python programmers. The `with` statement is most
    commonly used as a context manager that properly manages resources, which is essential
    in concurrent and parallel programming, where resources are shared across different
    entities in the concurrent or parallel application.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from managing files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an experienced Python user, you have probably seen the `with` statement being
    used to open and read external files inside Python programs. Looking at this problem
    at a lower level, the operation of opening an external file in Python will consume
    a resource—in this case, a file descriptor—and your operating system will set
    a limit on this resource. This means that there is an upper limit on how many
    files a single process running on your system can open simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a quick example to illustrate this point further. Let''s take
    a look at the `Chapter04/example1.py` file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This quick program simply creates 10 text files inside the `output1` folder:
    `sample0.txt`, `sample1.txt`, ..., `sample9.txt`. What might be of more interest
    to us is the fact that the files were opened inside the `for` loop but were not
    closed—this is a bad practice in programming that we will discuss later. Now,
    let''s say we wanted to reassign the `n_files` variable to a large number—say
    10,000—as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We would get an error similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Looking closely at the error message, we can see that my laptop can only handle
    253 opened files simultaneously (as a side note, if you are working on a UNIX-like
    system, running `ulimit -n` will give you the number of files that your system
    can handle). More generally, this situation arose from what is known as **file
    descriptor leakage**. When Python opens a file inside a program, that opened file
    is essentially represented by an integer. This integer acts as a reference point
    that the program can use in order to have access to that file, while not giving
    the program complete control over the underlying file itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'By opening too many files at the same time, our program assigned too many file
    descriptors to manage the open files, hence the error message. File descriptor
    leakage can lead to a number of difficult problems—especially in concurrent and
    parallel programming—namely, unauthorized I/O operations on open files. The solution
    to this is to simply close opened files in a coordinated manner. Let''s look at
    our `Chapter04/example1.py` file in the second method. In the `for` loop, we would
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The with statement as a context manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In real-life applications, it is rather easy to mismanage opened files in your
    programs by forgetting to close them; it can sometimes also be the case that it
    is impossible to tell whether the program has finished processing a file, and
    we programmers will therefore be unable to make a decision as to when to put the
    statement to close the files appropriately. This situation is even more common
    in concurrent and parallel programming, where the order of execution between different
    elements changes frequently.
  prefs: []
  type: TYPE_NORMAL
- en: One possible solution to this problem that is also common in other programming
    languages is to use a `try...except...finally` block every time we want to interact
    with an external file. This solution still requires the same level of management
    and significant overhead and does not provide a good improvement in the ease and
    readability of our programs either. This is when the `with` statement of Python
    comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `with` statement gives us a simple way of ensuring that all opened files
    are properly managed and cleaned up when the program finishes using them. The
    most notable advantage of using the `with` statement comes from the fact that,
    even if the code is successfully executed or it returns an error, the `with` statement
    always handles and manages the opened files appropriately via context. For example,
    let''s look at our `Chapter04/example1.py` file in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: While this method accomplishes the same job as the second method we saw earlier,
    it additionally provides a cleaner and more readable way to manage the opened
    files that our program interacts with. More specifically, the `with` statement
    helps us indicate the scope of certain variables—in this case, the variables that
    point to the opened files—and hence, their context.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the third method in the preceding code, the `f` variable indicates
    the current opened file within the `with` block at each iteration of the `for`
    loop, and as soon as our program exits that `with` block (which is outside the
    scope of that `f` variable), there is no longer any other way to access it. This
    architecture guarantees that all cleanup associated with a file descriptor happens
    appropriately. The `with` statement is hence called a context manager.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of the with statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The syntax of the `with` statement can be intuitive and straightforward. With
    the purpose of wrapping the execution of a block with methods defined by a context
    manager, it consists of the following simple form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `as [target]` part of the `with` statement is actually not required,
    as we will see later on. Additionally, the `with` statement can also handle more
    than one item on the same line. Specifically, the context managers created are
    treated as if multiple `with` statements were nested inside one another. For example,
    look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is interpreted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The with statement in concurrent programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Obviously, opening and closing external files does not resemble concurrency
    very much. However, we mentioned earlier that the `with` statement, as a context
    manager, is not only used to manage file descriptors, but most resources in general.
    And if you actually found managing lock objects from the `threading.Lock()` class
    similar to managing external files while going through [Chapter 2](d36d34b5-2541-4a16-9f87-ace6cec25865.xhtml),
    *Amdahl's Law*, then this is where the comparison between the two comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: As a refresher, locks are mechanisms in concurrent and parallel programming
    that are typically used to synchronize threads in a multithreaded application
    (that is, to prevent more than one thread from accessing the critical session
    simultaneously). However, as we will discuss again in [Chapter 12](e8b97a27-3966-4a32-aae6-b8d995f4c662.xhtml),
    *Starvation*, locks are also a common source of **deadlock**, during which a thread
    **acquires** a lock but never **releases** it because of an unhandled occurrence,
    thereby stopping the entire program.
  prefs: []
  type: TYPE_NORMAL
- en: Example of deadlock handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a quick example in Python. Let''s a take look at the `Chapter04/example2.py`
    file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have a `get_data_from_file_v1()`function that takes in the
    path to an external file, reads the data from it, and appends that data to a predeclared
    list called `data`. Inside this function, a lock object called `my_lock`, which
    is also predeclared prior to the function being called, is acquired and released
    as the parameter file is read before and after, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In the main program, we will try to call `get_data_from_file_v1()` on a nonexistent
    file, which is one of the most common errors in programming. At the end of the
    program, we also acquire the lock object again. The point is to see whether our
    programming could handle the error of reading a nonexistent file appropriately
    and gracefully with just the `try...except` block that we have.
  prefs: []
  type: TYPE_NORMAL
- en: After running the script, you will notice that our program will print out the
    error message specified in the `try...except` block, `Encountered an exception...`,
    which is expected, since the file could not be found. However, the program will
    also fail to execute the rest of the code; it will never get to the last line
    of code—`print('Lock acquired.')`—and will hang forever (or until you hit *Ctrl*
    + *C* to force-quit the program).
  prefs: []
  type: TYPE_NORMAL
- en: This is a deadlock situation, which, again, occurs when `my_lock` is acquired
    inside the `get_data_from_file_v1()` function, but since our program encountered
    an error before executing `my_lock.release()`, the lock was never released. This
    in turn caused the `my_lock.acquire()` line at the end of the program to hang,
    as the lock could not be acquired in any way. Our program hence could not reach
    its last line of code, `print('Lock acquired.')`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This problem, however, could be handled with a `with` statement easily and
    effortlessly. In the `example2.py` file, simply comment out the line calling `get_data_from_file_v1()`
    and uncomment the line calling `get_data_from_file_v2()`, and you will have the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `get_data_from_file_v2()` function, we have the equivalent of a pair
    of nested `with` statements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `Lock` objects are context managers, simply using `with my_lock:` would
    ensure that the lock object is acquired and released appropriately, even if an
    exception is encountered inside the block. After running the script, you will
    have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can see that, this time, our program was able to acquire the lock and reach
    the end of the script gracefully and without errors.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `with` statement in Python offers an intuitive and convenient way to manage
    resources while ensuring that errors and exceptions are handled correctly. This
    ability to manage resources is even more important in concurrent and parallel
    programming, where various resources are shared and utilized across different
    entities—specifically, by using the `with` statement with `threading.Lock` objects
    that are used to synchronize different threads in a multithreaded application.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from better error handling and guaranteed cleanup tasks, the `with` statement
    also provides extra readability from your programs, which is one of the strongest
    features that Python offers its developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will be discussing one of the most popular uses of
    Python at the moment: web-scraping applications. We will look at the concept and
    the basic idea behind web scraping, the tools that Python provides to support
    web scraping, and how concurrency will significantly help your web-scraping applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a file descriptor and in what ways can it be handled in Python?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What problem arises when file descriptors are not handled carefully?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a lock and in what ways can it be handled in Python?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What problem arises when locks are not handled carefully?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the idea behind context managers?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What options does the `with` statement in Python provide in terms of context
    management?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Python Parallel Programming Cookbook*, by Zaccone and Giancarlo, published
    by Packt, 2015'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Improve Your Python: the with Statement and Context Managers*, Jeff Knupp
    ([https://jeffknupp.com/blog/2016/03/07/improve-your-python-the-with-statement-and-context-managers/](https://jeffknupp.com/blog/2016/03/07/improve-your-python-the-with-statement-and-context-managers/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Compound statements*, Python Software Foundation ([https://docs.python.org/3/reference/compound_stmts.html](https://docs.python.org/3/reference/compound_stmts.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
