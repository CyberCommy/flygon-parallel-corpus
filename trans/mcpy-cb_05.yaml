- en: Reading Sensor Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce you to methods that you can use to read sensor data
    from a number of sensors that come onboard with Adafruit Circuit Playground Express.
    We will cover the temperature and light sensors, as well as the motion sensor,
    and you will also learn how to make the board react to sensor events, such as
    the board being shaken or the light levels changing. Having access to this rich
    sensor data can make all sorts of projects possible. For example, you could make
    a project that makes an alarm beep if the detected temperature has exceeded a
    certain level. By learning how to read and process this sensor data, you can make
    a wide array of embedded projects a reality.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Circuit Playground Express sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading temperature readings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading brightness levels from the light sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a light meter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading data from the motion sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting a single or double tap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting a shake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beeping on a shake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit Playground Express sensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Three different hardware sensors will be used in this chapter to get sensor
    readings from the environment. The following photograph is of a thermistor, showing
    the location of the temperature sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d8b00dc3-8ddc-4693-b358-5fdd6aaffb50.png)'
  prefs: []
  type: TYPE_IMG
- en: Courtesy of adafruit.com
  prefs: []
  type: TYPE_NORMAL
- en: 'The following photograph shows the light sensor that is available on the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/67cbbbc0-96ae-4b86-b361-6a9c5aec0e37.png)'
  prefs: []
  type: TYPE_IMG
- en: Courtesy of adafruit.com
  prefs: []
  type: TYPE_NORMAL
- en: 'The following photograph shows the accelerometer, which can be used to detect
    motion, as well as tap and double tap strikes on the board:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6c2e0897-dcd6-4176-b9e7-f4a79f0ee32c.png)'
  prefs: []
  type: TYPE_IMG
- en: Courtesy of adafruit.com
  prefs: []
  type: TYPE_NORMAL
- en: Let's check our first recipe now.
  prefs: []
  type: TYPE_NORMAL
- en: Reading temperature readings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create a loop that repeatedly reads the
    current temperature from the temperature sensor and prints it out. This will let
    us experiment with the sensor and see how it reacts to changes in temperature.
    The methods in this recipe can be used whenever you need to incorporate temperature
    readings into your project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to read temperature readings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL. The output shows that the room
    temperature is around 25°C:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, use your body temperature to increase the temperature sensor readings
    by pressing your finger on the temperature sensor while you take the next reading:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The temperature should have increased by a number of degrees. If you run the
    following code, a floating-point number should be returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for a few seconds before executing the following line of code. It will
    calculate the number of seconds since you assigned the value to the start variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the following code, a list of all the local variables and their
    values should be displayed as a dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file and, when executed,
    will repeatedly print the current elapsed time and current temperature reading:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first lines of code import the Circuit Playground Express library and the
    `time` module. The `cpx` object exposes a property called `temperature`—this property
    returns the current temperature reading from the thermistor as a floating-point
    number whenever the value is accessed.
  prefs: []
  type: TYPE_NORMAL
- en: This value is expressed on the Celsius temperature scale. The start time is
    recorded so that the elapsed time can be calculated for each temperature reading.
    The script then goes into an infinite loop, calculating the elapsed time and getting
    a temperature reading for each loop iteration.
  prefs: []
  type: TYPE_NORMAL
- en: The elapsed time and temperature are printed with a tab delimiter. A 0.1-second
    delay is applied before the next iteration of the loop is started.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The temperature sensor on this device is a **negative temperature coefficient**
    (**NTC**) thermistor. This component is a resistor that changes resistance with
    a change in temperature. By measuring its resistance, we can get a reading for
    the temperature. In the case of NTC thermistors, the resistance will decrease
    as the temperature increases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, the time and temperature data was output in a tab-delimited
    format. This format makes it easy to move the data into other applications for
    analysis. The following graph was generated using data that was output from the
    main script in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8b264f44-a891-418e-9198-1b86fc7ff2a8.png)'
  prefs: []
  type: TYPE_IMG
- en: After the script was run for 60 seconds, the output from the REPL was taken
    and copy-pasted into our spreadsheet program, LibreOffice Calc. The tab delimiter
    separates the time and temperature data into their own columns by default. Then,
    using this table of data, the *x*-*y* scatter graph was generated.
  prefs: []
  type: TYPE_NORMAL
- en: Graphing sensor data like this makes it very easy to visualize what is happening
    to the temperature readings over time. In this specific dataset (at the start
    of script execution), the temperature sensor was reading the ambient room temperature
    as being around 26°C. Around 10 seconds into the script execution, the sensor
    was touched to heat it up to almost 30°C.
  prefs: []
  type: TYPE_NORMAL
- en: This can be seen in the sharp increase in temperature in the preceding diagram,
    which occurs at the 10-second mark. After letting go of the sensor, it starts
    the slow process of cooling down, until the sensor cools down past the 27°C mark
    over a 40-second period.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the temperature property can be found at [https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.temperature](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.temperature).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the CircuitPython `time` module can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/time/__init__.html](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/time/__init__.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the built-in `locals` function can be found at [https://docs.python.org/3/library/functions.html#locals](https://docs.python.org/3/library/functions.html#locals).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details on how thermistors work can be found at [https://www.omega.com/prodinfo/thermistor.html](https://www.omega.com/prodinfo/thermistor.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The project page and the application download for the LibreOffice Calc application
    can be found at [https://www.libreoffice.org/](https://www.libreoffice.org/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading brightness levels from the light sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create a loop that will repeatedly read
    the current light brightness from the light sensor. Getting live readings from
    the sensor can be a fun way to experiment with the sensor to see how sensitive
    it is to different light sources.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the techniques in this recipe can help you build projects that interact
    with their environment, depending on the presence or absence of light.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to read brightness levels from the light sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following block of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The number that's output is the light level of the room. Under normal lighting
    conditions, this should be a low number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, shine a flashlight on the light sensor while you run the following block
    of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the value shoot up to a much higher value. The following code
    should be put into the `main.py` file and, when executed, will repeatedly print
    the current light levels that are being read from the light sensor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first lines of code import the Circuit Playground Express library and the
    `time` module. The `cpx` object exposes a property called `light`. This property
    will return the current light level reading from the light sensor. This value
    is expressed using lux units, which is a unit for measuring illuminance.
  prefs: []
  type: TYPE_NORMAL
- en: In this script, an infinite loop is run, which prints the current lights levels
    and then sleeps for 0.1 seconds before the next iteration starts.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A convenient way to experiment with the light sensor is to use the flashlight
    found on most smartphones. This flashlight is bright enough to create dramatic
    differences in the light readings on Circuit Playground Express. While running
    the main script in this recipe, watch how the values change as you bring the flashlight
    closer and farther away from the sensor.
  prefs: []
  type: TYPE_NORMAL
- en: The light sensor on this device is a phototransistor. This type of device is
    a transistor that, when exposed to different light levels, will cause a difference
    in the flow of current to its circuits. These electrical changes can be read to
    then calculate the light level.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a couple of references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `light` property can be found at [https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.light](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.light).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More details on how phototransistors work can be found at [https://www.elprocus.com/phototransistor-basics-circuit-diagram-advantages-applications/](https://www.elprocus.com/phototransistor-basics-circuit-diagram-advantages-applications/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a light meter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use 10 NeoPixels to create a ring that will show the
    current light level. The ring will get smaller and bigger as the light level increases
    and decreases. This recipe will show you one way you can make your projects interact
    with light. It will also show a generic technique for turning the ring of pixels
    into a 10-level gauge that you can use in all sorts of projects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to create a light meter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the REPL to run the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you should see the first two pixels turn blue. Run the following
    line of code to see the first five pixels turn blue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file and, when executed,
    it will create a light meter that gets bigger and smaller as the light levels
    get brighter and darker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first lines of code import the Circuit Playground Express library and the
    `time` module. The color codes are defined for the colors blue and black. The
    brightness is then set to a comfortable level. The `gauge` function is then defined.
    This function receives a single integer argument, which should range its value
    from 0 to 10\. This value will be used to determine how many pixels will be turned
    blue in the ring of pixels. This function creates a visual display similar to
    a classic gauge, which shows a smaller or larger ring depending on the level of
    the value.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `last` variable is initialized. This variable is used to keep track
    of whether the gauge level has changed since the last loop. This extra step is
    needed to prevent the pixels from flickering because of unnecessarily turning
    them off and on in each loop. The gauge level is calculated by taking the current
    light level and dividing it by its maximum possible value, which happens to be
    330 on this board.
  prefs: []
  type: TYPE_NORMAL
- en: This value is then multiplied by 10, which is the number of levels in the gauge.
    If the gauge level has changed, all the pixels are turned off and then the correct
    gauge level is displayed. This process is done during each iteration of the infinite
    loop with a delay of 50 milliseconds between each loop to create a responsive
    feeling when interacting with the light sensor.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, the functionality to display the gauge was intentionally kept
    in its own function to encourage reusability. It can be used in other projects
    or kept in its own module, which can be imported and used whenever you have the
    need to display information as a gauge using the pixels that come with the board.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of this recipe is the extra work that had to be done to address
    the light flickering issue that occurs when you unnecessarily turn pixels on and
    off repeatedly. When you change the state of many pixels all at once, flickering
    issues can occur if you don't do your implementation carefully. This is not a
    major issue in terms of the functionality of the light meter; it is more about
    creating a more pleasant visual experience when people use the light meter.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a couple of references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: A project that uses Circuit Playground Express pixels to create a sound meter
    can be found at [https://learn.adafruit.com/adafruit-circuit-playground-express/playground-sound-meter](https://learn.adafruit.com/adafruit-circuit-playground-express/playground-sound-meter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More details on what a light meter is and their uses can be found at [https://shuttermuse.com/glossary/light-meter/](https://shuttermuse.com/glossary/light-meter/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading data from the motion sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a loop that continually reads from the accelerometer
    and prints the *x*, *y*, and *z* axes' data. Printing output will help us experiment
    with how the sensor will react to shaking the board or tilting it in different
    directions. Once you get a sense of how the sensor works, you can start incorporating
    it into projects to have your board react to tilt or acceleration.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to read data from the motion sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL while the board is placed on a
    level surface with its buttons facing upward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following block of code while the board is placed with its buttons
    facing downward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file and, when executed,
    will continually print the current *x*, *y*, and *z* axes'' data from the accelerometer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first lines of code import the Circuit Playground Express library and the
    `time` module. An infinite loop is started, which will get readings from the accelerometer
    during each loop. The readings are unpacked into the *x*, *y*, and *z* variables.
    Then, the value of each axis is printed before the script goes to sleep for 0.1
    seconds and starts the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While this script is running, experiment with tilting the board in different
    directions. This sensor is quite sensitive and can give you a pretty accurate
    reading that's related to the tilt of the board. Beyond detecting the orientation
    of the board, it can also be used to detect acceleration on any of the three axes.
    As the script is running, also shake the board in different directions—you should
    see the readings related to acceleration shoot up. Depending on the direction
    you shake the board, different axes should react accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a couple of references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `acceleration` property can be found at [https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.acceleration](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.acceleration).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More details on the accelerometer that comes with Circuit Playground Express
    can be found at [https://learn.adafruit.com/circuit-playground-lesson-number-0/accelerometer](https://learn.adafruit.com/circuit-playground-lesson-number-0/accelerometer).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting a single or double tap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to configure the board to detect single or
    double taps. Sensor data from the accelerometer will be used to detect these tap
    events. This recipe shows you how to create applications that can react to people
    tapping the board.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to detect a single or double tap:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following block of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Tap the board once and then run the following block of code. You should get
    a `True` value for the first value, indicating that a tap was detected, and then
    a `False` value on the next check, which indicates that no new taps have been
    detected since the last check:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file and, when executed,
    will continually print whether or not a tap has been detected since the last check:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first lines of code import the Circuit Playground Express library and the
    `time` module. The tap detection algorithm is configured to detect single taps
    by setting `detect_taps` to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: An infinite loop is started, which will retrieve the value of the `tapped` property
    on each loop. This property will return `True` only if a single tap has been detected
    by the accelerometer since the last time taps were checked. The `sleep` function
    is then called to cause a 0.1-second delay before starting the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modify the script by setting `detect_taps` to `2`. When you run it again, try
    and perform some single taps on the board. It shouldn't register anything.
  prefs: []
  type: TYPE_NORMAL
- en: Now try performing some double taps. You should see them being detected. Try
    varying the amount of force you use to tap the board to see what level of force
    is required before a tap can be detected.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `detect_taps` property can be found at [https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.detect_taps](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.detect_taps).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `tapped` property can be found at [https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.tapped](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.tapped).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More details on the board's tap detection abilities can be found at [https://learn.adafruit.com/circuitpython-made-easy-on-circuit-playground-express/tap](https://learn.adafruit.com/circuitpython-made-easy-on-circuit-playground-express/tap).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting a shake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to poll the `shake` method and print it whenever
    the board has been shaken. Creating projects that can respond to the device being
    shaken can be really fun. The board can also be configured so that you can specify
    whether a light or heavy shake is required before it registers as a shake. This
    can open up new and creative ways to make people interact with your devices.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to detect a shake:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the REPL to run the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Shake the board repeatedly while you run the following block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file and, when executed,
    will continually print whether or not the board is currently being shaken:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first lines of code import the Circuit Playground Express library and the
    `time` module. An infinite loop is started, which will print the result of the
    `shake` method on each loop. This method will return `True` or `False`, depending
    on whether or not the board is currently being shaken. The `sleep` function is
    then called to cause a 0.1-second delay before starting the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modify the script and give the `shake` function the value `20` as the first
    argument. Now, run the script and try and shake it. You should find that less
    force is needed for the board to register a shake event. The default value for
    the first argument, `shake_threshold`, is `30`, and the lower the value, the more
    sensitive the board will be to detecting shakes. Do not set the value to `10`
    or lower, otherwise it will be too sensitive and will continuously think that
    it has detected shakes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a couple of references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `shake` method can be found at [https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.shake](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.shake).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of using the `shake` method can be found at [https://learn.adafruit.com/circuitpython-made-easy-on-circuit-playground-express/shake](https://learn.adafruit.com/circuitpython-made-easy-on-circuit-playground-express/shake).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beeping on a shake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to make the board beep every time you give
    it a shake. This is an interesting way to make the board respond to motion. The
    same approach can be used to make pixels respond to shakes instead of just beeps.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to make the board beep every time you shake
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL; you should hear a beep:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file and, when executed,
    will beep every time the board is shaken:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first lines of code import the Circuit Playground Express library and the
    `time` module. An infinite loop is started, which will check to see whether the
    board is currently being shaken. If a shake event is detected, a short beep is
    played for 0.2 seconds. After this, check that the board then sleeps for 0.1 seconds
    before starting the process again.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You could incorporate the slide switch into this recipe so that people can choose
    a high or low shake threshold, depending on what position the slide switch is
    in. In this way, the slide switch can be used to make it easy or difficult for
    a shake to be detected. You could create a game where each shake increments a
    counter and plays a beep.
  prefs: []
  type: TYPE_NORMAL
- en: When the counter reaches 10, you could play a victory melody. Then, whoever
    achieves 10 shakes first wins. Interacting with devices using shakes instead of
    push-button presses can be a fun way to vary how people interact with your projects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a couple of references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: A guide to how accelerometers work can be found at [https://www.dimensionengineering.com/info/accelerometers](https://www.dimensionengineering.com/info/accelerometers).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the Python library being used to interact with the onboard
    accelerometer can be found at [https://circuitpython.readthedocs.io/projects/lis3dh/en/latest/api.html](https://circuitpython.readthedocs.io/projects/lis3dh/en/latest/api.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
