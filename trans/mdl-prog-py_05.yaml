- en: Chapter 5. Working with Module Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, we have looked in detail at how Python modules and
    packages work, and learned how you can use them in your programs. When using modular
    programming techniques, you will find that the ways in which modules and packages
    are used tend to follow standard patterns. In this chapter, we will examine a
    number of these common patterns for using modules and packages to deal with a
    range of programming challenges. In particular, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn how the divide and conquer technique helps you to solve programming problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how the principle of abstraction helps you to separate what you want to
    do from how you do it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover how encapsulation allows you to hide the details of how information
    is represented from the rest of your system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See that wrappers are modules that call other modules to simplify or alter the
    way a module is used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to create extensible modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by looking at the principle of divide and conquer.
  prefs: []
  type: TYPE_NORMAL
- en: Divide and conquer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Divide and conquer is the process of breaking a problem down into smaller parts.
    You might not know how to solve a particular problem, but by breaking it down
    into smaller parts, you can then solve each part in turn, which then solves the
    original problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a very general technique, of course, and doesn''t just apply to the
    use of modules and packages. However, modular programming helps you work through
    the divide and conquer process: as you break your problem down, you discover that
    you''ll need a part of your program which performs a given task or range of tasks,
    and Python modules (and packages) are the perfect way of organizing those tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: We have done this several times already in this book. For example, when faced
    with the challenge of creating a chart-generation library, we used the divide
    and conquer technique to come up with the notion of a **renderer** that could
    draw a single chart element. We then realized that we would need several different
    renderers, which translated perfectly to the `renderers` package containing a
    separate module for each renderer.
  prefs: []
  type: TYPE_NORMAL
- en: The divide and conquer approach doesn't just suggest a possible modular structure
    for your code, it works the other way around too. As you think about the design
    for your program, you may come up with the notion of a module or package that
    does something related to the problem you're trying to solve. You might even map
    out the individual functions that each module and package provides. Even though
    you don't yet know how to solve the whole problem, this modular design helps you
    to clarify your thinking about the problem, which in turn makes it easier to use
    the divide-and-conquer approach to solve the remainder of the problem. In other
    words, modules and packages help you to *clarify your thinking* as you work through
    the divide and conquer process.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Abstraction is another very general programming pattern that applies to more
    than just modular programming. Abstraction is essentially the process of hiding
    complexity: separating *what* you want to do from *how* to do it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Abstraction is absolutely fundamental to all computer programming. Imagine,
    for example, that you had to write a program that calculates two averages and
    then figures out the difference between the two. A simplistic implementation of
    this program might look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the code that calculates the average of a list of numbers is
    repeated twice. This is inefficient, so you would normally write a function to
    avoid repeating yourself. This can be done in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you do this sort of thing every time you program, but it is actually
    quite an important process. When you create a function like this, the code inside
    the function deals with *how* to do something, while the code that calls that
    function simply knows *what* has to be done—and that the function will do it.
    In other words, the function *hides the complexity* of how the task is performed,
    allowing other parts of your program to simply call that function whenever they
    want that task to be performed.
  prefs: []
  type: TYPE_NORMAL
- en: This type of process is called **abstraction**. Using this pattern, you *abstract
    away* the details of how something is done so that the rest of your program doesn't
    need to worry about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Abstraction doesn''t just apply to writing functions. The general principle
    of hiding complexity applies to groups of functions as well—and the module is
    a perfect way of grouping functions together. For example, your program might
    need to work with colors, and so you write a module named `colors` which contains
    various functions that allow you to create and work with color values. The various
    functions in the `colors` module know about color values and how to use them,
    so the rest of your program doesn''t need to worry about it. Using this module,
    you could do all sorts of interesting things with colors. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Outside of this module, your code can simply concentrate on what it wants to
    do, without the slightest idea of how these various tasks are performed. By doing
    this, you are using the abstraction pattern to hide away the complexity of these
    color calculations from the rest of your program.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction is a fundamental technique for designing and writing modules and
    packages. For example, the Pillow library we used in the previous chapter provides
    a wide range of modules that allow you to load, manipulate, create, and save images.
    We can use this library without having any idea how these various operations are
    performed. For example, we could call `drawer.line((x1, y1), (x2, y2), color,
    width)` and not have to worry about the details of setting individual pixels within
    the image.
  prefs: []
  type: TYPE_NORMAL
- en: One of the great things about applying the abstraction pattern is that you often
    don't know just how complex something will be when you first start implementing
    your code. For example, imagine that you are writing a point-of-sale system for
    a hotel bar. Part of your system will need to calculate the price to charge a
    customer for the drinks they order. There are various formulae we can use to calculate
    this price, based on the quantity, the type of liquor used, and so on. But one
    of the challenging features is the need to support *happy hour*, that is, a period
    of time during which drinks will be offered at a discounted rate.
  prefs: []
  type: TYPE_NORMAL
- en: 'At first, you are told that happy hour is between five and six each evening.
    So, using good modular techniques, you add the following function to your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then use this function to separate how happy hour is calculated from
    what happens during happy hour. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'So far this is pretty simple, and you might be tempted to bypass the creation
    of the `is_happy_hour()` function completely. However, this function soon becomes
    more complicated when you discover that happy hour doesn''t apply on Sundays.
    So, you have to modify the `is_happy_hour()` function to support this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: But you then discover that happy hour doesn't apply on Christmas day or on Good
    Friday. While Christmas day is easy enough to calculate, the logic used to calculate
    when Easter is on a given year is much more complicated. If you're interested,
    the example code for this chapter includes an implementation of the `is_happy_hour()`
    function which includes support for Christmas day and Good Friday. Needless to
    say, the implementation is rather complex.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that our `is_happy_hour()` function becomes more and more complicated
    as we go along—we thought it would be quite simple at first but added requirements
    made it much more complicated. Fortunately, because we've abstracted away the
    details of how happy hour is calculated from the code that needs to know whether
    it is currently happy hour or not, only that one function needs to be updated
    to support this increased complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encapsulation is another programming pattern that often applies to modules and
    packages. Using encapsulation, you have a *thing*—for example, a color, a customer,
    or a currency—that you need to store data about, but you hide the representation
    of this data from the rest of your system. Rather than make the thing available
    directly, you provide functions for setting, retrieving, and manipulating the
    thing's data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, let''s look back at a module we wrote in the previous
    chapter. Our `chart.py` module lets the user define a chart and set the various
    pieces of information about it. Here is a copy of the code that we wrote for this
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `new_chart()` function creates a new "chart" without making
    it clear to the rest of the system how the information about a chart is to be
    stored—we're using a dictionary here, but we could just as easily have used an
    object, a base64-encoded string, or whatever. The rest of the system doesn't care
    as it simply calls the various functions within the `chart.py` module to set the
    various values for a chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, this isn''t quite a perfect example of encapsulation. Our various
    `set_XXX()` functions act as **setters**—they let us set the various values for
    a chart—but we just assume that our chart-generation functions can access the
    information about a chart directly from the chart''s dictionary. If this was going
    to be a pure example of encapsulation, we would also write the equivalent **getter**
    functions, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With these getter functions added to our module, we now have a fully encapsulated
    module that allows us to store and retrieve information about a chart. The other
    parts of the `charter` package that want to use a chart would then call the getter
    functions to retrieve that chart's data, rather than accessing it directly.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These examples of writing setter and getter functions in a module are slightly
    contrived; encapsulation is usually done using object-oriented programming techniques.
    However, as you can see, it is perfectly possible to use encapsulation when writing
    code that uses only modular programming techniques.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why on earth anyone would want to use encapsulation.
    Instead of writing `charts.get_title(chart)`, why not simply write `chart['title']`?
    The second version is shorter. It also avoids calling a function and so would
    be infinitesimally faster. Why bother with encapsulation at all?
  prefs: []
  type: TYPE_NORMAL
- en: There are two reasons why you should use encapsulation in your programs. Firstly,
    by using getter and setter functions, you hide the details of how your information
    is stored. This allows you to change the internal representation without affecting
    any other part of your program—and the one thing you can pretty much guarantee
    as you write your program is that you're going to be adding more information and
    features as you go along. This means that the internal representation of your
    data *will* change. By separating what you are storing from how it is stored,
    your system becomes more robust, and you can make changes without having to rewrite
    a lot of code. This is the hallmark of a good modular design.
  prefs: []
  type: TYPE_NORMAL
- en: The second major reason for using encapsulation is to allow your code to do
    something when the user sets a particular value. For example, if the user changes
    the quantity of an order, you can immediately recalculate the total price for
    that order. Another thing that setters often do is save the updated value to disk
    or into a database. You can also add error-checking and other logic to your setters
    in order to catch bugs that might otherwise be hard to track down.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a detailed look at a Python module that uses the encapsulation pattern.
    For this example, let's pretend that we are writing a program for storing recipes.
    The user can create a database of favorite recipes and display these recipes when
    they want to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a Python module to encapsulate the concept of a recipe. For this
    example, we'll store the recipe in memory to keep things simple. For each recipe,
    we will store the name, the number of servings the recipe produces, a list of
    ingredients, and a list of instructions the user needs to follow when making the
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Python source file, named `recipes.py`, and enter the following
    into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are once again using a Python dictionary to store our information.
    We could use a Python class or a `namedtuple` from the Python Standard Library.
    Alternatively, we could store our information in a database. For this example,
    however, we want to keep our code as simple as possible, and a dictionary is the
    easiest solution.
  prefs: []
  type: TYPE_NORMAL
- en: After creating a new recipe, the user can call the various setter and getter
    functions to store and retrieve information about the recipe. We also have some
    helpful functions that let us add the instructions and ingredients one at a time,
    which is more convenient for the program we are writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that when adding an ingredient to the recipe, the caller needs to supply
    three pieces of information: the name of the ingredient, the required quantity,
    and the units in which this quantity is measured. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have encapsulated the concept of a recipe, allowing us to store the
    information we need and retrieve it when required. Because our module followed
    the encapsulation principle, we could change the way recipes are stored, add more
    information, and new behavior to our module without affecting the rest of the
    program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add one more useful function to our recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This function returns a list of strings which can be printed out to summarize
    the recipe. Notice the `num_servings` parameter: this allows us to customize the
    recipe for a different number of servings. For example, if the user creates a
    recipe for three servings and wants to double it, the `to_string()` function can
    be called with a `num_servings` value of `6`, and the correct quantities will
    be included in the list of returned strings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how this module works. Open up a terminal or command-line
    window, use the `cd` command to go to the directory where you created your `recipes.py`
    file, and type `python` to start the Python interpreter. Then, try typing the
    following to create a recipe for pizza dough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So far so good. Let''s now use the `to_string()` function to print out the
    details of the recipe, doubling it to two servings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'All going well, the recipe should be printed out for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are a few minor formatting issues. For example, the required
    quantity of Greek yogurt is listed as `2 cup` rather than `2 cups`. You can fix
    this easily enough if you want—but the important thing to notice is that the `recipes.py`
    module has encapsulated the idea of a recipe, allowing you (and other programs
    you write) to work with recipes without having to worry about the details.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, you might like to try fixing the display of quantities in the
    `to_string()` function. You could also try writing a new function that creates
    a shopping list from a list of recipes, automatically combining quantities when
    two or more recipes use the same ingredient. If you work through these exercises,
    you'll soon notice that the implementation can get quite complicated, but by encapsulating
    the details in a module, you can hide these details from the rest of your program.
  prefs: []
  type: TYPE_NORMAL
- en: Wrappers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A wrapper is essentially a group of functions that call other functions to
    do the work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wrappers](graphics/B05012_5_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Wrappers are used to simplify an interface, to make a confusing or badly designed
    API easier to use, to convert data formats into something more convenient, and
    to implement cross-language compatibility. Wrappers are also sometimes used to
    add testing and error-checking code to an existing API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a real-world application of a wrapper module. Imagine
    that you work for a large bank and have been asked to write a program to analyze
    fund transfers to help identify possible fraud. Your program receives information,
    in real time, about every inter-bank funds transfer that takes place. For each
    transfer, you are given:'
  prefs: []
  type: TYPE_NORMAL
- en: The amount of the transfer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ID of the branch in which the transfer took place
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The identification code for the bank the funds are being sent to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your task is to analyze the transfers over time to identify unusual patterns
    of activity. To do this, you need to calculate, for each of the last eight days,
    the total value of all transfers for each branch and destination bank. You can
    then compare the current day's totals against the average for the previous seven
    days, and flag any daily totals that are more than 50% above the average.
  prefs: []
  type: TYPE_NORMAL
- en: 'You start by deciding how to represent the total transfers for a day. Because
    you need to keep track of this for each branch and destination bank, it makes
    sense to store these totals in a two-dimensional array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wrappers](graphics/B05012_5_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In Python, this type of two-dimensional array is represented as a list of lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then keep a separate list of the branch ID for each row and another
    list holding the destination bank code for each column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Using these lists, you can calculate the totals for a given day by processing
    the transfers that took place on that particular day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So far so good. Once you have these totals for each day, you can then calculate
    the average and compare it against the current day's totals to identify the entries
    that are higher than 150% of the average.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine that you''ve written this program and managed to get it working.
    When you start using it, though, you immediately discover a problem: your bank
    has over 5,000 branches, and there are more than 15,000 banks worldwide that your
    bank can transfer funds to—that''s a total of 75 million combinations that you
    need to keep totals for, and as a result, your program is taking far too long
    to calculate the totals.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make your program faster, you need to find a better way of handling large
    arrays of numbers. Fortunately, there''s a library designed to do just this: **NumPy**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy is an excellent array-handling library. You can create huge arrays and
    perform sophisticated operations on an array with a single function call. Unfortunately,
    NumPy is also a dense and impenetrable library. It was designed and written for
    people with a deep understanding of mathematics. While there are many tutorials
    available and you can generally figure out how to use it, the code that uses NumPy
    is often hard to comprehend. For example, to calculate the average across multiple
    matrices would involve the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Figuring out what that last line does would require a trip to the NumPy documentation.
    Because of the complexity of the code that uses NumPy, this is a perfect example
    of a situation where a **wrapper module** can be used: the wrapper module can
    provide an easier-to-use interface to NumPy, so your code can use it without being
    cluttered with complex and confusing function calls.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To work through this example, we''ll start by installing the NumPy library.
    NumPy ([http://www.numpy.org](http://www.numpy.org)) runs on Mac OS X, Windows,
    and Linux machines. How you install it depends on which operating system you are
    using:'
  prefs: []
  type: TYPE_NORMAL
- en: For Mac OS X, you can download an installer from [http://www.kyngchaos.com/software/python](http://www.kyngchaos.com/software/python).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For MS Windows, you can download a Python "wheel" file for NumPy from [http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy](http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy).
    Choose the pre-built version of NumPy that matches your operating system and the
    desired version of Python. To use the wheel file, use the `pip install` command,
    for example, `pip install numpy-1.10.4+mkl-cp34-none-win32.whl`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about installing Python wheels, refer to [https://pip.pypa.io/en/latest/user_guide/#installing-from-wheels](https://pip.pypa.io/en/latest/user_guide/#installing-from-wheels).
  prefs: []
  type: TYPE_NORMAL
- en: If your computer runs Linux, you can use your Linux package manager to install
    NumPy. Alternatively, you can download and build NumPy in source code form.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To ensure that NumPy is working, fire up your Python interpreter and enter
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'All going well, you should see a 2 x 2 matrix displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have NumPy installed, let''s start working on our wrapper module.
    Create a new Python source file, named `numpy_wrapper.py`, and enter the following
    into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: That's all for now; we'll add functions to this wrapper module as we need them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create another Python source file, named `detect_unusual_transfers.py`,
    and enter the following into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are hardwiring the bank and branch codes for our example;
    in a real program, these values would be loaded from somewhere, such as a file
    or a database. Since we don't have any available data, we will use the `random`
    module to create some. We are also changing the name of the `numpy_wrapper` module
    to make it easier to access from our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create some funds transfer data to process, using the `random` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we randomly select a day, a bank code, a branch ID, and an amount, storing
    these values in the `transfers` list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next task is to collate this information into a series of arrays. This
    allows us to calculate the total value of the transfers for each day, grouped
    by the branch ID and destination bank. To do this, we''ll create a NumPy array
    for each day, where the rows in each array represent branches and the columns
    represent destination banks. We''ll then go through the list of transfers, processing
    them one by one. The following illustration summarizes how we process each transfer
    in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wrappers](graphics/B05012_5_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we select the array for the day on which the transfer occurred, and then
    we select the appropriate row and column based on the destination bank and the
    branch ID. Finally, we add the amount of the transfer to that item within the
    day's array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement this logic. Our first task is to create a series of NumPy
    arrays, one for each day. Here, we immediately hit a snag: NumPy has many different
    options for creating arrays; in this case, we want to create an array that holds
    integer values and has its contents initialized to zero. If we used NumPy directly,
    our code would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not exactly easy to understand, so we''re going to move this logic
    into our NumPy wrapper module. Edit the `numpy_wrapper.py` file, and add the following
    to the end of this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create a new array by calling our wrapper function (`npw.new()`)
    and not have to worry about the details of how NumPy works at all. We have simplified
    the interface to this particular aspect of NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wrappers](graphics/B05012_5_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now use our wrapper function to create the eight arrays that we will
    need, one for each day. Add the following to the end of the `detect_unusual_transfers.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our NumPy arrays, we can use them as if they were nested Python
    lists. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We just need to choose the appropriate array, and calculate the row and column
    numbers to use. Here is the necessary code, which you should add to the end of
    your `detect_unusual_transfers.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve collated the transfers into eight NumPy arrays, we want to
    use all this data to detect any unusual activity. For each combination of branch
    ID and destination bank code, we will need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the average of the first seven days' activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiply the calculated average by 1.5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the activity on the eighth day is greater than the average multiplied by
    1.5, then we consider this activity to be unusual.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of course, we need to do this for every row and column in our arrays, which
    would be very slow; this is why we're using NumPy. So, we need to calculate the
    average for multiple arrays of numbers, then multiply the array of averages by
    1.5, and finally, compare the values within the multiplied array against the array
    for the eighth day of data. Fortunately, these are all things that NumPy can do
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by collecting together the seven arrays we need to average, as
    well as the array for the eighth day. To do this, add the following to the end
    of your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To calculate the average of a list of arrays, NumPy requires us to use the
    following function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is confusing, we will move this function into our wrapper. Add the
    following code to the end of the `numpy_wrapper.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This lets us calculate the average of the seven day''s activity using a single
    call to our wrapper function. To do this, add the following to the end of your
    `detect_unusual_transfers.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, using the wrapper makes our code much easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next task is to multiply the array of calculated averages by 1.5, and compare
    the result against the current day''s totals. Fortunately, NumPy makes this easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Because this code is so clear, there''s no advantage in creating a wrapper
    function for it. The resulting array, `unusual_transfers`, will be the same size
    as our `current` and `average` arrays, where each entry in the array is either
    `True` or `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wrappers](graphics/B05012_5_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We''re almost done; our final task is to identify the array entries with a
    value of `True`, and tell the user about the unusual activity. While we could
    scan through every row and column to find the `True` entries, using NumPy is much
    faster. The following NumPy code will give us a list containing the row and column
    numbers for the `True` entries in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'True to form, though, this code is hard to understand, so it''s a perfect candidate
    for another wrapper function. Go back to your `numpy_wrapper.py` module, and add
    the following to the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This function returns a list (actually an array) of `(row,col)` values for
    all the `True` entries in the array. Back in our `detect_unusual_activity.py`
    file, we can use this function to quickly identify the unusual activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use the `BRANCH_IDS` and `BANK_CODES` lists to convert from
    the row and column number back to the relevant branch ID and bank code. We also
    retrieve the average and current amounts for the suspicious activity. Finally,
    we print out this information to warn the user about the unusual activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run your program, you should see an output that looks something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Because we are using random numbers for our financial data, the output will
    be random too. Try running the program a few times; you may not get any output
    at all if none of the randomly-generated values are suspicious.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we are not really interested in detecting suspicious financial activity—this
    example is just an excuse for working with NumPy. What is far more interesting
    is the wrapper module that we created, hiding the complexity of the NumPy interface
    so that the rest of our program can concentrate on the job to be done.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to continue developing our unusual activity detector, we would no
    doubt add more functionality to our `numpy_wrapper.py` module as we found more
    NumPy functions that we wanted to wrap.
  prefs: []
  type: TYPE_NORMAL
- en: This is just one example of a wrapper module. As we mentioned earlier, simplifying
    a complex and confusing API is just one use for a wrapper module; they can also
    be used to convert data from one format to another, add testing and error-checking
    code to an existing API, and call functions that are written in a different language.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, by definition, a wrapper is always *thin*—while there might be code
    in a wrapper (for example, to convert a parameter from an object into a dictionary),
    the wrapper function always ends up calling another function to do the actual
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Extensible modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time, the functionality provided by a module is known in advance.
    The module's source code implements a well-defined set of behavior, and that is
    all the module does. In some situations, however, you may need a module where
    the behavior of the module is not completely defined at the time you write it.
    Other parts of your system can *extend* the behavior of the module in various
    ways. Modules that are designed to be extended are called **extensible modules**.
  prefs: []
  type: TYPE_NORMAL
- en: One of the great things about Python is that it is a *dynamic* language. You
    don't need to define and compile all your code before it will run. This makes
    it easy to create extensible modules using Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will look at three different ways in which a module can
    be made extensible: through the use of **dynamic imports**, by writing **plugins**,
    and using **hooks**.'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic imports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous chapter, we created a module called `renderers.py` which selected
    an appropriate renderer module to draw a chart element using a given output format.
    The following is an abbreviated copy of this module''s source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This module is interesting because it implements, in a limited way, the concept
    of extensibility. Notice that the `renderer.draw()` function calls a `draw()`
    function within another module to do the actual work; which module is used depends
    on the desired chart format and the element to be drawn.
  prefs: []
  type: TYPE_NORMAL
- en: This module is not truly extensible because the list of possible modules is
    determined by the `import` statements at the top of the module. However, it is
    possible to turn this into a fully extensible module by making use of `importlib`.
    This is a module in the Python Standard Library that gives a developer access
    to the internal mechanism used to import modules; using `importlib`, you can import
    modules dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how this works, let''s look at an example. Create a new directory
    to hold your source code, and in this directory, create a new module named `module_a.py`.
    Enter the following code into this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now, create a copy of this module, named `module_b.py`, and edit the `say_hello()`
    function to print *Hello from module_b*. Then, repeat the process to create `module_c.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have three modules that all implement a function named `say_hello()`.
    Now, create another Python source file in the same directory, and name it `load_module.py`.
    Then, enter the following into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This program prompts the user to enter a string using the `input()` statement.
    We then call `importlib.import_module()` to import the module with that name,
    and call that module's `say_hello()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try running this program, and when prompted, type in `module_a`. You should
    see the following message displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Try repeating this process with the other modules. If you type in the name of
    a non-existent module, you'll get an `ImportError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, `importlib` isn''t limited to importing modules in the same directory
    as the current module; you can include package names if you want. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `importlib`, you can import a module dynamically—you don''t need to know
    the name of the module at the time you write your program. We could use this to
    rewrite the `renderer.py` module from the previous chapter to make it fully extensible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice the use of the special `__package__` variable. This holds the name of
    the package enclosing the current module; using this allows us to import a module
    relative to the package that the `renderer.py` module is part of.
  prefs: []
  type: TYPE_NORMAL
- en: The great thing about dynamic imports is that you don't need to know what all
    the modules are at the time you create your program. Using the `renderer.py` example,
    you could add new chart formats or elements by creating new renderer modules,
    and the system will import them when requested, without having to make any changes
    at all to your `renderer.py` module.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Plugins are modules that the user (or another developer) writes and "plugs in"
    to your program. Plugins are popular in many large systems such as WordPress,
    JQuery, Google Chrome, and Adobe Photoshop. Plugins are used to extend the functionality
    of an existing program.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, it is easy to implement plugins using the same dynamic import mechanism
    we discussed in the previous section. The only difference is that instead of importing
    modules that are already part of your program's source code, you set up a separate
    directory where the user can place the plugins they want to add to your program.
    This could be as simple as creating a `plugins` directory at the top level of
    your program, or you could store your plugins in a directory outside of your program's
    source code, and modify `sys.path` so that the Python interpreter can find the
    modules in that directory. Either way, your program will use `importlib.import_module()`
    to load the desired plugin, and then access the functions and other definitions
    within the plugin just like you would access functions and other definitions in
    any other Python module.
  prefs: []
  type: TYPE_NORMAL
- en: The sample code available for this chapter includes a simple plugin loader which
    shows how this mechanism works.
  prefs: []
  type: TYPE_NORMAL
- en: Hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **hook** is a way of allowing external code to be called at particular points
    in your program. A hook is usually a function—your program checks to see if a
    hook function has been defined, and if so, it calls this function at an appropriate
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a concrete example. Imagine that you have a program that includes
    the ability to log a user in and out. Part of your program may include the following
    module, which we will call `login_module.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, imagine that you want to add a hook that gets called whenever the user
    logs in. Adding this to your program would involve the following changes to this
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'With this code in place, other parts of your system can hook into your login
    process by setting their own login hook function, which does something whenever
    the user logs in. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: By implementing this login hook, you have extended the behavior of the login
    process without altering the login module itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of things to be aware of with hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the behavior you are implementing a hook for, the value returned
    by the hook function might be used to alter the behavior of your code. For example,
    if the login hook returned `False`, the user might be blocked from logging in.
    This doesn't apply to every hook, but it can be a very useful way of giving a
    hook function more control over what happens in your program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, we only allow a single hook function to be defined for each
    hook. Another way of implementing this would be to have a list of registered hook
    functions, and let your program add or remove hook functions as required. In this
    way, you could have several hook functions, which get called one after the other
    whenever something happens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hooks are an excellent way of adding specific points of extensibility to your
    modules. They are easy to implement and use, and unlike dynamic imports and plugins,
    they don't require you to put your code into a separate module. This means that
    hooks are an ideal way of extending your modules in a very fine-grained way.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw that the ways in which modules and packages are used
    tend to follow standard patterns. We examined the divide-and-conquer pattern,
    which is the process of breaking a problem down into smaller parts, and saw how
    this technique both helps to structure your programs and clarify your thinking
    about the problem you are trying to solve.
  prefs: []
  type: TYPE_NORMAL
- en: We next looked at the abstraction pattern, which is the process of hiding complexity
    by separating what you want to do from how to do it. We then examined the notion
    of encapsulation, which is where you store data about something but hide the details
    of how that data is represented from the rest of the system, and use getter and
    setter functions to provide access to that data.
  prefs: []
  type: TYPE_NORMAL
- en: We then turned to the concept of wrappers, and saw how wrappers can be used
    to simplify the interface to a complex or confusing API, to convert data formats,
    to implement cross-language compatibility, and to add testing and error-checking
    code to an existing API.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned about extensible modules, and saw how we can use the techniques
    of dynamic module imports, plugins, and hooks to create a module that does more
    than you designed it to do. We saw that the dynamic nature of Python makes it
    ideally suited to the creation of extensible modules where the behavior of your
    modules is not completely defined at the time you write them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to design and implement modules that
    can be shared and reused in other programs.
  prefs: []
  type: TYPE_NORMAL
