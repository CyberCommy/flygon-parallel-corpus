- en: Creating Docker Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to create enterprise-grade Docker images.
    We will start off by learning about the main building block of Docker images,
    specifically the Dockerfile. Then, we will explore all the instructions available
    to use in a Dockerfile. There are some instructions that on the surface seem very
    similar. We will uncover what the differences are between the `COPY` and `ADD`
    instructions, the `ENV` and `ARG` instructions, and most importantly between the
    `CMD` and `ENTRYPOINT` instructions. Next, we will find out what the build context
    is and why it is important. Finally, we will cover the actual image build command.
  prefs: []
  type: TYPE_NORMAL
- en: If well-maintained, the average shipping container has a lifespan of around
    20 years, whereas the average lifespan of a Docker container is 2.5 days. – [https://www.tintri.com/blog/2017/03/tintri-supports-containers-advanced-storage-features](https://www.tintri.com/blog/2017/03/tintri-supports-containers-advanced-storage-features)
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a Dockerfile?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the instructions that can be used in a Dockerfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to use either the `COPY` or the `ADD` instruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between the `ENV` and `ARG` variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why you use the `CMD` and `ENTRYPOINT` instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of the build context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Docker images using a Dockerfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be pulling Docker images from Docker's public repository, so basic
    internet access is required to execute the examples within this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter03](https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter03)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action: [http://bit.ly/2rbHvwC](http://bit.ly/2rbHvwC)'
  prefs: []
  type: TYPE_NORMAL
- en: What is a Dockerfile?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You learned in [Chapter 2](e66034ed-dcc0-48a8-a2ec-9466669e6649.xhtml), *Learning
    Docker Commands*, that you can run a Docker container, make modifications to that
    running container, and then using the docker commit command, save those changes,
    effectively creating a new Docker image. Although this method works, it is not
    the preferred way to create Docker containers. The best way to create Docker images
    is to use the Docker image build command with a Dockerfile that describes your
    desired image.
  prefs: []
  type: TYPE_NORMAL
- en: A Dockerfile (yes, the correct spelling is all one word, with a capital *D*)
    is a text file that contains instructions used by the Docker daemon to create
    a Docker image. The instructions are defined using a type of value pair syntax.
    Each one has an instruction word followed by the parameters for that instruction.
    Every command gets its own line in the Dockerfile. Although the Dockerfile instructions
    are not case-sensitive, there is a well-used convention that the instruction word
    is always uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: The order of the instructions in the Dockerfile is significant. Instructions
    are evaluated in sequential order, starting at the top of the Dockerfile and finishing
    at the bottom of the file. If you recall from [Chapter 1](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml), *Setting
    up a Docker Development Environment*, Docker images are made up of layers. All
    of the instructions found in the Dockerfile will result in a new layer being generated
    as the Docker image is built, however, some instructions will only add a zero-byte-sized
    metadata layer to the created image. Since it is a best practice to keep Docker
    images as small as possible, you will want to use instructions that create non-zero-byte-sized
    layers as efficiently as possible. In the following sections, we'll note where
    using an instruction creates a non-zero-byte-sized layer, and how to best use
    that instruction to minimize the number and size of layers. Another important
    consideration is the ordering of the instructions. Certain instructions must be
    used before others, but with those exceptions, you can place the other instructions
    in any order you please. The best practice is to use instructions that change
    least early in the Dockerfile, and instructions that change more frequently in
    the later part of the Dockerfile. The reason is that when you need to rebuild
    an image, the only layers that get rebuilt are the ones that are at, or after,
    the first line changed in the Dockerfile. If you don't understand this yet, don't
    worry, it will make more sense once we see some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will review the build command at the end of this section, but we will start
    with the instructions available to the Dockerfile first, beginning with the instruction
    that has to be the first instruction in your Dockerfile: the `FROM` instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: The FROM instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every Dockerfile must have a `FROM` instruction, and it must be the first instruction
    in the file. (Actually, the ARG instruction can be used before a `FROM` instruction,
    but it is not a required instruction. We will talk more about that in the ARG
    instruction section.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FROM` instruction sets the base for the image being created and instructs
    the Docker daemon that the base of the new image should be the existing Docker
    image specified as the parameter. The specified image can be described using the
    same syntax we saw in the Docker `container run` command from [Chapter 2](e66034ed-dcc0-48a8-a2ec-9466669e6649.xhtml),
    *Learning Docker Commands*. Here, it''s a `FROM` instruction that specifies using
    the official `nginx` image with a version of 1.15.2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that in this example, there is no repository specified that indicates that
    the specified image is the official nginx image. If no tag is specified, the `latest`
    tag will be assumed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FROM` instruction will create the first layer in our new image. That layer
    will be the size of the image specified in the instruction''s parameter so it
    is best to specify the smallest image that meets the criteria needed for your
    new image. An application-specific image, such as `nginx`, is going to be smaller
    than an OS image, such as ubuntu. And, the OS image for `alpine` will be much
    smaller than images of other OSes, such as Ubuntu, CentOS, or RHEL. There is a
    special keyword that can be used as the parameter to the `FROM` instruction. It
    is `scratch`. Scratch is not an image that you can pull or run, it just a signal
    to the Docker daemon that you want to build an image with an empty base-image
    layer. The FROM scratch instruction is used as the base layer for many other base
    images, or for specialized app-specific images. You have already seen an example
    of such a specialized app image: hello-world. The full Dockerfile for the hello-world
    image looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will discuss the `COPY` and `CMD` instructions shortly, but you should get
    a sense of how small the hello-world image is based on its Dockerfile. In the
    world of Docker images, smaller is definitely better. Take a look at the size
    of some images for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3e91115f-6c8d-4634-8638-b0c8e051a85b.png)'
  prefs: []
  type: TYPE_IMG
- en: The LABEL instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `LABEL` instruction is a way to add metadata to your Docker image. This
    instruction adds embedded key-value pairs to the image. The `LABEL` instruction
    adds a zero-byte-sized layer to the image when it is created. An image can have
    more than one `LABEL`, and each `LABEL` instruction can provide one or more LABELs.
    The most common use for the `LABEL` instruction is to provide information about
    the image maintainer. This data used to have its own instruction. See the following
    tip box about the now-deprecated `MAINTAINER` instruction. Here are some examples
    of valid `LABEL` instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LABEL` instruction is one of the instructions that can be used multiple
    times in a Dockerfile. You will learn later that some instructions that can be
    used multiple times will result in only the last use being significant, thus ignoring
    all previous uses. The `LABEL` instruction is different. Every use of the `LABEL`
    instruction adds an additional label to the resulting image. However, if two or
    more uses of `LABEL` have the same key, the label will get the value provided
    in the last matching `LABEL` instruction. That looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to know that the base image specified in your `FROM` instruction
    may include labels created with the `LABEL` instruction and that they will automatically
    be included in the metadata of the image you are building. If a `LABEL` instruction
    in your Dockerfile uses the same key as a `LABEL` instruction used in the FROM
    image''s Dockerfile, your (later) value will override the one in the FROM image.
    You can view all of the labels for an image by using the `inspect` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c01d1aab-1110-46c5-9623-cad509812cc6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The MAINTAINER instruction There is a Dockerfile instruction specifically for
    providing the info about the image maintainer, however, this instruction has been
    deprecated. Still, you will probably see it used in a Dockerfile at some point.
    The syntax goes like this: `"maintainer": "Earl Waud <earlwaud@mycompany.com>"`.'
  prefs: []
  type: TYPE_NORMAL
- en: The COPY instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have already seen an example of using the `COPY` instruction in the hello-world
    Dockerfile shown in *The FROM instruction* section. The `COPY` instruction is
    used to copy files and folders into the Docker image being built. The syntax for
    the `COPY` instruction is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `--chown` parameter is only valid for Linux-based containers.
    Without the `--chown` parameter, the owner ID and group ID will both be set to
    0.
  prefs: []
  type: TYPE_NORMAL
- en: The `<src>` or source is a filename or folder path and is interpreted to be
    relative to the context of the build. We will talk more about the build context later
    in this chapter, but for now, think of it as where the build command is run. The
    source may include wildcards.
  prefs: []
  type: TYPE_NORMAL
- en: The `<dest>` or destination is a filename or path inside of the image being
    created. The destination is relative to the root of the image's filesystem unless
    there is a preceding `WORKDIR` instruction. We will discuss the `WORKDIR` instruction
    later, but for now, just think of it as a way to set the current working directory.
    When the COPY command comes after a `WORKDIR` instruction in a Dockerfile, the
    file or folders being copied into the image will be placed in the destination
    relative to the current working directory. If the destination includes a path
    with one or more folders, all of the folders will be created if they don't already
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our earlier hello-world Dockerfile example, you saw a `COPY` instruction
    that copied an executable file, named `hello`, into the image at the filesystem''s
    root location. It looked like this: `COPY hello /`. That is about as basic a `COPY`
    instruction as can be used. Here are some other examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see what the resulting image''s filesystem would get using the preceding
    Dockerfile by running a container from the image, and executing an `ls` command,
    which would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/442d213e-eea8-4ca6-bee4-253d64e84aa5.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that folders specified in the destination path were created during
    the COPY. You will also notice that providing the `--chown` parameter sets the
    owner and group on the destination files. An important distinction is that when
    the source is a folder, the contents of the folder are copied but not the folder
    itself. Notice that using a `WORKDIR` instruction changes the path in the image
    filesystem and following `COPY` instructions will now be relative to the new current
    working directory. In this example, we returned the current working directory
    to `/` so that commands executed in containers will run relative to `/`.
  prefs: []
  type: TYPE_NORMAL
- en: The ADD instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ADD` instruction is used to copy files and folders into the Docker image
    being built. The syntax for the `ADD` instruction is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: About now, you are thinking that the `ADD` instruction seems to be just like
    the `COPY` instruction that we just reviewed. Well, you are not wrong. Basically,
    all of the things we saw the `COPY` instruction do, the `ADD` instruction can
    do as well. It uses the same syntax as the `COPY` instruction and the effects
    of `WORKDIR` instructions are the same between the two. So, why do we have two
    commands that do the same thing?
  prefs: []
  type: TYPE_NORMAL
- en: The difference between COPY and ADD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The answer is that the `ADD` instruction can actually do more than the `COPY`
    instruction. The more is dependent upon the values used for the source input.
    With the `COPY` instruction, the source can be files or folders. However, with
    the `ADD` instruction, the source can be files, folders, a local `.tar` file,
    or a URL.
  prefs: []
  type: TYPE_NORMAL
- en: When the `ADD` instruction has a source value that is a `.tar` file, the contents
    of that TAR file are extracted into a corresponding folder inside the image.
  prefs: []
  type: TYPE_NORMAL
- en: When you use a `.tar` file as the source in an `ADD` instruction and include
    the `--chown` parameter, you might expect the owner and group in the image to
    be set on the files extracted from the archive. This is currently not the way
    it works. Unfortunately, the owner, group, and permissions on the extracted contents
    will match what is contained within the archive in spite of the `--chown` parameter.
    When you use a `.tar` file, you will probably want to include `RUN chown -R X:X`
    after the ADD.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, the `ADD` instruction can use a URL as the source value. Here
    is an example Dockerfile that includes an `ADD` instruction using a URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'While using a URL in an `ADD` instruction works, downloading the file into
    the image, this feature is not recommended, even by Docker. Here is what the Docker
    documentation has to say about using `ADD`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f457493e-9d04-4f9f-8892-4eb6466b159d.png)'
  prefs: []
  type: TYPE_IMG
- en: So, generally speaking, whenever you can get the desired content into the image
    using a `COPY` instruction, then you should choose to use `COPY` instead of `ADD`.
  prefs: []
  type: TYPE_NORMAL
- en: The ENV instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you may guess, the `ENV` instruction is used to define environment variables
    that will be set in the running containers created from the image being built.
    The variables are defined using typical key-value pairs. A Dockerfile can have
    one or more `ENV` instructions. Here is the `ENV` instruction syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Each `ENV` instruction will create one or more environment variables (unless
    the key name is repeated). Let''s take a look at some `ENV` instructions in a
    Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After building the image using this Dockerfile, you can inspect the image metadata
    and see the environment variables that have been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e98f6d2e-906f-4c99-8a98-7fd5aceb10fc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Environment variables can be set (or overridden) when a container is run using
    the `--env` parameter. Here, we see this feature in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/572af022-9c53-496a-96e1-7e1c23a14b24.png)'
  prefs: []
  type: TYPE_IMG
- en: It is important to know that using `ENV` instructions create a zero-byte-sized
    additional layer in the resulting image. If you are adding more than one environment
    variable to your image and can use the form of the instruction that supports setting
    multiple variables with one instruction, doing so will only create a single additional
    image layer, so that is the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: The ARG instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes when building Docker images, you may need to use variable data to
    customize the build. The `ARG` instruction is the tool to handle that situation.
    To use it, you add `ARG` instructions to your Dockerfile, and then when you execute
    the build command, you pass in the variable data with a `--build-arg` parameter.
    The `--build-arg` parameter uses the now familiar key-value pair format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can use multiple `ARG` instructions in your Dockerfile with corresponding
    `--build-arg` parameters on the docker image build commands. You have to include
    an `ARG` instruction for every use of the `--build-arg` parameter. Without the
    `ARG` instruction, the `--build-arg` parameter will not be set during the build,
    and you will get a warning message. If you do not provide a `--build-arg` parameter
    or you do not provide the value part of the key-value pair for a `--build-arg` parameter for
    an existing `ARG` instruction, and that `ARG` instruction includes a default value,
    then the variable will be assigned the default value.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that during the image build, even though `--build-arg` is included
    as a parameter of the docker image build command, the corresponding variable does
    not get set until the `ARG` instruction is reached in the Dockerfile. Said another
    way, the value of the key-value pair of a `--build-arg` parameter will never be
    set until after its corresponding `ARG` line in the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters defined in `ARG` instructions do not persist into containers
    run from the created image, however, ARG instructions create new zero-byte-sized
    layers in the resulting images. Here is an educational example of using the `ARG`
    instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a Dockerfile with the contents shown in the preceding code block and
    run the following build command to see how the scope of the `ENV` and `ARG` instructions
    play out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You will see by the first `echo ${key1}` that even though there is a `--build-arg` parameter
    for `key1`, it will not be stored as `key1` because there is an `ENV` instruction
    that has the same key name. This still holds true for the second `echo ${key1}`,
    which is after the ARG `key1` instruction. The ENV variable values will always
    be the winner when there are both `ARG` and `EVN` instructions with the same key
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you will see that the first `echo ${key2}` is empty even though there
    is a `--build-arg` parameter for it. It is empty because we have not reached the
    `ARG key2` instruction yet. The second `echo ${key2}` will contain the value from
    the corresponding `--build-arg` parameter even though there is a default value
    provided in the `ARG key2` instruction. The final `echo ${key2}` will show the
    value provided in the `ENV key2` instruction in spite of there being both a default
    value in the `ARG` and a value passed in via the `--build-arg` parameter. Again,
    this is because `ENV` always trumps ARG.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between ENV and ARG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Again, here is a pair of instructions that have a similar functionality. They
    both can be used during the build of an image, setting parameters to be available
    to use within other Dockerfile instructions. The other Dockerfile instructions
    that can use these parameters are `FROM`, `LABEL`, `COPY`, `ADD`, `ENV`, `USER`,
    `WORKDIR`, `RUN`, `VOLUME`, `EXPOSE`, `STOPSIGNAL`, and `ONBUILD`. Here is an
    example of using the `ARG` and `ENV` variables in other Docker commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With this Dockerfile, you would want to provide `--build-arg` parameters for
    the `appdir` `ARG` instruction, and the username (if you want to override the
    default) to the build command. You could also provide an `--env` parameter at
    runtime to override the lifecycle variable. Here are possible build and run commands
    you could use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'While the `ENV` and `ARG` instructions might seem similar, they are actually
    quite different. Here are the key differences to remember between the parameters
    created by the `ENV` and `ARG` instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: ENVs persist into running containers, ARGs do not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARGs use corresponding build parameters, ENVs do not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENV` instructions must include both a key and a value, `ARG` instructions
    have a key but the (default) value is optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ENVs are more significant than ARGs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should never use either `ENV` or `ARG` instructions to provide secret data
    to the build command or resulting containers because the values are always visible
    in clear text to any user that runs the docker history command.
  prefs: []
  type: TYPE_NORMAL
- en: The USER instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The USER instruction allows you to set the current user (and group) for all
    of the instructions that follow in the Dockerfile, and for the containers that
    are run from the built image. The syntax for the `USER` instruction is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If a named user (or group) is provided as parameters to the `USER` instruction,
    that user (and group) must already exist in the passwd file (or group file) of
    the system, or a build error will occur. If you provide the `UID` (or `GID`) as
    the parameter to the `USER` command, the check to see whether the user (or group)
    exists is not performed. Consider the following Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When the image build starts, the current user is root or `UID=0` `GID=0`. Then,
    the `USER` instruction is executed to set the current user and group to `games:games`.
    Since this is the last use of the `USER` instruction in the Dockerfile, all containers
    run using the built image will have the current user (and group) set to games.
    Here is what the build and run look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0aca2a20-ee07-4b3b-ba94-bc58b78b8deb.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the output from Step 3/6:RUN id shows the current user as root,
    and then in Step 5/6 (which is after the `USER` instruction) it shows the current
    user as games. Finally, notice that the container run from the image has the current
    user games. The `USER` instruction creates a zero-byte-sized layer in the image.
  prefs: []
  type: TYPE_NORMAL
- en: The WORKDIR instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen the `WORKDIR` instruction used in some of the examples used to
    demonstrate other instructions. It is sort of like a combination of the Linux
    `cd` and `mkdir` commands. The `WORKDIR` instruction will change the current working
    directory in the image to the value provided in the instruction. If any segment
    of the path in the parameter of the `WORKDIR` instruction does not yet exist,
    it will be created as part of the execution of the instruction. The syntax for
    the `WORKDIR` instruction is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WORKDIR` instruction can use `ENV` or `ARG` parameter values for all or
    part of its parameter. A Dockerfile can have more than one `WORKDIR` instruction,
    and each subsequent `WORKDIR` instruction will be relative to the previous one
    (if a relative path is used). Here is an example that demonstrates this possibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Building the image from this Dockerfile will result in the image having three
    levels of nested folders. Running a container from the image and listing the files
    and folders will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c1c550ed-5793-45d4-a4d7-a9f8c4c60f81.png)'
  prefs: []
  type: TYPE_IMG
- en: The `WORKDIR` instruction will create a zero-byte-sized layer in the resulting
    image.
  prefs: []
  type: TYPE_NORMAL
- en: The VOLUME instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should remember that a Docker image is made up of a series of read-only
    layers built upon one another, and that when you run a container from a Docker
    image, it creates a new read-write layer that you can think of as being on top
    of the read-only layers. All the changes to the container are applied to the read-write
    layer. If you make a change to a file found in one of the read-only layers, a
    copy of that file is made and added to the read-write layer. Then, all the changes
    are applied to the copy. The copy hides the version found in the read-only layer
    so, from the point of view of the running container, there is only one version
    of the file, and it is the one that has been changed. This is roughly how the
    Unified File System works.
  prefs: []
  type: TYPE_NORMAL
- en: This is actually a great thing. However, it presents a challenge, this being
    that when the running container exits and is removed, all of the changes are removed
    with it. This is normally OK until you want to have some data that persists after
    the life of the container, or when you want to share data between containers.
    Docker has an instruction to help you solve this issue, the `VOLUME` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `VOLUME` instruction will create a storage location that is outside of
    the United File System, and by so doing, allow storage to persist beyond the life
    of your container. Here is the syntax of the `VOLUME` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Other ways to create volumes are to add volume parameters to the docker `container
    run` command or to use the docker volume create command. We will cover those methods
    in detail in [Chapter 4](6e908793-3bc0-45f3-bcb5-af85ac6aecab.xhtml), *Docker
    Volumes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example Dockerfile. It creates a volume at `/myvol` that will
    have a file named `greeting`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Running a container based on an image made from this Dockerfile will create
    a mount point on the host system that initially contains the `greeting` file.
    When the container exits, the mount point will remain. Be careful with the use
    of the `--rm` parameter when running a container that has mount points you wish
    to persist. Using `--rm`, with no other volume parameters, will cause the mount
    points to be cleaned up along with the container when it exits. Here is what that
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b5f7a39c-bbc2-4ed6-96a3-96327e0839af.png)'
  prefs: []
  type: TYPE_IMG
- en: We start out with no volumes. Then, we run a container based on the image made
    from the preceding Dockerfile in detached mode. We check the volumes again, and
    we see the volume created by running the container. Then, we stop the container
    and check for volumes again, and the volume is now gone. Usually, the purpose
    of using a `VOLUME` instruction is to have data in a mount point that persists
    after the container is gone. So, if you are going to use `--rm` when you run a
    container, you should include the `--mount` run parameter, which we will cover
    in detail in [Chapter 4](6e908793-3bc0-45f3-bcb5-af85ac6aecab.xhtml), *Docker
    Volumes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can interact with the data on the host using the mount point for a volume.
    Here is an example that demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/bd92fd61-ea21-4375-850c-4e759713d89e.png)'
  prefs: []
  type: TYPE_IMG
- en: In this demo, we run a container that is based on an image created with the
    preceding Dockerfile. Then, we list the volumes and see the myvolsrc volume (we
    already knew the name since we provided it in the run command, but you can use
    the `ls` command to find volume names that you might not otherwise know). Using
    the volume's name, we inspect the volume to find its mount point on the host.
    To verify the contents of the volume in the container, we use an exec command
    to do an ls of the folder. Next, using the mount point path, we create a new file
    using the touch command. Finally, we use the same exec command and see that inside
    the container the volume has been changed (from actions outside of the container).
    Similarly, if the container makes changes to the contents of the volume, they
    are reflected instantly on the host mount point.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example will not work on OS X directly as shown. It requires some
    extra work. Don't panic though! We'll show you how to deal with the extra work
    required for OS X in [Chapter 4](6e908793-3bc0-45f3-bcb5-af85ac6aecab.xhtml),
    *Docker Volumes*.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `VOLUME` instruction is both powerful and dangerous. It is powerful
    in that it lets you have data that will persist beyond the life of your containers.
    It is dangerous because data is passed instantaneously from the container to the
    host, and if the container is ever compromised, that can spell trouble. That is
    why, for security purposes, it is best practice to *not* include host-based VOLUME
    mounts in your Dockerfiles. We will cover some safer alternatives in [Chapter
    4](6e908793-3bc0-45f3-bcb5-af85ac6aecab.xhtml), *Docker Volumes*.
  prefs: []
  type: TYPE_NORMAL
- en: The `VOLUME` instruction will add a zero-bytes sized layer to your resulting
    Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: The EXPOSE instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `EXPOSE` instruction is a way to document what network ports the image
    expects to be opened when a container is run from the image built using the Dockerfile.
    The syntax for the `EXPOSE` instruction is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It is important to understand that including the `EXPOSE` instruction in the
    Dockerfile does not actually open network ports in containers. When containers
    are run from the images with the `EXPOSE` instruction in their Dockerfile, it
    is still necessary to include the `-p` or `-P` parameters to actually open the
    network ports to the container.
  prefs: []
  type: TYPE_NORMAL
- en: You can include multiple `EXPOSE` instructions in your Dockerfile as needed. Including
    the `-P` parameter at runtime is a shortcut way to automatically open ports for
    all of the `EXPOSE` instructions included in the Dockerfile. The corresponding
    host ports will be randomly assigned when using the `-P` parameter on the run
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Think of the `EXPOSE` instruction as a message from the image developer telling
    you that the application in the image is expecting you to open the indicated port(s)
    when you run your containers. The `EXPOSE` instruction creates a zero-byte-sized layer
    in the resulting image.
  prefs: []
  type: TYPE_NORMAL
- en: The RUN instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `RUN` instruction is the real workhorse of the Dockerfile. It is the tool
    by which you affect the most change in the resulting docker image. Basically,
    it allows you to execute any command in the image. There are two forms of the
    `RUN` instruction. Here is the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Every `RUN` instruction creates a new layer in the image, and the layers for
    each instruction that follow will be built on the results of the `RUN` instruction''s
    layer. The shell form of the instruction will use the default shell unless it
    is overridden using a `SHELL` instruction, which we will discuss in *The SHELL
    instruction* section. If you are building a container that does not include a
    shell, you will need to use the exec form of the `RUN` instruction. You can also
    use the exec form of the instruction to use a different shell. For example, to
    run a command using the bash shell, you could add a `RUN` instruction, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The uses for the `RUN` command are limited only by the imagination, so providing
    an exhaustive list of `RUN` instruction samples would be impossible, but here
    are a few using both forms of the instruction, just to give you some ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a fun and useful `RUN` instruction you can add when you know your
    image will include bash. This idea was shared with me by my colleague *Marcello
    de Sales* after he learned of it at Dockercon 16.You can use the following code
    to create a custom prompt displayed when you shell into your containers. If you
    don''t like the whale graphic, you can switch it up and use anything you like
    better. I''ve included some of my favorite options. Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting prompt looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2d0c1502-1539-4012-9e25-d472c87bea18.png)'
  prefs: []
  type: TYPE_IMG
- en: The CMD instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CMD` instruction is used to define the default action taken when containers
    are run from images built with their Dockerfile. While it is possible to include
    more than one `CMD` instruction in a Dockerfile, only the last one will be significant.
    Essentially, the final `CMD` instruction provides the default action for the image.
    This allows you to either override or use the `CMD` in the image used in the `FROM`
    instruction of your Dockerfile. Here is an example where a trivial Dockerfile
    does not contain a `CMD` instruction and relies on the one found in the ubuntu
    image used in the `FROM` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2c1f6b2e-a069-432c-a891-fb4eb69f7bab.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see from the output of the history command that the ubuntu image includes
    the `CMD ["/bin/bash"]` instruction. You will also see that our Dockerfile does
    not have its own `CMD` instruction. When we run the container, the default action
    is to run `"/bin/bash"`.
  prefs: []
  type: TYPE_NORMAL
- en: There are three forms of the `CMD` instruction. The first is a shell form. The
    second is an exec form, which is the best practice form to use. And, the third
    is a special exec form that has exactly two parameters, and it is used in conjunction
    with the `ENTRYPOINT` instruction, which we will talk about in *The ENTRYPOINT*
    *instruction* section. Here is the syntax for the `CMD` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are a few `CMD` instruction examples for your enjoyment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Like the `RUN` instruction, the shell form of the `CMD` instruction will use
    the `["/bin/sh", "-c"]` shell command (or `["cmd", "/S", "/C"]` for Windows) by
    default unless it is overridden with a `SHELL` instruction. However, unlike the
    `RUN` instruction, the `CMD` instruction does not execute anything during the
    building of the image but instead is executed when containers built from the image
    are run. If the container image being built will not have a shell, then the exec
    form of the instruction can be used as it does not invoke a shell. The `CMD` instruction
    adds a zero-byte-sized layer to the image.
  prefs: []
  type: TYPE_NORMAL
- en: The ENTRYPOINT instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ENTRYPOINT` instruction is used to configure a docker image to run like
    an application or a command. For example, we can use the `ENTRYPOINT` instruction
    to make an image that displays help for the `curl` command. Consider this Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the container image with no overriding `CMD` parameter and it will
    show help for the `curl` command. However, when we run the container with a `CMD`
    override parameter, in this case, a URL, the response will be to `curl` the URL.
    Take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/71810ef5-9fe0-439d-963f-7a03c6b758df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When run parameters are provided to a container that has the exec form of the
    `ENTRYPOINT` command, those parameters will be appended to the `ENTRYPOINT` instruction,
    overriding anything provided in a `CMD` instruction. In this example, `--help` is
    overridden with the `google.com` run parameter, so the resulting instruction is
    `curl google.com`. Here is the actual syntax for the `ENTRYPOINT` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Like the `CMD` instruction, only the last `ENTRYPOINT` instruction is significant.
    Again, this allows you to either use or override the `ENTRYPOINT` instruction
    in the `FROM` image used. Like both the `RUN` and `CMD` instructions, using the
    shell form will invoke a shell as `["/bin/sh", "-c"]` (or `["cmd", "/S", "/C"]`
    on Windows). This is not the case when using the exec form of the instruction.
    This is key if you have an image that does not have a shell or if the shell is
    not available to the active user context. However, you will not get shell processing,
    so any shell environment variables will not get substituted when using the exec
    form of the instruction. It is generally considered best practice to use the exec
    form of the `ENTRYPOINT` instruction whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between CMD and ENTRYPOINT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here again, we have two instructions that on the surface seem to be very much
    the same. It is true that there is some overlap of functionality between the two.
    Both instructions provide a way to define a default application that is executed
    when containers are run. However, they each serve their own unique purpose, and
    in some cases work together to provide greater functionality than either instruction
    alone.
  prefs: []
  type: TYPE_NORMAL
- en: The best practice is to use the `ENTRYPOINT` instruction when you want a container
    to execute as an application, providing a specific (developer) defined function,
    and to use `CMD` when you want to give the user more flexibility in what function
    the container will serve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both of these instructions have two forms: a shell form and an exec form. It
    is best practice to use the exec form of either whenever possible. The reason
    for this is that the shell form, by definition, will run `["/bin/sh", "-c"]` (or `["cmd",
    "/S", "/C"]` on Windows) to launch the application in the parameter of the instruction.
    Because of this, the primary process running in the container is not the application.
    Instead, it is the shell. This affects how the container exits, it affects how
    signals are processed, and it can really cause problems for images that do not
    include `"/bin/sh"`. One use case where you might need to use the shell form is
    if you require shell-environment-variable substitution.'
  prefs: []
  type: TYPE_NORMAL
- en: There is also a use case for using both instructions in your Dockerfile. When
    you use both, you can define a specific application that gets executed when the
    container is run, and allow the user to easily provide the parameters that get
    used with the defined application. In this scenario, you would use the `ENTRYPOINT`
    instruction to set the application being executed and provide a default set of
    parameters for the application using the `CMD` instruction. With this configuration,
    the user of the container can benefit from the default parameters supplied in
    the `CMD` instruction, or they can easily override those parameters used in the
    application by supplying them as arguments in the `container run` command. It
    is highly recommended that you use the exec form of both instructions when you
    use them together.
  prefs: []
  type: TYPE_NORMAL
- en: The HEALTHCHECK instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `HEALTHCHECK` instruction, which is a fairly new addition to the Dockerfile,
    is used to define the command to run inside a container to test the container''s
    application health. When a container has a `HEALTHCHECK`, it gets a special status
    variable. Initially, that variable will be set to `starting`. Any time a `HEALTHCHECK`
    is performed successfully, the status will be set to `healthy`. When a `HEALTHCHECK`
    is performed and fails, the fail count value will be incremented and then checked
    against a retries value. If the fail count equals or exceeds the retries value,
    the status is set to `unhealthy`. The syntax of the `HEALTHCHECK` instruction
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'There are four options that can be used when setting the `HEALTHCHECK`, and
    these options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `--interval` option allows you to define the amount of time between the
    `HEALTHCHECK` tests. The `--timeout` option allows you to define the amount of
    time that is considered too long for a `HEALTHCHECK` test. If the timeout is exceeded,
    the test is automatically considered a failure. The `--start-period` option allows
    for the definition of a no-fail time period during the container startup. Finally,
    the `--retries` option allows you to define how many consecutive failures it takes
    to update the `HEALTHCHECK` status to `unhealthy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CMD` part of the `HEALTHCHECK` instruction follows the same rules as the
    `CMD` instruction. Please review the preceding section regarding the `CMD` instruction
    for complete details. The `CMD` that is used will provide a status when it exits,
    which will be either a 0 for success or a 1 for fail. Here is a Dockerfile example
    that uses the `HEALTHCHECK` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Running a container from an image built with the preceding Dockerfile looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5a4d6561-c20e-4f21-94d0-0de027616a41.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the `HEALTHCHECK` initially reported a status of `starting`,
    but once the `HEALTHCHECK` `CMD` reported success, the status updated to `healthy`.
  prefs: []
  type: TYPE_NORMAL
- en: The ONBUILD instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ONBUILD` instruction is a tool used when creating images that will become
    the parameter to the `FROM` instructions in another Dockerfile. The `ONBUILD`
    instruction just adds metadata to your image, specifically a trigger that is stored
    in the image and not otherwise used. However, that metadata trigger does get used
    when your image is supplied as the parameter in the `FROM` command of another
    Dockerfile. Here is the `ONBUILD` instruction syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ONBUILD` instruction is kind of like a Docker time machine used to send
    instructions into the future. (You might laugh if you knew how many times I just
    typed *Doctor time machine*!) Let''s demonstrate the use of the `ONBUILD` instruction
    with a simple example. First, we will build an image named `my-base` using the
    following Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s build an image named `my-app` that is built `FROM` the `my-base`
    image, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspecting the resulting `my-app` image shows us that the LABEL commands provided
    in the `ONBUILD` instructions were sent forward in time, arriving at the `my-app`
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a1594a9a-5813-48bd-ae3e-0c40d9ed65b3.png)'
  prefs: []
  type: TYPE_IMG
- en: If you did a similar inspect of the `my-base` image, you would find that it
    does *not* contain the version and support labels. Note also that the `ONBUILD`
    instruction is a one-time-use time machine. If you were to build a new image using
    the `my-app` in the `FROM` instruction, the new image would *not* get the labels
    that were provided in the ONBUILD instructions of the `my-base` image.
  prefs: []
  type: TYPE_NORMAL
- en: The STOPSIGNAL instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `STOPSIGNAL` instruction is used to set the system call signal that will
    be sent to the container to tell it to exit. The parameter used in the instruction
    can be an unsigned number, which equals a position in the kernel''s syscall table,
    or it can be an actual signal name in uppercase. Here is the syntax for the instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Examples of the `STOPSIGNAL` instruction include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The parameter supplied to the `STOPSIGNAL` instruction is used when a `docker
    container stop` command is issued. Remember that it is vital to use the exec form
    of your `ENTRYPOINT` and/or `CMD` instructions so that the application is PID
    1, and will receive the signals directly. Here is a link to an excellent blog
    post on using signals with Docker: [https://medium.com/@gchudnov/trapping-signals-in-docker-containers-7a57fdda7d86](https://medium.com/@gchudnov/trapping-signals-in-docker-containers-7a57fdda7d86).
    The article provides an excellent example of using a node.js app to handle the
    signals, complete with code and Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: The SHELL instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you have read in many sections throughout this chapter, there are several
    instructions that take two forms, the exec form or the shell form. As mentioned,
    the default used by all of the shell forms is `["/bin/sh", "-c"]` for Linux containers,
    and `["cmd", "/S", "/C"]` for Windows containers. The `SHELL` instruction allows
    you to change that default. Here is the syntax for the `SHELL` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `SHELL` instruction can be used more than once in a Dockerfile. All instructions
    that use a shell, and that come after a `SHELL` instruction, will use the new
    shell. Thus, you can change the shell multiple times in a single Dockerfile as
    needed. This can be especially powerful when creating Windows containers since
    it allows you to switch back and forth between using `cmd.exe` and `powershell.exe`.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker image build command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OK, so the image build command is not a Dockerfile instruction. Instead, it
    is the docker command that is used to turn your Dockerfile into a docker image.
    The Docker image build command sends the docker build context, including the Dockerfile,
    to the docker daemon, which parses the Dockerfile and builds the image layer by
    layer. We will discuss the build context shortly, but for now, consider it to
    be everything that is needed to build the Docker image based on the content found
    in the Dockerfile. The build command syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many options for the image build command. We will not be covering
    all of the options now, but let''s take a look at a few of the most common:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The Docker daemon builds the image by creating a new image from each command
    in the Dockerfile. Each new image is built upon the previous. Using the optional
    `--rm` parameter will instruct the daemon to delete all the intermediate images
    when the build completes successfully. Using this will slow the build process
    when you rebuild a successfully built image, but will keep the local image cache
    cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: We have already talked about build args when we covered the `ARG` instruction.
    Remember that the `--build-arg` option is how you provide a value to the `ARG`
    instruction in the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: The `--tag` option allows you to give your images a more human-readable name
    and version. We have seen this option used in several of the earlier examples
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: The `--file` option allows you to use a filename other than Dockerfile, and
    to keep the Dockerfile in a path other than the build context folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some image build commands for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You will notice the trailing `.` in each of the preceding examples. This period
    is indicating that the current working directory is the root of the build context
    for the image build.
  prefs: []
  type: TYPE_NORMAL
- en: Parser Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Parser Directives are a special subset of optional comment lines in the Dockerfile.
    Any parser directives must occur before the first normal comment line. They must
    also precede any blank lines or other build instructions, including the `FROM`
    instruction. Basically, all parser directives must be at the very top of the Dockerfile. By
    the way, if you haven''t figured it out yet, you can create a normal comment line
    in a Dockerfile by starting that line with a `#` character. The syntax for a parser
    directive is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what can you do with a parser directive? Well right now, the only one supported
    is `escape`. The `escape` parser directive is used to change what character is
    used to indicate that the next character in the instruction is to be treated as
    a character and not as the special character it represents. The default value
    if no parser directive is used is `\`. You have seen this used in several examples
    throughout this chapter to escape the newline character, allowing for instructions
    to be continued onto the next line in the Dockerfile. If it is necessary to use
    a different `escape` character, you can use the `escape` parser directive to handle
    that. You can set the `escape` character to one of two choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: One example where you might want to change the character used as the `escape`
    character is when you are creating a Dockerfile on Windows systems. As you know,
    the `\` is used to distinguish folder levels in path strings, such as `c:\windows\system32
  prefs: []
  type: TYPE_NORMAL
- en: '\drivers`. Switching to the backtick for the `escape` character will avoid
    needing to escape such strings as this: `c:\\windows\\system32\\drivers`.'
  prefs: []
  type: TYPE_NORMAL
- en: The build context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The build context is everything that gets sent to the Docker daemon when using
    the build image command. This includes the Dockerfile and the contents of the
    current working directory when the build command is issued, including all subdirectories
    that the current working directory may contain. It is possible to have the Dockerfile
    in a directory other than the current working directory by using a `-f` or `--file` option,
    but the Dockerfile still gets sent with the build context. Using the `.dockerignore`
    file, you can exclude files and folders from the build context when it gets sent
    to the Docker daemon.
  prefs: []
  type: TYPE_NORMAL
- en: 'When building Docker images, it is very important to keep the build context
    as small as possible. This is because the entire build context is sent to the
    Docker daemon for building the image. If you have unnecessary files and folders
    in the build context, then it will slow the build process, and depending on the
    contents of the Dockerfile, can result in bloated images. This is such an important
    consideration, that every image build command displays the size of the build context
    as the first line of the command''s output. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b0300473-f75d-45ad-8bb7-c37fd77987bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The build context becomes the filesystem root for the commands in the Dockerfile.
    For example, consider using the following `COPY` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This tells the Docker daemon to copy the `hello` file from the root of the build
    context into the root of the container image.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the command completes successfully, the image ID will be displayed, and
    if a `--tag` option is provided, the new tag and version will be shown as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a22a41a4-e7bb-47ec-8112-2e22153de989.png)'
  prefs: []
  type: TYPE_IMG
- en: One of the keys to keeping the build context small is the use of a `.dockerignore`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The .dockerignore file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are familiar with using `.gitignore` files, then you will already have
    a basic understanding of the purpose for the `.dockerignore` file. The `.dockerignore`
    file is used to exclude files that you do not want to be included with the build
    context during a docker image build. Using it helps to prevent sensitive and other
    unwanted files from being included in the build context, and potentially in the
    docker image. It is an excellent tool to help keep your Docker images small.
  prefs: []
  type: TYPE_NORMAL
- en: The `.dockerignore` file needs to be in the root folder of the build context.
    Like a `.gitignore` file, it uses a newline-separated list of patterns. Comments
    in the `.dockerignore` file are denoted by a `#` as the first character of a line.
    You can override a pattern by including an exception line. An exception line is
    denoted with a `!` as the first character of the line. All other lines are considered
    patterns to use to exclude files and/or folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Line order in the `.dockerignore` file is significant. Matching patterns of
    lines later in the file will override matching lines earlier in the file. If you
    add a pattern that matches the `.dockerignore` file or the Dockerfile file, they
    will still be sent to the docker daemon with the build context, but they will
    not be available to any `ADD` or `COPY` instructions, and therefore cannot end
    up in the resulting image. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OK! That was an adventure. You should now be able to build any type of Docker
    image that your heart desires. You know when to use `COPY` versus `ADD`, when
    to use `ENV` versus `ARG`, and perhaps most importantly, when to use `CMD` versus
    `ENTERYPOINT`. You even learned how to travel through time! This information is
    really a great foundation for getting started with Docker and will serve as a
    great reference as you develop more complex Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you have learned a lot from this chapter, but we still have more to learn,
    so let's turn our attention to the next topic. In [Chapter 4](6e908793-3bc0-45f3-bcb5-af85ac6aecab.xhtml), *Docker
    Volumes*, we are going to learn more about Docker volumes. Turn the page and let's
    continue our quick-start journey.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the following links for information about topics discussed in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The hello-world GitHub repository: [https://github.com/docker-library/hello-world](https://github.com/docker-library/hello-world)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker volumes: [https://docs.docker.com/storage/volumes/](https://docs.docker.com/storage/volumes/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using signals with Docker: [https://medium.com/@gchudnov/trapping-signals-in-docker-containers-7a57fdda7d86](https://medium.com/@gchudnov/trapping-signals-in-docker-containers-7a57fdda7d86)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `.dockerignore` reference document: [https://docs.docker.com/engine/reference/builder/#dockerignore-file](https://docs.docker.com/engine/reference/builder/#dockerignore-file)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices for the Dockerfile: [https://docs.docker.com/v17.09/engine/userguide/eng-image/dockerfile_best-practices/](https://docs.docker.com/v17.09/engine/userguide/eng-image/dockerfile_best-practices/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
