- en: Working with Container Orchestration Engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be looking at the **Container Orchestration Engine** (**COE**).
    Container Orchestration Engines are tools which help in managing many containers
    running on multiple hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to COE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Swarm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache Mesos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes hands-on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to COE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers provide users with an easy way to package and run their applications.
    Packaging involves defining the library and tools that are necessary for a user's
    application to run. These packages, once converted to images, can be used to create
    and run containers. These containers can be run anywhere, whether it's on developer
    laptops, QA systems, or production machines, without any change in environment.
    Docker and other container runtime tools provide the facility to manage the life
    cycle of such containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these tools, users can build and manage images, run containers, delete
    containers, and perform other container life cycle operations. But these tools
    can only manage one container on a single host. When we deploy our application
    on multiple containers and multiple hosts, we need some kind of automation tool.
    This type of automation is generally called orchestration. Orchestration tools
    provide a number of features, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning and managing hosts on which containers will run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pulling the images from the repository and instantiating the containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the life cycle of containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling containers on hosts based on the host's resource availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting a new container when one dies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling the containers to match the application's demand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing networking between containers so that they can access each other on
    different hosts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing these containers as services so that they can be accessed from outside
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Health monitoring of the containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrading the containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, these kinds of orchestration tools provide declarative configuration
    in YAML or JSON format. These definitions carry all of the information related
    to containers including image, networking, storage, scaling, and other things.
    Orchestration tools use these definitions to apply the same setting to provide
    the same environment every time.
  prefs: []
  type: TYPE_NORMAL
- en: There are many container orchestration tools available, such as Docker Machine,
    Docker Compose, Kuberenetes, Docker Swarm, and Apache Mesos, but this chapter
    focuses only on Docker Swarm, Apache Mesos, and Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Swarm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Docker Swarm** is a native orchestration tool from Docker itself. It manages
    a pool of Docker hosts and turns them into a single virtual Docker host. Docker
    Swarm provides a standard Docker API to manage containers on the cluster. It''s
    easy for users to move to Docker Swarm if they are already using Docker to manage
    their containers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Swarm follows a *swap, plug, and play* principle. This provides pluggable
    scheduling algorithms, a broad registry, and discovery backend support in the
    cluster. Users can use various scheduling algorithms and discovery backends as
    per their needs. The following diagram represents the Docker Swarm architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Docker Swarm components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following sections explain the various components in Docker Swarm.
  prefs: []
  type: TYPE_NORMAL
- en: Node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node is an instance of the Docker host participating in the Swarm cluster. There
    can be one or multiple nodes in a single Swarm cluster deployment. Nodes are categorized
    into Manager and Worker based on their roles in the system.
  prefs: []
  type: TYPE_NORMAL
- en: Manager node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Swarm manager node manages the nodes in the cluster. It provides the API
    to manage the nodes and containers across the cluster. Manager nodes distribute
    units of work, also known as tasks, to worker nodes. If there are multiple manager
    nodes, then they select a single leader to perform an orchestration task.
  prefs: []
  type: TYPE_NORMAL
- en: Worker node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The worker node receives and executes task distributed by manager nodes. By
    default, every manager node is also a worker node, but they can be configured
    to run Manager tasks exclusively. Worker nodes run agents and keep track of tasks
    running on them, and reports them. The Worker node also notifies the manager node
    about the current state of assigned tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Task is the individual Docker container with a command to run inside the container.
    The manager assigns the tasks to worker nodes. Tasks are the smallest unit of
    scheduling in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service is the interface for a set of Docker containers or tasks running across
    the Swarm cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Discovery service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Discovery service stores cluster states and provides node and service discoverability.
    Swarm supports a pluggable backend architecture that supports etcd, Consul, Zookeeper,
    static files, lists of IPs, and so on, as discovery services.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Swarm scheduler schedules the tasks on different nodes in the system. Docker
    Swarm comes with many built-in scheduling strategies that gives users the ability
    to guide container placement on nodes in order to maximize or minimize the task
    distribution across the cluster. The random strategy is also supported by Swarm.
    It chooses a random node to place the task on.
  prefs: []
  type: TYPE_NORMAL
- en: Swarm mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In version 1.12, Docker introduced the Swarm mode, built into its engine. To
    run a cluster, the user needs to execute two commands on each Docker host:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To enter Swarm mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a node to the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Unlike Swarm, Swarm mode comes with service discovery, load balancing, security,
    rolling updates and scaling, and so on, built into the Docker engine itself. Swarm
    mode makes the management of the cluster easy since it does not require any orchestration
    tools to create and manage the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Apache Mesos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apache Mesos is an open source, fault-tolerant cluster manager. It manages a
    set of nodes called slaves and offers their available computing resources to frameworks.
    Frameworks take the resource availability from the master and launches the tasks
    on the slaves. Marathon is one such framework, which runs containerized applications
    on the Mesos cluster. Together, Mesos and Marathon become a container orchestration
    engine like Swarm or Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram represents the whole architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Apache Mesos and its components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a list of Apache Mesos components:'
  prefs: []
  type: TYPE_NORMAL
- en: Master
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Master manages the slave nodes in the system. There may be many masters in the
    system, but only one is elected as leader.
  prefs: []
  type: TYPE_NORMAL
- en: Slaves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Slaves are the nodes which offer their resources to the master and run the tasks
    provided by frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Frameworks are long running applications consisting of schedulers which take
    resource offers from the master and execute the tasks on the slave.
  prefs: []
  type: TYPE_NORMAL
- en: Offer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Offer is nothing but a collection of each slave node's available resources.
    The master gets these offers from slave nodes and provides them to frameworks,
    which in turn runs tasks on the slave nodes
  prefs: []
  type: TYPE_NORMAL
- en: Tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tasks are the smallest unit of work scheduled by frameworks to be run on slave
    nodes. For example, a containerized application can be one task
  prefs: []
  type: TYPE_NORMAL
- en: Zookeeper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Zookeeper is a centralized configuration manager in a cluster. Mesos uses Zookeeper
    to elect a master and for slaves to join the cluster
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the Mesos Marathon framework provides service discovery and load
    balancing for long running applications, such as containers. Marathon also provides
    the REST API to manage workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is a container orchestration engine created by Google, designed to
    automate the deployment, scaling, and operating of containerized applications.
    It is one of the fastest developing COEs because it provides a reliable platform
    to build distributed applications on a massive scale. Kubernetes automates your
    application, manages its life cycle, and maintains and tracks resource allocation
    in a cluster of servers. It can run application containers on physical or virtual
    machine clusters.
  prefs: []
  type: TYPE_NORMAL
- en: 'It provides a unified API to deploy web applications, databases, and batch
    jobs. It comprises of a rich set of complex features:'
  prefs: []
  type: TYPE_NORMAL
- en: Auto-scaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-healing infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration and updating of batch jobs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service discovery and load balancing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application life cycle management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quota management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section outlines the Kubernetes architecture and the various components
    that deliver a running cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes consists of the following components from a top-level view:'
  prefs: []
  type: TYPE_NORMAL
- en: External requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Master node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Worker nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the architecture of Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We will discuss each of the components in detail in the next section. Some of
    the key components are depicted in the diagram.
  prefs: []
  type: TYPE_NORMAL
- en: External request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users interact with Kubernetes cluster through APIs; they explain what their
    requirements are and what their application looks like, and Kubernetes does all
    the hard work to manage their application. `kubectl` is command-line tool from
    the Kubernetes project to call Kubernetes APIs in a simple way.
  prefs: []
  type: TYPE_NORMAL
- en: Master node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The master node provides the cluster's control plane. It acts like a controller
    in the cluster. Most of the major functionalities, such as scheduling, service
    discovery, load balancing, responding to cluster events, and so on, are done by
    components running on the master node only. Now, let's take a look at the master
    components and their functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: kube-apiserver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It exposes the Kubernetes APIs. All of the internal and external requests go
    through the API server. It verifies all of the incoming requests for authenticity
    and the right level of access, and then forwards the requests to targeted components
    in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: etcd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`etcd` is used for storing all of the cluster state information by Kubernetes.
    `etcd` is a critical component in Kubernetes.'
  prefs: []
  type: TYPE_NORMAL
- en: kube-controller-manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple controllers in the Kubernetes cluster such as the node controller,
    replication controller, endpoints controller, service account, and token controllers.
    These controllers are run as background threads that handle routine tasks in the
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: kube-scheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It watches all of the newly created pods and schedules them to run on a node
    if they aren't assigned to any node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please read the Kubernetes documentation ([https://kubernetes.io/docs/concepts/overview/components/](https://kubernetes.io/docs/concepts/overview/components/))
    to learn about other components in the control plane, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-controller-manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container resource monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cluster level logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Worker nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The worker nodes run the user's applications and services. There can be one
    or more worker node in the cluster. You can add or remove nodes from the cluster
    to achieve scalability in the cluster. Worker nodes also run multiple components
    to manage applications.
  prefs: []
  type: TYPE_NORMAL
- en: kubelet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`kubelet` is the primary agent that lives on every worker node. It listens
    to the `kube-apiserver` for commands to perform. Some of the functionalities of
    `kubelet` include mounting the pod''s volume, downloads the pod''s secrets, running
    the pod''s containers via Docker or specified container runtime, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: kube-proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It enables the service abstraction for Kubernetes by maintaining network rules
    on the host and performing connection forwarding.
  prefs: []
  type: TYPE_NORMAL
- en: Container runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Either Docker or Rocket to create containers.
  prefs: []
  type: TYPE_NORMAL
- en: supervisord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`supervisord` is a lightweight process monitor and control system that can
    be used to keep `kubelet` and Docker running.'
  prefs: []
  type: TYPE_NORMAL
- en: fluentd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`fluentd` is a daemon which helps provide cluster-level logging.'
  prefs: []
  type: TYPE_NORMAL
- en: Concepts in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following sections, we will learn about the concepts of Kubernetes that
    are used to represent your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Pod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A pod is the smallest deployable unit of computing in Kubernetes. A pod is a
    group of one or more containers with shared storage or a shared network, and a
    specification of how to run the containers. Containers themselves are not assigned
    to hosts, whereas closely related containers are always co-located and co-scheduled
    together as pods and run in a shared context.
  prefs: []
  type: TYPE_NORMAL
- en: A pod models an application-specific logical host; it contains one or more application
    container, and they are relatively tightly coupled. In a pre-container world,
    they would have executed on the same physical or virtual machine. Using pods,
    we have the advantage of better resource sharing, guaranteed fate sharing, inter-process
    communication and simplified management.
  prefs: []
  type: TYPE_NORMAL
- en: Replica sets and replication controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Replica sets are the next generation of replication controllers. The only difference
    between both is that replica sets support the more advanced set-based selectors
    whereas replication controllers only support equality-based selectors, therefore
    making replica sets more flexible than replication controllers. However, the following
    explanation applies to both.
  prefs: []
  type: TYPE_NORMAL
- en: A pod is ephemeral and won't be rescheduled if the node it is running on goes
    down. The replica set ensures that a specific number of pod instances (or replicas)
    are running at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: Deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deployment is high-level abstraction which creates replica sets and pods. Replica
    sets maintain the desired number of pods in a running state. Deployment provides
    an easy way to upgrade, rollback, and scale up or scale down pods by just changing
    the deployment specification.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Secrets are used to store sensitive information such as usernames, passwords,
    OAuth tokens, certificates, and SSH keys. It's safer and more flexible to store
    such sensitive information in secrets rather than putting them in pod templates.
    Pods can refer these secrets and use the information inside them.
  prefs: []
  type: TYPE_NORMAL
- en: Labels and selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Labels are key value pairs that can be attached to objects, such as pods and
    even nodes. They are used to specify the identifying attributes of objects that
    are meaningful and relevant to users. Labels can be attached to objects at creation
    time and added or modified later. They are used to organize and select subsets
    of objects. Some examples include environment (development, testing, production,
    release), stable, pike, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Labels don't provide uniqueness. Using label selectors, a client or user can
    identify and subsequently manage a group of objects. This is the core grouping
    primitive of Kubernetes and it is used in many situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes supports two kinds of selectors: equality-based and set-based. Equality-based
    uses key value pairs to filter based on basic equality or inequality, whereas
    set-based are a bit more powerful and allow for the filtering of keys according
    to a set of values.'
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As pods are short-lived objects in Kubernetes, the IP address assigned to them
    can't be relied upon to be stable for a long time. This makes the communication
    between pods difficult. Hence, Kubernetes has introduced the concept of a service.
    A service is an abstraction on top of a number of pods and a policy by which to
    access them, typically requiring the running of a proxy for other services to
    communicate with it via a virtual IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Volume provides persistent storage to pods or containers. If data is not persisted
    on external storage, then once the container crashes, all of its files will be
    lost. Volumes also make data sharing easy between multiple containers inside the
    pod. Kubernetes supports many types of volumes, and pods can use any number of
    volumes simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes can run on various platforms, from laptops and VMs on a cloud provider
    to a rack of bare metal servers. There are multiple solutions today to install
    and run Kubernetes clusters. Read the Kubernetes documentation to find the best
    solution for your particular use case.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use `kubeadm` to bring up a Kubernetes cluster on Ubuntu
    16.04+. `kubeadm` can be used to easily bring up a cluster with a single command
    per machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this installation, we will use a tool called `kubeadm`, which is a part
    of Kubernetes. The prerequisites for installing `kubeadm` are:'
  prefs: []
  type: TYPE_NORMAL
- en: One or more machines running Ubuntu 16.04+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum of 1 GB or more of RAM per machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Full network connectivity between all machines in the cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of the machines in the cluster need the following components to be installed:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Docker on all of the machines. As per the Kubernetes documentation,
    version 1.12 is recommended. Please refer to the *Installation of Docker* section
    in [Chapter 1](part0021.html#K0RQ0-08510d04d33546e798ef8c1140114deb), *Working
    with Containers*, for instructions on installing Docker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install `kubectl` on each machine. `kubectl` is a command-line tool from Kubernetes
    to deploy and manage applications on Kubernetes. You can use `kubectl` to inspect
    cluster resources, create, delete, and update components, and look at your new
    cluster and bring up example apps. Again, there are multiple options to install
    `kubectl`. In this chapter, we will use curl to install it. Please refer to the
    Kubernetes documentation for more options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download the latest release of `kubectl` using curl:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the `kubectl` binary executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, install `kubelet` and `kubeadm` on all the machines. `kubelet` is the
    component that runs on all of the machines in your cluster and does things such
    as starting pods and containers. `kubeadm` is the command to bootstrap the cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Log in as root:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Update and install the packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the authenticate key for the package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the Kubernetes source to the `apt` list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Update and install the tools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The following steps demonstrate how to set up a secure Kubernetes cluster using
    `kubeadm`. We will also create a pod network on the cluster so that the application
    components can talk to each other. Finally, install a sample microservices application
    on the cluster to verify the installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the master node. To initialize the master, choose one of the machines
    you previously installed `kubeadm` on and run the following command. We have specified
    `pod-network-cidr` for providing the network for communication between pods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to the `kubeadm` reference document to read more about the flags
    `kubeadm init` provides.
  prefs: []
  type: TYPE_NORMAL
- en: This may take several minutes, as `kubeadm init` will first run a series of
    pre-checks to ensure that the machine is ready to run Kubernetes. It might expose
    warnings and exit on errors depending on the pre-check results. It will then download
    and install the control plane components and cluster database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding command looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Save the `kubeadm join` command from the preceding output. You will need this
    to join nodes to your Kubernetes cluster. The token is used for mutual authentication
    between the master and the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to start using your cluster, run the following commands as a regular user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Install a pod network. This network is used for the communication between pods
    in the cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The network must be deployed before running any application. Also, services
    such as `kube-dns` will not start up before a network is installed. `kubeadm`
    only supports **Container Network Interface** (**CNI**) networks and does not
    support `kubenet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple network add-on projects which can be used to create a secure
    network. To see a complete list, please visit the Kubernetes documentation for
    reference. In this example, we will use flannel for the networking. Flannel is
    an overlay network provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can confirm that it is working by checking that the `kube-dns` pod is up
    and running in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Join the nodes to the cluster. To add nodes to the Kubernetes cluster, and
    SSH to the node and run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following command to verify the joining of the nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify your installation by creating a sample Nginx pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Kubernetes hands-on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned how to install the Kubernetes cluster in the previous section. Now,
    let's create a more complex example with Kubernetes. In this application, we will
    deploy an application running a WordPress site and MySQL database using official
    Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a persistent volume. Both WordPress and MySQL will use this volume to
    store data. We will create two local persistent volumes of size 5 GB each. Copy
    the following content to the `volumes.yaml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create the volume by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that the volumes were created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a secret to store the MySQL password. This secret will be referenced
    by the MySQL and WordPress pods so that those pods will have access to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the secrets were created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the MySQL deployment. We will now create a service that exposes a MySQL
    container, a persistent volume claim of 5 GB, and a deployment running the pod
    with the MySQL container. Copy the following content to the `mysql-deployment.yaml`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, launch the MySQL pod:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the status of the pod:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can check the logs of the pod by running the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This will also give you the option of removing the test databases and anonymous
    user created by default. It is strongly recommended for production servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the manual for more instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Please report any problems at [http://bugs.mysql.com/](http://bugs.mysql.com/).
    The latest information about MySQL is available on the web at [http://www.mysql.com](http://www.mysql.com).
    Support MySQL by buying support/licenses at: [http://shop.mysql.com](http://shop.mysql.com).
  prefs: []
  type: TYPE_NORMAL
- en: Please note that a new default `config` file was not created; please make sure
    your `config` file is current.
  prefs: []
  type: TYPE_NORMAL
- en: The default `config` file, `/etc/mysql/my.cnf`, exists on the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'This file will be read by default by the MySQL server. If you do not want to
    use this, either remove it or use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The MySQL `init` process is now done. We are ready for startup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the status of persistent volume claims by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the WordPress deployment. We will now create a service that exposes
    a WordPress container, a persistent volume claim of 5 GB, and a deployment running
    the pod with the WordPress container. Copy the following content to the `wordpress-deployment.yaml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, launch the WordPress pod:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the status of the service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The application is up and running now!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lists the commands needed to delete all of the resources created:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete your secret:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete all of the deployments and services:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete the persistent volume claims and the persistent volumes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about container orchestration engines. We looked
    at the different COEs such as Docker Swarm and Apache Mesos. We dealt with Kubernetes
    and its architecture, components, and concepts in detail.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to install a Kubernetes cluster using the `kubeadm` tool. Then,
    at the end, we did a hands-on exercise to run a MySQL WordPress application on
    a Kubernetes cluster. In the next chapter, we will read about the OpenStack architecture
    and its core components.
  prefs: []
  type: TYPE_NORMAL
