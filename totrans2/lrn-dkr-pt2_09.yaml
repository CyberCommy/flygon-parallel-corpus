- en: Chapter 9. Testing with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Undoubtedly, the trait of testing has been at the forefront of the software
    engineering discipline. It is widely accepted that there is a deep and decisive
    penetration of software into every kind of tangible object in our daily environments
    these days in order to have plenty of smart, connected, and digitized assets.
    Also, with a heightened focus on distributed and synchronized software, the complexity
    of the software design, development, testing and debugging, deployment, and delivery
    are continuously on the climb. There are means and mechanisms being unearthed
    to simplify and streamline the much-needed automation of software building and
    the authentication of software reliability, resiliency, and sustainability. Docker
    is emerging as an extremely flexible tool to test a wide variety of software applications.
    In this chapter, we are going to discuss how to effectively leverage the noteworthy
    Docker advancements for software testing and its unique advantages in accelerating
    and augmenting testing automation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief overview of **test-driven development** (**TDD**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing your code inside Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating the Docker testing process into Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The emerging situation is that Docker containers are being leveraged to create
    development and testing environments that are the exact replicas of the production
    environment. Containers require less overhead when compared to virtual machines,
    which have been the primary environments for development, staging, and deployment
    environments. Let's start with an overview of test-driven development of the next
    generation software and how the Docker-inspired containerization becomes handy
    in simplifying the TDD process.
  prefs: []
  type: TYPE_NORMAL
- en: A brief overview of the test-driven development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The long and arduous journey of software development has taken many turns and
    twists in the past decades, and one of the prominent software engineering techniques
    is nonetheless the TDD. There are more details and documents on TDD at [http://agiledata.org/essays/tdd.html](http://agiledata.org/essays/tdd.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, the test-driven development, also popularly known as TDD, is
    a software development practice in which the development cycle begins with writing
    a test case that would fail, then writes the actual software to make the test
    pass, and continues to refactor and repeat the cycle till the software reaches
    the acceptable level. This process is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A brief overview of the test-driven development](graphics/7937OT_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testing your code inside Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will take you through a journey in which we will show you
    how TDD is done using stubs, and how Docker can come handy in developing software
    in the deployment equivalent system. For this purpose, we take a web application
    use case that has a feature to track the visit count of each of its users. For
    this example, we use Python as the implementation language and `redis` as the
    key-value pair database to store the users hit count. Besides, to showcase the
    testing capability of Docker, we limit our implementation to just two functions:
    `hit` and `getHit`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NOTE: All the examples in this chapter use `python3` as the runtime environment.
    The `ubuntu 14.04` installation comes with `python3` by default. If you don''t
    have `python3` installed on your system, refer to the respective manual to install
    `python3`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As per the TDD practice, we start by adding unit test cases for the `hit` and
    `getHit` functionalities, as depicted in the following code snippet. Here, the
    test file is named `test_hitcount.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example is also available at [https://github.com/thedocker/testing/tree/master/src](https://github.com/thedocker/testing/tree/master/src).
  prefs: []
  type: TYPE_NORMAL
- en: Here, in the first line, we are importing the `unittest` Python module that
    provides the necessary framework and functionality to run the unit test and generate
    a detailed report on the test execution. In the second line, we are importing
    the `hitcount` Python module, where we are going to implement the hit count functionality.
    Then, we will continue to add the test code that would test the `hitcount` module's
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the test suite using the unit test framework of Python, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output generated by the unit test framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the test failed with the error message `ImportError: No module
    named ''hitcount''` because we had not even created the file and hence, it could
    not import the `hitcount` module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a file with the name `hitcount.py` in the same directory as `test_hitcount.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Continue to run the unit test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output generated by the unit test framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Again the test suite failed like the earlier but with a different error message
    `AttributeError: ''module'' object has no attribute ''hit''`. We are getting this
    error because we have not implemented the `hit` function yet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed to implement the `hit` and `getHit` functions in `hitcount.py`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example is also available on GitHub at [https://github.com/thedocker/testing/tree/master/src](https://github.com/thedocker/testing/tree/master/src).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: To continue with this example, you must have the `python3` compatible
    version of package installer (`pip3`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command is used to install `pip3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the first line of this program, we are importing the `redis` driver, which
    is the connectivity driver of the `redis` database. In the following line, we
    are connecting to the `redis` database, and then we will continue to implement
    the `hit` and `getHit` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `redis` driver is an optional Python module, so let''s proceed to install
    the `redis` driver using the pip installer, which is illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `unittest` will still fail even after installing the `redis` driver because
    we are not running a `redis` database server yet. So, we can either run a `redis`
    database server to successfully complete our unit testing or take the traditional
    TDD approach of mocking the `redis` driver. Mocking is a testing approach wherein
    complex behavior is substituted by predefined or simulated behavior. In our example,
    to mock the redis driver, we are going to leverage a third-party Python package
    called mockredis. This mock package is available at [https://github.com/locationlabs/mockredis](https://github.com/locationlabs/mockredis)
    and the `pip` installer name is `mockredispy`. Let''s install this mock using
    the pip installer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Having installed `mockredispy`, the `redis` mock, let''s refactor our test
    code `test_hitcount.py` (which we had written earlier) to use the simulated `redis`
    functionality provided by the `mockredis` module. This is accomplished by the
    patch method provided by the `unittest.mock` mocking framework, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example is also available on GitHub at [https://github.com/thedocker/testing/tree/master/src](https://github.com/thedocker/testing/tree/master/src).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the test suite again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Finally, as we can see in the preceding output, we successfully implemented
    our visitors count functionality through the test, code, and refactor cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Running the test inside a container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we walked you through the complete cycle of TDD, in
    which we installed additional Python packages to complete our development. However,
    in the real world, one might work on multiple projects that might have conflicting
    libraries and hence, there is a need for the isolation of runtime environments.
    Before the advent of Docker technology, the Python community used to leverage
    the `virtualenv` tool to isolate the Python runtime environment. Docker takes
    this isolation a step further by packaging the OS, the Python tool chain, and
    the runtime environment. This type of isolation gives a lot of flexibility to
    the development community to use appropriate software versions and libraries as
    per the project needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the step-by-step procedure to package the test and visitor count implementation
    of the previous section to a Docker container and perform the test inside the
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Craft a `Dockerfile` to build an image with the `python3` runtime, the `redis`
    and `mockredispy` packages, both the `test_hitcount.py` test file and the visitors
    count implementation `hitcount.py`, and finally, launch the unit test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example is also available on GitHub at [https://github.com/thedocker/testing/tree/master/src](https://github.com/thedocker/testing/tree/master/src).
  prefs: []
  type: TYPE_NORMAL
- en: Now create a directory called `src` on the directory, where we crafted our `Dockerfile`.
    Move the `test_hitcount.py` and `hitcount.py` files to the newly created `src`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Build the `hit_unittest` Docker image using the `docker build` subcommand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have successfully built the image, let''s launch our container
    with the unit testing bundle using the `docker run` subcommand, as illustrated
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Apparently, the unit test ran successfully with no errors because we already
    packaged the tested code.
  prefs: []
  type: TYPE_NORMAL
- en: In this approach, for every change, the Docker image is built and then, the
    container is launched to complete the test.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Docker container as a runtime environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we built a Docker image to perform the testing. Particularly,
    in the TDD practice, the unit test cases and the code go through multiple changes.
    Consequently, the Docker image needs to be built over and over again, which is
    a daunting job. In this section, we will see an alternative approach in which
    the Docker container is built with a runtime environment, the development directory
    is mounted as a volume, and the test is performed inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: During this TDD cycle, if an additional library or update to the existing library
    is required, then the container will be updated with the required libraries and
    the updated container will be committed as a new image. This approach gives the
    isolation and flexibility that any developer would dream of because the runtime
    and its dependency live within the container, and any misconfigured runtime environment
    can be discarded and a new runtime environment can be built from a previously
    working image. This also helps to preserve the sanity of the Docker host from
    the installation and uninstallation of libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is a step-by-step instruction on how to use the Docker
    container as a nonpolluting yet very powerful runtime environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with launching the Python runtime interactive container, using the
    `docker run` subcommand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, in this example, the `/home/peter/src/hitcount` Docker host directory
    is earmarked as the placeholder for the source code and test files. This directory
    is mounted in the container as `/src`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, on another terminal of the Docker host, copy both the `test_hitcount.py`
    test file and the visitors count implementation `hitcount.py` to `/home/peter/src/hitcount
    directory`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Switch to the Python runtime interactive container terminal, change the current
    working directory to `/src`, and run the unit test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Evidently, the test failed because it could not find the `mockredis` Python
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Proceed to install the `mockredispy pip` package because the previous step
    failed, as it could not find the `mockredis` library in the runtime environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerun the Python unit test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Again, the test failed because the `redis` driver is not yet installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue to install the `redis` driver using the pip installer, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Having successfully installed the `redis` driver, let''s once again run the
    unit test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Apparently, this time the unit test passed with no warnings or error messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have a runtime environment that is good enough to run our test cases.
    It is better to commit these changes to a Docker image for reuse, using the `docker
    commit` subcommand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: From now on, we can use the `python_rediswithmock` image to launch new containers
    for our TDD.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we vividly illustrated the approach on how to use the Docker
    container as a testing environment, and also at the same time, preserve the sanity
    and sanctity of the Docker host by isolating and limiting the runtime dependency
    within the container.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Docker testing into Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we laid out a stimulating foundation on software testing,
    how to leverage the Docker technology for the software testing, and the unique
    benefits of the container technology during the testing phase. In this section,
    we will introduce you to the steps required to prepare the Jenkins environment
    for testing with Docker, and then, demonstrate how Jenkins can be extended to
    integrate and automate testing with Docker using the well-known hit count use
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Jenkins environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will take you through the steps to install `jenkins`, GitHub
    plugin for Jenkins and `git`, and the revision control tool. These steps are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with adding the Jenkins'' trusted PGP public key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using `wget` to download the PGP public key, and then we add it
    to the list of trusted keys using the apt-key tool. Since Ubuntu and Debian share
    the same software packaging, Jenkins provides a single common package for both
    Ubuntu and Debian.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the Debian package location to the `apt` package source list, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Having added the package source, continue to run the `apt-get` command update
    option to resynchronize the package index from the sources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, install `jenkins` using the `apt-get` command install option, as demonstrated
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, activate the `jenkins` service using the `service` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `jenkins` service can be accessed through any web browsers by specifying
    the IP address (`10.1.1.13`) of the system in which Jenkins is installed. The
    default port number for Jenkins is `8080`. The following screenshot is the entry
    page or **Dashboard** of **Jenkins**:![Preparing the Jenkins environment](graphics/7937OT_09_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this example, we are going to use GitHub as the source code repository.
    Jenkins does not support GitHub by default and hence, we need to install the GitHub
    plugin. During the installation, sometimes Jenkins does not populate the plugin
    availability list, and hence, you have to force it to download the list of available
    plugins. You can do so by performing the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Manage Jenkins** on the left-hand side of the screen, which will take
    us to a **Manage Jenkins** page, as shown in the following screenshot:![Preparing
    the Jenkins environment](graphics/7937OT_09_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Manage Jenkins** page, select **Manage Plugins** and this will take
    us to the **Plugin Manager** page, as shown in the following screenshot:![Preparing
    the Jenkins environment](graphics/7937OT_09_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, on the **Plugin Manager** page, select the **Advanced** tab, go to the
    bottom of this page, and you will find the **Check now** button in the right-hand
    side corner of the page. Click on the **Check now** button to start the plugin
    updates. Alternatively, you can directly go to the **Check now** button on the
    **Advanced** page by navigating to `http://<jenkins-server>:8080/pluginManager/advanced`,
    wherein `<jenkins-server>` is the IP address of the system in which Jenkins is
    installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NOTE: If Jenkins does not update the available plugin list, it is most likely
    a mirror site issue, so modify the **Update Site** field with a working mirror
    URL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having updated the available plugin list, let''s continue to install the GitHub
    plugin, as depicted in the following substeps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Available** tab in the **Plugin Manager** page, which will list
    all the available plugins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `GitHub plugin` as the filter, which will list just the GitHub plugin,
    as shown in the following screenshot:![Preparing the Jenkins environment](graphics/7937OT_09_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the checkbox, and click on **Download now and install after restart**.
    You will be taken to a screen that will show you the progress of the plugin installation:![Preparing
    the Jenkins environment](graphics/7937OT_09_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After all the plugins have successfully downloaded, go ahead and restart Jenkins
    using `http://< jenkins-server >:8080/restart`, where `<jenkins-server>` is the
    IP address of the system in which Jenkins is installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that the `git` package is installed, otherwise install the `git` package
    using the `apt-get` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have been running the Docker client using the `sudo` command, but
    unfortunately, we could not invoke `sudo` inside Jenkins because sometimes it
    prompts for a password. To overcome the `sudo` password prompt issue, we can make
    use of the Docker group, wherein any user who is part of the Docker group can
    invoke the Docker client without using the `sudo` command. Jenkins installation
    always sets up a user and group called `jenkins` and runs the Jenkins server using
    that user and group. So, we just need to add the `jenkins` user to the Docker
    group to get the Docker client working without the `sudo` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the `jenkins` service for the group change to take effect using the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We have set up a Jenkins environment that is now capable of automatically pulling
    the latest source code from the [http://github.com](http://github.com) repository,
    packaging it as a Docker image, and executing the prescribed test scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Automating the Docker testing process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will explore how to automate testing using Jenkins and Docker.
    As mentioned earlier, we are going to use GitHub as our repository. We have already
    uploaded the `Dockerfile`, `test_hitcount.py`, and `hitcount.py` files of our
    previous example to GitHub at [https://github.com/thedocker/testing](https://github.com/thedocker/testing),
    which we are to use in the ensuing example. However, we strongly encourage you
    to set up your own repository at [http://github.com](http://github.com), using
    the fork option that you can find at [https://github.com/thedocker/testing](https://github.com/thedocker/testing),
    and substitute this address wherever applicable in the ensuing example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the detailed steps to automate the Docker testing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure Jenkins to trigger a build when a file is modified in the GitHub
    repository, which is illustrated in the following substeps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect to the Jenkins server again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select either **New Item** or **create new jobs**:![Automating the Docker testing
    process](graphics/7937OT_09_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the following screenshot, give a name to the project (for example, `Docker-Testing`),
    and select the **Freestyle project** radio button:![Automating the Docker testing
    process](graphics/7937OT_09_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next screenshot, select the **Git** radio button under **Source Code
    Management**, and specify the GitHub repository URL in the **Repository URL**
    text field:![Automating the Docker testing process](graphics/7937OT_09_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Poll SCM** under **Build Triggers** to schedule GitHub polling for
    every `15` minute interval. Type the following line of code `H/15 * * * *` in
    the **Schedule** textbox, as shown in the following screenshot. For testing purposes,
    you can reduce the polling interval:![Automating the Docker testing process](graphics/7937OT_09_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down the screen a little further, and select the **Add build step** button
    under **Build**. In the drop-down list, select **Execute shell** and type in the
    text, as shown in the following screenshot:![Automating the Docker testing process](graphics/7937OT_09_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, save the configuration by clicking on the **Save** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to the Jenkins Dashboard, and you can find your test listed on the dashboard:![Automating
    the Docker testing process](graphics/7937OT_09_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can either wait for the Jenkins schedule to kick-start the build, or you
    can click on the clock icon on the right-hand side of the screen to kick-start
    the build immediately. As soon as the build is done, the Dashboard is updated
    with the build status as a success or failure, and the build number:![Automating
    the Docker testing process](graphics/7937OT_09_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you hover the mouse closer to the build number, you will get a drop-down
    button with options, such as **Changes**, **Console Output**, and so on, as shown
    in the following screenshot:![Automating the Docker testing process](graphics/7937OT_09_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Console Output** option will show the details highlighted for the build,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Evidently, the test failed because of the wrong module name **error_hitcount**,
    which we deliberately introduced. Now, let's experiment a negative scenario by
    deliberately introducing a bug in **test_hitcount.py** and observe the effect
    the on Jenkins build. As we have configured Jenkins, it faithfully polls the GitHub
    and kick-starts the build:![Automating the Docker testing process](graphics/7937OT_09_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apparently, the build failed as we expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final step, open **Console Output** of the failed build:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Evidently, the test failed because of the wrong module name `error_hitcount`,
    which we deliberately introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Cool, isn't it? We automated our testing using Jenkins and Docker. Besides,
    we are able to experience the power of testing automation using Jenkins and Docker.
    In a large-scale project, Jenkins and Docker can be combined together to automate
    the complete unit testing needs, and thus, to automatically capture any defects
    and deficiencies introduced by any developers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The potential benefits of containerization are being discovered across the breadth
    and the length of software engineering. Previously, testing sophisticated software
    systems involved a number of expensive and hard-to-manage server modules and clusters.
    Considering the costs and complexities involved, most of the software testing
    is accomplished using mocking procedures and stubs. All of this is going to end
    for good with the maturity of the Docker technology. The openness and flexibility
    of Docker enables it to work seamlessly with other technologies to substantially
    reduce the testing time and complexity.
  prefs: []
  type: TYPE_NORMAL
- en: For a long time, the leading ways of testing software systems included mocking,
    dependency, injection, and so on. Usually, these mandate creating many sophisticated
    abstractions in the code. The current practice for developing and running test
    cases against an application is actually done on stubs rather than on the full
    application. That is, with a containerized workflow, it is very much possible
    to test against real application containers with all the dependencies. The contributions
    of the Docker paradigm, especially for the testing phenomenon and phase are therefore
    being carefully expounded and recorded in the recent past. Precisely speaking,
    the field of software engineering is moving towards smart and sunnier days with
    all the innovations in the Docker space.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we clearly expounded and explained a powerful testing framework
    for integrated applications using the Docker-inspired containerization paradigm.
    Increasingly for the agile world, the proven and potential TDD method is being
    insisted as an efficient software building and sustenance methodology. This chapter
    has utilized the Python unit test framework to illustrate how the TDD methodology
    is a pioneering tool for software engineering. The unit test framework is tweaked
    to be efficiently and elegantly containerized, and the Docker container is seamlessly
    integrated with Jenkins, which is a modern day deployment tool for continuous
    delivery, and is part and parcel of the agile programming world, as described
    in this chapter. The Docker container source code is pre-checked before it enters
    into the GitHub code repository. The Jenkins tool downloads the code from GitHub
    and runs the test inside a container. In the next chapter, we shall will dive
    deep into, and describe the theoretical aspects of, the process isolation through
    the container technology and various debugging tools and techniques.
  prefs: []
  type: TYPE_NORMAL
