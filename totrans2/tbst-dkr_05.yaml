- en: Chapter 5. Moving Around Containerized Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we covered microservices application architecture deployment
    with the help of Docker containers. In this chapter, we will explore Docker registry
    and how it can be used in public and private modes. We will also dive deeply into
    troubleshooting issues when using public and private Docker registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Redistributing via Docker registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public Docker registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private Docker registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring integrity of images-signed images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Trusted Registry** (**DTR**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Universal Control Plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redistributing via Docker registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker registry is the server-side application that allows the users to store
    and distribute Docker images. By default, public Docker registry (Docker Hub)
    can be used to host multiple Docker images that provides free to use, zero maintenance,
    and additional features such as automated builds and organization accounts. Let's
    take a look at public and private Docker registries in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Docker public repository (Docker Hub)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As explained earlier, Docker Hub allows individuals as well as organizations
    to share the Docker images with its internal teams and customers without the hassle
    of maintaining a cloud based public repository. It provides centralized resource
    image discovery and management. It also provides team collaboration and workflow
    automation for the development pipeline. Some of the additional functions of the
    Docker Hub, besides Image repository management are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automated build**: It helps in the creation of new images whenever code is
    changed in the GitHub or Bitbucket repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WebHooks**: It is a new feature that allows to trigger an action after successful
    image push to repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User management**: It allows creating workgroups to manage an organization''s
    user access to image repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An account can be created using the Docker Hub sign-in page in order to host
    the Docker images; each account will be linked to a unique identification user-based
    Docker ID. Basic functions, such as Docker image search and *pull* from the Docker
    Hub, can be performed without creating a Docker Hub account. Images existing in
    the Docker Hub can be explored using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It will show the existing images in Docker Hub on the basis of the keyword matched.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker ID can also be created using the `docker login` command. The following
    command will prompt to create a Docker ID that will be public namespace for the
    user public repository. It will prompt to enter a `Username`, and it will also
    prompt to enter `Password` and `Email` in order to complete the registration process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to log out, the following command can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Private Docker registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Private Docker registry can be deployed inside the local organization; it is
    open-source under Apache license and is easy to deploy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using private Docker registry, you have the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: The organization can control and keep a watch on the location where Docker images
    are stored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The complete image distribution pipeline will be owned by the organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image storage and distribution will be useful for in-house development workflow
    and integration with other DevOps components, such as Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing images to Docker Hub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create a customized image that can then be pushed on Docker Hub using
    tagging. Let''s create a simple image with a small terminal-based application.
    Create a Dockerfile with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to the directory containing the Dockerfile and execute the following command
    to build an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, as shown in the following diagram, we can first create a container
    and test it out and then create a tagged **Docker Image** that can be easily pushed
    to **Docker Hub**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pushing images to Docker Hub](graphics/image_05_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Steps to create a Docker Image from Docker Container and push it to public Docker
    Hub
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check whether the image is created using the following command. As you
    can see, the `test/cowsay-dockerfile` image got created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to push the image to Docker Hub account, we will have to tag it with
    the Docker tag/Docker ID using the image ID in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As the tagged username will match the Docker Hub ID account, we can easily
    push the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Pushing images to Docker Hub](graphics/image_05_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot of Docker Hub
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the troubleshooting issues that can be prechecked is that the username
    tagged on the custom Docker image should meet the username of the Docker Hub account
    in order to push the image successfully. Custom images pushed to a Docker Hub
    will be made publicly available. Docker provides one private repository for free,
    which should be used in order to push the private images. The Docker client version
    1.5 and earlier will not be able to push the images to Docker Hub account, but
    will still be able to pull the images. Only version 1.6 or later are supported.
    Thus, it is always advised to keep the Docker version up to date.
  prefs: []
  type: TYPE_NORMAL
- en: If the push to Docker Hub fails with a **500 Internal Server Error**, the issue
    is related to Docker Hub infrastructure and a repush might be helpful. If the
    issue persists while pushing the Docker image, Docker logs should be referred
    at `/var/log/docker.log in` in order to debug in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a private local Docker registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The private Docker registry can be deployed using the image that exists on
    the Docker Hub. The port mapped to access the private Docker registry will be
    `5000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will the tag the same image created in the preceding tutorial to `localhost:5000/cowsay-dockerfile`
    so that the repository name and the image name that match can be easily pushed
    to private Docker registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Push the image to private Docker registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The push refers to a repository (`localhost:5000/cowsay-dockerfile`) (len:
    1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Image ID can be seen by visiting the link in browser or using the `curl` command
    that comes up after pushing the image.
  prefs: []
  type: TYPE_NORMAL
- en: Moving images in between hosts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Moving an image from one registry to another requires pushing and pulling the
    image from Internet. If the image is required to be moved from one host to another,
    then it can be simply achieved with the help of the `docker save` command, without
    the overhead of uploading and downloading the image. Docker provides two different
    types of methods in order to save container image to tar ball:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker export`: This saves a container''s running or paused state to a tar
    file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker save`: This saves a non-running container image to a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s compare the `docker export` and `docker save` commands with the help
    of the following tutorial:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using export, pull a basic image from Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a sample file after running the Docker container from the preceding
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the other shell, we can see the running Docker container and then it can
    be exported into a tar file using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The tar file can then be exported to another machine and then imported using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After we run the container from the Ubuntu-sample image in another machine,
    we can find the sample file intact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Using save, in order to transport the image in spite of the running Docker
    container as shown in the preceding tutorial, we can use the `docker save` command
    that will convert the image into a tar file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ubuntu-bundle.tar.gz` file can now be extracted and used in the other
    machine using the `docker load` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the container from the `ubuntu-bundle` image in the other machine,
    we will find out that the sample file does not exist as the `docker load` command
    will store the image with zero complaints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Both the preceding examples show the difference between the export and save
    commands as well as their use in order to transport the images across local hosts
    without the use of Docker registry.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring integrity of images - signed images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From Docker version 1.8, the feature included is Docker container trust that integrates
    **The Update Framework** (**TUF**) into Docker using Notary, an open source tool
    which provides trust over any content or data. It allows the verification of the
    publisher-Docker Engine uses the publisher key in order to verify that-and the
    image that the user is about to run is exactly what the publisher has created;
    it has not been tampered with and is up to date. Thus, it is an opt-in feature
    that allows verification of the publisher of the image. Docker central commands-*push*,
    *pull*, *build*, *create* and *run-*will operate on the images that either have
    content signatures or explicit content hashes. The images are signed with private
    keys by the content publisher before they are pushed to a repository. A trust
    gets established with publisher when the user interacts with the image for the
    first time, then all the subsequent interactions require only a valid signature
    from the same publisher. The model is similar to the first model of SSH that is
    familiar to us. Docker content trust uses two keys-**offline key** and **tagging
    key**-which are generated for the first time when the publisher pushes an image.
    Each repository has its own tagging key. When users run the `docker pull` command
    for the first time, the trust to repository is established using the offline key:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Offline key**: It is the root of trust for your repository; different repositories
    use the same offline key. This key should be kept offline as it has advantages
    against certain classes of attacks. Basically, this key is required during creation
    of a new repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tagging key**: It is generated for each new repository that the publisher
    owns. It can be exported and shared with the person who requires the ability to
    sign content for the specific repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s a list of the protection provided by following the trust key structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Protection against image forgery**: Docker content trust provides protection
    from man-in-the middle attacks. In case a registry is compromised, the malicious
    attacker cannot tamper with the content and serve it to users as every run command
    will fail stating the message unable to verify the content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protection against reply attacks**: In case of replay attacks, the previous
    payloads are used by attackers to trick the system. Docker content trust makes
    use of the timestamp key when publishing the image, thus providing protection
    against replay attacks and ensuring that a user receives the most up to date content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protection against key compromise**: The tagging key might get compromised
    due to its online nature, and it is needed every time new content is pushed to
    the repository. Docker content trust allows publisher to rotate the compromised
    key transparently to user and effectively remove it from the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker content trust is enabled through integration of Notary into Docker Engine.
    Notary can be downloaded and implemented by anyone who wants to digitally sign
    and verify arbitrary collection of content. Basically, it is the utility for securely
    publishing and verifying content over distributed insecure networks. In the following
    sequence diagram, we can see the flow as to how Notary server is used to verify
    the metadata files and their integration with Docker client. Trusted collections
    will be stored in a Notary server and once Docker client has a trusted list of
    named hashes (tags), it can utilize the Docker remote APIs from client to daemon.
    Once the pull succeeds, we can trust all the content on manifests and layers in
    registry pulls.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ensuring integrity of images - signed images](graphics/image_05_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sequence diagram for Docker trusted run
  prefs: []
  type: TYPE_NORMAL
- en: Internally, Notary uses TUF, a secure general design for software distribution
    and updates that are often vulnerable to attacks. TUF addresses the widespread
    problem by providing a comprehensive, flexible-security framework that the developers
    can integrate with the software update system. Generally, the software update
    system is an application running on a client system that obtains and installs
    software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started with installing Notary; On Ubuntu 16.04, Notary can be directly
    installed using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise the project can be downloaded from GitHub and can be manually built
    and installed; Docker Compose is required to be installed in order to build the
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: After the preceding steps, add `127.0.0.1` Notary server to the `/etc/hosts`
    or, if a Docker machine is used, add `$(docker-machine ip)` to the Notary server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will push the `docker-cowsay` image that we created previously. By
    default, content trust is disabled; it can be enabled with the help of the `DOCKER_CONTENT_TRUST` environment
    variable,  which will be done later in this tutorial. Currently, the commands
    that operate with content trust are as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: push
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: create
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pull
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will tag the image with the repository name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s check whether notary has data for this image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see here, there is no trust data that lets us enable the `DOCKER_CONTENT_TRUST`
    flag and then try to push the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As we can see here, for the first time push, it will ask for the passphrase
    in order to sign the tagged image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will be getting the trust data from the Notary for the latest image
    pushed previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: With the help of the preceding example, we clearly get to know the working of
    Notary as well as Docker content trust.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Trusted Registry (DTR)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DTR provides enterprise grade Docker image storage on-premises as well as in
    the virtual private cloud to provide security and meet regulatory compliances.
    DTR runs on top of Docker **Universal Control Plane** (**UCP**), which can be
    installed on-premises or on top of the virtual private cloud, with the help of
    which we can store the Docker images securely behind a firewall.
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker Trusted Registry (DTR)](graphics/image_05_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: DTR running on UCP node
  prefs: []
  type: TYPE_NORMAL
- en: 'The two most important features of DTR are as listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Image management**: It allows the user to store Docker images securely behind
    firewall and DTR can be easily made as part of the continuous integration and
    delivery process in order to build, run, and ship applications.![Docker Trusted
    Registry (DTR)](graphics/image_05_006.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screenshot of DTR
  prefs: []
  type: TYPE_NORMAL
- en: '**Access control and built-in security**: DTR provides authentication mechanism
    in order to add users as well as integrates with **Lightweight Directory Access
    Protocol** (**LDAP**) and Active Directory. It supports **role-based authentication**
    (**RBAC**) as well, which allows you to assign access control policies for each
    user.![Docker Trusted Registry (DTR)](graphics/image_05_007.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User authentication options in DTR
  prefs: []
  type: TYPE_NORMAL
- en: Docker Universal Control Plane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker UCP is the enterprise-grade cluster management solution that allows you
    to manage the Docker containers from a single platform. It also allows you to
    manage thousands of nodes, which can be managed and monitored with a graphical
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'UCP has two important components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Controller**: It manages the cluster and persists the cluster configurations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node**: Multiple nodes can be added to cluster in order to run the containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UCP can be installed using the sandbox installation on top of Mac OS X or Windows
    system using **Docker Toolbox**. Installation consists of a UCP controller and
    one or more hosts that will be added as nodes in the UCP cluster using Docker
    Toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: A prerequisite for Docker Toolbox is that it is required to be installed for
    Mac OS X and Windows system using the installer available at the official Docker
    website.
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker Universal Control Plane](graphics/image_05_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Docker Toolbox Installation
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started with the deployment of Docker UCP:'
  prefs: []
  type: TYPE_NORMAL
- en: After the installation, launch the Docker Toolbox terminal:![Docker Universal
    Control Plane](graphics/image_05_009.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker Quickstart Terminal
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a virtual machine named `node1` using the `docker-machine` command and
    `virtualbox` that will act as UCP controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `node2` VM as well, which will be configured as a UCP node later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure `node1` as a UCP controller, which will be responsible for serving the
    UCP application and running the processes to manage Docker objects'' installation.
    Before that, set the environment to configure `node1` as a UCP controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'While setting the `node1` as a UCP controller, it will ask for the password
    for the UCP admin account and additional aliases will be asked for, which can
    be added or skipped with the enter command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The UCP console can be accessed using the URL provided at the end of installation;
    log in with `admin` as the username and the password that you set previously while
    installing.![Docker Universal Control Plane](graphics/image_05_010.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker UCP license page
  prefs: []
  type: TYPE_NORMAL
- en: After logging in, the trail license can be added or skipped. The trail license
    can be downloaded by following the link on the UCP dashboard on the Docker website.
    The UCP console with multiple options such as listing application, container,
    and nodes:![Docker Universal Control Plane](graphics/image_05_011.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker UCP management dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'Join UCP `node2` to the controller first by setting the environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the node to UCP controller using the following command. UCP controller
    URL, username, and password will be asked for, as illustrated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The installation of UCP is complete; now DTR can be installed on `node2` by
    pulling the official DTR image from Docker Hub. UCP URL, username, password, and
    certificate will also be required in order to complete the DTR installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: After the successful installation, DTR can be listed as an application in the
    UCP UI:![Docker Universal Control Plane](graphics/image_05_012.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker UCP listing all the applications
  prefs: []
  type: TYPE_NORMAL
- en: The DTR UI can be accessed using the `http://node2` URL. The new repository
    can be created by clicking on the **New repository** button:![Docker Universal
    Control Plane](graphics/image_05_013.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a new private registry in DTR
  prefs: []
  type: TYPE_NORMAL
- en: The images can be pushed and pulled from the secured DTR created previously
    and the repository can be made private as well in order to keep the internal company-wide
    containers secured.![Docker Universal Control Plane](graphics/image_05_014.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a new private registry in DTR
  prefs: []
  type: TYPE_NORMAL
- en: DTR can be configured using the **Settings** option from the menu that allows
    to set the domain name, TLS certificate, and storage backend for Docker images.![Docker
    Universal Control Plane](graphics/image_05_015.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Settings option in DTR
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dived deeply into Docker registry. We started with the basic
    concepts of a Docker public repository using Docker Hub and the use-case of sharing
    containers with a larger audience. Docker also provides the option to deploy a
    private Docker registry that we looked into and that can be used to push, pull,
    and share the Docker containers internally in the organization. Then, we looked
    into tagging and ensuring the integrity of Docker containers by signing them with
    the help of a Notary server, which can be integrated with Docker Engine. A more
    robust solution is provided with the help of DTR, which provides enterprise grade
    Docker image storage on-premises as well as in the virtual private cloud to provide
    security and meet regulatory compliances. It runs on top of the Docker UCP, as
    shown in the preceding detailed installation steps. I hope this chapter has helped
    you troubleshoot and learn the latest trends in Docker registry. In the next chapter,
    we will look into making containers work with the help of privileged containers
    and their resource sharing.
  prefs: []
  type: TYPE_NORMAL
