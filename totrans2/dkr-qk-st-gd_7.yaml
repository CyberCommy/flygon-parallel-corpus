- en: Docker Stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will bring together all that we've learned from the first
    six chapters and use it to define, deploy, and manage multi-container applications.
    We will achieve this via the use of Docker stacks. We are going to learn how to
    use Docker stacks and the YAML files required to define multi-container applications.
    And we will leverage what we learned about Docker services, Docker volumes, Docker
    swarm, and Docker networking to create full-featured multi-service Docker-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: The largest cargo ship is 400 meters long and can carry between 15,000 and 18,000
    shipping containers!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker stacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a multi-service Docker application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using compose (stack) YAML files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling a deployed multi-service Docker application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be pulling Docker images from Docker's public repo, and installing
    network drivers from Weave, so basic internet access is required to execute the
    examples within this chapter. Also, we will be using the jq software package,
    so if you haven't installed it yet, please see the instructions on how to do so;
    they can be found in the* Container inspect command* section of [Chapter 2](e66034ed-dcc0-48a8-a2ec-9466669e6649.xhtml),
    *Learning Docker Commands*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter07](https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter07)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action: [http://bit.ly/2E2qc9U](http://bit.ly/2E2qc9U)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the use of Docker stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have mostly been looking at running a Docker container from a single
    Docker image, simplifying the Docker model to imagine a world where every application
    only required a single service, and thus a single Docker image, to run. However,
    as you know, that is a pretty unrealistic model. Real-world applications are composed
    of multiple services, and those services are deployed using multiple Docker images.
    To run all of the necessary containers, and maintain them at the desired number
    of replicas, handling planned and unplanned downtimes, scaling requirements and
    all of the other service management needs is a really daunting and complex task.
    In the recent past, this scenario was handled using a tool called Docker Compose.
    Docker Compose (as you learned in [Chapter 1](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml),
    *Setting up a Docker Development Environment*) is an additional tool that you
    can install in your Docker environment, which we did to complete our workstation's
    environment. While much of the functionality of Docker Compose is similar to what
    you find in Docker stacks, we will be focusing on Docker stacks in this chapter.
    We are doing this because Docker Compose is used to manage containers, and the
    Docker world has evolved toward the commodity unit being services instead of containers.
    Docker stacks manages services, and so I see Docker stacks as the evolution of
    Docker Compose (which was the evolution of a project named Fig). The reason we
    did not install Docker stacks in [Chapter 1](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml), *Setting
    up a Docker Development Environment*, is that Stacks is already included as part
    of a standard Docker installation.
  prefs: []
  type: TYPE_NORMAL
- en: OK, so Docker stacks is the new and improved Docker Compose, and it is included
    in our installation. I bet you're thinking, Great. But what does that mean? What
    is the use case of Docker stacks? Great question! Docker stacks is *the* way to
    leverage all of the functionality that we have learned about in the earlier chapters,
    such as the Docker commands, Docker images, Docker services, Docker volumes, Docker
    swarm, and Docker networks, wrapping it all up in an easy-to-use, easy-to-understand,
    declarative document file that will instantiate and maintain a complex, multi-image
    application on our behalf.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of your work, which is still the easy part, will be in creating the compose
    file that will be used in the Docker stack commands. All of the really hard work
    will be done by Docker when it creates, starts, and manages all of the services
    required for your multi-service (multi-container) applications. All of this is
    handled by a single command on your part. Just like image, the container and swarm
    stacks are another Docker management group. Let''s take a look at the stack management
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/122c40cb-3742-4665-be75-2ce2ecfaa9df.png)'
  prefs: []
  type: TYPE_IMG
- en: So, what do we have here? For all the power that this management group represents,
    it has a pretty simple set of commands. The main command is the `deploy` command.
    It is the powerhouse! With this command (and a compose file), you will stand up
    your application, pulling any images that are not local to your environment, running
    the images, creating volumes as needed, creating networks as needed, deploying
    the defined number of replicas for each image, spreading them across your swarm
    for HA and load-balancing purposes, and more. This command is kind of like the
    one ring in *The Lord of the Rings*. In addition to deploying your application,
    you will use this same command to update running applications, when you need to
    do things such as scale your application.
  prefs: []
  type: TYPE_NORMAL
- en: The next command in the management group is the list stacks command. As the
    name implies, the ls command allows you to get a list of all the stacks currently
    deployed to your swarm. When you need more detailed information about a particular
    stack that is running in your swarm, you will use the `ps` command to list all
    of the tasks of a particular stack. When it comes time to end of life a deployed
    stack, you will use the mighty rm command. And finally, rounding out the management
    commands, we have the services command, which allows us to get a list of the services
    that are part of the stack. There is one more important part of the stack puzzle,
    that being the `--orchestrator` option. With this option, we can instruct Docker
    to use either Docker swarm or Kubernetes for the stack orchestration. Of course,
    to use Kubernetes, it must be installed, and to use swarm—which is the default
    if the option is not specified—swarm mode must be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of this chapter, we are going to take a deep dive into Docker stacks
    using a sample application. Docker provides several such samples, but the one
    we are going to examine is the voting application sample. I will provide a link
    to the Docker repo for the app, as well as a link to a fork of the project in
    my space in the event that the Docker app changes drastically or the project goes
    away. Let's take a look at the stack file for the example voting application.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the following links for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose Overview: [https://docs.docker.com/compose/overview/](https://docs.docker.com/compose/overview/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker stack command reference: [https://docs.docker.com/engine/reference/commandline/stack/](https://docs.docker.com/engine/reference/commandline/stack/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker samples: [https://github.com/dockersamples](https://github.com/dockersamples)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker voting app example: [https://github.com/dockersamples/example-voting-app](https://github.com/dockersamples/example-voting-app)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: My fork of the voting app: [https://github.com/EarlWaud/example-voting-app](https://github.com/EarlWaud/example-voting-app)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create and use a compose YAML files for Stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The stack file is a YAML file, and is basically the same thing as a Docker Compose
    file. Both are YAML files that define a Docker base application. Technically,
    a stack file is a compose file that requires a specific version (or above) of
    the compose specification. Only the version 3.0 specification and above are supported
    by Docker stacks. If you have an existing project that uses Docker compose YAML
    files, and those files are using the version 2 or older specification, then you
    will need to update the YAML files to the version 3 spec to be able to use them
    with Docker stacks. It is worth noting that the same YAML file can be used with
    either Docker stacks or Docker compose (provided it is written using the version
    3 specification or higher). However, there are some instructions that will be
    ignored by one or the other tools. For example, the build instruction is ignored
    by Docker stacks. That is because one of the most significant differences between
    stacks and compose is that all utilized Docker images must be pre-created for
    use with stacks, whereas Docker images can be created as part of the process of
    standing up a compose-based application. Another significant difference is the
    stack file is able to define Docker services as part of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now would be a good time to clone the voting app project and the visualizer
    image repos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Strictly speaking, you don''t need to clone these two repos because all you
    really need is the stack compose file from the voting app. This is because all
    of the images are already created and publicly available to pull from hub.docker.com,
    and when you deploy the stack, the images will be pulled for you as part of the
    deployment. So, here is the command to obtain just the stack YAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Of course, if you want to customize the app in any way, having the project local
    allows you to build your own versions of the Docker images and then deploy your
    custom version of the app using your custom images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the project (or at least the `docker-stack.yml` file) on your
    system, you can begin to play around with the Docker stack commands. So now, let''s
    go ahead and kick things off by using the `docker-stack.yml` file to deploy our
    application. You will need to have your Docker nodes set up and have swarm mode
    enabled for this to work, so if you haven''t done so already, set up your swarm
    as described in [Chapter 5](f1681897-580b-44fb-9e43-4aed37e67529.xhtml), *Docker
    Swarm*. Then, use the following command to deploy your example voting application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what this might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2aee2f71-d5df-4f98-846b-ac4b0b65e79b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let me quickly explaining this command: we are using the `deploy` command with
    the `docker-stack.yml` compose file, and naming our stack `voteapp`. This command
    will handle all of the configuration, deployment, and management for our new application.
    It will take some time to get everything up and running as defined in the `docker-stack.yml`
    file, so while that is happening, let''s start diving into our stack compose file.'
  prefs: []
  type: TYPE_NORMAL
- en: By now, you know we are using the `docker-stack.yml` file. So, as we explain
    the various parts of the stack compose file, you can bring that file up in your
    favorite editor, and follow along. Here we go!
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we are going to look at is the top-level keys. In this case,
    they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As mentioned previously, the version must be at least 3 to work with Docker
    stacks. Looking at line 1 (the version key is always on line 1) in the `docker-stack.yml`
    file, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/db63823a-5514-4548-8c15-00c967515e96.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Perfect! We have a compose file that is at the version 3 specification. Skipping
    over the (collapsed) services key section for a minute, let''s take a look at
    the networks key and then the volumes key. In the networks key section, we are
    instructing Docker to create two networks, one named frontend, and one named backend.
    Actually, in our case, the networks will have the names `voteapp_frontend` and
    `voteapp_backend`. This is because we named our stack `voteapp`, and Docker will
    prepend the name of the stack to the various components it deploys as part of
    the stack. Simply by including the names for our desired networks within the networks
    key of our stack file, Docker will create our networks when we deploy our stack.
    We can provide specific details for each network (as we learned in [Chapter 6](873454a4-2f8e-42df-93ab-7648545167bb.xhtml),
    *Docker Networking*), but if we don''t provide any, then certain default values
    will be used. It''s probably been long enough for our stack to deploy our networks,
    so let''s use the network list command and take a look at what networks we have
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4f26a50f-92fc-4fb0-a453-2a1448250df9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There they are: `voteapp_frontend` and `voteapp_backend`. You might be wondering
    what the `voteapp_default` network is. When you deploy a stack, you will always
    get a default swarm network and all containers are attached to it if they don''t
    have any other network connection defined for them in the stack compose file.
    This is very cool, right?! You didn''t have to do any docker network create commands,
    and your desired networks are created and ready to use in your application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The volumes key section does pretty much the same thing as the networks key
    section, except it does it for volumes. You get your defined volumes created automatically
    when you deploy the stack. The volumes are created with default settings if no
    additional configuration is provided in the stack file. In our example, we are
    asking Docker to create a volume named `db-data`. As you may have guessed, the
    volume created actually has the name of `voteapp_db-data` because Docker prepended
    the name of our stack to the volume name. In our case, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/457d5f8c-cb66-4cd6-96b8-75adb3afcfe9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, deploying our stack created our desired networks and our desired volume.
    All with the easy-to-create, and easy-to-read-and-understand content in our stack
    compose file. OK, so we now have a good grasp of three of the four top-level key
    sections in our stack compose file. Now, let''s return to the services key section.
    If we expand this key section, we will see definitions for each of the services
    we wish to deploy as part of the application. In the case of the `docker-stack.yml`
    file, we have six services defined. These are redis, db, vote, result, worker,
    and visualizer. In the stack compose file, they look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3fc6f525-3d09-4045-bc56-d9da65483394.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s expand the first one, redis, and take a closer look at what is defined
    as the redis service for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4bf276e3-699f-4d20-a441-9182e0db84cb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you recall the discussion of Docker services from [Chapter 5](f1681897-580b-44fb-9e43-4aed37e67529.xhtml),
    *Docker Swarm*, many of the keys shown here should seem familiar to you. Let''s
    examine the keys in the redis service now. First up, we have the `image` key.
    The image key is required for the service definition. This key is telling docker
    that the Docker image to pull and run for this service is `redis:alpine`. As you
    should understand now, this means that we are using the official redis image from
    hub.docker.com, requesting the version tagged as `alpine`. The next key, `ports`,
    is defining what port the images will be exposing from the container, and from
    the hosts. In this case, the port on the host that is to be mapped to the container''s
    exposed port (`6379`) is left to Docker to assign. You can find the port assigned
    using the `docker container ls` command. In my case, the redis service is mapping
    port `30000` on the host to port `6379` on the container. The next key used is
    `networks`. We already have seen that deploying the stack will create our networks
    for us. This directive is telling Docker which networks that the redis replica
    containers should be connected to; in this case it is the `frontend` network.
    If we inspect a redis replica container, examining the networks section, we will
    see this to be accurate. You can have a look at your deployment with a command
    such as this (note that the container name will be slightly different on your
    system):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, you should see that the container is attached to two networks:
    the ingress network and our `voteapp_frontend` network.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next key in our redis service definition is the deploy key. This is a key
    category that was added to the compose file specification with version 3\. It
    is what defines the specifics for running the containers based on the image in
    this service: in this case, the redis image. It is essentially the orchestration
    instructions. The `replicas` tag tells docker how many copies or containers should
    be running when the application is fully deployed. In our example, we are stating
    that we only need one instance of the redis container running for our application.
    The `update_config` key provides two sub keys, `parallelism` and `delay`, that
    tell Docker how many container `replicas` should be started in parallel, and how
    much time to wait between starting each `parallel` set of container `replicas`.
    Of course, with one replica, the parallelism and delay details have little use.
    If the value for `replicas` were something greater, such as `10`, our update_config
    keys would result in two replicas starting at a time, with a wait of 10 seconds
    between starts. The final deploy key is `restart_policy`, and this defines the
    conditions that a new replica will be created in a deployed stack. In this case,
    if a redis container fails, a new redis container will be started to take its
    place. Let''s take a look at the next service in our application, the `db` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/05c62070-b99e-44b6-9aeb-87a5a39cd8e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The db service will have several keys in common with the redis service, but
    with different values. First, we have the image key. This time we are indicating
    that we want the official postgres image with the tag for version 9.4\. Our next
    key is the volumes key. We are indicating that we are using the volume named db-data,
    and that in the DB container the volume should be mounted at `/var/lib/postgresql/data`.
    Let''s take a look at the volume information in our environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/cc874b3a-4a1f-4e7c-9205-1370c49b6cb7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the volume inspect command, we get the volume mount point and then compare
    the contents of the folder within the container to the contents of the mount point
    on the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c15dc49d-8cbc-44b6-92c8-17fa68ade32c.png)'
  prefs: []
  type: TYPE_IMG
- en: Voila! As expected, they match. This is not as straightforward on a Mac. See
    [Chapter 4](6e908793-3bc0-45f3-bcb5-af85ac6aecab.xhtml), *Docker Volumes,* on
    Docker volumes for details on how to handle this on OS X. The next key is the
    networks key, and here we are directing Docker to attach the backend network to
    our db container. Next up is the deploy key. Here, we see a new sub-key, called
    `placement`. This is a directive to tell Docker that we only want db containers
    to run on manager nodes, that is, on nodes that have the role of `manager`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that there are some sub-keys of the deploy key that are
    present in the redis service, but are absent in our db service—most notably, the
    `replicas` key. By default, if you do not specify the number of replicas to maintain,
    Docker will default to having one replica. All in all, the description of the
    db service configuration is pretty much the same as the redis service. You will
    see this similarity between the configuration of all the services. This is because
    Docker has made it very easy to define the desired state of our services, and
    by correlation, our applications. To validate this, let''s take a look at the
    next service in the stack compose file, the `vote` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c7b6874c-7c27-4aa9-895c-297b22c27b06.png)'
  prefs: []
  type: TYPE_IMG
- en: You should be starting to get familiar with these keys and their values. Here
    in the vote service we see that the image defined is not one of the official container
    images, but instead is in a public repo named `dockersamples`. Within that repo,
    we are using the image named `examplevotingapp_vote`, with a version tag of `before`.
    Our ports key is telling Docker, and us, that we want to open port `5000` on the
    swarm hosts and have traffic on that port mapped to port 80 in the running vote
    service containers. As it turns out, the vote service is the `face` of our application
    and we will access it via port `5000`. Since it is a service, we can access it
    by going to port `5000` on *any* of the hosts in the swarm, even when a particular
    host is not running one of the replicas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the next key, we see that we are attaching the `frontend` network
    to our vote service containers. Nothing new there, however, as our next key is
    one we have not seen before: the `depends_on` key. This key is telling Docker
    that our vote service requires the redis service to function. What this means
    to our `deploy` command is that the service or services that are depended on need
    to be started before starting this service. Specifically, the redis service needs
    to be started before the vote service. One key distinction here is that I said
    started. This does not mean that the depended-upon service has to be running before
    starting this service; the depended-on service just has to be started before it.
    Again, specifically, the redis service does not have to be at the state of running
    before starting the vote service, it just has to be started before the vote service
    is started. There is nothing we haven''t seen yet in the deploy key in for the
    vote service, with the only difference being that we are asking for two replicas
    for the vote service. Are you beginning to understand the simplicity and the power
    of the service definition in the stack compose file?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next service defined in our stack compose file is for the result service.
    However, since there are no keys present in that service definition that we haven''t
    seen in the previous services, I will skip the discussion on the result service,
    and move on to the worker service where we''ll see some new stuff. Here is the
    worker service definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b4ddec41-7ece-487d-a782-615d8853be3c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You know about the image key and what it means. You know about the networks
    key and what it means too. You know about the deploy key, but we have some new
    sub-keys here so let''s talk about them, starting with the `mode` key. You may
    recall from our discussion of services in [Chapter 5](f1681897-580b-44fb-9e43-4aed37e67529.xhtml), *Docker
    Swarm*, that there is a `--mode `parameter that can have one of two values: `global` or
    `replicated`. This key is exactly the same as the parameter we saw in [Chapter
    5](f1681897-580b-44fb-9e43-4aed37e67529.xhtml), *Docker Swarm*. The default value
    is replicated, and so if you do not specify the mode key, you will get the replicated
    behavior, which is to have exactly the number of replicas that are defined (or
    one replica if no number of replicas is specified). Using the other value option
    of global will ignore the replicas key and deploy exactly one container to every
    host in the swarm.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next key that we have not seen before in this stack compose file is the
    `labels` key. The location of this key is significant as it can appear as its
    own upper-level key, or as a sub-key to the deploy key. What is the distinction?
    When you use the `labels` key as a sub-key to the deploy key, the label will be
    set only on the service. When you use the `labels` key as its own upper-level
    key, the label will be added to each replica, or container, deployed as part of
    the service. In our example, the `APP=VOTING `label will be applied to the service
    because the `labels` key is a sub-key to the deploy key. Again, let''s see this
    in our environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what that looks like on my system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4b1b7fba-94cd-40ec-ac68-66fd1d791c1d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Executing an inspect command on a worker container to view the labels on it
    will show that the `APP=VOTING` label does not appear. If you want to confirm
    this on your system, the command will look like this (with a different container
    name):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, here is what it looks like on my system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c4206773-5d0a-4903-a6d6-af59fc260ead.png)'
  prefs: []
  type: TYPE_IMG
- en: Two new sub-keys for the restart_policy key are the `max_attempts` and `window`
    keys. You can probably guess their purpose; the `max_attempts` key tells Docker
    to keep trying to start the worker containers if they fail to start, up to three
    times before giving up. The `window` key tells Docker how long to wait before
    retrying to start a worker container if it failed to start previously. Pretty
    straightforward, right? Again, these definitions are easy to set up, easy to understand,
    and extremely powerful for orchestrating the services of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright. We have one more service definition to review for new stuff, that
    being the visualizer service. Here is what it looks like in our stack compose
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9a9366b9-a6af-4510-990e-0c8af430a4da.png)'
  prefs: []
  type: TYPE_IMG
- en: The only truly new key is the `stop_grace_period` key. This key tells Docker
    how long to wait after it tells a container to stop before it will forcefully
    stop the container. The default time period, if the `stop_grace_period` key is
    not used, is 10 seconds. When you need to update a stack, essentially do a re-stack,
    the containers of a service will be told to shut down gracefully. Docker will
    wait for the amount of time specified in the `stop_grace_period` key, or for 10
    seconds if the key is not provided. If the container shuts down during that time,
    the container will be removed, and a new container will be started in its place.
    If the container does not shut down during that window of time, it will be stopped
    by force, killing it, then removing it, then starting a new container to take
    its place. The significance of this key is that it allows the necessary time for
    containers that are running processes that take longer to stop gracefully to actually
    stop gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last aspect of this service that I want to point out and that is regarding
    the kind of strange volume listed. This is not a typical volume and has no entry
    in the volumes key definitions. The `/var/run/docker.sock:/var/run/docker.sock`
    volume is a way to access the Unix socket that the host''s Docker daemon is listening
    on. In this case, it''s allowing the container to communicate with its host. The
    visualizer container is gathering information about what containers are running
    on what hosts and is able to present that data in a graphical way. You will notice
    that it maps the 8080 host port to the 8080 container port, so we can have a look
    at what data it shares by browsing to port 8080 on any of our swarm nodes. Here
    is what it looks like on my (current) three-node swarm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/51807fb7-0768-419a-80af-5281df5e2ef8.png)'
  prefs: []
  type: TYPE_IMG
- en: The rest of the stack commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s take a quick look at our other stack-related commands through the
    lens of the swarm where we deployed our `voteapp` stack. First up, we have the
    list stacks command: `docker stack ls`. Giving that a try looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what it looks like in the example environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9b32a41a-3a67-427f-bc1c-a6d2167d52aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is showing that we have one stack named voteapp currently deployed, and
    that it is composed of six services and is using swarm mode for its orchestration.
    Knowing the name of a deploy stack allows us to gather more information about
    it using the other stack commands. Next up is the list stack tasks command. Let''s
    give this command a try in our example environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the results in my environment right now; yours should look very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d6dbb6ce-fbfb-4386-8250-2bfd9bc4857e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will have a look at the stack services command. This command will give
    us a nice summary of the services that are deployed as part of our stack application.
    The command looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what we see in the example environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d7c657d4-540a-433b-97ee-b230735ed4c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This command provides some very useful information. We can quickly see the
    names of our services, the number of replicas desired, and the actual number of
    replicas for each service. We can see the image used to deploy each service, and
    we can see the port mapping used for each service. Here, we can see the visualizer
    service is using port `8080`, as we mentioned earlier. We can also see that our
    vote service is exposed on port `5000` of our swarm hosts. Let''s have a look
    at what we are presenting in our voteapp by browsing to port `5000` (on any node
    in the swarm) now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/96258e39-c554-4dd6-b33c-697eb17986ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Are you a dog person or a cat person? You can express yourself by voting in
    your own voteapp! Cast your vote and then use the data in the stack service command
    to see the results of the vote by browsing to port `5001`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7c015ab2-78dd-47e0-b949-dffb749946d9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Yes, I am a dog person. There is one final stack command: the remove command.
    We can quickly and easily take down an application deployed with the stack deploy
    command by issuing the `rm` command. Here is what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you see it, now you don''t:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/46c33edf-aa70-4eb8-9eb3-598d69cab70a.png)'
  prefs: []
  type: TYPE_IMG
- en: You should notice that there was none of the are you sure? hand-holding, so
    be very sure and very careful before pressing *Enter* on this command. Let's close
    out the discussion on Docker stacks with a quick look at the best practices for
    scaling or restacking an application deployed as a Docker stack.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for scaling a stack application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with most things Docker, there are a few different ways to accomplish desired
    states for your applications. When you are using Docker stacks, you should always
    use the same method for updating the application as you did for deploying it.
    Make any desired state changes in the stack compose file, and then run the exact
    same command you used to deploy the stack. This allows you to use standard source-code-control
    features to properly handle your compose file, such as tracking and reviewing
    changes. And, it allows Docker to do the right things for orchestrating your application.
    If you need to scale a service up or down within your application, you should
    update the replicas key in the stack compose file and then run the deploy command
    again. In our example, we have two replicas for our vote service. If the demands
    for voting skyrocketed, we can easily scale our application by changing the replica
    value from 2 to, say, 16 by editing the `docker-stack.yml` file, then issuing
    the same command we originally used to deploy the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we check the services, we can see we are scaling our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c8149abc-acce-4e48-bf42-3d65cb21a180.png)'
  prefs: []
  type: TYPE_IMG
- en: There you have it, an easy-to-use, easy-to-understand, and very, very powerful
    Docker application orchestration!
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the following links for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: The compose file reference: [https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some compose file examples: [https://github.com/play-with-docker/stacks](https://github.com/play-with-docker/stacks)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker sample images on Docker hub: [https://hub.docker.com/u/dockersamples/](https://hub.docker.com/u/dockersamples/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official redis image tags found on Docker hub: [https://hub.docker.com/r/library/redis/tags/](https://hub.docker.com/r/library/redis/tags/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A great article about using the Docker daemon socket: [https://medium.com/lucjuggery/about-var-run-docker-sock-3bfd276e12fd](https://medium.com/lucjuggery/about-var-run-docker-sock-3bfd276e12fd)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The stack deploy command reference: [https://docs.docker.com/engine/reference/commandline/stack_deploy/](https://docs.docker.com/engine/reference/commandline/stack_deploy/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The stack ps command reference: [https://docs.docker.com/engine/reference/commandline/stack_ps/](https://docs.docker.com/engine/reference/commandline/stack_ps/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The stack services command reference: [https://docs.docker.com/engine/reference/commandline/stack_services/](https://docs.docker.com/engine/reference/commandline/stack_services/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you know a lot about Docker stacks. You can easily create application definitions
    with a compose file and then deploy those applications using the stack deploy
    command. You can explore the details of your deployed stacks with the ls, ps,
    and services commands. You can scale your applications with easy modifications
    to your compose file and by executing the same command used to deploy your app.
    Finally, you can remove an application that has reached the end of its life with
    the stack rm command. With great power comes great responsibility, so be very
    careful with that remove command. You have enough information to create and orchestrate world-class
    enterprise-grade applications now, so get busy! However, if you would like to
    learn how to use Docker with Jenkins, you'll be pleased to know that that's the
    topic of [Chapter 8](88652c62-a041-4cec-b42c-0aaa414d7083.xhtml), *Docker and
    Jenkins*, so turn the page and start reading!
  prefs: []
  type: TYPE_NORMAL
