- en: Preface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim of this book is to provide you with in-depth knowledge of how Docker
    implements container networking. Whether you use Docker every day or are just
    getting started, this book will introduce you to how Docker uses Linux networking
    primitives to network containers. Through numerous examples, we’ll cover everything
    from the fundamentals of Linux networking to the latest Docker networking drivers.
    Along the way, we’ll also look at integrating existing networking constructs and
    third-party plugins into Docker. The end goal is for you to be comfortable with
    the process Docker uses to provide networking capabilities to containers.
  prefs: []
  type: TYPE_NORMAL
- en: Like many open source projects, Docker is a fast-moving piece of software. At
    the time of publication, the most recent version of Docker was 1.12\. I’ve done
    my best to ensure that the content in this book reflects the most up-to-date features
    and configurations based on this version. Regardless of the version, many of these
    features have existed in one form or another since the very early versions of
    Docker. So while there have been significant changes in Docker networking over
    the last couple of years, much of the network functionality is still implemented
    in the same manner. It is for this reason that I believe the majority of the content
    in this book will remain relevant for a long time to come.
  prefs: []
  type: TYPE_NORMAL
- en: '**What this book covers**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 1](ch01.html "Chapter 1. Linux Networking Constructs"), *Linux Networking
    Constructs*, will focus on introducing you to Linux networking primitives. Topics
    such as interface creation, addressing, and general connectivity will be discussed
    in detail. You will also be introduced to common Linux command-line syntax and
    tooling as it relates to Linux host network configuration. Understanding these
    basic constructs will greatly increase your ability to understand how Docker handles
    container networking.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.html "Chapter 2. Configuring and Monitoring Docker Networks"),
    *Configuring and Monitoring Docker Networks*, explains the default means in which
    Docker handles container networking. These include bridge, host, and mapped container
    modes of Docker network operation. We’ll also begin our exploration of how Docker
    handles mapping container-based services to the outside or external network. There
    will also be discussion around Linux host requirements for Docker networking and
    some of the possible Docker service-level parameters that can be modified.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](ch03.html "Chapter 3. User-Defined Networks"), *User-Defined Networks*,
    begins our discussion on Docker user-defined networks. The advent of user-defined
    networks has greatly increased the flexibility of Docker networking providing
    the end user far more possibilities in regard to container connectivity. We’ll
    discuss the syntax required to create user-defined networks as well as show examples
    of how to create user-defined bridge and overlay-based networks. Finally, we’ll
    cover some options to isolate network segments within Docker.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4](ch04.html "Chapter 4. Building Docker Networks"), *Building Docker
    Networks*, begins with a deep dive into how Docker provides container connectivity.
    Starting with a container that was provisioned without a network interface, we’ll
    cover all the steps required in order to get the container communicating on the
    network. We’ll then move on to discuss other options to use custom bridges with
    Docker and cover multiple use cases related to using OVS in conjunction with Docker.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html "Chapter 5. Container Linking and Docker DNS"), *Container
    Linking and Docker DNS*, discusses the available options for container name resolution.
    This includes both the default name resolution behavior as well as the new embedded
    DNS server functionality that exists with user-defined networks. You will become
    comfortable with the process used to determine name server assignment in each
    of these scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6](ch06.html "Chapter 6. Securing Container Networks"), *Securing
    Container Networks*, shows a variety of features and strategies that are related
    to container security. You will be exposed to several options to limit the scope
    of container exposure and connectivity. We’ll also discuss options to implement
    a container-based load balancer that utilizes a user-defined overlay network.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7](ch07.html "Chapter 7. Working with Weave Net"), *Working with Weave
    Net*, will be our first look at a third-party networking solution that integrates
    with Docker. Weave provides multiple methods to integrate with Docker including
    its own CLI tool as well as a full-blown Docker driver. An example of using Weave
    to provide network isolation will also be demonstrated.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8](ch08.html "Chapter 8. Working with Flannel"), *Working with Flannel*,
    examines the third-party network plugin built by the team at CoreOS. Flannel is
    an interesting example of how a networking plugin can be integrated into Docker
    just by changing Docker service-level parameters. In addition to providing overlay
    type networking, Flannel also offers a host gateway backend that allows the hosts
    to route directly to each other so long as they meet certain requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9](ch09.html "Chapter 9. Exploring Network Features"), *Exploring
    Network Features*, focuses on how newer networking features are integrated into
    Docker. We’ll examine how you can gain access to and test these new features by
    evaluating different versions of Docker engine. Through the course of the chapter,
    we’ll also examine the now integrated MacVLAN network driver as well as the IPVLAN
    network driver, which is still in testing.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 10](ch10.html "Chapter 10. Leveraging IPv6"), *Leveraging IPv6*, covers
    IPv6 and Docker’s support of it. IPv6 is a big topic and one that deserves a great
    amount of attention considering the current state of IPv4\. In this chapter, we’ll
    review some of the basics of working with IPv6 on a Linux system. We’ll then spend
    some time reviewing how Docker supports IPv6 and discuss some of the options you
    have around deployment.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 11](ch11.html "Chapter 11. Troubleshooting Docker Networks"), *Troubleshooting
    Docker Networks*, examines some of the common steps you might take when troubleshooting
    Docker networking. The focus will be on validating the configuration, but you’ll
    also learn some steps you can take to prove that the configuration is working
    as intended.'
  prefs: []
  type: TYPE_NORMAL
- en: What you need for this book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the labs shown in this book were performed on Ubuntu Linux hosts running
    version 16.04 and Docker engine version 1.12.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll note that the network interface names used on the hosts in this book
    use the familiar eth (eth0, eth1, and so on) naming convention. While this is
    still the standard on many versions of Linux, newer versions that run systemd
    (such as Ubuntu 16.04) now use something called Predictable Network Interface
    Names (PNIN). With PNIN, the network interface uses more predictable names based
    on the information about the interface itself. In these cases, the interface names
    will show up using different names, such as ens1 or ens32\. For the sake of making
    the content in this book easier to understand, I chose to disable PNIN on all
    of the hosts. If you’re interested in doing the same instructions can be found
    by doing a web search for ‘Ubuntu disable predictable interface names’. If you
    chose not to, just know that your interface names will show up differently than
    mine do in the examples.
  prefs: []
  type: TYPE_NORMAL
- en: The requirements for labs shown in this book are included at the beginning of
    each recipe. Later recipes may build on configurations shown in earlier recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Who this book is for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book is for people who are interested in learning more about how Docker
    implements container networking. While the recipes cover many of the basics required
    to get you up and running, it is assumed that you have a working knowledge of
    Linux and Docker. It is also assumed that you have a basic understanding of networking.
  prefs: []
  type: TYPE_NORMAL
- en: Conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, you will find a number of text styles that distinguish between
    different kinds of information. Here are some examples of these styles and an
    explanation of their meaning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code words in text, file paths, and executables are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Interfaces on the host can be seen by using the `ip link show` command".'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any command-line input or output is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When possible any multiline command-line input will be written using the Linux
    line continuation method of including a trailing `\` at the end of the line to
    be continued:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In some cases command-line output will also be multiline. In those cases, formatting
    was done in an effort to make the output easily readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we wish to draw your attention to a particular part of command-line output,
    the relevant lines or items are set in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Warnings or important notes appear in a box like this.
  prefs: []
  type: TYPE_NORMAL
