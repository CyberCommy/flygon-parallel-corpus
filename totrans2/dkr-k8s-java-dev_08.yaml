- en: Using Kubernetes with Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7](text00137.html) , *Introduction to Kubernetes* , we learned about
    the Kubernetes architecture and concepts. We know about nodes, Pods, and services.
    In this chapter, we will do some practical hands-on and deploy our Java REST service
    to a local Kubernetes cluster. For learning purposes, we will use the Minikube
    tool to create a cluster on the local machine. It's easier to learn Kubernetes
    on a local machine instead of going to the cloud in the first place. Because Minikube
    runs locally, instead of through a cloud provider, certain provider-specific features
    such as load balancers and persistent volumes, will not work out of the box. However,
    you can use `NodePort` , `HostPath` , persistent volumes and several addons such
    as DNS, or dashboard to test your apps locally before pushing to a real, production-grade
    cluster. In [Chapter 10](text00205.html) , *Deploying Java on Kubernetes in the
    Cloud* , we will run Kubernetes using **Amazon Web Services** (**AWS** ) and hosted
    Kubernetes in Google container engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To follow along, we will need the following tools ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Docker` : To build the Docker images we want to deploy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minikube` : A local Kubernetes environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubectl` : The Kubernetes command line interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Minikube on macOS, Windows, and Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting up the local Kubernetes cluster using Minikube
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a Java application on a local cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interacting with containers: scaling, autoscaling, and viewing cluster events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Kubernetes dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I assume you have Docker up and running so far, so let's focus on the `minikube`
    utility. We have already mentioned `minikube` in the [Chapter 7](text00137.html)
    , *Introduction to Kubernetes;* now, we will go into some more details, starting
    with the installation process.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Minikube tool source code with all the documentation is available at GitHub
    at [https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Installing on Mac
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following sequences of commands will download the `minikube` binary, set
    the executable flag and copy it to the `/usr/local/bin` folder, which will make
    it available in the macOS shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you use Homebrew package manager (available freely at [https://brew.sh](https://brew.sh)
    ), which is, by the way, very handy and recommended, you can just install `minikube`
    by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Installing on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Minikube for Windows is also simply a single executable file. You can always
    find the newest version on the Minikube's site, at [https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube)
    . You just need to download the latest executable, rename it `minikube.exe` ,
    and place it in your system path to have it available from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Installing on Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The installation process on Linux is identical to the macOS one. The only difference
    is the executable name. The following command will download the latest Minikube
    release, set the executable bit, and move it to the `/usr/local/bin` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all, a single Minikube and Docker is all we need to start the local
    cluster. It''s time to bring it to life:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting up the local Kubernetes cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re using the local Kubernetes cluster provided by `minikube` . Start your
    cluster with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Minikube works on its own virtual machine. Depending on your host OS, you can
    choose between several virtualization drivers. Currently supported are `virtualbox`
    , `vmwarefusion` , `xhyve` , `hyperv` , and `kvm` (**Kernel-based virtual machine**
    ). The default VM driver is virtual box. You can override this option. This is
    the example macOS startup command line which uses `xhyve` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When starting Minikube for the first time, you will see it downloading the Minikube
    ISO, so the process will take a little longer. This is, however, a one-time action.
    The Minikube configuration will be saved in the `.minikube` folder in your `home`
    directory, for example `~/.minikube` on Linux or macOS. On the first run, Minikube
    will also configure the `kubectl` command line tool (we will get back to it in
    a short while) to use the local `minikube` cluster. This setting is called a `kubectl`
    context. It determines which cluster `kubectl` is interacting with. All available
    contexts are present in the `~/.kube/config` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the cluster is running now and we have the `dashboard` addon enabled by
    default, you can take a look at the (still empty) Kubernetes dashboard with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It will open your default browser with the URL of the cluster''s dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](Image00084.jpg)**'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the dashboard is empty now. If you browse to the Namespaces
    menu, you will notice that Minikube creates some namespaces, with the one available
    for our purposes named simply the default. The parts of the Minikube installation,
    such as DNS or the Dashboard, which are also running on the cluster itself, with
    separate namespaces such as kube-public and kube-system.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to browse the menus and sections; so far, no harm can be done, it's
    a local development cluster running nothing at the moment. We will get back to
    the dashboard in the last section of this chapter, to see how can we use it to
    deploy our services from the nice UI, if you prefer to do so, instead to using
    the shell of command line.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, having the cluster running empty is quite useless, so we need a tool
    to manage it. While we can almost all everything using the dashboard, it's a lot
    more convenient to have a command line tool for that. `kubectl` controls the Kubernetes
    cluster. We will use the `kubectl` command line tool heavily to deploy, schedule,
    and scale our applications and microservices. The tool comes as a self-contained
    binary for Mac, Linux, and Windows. In the next section you will find installation
    instructions for different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Installing kubectl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`kubectl` is available for all major platforms. Let''s start with macOS installation.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing on Mac
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following sequences of command will download the `kubectl` binary, set
    the executable flag and copy it to `/usr/local/bin` folder which will make it
    available in the macOS shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Homebrew provides the most convenient way to install `kubectl` and keep it
    up to date. To install, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To update, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Installing on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the list of Windows `kubectl` releases on GitHub at [https://github.com/eirslett/kubectl-windows/releases](https://github.com/eirslett/kubectl-windows/releases)
    . Similar to Minikube, kubectl is just a single `.exe` file. At the time of writing
    this book it's [https://github.com/eirslett/kubectl-windows/releases/download/v1.6.3/kubectl.exe](https://github.com/eirslett/kubectl-windows/releases/download/v1.6.3/kubectl.exe)
    . You will need to download the `exe` file and place in on your system path, to
    have it available in the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Installing on Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The installation process is, again, very similar to the macOS. The following
    commands will fetch the `kubectl` binary, give it an executable flag, and then
    move it to the `/usr/local/bin` to make it available in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify if your local cluster is up and running and `kubectl` is properly
    configured, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output, you will be given basic information about the cluster, which
    includes its IP address, and running Minikube addons (we will get back to addons
    later in this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To list the nodes we have running in our cluster, execute the `get nodes` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this is just a single node cluster, so there is no surprise in the
    output of the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00086.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our cluster is up and running; it's time to deploy our service on it.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying on the Kubernetes cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We begin the process of deploying our software on the Kubernetes cluster by
    defining a service. As you remember from [Chapter 7](text00137.html) , *Introduction
    to Kubernetes* , services abstract a set of Pods as a single IP and port, allow
    simple TCP/UDP load, and allow the list of Pods to change dynamically. Let's start
    with service creation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, each Pod is only accessible by its internal IP address within the
    Kubernetes cluster. To make the container accessible from outside the Kubernetes
    virtual network, we need to expose the Pod as a Kubernetes Service. To create
    a service, we are going to use the simple `.yaml` file, with a service manifest.
    YAML is a human-readable data serialization language, which is commonly used for
    configuration files. A sample service manifest for our Java `rest-example` could
    look the same as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the manifest of a service doesn''t refer to a Docker image. This
    is because, as you remember from [Chapter 7](text00137.html) , *Introduction to
    Kubernetes* , a service in Kubernetes is just an abstraction which provides a
    network connection to one or more Pods. Each service is given its own IP address
    and port, which remains constant for the lifetime of the service. Each Pod needs
    to have a specific label, to be discovered by the service, services find Pods
    to group using and labels `selectors` . In our previous example, the `selector`
    will pick up all Pods having a label `app` with the value of `rest-example` and
    a label named `tier` with a value of `backend` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As you remember from [Chapter 7](text00137.html) , *Introduction to Kubernetes*
    , every node in a Kubernetes cluster runs a kube-proxy process. The kube-proxy
    plays a crucial role in Kubernetes services. Its purpose is to expose a virtual
    IP for them. Since Kubernetes 1.2, the iptables proxy is the default. You have
    two options that you can use for setting up the proxy: userspace and iptables.
    Those settings refer to what actually handles the connection forwarding. In both
    cases, local iptables rules are installed to intercept outbound TCP connections
    that have a destination IP address associated with a service. There''s an important
    difference between those two modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Proxy-mode: userspace` : In the userspace mode, the iptables rule forwards
    to a local port where kube-proxy is listening for connections. The kube-proxy,
    running in userspace, terminates the connection, establishes a new connection
    to a backend for the service, and then forwards requests to the backend and responses
    back to the local process. An advantage of the userspace mode is that because
    the connections are created from an application, if the connection is refused,
    the application can retry to a different backend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Proxy-mode: iptables` : in this mode, the iptables rules are installed to
    directly forward packets that are destined for a service to a backend for the
    service. This is more efficient than moving the packets from the kernel to kube-proxy
    and then back to the kernel so it results in higher throughput and better tail
    latency. However, unlike the userspace mode, using iptables mode makes it impossible
    to automatically retry another Pod if the one it initially selects does not respond,
    so it depends on having working readiness probes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, in both cases there will be a kube-proxy binary running on the
    node. In userspace mode, it inserts itself as the proxy; in iptables mode, it
    will configure iptables rather than to proxy connections itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The service type can have the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NodePort** : By specifying a service type of `NodePort` , we declare to expose
    the service outside the cluster. The Kubernetes master will allocate a port from
    a flag-configured range (`default: 30000-32767` ), and each node of the cluster
    will proxy that port (the same port number on every node) into your service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load balancer** : This would create a load balancer on cloud providers which
    support external load balancers (for example, on Amazon AWS cloud). This feature
    is not available when using Minikube'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cluster IP** : This would expose the service only within the cluster. This
    is the default value which will be used if you don''t provide another'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Having our `service.yml` file ready, we can create our first Kubernetes service,
    by executing the following `kubectl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To see if our service is created properly, we can execute the `kubectl get
    services` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also list other services (including the services provided by the `minikube`
    cluster itself, if you are curious) by adding the `--all-namespaces` switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the details of a specific service, we use the `describe` command. Execute
    the following to see the details of our `rest-example` Java service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output, we are presented with the most useful service properties, especially
    the endpoints (our internal container IP and port, just one in this case, because
    we have one Pod running in the service), service internal port, and proxied NodePort:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Having all of the settings in a `.yaml` file is very convenient. Sometimes,
    though, there is a need to create a service in a more dynamic way; for example
    in some automation flows. In this case, instead of creating a `.yaml` file first,
    we can create a service manually, by providing all the parameters and options
    to the `kubectl` command itself. Before doing this, however, you will need have
    the deployment created first, because creating a service manually is just exposing
    a deployment using the `kubectl` command. After all, a service is an exposed deployment
    which, in fact, is just a set of Pods. The example of such exposure, which will
    result with service creation, looks the same as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Creating a deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before creating a deployment, we need to have our Docker image ready and published
    to a registry, the same as the Docker Hub for example. Of course, it can also
    be a private repository hosted in your organization. As you remember from the
    [Chapter 7](text00137.html) , *Introduction to Kubernetes* , each Docker container
    in a Pod has its own image. By default, the kubectl process in a Pod will try
    to pull each image from the specified registry. You can change this behavior by
    specifying a value for the `imagePullPolicy` property in a deployment descriptor.
    It can have the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IfNotPresent` : With this setting, the image will be pulled from the registry
    only if not present on the local host'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Never` : With this one, kubelet will use only local images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting `imagePullPolicy` with a value `IfNotPresent` when creating a deployment
    is useful; otherwise, Minikube will try to download the image before looking for
    an image on the local host.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes uses the same syntax for images as Docker itself, including private
    registries and tags.
  prefs: []
  type: TYPE_NORMAL
- en: It is important that you provide a tag in the image name. Otherwise, Kubernetes
    will use the latest tag when looking for your image in a repository, the same
    as Docker does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using locally built images gets a little bit tricky when working with a local
    Kubernetes cluster. Minikube runs in a separate VM, hence it will not see the
    images you''ve built locally using Docker on your machine. There''s a workaround
    for that. You can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The previous command will actually utilize the Docker daemon running on `minikube`
    , and build your image on the Minikube's Docker. This way, the locally built image
    will be available to the Minikube without pulling from the external registry.
    This is not very convenient, it is certainly easier to push the Docker image to
    a `remote` registry. Let's push our rest-example image into the `DockerHub` registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to log in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we are going to tag our image using the `docker tag` command (not that
    you will need to provide your own DockerHub username instead of `$DOCKER_HUB_USER`
    ):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step will be to push our image to Docker Hub using the `docker push`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have an image available in the registry, we need a deployment manifest.
    It''s again a `.yaml` file, which can look the same as this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To create this deployment on the cluster using `kubectl` , you will need to
    execute the following command, which is exactly the same as when creating a service,
    with a difference in the filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can look at the deployment properties with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, one Pod has been created along with a ReplicaSet and the default
    rolling update strategy. You can also look at the Pods with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of `get pods` command will give you the names of Pods running in
    the deployment. This is will be important later, because if you want to interact
    with a specific Pod, you will need to know its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00091.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As an alternative to the deployment descriptor in `.yaml` file, you can create
    deployments from the command line using `kubectl run` command with options, as
    you can see in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s summarize the `kubectl` commands related to creating resources and getting
    information about them, with some examples, in a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Example command** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl create -f ./service.yaml` | Create resource(s) |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl create -f ./service.yaml -f ./deployment.yaml` | Create from multiple
    files |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl create -f ./dir` | Create resource(s) in all manifest files in the
    specified directory |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl create -f https://sampleUrl` | Create resource(s) from URL |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl run nginx --image=nginx` | Start a single instance of nginx |'
  prefs: []
  type: TYPE_TB
- en: '| `Kubectl get pods` | Get the documentation for `pod` |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl get pods --selector=app=rest-example` | List all the Pods that match
    the specified label `selector` |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl explain pods` | Show details of all Pods |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl get services` | List all created services |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl explain service` | Show details of specified service |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl explain services` | Show details of all created services |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl get deployments` | List all created deployments |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl get deployment` | Show details of specified service |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl explain deployment` | Show details of specified deployment |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl explain deployments` | Show details of all created deployments |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl get nodes` | List all cluster nodes |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl explain node` | Show details of specified node |'
  prefs: []
  type: TYPE_TB
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have seen on the `kubectl` describe service `rest-example` command output,
    our `rest-example service` can be accessed within the cluster via port `8080`
    and the domain name `rest-example` . In our case, the complete URL of the endpoint
    would be `http://rest-example:8080` . However, to be able to execute the service
    from the outside world, we have used the `NodePort` mapping, and we know that
    it was given the port `31141` . All we need to call the service is the IP of the
    cluster. We can get it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a shortcut for getting to know the externally accessible service URL
    and a port number. We can use a `minikube service` command to tell us the exact
    service address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The output of the previous command will be the service URL with a mapped port
    number. If you skip the `--url` switch, `minikube` will just open the service's
    URL using your default web browser. This is sometimes handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having the complete URL of the endpoint, we can access the service, using any
    of the `HTTP` clients, such as `curl` , for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the service is running, application logs can often help you understand
    what is happening inside your cluster. The logs are particularly useful for debugging
    problems and monitoring cluster activity. Let's see how we can access our container
    logs.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with containers and viewing logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most modern applications have some kind of logging mechanism. Our Java REST
    service, for example, uses slf4j to output logs from the REST controller. The
    easiest and most simple logging method for containerized applications is just
    to write to the standard output and standard error streams. Kubernetes supports
    this out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming we''ve sent requests to our new web service using the browser or curl,
    we should now be able to see some logs. Prior to that, we need to have a Pods
    name, created automatically during deployment. To get the Pod''s name, use the
    `kubectl get pods` command. After that, you can show logs of the specified Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the following screenshot, we will get access to a well-known
    Spring Boot banner coming from a service running in a Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00093.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Viewing the log is not the only thing we can do with a specific Pod. Similar
    to Docker (a Pod is running Docker, actually), we can interact with a container
    by using the `kubectl exec` command. For example, to get a shell to the running
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will attach your shell console into the shell in the running
    container, where you can interact with it, such as listing the processes, for
    example, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The syntax of a `kubectl exec` command is very similar to the `exec` command
    in Docker, with one little difference, as you remember from the [Chapter 7](text00137.html)
    , *Introduction to Kubernetes* , a Pod can run more than one container. In such
    case, we can use `--container` or `-c` command switch to specify a container in
    the `kubectl exec` command. For example, let''s suppose we have a Pod named `rest-example-3660361385-gkzb8`
    . This Pod has two containers named service and database. The following command
    would open a shell to the service container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Having the possibility to view logs and interact with the containers gives
    you a lot of flexibility to pinpoint potential problems you may have with running
    Pods. Let''s summarize the `kubectl` commands related to viewing logs and interacting
    with the Pods in a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Example command** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl logs myPod` | Dump `pod` logs (`stdout` ) |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl logs myPod -c myContainer` | Dump `pod` container logs (`stdout`
    , multi-container case) |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl logs -f myPod` | Stream `pod` logs (`stdout` ) |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl logs -f myPod -c myContainer` | Stream `pod` container logs (`stdout`
    , multi-container case) |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl run -i --tty busybox --image=busybox -- sh` | `run pod` as interactive
    shell |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl attach myPod -i` | Attach to running container |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl port-forward myPod 8080:8090` | Forward port `8080` of Pod to your
    to `8090` on your local machine |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl exec myPod -- ls /` | `run` command in existing `pod` (one container
    case) |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl exec myPod -c myContainer -- ls /` | `run` command in existing `pod`
    (multi-container case) |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl top pod POD_NAME --containers` | Show metrics for a given `pod`
    and its containers |'
  prefs: []
  type: TYPE_TB
- en: As you already know, Pods and containers are fragile. They can crash or be killed.
    You can use `kubectl` logs to retrieve logs from a previous instantiation of a
    container with the `--previous` flag, in case the container has crashed. Let's
    say our service is running fine, but for the reasons described in the [Chapter
    7](text00137.html) , *Introduction to Kubernetes* , such as higher load, for example,
    you decide to increase the number of containers running. Kubernetes gives you
    the possibility to increase the number of Pod instances running in each service.
    This can be done manually or automatically. Let's focus on the manual scaling
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the deployment has been created, the new ReplicaSet has also been created,
    automatically. As you will remember from [Chapter 7](text00137.html) , *Introduction
    to Kubernetes* , a ReplicaSet ensures that a specified number of Pod clones, known
    as `replicas` , are running at any given time. It there are too many, some of
    them will be shut down. If there is a need for more, for example if some of them
    died because of an error or crash, new Pods will be created. Note that if you
    try to scale the ReplicaSet directly, then it will (for a very short time) have
    a new count of your desired number of Pods, for example three. But if the deployment
    controller sees that you have modified the replica set to three, since it knows
    that it is supposed to be one (defined in the deployment manifest), it will reset
    it back to one. By manually modifying the replica set that was created for you,
    you are, kind of, dealing against the system controller.
  prefs: []
  type: TYPE_NORMAL
- en: You need to scale your deployment instead of the replica set directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, our Java `rest-example` service keeps its data in memory so it''s
    not stateless, so it may be not the best example for scaling; if another instance
    is brought to life, it will have its own data. However, it is a Kubernetes service,
    so we can use it to demonstrate scaling anyway. To scale up our `rest-example`
    deployment from one up to three Pods, execute the following `kubectl scale` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After a short while, in order to check, execute the following commands, you
    will see that now three Pods are running in the deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following table, you can see some more examples of `kubectl` commands
    related to manual scaling:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Example command** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl scale deployment rest-example --replicas=3` | Scale a deployment
    named `rest-example` to `3` Pods |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl scale --replicas=3 -f deployment.yaml` | Scale a resource specified
    in `deployment.yaml` file to `3` |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl scale deployment rest-example --current-replicas=2 --replicas=3`
    | If the deployment named `rest-example` current size is `2` , scale it to `3`
    Pods |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl scale --replicas=5 deployment/foo deployment/bar` | Scale multiple
    deployments at one time |'
  prefs: []
  type: TYPE_TB
- en: Scaling can be done automatically by Kubernetes, if, for example, the service
    load increases.
  prefs: []
  type: TYPE_NORMAL
- en: Autoscaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With horizontal Pod auto scaling, Kubernetes automatically scales the number
    of Pods in a deployment or ReplicaSet based on observed CPU utilization. The Kubernetes
    controller periodically adjusts the number of Pod `replicas` in a deployment to
    match the observed average CPU utilization to the target you specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Horizontal Auto Scaler is just another type of resource in Kubernetes,
    so we can create it as any other resource, using the `kubectl` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl get hpa` : List autoscalers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubectl describe hpa` : Get detailed description'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubectl delete hpa` : Delete an autoscaler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, there is a special `kubectl autoscale` command for easy creation
    of a Horizontal Pod Autoscaler. An example could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The previous command will create an autoscaler for our `rest-example` deployment,
    with the target CPU utilization set to `5 0` % and the number of `replicas` between
    `1` and `10` .
  prefs: []
  type: TYPE_NORMAL
- en: All cluster events are being registered, including those which come from scaling,
    either manually or automatically. Viewing cluster events can be helpful when monitoring
    what exactly is being performed on our cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing cluster events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To view cluster events, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It will present a huge table, with all the events registered on the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The table will include the changes in the status of nodes, pulling Docker images,
    events of starting and stopping containers, and so on. It can be very handy to
    see the picture of the whole cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Kubernetes dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes dashboard is a general purpose, web-based UI for Kubernetes clusters.
    It allows users to manage applications running in the cluster and troubleshoot
    them, as well as manage the cluster itself. We can also edit the manifest files
    of deployment, services, or Pods. The changes will be picked up immediately by
    Kubernetes, so it gives us the capability to scale down or up the deployment,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open the dashboard with the `minikube dashboard` command, it will open
    your default browser with a dashboard URL. From here, you can list all the resources
    on the cluster, such as deployments, services, Pods, and so on. Our dashboard
    is no longer empty, as you can see in the following screenshot; we have one deployment
    called `rest-example` :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click on its name, you will be taken to the deployment details page,
    which will show the same information you could get with the `kubectl describe
    deployment` command, with a nice UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The dashboard is not only read-only utility. Each resource has a handy menu
    which you can use to delete it or to edit its manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you pick the view/edit YAML menu option, you will be able to edit the manifest
    with a handy editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that if you change a value, for example the number of `replicas` , and
    click Update , the change will be sent to the Kubernetes and executed. This way
    you can also, for example, scale your deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'As deployment has created a ReplicaSet automatically, the ReplicaSet will also
    be visible in the dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The same applies to services. If you browse to the Services menu, it will present
    a list of all services created on a cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on the name of service will take you to the details page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the details screen, all important information is listed. This includes label
    selector, that will be used to find Pods, port type, cluster IP, internal endpoints,
    and of course the list of Pods running inside the service. By clicking Pod''s
    name, you can see details of a running Pod, including its log output, as you can
    see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00103.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The dashboard is a very handy tool to interact with your existing deployments,
    services, and Pods. But there''s more. If you click on the Create button in the
    top right corner of the dashboard''s toolbar, you will be presented with a Deploy
    a Containerized App screen. From here, you can actually create a new deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00104.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You have an opportunity to use the `.yaml` file, as we did before using the
    command line, but also you can specify details of the deployment manually, providing
    an application name, and container image to use and optionally create a service
    for the deployment. Quite handy, isn't it? The dashboard is just one of the Minikube
    add-ons available. Let's look at what else we have at our disposal.
  prefs: []
  type: TYPE_NORMAL
- en: Minikube addons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Minikube comes with several add-ons, such as Kubernetes dashboard, Kubernetes
    DNS, and so on. We can list the available addons by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the previous command will list the available addons with their
    current status, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00105.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To enable or disable the addon, we use `minikube addons disable` or `minikube
    addons enable` , respectively, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If the add-on is enabled, we can the corresponding web user interface by executing
    the `addon open` command, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Cleaning up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you finish playing with your deployment and services or would like to start
    from the beginning, you can do some cluster cleaning by removing the deployment
    or services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This code can also be combined in one command, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `kubectl delete` supports label `selectors` and namespaces. Let''s see
    some other examples of the command in a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Example command** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl delete pod,service baz foo` | Delete pods and services with same
    names `baz` and `foo` |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl delete pods,services -l name=myLabel` | Delete pods and services
    with label `name=myLabel` |'
  prefs: []
  type: TYPE_TB
- en: '| `kubectl -n my-ns delete po,svc --all` | Delete all pods and services in
    namespace `my-ns` |'
  prefs: []
  type: TYPE_TB
- en: 'To stop the `minikube` cluster, issue simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If you would like to delete the current `minikube` cluster, you can issue the
    following command to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, the Minikube is an easy way to try out Kubernetes and use it
    for local development. Running the local cluster is not as scary as it may have
    seemed at the beginning. Best of all, the local `minikube` cluster is a valid
    Kubernetes cluster. If you get to know Kubernetes by playing with it locally,
    you will be able to deploy your applications in the real cloud without any issues.
    Let's summarize the steps that we need to perform to make our Java application
    run on the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to write some code for our microservice. This can be based on
    whatever you want, it can be a microservice running on Tomcat, JBoss, or Spring
    Bootstrap. It doesn''t matter, you just choose the technology you want your software
    to run with:'
  prefs: []
  type: TYPE_NORMAL
- en: Next, put the code into Docker image. You can do it by hand by creating a Dockerfile
    or you can use Docker Maven plugin to automate this
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create Kubernetes metadata, such as deployment manifest and service manifest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply the metadata by rolling out the deployment and creating the service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scale your applications to your needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage your cluster either from the command line or from the dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 9](text00180.html) , *Working with Kubernetes API* , we will take
    a look at the Kubernetes API. This is a great way of interacting with Kubernetes
    cluster. Because of API, the possibilities are almost endless, you can create
    your own development flows, such as continuous delivery using Jenkins, for example.
    Having the API, you are not limited only to existing tools to deploy your software
    to Kubernetes. Things can get more interesting.
  prefs: []
  type: TYPE_NORMAL
