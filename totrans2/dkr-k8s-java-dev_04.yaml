- en: Creating Java Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve seen a lot of theory behind microservice architecture in [Chapter 3](text00053.html)
    , *Working with Microservices* . It''s time to do some hands-on practice; we are
    going to implement our own microservice. This will be a simple REST service, accepting
    `HTTP` methods such as `GET` and `POST` to retrieve and update entities. There
    are a couple of choices when developing microservices in Java. In this chapter,
    we are going to get an overview about two main approaches, probably the most popular
    will be JEE7, and Spring Boot. We will briefly see how we can code a microservice
    using JEE JAX-RS. We will also create a microservice running on Spring Boot. In
    fact, in [Chapter 5](text00084.html) , *Creating Images with Java Applications*
    , we are going to run our Spring Boot microservice from within a Docker container.
    As we have said in [Chapter 3](text00053.html) , *Working with Microservices*
    , microservices usually communicate with the outside world using REST. Our REST
    microservice will be as simple as possible; we just need to have something to
    deploy using Docker and Kubernetes. We will not focus on advanced microservice
    features such as authentication, security, filters, and so on, as this is outside
    the scope of this book. The purpose of our examples is to give you an idea of
    how to develop REST services and then deploy them using Docker and Kubernetes.
    This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a REST service in Java using Java EE7 annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a REST service using Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the service and then calling it with different HTTP clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of the chapter, we will become familiar with some useful tools- we
    will use some code generation tools such as Spring Initialzr to quickly bootstrap
    a Spring Boot service project. Before we start coding our own microservice, let's
    explain briefly what REST is.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The REST acronym stands for Representational State Transfer. It's an architectural
    style and a design for network-based software. It describes how one system can
    communicate a state with another. This fits perfectly well into the microservice
    world. As you will remember from [Chapter 3](text00053.html) , *Working with Microservices*
    , the software applications based on the microservices architecture is a bunch
    of separated, independent services talking to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some concepts in REST that we need to understand, before we go further:'
  prefs: []
  type: TYPE_NORMAL
- en: '`resource` : This is the main concept in the REST architecture. Any information
    can be a resource. A bank account, a person, an image, a book. A representation
    of a resource must be **stateless**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`representation` : A specific way a resource can be represented. For example,
    a bank account resource can be represented using JSON, XML, or HTML. Different
    clients might request different representations of the resource, one can accept
    JSON, while others will be expecting XML'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`server` : A service provider. It exposes services which can be consumed by
    clients'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`client` : A service consumer. This could be another microservice, application,
    or just a user''s web browser running an Angular application, for example'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the definition says, REST is being used to transport those resource representations
    over the network. The representation itself is being created via some media type.
    Media types can be different. Some examples of media types include JSON, XML,
    or RDF. The JSON media type is widely accepted and probably the most often used.
    In our examples, we will also use JSON to communicate with our service. Of course,
    REST is not the only option for microservices communication; there are others,
    such as Google's very good gRPC, for example, which brings a lot of advantages
    such as HTTP/2 and protobuff. In the REST architecture, resources are manipulated
    by components. In fact, these components are our microservices. Components request
    and manipulate resources via a standard uniform interface. REST is not tied to
    any specific protocol; however, REST calls are most often being made using the
    most popular `HTTP` or `HTTPS` protocol. In the case of `HTTP` , this uniform
    interface consists of standard HTTP methods such as `GET` , `PUT` , `POST` , and
    `DELETE` .
  prefs: []
  type: TYPE_NORMAL
- en: REST is not tied to any specific protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start implementing our service that will respond to `HTTP` calls,
    it's worth knowing about the HTTP methods we are going to use. We are going to
    focus on them a little bit closer now.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The REST-based architecture uses standard HTTP methods: `PUT` , `GET` , `POST`
    , and `DELETE` . The following list gives an explanation of these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET` gives a read access to the resource. Calling `GET` should not create
    any side-effects. It means that the `GET` operation is idempotent. The resource
    is never changed via a `GET` request; for example, the request has no side effects.
    It means it''s idempotent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT` creates a new resource. Similar to `GET` , it should also be idempotent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE` removes the resource or resources. The `DELETE` operation should not
    give different results when called repeatedly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` will update an existing resource or create a new one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A RESTful web service is simply a web service that is based on the `REST` resource
    concept and usage of HTTP methods. It should define the base URI for the exposed
    methods, the MIME-types supported, such as XML, text, or JSON, and the set of
    operations (`POST` , `GET` , `PUT` , and `DELETE` ) which the service handles.
    HTTP is simple and very natural for REST, according to RESTful principles. These
    principles are a set of constraints that ensure that clients (service consumers,
    other services or browsers, for example) can communicate with servers in a flexible
    way. Let's look at them now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In REST principles client-server communication, all applications built in the
    RESTful style must also be client-server in principle. There should be a server
    (service provider) and a client (service consumer). Having this enables loose
    coupling and independent evolution of server and client. This fits very well to
    the concept of a microservice. As you will remember from [Chapter 3](text00053.html)
    , *Working with Microservices* , they must be independent:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stateless** : Each `client` request to the server requires that its state
    be fully represented. The server must be able to completely understand the `client`
    request without using any server context or server session state. In other words,
    all states must be managed on the client side. Each REST service should be **stateless**
    . Subsequent requests should not depend on some data from a previous request being
    temporarily stored. Messages should be self-descriptive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cacheable** : Response data could be marked as cacheable or non-cacheable.
    Any data marked as cacheable may be reused as the response to the same subsequent
    request. Each response should indicate if it is cacheable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uniform interface** : All components must interact through a single uniform
    interface. Because all component interactions occur via this interface, interaction
    with different services is very simple.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layered system** : A consumer of the service should not assume direct connection
    to the service provider. In other words, at any time the client cannot tell if
    it is connected to the end server or to an intermediate. The intermediate layer
    helps to enforce the security policies and improve the system scalability by enabling
    load-balancing. Since requests can be cached, the client might be getting the
    cached response from a middle layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manipulation of resources through representations** : A resource can have
    multiple representations. It should be possible to modify the resource through
    a message with any of these representations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hypermedia As The Engine Of Application State (HATEOAS)** : A consumer of
    a RESTful application should know about only one fixed service URL. All subsequent
    resources should be discoverable from the links included in the resource representations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The previous concepts represent defining characteristics of REST and differentiate
    the REST architecture from other architectures such as web services. It is useful
    to note that a REST service is a web service, but a web service is not necessarily
    a REST service. The REST microservice should represent the state of an entity.
    Let our entity be a book, for example (altogether with its properties such as
    ID, title, and an author), represented as XML, JSON, or plain text. The most basic
    way of thinking about REST is as a way of formatting the URLs of your service.
    For example, having our `book` resource, we could imagine having the following
    operations defined in the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/books` would allow access of all the books'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/books/:id` would be an operation for viewing an individual book, retrieved
    based on its unique ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: sending a `POST` request to `/books` would be how you would actually create
    a new book and store it in a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: sending a `PUT` request to `/books/:id` would be how you would update the attributes
    of a given book, again identified by its unique ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: sending a `DELETE` request to `/books/:id` would be how you would delete a specific
    book, again identified by its unique ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's worth trying to understand that REST is not HTTP. It often uses HTTP because
    in its most general form, REST is about mapping the concept of a verb against
    an arbitrary collection of nouns and fits well with HTTP methods. HTTP contains
    a useful set of generic verbs (`GET` , `POST` , `PUT` , `PATCH` , and so on).
    In REST, we do not transfer an actual object but a representation of it in a specific
    form, such as XML, text, or JSON. REST as an architectural style means it is just
    a concept. How it's implemented, is up to you. Java is suited well for developing
    REST services. Let's see how can we do it.
  prefs: []
  type: TYPE_NORMAL
- en: REST in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing a REST service in Java, we have at least a couple of options
    for the framework we could use. The most popular will be pure JEE7 with JAX-RS
    or Spring Framework with its Spring Boot. You can use either of them or mix them
    together. Let's look at those two now in more detail, starting with JAX-RS.
  prefs: []
  type: TYPE_NORMAL
- en: Java EE7 - JAX-RS with Jersey
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JAX-RS was born as a result of **Java Specification Request** (**JSR** ) 311\.
    As the official definition says, the JAX-RS is the Java API for RESTful web services.
    It's a specification that provides support in creating web services according
    to the REST architectural pattern. JAX-RS uses Java annotations, introduced in
    Java SE 5, to simplify the development and deployment of web service clients and
    endpoints. From version 1.1 on, JAX-RS is an official part of Java EE. A notable
    feature of being an official part of Java EE is that no configuration is necessary
    to start using JAX-RS.
  prefs: []
  type: TYPE_NORMAL
- en: Java EE 7 with JAX-RS 2.0 brings several useful features, which further simplify
    the development of microservices. One of the most important new features of JAX-RS
    2.0 is the support for hypermedia following the HATEOAS principle of REST. `Jersey`
    , a library from Oracle, is probably the most widely known library, which implements
    this specification.
  prefs: []
  type: TYPE_NORMAL
- en: Jersey is the reference implementation for the JSR 311 specification.
  prefs: []
  type: TYPE_NORMAL
- en: The Jersey implementation provides a library to implement RESTful web services
    in a Java servlet container. On the server-side, Jersey provides a servlet implementation
    which scans predefined classes to identify RESTful resources. Jersey makes it
    a lot easier to write RESTful services. It abstracts away a lot of the low level
    coding you will need to do yourself otherwise. Using Jersey, you do it in a declarative
    way. The servlet, registered in your `web.xml` file, analyzes the incoming `HTTP`
    request and selects the correct class and method to respond to this request. It
    finds the proper method to execute by looking at the class and method level annotations.
    Annotated classes can reside in different packages, but you can instruct a Jersey
    servlet via the `web.xml` to scan certain packages for annotated classes.
  prefs: []
  type: TYPE_NORMAL
- en: JAX-RS supports the creation of XML and JSON via the **Java Architecture for
    XML Binding** (**JAXB** ). The Jersey implementation also provides a `client`
    library to communicate with a RESTful web service.
  prefs: []
  type: TYPE_NORMAL
- en: As we have said before, we develop JAX-RS applications using Java annotations.
    It's easy and pleasant to work with. Let's describe those annotations now.
  prefs: []
  type: TYPE_NORMAL
- en: JAX-RS annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most important annotations in JAX-RS are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Annotation** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `@PATH` | Sets the path to base `URL + /your_path` . The base URL is based
    on your application name, the servlet, and the URL pattern from the `web.xml`
    configuration file. |'
  prefs: []
  type: TYPE_TB
- en: '| `@POST` | Indicates that the following method will answer to an `HTTP POST`
    request. |'
  prefs: []
  type: TYPE_TB
- en: '| `@GET` | Indicates that the following method will answer to an `HTTP GET`
    request. |'
  prefs: []
  type: TYPE_TB
- en: '| `@PUT` | Indicates that the following method will answer to an `HTTP PUT`
    request. |'
  prefs: []
  type: TYPE_TB
- en: '| `@DELETE` | Indicates that the following method will answer to an `HTTP DELETE`
    request. |'
  prefs: []
  type: TYPE_TB
- en: '| `@Produces` | Defines which MIME type is delivered by a method annotated
    with `@GET` . It can be `"text/plain"` , `"application/xml"` , or `"application/json"`
    for example. |'
  prefs: []
  type: TYPE_TB
- en: '| `@Consumes` | Defines which MIME type is consumed by this method. |'
  prefs: []
  type: TYPE_TB
- en: '| `@PathParam` | Used to extract (inject) values from the URL into a method
    parameter. This way you inject, for example, the ID of a resource into the method
    to get the correct object. |'
  prefs: []
  type: TYPE_TB
- en: '| `@QueryParam` | Used to extract (inject) the URI query parameter coming with
    the request. The **Uniform Resource Identifier** (**URI** ) is a string of characters
    used to identify a name or a resource on the Internet. |'
  prefs: []
  type: TYPE_TB
- en: '| `@DefaultValue` | Specifies a default value. Useful for optional parameters.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@CookieParam` | Annotation that allows you to inject cookies sent by a client
    request into your JAX-RS resource methods. |'
  prefs: []
  type: TYPE_TB
- en: '| `@Provider` | The `@Provider` annotation is used for anything that is of
    interest to the JAX-RS runtime, such as `MessageBodyReader` and `MessageBodyWriter`
    . For `HTTP` requests, `MessageBodyReader` is used to map an `HTTP` request entity
    body to method parameters. On the response side, a return value is mapped to an
    `HTTP` response entity body by using `MessageBodyWriter` . If the application
    needs to supply additional metadata, such as `HTTP` headers or a different status
    code, a method can return a response that wraps the entity and that can be built
    using `Response.ResponseBuilder` . |'
  prefs: []
  type: TYPE_TB
- en: '| `@ApplicationPath` | The `@ApplicationPath` annotation is used to define
    the URL mapping for the application. The path specified by `@ApplicationPath`
    is the base URI for all resource URIs specified by `@Path` annotations in the
    `resource` class. You may only apply `@ApplicationPath` to a subclass of `javax.ws.rs.core.Application`
    . |'
  prefs: []
  type: TYPE_TB
- en: 'The annotation names might not be clear or self-explanatory at first glance.
    Let''s look at the sample REST endpoint implementation, and it will become a lot
    clearer. The application itself is marked with the `@ApplicationPath` annotation.
    By default, during start-up of the JEE compliant server, JAX-RS will scan all
    the resources in a Java application archive to find the exposed endpoints. We
    can override the `getClasses()` method to manually register the `resource` classes
    in the application with the JAX-RS runtime. You can see it in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we just register a REST application, giving it the
    `/myApp` base URI path. There is only one `REST` method handler (endpoint), the
    `MyBeansExposure` class, which we register within the REST application. The simplified
    REST endpoint, implemented in the separate Java class can look same as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the previous example, we have class-level `@Path` annotation.
    Every method marked with `@GET` , `@PUT` , `@DELETE` , or `@POST` annotations
    will respond to a call to the URI starting with the base `@Path` . Additionally,
    we can use the `@Path` annotation on a method level; it will, kind of, extend
    the URI path that the specific method responds to. In our example, the `HTTP GET`
    executed with a URI path `myApp/beans` will call the `allBeans()` method, returning
    the collection of beans in JSON format. The `GET` method executed using the `myApp/beans/12`
    URI path will call the `singleBean()` method, and the `{id}` parameter will be
    transferred to the method because of the `@PathParam` annotation. Calling the
    `HTTP DELETE` method on the `myApp|beans|12` URI will execute the `remove()` method
    with an `id` parameter value `12` . To give you almost infinite flexibility, the
    `@Path` annotation supports regular expressions. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we have two `@GET` mappings, each with the same `/books/`
    path mapped. The first one, with the `/{title : [a-zA-Z][a-zA-Z_0-9]}` parameter,
    will react only to letters and numbers. The second one, with the `/{isbn : \\d+}`
    parameter, will be executed only if you provide a number when calling the URI.
    As you can see, we have mapped two identical paths, but each one will react to
    a different type of incoming path parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from using `@PathParam` , we can also use `@QueryParams` to supply parameters
    using the request parameters. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, when calling `HTTP GET` on the `/users/query?from=1&to=100&orderBy=name`
    JAX-RS will pass the URI parameters into the `getUsers()` method parameter and
    call the injected `userService` to get the data (for example, from a database).
  prefs: []
  type: TYPE_NORMAL
- en: 'To package the JAX-RS application, we will need a Maven `pom.xml` file, of
    course. In its simplest form, it can look the same as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Creating JEE7 REST services is quite straightforward, isn't it? By building
    the project and deploying it to a JEE compliant application server, we have a
    couple of endpoints ready and waiting to be called over `HTTP` . But there's an
    even more simple and faster approach. In the era of microservices, we would want
    to create individual components faster with a minimal overhead, after all. Here
    comes Spring Boot. Let's look at it now.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring itself is a very popular Java-based framework for building web and enterprise
    applications. It''s not only the Spring Core, which focuses on dependency injection.
    Spring Framework provides a lot of features that can make a developer''s life
    easier out of the box and allows you to deliver needed features faster. The list
    is long; here are just a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring data** : Simplifies data access from relational and NoSQL data stores'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring batch** : Provides a powerful batch processing framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring security** : Provides numerous ways to secure applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring social** : Supports integration with social networking sites such
    as Twitter, Facebook, GitHub, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring integration** : An implementation of enterprise integration patterns
    to facilitate integration with other enterprise applications using lightweight
    messaging and declarative adapters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But why did Spring become so popular? There are several reasons for that:'
  prefs: []
  type: TYPE_NORMAL
- en: It uses the dependency injection approach, which encourages writing testable,
    loosely coupled code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's easy to include database transaction management capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The integration with other popular Java frameworks such as JPA/Hibernate, for
    example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It includes a state of the art MVC framework for building web applications faster,
    separating the view from the business logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring beans in the Spring framework can be done in multiple ways such
    as the XML definition file, Java annotations, and code configuration. This can
    be a tedious process. Also, we often do a lot of boilerplate configuration all
    the time, for different applications. Spring Boot was born to address the complexity
    of configuration. We can use Spring Boot for our own purposes, and develop small,
    independent services that can just be run. It can be a single runnable fat JAR
    file, with all the Java dependencies needed to run your application. There's no
    need for an application server or the complicated deployment descriptor configuration.
    In fact, behind the scenes, Spring Boot will boot up an embedded server for you.
    Of course, you are not forced to use the embedded application server. You can
    always build a WAR file to deploy it on your own Tomcat or Wildfly, for example.
    It's worth knowing, that even though most things will happen automatically when
    running a Spring Boot application, it's not a code generation framework.
  prefs: []
  type: TYPE_NORMAL
- en: Does all of this remind you about the simplicity and portability of Docker containers?
    Sure it does, but on the application level. As we discussed in [Chapter 3](text00053.html)
    , *Working with Microservices* , we are moving towards architectures with smaller,
    independently deployable microservices. This means we will need to be able to
    quickly get off the ground and get running with new components. We get a lot of
    features out of the box when using Spring Boot. These features are delivered in
    the form of Maven artifacts, which you can just include in your Maven `pom.xml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows some of the important starter projects provided by
    Spring Boot we will be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Project** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter` | Base starter for Spring Boot applications. Provides
    support for auto-configuration and logging. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-web` | Starter project for building Spring MVC based
    web applications or RESTful applications. This uses Tomcat as the default embedded
    servlet container. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-data-jpa` | Provides support for Spring Data JPA. Default
    implementation is Hibernate. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-validation` | Provides support for Java Bean Validation
    API. Default implementation is Hibernate Validator. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-test` | Provides support for various unit testing frameworks,
    such as JUnit, Mockito, and Hamcrest matchers |'
  prefs: []
  type: TYPE_TB
- en: 'There are a lot more projects, which can be useful for you. We are not going
    to use them, but let''s look at what else is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `spring-boot-starter-web-services` | Starter project for developing XML based
    web services |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-activemq` | Supports message based communication using
    JMS on ActiveMQ |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-integration` | Supports Spring Integration, framework
    that provides implementations for Enterprise Integration Patterns |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-jdbc` | Provides support for using Spring JDBC. Configures
    a Tomcat JDBC connection pool by default. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-hateoas` | HATEOAS stands for Hypermedia as the Engine
    of Application State. RESTful services that use `HATEOAS` return links to additional
    resources that are related to the current context in addition to data. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-jersey` | JAX-RS is the Java EE standard for developing
    REST APIs. Jersey is the default implementation. This starter project provides
    support for building JAX-RS based REST APIs. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-websocket` | `HTTP` is stateless. Web sockets allow
    maintaining connection between server and browser. This starter project provides
    support for Spring WebSockets. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-aop` | Provides support for Aspect oriented programming.
    Also provides support for AspectJ for advanced Aspect oriented programming. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-amqp` | With default as `RabbitMQ` , this starter project
    provides message passing with AMQP. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-security` | This starter project enables auto-configuration
    for Spring Security. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-batch` | Provides support for developing batch applications
    using Spring Batch. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-cache` | Basic support for caching using Spring Framework.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-data-rest` | Support for exposing REST services using
    Spring Data REST. |'
  prefs: []
  type: TYPE_TB
- en: Let's use some of these goodies to code our own Spring Boot microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Spring Boot microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We know that we have some starters available, so let''s make use of them to
    save some time. The service that we are going to create will be the simple REST
    microservice for storing and retrieving entities from a database: books, in our
    case. We are not going to implement authentication and security features, just
    to make it as clean and simple as possible. Books will be stored in an in-memory
    relational H2 database. We are going to build and run our bookstore with Maven,
    so let''s begin with the `pom.xml` build file.'
  prefs: []
  type: TYPE_NORMAL
- en: Maven build file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you will see, the parent project for our own service is spring-boot-starter-parent.
    Spring this is the parent project providing dependency and plugin management for
    Spring Boot-based applications. This gives us a lot of features to start with.
    We also include two starters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-boot-starter-web` : This is because we are going to create our request
    mappings (similar to `@GET` or `@POST` mappings with the `@Path` annotation we
    did previously using JEE7 JAX-RS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-boot-starter-data-jpa` : Because we are going to save our books in
    the in-memory H2 database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Starters are simplified dependency descriptors customized for different purposes.
    For example, `spring-boot-starter-web` is the starter for building web and RESTful,
    applications using Spring MVC. It uses Tomcat as the default embedded container.
    We also include the Spring Boot Maven plugin, which allows us to run the applications
    in place without building a JAR or a WAR, or preparing a JAR or WAR file for future
    deployment. Our complete `pom.xml` should look the same as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, in the `pom.xml` file, we define the parent Maven artifact. As our application
    is the Spring Boot application, we inherit our `pom.xml` from the `spring-boot-starter-parent`
    artifact. This gives us all the Spring Boot goodies out of the box, such as the
    startup mechanism, dependency injection, and so on. By adding `spring-boot-starter-data-jpa`
    as a dependency, we will be able to use all the database-related features, such
    as JDBC transaction management, JPA annotations for the entity classes, and so
    on. Having the `pom.xml` ready, let's continue and define the entry point for
    our microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Application entry point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our application entry point will be named `BookStoreApplication` and will be
    `BookstoreApplication.java` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. The whole nine lines of code, not counting blank lines. It could
    not be more concise. The `@SpringBootApplication` is a kind of shortcut annotation,
    which is very convenient. It replaces all of the following annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Configuration` : A class marked with this annotation becomes a source of
    bean definitions for the application context'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@EnableAutoConfiguration` : This annotation makes Spring Boot add beans based
    on classpath settings, other beans, and various property settings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@EnableWebMvc` : Normally you would add `this one` for a Spring MVC application,
    but Spring Boot adds it automatically when it sees `spring-webmvc` on the classpath.
    This marks the application as a web application, which in turn will activate key
    behaviors such as setting up a `DispatcherServlet`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ComponentScan` : Tells Spring to look for other components, configurations,
    and services, allowing it to find the controllers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far so good. We need some models for our service. We are going to save some
    entities in the database; this is where the `spring-boot-starter-data-jpa` starter
    will come in handy. We will be able to use JPA (implemented with Hibernate) and
    `javax.transaction-api` without even declaring it explicitly. We need an entity
    model for our bookstore.
  prefs: []
  type: TYPE_NORMAL
- en: Domain model and a repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A domain model in our service will be a `Book` class, defined in the `Book.java`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see on the previous listing, the `Book` class is a simple POJO with
    some annotations, properties, and getters and setters. The `@Entity` annotations
    come from the `javax.persistence` package and marks the POJO as a database entity,
    to enable JPA to store or retrieve it from the H2 database. `@Column` annotations
    specify the names of database columns where the corresponding book properties
    will be stored. The `@NotNull` and `@Size` annotations will make sure that our
    entity has proper values filled in, before it goes into the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have our entity defined; it''s now time to have a mechanism to read and
    store it in the database. We will use Spring''s `JpaRepository` for this purpose.
    The name of our repository will be `BookRepository` in the `BookRepository.java`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The Spring Data JPA provides a repository programming model that starts with
    an interface per managed domain object. Defining this interface serves two purposes.
    First, by extending the `JPARepository` interfaces, we get a bunch of generic
    CRUD methods into our type that allows saving our entities, deleting them, and
    so on. For example, the following methods are available (declared in the `JPARepository`
    interfaces we are extending):'
  prefs: []
  type: TYPE_NORMAL
- en: '`List<T> findAll();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<T> findAll(Sort sort);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<T> findAll(Iterable<ID> ids);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<S extends T> List<S> save(Iterable<S> entities);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T getOne(ID id);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<S extends T> S save(S entity);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<S extends T> Iterable<S> save(Iterable<S> entities);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T findOne(ID id);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean exists(ID id);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Iterable<T> findAll();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Iterable<T> findAll(Iterable<ID> ids);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long count();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void delete(ID id);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void delete(T entity);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void delete(Iterable<? extends T> entities);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void deleteAll();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No SQL coding, no JPA-QL queries, nothing. Simply by extending the Spring `JPARepository`
    interface, all those methods are at our disposal. Of course, we are not limited
    to those. We can declare our own methods in our interface, as `findByTitle(String
    title)` , for example. It will be picked up by Spring at runtime and will find
    us a book by its title. I highly recommend reading the Spring Data project documentation
    and experimenting further; it''s very convenient to use. Using the `entity` repository
    straight from the controller is usually not very good practice, so it''s time
    to have a book service. It will be a `BookService` interface, defined in the `BookService.java`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation, in the `BookServiceImpl.java` , can look the same as following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The previous listing presents the `BookService` implementation. Note that we
    have injected the `BookRepository` in the constructor. All the implementation
    methods, such as `saveBook()` , `getBook()` , `deleteBook()` , and `getList()`
    will use the injected `BookRepository` to operate on the book entities in the
    database. It's time for the last class, the actual controller that will wire all
    the previous classes together.
  prefs: []
  type: TYPE_NORMAL
- en: REST controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The REST controller defines URI paths that the service is going to respond
    to. It declares paths and corresponding `HTTP` methods that each controller method
    should react to. We define all of these using annotations. This approach is very
    similar to JAX-RS with Jersey. Our service has just one, single `book` resource,
    so we will have just a single controller for starters. It will be `BookController`
    class, defined in the `BookController.java` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the previous example, the class is annotated with the `@RestController`
    annotation. This is what makes it a controller, actually. In fact, it''s a convenient
    annotation that is itself annotated with `@Controller` and `@ResponseBody` annotations.
    `@Controller` indicates that an annotated class is a controller (a web controller),
    also allowing for implementation classes to be autodetected through Spring''s
    classpath scanning. Every method in a controller that should respond to a call
    to a specific URI is mapped with the `@RequestMapping` annotation. `@RequestMapping`
    takes parameters, the most important ones are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`value` : It will specify the URI path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`method` : Specifyies the `HTTP` method to handle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`headers` : The headers of the mapped request, in a format `myHeader=myValue`
    . A request will be handled by the method using the headers parameter, only if
    the incoming request header is found to have the given value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`consumes` : Specifies the media types the mapped request can consume, such
    as `"text/plain"` or `"application/json"` . This can be a list of media types,
    for example: `{"text/plain", "application/json"}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`produces` : Specifies the media types the mapped request can produce, such
    as `"text/plain"` or `"application/json"` . This again can be a list of media
    types, for example: `{"text/plain", "application/json"}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Similar to JAX-RS` `@PathParam` and `@QueryParam` to specify the controller
    method''s input parameters`,` now we have `@PathVariable` and `@RequestParam`
    in Spring. If you need to have your method parameter come in the request body
    (as a whole JSON object that you want to save, the same as in our `saveBook()`
    method), you will need to map the parameter using the `@RequestBody` annotation.
    As for the output, the `@ResponseBody` annotation can tell our controller that
    the method return value should be bound to the web response body.'
  prefs: []
  type: TYPE_NORMAL
- en: In a real-world service, you will probably have a lot of controllers with a
    lot of paths mapped. When exposing such a service to the world, it's usually a
    good practice to document the API of the service. This API documentation is the
    service contract. Doing this manually could be a tedious process. Also, if you
    make changes, it's good to have the API documentation in sync. There is a tool
    that can make it a lot easier, Swagger.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before a client can consume a service, it would need a service contract. A
    service contract defines all the details about a service; for example, how the
    service can be called, the URI of the service, and what the request and response
    formats are. Your clients will need to know how to interact with your API. Swagger
    is gaining a lot of ground with support from major vendors in the last couple
    of years. Swagger''s specification presents all the details of your service resources
    and operations in a JSON format. The format of the specification is known as the
    OpenAPI specification (Swagger RESTful API documentation specification). It''s
    human and machine readable, easy for parsing, transferring, and using in integration.
    The `SpringFox` library can be used to generate Swagger documentation from the
    RESTful services code. What''s more, there is a wonderful tool called Swagger
    UI, which when integrated into the application, provides human readable documentation.
    In this section, we will generate Swagger documentation for our services. The
    `SpringFox` library, available on GitHub at [http://springfox.github.io/springfox/](http://springfox.github.io/springfox/)
    and in the Maven central, is a tool to automatically build JSON API documentation
    for APIs built with Spring. Even better, the library provides the Swagger UI tool.
    The tool will be deployed together with your service and can be used, browse the
    generated API documentation in a very convenient way. Let''s introduce Swagger
    to our service. We begin with adding the needed dependencies to our service `pom.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Having the library available in a classpath of our application, we need to
    turn it on. The next step will be then be adding the configuration class to enable
    and generate the Swagger documentation. We do it by creating a class annotated
    with the Spring `@Configuration` annotation, the same as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A couple of words of explanation here. `@Configuration` means that the annotated
    class is defining a Spring configuration, `@EnableSwagger2` turns off the Swagger
    support. The `Docket` is a builder class to configure the generation of Swagger
    documentation, configured with `DocumentationType.SWAGGER_2` to generate Swagger
    2 compatible API documentation. The `select()` method called on the `Docket` bean
    instance returns an `ApiSelectorBuilder` , which provides the `apis()` and `paths()`
    methods to filter the controllers and methods being documented using string predicates.
    In our example, we want all controllers and all mapped paths to be documented;
    that's why we use `.apis(RequestHandlerSelectors.any()).paths(PathSelectors.any())`
  prefs: []
  type: TYPE_NORMAL
- en: You could also use the `regex` parameter passed to `paths()` to provide an additional
    filter to generate documentation only for the path matching the regex expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it; it''s the simplest form of generating a documentation for your
    API. If you now run the service (we are going to do this in a short while), two
    endpoints will be available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8080/v2/api-docs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/swagger-ui.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first one contains the Swagger 2 compatible documentation, in a JSON format,
    as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To browse the API documentation in a lot more useful form, point your browser
    to the second URL. You will be presented with the Swagger UI tool interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Swagger UI is a collection of HTML, JavaScript, and CSS assets that dynamically
    generate beautiful documentation from a Swagger-compliant API. It lists your service
    operations, and its request and response formats. Best of all, you can test your
    service using this tool, by executing specific requests. In fact, it''s a great
    tool to quickly test your service. Our documentation is not very descriptive.
    Of course, we have a listing of our exposed endpoints with their input and output
    description. It would be nice if we could enhance the documentation with some
    more specific details. We CAN do it, there are Java annotations we can use in
    the service''s code to enhance the generated documentation. The annotations come
    from the Swagger-annotation package, which will be available if you use the `springfox-swagger2`
    library in your project. For example, consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, we use the `@ApiOperation` annotation to provide a more
    detailed description of what the operation does. There''s a lot more: `@ApiImplicitParam`
    for describing parameters, `@Authorization` to provide a name of the authorization
    scheme to be used on this resource/operation, `@License` to provide information
    about the license, and so on. All of those annotations will be picked up by `springfox-swagger2`
    and used to enhance the generated documentation. I highly recommend looking at
    the swagger-annotations JavaDoc; you will be able to document your API in a detailed,
    professional way.'
  prefs: []
  type: TYPE_NORMAL
- en: I guess our little service is ready; it's time to bring it to life.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because we have defined the Spring Boot plugin in our `pom.xml` build file,
    we can now start the application using Maven. All you need to have is Maven present
    on the system path, but you probably have this already as a Java developer. To
    run the application, execute the following from the command shell (terminal on
    MacOS or `cmd.exe` on Windows):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After a while, the Spring splash log will show up in the console and your microservice
    will be ready to accept `HTTP` requests. Soon, in [Chapter 5](text00084.html)
    , *Creating Images with Java Applications* , our goal will be to see the same
    coming from the Docker container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to, you can also run the application straight from the IDE, be it
    IntelliJ IDEA, Eclipse, or Netbeans. Our `BookstoreApplication` class has a `main()`
    method; you will just need to create a runtime configuration in your IDE and run
    it. This is different from the JEE7 JAX-RS service. It that case, you would need
    to deploy the service in a JEE compliant application server to be able to run
    it. Having the `main()` method defined is very convenient when debugging your
    service. Just start a debugging session with `BookstoreApplication` as the entry
    point. There is no need to create a remote debugging session. Having our service
    running, it's time to make some calls to its exposed endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Making calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making a call to the operation exposed from the service can be done using any
    tool or library that can execute the `HTTP` requests. The first obvious choice
    would be just a web browser. But a web browser is convenient only for executing
    `GET` requests (as for getting a list of books from our bookstore service). If
    you need to execute other methods such as `POST` or `PUT` or provide additional
    request parameters, header values, and so on, you will need to use some alternatives.
    The first choice could be cURL, a command-line tool for transferring data using
    various protocols. Let's look at other options we have.
  prefs: []
  type: TYPE_NORMAL
- en: Spring RestTemplate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you need to call a service from another service, you will need a `HTTP`
    client. Spring provides the very useful `RestTemplate` class. It gives you a synchronous
    client-side `HTTP` access, simplifies communication with HTTP servers, and enforces
    RESTful principles. It handles HTTP connections, leaving application code to provide
    URLs (with possible template variables) and extracts results. By default, `RestTemplate`
    relies on standard JDK facilities to establish HTTP connections. You can switch
    to a different HTTP library of your choice, such as Apache `HttpComponents` ,
    `Netty` , and `OkHttp` through its `setRequestFactory()` method. Calling the `REST`
    resource to get a book with `ID = 1` can be as simple as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this is just a simplified client example, to present you the idea.
    You can use `RestTemplate` to create more sophisticated client calls to the REST
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: HTTPie
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A great command-line alternative to cURL is HTTPie, available at [https://httpie.org](https://httpie.org)
    . It''s a command-line `HTTP` client. Luckily, the `*ie*` in the name doesn''t
    come from Internet Explorer. If you prefer to work from the shell or command line,
    `HTTPie` is a just a single command which adds the following features to cUrl:
    sensible defaults, expressive and intuitive command syntax, colorized and formatted
    terminal output, built-in JSON support, persistent sessions, forms and file uploads,
    proxies and authentication support, and support for arbitrary request data and
    headers. It''s written in Python and works on Linux, macOSX, and Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: Postman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Postman is a tool of choice for many developers. It''s available as the Chrome
    plugin or a standalone utility at [https://www.getpostman.com](https://www.getpostman.com)
    . Postman is very convenient for use. It''s a powerful GUI platform to make your
    API development faster and easier, from building API requests through testing,
    documentation, and sharing. You can save your `HTTP` requests for later use and
    organize them in collections. If you work in multiple environments, for example
    your localhost, when developing the service and a production environment later
    on, Postman introduces the concept of environments. Environments give you the
    ability to customize your requests using variables. This way you can easily switch
    between different setups without changing your requests. Each environment is represented
    as a set of key-value pairs. This makes working with multiple environments easy.
    It also has a very handy UI for editing your `HTTP` requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can define request headers, cookies, and body. If your service supports
    authentication, Postman contains a lot of authentication helpers: it can be basic
    Auth, digest Auth, and OAuth. The response body can be viewed in one of three
    views: pretty, raw, and preview. The pretty mode formats JSON or XML responses
    so that they are easier to look at and headers are displayed as key/value pairs
    in the header tab. It''s a really powerful and pleasant to use tool. If you work
    on macOS, there''s something even better.'
  prefs: []
  type: TYPE_NORMAL
- en: Paw for Mac
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Paw** is a full-featured `HTTP` client that lets you test the APIs you build
    or consume. It has a beautiful native OS X interface to compose requests, inspect
    server responses, and generate client code out of the box. As you can see in the
    following screenshot, it also contains a powerful editor to compose your requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](Image00065.jpg)**'
  prefs: []
  type: TYPE_NORMAL
- en: It also supports a lot of authentication schemas including OAuth 1 and 2, Basic
    Auth, Digest Auth, Hawk, AWS Signature Version 4, and Amazon S3\. Similar to Postman,
    Paw also allows you to organize your requests in folders. You can also define
    and switch different environments quickly. The interesting feature is that Paw
    can generate client code to execute your requests. It can generate code for cURL,
    HTTPie, Objective-C, Python, JavaScript, Ruby, PHP, Java, Go, and many others.
    And guess what? Paw can also import the Swagger documentation we have been talking
    about. You can use this feature to test the service you were given the documentation
    for.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to quickly start with your new service, there are a couple of tools
    that may come in handy. One of them is **Initializr** .
  prefs: []
  type: TYPE_NORMAL
- en: Spring Initializr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Initializr is a web-based tool available at [https://start.spring.io](https://start.spring.io)
    . It''s a quick start generator for Spring projects. Spring Initializr can be
    used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: From the web browser at [https://start.spring.io](https://start.spring.io)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In your IDE (IntelliJ IDEA Ultimate or NetBeans, using plugins)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the command line with the Spring Boot CLI or simply with cURL or HTTPie
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the web application is very convenient; all you need to do is provide
    details about your application Maven archetype, such as group, artifact name,
    description, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Dependencies section, you can enter the keywords of the features you
    would like to have included, such as JPA, web, and so on. You can also switch
    the UI to an advanced view, to have all the features listed and ready to be selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the output, Spring Initializr will create a ZIP archive with the base Maven
    project you want to start with. The project created by Spring Initializr is a
    Maven project and follows the standard `Maven` directory layout. This really saves
    a lot of time when creating new Spring projects. You no longer need to search
    for specific Maven archetypes and look for their versions. Initializr will generate
    the `pom.xml` for you, automatically. The presence of the dependencies in the
    `pom.xml` is important because Spring Boot will make decisions on what to create
    automatically when certain things are found on the classpath. For example, if
    the dependency for the H2 database is present and exists on the classpath when
    the application is run, Spring Boot will automatically create a data connection
    and an embedded H2 database.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, developing Java microservices is not as tricky as it may sound.
    You can choose between JEE7 JAX-RS or Spring Boot, wire some classes, and a basic
    service is ready. You are not limited to using Spring MVC for creating your REST
    endpoints. If you are more familiar with the Java EE JAX-RS specification, you
    can easily integrate JAX-RS into Spring applications, especially Spring Boot applications.
    You can then take what is best for you from both.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in the real world you would probably want to include some more advanced
    features such as authentication and security. Having Spring Initializr available
    can give you a serious speed boost when developing your own service. In [Chapter
    5](text00084.html) , *Creating Images with Java Applications* , we are going to
    package our bookstore service into a Docker image and run it using Docker Engine.
  prefs: []
  type: TYPE_NORMAL
