- en: Chapter 3. Building Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we explained the image and container handling, and
    its housekeeping techniques and tips to you in detail. In addition to that, we
    also have explained the standard procedure for installing any software package
    on a Docker container and then converting the container into an image for future
    usage and maneuvering. This chapter is quite different from the earlier ones,
    and it is in this chapter to clearly describe how the Docker images are built
    using `Dockerfile`, which is the standard way to bring forth the highly usable
    Docker images. Leveraging `Dockerfile` is the most competent way to build powerful
    images for the software development community.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker's integrated image building system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick overview of the Dockerfile's syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dockerfile` build instructions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Docker stores images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker's integrated image building system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Docker images are the fundamental building blocks of containers. These images
    could be very basic operating environments, such as `busybox` or `ubuntu,` as
    we found while experimenting with Docker in the previous chapters. Alternatively,
    the images could craft advanced application stacks for the enterprise and cloud
    IT environments. As we discussed in the previous chapter, we could craft an image
    manually by launching a container from a base image, install all the required
    applications, make the necessary configuration file changes, and then commit the
    container as an image.
  prefs: []
  type: TYPE_NORMAL
- en: As a better alternative, we could resort to the automated approach of crafting
    the images by using `Dockerfile`. `Dockerfile` is a text-based build script that
    contains special instructions in a sequence for building the right and relevant
    images from the base images. The sequential instructions inside the `Dockerfile`
    can include the base image selection, installing the required application, adding
    the configuration and the data files, and automatically running the services as
    well as exposing those services to the external world. Thus the Dockerfile-based
    automated build system has simplified the image-building process. It also offers
    a great deal of flexibility in the way in which the build instructions are organized
    and in the way in which they visualize the complete build process.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker engine tightly integrates this build process with the help of the
    `docker build` subcommand. In the client-server paradigm of Docker, the Docker
    server (or daemon) is responsible for the complete build process and the Docker
    command line interface is responsible for transferring the build context, including
    transferring `Dockerfile` to the daemon.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to have a sneak peak into the `Dockerfile` integrated build system
    in this section, we will introduce you to a basic `Dockerfile`. Then we will explain
    the steps for converting that `Dockerfile` into an image, and then launching a
    container from that image. Our `Dockerfile` is made up of two instructions, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following, we will discuss the two instructions mentioned earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: The first instruction is for choosing the base image selection. In this example,
    we will select the `busybox:latest` image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second instruction is for carrying out the command `CMD`, which instructs
    the container to `echo Hello World!!`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s proceed towards generating a Docker image by using the preceding
    `Dockerfile` by calling `docker build` along with the path of `Dockerfile`. In
    our example, we will invoke the `docker build` subcommand from the directory where
    we have stored `Dockerfile,` and the path will be specified by the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After issuing the preceding command, the `build` process will begin by sending
    `build context` to the `daemon` and then display the text shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The build process would continue and, after completing itself, it will display
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the image was built by the `IMAGE ID 0a2abe57c325`.
    Let''s use this image to launch a container by using the `docker run` subcommand
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Cool, isn't it? With very little effort, we have been able to craft an image
    with `busybox` as the base image, and we have been able to extend that image to
    produce `Hello World!!`. This is a simple application, but the enterprise-scale
    images can also be realized by using the same technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the image details by using the `docker images` subcommand,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you may be surprised to see that the `IMAGE` (`REPOSITORY`) and `TAG`
    name have been listed as `<none>`. This is because we did not specify any image
    or any `TAG` name when we built this image. You could specify an `IMAGE` name
    and optionally a `TAG` name by using the `docker tag` subcommand, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The alternative approach is to build the image with an image name during the
    `build` time by using the `-t` option for the `docker build` subcommand, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Since there is no change in the instructions in `Dockerfile`, the Docker engine
    will efficiently reuse the old image that has `ID 0a2abe57c325` and update the
    image name to `busyboxplus`. By default, the build system would apply `latest`
    as the `TAG` name. This behavior can be modified by specifying the `TAG` name
    after the `IMAGE` name by having a `:` separator placed between them. That is,
    `<image name>:<tag name>` is the correct syntax for modifying behaviors, where
    `<image name>` is the name of the image and `<tag name>` is the name of the tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, let''s look at the image details by using the `docker images` subcommand,
    and you will notice that the image (Repository) name is `busyboxplus` and the
    tag name is `latest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Building images with an image name is always recommended as the best practice.
  prefs: []
  type: TYPE_NORMAL
- en: Having experienced the magic of `Dockerfile`, in the subsequent sections we
    will introduce you to the syntax or the format of `Dockerfile` and explain a dozen
    `Dockerfile` instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The latest Docker release (1.5) has incorporated an additional option (`-f`)
    in the `docker build` subcommand, and it is used for specifying a `Dockerfile`
    with an alternative name.
  prefs: []
  type: TYPE_NORMAL
- en: A quick overview of the Dockerfile's syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will explain the syntax or the format of `Dockerfile`.
    A `Dockerfile` is made up of instructions, comments, and empty lines, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The instruction line of `Dockerfile` is made up of two components, where the
    instruction line begins with the instruction itself, which is followed by the
    arguments for the instruction. The instruction could be written in any case, in
    other words, it is case-insensitive. However, the standard practice or convention
    is to use *uppercase* in order to differentiate it from the arguments. Let''s
    take another look at the content of `Dockerfile` in our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, `FROM` is an instruction which has taken `busybox:latest` as an argument,
    and `CMD` is an instruction which has taken `echo Hello World!!` as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The comment line in `Dockerfile` must begin with the `#` symbol. The `#` symbol
    after an instruction is considered as an argument. If the `#` symbol is preceded
    by a whitespace, then the `docker build` system would consider that as an unknown
    instruction and skip the line. Now, let''s better understand these mentioned cases
    with the help of an example to get a better understanding of the comment line:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A valid `Dockerfile` comment line always begins with a `#` symbol as the first
    character of the line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `#` symbol can be a part of an argument:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `#` symbol is preceded by a whitespace, then it is considered as an
    unknown instruction by the build system:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `docker build` system ignores any empty line in the `Dockerfile`, and so
    the author of `Dockerfile` is encouraged to add comments and empty lines to substantially
    improve the readability of `Dockerfile`.
  prefs: []
  type: TYPE_NORMAL
- en: The Dockerfile build instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have looked at the integrated build system, the `Dockerfile` syntax
    and a sample life cycle, including how a sample `Dockerfile` is leveraged to generate
    an image and how a container gets spun off from that image. In this section, we
    will introduce the `Dockerfile` instructions, their syntax, and a few fitting
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: The FROM instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `FROM` instruction is the most important one and it is the first valid instruction
    of a `Dockerfile`. It sets the base image for the build process. The subsequent
    instructions would use this base image and build on top of it. The `docker build`
    system lets you flexibly use the images built by anyone. You can also extend them
    by adding more precise and practical features to them. By default, the `docker
    build` system looks in the Docker host for the images. However, if the image is
    not found in the Docker host, then the `docker build` system will pull the image
    from the publicly available Docker Hub Registry. The `docker build` system will
    return an error if it can not find the specified image in the Docker host and
    the Docker Hub Registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FROM` instruction has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code statement, note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<image>`: This is the name of the image which will be used as the base image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<tag>`: This is the optional tag qualifier for that image. If any tag qualifier
    has not been specified, then the tag `latest` is assumed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of the `FROM` instruction with the image name `centos`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example of the `FROM` instruction with the image name `ubuntu`
    and the tag qualifier `14.04`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Docker allows multiple `FROM` instructions in a single `Dockerfile` in order
    to create multiple images. The Docker build system will pull all the images specified
    in the `FROM` instruction. Docker does not provide any mechanism for naming the
    individual images that are generated with the help of multiple `FROM` instructions.
    We strongly discourage using multiple `FROM` instructions in a single `Dockerfile`,
    as damaging conflicts could arise.
  prefs: []
  type: TYPE_NORMAL
- en: The MAINTAINER instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MAINTAINER` instruction is an informational instruction of a `Dockerfile`.
    This instruction capability enables the authors to set the details in an image.
    Docker does not place any restrictions on placing the `MAINTAINER` instruction
    in `Dockerfile`. However, it is strongly recommended that you should place it
    after the `FROM` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the syntax of the `MAINTAINER` instruction, where `<author''s
    detail>` can be in any text. However, it is strongly recommended that you use
    the image author''s name and the e-mail address, as shown in this code syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of the `MAINTAINER` instruction with the author name and
    the e-mail address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The COPY instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `COPY` instruction enables you to copy the files from the Docker host to
    the filesystem of the new image. The following is the syntax of the `COPY` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code terms bear the explanations shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<src>`: This is the source directory, the file in the build context, or the
    directory from where the `docker build` subcommand was invoked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`...`: This indicates that multiple source files can either be specified directly
    or be specified by wildcards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<dst>`: This is the destination path for the new image into which the source
    file or directory will get copied. If multiple files have been specified, then
    the destination path must be a directory and it must end with a slash `/`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an absolute path for the destination directory or a file is recommended.
    In the absence of an absolute path, the `COPY` instruction will assume that the
    destination path will start from root `/`. The `COPY` instruction is powerful
    enough for creating a new directory and for overwriting the filesystem in the
    newly created image.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will copy the `html` directory from the source
    build context to `/var/www/html`, which is in the image filesystem, by using the
    `COPY` instruction, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example of the multiple files (`httpd.conf` and `magic`) that
    will be copied from the source build context to `/etc/httpd/conf/`, which is in
    the image filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The ADD instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ADD` instruction is similar to the `COPY` instruction. However, in addition
    to the functionality supported by the `COPY` instruction, the `ADD` instruction
    can handle the TAR files and the remote URLs. We can annotate the `ADD` instruction
    as `COPY` on steroids.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the syntax of the `ADD` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The arguments of the `ADD` instruction are very similar to those of the `COPY`
    instruction, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<src>`: This is either the source directory or the file that is in the build
    context or in the directory from where the `docker build` subcommand will be invoked.
    However, the noteworthy difference is that the source can either be a TAR file
    stored in the build context or be a remote URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`...`: This indicates that the multiple source files can either be specified
    directly or be specified by using wildcards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<dst>`: This is the destination path for the new image into which the source
    file or directory will be copied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example for demonstrating the procedure for copying multiple source
    files to the various destination directories in the target image filesystem. In
    this example, we have taken a TAR file (`web-page-config.tar`) in the source build
    context with the `http` daemon configuration file and the files for the web pages
    are stored in the appropriate directory structure, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The next line in the `Dockerfile` content has an `ADD` instruction for copying
    the TAR file (`web-page-config.tar`) to the target image and extracting the TAR
    file from the root directory (`/`) of the target image, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Thus the TAR option of the `ADD` instruction can be used for copying multiple
    files to the target image.
  prefs: []
  type: TYPE_NORMAL
- en: The ENV instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ENV` instruction sets an environment variable in the new image. An environment
    variable is a key-value pair, which can be accessed by any script or application.
    The Linux applications use the environment variables a lot for a starting configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line forms the syntax of the `ENV` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the code terms indicate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<key>`: This is the environment variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<value>`: This is the value that is to be set for the environment variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following lines give two examples for the `ENV` instruction, where in the
    first line `DEBUG_LVL` has been set to `3` and, in the second line, `APACHE_LOG_DIR`
    has been set to `/var/log/apache`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The USER instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `USER` instruction sets the start up user ID or user Name in the new image.
    By default, the containers will be launched with `root` as the user ID or `UID`.
    Essentially, the `USER` instruction will modify the default user ID from `root`
    to the one specified in this instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the `USER` instruction is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `USER` instructions accept either `<UID>` or `<UName>` as its argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<UID>`: This is a numerical user ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<UName>`: This is a valid user Name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example for setting the default user ID at the time of
    startup to `73`. Here `73` is the numerical ID of the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it is recommended that you have a valid user ID to match with the
    `/etc/passwd` file, the user ID can contain any random numerical value. However,
    the user Name must match with a valid user name in the `/etc/passwd` file, otherwise
    the `docker run` subcommand will fail and it will display the following error
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The WORKDIR instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `WORKDIR` instruction changes the current working directory from `/` to
    the path specified by this instruction. The ensuing instructions, such as `RUN`,
    `CMD`, and `ENTRYPOINT` will also work on the directory set by the `WORKDIR` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line gives the appropriate syntax for the `WORKDIR` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, `<dirpath>` is the path for the working directory to set in. The path
    can be either absolute or relative. In case of a relative path, it will be relative
    to the previous path set by the `WORKDIR` instruction. If the specified directory
    is not found in the target image filesystem, then the director will be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line is a clear example of the `WORKDIR` instruction in a `Dockerfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The VOLUME instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `VOLUME` instruction creates a directory in the image filesystem, which
    can later be used for mounting volumes from the Docker host or the other containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `VOLUME` instruction has two types of syntax, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first type is either exec or JSON array (all values must be within double-quotes
    (`"`)):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The second type is shell, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding line, `<mountpoint>` is the mount point that has to be created
    in the new image.
  prefs: []
  type: TYPE_NORMAL
- en: The EXPOSE instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `EXPOSE` instruction opens up a container network port for communicating
    between the container and the external world.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the `EXPOSE` instruction is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the code terms mean the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<port>`: This is the network port that has to be exposed to the outside world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<proto>`: This is an optional field provided for a specific transport protocol,
    such as TCP and UDP. If no transport protocol has been specified, then TCP is
    assumed to be the transport protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `EXPOSE` instruction allows you to specify multiple ports in a single line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of the `EXPOSE` instruction inside a `Dockerfile`
    exposing the port number `7373` as a `UDP` port and the port number `8080` as
    a `TCP` port. As mentioned earlier, if the transport protocol has not been specified,
    then the `TCP` transport is assumed to be the transport protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The RUN instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `RUN` instruction is the real workhorse during the build time, and it can
    run any command. The general recommendation is to execute multiple commands by
    using one `RUN` instruction. This reduces the layers in the resulting Docker image
    because the Docker system inherently creates a layer for each time an instruction
    is called in `Dockerfile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RUN` instruction has two types of syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is the shell type, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `<command>` is the shell command that has to be executed during the
    build time. If this type of syntax is to be used, then the command is always executed
    by using `/bin/sh -c`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second syntax type is either exec or the JSON array, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Within this, the code terms mean the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<exec>`: This is the executable to run during the build time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<arg-1>, ..., <arg-n>`: These are the variables (zero or more) number of the
    arguments for the executable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike the first type of syntax, this type does not invoke `/bin/sh -c`. Therefore,
    the types of shell processing, such as the variable substitution (`$USER`) and
    the wild card substitution (`*`, `?`), do not happen in this type. If shell processing
    is critical for you, then you are encouraged to use the shell type. However, if
    you still prefer the exec (JSON array type) type, then use your preferred shell
    as the executable and supply the command as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `RUN ["bash", "-c", "rm", "-rf", "/tmp/abc"]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at a few examples of the `RUN` instruction. In the first example,
    we will use the `RUN` instruction for adding a greeting line to the `.bashrc`
    file in the target image filesystem, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The second example is a `Dockerfile,` which has the instructions for crafting
    an `Apache2` application image on top of the `Ubuntu 14.04` base image. The ensuing
    steps will explain the `Dockerfile` instructions line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to build an image by using `ubuntu:14.04` as the base image using
    the `FROM` instruction, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the author''s details by using the `MAINTAINER` instruction, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'By using one `RUN` instruction, we will synchronize the `apt` repository source
    list, install the `apache2` package, and then clean the retrieved files, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The CMD instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `CMD` instruction can run any command (or application), which is similar
    to the `RUN` instruction. However, the major difference between those two is the
    time of execution. The command supplied through the `RUN` instruction is executed
    during the build time, whereas the command specified through the `CMD` instruction
    is executed when the container is launched from the newly created image. Therefore,
    the `CMD` instruction provides a default execution for this container. However,
    it can be overridden by the `docker run` subcommand arguments. When the application
    terminates, the container will also terminate along with the application and vice
    versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CMD` instruction has three types of syntax, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first syntax type is the shell type, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Within this, the `<command>` is the shell command, which has to be executed
    during the launch of the container. If this type of syntax is used, then the command
    is always executed by using `/bin/sh -c`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second type of syntax is exec or the JSON array, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Within this, the code terms mean the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<exec>`: This is the executable, which is to be run during the container launch
    time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<arg-1>, ..., <arg-n>`: These are the variable (zero or more) numbers of the
    arguments for the executable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The third type of syntax is also exec or the JSON array, which is similar to
    the previous type. However, this type is used for setting the default parameters
    to the `ENTRYPOINT` instruction, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Within this, the code terms mean the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<arg-1>, ..., <arg-n>`: These are the variable (zero or more) numbers of the
    arguments for the `ENTRYPOINT` instruction, which will be explained in the next
    section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntactically, you can add more than one `CMD` instruction in `Dockerfile`.
    However, the build system would ignore all the `CMD` instructions except for the
    last one. In other words, in the case of multiple `CMD` instructions, only the
    last `CMD` instruction would be effective.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, in this example, let''s craft an image by using `Dockerfile` with the
    `CMD` instruction for providing a default execution, and then launching a container
    by using the crafted image. The following is `Dockerfile` with a `CMD` instruction
    to `echo` a text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s build a Docker image by using the `docker build` subcommand and
    `cmd-demo` as the image name. The `docker build` system will read the instruction
    from the `Dockerfile`, which is stored in the current directory (`.`), and craft
    the image accordingly as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Having built the image, we can launch the container by using the `docker run`
    subcommand, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Cool, isn''t it? We have given a default execution for our container and our
    container has faithfully echoed `Dockerfile CMD demo`. However, this default execution
    can be easily overridden by passing another command as an argument to the `docker
    run` subcommand, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The ENTRYPOINT instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ENTRYPOINT` instruction will help in crafting an image for running an application
    (entry point) during the complete life cycle of the container, which would have
    been spun out of the image. When the entry point application is terminated, the
    container would also be terminated along with the application and vice versa.
    Therefore, the `ENTRYPOINT` instruction would make the container function like
    an executable. Functionally, `ENTRYPOINT` is akin to the `CMD` instruction, but
    the major difference between the two is that the entry point application is launched
    by using the `ENTRYPOINT` instruction, which cannot be overridden by using the
    `docker run` subcommand arguments. However, these `docker run` subcommand arguments
    will be passed as additional arguments to the entry point application. Having
    said this, Docker provides a mechanism for overriding the entry point application
    through the `--entrypoint` option in the `docker run` subcommand. The `--entrypoint`
    option can accept only word as its argument, and so it has limited functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntactically, the `ENTRYPOINT` instruction is very similar to the `RUN` and
    `CMD` instructions, and it has two types of syntax, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first type of syntax is the shell type, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, `<command>` is the shell command, which is executed during the launch
    of the container. If this type of syntax is used, then the command is always executed
    by using `/bin/sh -c`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second type of syntax is exec or the JSON array, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Within this, the code terms mean the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<exec>`: This is the executable, which has to be run during the container
    launch time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<arg-1>, ..., <arg-n>`: These are the variable (zero or more) numbers of arguments
    for the executable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntactically, you can have more than one `ENTRYPOINT` instruction in a `Dockerfile`.
    However, the build system will ignore all the `ENTRYPOINT` instructions except
    the last one. In other words, in the case of multiple `ENTRYPOINT` instructions,
    only the last `ENTRYPOINT` instruction will be effective.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to gain a better understanding of the `ENTRYPOINT` instruction, let''s
    craft an image by using `Dockerfile` with the `ENTRYPOINT` instruction, and then
    launching a container by using the crafted image. The following is `Dockerfile`
    with an `ENTRYPOINT` instruction to echo a text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s build a Docker image by using the `docker build` as the subcommand
    and `entrypoint-demo` as the image name. The `docker build` system would read
    the instruction from `Dockerfile` stored in the current directory (`.`) and craft
    the image, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Having built the image, we can launch the container by using the `docker run`
    subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the container will run like an executable by echoing the `Dockerfile
    ENTRYPOINT demo` string and then it will exit immediately. If we pass any additional
    arguments to the `docker run` subcommand, then the additional argument would be
    passed to the entry point command. The following is a demonstration of launching
    the same image with the additional arguments given to the `docker run` subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see an example where we override the build time entry point application
    with the `--entrypoint` option and then launch a shell (`/bin/sh`) in the `docker
    run` subcommand, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The ONBUILD instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ONBUILD` instruction registers a build instruction to an image and this
    is triggered when another image is built by using this image as its base image.
    Any build instruction can be registered as a trigger and those instructions will
    be triggered immediately after the `FROM` instruction in the downstream `Dockerfile`.
    Therefore, the `ONBUILD` instruction can be used to defer the execution of the
    build instruction from the base image to the target image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the `ONBUILD` instruction is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Within this, `<INSTRUCTION>` is another `Dockerfile` build instruction, which
    will be triggered later. The `ONBUILD` instruction does not allow the chaining
    of another `ONBUILD` instruction. In addition, it does not allow the `FROM` and
    `MAINTAINER` instructions as `ONBUILD` triggers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the `ONBUILD` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The .dockerignore file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the *Docker''s integrated image building system* section, we learnt that
    the `docker build` process will send the complete build context to the daemon.
    In a practical environment, the `docker build` context will contain many other
    working files and directories, which would never be built into the image. Nevertheless,
    the `docker build` system would still send those files to the daemon. So, you
    may be wondering how you can optimize the build process by not sending these working
    files to the daemon. Well, the folks behind Docker too have thought about that
    and given a very simple solution: using a `.dockerignore` file.'
  prefs: []
  type: TYPE_NORMAL
- en: The`.dockerignore` is a newline-separated TEXT file, wherein you can provide
    the files and the directories which are to be excluded from the build process.
    The exclusion list in the file can have both the fully specified file or directory
    name and the wild cards.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet is a sample `.dockerignore` file through which the build
    system has been instructed to exclude the `.git` directory and all the files that
    have the`.tmp` extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: A brief overview of the Docker image management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in the previous chapter and this chapter, there are many ways
    of getting a handle on a Docker image. You could download a fully set up application
    stack from the public repository by using the `docker pull` subcommand. Otherwise
    you could craft your own application stack either manually by using the `docker
    commit` subcommand or automatically by using `Dockerfile` and the `docker build`
    subcommand combination.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker images are being positioned as the key building-blocks of the containerized
    applications that, in turn, enable the realization of distributed applications,
    which will be deployed on the cloud servers. The Docker images are built in layers,
    that is, the images can be built on top of other images. The original image is
    called the parent image and the one that is generated is called the child image.
    The base image is a bundle, which comprises an application's common dependencies.
    Each change that is made to the original image is stored as a separate layer.
    Each time you commit to a Docker image, you will create a new layer on the Docker
    image, and each change that is made to the original image will be stored as a
    separate layer. As the reusability of the layers is facilitated, making new Docker
    images becomes simple and fast. You can create a new Docker image by changing
    a single line in `Dockerfile` and you do not need to rebuild the whole stack.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learnt about the layers in the Docker image, you may be wondering
    how one could visualize these layers in a Docker image. Well, the `docker history`
    subcommand is an excellent and handy tool for visualizing the image layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a practical example to better understand the layering in the Docker
    images. For this purpose, let''s follow these three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have `Dockerfile` with the instructions for automatically building
    the Apache2 application image on top of the Ubuntu 14.04 base image. The `RUN`
    section of the previously crafted and used `Dockerfile` of this chapter will be
    reused in this section, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now craft an image from the preceding `Dockerfile` by using the `docker build`
    subcommand, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s visualize the layers in the Docker image by using the `docker
    history` subcommand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce a detailed report on each layer of the `apache2` Docker image,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `apache2` image is made up of ten image layers. The top two layers,
    the layers with image IDs `aa83b67feeba` and `c7877665c770`, are the result of
    `RUN` and `MAINTAINER` instructions in our `Dockerfile`. The remaining eight layers
    of the image will be pulled from the repository by the `FROM` instruction in our
    `Dockerfile`.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for writing Dockerfiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is an undisputable truth that a set of best practices always plays an indispensable
    role in elevating any new technology. There is a well-written document listing
    all the best practices for crafting a `Dockerfile`. We found it incredible, and
    so, we wanted to share it for your benefit. You can find it at [https://docs.docker.com/articles/dockerfile_best-practices/](https://docs.docker.com/articles/dockerfile_best-practices/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building the Docker images is a critical aspect of the Docker technology for
    streamlining the arduous task of containerization. As indicated before, the Docker
    initiative has turned out to be disruptive and transformative for the containerization
    paradigm. Dockerfile is the most prominent way for producing the competent Docker
    images, which can be used meticulously. We have illustrated all the commands,
    their syntax, and their usage techniques in order to empower you with all the
    easy-to-grasp details, and this will simplify the image-building process for you.
    We have supplied a bevy of examples in order to substantiate the inner meaning
    of each command. In the next chapter, we are going to discuss the Docker Hub,
    which is a well-designated store for storing and sharing the Docker images, and
    we will also discuss its profound contribution to the penetration of the containerization
    concept into the IT enterprises.
  prefs: []
  type: TYPE_NORMAL
