- en: Chapter 7. Securing Docker with Third-party Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, let''s take a look at securing Docker using third-party tools.
    These would be tools that are not part of the Docker ecosystem, which you can
    use to help secure your systems. We will be taking a look at the following three
    items:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Traffic Authorization**: This allows inbound and outbound traffic to be verified
    by the token broker in order to ensure that traffic between services is secure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Summon**: Summon is a command-line tool that reads a file in the `secrets.yml`
    format and injects secrets as environment variables into any process. Once the
    process exits, the secrets are gone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sVirt and SELinux**: sVirt is a community project that integrates **Mandatory
    Access Control** (**MAC**) security and Linux-based virtualization (**Kernel-base
    Virtual Machine** (**KVM**), lguest, and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will then add bonus material with regards to some extra third-party tools
    that are quite useful and powerful and deserve to get some recognition as useful
    third-party tools. These tools include **dockersh**, **DockerUI**, **Shipyard**,
    and **Logspout**. Without further ado, let's jump in and get started on our path
    to the most secure environments that we can obtain.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what third-party tools will we focus on? Well from the preceding introduction,
    you learned that we will be looking at three tools in particular. These would
    be Traffic Authorization, Summon, and sVirt with SELinux. All the three tools
    help in different aspects and can be used to perform different things. We will
    learn the differences between them and help you to determine which ones to implement.
    You can decide whether you want to implement them all, only one or two of them,
    or maybe you feel that none of these would pertain to your current environment.
    However, it is good to know what is out there, in case, your needs change and
    the overall architecture of your Docker environments change over time.
  prefs: []
  type: TYPE_NORMAL
- en: Traffic Authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Traffic Authorization can be used to regulate HTTP/HTTPS traffic between services.
    This involves a forwarder, gatekeeper, and token broker. This allows inbound and
    outbound traffic to be verified by the token broker in order to ensure that traffic
    between services is secure. Each container runs a gatekeeper that is used to intercept
    all the HTTP/HTTPS inbound traffic and verifies its authenticity from a token
    that is found in the authorization header. The forwarder also runs on each container,
    and like the gatekeeper, this also intercepts traffic; however, instead of intercepting
    inbound traffic, it intercepts outbound traffic and places the token on the authorization
    header. These tokens are issues from the token broker. These tokens can also be
    cached to save time and minimize the impact of latency. Let''s break it down into
    a series of steps, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Service A initiates a request to Service B.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The forwarder on Service A will authenticate itself with the token broker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The token broker will issue a token that Service A will apply to the authorization
    header and forward the request to Service B.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Service B's gatekeeper will intercept the request and verify the authorization
    header against the token broker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the authorization header has been verified, it is then forwarded to Service
    B.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, this applies extra authorizations on both inbound and outbound
    requests. As we will see in the next section, you can also use Summon along with
    Traffic Authorization to use shared secrets that are available once they are used,
    but go away once the application has completed its actions.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about Traffic Authorization and Docker, visit [https://blog.conjur.net/securing-docker-with-secrets-and-dynamic-traffic-authorization](https://blog.conjur.net/securing-docker-with-secrets-and-dynamic-traffic-authorization).
  prefs: []
  type: TYPE_NORMAL
- en: Summon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Summon is a command-line tool and is used to help pass along secrets or things
    you don't want exposed, such as passwords or environmental variables and then
    these secrets are disposed upon exiting the process. This is great as once the
    secret is used and the process exits, the secret no longer exists. This means
    the secret isn't lingering around until it is either removed manually or discovered
    by an attacker for malicious use. Let's take a look at how to utilize Summon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summon typically uses three files: a `secrets.yml` file, script used to perform
    the action or task, and Dockerfile. As you have learned previously, or based on
    your current Docker experience, the Dockerfile is the basis of what helps in building
    your containers and has instructions on how to set up the container, what to install,
    what to configure, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One great example have for the usage of Summon is to be able to deploy your
    AWS credentials to a container. For utilizing AWS CLI, you need a few key pieces
    of information that should be kept secret. These two pieces of information are
    your **AWS Access Key ID** and **AWS Secret Access Key**. With these two pieces
    of information, you can manipulate someone''s AWS account and perform actions
    within this account. Let''s take a look at the contents of one of these files,
    the `secrets.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `-D` option is used to substitute values while `$env` is an example of a
    substitution variable, therefore, the options can be interchanged.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding content, we can see that we want to pass along these two values
    into our application. With this file, the script file you want to deploy, and
    the Dockerfile, you are now ready to build your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We simply utilize the `docker build` command inside the folder that has our
    three files in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to install Summon, which can be done with a simple `curl` command,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have Summon installed, we need to run the container with Summon
    and pass along our secret values (note that this will only work on OS X):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to run Docker with Summon in order to pass along these credentials
    to the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also view the values that you have passed along by using the following
    `cat` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `@SUMMONENVFILE` is a memory-mapped file that contains the values from the
    `secrets.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: For more information and to see other options to utilize Summon, visit [https://conjurinc.github.io/summon/#examples](https://conjurinc.github.io/summon/#examples).
  prefs: []
  type: TYPE_NORMAL
- en: sVirt and SELinux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: sVirt is part of the SELinux implementation, but it is typically turned off
    as most view it as a roadblock. The only roadblock should be learning sVirt and
    SELinux.
  prefs: []
  type: TYPE_NORMAL
- en: sVirt is an open source community project that implements MAC security for Linux-based
    virtualization. A reason you would want to implement sVirt is to improve the security
    as well as harden the system against any bugs that might exist in the hypervisor.
    This will help in eliminating any attack vectors that might be aimed towards the
    virtual machine or host.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that all containers on a Docker host share the usage of the Linux kernel
    that is running on the Docker host. If there is an exploit to this Linux kernel
    on the host, then all containers running on this Docker host have the potential
    to be easily compromised. If you implement sVirt and a container is compromised,
    there is no way for the compromise to reach your Docker host and then out to other
    Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'sVirt utilizes labels in the same way as SELinux. The following table is a
    list of these labels and their descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | SELinux Context | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Virtual machine processes | `system_u:system_r:svirt_t:MCS1` | `MCS1` is
    a randomly selected MCS field. Currently, approximately 500,000 labels are supported.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Virtual machine image | `system_u:object_r:svirt_image_t:MCS1` | Only processes
    labeled `svirt_t` with the same MCS fields are able to read/write these image
    files and devices. |'
  prefs: []
  type: TYPE_TB
- en: '| Virtual machine shared read/write content | `system_u:object_r:svirt_image_t:s0`
    | All processes labeled `svirt_t` are allowed to write to the `svirt_image_t:s0`
    files and devices. |'
  prefs: []
  type: TYPE_TB
- en: '| Virtual machine image | `system_u:object_r:virt_content_t:s0` | This is the
    system default label used when an image exits. No `svirt_t` virtual processes
    are allowed to read files/devices with this label. |'
  prefs: []
  type: TYPE_TB
- en: Other third-party tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some other third-party tools that do deserve a mention in this chapter
    and are worth exploring to see the value that they can add for you. It seems that
    these days, a lot of focus is on GUI applications to help with securing applications
    and infrastructures. The following utilities will give you a few options that
    could be pertinent to the environment you are running with the Docker tools.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that you should use caution when implementing some of the following items
    as there could be unwanted repercussions. Make sure to use testing environments
    prior to production implementation.
  prefs: []
  type: TYPE_NORMAL
- en: dockersh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The dockersh was designed to be used as a login shell replacement on machines
    that support multiple interactive users. Why is this important? If you remember
    some of the general security warnings that you have when dealing with Docker containers
    on a Docker host, you will know that whoever has access to the Docker host has
    access to all the running containers on this Docker host. With dockersh, you can
    isolate the use on a per-container basis and only allow users access the containers
    that you want them to, while maintaining administrative control over the Docker
    host and keeping the security threshold minimum.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an ideal way to help isolate users on a per-container basis, while
    containers help eliminate the need for SSH by utilizing dockersh, you can remove
    some of these fears about providing everyone that needs container to access, the
    access to the Docker host(s) as well. There is a lot of information required to
    set up and invoke dockersh, therefore, if you are interested, it''s recommended
    to visit the following URL to find more about dockersh, including how to set it
    up and use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/Yelp/dockersh](https://github.com/Yelp/dockersh)'
  prefs: []
  type: TYPE_NORMAL
- en: DockerUI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'DockerUI is a simple way to view what is going on inside your Docker host.
    The installation of DockerUI is very straightforward and is done by running a
    simple `docker run` command in order to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the DockerUI, you simply open a browser and navigate to the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://<docker_host_ip>:9000`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This opens your DockerUI to the world on port `9000`, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![DockerUI](../images/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can get the general high-level view of your Docker host and its ecosystem
    and can do things such as manipulate the containers on the Docker host by restarting,
    stopping, or starting them from a stopped state. DockerUI takes some of the steep
    learning curve of running command-line items and places them into actions that
    you perform in a web browser using point and click.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about DockerUI, visit [https://github.com/crosbymichael/dockerui](https://github.com/crosbymichael/dockerui).
  prefs: []
  type: TYPE_NORMAL
- en: Shipyard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shipyard, like DockerUI, allows you to use a GUI web interface to manage various
    aspects—mainly in your containers—and manipulate them. Shipyard is build on top
    of Docker Swarm so that you get to utilize the feature set of Docker Swarm, where
    you can manage multiple hosts and containers instead of having to just focus on
    one host and its containers at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Shipyard is simple and the following `curl` command re-enters the picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the Shipyard once the set up is completed, you can simply open a
    browser and navigate to the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://<docker_host_ip>:8080`'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see in the following screenshot, we can view all the containers on
    our Docker host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shipyard](../images/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also view all the images that are on our Docker host, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shipyard](../images/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also control our containers, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shipyard](../images/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Shipyard, like DockerUI, allows you to manipulate your Docker hosts and containers,
    by restarting them, stopping them, starting them from a failed state, or deploying
    new containers and having them join the Swarm cluster. Shipyard also allows you
    to view information such as port mapping information that is what port from the
    host maps to the container. This allows you to get a hold of important information
    like that when you need it quickly to address any security related issues. Shipyard
    also has user management where DockerUI lacks such capability.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about Shipyard simply visit the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/shipyard/shipyard](https://github.com/shipyard/shipyard)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://shipyard-project.com](http://shipyard-project.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logspout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Where do you go when there is an issue that needs to be addressed? Most people
    will first look at the logs of that application to see if it is outputting any
    errors. With Logspout, this becomes a much more manageable task with many multiple
    running containers. With Logspout, you can route all the logs for each and every
    container to a location of your choice. Then, you could parse these logs in one
    place. Instead of having to pull the logs from each container and review them
    individually you can instead have Logspout do that work for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Logspout is just as easy to set up as we have seen for other third-party solutions.
    Simply run the following command on each Docker host to start collecting the logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have all the container logs collected in one area, we need to parse
    through these logs, but how do we do it?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here's the `curl` command to the rescue again! Logs get prefixed with the container
    names and colorized in a manner in order to distinguish the logs. You can replace
    the loopback (`127.0.0.1`) address in the `docker run` invocations with the IP
    address of the Docker host so that it's easier to connect to in order to be able
    to get the logs as well as change the port from `8000` to something of your choice.
    There are also different modules that you can utilize to obtain and collect logs.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about Logspout, visit [https://github.com/gliderlabs/logspout](https://github.com/gliderlabs/logspout).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we looked at some third-party tools in order to be able to
    help secure Docker environments. Mainly, we looked at three tools: Traffic Authorization,
    Summon, and sVirt with SELinux. All the three can be utilized in different ways
    to help secure your Docker environments to give you the peace of mind at end of
    the day to run your applications in the Docker containers. We learned what third-party
    tools, beyond those offered by Docker, are out there to help secure your environments
    to keep your application(s) secure when running on Docker.'
  prefs: []
  type: TYPE_NORMAL
- en: We then took a look at some other third-party tools. These are extra tools that
    are worthwhile to some, given what your Docker environment setup looks like. Some
    of these tools include dockersh, DockerUI, Shipyard, and Logsprout. These tools,
    when carefully applied, layer on extra enhancements to help in the overall security
    of your Docker configurations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at keeping up on security. With so much
    going on these days that surrounds the security, it's sometimes tough to know
    where to look for updated information and be able to apply quick fixes.
  prefs: []
  type: TYPE_NORMAL
- en: You will be learning to help enforce the idea of keeping security in the forefront
    of your mind and subscribing to things such as e-mail lists that not only include
    Docker, but also include items that are related to the environments you are running
    with Linux. Other items are keeping up on following what is going on with regards
    to items such as GitHub issues that relate to Docker security, following along
    in the IRC rooms, and watching websites such as the CVE.
  prefs: []
  type: TYPE_NORMAL
