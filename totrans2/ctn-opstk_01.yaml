- en: Working with Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers containers and various topics related to them. In this
    chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The historical context of virtualization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of container runtime tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation of Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker hands-on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The historical context of virtualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditional virtualization appeared on the Linux kernel in the form of hypervisors
    such as Xen and KVM. This allowed users to isolate their runtime environment in
    the form of **virtual machines** (**VMs**). Virtual machines run their own operating
    system kernel. Users attempted to use the resources on host machines as much as
    possible. However, high densities were difficult to achieve with this form of
    virtualization, especially when a deployed application was small in size compared
    to a kernel; most of the host's memory was consumed by multiple copies of kernels
    running on it. Hence, in such high-density workloads, machines were divided using
    technologies such as *chroot jails* which provided imperfect workload isolation
    and carried security implications.
  prefs: []
  type: TYPE_NORMAL
- en: In 2001, an operating system virtualization in the form of Linux vServer was
    introduced as a series of kernel patches.
  prefs: []
  type: TYPE_NORMAL
- en: This led to an early form of container virtualization. In such forms of virtualization,
    the kernel groups and isolates processes belonging to different tenants, each
    sharing the same kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a table that explains the various developments that took place to enable
    operating system virtualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Year and Development** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 1979: chroot | The concept of containers emerged way back in 1979 with UNIX
    chroot. Later, in 1982, this was incorporated into BSD. With chroot, users can
    change the root directory for any running process and its children, separating
    it from the main OS and directory. |'
  prefs: []
  type: TYPE_TB
- en: '| 2000: FreeBSD Jails | FreeBSD Jails was introduced by Derrick T. Woolworth
    at R&D associates in 2000 for FreeBSD. It is an operating system''s system call
    similar to chroot, with additional process sandboxing features for isolating the
    filesystem, users, networking, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| 2001: Linux vServer | Another jail mechanism that can securely partition
    resources on a computer system (filesystem, CPU time, network addresses, and memory).
    |'
  prefs: []
  type: TYPE_TB
- en: '| 2004: Solaris containers | Solaris containers were introduced for x86 and
    SPARC systems, and first released publicly in February 2004\. They are a combination
    of system resource controls and the boundary separations provided by zones. |'
  prefs: []
  type: TYPE_TB
- en: '| 2005: OpenVZ | OvenVZ is similar to Solaris containers and makes use of a
    patched Linux kernel for providing virtualization, isolation, resource management,
    and checkpointing. |'
  prefs: []
  type: TYPE_TB
- en: '| 2006: Process containers | Process containers were implemented at Google
    in 2006 for limiting, accounting, and isolating the resource usage (CPU, memory,
    disk I/O, network, and so on) of a collection of processes. |'
  prefs: []
  type: TYPE_TB
- en: '| 2007: Control groups | Control groups, also known as CGroups, were implemented
    by Google and added to the Linux Kernel in 2007\. CGroups help in the limiting,
    accounting, and isolation of resource usages (memory, CPU, disks, network, and
    so on) for a collection of processes. |'
  prefs: []
  type: TYPE_TB
- en: '| 2008: LXC | LXC stands for Linux containers and was implemented using CGroups
    and Linux namespaces. In comparison to other container technologies, LXC works
    on the vanilla Linux kernel. |'
  prefs: []
  type: TYPE_TB
- en: '| 2011: Warden | Warden was implemented by Cloud Foundry in 2011 using LXC
    at the initial stage; later on, it was replaced with their own implementation.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 2013: LMCTFY | **LMCTFY** stands for **Let Me Contain That For You**. It
    is the open source version of Google''s container stack, which provides Linux
    application containers. |'
  prefs: []
  type: TYPE_TB
- en: '| 2013: Docker | Docker was started in the year of 2016\. Today it is the most
    widely used container management tool. |'
  prefs: []
  type: TYPE_TB
- en: '| 2014: Rocket | Rocket is another container runtime tool from CoreOS. It emerged
    to address security vulnerabilities in early versions of Docker. Rocket is another
    possibility or choice to use instead of Docker, with the most resolved security,
    composability, speed, and production requirements. |'
  prefs: []
  type: TYPE_TB
- en: '| 2016: Windows containers | Microsoft added container support (Windows containers)
    to the Microsoft Windows Server operating system in 2015 for Windows-based applications.
    With the help of this implementation, Docker would be able to run Docker containers
    on Windows natively without having to run a virtual machine to run. |'
  prefs: []
  type: TYPE_TB
- en: Introduction to containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux containers are operating system level virtualization which provides multiple
    isolated environments on a single host. Rather than using dedicated guest OS like
    VMs, they share the host OS kernel and hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Before containers came into the limelight, multitasking and traditional hypervisor-based
    virtualization were used, mainly. Multitasking allows multiple applications to
    run on the same host machine, however, it provides less isolation between different
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional hypervisor-based virtualization allows multiple guest machines to
    run on top of host machines. Each of these guest machines runs their own operating
    system. This approach provides the highest level of isolation as well as the ability
    to run different operating systems simultaneously on the same hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it comes with a number of disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Each operating system takes a while to boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each kernel takes up its own memory and CPU, so the overhead of virtualization
    is large
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The I/O is less efficient as it has to pass through different layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource allocation is not done on a fine-grained basis, for example, memory
    is allocated to a virtual machine at the time of creation, and memory left idle
    by one virtual machine can't be used by others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maintenance load of keeping each kernel up to date is large
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure explains the concept of virtualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Containers provide the best of both words. To provide an isolated and secure
    environment for containers, they use Linux kernel features such as chroot, namespaces,
    CGroups, AppArmor, SELinux profiles, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The secure access to the host machine kernel from the container is ensured by
    Linux security modules.. Boot is faster as there is no kernel or operating system
    to start up. Resource allocation is fine-grained and handled by the host kernel,
    allowing the effective per container quality of service (QoS). The next figure
    explains container virtualization.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are some disadvantages of containers compared to traditional
    hypervisor-based virtualization: guest operating systems are limited to those
    which can use the same kernel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditional hypervisors provide additional isolation that is not available
    in containers, meaning the noisy neighbor problem is more significant in containers
    than it is with a traditional hypervisor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Container components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux containers are typically comprised of five major components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kernel namespaces**: Namespaces are the major building blocks of Linux containers.
    They isolate various types of Linux resources such as the network, processes,
    users, and the filesystem into different groups. This allows different groups
    of processes to have completely independent views of their resources. Other resources
    that can be segregated include the process ID space, the IPC space, and semaphore
    space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Control groups**: Control groups, also known as CGroups, limit and account
    for different types of resource usage such as the CPU, memory, disk I/O, network
    I/O, and so on, across a group of different processes. They help in preventing
    one container from resource starvation or contention caused by another container,
    and thereby maintains QoS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: Security in containers is provided via the following components:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Root capabilities**: This will help in enforcing namespaces in so-called
    privileged containers by reducing the power of root, in some cases to no power
    at all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Discretionary Access Control (DAC)**: It mediates access to resources based
    on user-applied policies so that individual containers can''t interfere with each
    other and can be run by non-root users securely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mandatory Access Controls (MAC)**: Mandatory Access Controls (MAC), such
    as AppArmor and SELinux, are not required for creating containers, but are often
    a key element to their security. MAC ensures that neither the container code itself
    nor the code running in the containers has a greater degree of access than the
    process itself requires. This way, it minimizes the privileges granted to rogue
    or compromised processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Toolsets**: Above the host kernel lies the user-space toolsets such as LXD,
    Docker, and other libraries, which help in managing containers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../images/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Types of containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The types of containers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Machine containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Machine containers are virtual environments that share the kernel of the host
    operating system but provide user space isolation. They look far more similar
    to virtual machines. They have their own init process, and may run a limited number
    of daemons. Programs can be installed, configured, and run just as they would
    be on any guest operating system. Similar to a virtual machine, anything running
    inside a container can only see resources that have been assigned to that container.
    Machine containers are useful when the use case is to run a fleet of identical
    or different flavors of distros.
  prefs: []
  type: TYPE_NORMAL
- en: Machine containers having their own operating system does not mean that they
    are running a full-blown copy of their own kernel. Rather, they run a few lightweight
    daemons and have a number of necessary files to provide a separate OS within another
    OS.
  prefs: []
  type: TYPE_NORMAL
- en: Container technologies such as LXC, OpenVZ, Linux vServer, BSD Jails, and Solaris
    zones are all suitable for creating machine containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the machine container concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Application containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While machine containers are designed to run multiple processes and applications,
    application containers are designed to package and run a single application. They
    are designed to be very small. They need not contain a shell or `init` process.
    The disk space required for an application container is very small. Container
    technologies such as Docker and Rocket are examples of application containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure elaborates on application containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](../images/00009.jpeg)**'
  prefs: []
  type: TYPE_NORMAL
- en: Types of container runtime tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multiple solutions are available today for managing containers. This section
    discusses alternative types of containers.
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Docker** is the world''s leading container platform software. It has been
    available since 2013\. Docker is a container runtime tool designed to make it
    easier to create, deploy, and run applications by using containers. Docker has
    drastically reduced the complexity of managing applications by containerizing
    them. It allows applications to use the same Linux kernel as the host OS, unlike
    VMs, which create a whole new OS with dedicated hardware. Docker containers can
    run both on Linux and Windows workloads. Docker containers have enabled huge efficiencies
    in the development of software, but require runtime tools such as Swarm or Kubernetes.'
  prefs: []
  type: TYPE_NORMAL
- en: Rocket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Rocket** is another container runtime tool from CoreOS. It emerged to address
    security vulnerabilities in early versions of Docker. Rocket is another possibility
    or choice to Docker, with the most resolved security, composability, speed, and
    production requirements. Rocket has built things differently to Docker in many
    aspects. The main difference is that Docker runs a central daemon with root privileges
    and spins off a new container as its sub process, whereas Rocket never spins a
    container with root privileges. However, Docker always recommends running containers
    within SELinux or AppArmor. Since then, Docker has come up with many solutions
    to tackle the flaws.'
  prefs: []
  type: TYPE_NORMAL
- en: LXD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**LXD** is a container hypervisor for managing LXC by Ubuntu. LXD is a daemon
    which provides a REST API for running containers and managing related resources.
    LXD containers provide the same user experience as traditional VMs, but using
    LXC, which provides similar runtime performance to containers and improved utilization
    over VMs. LXD containers run a full Linux OS so are typically long running, whereas
    Docker application containers are short-lived. This makes LXD a machine management
    tool that is different to Docker and is closer to software distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: OpenVZ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**OpenVZ** is a container-based virtualization for Linux which allows the running
    of multiple secure, isolated Linux containers also known as **virtual environments**
    (**VEs**) and **virtual private server** (**VPS**) on a single physical server.
    OpenVZ enables better server utilization and ensures that applications do not
    conflict. It is similar to LXC. It can only run on a Linux-based OS. Since all
    OpenVZ containers share the same kernel version as hosts, users are not allowed
    to do any kernel modification. However, it also has the advantage of a low memory
    footprint due to the shared host kernel.'
  prefs: []
  type: TYPE_NORMAL
- en: Windows Server containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Windows Server 2016 introduced Linux containers to Microsoft workloads. Microsoft
    has partnered with Docker to bring the benefits of the Docker container to Microsoft
    Windows Server. They have also re-engineered the core windows OS to enable container
    technology. There are two types of Windows containers: Windows server containers
    and Hyper-V isolation.'
  prefs: []
  type: TYPE_NORMAL
- en: Windows server containers are used for running application containers on Microsoft
    workloads. They use process and namespace isolation technology for ensuring the
    isolation between multiple containers. They also share the same kernel as the
    host OS, as these containers require the same kernel version and configuration
    as the host. These containers do not provide a strict security boundary and should
    not be used to isolate untrusted code.
  prefs: []
  type: TYPE_NORMAL
- en: Hyper-V containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hyper-V containers are types of Windows containers which provide higher security
    compared to Windows server containers. Hyper-V hosts Windows server containers
    in lightweight, highly optimized **Hyper-V** virtual machines. Thus, they bring
    a higher degree of resource isolation, but at the cost of efficiency and density
    on the host. They can be used when the trust boundaries of the host OS requires
    additional security. In this configuration, the kernel of the container host is
    not shared with other containers on the same host. Since these containers do not
    share the kernel with the host or other containers on the host, they can run kernels
    with different versions and configurations. Users can choose to run containers
    with or without Hyper-V isolation at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Clear container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Virtual machines are secure but very expensive and slow to start, whereas containers
    are fast and provide a more efficient alternative, but are less secure. Intel's
    Clear containers are a trade-off solution between hypervisor-based VMs and Linux
    containers that offer agility similar to that of conventional Linux containers,
    while also offering the hardware-enforced workload isolation of hypervisor-based
    VMs.
  prefs: []
  type: TYPE_NORMAL
- en: A Clear container is a container wrapped in its own individual ultra-fast, trimmed
    down VM which offers security and efficiency. The Clear container model uses a
    fast and lightweight QEMU hypervisor that has been optimized to reduce memory
    footprints and improve startup performance. It has also optimized, in the kernel,
    the systemd and core user space for minimal memory consumption. These features
    improve the resource utilization efficiency significantly and offer enhanced security
    and speed compared to traditional VMs.
  prefs: []
  type: TYPE_NORMAL
- en: Intel Clear containers provide a lightweight mechanism to isolate the guest
    environment from the host and also provide hardware-based enforcement for workload
    isolation. Moreover, the OS layer is shared transparently and securely from the
    host into the address space of each Intel Clear container, providing an optimal
    combination of high security with low overhead.
  prefs: []
  type: TYPE_NORMAL
- en: With the security and agility enhancements offered by Clear containers, they
    have seen a high adoption rate. Today, they seamlessly integrate with the Docker
    project with the added protection of Intel VT. Intel and CoreOS have collaborated
    closely to incorporate Clear containers into CoreOS's Rocket (Rkt) container runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Installation of Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker is available in two editions, **Community Edition (CE)** and **Enterprise
    Edition (EE)**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Community Edition (CE)**: It is ideal for developers and small teams
    looking to get started with Docker and may be experimenting with container-based
    apps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Enterprise Edition (EE)**: It is designed for enterprise development
    and IT teams who build, ship, and run business critical applications in production
    at scale'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This section will demonstrate the instructions for installing Docker CE on
    Ubuntu 16.04\. The Docker installation package, available in the official Ubuntu
    16.04 repository, may not be the latest version. To get the latest and greatest
    version, install Docker from the official Docker repository. This section shows
    you how to do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the GPG key for the official Docker repository to the system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the Docker repository to APT sources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, update the package database with the Docker packages from the newly added
    repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure you are about to install Docker repository instead of the default
    Ubuntu 16.04 repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an output similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `docker-ce` is not installed, but the candidate for installation
    is from the Docker repository for Ubuntu 16.04\. The `docker-ce` version number
    might be different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, install Docker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Docker should now be installed, the daemon started, and the process enabled
    to start on boot. Check that it''s running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that Docker CE is installed correctly by running the hello-world image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Docker hands-on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section explains how to use Docker to run any application inside containers.
    The Docker installation explained in the previous section also installs the docker
    command-line utility or the Docker client. Let's explore the `docker` command.
    Using the `docker` command consists of passing it a chain of options and commands
    followed by arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax takes this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To view system wide information about Docker and the Docker version, use the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Docker has many subcommands to manage multiple resources managed by the Docker
    daemon. Here is a list of management commands supported by Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Management command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Config` | Manages Docker configs |'
  prefs: []
  type: TYPE_TB
- en: '| `container` | Manages containers |'
  prefs: []
  type: TYPE_TB
- en: '| `image` | Manages images |'
  prefs: []
  type: TYPE_TB
- en: '| `network` | Manages networks |'
  prefs: []
  type: TYPE_TB
- en: '| `Node` | Manages Swarrn nodes |'
  prefs: []
  type: TYPE_TB
- en: '| `Plugin` | Manages plugins |'
  prefs: []
  type: TYPE_TB
- en: '| `secret` | Manages Docker secrets |'
  prefs: []
  type: TYPE_TB
- en: '| `Service` | Manages services |'
  prefs: []
  type: TYPE_TB
- en: '| `Stack` | Manages Docker stacks |'
  prefs: []
  type: TYPE_TB
- en: '| `Swarm` | Manages swarm |'
  prefs: []
  type: TYPE_TB
- en: '| `System` | Manages Docker |'
  prefs: []
  type: TYPE_TB
- en: '| `Volume` | Manages volumes |'
  prefs: []
  type: TYPE_TB
- en: In the next section, we will explore container and image resources.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Docker images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An image is a lightweight, standalone executable package that includes everything
    needed to run a piece of software, including the code, a runtime, libraries, environment
    variables, and configuration files. Docker images are used to create Docker containers.
    Images are stored in the Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: Listing images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can list all of the images that are available in the Docker host by running
    the Docker images subcommand. The default Docker images will show all top-level
    images, their repository and tags, and their size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Getting new images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker will automatically download any image that is not present in the Docker
    host system. The `docker pull` subcommand will always download the image that
    has the latest tag in that repository if a tag is not provided. If a tag is provided,
    it pulls the specific image with that tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pull a base image, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Searching Docker images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most important features of Docker is that a lot of people have created
    Docker images for a variety of purposes. Many of these have been uploaded to Docker
    Hub. You can easily search for Docker images in the Docker Hub registry by using
    the docker search subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Deleting images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To delete an image, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to the Docker documentation for the rest of the commands related
    to Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Docker containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A container is a runtime instance of an image. It runs completely isolated from
    the host environment by default, only accessing host files and ports if configured
    to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Creating containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Launching a container is simple, as `docker run` passes the image name you
    would like to run and the command to run this within the container. If the image
    doesn''t exist on your local machine, Docker will attempt to fetch it from the
    public image registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the container will start, print hello world, and then
    stop. Containers are designed to stop once the command executed within them has
    exited.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s run a container using the latest image in Ubuntu. The
    combination of the `-i` and `-t` switches gives you interactive shell access to
    the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Listing containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can list the all containers running on the Docker host using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Checking container's logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also view the information logged by a running container using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Starting containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can start a stopped container using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, you can use commands such as stop, pause, unpause, reboot, restart,
    and so on to operate containers.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also delete a stopped container using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to the Docker documentation for the rest of the commands related
    to Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about containers and their types. We have also
    learned about the components in containers. We took a look at the different container
    runtime tools. We took a deep dive into Docker, we installed it, and we did a
    hands-on exercise. We also learned the commands for managing containers and images
    using Docker. In the next chapter, we will read about different COE tools available
    today.
  prefs: []
  type: TYPE_NORMAL
