- en: Networking and Persistent Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We learned a lot about Docker concepts in the previous chapter. We know that
    the container is a runtime of an image. It will contain your Java application
    altogether with all needed dependencies, such as JRE or an application server.
    But, there are rare cases when the Java application is self-sufficient. It always
    needs to communicate with other servers (as a database), or expose itself to others
    (as a web application running on the application server which needs to accept
    requests coming from the user or from the other applications). It''s time to describe
    ways to open the Docker container to the outside world, networking, and persistent
    storage. In this chapter, you are going to learn how to configure networking,
    and expose and map network ports. By doing that, you will enable your Java application
    to communicate with other containers. Imagine the following scenario: you can
    have one container running a Tomcat application server with your Java application,
    communicating with another container running a database, `PostgreSQL` for example.
    While the Kubernetes approach to networking is somewhat different in comparison
    to what Docker provides by default, let''s focus on Docker itself briefly now.
    We are going to cover Kubernetes'' specific networking later on. The container
    communication with the outside world is not only about networking; in this chapter,
    we will also focus on data volumes as a way to persist the data between container
    run and stop cycles.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker network types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping and exposing ports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volume-related commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and removing volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin with Docker networking.
  prefs: []
  type: TYPE_NORMAL
- en: Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make your container able to communicate with the outside world, whether another
    server or another Docker container, Docker provides different ways of configuring
    networking. Let's begin with the network types which are available for our containers.
  prefs: []
  type: TYPE_NORMAL
- en: Docker network types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three different network types Docker delivers out of the box. To
    list them, execute the `docker network ls` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Docker will output the list of available networks containing the unique network
    identifier, its name, and a driver which powers it behind the scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To have an overview of the differences between various network types, let's
    describe them now one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Bridge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the default network type in Docker. When the Docker service daemon
    starts, it configures a virtual bridge, named `docker0` . If you do not specify
    a network with the `docker run -net=<NETWORK>` option, the Docker daemon will
    connect the container to the bridge network by default. Also, if you create a
    new container, it will be connected to the bridge network. For each container
    that Docker creates, it allocates a virtual Ethernet device which will be attached
    to the bridge. The virtual Ethernet device is mapped to appear as `eth0` in the
    container, using Linux namespaces, as you can see in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `in-container eth0` interface is given an IP address from the bridge's address
    range. In other words, Docker will find a free IP address from the range available
    on the bridge and will configure the container's `eth0` interface with that IP
    address. From now on, if the new container wants to, for example, connect to the
    Internet, it will use the bridge; the host's own IP address. The bridge will automatically
    forward packets between any other network interfaces that are attached to it and
    also allow containers to communicate with the host machine, as well as with the
    containers on the same host. The bridge network will probably be the most frequently
    used one.
  prefs: []
  type: TYPE_NORMAL
- en: Host
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This type of network just puts the container in the host''s network stack.
    That is, all of the network interfaces defined on the host will be accessible
    to the container, as you can see in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you start your container using the `-net=host` option, then the container
    will use the host network. It will be as fast as normal networking: there is no
    bridge, no translation, nothing. That''s why it can be useful when you need to
    get the best network performance. Containers running in the host''s network stack
    will achieve faster network performance compared to those running on bridge networking,
    there is no need to traverse the `docker0` `bridge` and `iptables` port mappings.
    In host mode, the container shares the networking namespace of the host (your
    local machine, for example), directly exposing it to the outside world. By using
    the `-net=host` command switch, your container will be accessible through the
    host''s IP address. However, you need to be aware that this can be dangerous.
    If you have an application running as root and it has some vulnerabilities, there
    will be a risk of a security breach, as someone can get remote control of the
    host network via the Docker container. Using the host network type also means
    that you will need to use port mapping to reach services inside the container.
    We are going to cover port mapping later, in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: None
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To cut a long story short, the none network does not configure networking at
    all. There is no driver being used by this network type. It's useful when you
    don't need your container to have network access; the `-net=none` switch to `docker
    run` command completely disables networking.
  prefs: []
  type: TYPE_NORMAL
- en: Docker provides a short list of commands to deal with networking. You can run
    them from the shell (Linux or macOS) or the command prompt and PowerShell in Windows.
    Let's get to know them now.
  prefs: []
  type: TYPE_NORMAL
- en: Networking commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The parent command for managing networks in Docker is `docker network` . You
    can list the whole command set using the `docker network help` command, as you
    can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To have a detailed syntax and description of each option available for a specific
    command, use the `-help` switch for each of the commands. For example, to get
    the description of parameters available for `docker network create` , execute
    the `docker network create -help` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s briefly describe each command available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**$ docker network ls**` : This is the command we have been using previously,
    it simply lists networks available for your containers. It will output the network
    identifier, its name, the driver being used, and a scope of the network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**$ docker network create**` : Creates new network. The full syntax of the
    command is, `docker network create [OPTIONS] NETWORK` . We will use the command
    in a short while'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**$ docker network rm**` : The `dockercnetworkcrm` command simply removes
    the network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**$ docker network connect**` : C onnects the container to the specific network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**$ docker network disconnect**` : A s the name suggests, it will disconnect
    the container from the network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**$ docker network inspect**` : The docker network inspect command displays
    detailed information about the network. It''s very useful, if you have network
    issues. We are going to create and inspect our network now'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `docker network` inspect command displays detailed information about the
    network. It's very useful if you have network issues. We are going to create and
    inspect our network now.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and inspecting a network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a network. We are going to call our network `myNetwork` . Execute
    the following command from the shell or command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the simplest form of the command, and yet it will probably be used
    the most often. It takes a default driver (we haven''t used any option to specify
    a driver, we will just use the default one, which is bridge). As the output, Docker
    will print out the identifier of the newly created network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will later use this identifier to refer to this network when connecting
    containers to it or inspecting the network''s properties. The last parameter of
    the command is the network''s name, which is a lot more convenient and easier
    to remember than the ID. The network name in our case is `myNetwork` . The `docker
    network` create command takes more parameters, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Option** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `-d, -driver="bridge"` | Driver to manage the network |'
  prefs: []
  type: TYPE_TB
- en: '| `-aux-address=map[]` | Auxiliary IPv4 or IPv6 addresses used by network driver
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-gateway=[]` | IPv4 or IPv6 gateway for the master subnet |'
  prefs: []
  type: TYPE_TB
- en: '| `-ip-range=[]` | Allocate container IP from a sub-range |'
  prefs: []
  type: TYPE_TB
- en: '| `-ipam-driver=default` | IP address management driver |'
  prefs: []
  type: TYPE_TB
- en: '| `-o` , `-opt=map[]` | Set driver''s specific options |'
  prefs: []
  type: TYPE_TB
- en: '| `-subnet=[]` | Subnet in CIDR format that represents a network segment |'
  prefs: []
  type: TYPE_TB
- en: 'One of the most important parameters is the `-d` (`--driver` ) option, with
    the default value bridge. Drivers let you specify the network type. As you remember,
    Docker has a couple of drivers available by default: `host` , `bridge` , and `none`
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating a network, we can inspect its properties using the `docker network
    inspect` command. Execute the following from the shell or command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In response, you will get a lot of detailed information about your network.
    As you can see in the screenshot, our newly created network uses the bridge driver,
    even if we haven''t explicitly asked for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00042.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the container list is empty, and the reason why is that we haven't
    connected any container to this network yet. Let's do it now.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting a container to the network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have our `myNetwork` ready, we can run the Docker container and attach
    it to the network. To launch containers, we are going to user the `docker run
    --net=<NETWORK>` option, where the `<NETWORK>` is the name of one of the default
    networks or the one you have created yourself. Let''s run Apache Tomcat for example,
    which is an open source implementation of the Java Servlet and JavaServer pages
    technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It will take a while. The Docker engine will pull all of the Tomcat''s image
    layers from the Docker Hub and then run the Tomcat container. There''s another
    option to attach the network to the container, you can inform Docker that you
    would like the container to connect to the same network as other containers use.
    This way, instead of specifying a network explicitly, you just instruct Docker
    that you want two containers run on the same network. To do this, use the `container:`
    prefix, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we run the `myTomcat` image using the bridge network.
    The next command will run the `myPostgreSQL` image, using the same network as
    `myTomcat` uses. This is a very common scenario; your application will run on
    the same network as the database and this will allow them to communicate. Of course,
    the containers you launch into the same network must be run on the same Docker
    host. Each container in the network can directly communicate with other containers
    in the network. Though, the network itself isolates the containers from external
    networks, as seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you run your containers in a bridge, isolated network, we need to instruct
    Docker on how to map the ports of our containers to the host's ports. We are going
    to do this now.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing ports and mapping ports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common scenario is usually when you want your containerized application to
    accept incoming connections, either from other containers or from outside of Docker.
    It can be an application server listening on port 80 or a database accepting incoming
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'An image can expose ports. Exposing ports means that your containerized application
    will listen on an exposed port. As an example, the Tomcat application server will
    listen on the port `8080` by default. All containers running on the same host
    and on the same network can communicate with Tomcat on this port. Exposing a port
    can be done in two ways. It can be either in the Dockerfile with the `EXPOSE`
    instruction (we will do this in the chapter about creating images later) or in
    the `docker run` command using the `--expose` option. Take this official Tomcat
    image Dockerfile fragment (note that it has been shortened for clarity of the
    example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there''s an `EXPOSE 8080` instruction near the end of the Dockerfile.
    It means that we could expect that the container, when run, will listen on port
    number `8080` . Let''s run the latest Tomcat image again. This time, we will also
    give our container a name, `myTomcat` . Start the application server using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For the purpose of checking if containers on the same network can communicate,
    we will use another image, `busybox` . BusyBox is software that provides several
    stripped-down Unix tools in a single executable file. Let''s run the following
    command in the separate shell or command prompt window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have instructed Docker that we want our `busybox` container
    to use the same network as Tomcat uses. As an alternative, we could of course
    go with specifying a network name explicitly, using the `--net myNetwork` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check if they indeed can communicate. Execute the following in the shell
    window with `busybox` running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous instruction will execute the `HTTP GET` request on port `8080`
    , on which Tomcat is listening in another container. After the successful download
    of Tomcat''s `index.html` , we have proof that both containers can communicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00044.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So far so good, containers running on the same host and the same network can
    communicate with each other. But what about communicating with our container from
    the outside? Mapping ports comes in handy. We can map a port, exposed by the Docker
    container, into the port of the host machine, which will be a localhost in our
    case. The general idea is that we want the port on the host to be mapped to a
    specific port in the running container, the same as port number `8080` of the
    Tomcat container.
  prefs: []
  type: TYPE_NORMAL
- en: 'To bind a port (or group of ports) from a host to the container, we use the
    `-p` flag of the `docker run` command, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command runs another Tomcat instance, also connected to the `myNetwork`
    network. This time, however, we map the container''s port `8080` to the host''s
    port of the same number. The syntax of the `-p` switch is quite straightforward:
    you just enter the host port number, a colon, and then a port number in the container
    you would like to be mapped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The Docker image can expose a whole range of ports to other containers using
    either the `EXPOSE` instruction in a Dockerfile (the same as `EXPOSE 7000-8000`
    , for example) or the `docker run` command, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then map a whole range of ports from the host to the container by using
    the `docker run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s verify if we can access the Tomcat container from outside of Docker.
    To do this, let''s run Tomcat with mapped ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can simply enter the following address in our favorite web browser:
    `http://localhost:8080` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, we can see Tomcat''s default welcome page, served straight from
    the Docker container running, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Good, we can communicate with our container from the outside of Docker. By the
    way, we now have two isolated Tomcats running on the host, without any port conflicts,
    resource conflicts, and so on. This is the power of containerization.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may ask, what is the difference between exposing and mapping ports, that
    is, between `--expose` switch and `-p` switches? Well, the `--expose` will expose
    a port at runtime but will not create any mapping to the host. Exposed ports will
    be available only to another container running on the same network, on the same
    Docker host. The `-p` option, on the other hand, is the same as `publish` : it
    will create a port mapping rule, mapping a port on the container with the port
    on the host system. The mapped port will be available from outside Docker. Note
    that if you do `-p` , but there is no `EXPOSE` in the Dockerfile, Docker will
    do an implicit `EXPOSE` . This is because, if a port is open to the public, it
    is automatically also open to other Docker containers.'
  prefs: []
  type: TYPE_NORMAL
- en: There is no way to create a port mapping in the Dockerfile. Mapping a port or
    ports is, just a runtime option. The reason for that is because port mapping configuration
    depends on the host. The Dockerfile needs to be host-independent and portable.
  prefs: []
  type: TYPE_NORMAL
- en: You can bind a port using `-p` in the runtime only.
  prefs: []
  type: TYPE_NORMAL
- en: There is yet one more option, which allows you to map all ports exposed in an
    image (that is; in the Dockerfile) at once, automatically during the container
    startup. The `-P` switch (capital `P` this time) will map a dynamically allocated
    random host port to all container ports that have been exposed in the Dockerfile
    by the `EXPOSE` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: The `-p` option gives you more control than `-P` when mapping ports. Docker
    will not automatically pick any random port; it's up to you what ports on the
    host should be mapped to the container ports.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the following command, Docker will map a random port on the host
    to Tomcat''s exposed port number `8080` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To check exactly which host port has been mapped, you can use the `docker ps`
    command. This is probably the quickest way of determining the current port mapping.
    The `docker ps` command is used to see the list of running containers. Execute
    the following from a separate shell console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output, Docker will list all running containers, showing which ports
    have been mapped in the `PORTS` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the previous screenshot, our `myTomcat3` container will have
    the `8080` port mapped to port number `32772` on the host. Again, executing the
    `HTTP GET` method on the `http://localhost:32772` address will give us `myTomcat3`
    ''s welcome page. An alternative to the `docker ps` command is the docker port
    command, used with the container `ID` or with a `name` as a parameter (this will
    give you information about what ports have been mapped). In our case, this will
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, Docker will output the mapping, saying that port number 80 from
    the container has been mapped to port number `8080` on the host machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Information about all the port mappings is also available in the result of
    the docker inspect command. Execute the following command, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output of the `docker inspect` command, you will find the `Ports` section
    containing the information about mappings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s briefly summarize the options related to exposing and mapping ports
    in a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `EXPOSE` | Signals that there is service available on the specified port.
    Used in the Dockerfile and makes exposed ports open for other containers. |'
  prefs: []
  type: TYPE_TB
- en: '| `--expose` | The same as `EXPOSE` but used in the runtime, during the container
    startup. |'
  prefs: []
  type: TYPE_TB
- en: '| `-p hostPort:containerPort` | Specify a port mapping rule, mapping the port
    on the container with the port on the host machine. Makes a port open from the
    outside of Docker. |'
  prefs: []
  type: TYPE_TB
- en: '| `-P` | Map dynamically allocated random port (or ports) of the host to all
    ports exposed using `EXPOSE` or `--expose` . |'
  prefs: []
  type: TYPE_TB
- en: Mapping ports is a wonderful feature. It gives you flexible configuration possibilities
    to open your containers to the external world. In fact, it's indispensable if
    you want your containerized web server, database, or messaging server to be able
    to talk to others. If a default set of network drivers is not enough, you can
    always try to find a specific driver on the Internet or develop one yourself.
    Docker Engine network plugins extend Docker to support a wide range of networking
    technologies, such as IPVLAN, MACVLAN, or something completely different and exotic.
    Networking possibilities are almost endless in Docker. Let's focus now on another
    very important aspect of Docker container extensibility volumes.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you remember from [Chapter 1](text00022.html) , *Introduction to Docker*
    , the Docker container filesystem is kind of temporary by default. If you start
    up a Docker image (that is, run the container), you'll end up with a read-write
    layer on top of the layers stack. You can create, modify, and delete files as
    you wish; if you commit the changes back into the image, they will become persisted.
    This is a great feature if you want to create a complete setup of your application
    in the image, altogether with all its environment. But, this is not very convenient
    when it comes to storing and retrieving data. The best option would be to separate
    the container life cycle and your application from the data. Ideally, you would
    probably want to keep these separate, so that the data generated (or being used)
    by your application is not destroyed or tied to the container life cycle and can
    thus be reused.
  prefs: []
  type: TYPE_NORMAL
- en: 'The perfect example would be a web application server: the Docker image contains
    web server software, the same as Tomcat for example, with your Java application
    deployed, configured, and ready to use. But, the data the server will be using
    should be separated from the image. This is done via volumes, which we will focus
    on in this part of the chapter. Volumes are not part of the union filesystem,
    and so the write operations are instant and as fast as possible, there is no need
    to commit any changes.'
  prefs: []
  type: TYPE_NORMAL
- en: Volumes live outside of the union filesystem and exist as normal directories
    and files on the host filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main use cases for Docker data volumes:'
  prefs: []
  type: TYPE_NORMAL
- en: To share data between the host filesystem and the Docker container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To keep data when a container is removed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To share data with other Docker containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin with a list of volume-related commands at our disposal.
  prefs: []
  type: TYPE_NORMAL
- en: Volume-related commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basis of volume-related commands is docker volume . The commands are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**$docker volume create**` : C reates a volume'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**$ docker volume inspect**` : D isplays detailed information on one or more
    volumes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**$docker volume ls**` : L ists volumes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**$ docker volume rm**` : r emoves one or more volumes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**$ docker volume prune**` : r emoves all unused volumes, which is all volumes
    that are no longer mapped into any container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similar to network-related commands, you can get the detailed description and
    all the possible options for each command if you execute it with the `-help` switch,
    for example: docker volume create `-help` . Let''s begin with creating a volume.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a volume
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you remember from [Chapter 1](text00022.html) , *Introduction to Docker*
    , there''s a settings screen in Docker for Windows or Docker for Mac, that allows
    us to specify which drives Docker can have access to. For a start, let''s mark
    drive D in our Docker for Windows to make it available for Docker containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For the purpose of our volume examples, I''ve created a `docker_volumes/volume1`
    directory on my `D` drive and created an empty `data.txt` file inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are two ways to create volumes. The first one is to specify the `-v`
    option when running an image. Let''s run the `busybox` image we already know and,
    at the same time, create a volume for our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous command, we have created a volume using the `-v` switch and
    instructed Docker that the `host` directory `d:/docker_volumes/volume1` should
    be mapped into the `/volume` directory in the running container. If we now list
    the contents of the `/volume` directory in the running `busybox` container, we
    can see our empty `data1.txt` file, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The parameters in the `-v` options are the directory on the host (your own operating
    system in this case, it is `d:/docker_volumes/volume1` in our example), a colon,
    and a path at which it will be available for the container, `/volume1` in our
    example. The volume created is a kind of mapped directory. It will be available
    for the container and also available from the host operating system. Any files
    already existing in the mapped directory (host's `d:/docker_volumes/volume1` )
    will be available inside the container; they will not be deleted during the mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-v` option can be used not only for directories but for a single file
    as well. This can be very useful if you want to have configuration files available
    in your container. The best example for this is the example from the official
    Docker documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Executing the previous command will give you the same bash history between your
    local machine and a running Ubuntu container. And best of all, if you exit the
    container, the bash history on your own local machine will contain the bash commands
    you have been executing inside the container. Mapping files can be useful also
    for you, as a developer, when debugging or trying out your application configuration,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping a single file from a host allows exposing a configuration of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from creating a volume when starting a container, there is a command to
    create a volume prior to starting a container. We will use it now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest form of creating a nameless volume will be just:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As the output, Docker will give you the volume identifier, which you can later
    use to refer to this volume. It''s better to give a volume a meaningful name.
    To create a standalone, named volume, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To list the volumes we now have available, execute the `docker volume ls` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be simply the list of volumes we have created so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Volumes created this way will not be mapped explicitly with a path on the host.
    If the container''s base image contains data at the specified mount point (as
    a result of Dockerfile processing), this data will be copied into the new volume
    upon volume initialization. This is different in comparison to specifying a `host`
    directory explicitly. The idea behind it is that when creating your image, you
    should not care about the location of the volume on the host system, making the
    image portable between different hosts. Let''s run another container and map the
    named volume into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this time, we do not specify a path on the host. Instead, we instruct
    Docker to use the named volume we created in the previous step. The named volume
    will be available at the `/volume` path in the container. Let''s create a text
    file on the volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we run another container now, specifying the same named volume, we will
    be able to access the same data we have available in our `myBusybox3` container
    which was created previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Our two containers share the single volume now, as you can see in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Docker named volumes are an easy way of sharing volumes between containers.
    They are also a great alternative to data-only containers that used to be a common
    practice in the old days of Docker. This is no longer the case—named volumes are
    way better. It's worth noting that you are not limited to just one volume per
    container, as that would be a serious limitation.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `-v` multiple times to mount multiple data volumes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option to share the volume between containers is the `-volumes-from`
    switch. If one of your containers has volumes mounted already, by using this option
    we can instruct Docker to use the volume mapped in some other container, instead
    of providing the name of the volume. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: After running the `myBusybox5` container this way, again, if you enter the `/volume`
    directory in the `myBusybox5` container running, you will see the same `data.txt`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker volume ls` command can take some filter parameters, which can be
    quite useful. For example, you can list volumes that are not being used by any
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Volumes that are no longer used by any container can be easily removed by using
    the docker volumes prune command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To list volumes being created with a specific driver (we are going to cover
    drivers in a short while), you can filter a list using the driver filter, as in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, another way of creating a volume is the `VOLUME CREATE`
    instruction in a Dockerfile. We will be using it later in the book when creating
    an image from a Dockerfile. Creating volumes using the `VOLUME CREATE` instruction
    has one but very important difference in comparison to using the `-v` option during
    the container startup: you cannot specify a `host` directory when using `VOLUME
    CREATE` . It''s an analogy to exposing and mapping ports. You cannot map a port
    in a Dockerfile. Dockerfiles are meant to be portable, shareable, and host-independent.
    The `host` directory is 100% host-dependent and will break on any other machine,
    which is a little bit off from the Docker''s idea. Because of this, it is only
    possible to use portable instructions within a Dockerfile.'
  prefs: []
  type: TYPE_NORMAL
- en: If you need to specify a `host` directory when creating a volume, you need to
    specify it at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a volume
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The same as with creating volumes, there are two ways of removing a volume
    in Docker. Firstly, you can remove a volume by referencing a container''s name
    and executing the docker `rm -v` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Docker will not warn you, when removing a container without providing the `-v`
    option, to delete its volumes. As a result, you will have `dangling` volumes—volumes
    that are no longer referenced by a container. As you remember, they are easy to
    get rid of using the docker volume prune command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option to remove the volume is by using the `docker volume rm` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If the volume happens to be in use by the container, Docker Engine will not
    allow you to delete it and will give you a warning message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, creating, sharing, and removing volumes in Docker is not that
    tricky. It's very flexible and allows the creating a setup you will need for your
    applications. But there's more to this flexibility. When creating a volume, you
    can specify a `--driver` option (or `-d` for short), which may be useful if you
    need to map some external, not so standard storage. The volumes we have created
    so far were using the local filesystem driver (the files were being stored on
    the local drive of the host system); you can see the driver name when inspecting
    a volume using the `volume inspect` command. There are other options though—let's
    look at them now.
  prefs: []
  type: TYPE_NORMAL
- en: Volume drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The same as with network driver plugins, volume plugins extend the capabilities
    of the Docker engine and enable integration with other types of storage. There
    are a ton of ready to use plugins available for free on the Internet; you can
    find a list on Docker''s GitHub page. Some of them include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker volume driver for Azure file storage** : This is a Docker volume driver
    which uses Azure file storage to mount file shares on the cloud to Docker containers
    as volumes. It uses the network file sharing (SMB/CIFS protocols) capabilities
    of Azure file storage. You can create Docker containers that can migrate from
    one host to another seamlessly or share volumes among multiple containers running
    on different hosts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IPFS** : Open source volume plugin that allows the use of an IPFS filesystem
    as a volume. IPFS is a very interesting and promising storage system; it makes
    it possible to distribute high volumes of data with high efficiency. It provides
    deduplication, high performance, and clustered persistence, providing secure P2P
    content delivery, fast performance, and decentralized archiving. IPFS provides
    resilient access to data, independent of low latency or connectivity to the backbone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keywhiz** : You can use this driver to make your container talk to a remote
    Keywhiz server. Keywhiz is a system for managing and distributing secret data,
    the same as TLS certificates/keys, GPG keys, API tokens, and database credentials.
    Instead of putting this data in config files or copying files (which is similarly
    to be leaked or difficult to track), Keywhiz makes managing it easier and more
    secure: Keywhiz servers in a cluster centrally store secrets encrypted in a database.
    Clients use **mutually authenticated TLS** (**mTLS** ) to retrieve secrets they
    have access to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see from the previous examples, they are quite interesting, sometimes
    even exotic. Because of the extendable nature of Docker and its plugin architecture,
    you can create very flexible setups. But, third-party drivers do not always introduce
    completely new storage types; sometimes, they just extend the existing drivers.
    An example of that can be the Local Persist Plugin, a volume plugin that extends
    the default local driver's functionality by allowing you to specify a mount point
    anywhere on the host, which enables the files to always persist, even if the volume
    is removed via the `docker volume rm` command.
  prefs: []
  type: TYPE_NORMAL
- en: If you need a volume plugin that is not yet available, you can just write your
    own. The process is very well documented on Docker's GitHub page, together with
    extensible examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve now covered how to open our containers to the external world. We can
    use networking and mounted volumes to be able to share data between containers
    and other hosts. Let''s summarize what we have learned so far in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the network plugins to further extend the networking data exchange
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volumes persist the data, even through container restarts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes to files on the volume are made directly, but they will not be included
    when you update an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data volumes persist even if the container itself is deleted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volumes allow of sharing data between the host filesystem and the Docker container,
    or between other Docker containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the volume drivers to further extend the file exchange possibilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers from the same Docker host see each other automatically on the default
    bridge network.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about Docker networking and storage volume
    features. We know how to differentiate between various network types, how to create
    a network, and expose and map network ports.
  prefs: []
  type: TYPE_NORMAL
- en: We've been through volume-related commands and can now create or remove a volume.
    In [Chapter 3](text00053.html) , *Working with Microservices* , we are going to
    focus on the software that we are going to deploy using Docker and Kubernetes,
    and later, Java microservices.
  prefs: []
  type: TYPE_NORMAL
