- en: Chapter 10. Debugging Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging has been an artistic component in the field of software engineering.
    All kinds of software building blocks individually, as well as collectively, need
    to go through a stream of deeper and decisive investigations by software development
    and testing professionals in order to ensure the security and safety of the resulting
    software applications. As Docker containers are said to be key runtime environments
    for next generation mission-critical software workloads, it is pertinent and paramount
    for containers, crafters, and composers to embark on the systematic and sagacious
    verification and validation of containers.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has been dedicatedly written to enable technical guys with all
    the right and relevant information to meticulously debug applications running
    inside containers and containers themselves. In this chapter, we will take a look
    at the theoretical aspects of process isolation for processes running as containers.
    A Docker container runs at a user-level process on host machines and typically
    has the same isolation level as provided by the operating system. With the release
    of Docker 1.5, many debugging tools are available, which can be efficiently used
    to debug your applications. We will also cover the primary Docker debugging tools,
    such as Docker `exec`, `stats`, `ps`, `top`, `events`, and `logs`. Finally, we
    will take a look at the `nsenter` tool to log in to containers without running
    the **Secure Shell** (**SSH**) daemon.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of topics that will be covered in the chapter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Process level isolation for Docker containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging a containerized application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and using `nsenter`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process level isolation for Docker containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the virtualization paradigm, the hypervisor emulates computing resources
    and provides a virtualized environment called a VM to install the operating system
    and applications on top of it. Whereas, in the case of the container paradigm,
    a single system (bare metal or virtual machine) is effectively partitioned to
    run multiple services simultaneously without interfering with each other. These
    services must be isolated from each other in order to prevent them from stepping
    on each other''s resources or dependency conflict (also known as dependency hell).
    The Docker container technology essentially achieves process-level isolation by
    leveraging the Linux kernel constructs, such as namespaces and cgroups, particularly,
    the namespaces. The Linux kernel provides the following five powerful namespace
    leavers to isolate the global system resources from each other. These are the
    **Interprocess Communication** (**IPC**) namespaces used to isolate the interprocess
    communication resources:'
  prefs: []
  type: TYPE_NORMAL
- en: The network namespace is used to isolate networking resources, such as the network
    devices, network stack, port number, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mount namespace isolates the filesystem mount points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PID namespace isolates the process identification number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user namespace is used to isolate the user ID and group ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UTS namespace is used to isolate the hostname and the NIS domain name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These namespaces add an additional level of complexity when we have to debug
    the services running inside the containers, which we will learn more in detail
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will discuss how the Docker engine provides process isolation
    by leveraging the Linux namespaces through a series of practical examples, and
    one of them is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by launching an `ubuntu` container in an interactive mode using the `docker
    run` subcommand, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Proceed to find the process ID of the preceding container `93f5d72c2f21`, using
    the `docker inspect` subcommand in a different terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Apparently, from the preceding output, the process ID of the container `93f5d72c2f21`
    is `2543`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having got the process ID of the container, let''s continue to see how the
    process associated with the container looks in the Docker host, using the `ps`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Amazing, isn't it? We launched a container with `/bin/bash` as its command,
    and we have the `/bin/bash` process in the Docker host as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go one step further and display the `/proc/2543/environ` file in the
    Docker host using the `cat` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, `HOSTNAME=93f5d72c2f21` stands out from the other environment
    variables because `93f5d72c2f21` is the container ID, as well as the hostname
    of the container, which we launched previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s get back to the terminal, where we are running our interactive
    container `93f5d72c2f21`, and list all the processes running inside this container
    using the `ps` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Surprising, isn't it? Inside the container, the process ID of the `bin/bash`
    process is `1`, whereas outside the container, in the Docker host, the process
    ID is `2543`. Besides, the **Parent Process ID** (**PPID**) is `0` (zero).
  prefs: []
  type: TYPE_NORMAL
- en: In the Linux world, every system has just one root process with the PID 1 and
    PPID 0, which is the root of the complete process tree of that system. The Docker
    framework cleverly leverages the Linux PID namespace to spin a completely new
    process tree; thus, the processes running inside a container have no access to
    the parent process of the Docker host. However, the Docker host has a complete
    view of the child PID namespace spun by the Docker engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The network namespace ensures that all containers have independent network
    interfaces on the host machine. Also, each container has its own loopback interface.
    Each container talks to the outside world using its own network interface. You
    will be surprised to know that the namespace not only has its own routing table,
    but also has its own iptables, chains, and rules. The author of this chapter is
    running three containers on his host machine. Here, it is natural to expect three
    network interfaces for each container. Let''s run the `docker ps` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'So here, three are three interfaces, one for each container. Let''s get their
    details by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The mount namespace ensures that the mounted filesystem is accessible only
    to the processes within the same namespace. The container A cannot see the mount
    points of the container B. If you want to check your mount points, you need to
    first log in to your container using the `exec` command (described in the next
    section), and then go to `/proc/mounts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's run a container with a mount point that runs as the **Storage Area Network**
    (**SAN**) or **Network Attached Storage** (**NAS**) device and access it by logging
    into the container. This is given to you as an exercise. I have implemented this
    in one of my projects at work.
  prefs: []
  type: TYPE_NORMAL
- en: There are other namespaces that these containers/processes can be isolated into,
    namely, user, IPC, and UTS. The user namespace allows you to have root privileges
    within the namespace without giving that particular access to processes outside
    the namespace. Isolating a process with the IPC namespace gives it its own interprocess
    communication resources, for example, System V IPC and POSIX messages. The UTS
    namespace isolates the *hostname* of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker has implemented this namespace using the `clone` system call. On the
    host machine, you can inspect the namespace created by Docker for the container
    (with `pid 3728`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In most industrial deployments of Docker, people are extensively using patched
    Linux kernels to provide specific needs. Also, a few companies have patched their
    kernels to attach arbitrary processes to the existing namespaces because they
    feel that this is the most convenient and reliable way to deploy, control, and
    orchestrate containers.
  prefs: []
  type: TYPE_NORMAL
- en: Control groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linux containers rely on control groups (cgroups), which not only track groups
    of processes, but also expose metrics of the CPU, memory, and block I/O usage.
    You can access these metrics and obtain network usage metrics as well. Control
    groups are another important components of Linux containers. Control groups are
    around for a while and are initially merged in the Linux kernel code 2.6.24\.
    They ensure that each Docker container will get a fixed amount of memory, CPU,
    and disk I/O, so that any container will not able to bring the host machine down
    at any point of time under any circumstances. Control groups do not play a role
    in preventing one container from being accessed, but they are essential to fending
    off some **Denial of Service** (**DoS**) attacks.
  prefs: []
  type: TYPE_NORMAL
- en: On Ubuntu 14.04, `cgroup` is implemented in the `/sys/fs/cgroup` path. The memory
    information of Docker is available at the `/sys/fs/cgroup/memory/docker/` path.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the CPU details are made available in the `/sys/fs/cgroup/cpu/docker/`
    path.
  prefs: []
  type: TYPE_NORMAL
- en: Let's find out the maximum limit of memory that can be consumed by the container
    (`41668be6e513e845150abd2dd95dd574591912a7fda947f6744a0bfdb5cd9a85`).
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, you can go to the `cgroup` memory path and check for the `memory.max.usage`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So, by default, any container can use up to 13.18 MB memory only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, CPU parameters can be found in the following path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Traditionally, Docker runs only one process inside the containers. So typically,
    you have seen people running three containers each for PHP, nginx, and MySQL.
    However, this is a myth. You can run all your three processes inside a single
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Docker isolates many aspects of the underlying host from an application running
    in a container without the root privileges. However, this separation is not as
    strong as that of virtual machines, which run independent OS instances on top
    of a hypervisor without sharing the kernel with the underlying OS. It's not a
    good idea to run applications with different security profiles as containers on
    the same host, but there are security benefits to encapsulate different applications
    into containerized applications that would otherwise run directly on the same
    host.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a containerized application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computer programs (software) sometimes fail to behave as expected. This is due
    to faulty code or due to the environmental changes between the development, testing,
    and deployment systems. Docker container technology eliminates the environmental
    issues between development, testing, and deployment as much as possible by containerizing
    all the application dependencies. Nonetheless, there could be still anomalies
    due to faulty code or variations in the kernel behavior, which needs debugging.
    Debugging is one of the most complex processes in the software engineering world
    and it becomes much more complex in the container paradigm because of the isolation
    techniques. In this section, we are going to learn a few tips and tricks to debug
    a containerized application using the tools native to Docker, as well as the tools
    provided by external sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, many people in the Docker community individually developed their
    own debugging tools, but later Docker started supporting native tools, such as
    `exec`, `top`, `logs`, `events`, and many more. In this section, we will dive
    deep into the following Docker tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '`exec`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ps`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`top`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stats`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`events`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Docker exec command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `docker exec` command provided the much-needed help to users, who are deploying
    their own web servers or other applications running in the background. Now, it
    is not necessary to log in to run the SSH daemon in the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, run the `docker ps -a` command to get the container ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Then, run the `docker exec` command to log in to the container.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to note that the `docker exec` command can only access the
    running containers, so if the container stops functioning, then you need to restart
    the stopped container in order to proceed. The `docker exec` command spawns a
    new process in the target container using the Docker API and CLI. So if you run
    the `pe -aef` command inside the target container, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, `python app.y` is the application that is already running in the target
    container, and the `docker exec` command has added the `bash` process inside the
    container. If you run `kill -9 pid(45)`, you will be automatically logged out
    of the container.
  prefs: []
  type: TYPE_NORMAL
- en: If you are an enthusiastic developer, and you want to enhance the `exec` functionality,
    you can refer to [https://github.com/chris-rock/docker-exec](https://github.com/chris-rock/docker-exec).
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that you use the `docker exec` command only for monitoring
    and diagnostic purposes, and I personally believe in the concept of one process
    per container, which is one of the best practices widely accentuated.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker ps command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `docker ps` command, which is available inside the container, is used to
    see the status of the process. This is similar to the standard `ps` command in
    the Linux environment and is *not* a `docker ps` command that we run on the Docker
    host machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command runs inside the Docker container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Use `ps --help <simple|list|output|threads|misc|all>` or `ps --help <s|l|o|t|m|a>`
    for additional help text.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker top command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can run the `top` command from the Docker host machine using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives a list of the running processes of a container without logging into
    the container, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The Docker `top` command provides information about the CPU, memory, and swap
    usage if you run it inside a Docker container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In case you get the error `error - TERM environment variable not set` while
    running the `top` command inside the container, perform the following steps to
    resolve it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `echo $TERM` command. You will get the result as `dumb`. Then, run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This will resolve the error.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker stats command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Docker `stats` command provides you with the capability to view the memory,
    CPU, and the network usage of a container from a Docker host machine, as illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the `stats` command to also view the usage for multiple containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the latest release of Docker 1.5, Docker provides you access to container
    statistics *read only* parameters. This will streamline the CPU, memory, network
    IO, and block IO of your containers. This helps you choose the resource limits
    and also in profiling. The Docker stats utility provides you with these resource
    usage details only for running containers. You can get detailed information using
    the end point APIs at [https://docs.docker.com/reference/api/docker_remote_api_v1.17/#inspect-a-container](https://docs.docker.com/reference/api/docker_remote_api_v1.17/#inspect-a-container).
  prefs: []
  type: TYPE_NORMAL
- en: Docker stats is originally taken from Michael Crosby's code contribution, which
    can be accessed at [https://github.com/crosbymichael](https://github.com/crosbymichael).
  prefs: []
  type: TYPE_NORMAL
- en: The Docker events command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Docker containers will report the following real-time events: `create`, `destroy`,
    `die`, `export`, `kill`, `omm`, `pause`, `restart`, `start`, `stop`, and `unpause`.
    The following are a few examples that illustrate how to use these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The Docker image will also report the untag and delete events.
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple filters will be handled as an `AND` operation; for example, `--filter
    container= a245253db38b --filter event=start` will display events for the container
    `a245253db38b` and the event type is start.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the supported filters are container, event, and image.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker logs command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This command fetches the log of a container without logging into the container.
    It batch-retrieves logs present at the time of execution. These logs are the output
    of `STDOUT` and `STDERR`. The general usage is shown in `docker logs [OPTIONS]
    CONTAINER`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `–follow` option will continue to provide the output till the end, `-t`
    will provide the timestamp, and `--tail= <number of lines>` will show the number
    of lines of the log messages of your container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We also used the `docker logs` utility in [Chapter 2](ch02.html "Chapter 2. Handling
    Docker Containers"), *Handling Docker Containers* and [Chapter 6](ch06.html "Chapter 6. Running
    Services in a Container"), *Running Services in a Container*, to view the logs
    of our containers.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and using nsenter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any commercial Docker deployments, you may use various containers, such as
    web application, database, and so on. However, you need to access these containers
    in order to modify the configuration or debug/troubleshoot the issues. A simple
    solution for this problem is to run an SSH server in each container. It is a not
    good way to access the machines due to unanticipated security implications. However,
    if you are working in any one of the world-class IT companies, such as IBM, DELL,
    HP, and so on, your security compliance guy will never allow you to use SSH to
    connect to machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here is the solution. The `nsenter` tool provides you access to log in
    to your container. Note that `nsenter` will be first deployed as a Docker container
    only. Using this deployed `nsenter`, you can access your container. Follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run a simple web application as a container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Test the web container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Install `nsenter` and run it as a container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, `nsenter` is up and running as a container.
  prefs: []
  type: TYPE_NORMAL
- en: Use the nsenter container to log in to the container (`a245253db38b`), that
    we created in step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command to get the `PID` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, access the web container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Then, you can log in and start accessing your container. Accessing your container
    in this way will make your security and compliance professionals happy, and they
    will feel relaxed.
  prefs: []
  type: TYPE_NORMAL
- en: Since Docker 1.3, the Docker exec is a supported tool used for logging into
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: The `nsenter` tool doesn't enter cgroups and therefore evades resource limitations.
    The potential benefit of this would be debugging and external audit, but for a
    remote access, `docker exec` is the current recommended approach.
  prefs: []
  type: TYPE_NORMAL
- en: The `nsenter` tool is tested only on Intel 64-bit platforms. You cannot run
    `nsenter` inside the container that you want to access, and hence, you need to
    run `nsenter` on host machines only. By running `nsenter` on a host machine, you
    can access all of the containers of that host machine. Also, you cannot use the
    running `nsenter` on a particular host, say host A to access the containers on
    host B.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker provides you with the isolation of containers using the Linux container
    technology, such as LXC and now `libcontainer`. Libcontainer is Docker's own implementation
    in the Go programming language to access the kernel namespace and control groups.
    This namespace is used for process-level isolation, while control groups is used
    for restricting the resource usage of running containers. Since the containers
    run as independent processes directly over the Linux kernel, the **generally available**
    (**GA**) debugging tools are not fit enough to work inside the containers to debug
    the containerized processes. Docker now provides you with a rich set of tools
    to effectively debug the container, as well as processes inside the container
    itself. Docker `exec` will allow you to log in to the container without running
    an SSH daemon in the container.
  prefs: []
  type: TYPE_NORMAL
- en: Docker `stats` provides information about the container's memory and CPU usage.
    Docker `events` reports the events, such as create, destroy, kill, and so on.
    Similarly, Docker `logs` fetch the logs from the container without logging into
    the container.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging is the foundation that can be used to strategize other security vulnerabilities
    and holes. The next chapter is therefore incorporated to expound the plausible
    security threats of Docker containers and how they can be subdued with a variety
    of security approaches, automated tools, best practices, key guidelines, and metrics.
  prefs: []
  type: TYPE_NORMAL
