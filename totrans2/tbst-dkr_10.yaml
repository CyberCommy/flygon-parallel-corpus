- en: Chapter 10. Docker Deployment in a Public Cloud - AWS and Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be doing Docker deployment on public clouds AWS and
    Azure. AWS rolled out the **Elastic Compute Cloud** (**EC2**) container service
    towards the end of 2014\. When it was launched, the company emphasised the management
    tasks with container cluster management with high-level APIs calls based on Amazon
    services release in the past. AWS has recently released Docker for AWS Beta, which
    allows users to quickly set up and configure a Docker 1.13 swarm mode on AWS as
    well as on Azure. With the help of this new service, we get the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: It ensures teams to can seamlessly move apps from the developer's laptop to
    a Dockerised staging and production environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps to deeply integrate with underlying AWS and Azure infrastructure, takes
    advantage of the host environment, and exposes familiar interfaces to administrators
    using the public cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It deploys the platform and migrates easily across various platforms where Dockerised
    apps can be moved simply and efficiently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes sure the apps run perfectly with the latest and greatest Docker versions
    on the chosen platform, hardware, infrastructure, and OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second half of the chapter, we'll be covering the Azure Container Service,
    which makes it simple to create, configure, and manage clusters of virtual machines
    that provide the support to run containerised applications. It allows us to deploy
    and manage containerised applications with Microsoft Azure. It also supports the
    various Docker orchestration tools, such as DC/OS, Docker Swarm, or Kubernetes
    as per user choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Architecture of **Amazon EC2 Container Service** (**Amazon** **ECS**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting AWS ECS deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the Docker containers in the ECS cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture of the Microsoft Azure Container Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting the Microsoft Azure Container Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Beta for AWS and Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture of Amazon ECS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The core architecture of Amazon ECS is the cluster manager, a backend service
    which handles the task of cluster coordination and state management. On top of
    the cluster manager sits the scheduler manager. They are decoupled from each other,
    allowing customers to build their own scheduler. The pool of resources includes
    CPU, memory, and the networking resources of Amazon EC2 instances partitioned
    by containers. Amazon ECS coordinates the cluster through the open source Amazon
    ECS container agent running on each EC2 instance, and does the job of starting,
    stopping, and monitoring containers as requested by the scheduler. In order to
    manage a single source of truth: EC2 instances, task running on them and containers
    and resources utilized. We need the state to be stored somewhere, which is done
    in the cluster manager key/value store. To be robust and scalable, this key/value
    store needs to be durable, available, and protect against network partitions and
    hardware failures. To achieve the concurrency control for this key/value store,
    a transactional journal based data store is maintained to keep record of changes
    to every single entry. The Amazon ECS cluster manager has opened a set of APIs
    to allow users to access all the clustered state information stored in the key/value
    store. Through the `list` command, customers can retrieve the cluster under management,
    running tasks, and EC2 instances. The `describe` command can help to retrieve
    details of specific EC2 instances and the resources available with them. Amazon
    ECS architecture delivers a highly scalable, available, and low latency container
    management solution. It is fully managed and provides operational efficiency,
    allowing customers to build and deploy applications and not think about clusters
    to manage or scale:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Architecture of Amazon ECS](graphics/4534_10_1-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Amazon ECS architecture
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting - AWS ECS deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An EC2 instance can be deployed manually and Docker can be configured on it,
    but ECS is a group of EC2 instances managed by ECS. ECS will take care of deploying
    Docker containers across the various hosts in a cluster and integrating with other
    AWS infrastructure services.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we''ll be covering some of the basic steps to set up ECS on
    AWS, which will help to troubleshoot and bypass basic configuration errors:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an ECS cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an ELB load balancer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Docker containers in the ECS cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating Docker containers in the ECS cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launch the **EC2 Container Service** listed under **Compute** from the AWS Console:![Troubleshooting
    - AWS ECS deployment](graphics/image_10_002.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Get Started** button:![Troubleshooting - AWS ECS deployment](graphics/image_10_003.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the next screen, select both options: deploy a sample application, create,
    and manage a private repository. A private repository is created for the EC2 service
    and secured by AWS. It requires an AWS login to push images:![Troubleshooting
    - AWS ECS deployment](graphics/image_10_004.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the repository name, and we'll be able to see the repository address
    where container images need to be pushed being generated:![Troubleshooting - AWS
    ECS deployment](graphics/image_10_005.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next screen shows some of the basic Docker and AWS CLI commands to push
    the container images to the private repository, as the following shows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install AWS CLI with the help of the `pip` package manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `aws configure` command and provide an AWS access key ID and AWS secret
    access key to log in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the `docker login` command to authenticate the local Docker client to the
    private AWS registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the link which is generated as the output of the preceding command which
    will configure the Docker client to work with the private repository deployed
    in AWS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll tag the nginx basic container image with the AWS private repository
    name in order to get it pushed to the private repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After pushing the image to the private Docker repository, we''ll be creating
    a task definition defining the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Docker images to run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resources (CPU, memory, and other) to be allocated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The volumes to be mounted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Docker containers to be linked together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The command container that should run when it is started
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The environment variables to be set for the container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The IAM roles the task should use for permission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Privileged Docker container or not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The labels to be given to the Docker container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The port mapping and network, and Docker networking mode to be used for the
    containers:![Troubleshooting - AWS ECS deployment](graphics/image_10_006.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced container configuration gives us the option to declare the **CPU units**,
    **Entry point**, privileged container or not, and so on:![Troubleshooting - AWS
    ECS deployment](graphics/image_10_007.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next step, we'll be declaring the service useful for a task that runs
    continuously, such as a web service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This allows us to run and maintain a specified number (desired count) of task
    definitions simultaneously in the ECS cluster. If any of the tasks fails, the
    Amazon ECS service scheduler launches another instance and maintains the desired
    number of tasks in the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can optionally run the desired count of tasks in our service behind a load
    balancer. Amazon ECS allows us to configure elastic load balancing to distribute
    traffic across the tasks defined in the service. The load balancer can be configured
    as an application load balancer, which can route requests to one or more ports
    and makes decisions at the application layer (HTTP/HTTPS). A classic load balancer
    makes decisions at the transport layer (TCP/SSL) or application layer (HTTP/HTTPS).
    It requires a fixed relationship between the load balancer port and container
    instance port:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Troubleshooting - AWS ECS deployment](graphics/image_10_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the next step, configure the cluster, which is a logical grouping of EC2
    instances. By default, we'll be defining `t2.micro` as an EC2 instance type and
    the current number of instances as `1`:![Troubleshooting - AWS ECS deployment](graphics/image_10_009.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the configuration and deploy the ECS cluster. After the cluster is created,
    click on the **View Service** button to see details about the service:![Troubleshooting
    - AWS ECS deployment](graphics/image_10_010.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the EC2 container load balancer to get the publicly accessible service
    URL:![Troubleshooting - AWS ECS deployment](graphics/image_10_011.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the description of the load balancer, DNS name is the URL to access the service
    from the Internet:![Troubleshooting - AWS ECS deployment](graphics/image_10_012.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Welcome to nginx page can be seen as we access the load balancer public
    URL:![Troubleshooting - AWS ECS deployment](graphics/image_10_013.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating Docker containers in the ECS cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have the Docker container running in the ECS cluster, so now, let's walk
    through a scenario where both the container and the service need to be updated.
    Usually, this happens in a continuous delivery model, where we have two production
    environments; the blue environment is the older version of the service and is
    currently live, to handle users' requests. The new release environment is termed
    the green environment, which is in the final stage and will be handling future
    incoming requests from users as we switch from the older version to the newer
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The blue-green deployment helps to give a rapid rollback. We can switch the
    router to the blue environment if we face any issues in the latest green environment.
    Now, as the green environment is live and handling all the requests, the blue
    environment can be used as a staging environment for the final testing step of
    the next deployment. This scenario can easily be achieved with the help of **Task
    definitions** in ECS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating Docker containers in the ECS cluster](graphics/image_10_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Blue-green deployment environment
  prefs: []
  type: TYPE_NORMAL
- en: The new revision can be created by selecting the ECS task created and clicking
    on the **Create new Task Definition** button:![Updating Docker containers in the
    ECS cluster](graphics/image_10_015.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the new definition of the task, we can attach a new container or click on
    the container definition and update it. *Advanced container configuration* can
    also be used to set up the *Environment Variables*:![Updating Docker containers
    in the ECS cluster](graphics/image_10_016.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After creating the latest task, click on **Actions** and then click on **Update
    Service**:![Updating Docker containers in the ECS cluster](graphics/image_10_017.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **console-sample-app-static:2** will update the **console-sample-app-static:1**
    and various options, including number of tasks and auto scaling options, are provided
    on the next screen:![Updating Docker containers in the ECS cluster](graphics/image_10_018.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The auto scaling group will launch, including the AMI, instance type, security
    group, and all other details used to launch the ECS instance. Using the scaling
    policy, we can scale the cluster instances and services, and safely scale them
    down as demands subside. The availability zone aware ECS scheduler manages, distributes,
    and scales the cluster, thus making the architecture highly available.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Azure container service architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure is one of the fastest growing infrastructure services in the market today.
    It supports scale-on-demand and the ability to create hybrid environments, and
    big data with the help of Azure Cloud Services. The Azure Container Service provides
    deployment of open source container clustering and orchestrating solutions. With
    the help of the Azure Container Service, we can deploy DC/OS (Marathon), Kubernetes,
    and Swarm based container clusters. The Azure portal provides a simple UI and
    CLI support to achieve this deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Azure is officially the first public cloud to support mainstream container
    orchestration engines. Even the Azure Container Service engine is open sourced
    on GitHub ([https://github.com/Azure/acs-engine](https://github.com/Azure/acs-engine)).
  prefs: []
  type: TYPE_NORMAL
- en: This step enables developers to understand the architecture and run multiple
    orchestration engines directly on the vSphere Hypervisor, KVM, or HyperV. The
    **Azure Resource Manager** (**ARM**) templates provide the basis of the cluster
    deployed via the ACS APIs. The ACS engine is built in Go, which enables users
    to combine different pieces of configuration and build a final template that can
    be used for deploying a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Azure container engine has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Orchestrator of your choice, such as DC/OS, Kubernetes, or Swarm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple agent pools (availability set and virtual machine set)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker cluster size up to 1,200:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting custom vNET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Azure Container Service is primarily built with DC/OS as one of the critical
    components, and implementation is optimized for easy creation and usage on Microsoft
    Azure. ACS architecture has three basic components: Azure Compute to manage the
    VM health, Mesos for container health management, and Swarm for Docker API management:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Microsoft Azure container service architecture](graphics/image_10_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Microsoft Azure container architecture
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting - The Microsoft Azure Container Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll be looking at how to deploy a Docker Swarm cluster
    and provide orchestrator configuration details in Microsoft Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create an RSA key, which will be requested in the deployment steps.
    The key will be required to log in to the deployed machines post installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Once generated, the keys can be found in `~/root/id_rsa`
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **New** button in your Azure account portal:![Troubleshooting -
    The Microsoft Azure Container Service](graphics/image_10_022.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for the **Azure Container Service** and select it:![Troubleshooting -
    The Microsoft Azure Container Service](graphics/image_10_023.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this step, select **Resource Manager** as the deployment model and click
    on the **Create** button:![Troubleshooting - The Microsoft Azure Container Service](graphics/image_10_024.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the basics settings page, the following details are required: **User
    name**, which will be administrator for the virtual machines deployed in the Docker
    Swarm cluster; the second field is to provide the **SSH public key** we created
    in the step 1; and create a new resource group by specifying the name in the **Resource
    Group** field:![Troubleshooting - The Microsoft Azure Container Service](graphics/image_10_025.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Orchestrator configuration** as **Swarm**, **DC/OS**, or **Kubernetes**,
    as required:![Troubleshooting - The Microsoft Azure Container Service](graphics/image_10_026.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next step, provide the orchestrator configuration, **Agent count**, and
    **Master count** for this deployment. Also, the DNS prefix can be provided as
    `dockerswarm` or as required:![Troubleshooting - The Microsoft Azure Container
    Service](graphics/image_10_027.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Summary**, and once validation is passed click on **OK**. On the
    next screen, click on the **Purchase** button to go ahead with the deployment:![Troubleshooting
    - The Microsoft Azure Container Service](graphics/image_10_028.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the deployment has started, the status can be seen on the Azure primary
    **Dashboard**:![Troubleshooting - The Microsoft Azure Container Service](graphics/image_10_029.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the Docker Swarm cluster is created, click on the swarm-master from the
    Docker Swarm resources shown on the dashboard:![Troubleshooting - The Microsoft
    Azure Container Service](graphics/image_10_030.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Essentials** section of the swarm-master, you'll be able to find the
    DNS entry, as shown in the following screenshot:![Troubleshooting - The Microsoft
    Azure Container Service](graphics/image_10_031.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the command to connect via SSH to the swarm-master:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once connected to the master, basic Docker Swarm commands can be executed, and
    container deployment can be done on the Swarm cluster deployed on Microsoft Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Beta for AWS and Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the recent release of this service, Docker has made it simple to deploy
    the Docker engine on AWS and Azure through tight integration with both cloud platforms'
    infrastructure services. This allows developers to bundle their code and deploy
    it in production machines, regardless of the environment. Currently, this service
    is in Beta version, but we have covered a basic tutorial of Docker deployment
    for AWS. This service also allows you to upgrade Docker versions comfortably within
    these environments. Even the Swarm modes are enabled in these services, which
    provides a self-healing and self-organizing Swarm mode for the individual Docker
    engines. They are also distributed across availability zones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Beta for AWS and Azure provides the following improvements compared
    to the preceding approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: Using SSH keys for an IaaS account, for access control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy provisioning of infrastructure load balancing, and dynamic updating, as
    apps are provisioned in the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secured Docker setups can be done with the help of security groups and virtual
    networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker for AWS uses the *CloudFormation* template and creates the following
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: EC2 instances with auto scaling enabled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IAM profiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DynamoDB Tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VPC, subnets, and security groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ELB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SSH keys of the AWS region are required to deploy and access the deployed instances.
    The installation can also be done with the CloudFormation template using the AWS
    CLI, but in this tutorial, we''ll be covering the AWS console based approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the console, select CloudFormation, and click on **Create Stack**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Specify the Amazon S3 template URL** as `https://docker-for-aws.s3.amazonaws.com/aws/beta/aws-v1.13.0-rc4-beta14.json`,
    as follows:![Docker Beta for AWS and Azure](graphics/image_10_032.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, specify the stack details, stating the number of Swarm managers
    and nodes needing to be deployed. The AWS generated SSH key to be used can also
    be specified:![Docker Beta for AWS and Azure](graphics/image_10_033.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, we'll have the option to provide tags as well as IAM permission
    roles:![Docker Beta for AWS and Azure](graphics/image_10_034.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the details and launch the stack:![Docker Beta for AWS and Azure](graphics/image_10_035.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The stack will get listed with the status **CREATE_IN_PROGRESS**. Wait till
    the stack gets fully deployed:![Docker Beta for AWS and Azure](graphics/image_10_036.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Post deployment, the stack will have the status **CREATE_COMPLETE**. Click on
    it and the deployed environment details will be listed:![Docker Beta for AWS and
    Azure](graphics/image_10_037.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The AWS generated SSH keys can be used to SSH into the manager node and administer
    the deployed Docker Swarm instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker info` command will provide information about the Swarm cluster.
    The Swarm nodes can be listed using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The SSH connection can be made directly to the leader node as well, and a basic
    Docker container can be deployed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The service can be created for the preceding deployed container as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The service can be scaled in the Swarm cluster and removed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered Docker deployment on public clouds Microsoft
    Azure and AWS. Both cloud providers provide a competitive container service for
    customers. This chapter helps to explain the detailed architecture of the AWS
    EC2 and Microsoft Azure Container Service architecture. It has also covered installation
    and troubleshooting for all the deployment steps of the container cluster. This
    chapter has covered the blue-green deployment scenario and how it can be supported
    in AWS EC2, which is mostly necessary in the case of modern SaaS applications.
    Finally, we have covered Docker Beta, for AWS and Azure, which was launched recently
    and provides easy migration of containers from a development environment to a
    production environment as they are same. Container-based applications can be easily
    deployed and scaled with Docker Beta, as this service is very well coupled with
    the IaaS of the cloud providers.
  prefs: []
  type: TYPE_NORMAL
