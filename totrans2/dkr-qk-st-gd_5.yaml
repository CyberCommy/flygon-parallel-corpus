- en: Docker Swarm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn what Docker swarm is, and how to set up a Docker
    swarm cluster. We'll learn about all of the swarm management commands, and then
    we will find out more about swarm managers and swarm workers. Next, we will discover
    swarm services. And finally, we will find out how easy it is to access a container
    application running on any node in a swarm cluster.
  prefs: []
  type: TYPE_NORMAL
- en: There are currently over 17,000,000 shipping containers in the world, and 5
    or 6,000,000 of them are currently shipping around the world on vessels, trucks,
    and trains. In total, they make around 200,000,000 trips a year.      – [https://www.billiebox.co.uk/facts-about-shipping-containers](https://www.billiebox.co.uk/facts-about-shipping-containers)
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Docker swarm?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Docker swarm cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managers and workers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swarm services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing container applications in a swarm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be pulling Docker images from Docker's public repo, so basic internet
    access is required to execute the examples within this chapter. You will be setting
    up a multi-node swarm cluster, so you will need multiple nodes to complete the
    examples in this chapter. You can use physical servers, EC2 instances, Virtual
    Machines on vSphere or Workstation or even on Virtual Box. I utilized 6 VMs on
    Vmware Workstation for my nodes. Each VM is configured with 1 GB ram, 1 CPU, and
    20 GB HDD. The guest OS utilized is Xubuntu 18.04 for its small size and full
    Ubuntu feature set. Xubuntu can be downloaded from [https://xubuntu.org/download/](https://xubuntu.org/download/). Virtually
    any modern Linux operating system choice would be acceptable for the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter05](https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter05)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action: [http://bit.ly/2KENJOD](http://bit.ly/2KENJOD)'
  prefs: []
  type: TYPE_NORMAL
- en: What is Docker swarm?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You probably have not noticed this, but so far, all of the Docker workstation
    deployments, or nodes that we have used in our examples have been run in single-engine
    mode. What does that mean? Well, it tells us that the Docker installation is managed
    directly and as a standalone Docker environment. While this is effective, it is
    not very efficient and it does not scale well. Of course, Docker understands the
    limitations and has provided a powerful solution to this problem. It is called
    Docker swarm. Docker swarm is a way to link Docker nodes together, and manage
    those nodes and the dockerized applications that run on them efficiently and at
    scale. Simply stated, a Docker swarm is a group of Docker nodes connected and
    managed as a cluster or swarm. Docker swarm is built into the Docker engine, so
    no additional installation is required to use it. When a Docker node is part of
    a swarm, it is running in swarm mode. If there is any doubt, you can easily check
    whether a system running Docker is part of a swarm or is running in single-engine
    mode using the `docker system info` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9e0e8cfa-39dd-47f7-a668-80354184afee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The features that provide swarm mode are part of the Docker SwarmKit, which
    is a tool for orchestrating distributed systems at scale, that is, Docker swarm
    clusters. Once a Docker node joins a swarm, it becomes a swarm node, becoming
    either a Manager node or a Worker node. We will talk about the difference between
    managers and workers shortly. For now, know that the very first Docker node to
    join a new swarm becomes the first Manager, also known as the Leader. There is
    a *lot* of technical magic that happens when that first node joins a swarm (actually,
    it creates and initializes the swarm, and then joins it) and becomes the leader.
    Here is some of the wizardry that happens (in no particular order):'
  prefs: []
  type: TYPE_NORMAL
- en: A Swarm-ETCD-based configuration database or cluster store is created and encrypted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutual TLS (mTLS) authentication and encryption is set up for all inter-node
    communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container orchestration is enabled, which takes responsibility for managing
    which containers run on which nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cluster store is configured to automatically replicate to all manager nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The node gets assigned a cryptographic ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Raft-based distributed consensus-management system is enabled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The node becomes a Manager and is elected to the status of swarm leader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The swarm managers are configured for HA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A public-key infrastructure system is created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The node becomes the certificate authority, allowing it to issue client certificates
    to any nodes that join the swarm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A default 90-day certificate-rotation policy is configured on the certificate
    authority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The node gets issued its client certificate, which includes its name, ID, the
    swarm ID, and the node's role in the swarm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new cryptographic join token for adding new swarm managers occurs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new cryptographic join token for adding new swarm workers occurs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That list represents a lot of powerful features that you get by joining the
    first node to a swarm. And, with great power comes great responsibility, meaning
    that you really need to be prepared to do a lot of work to create your Docker
    swarm, as you might well imagine. So, let's move on to the next section, where
    we will discuss how to enable all of these features when you set up a swarm cluster.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the following links for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: The repository for SwarmKit: [https://github.com/docker/swarmkit](https://github.com/docker/swarmkit)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Raft consensus algorithm: [https://raft.github.io/](https://raft.github.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up a Docker swarm cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have just learned about all of the incredible features that get enabled
    and set up when you create a Docker swarm cluster. So, now I am going to show
    you all of the steps needed to set up a Docker swarm cluster. Are you ready? Here
    they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What? Wait? Where is the rest of it? Nope. There is nothing missing. All of
    the setup and functionality that is described in the preceding section is achieved
    with one simple command. With that single `swarm init` command, the swarm cluster
    is created, the node is transformed from a single-instance node into a swarm-mode
    node, the role of manager is assigned to the node and it is elected as the leader
    of the swarm, the cluster store is created, the node becomes the certificate authority
    of the cluster and assigns itself a new certificate that includes a cryptographic
    ID, a new cryptographic join token is created for managers, and another is created
    for workers, and on and on. This is complexity made simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'The swarm commands make up another Docker management group. Here are the swarm-management
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/bd6dff1c-08fb-4b1b-9361-ad8741316fff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll review the purpose for each these commands in just a moment, but before
    we do, I want to make you aware of some important networking configurations. We
    will talk more about Docker networking in [Chapter 6](873454a4-2f8e-42df-93ab-7648545167bb.xhtml),
    *Docker Networking*, but for now be aware that you may need to open access to
    some protocols and ports on your Docker nodes to allow Docker swarm to function
    properly. Here is the information straight from Docker''s *Getting started with
    swarm mode* wiki:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4a75151b-36db-43db-b9e7-ab46c7288927.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Two other ports that you may need to open for the REST API are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: TCP 2375 for Docker REST API (plain text)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP 2376 for Docker REST API (ssl)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alright, let's move on to reviewing the swarm commands.
  prefs: []
  type: TYPE_NORMAL
- en: docker swarm init
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have already seen what the init command is for, that being to create the
    swarm cluster, add (this) the first Docker node to it, and then set up and enable
    all of the swarm features we just covered. The init command can be as simple as
    using it with no parameters, but there are many optional parameters available to
    fine-tune the initialization process. You can get a full list of the optional
    parameters, as usual, by using `--help`, but let''s consider a few of the available
    parameters now:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--autolock`: Use this parameter to enable manager autolocking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--cert-expiry duration`: Use this parameter to change the default validity
    period (of 90 days) for node certificates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--external-ca external-ca`: Use this parameter to specify one or more certificate-signing
    endpoints, that is, external CAs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: docker swarm join-token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you initialize the swarm by running the `swarm init` command on the first
    node, one of the functions that is executed creates unique cryptographic join
    tokens, one joins additional manager nodes, and one joins worker nodes. Using
    the `join-token` command, you can obtain these two join tokens. In fact, using
    the `join-token` command will deliver the full join command for whichever role
    you specify. The role parameter is required. Here are examples of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2f9b447e-3447-40f2-8449-5f4d754a4182.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that this does not invalidate existing workers that have used the old,
    now invalid, join token. They are still a part of the swarm and are unaffected
    by the change in the join token. Only new nodes that you wish to join to the swarm
    need to use the new token.
  prefs: []
  type: TYPE_NORMAL
- en: docker swarm join
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have already seen the join command used in the preceding *docker swarm
    join-token* section. The join command is used, in conjunction with a cryptographic
    join token, to add a Docker node to the swarm. All nodes except the very first
    node will use the join command to become part of the swarm (the first node uses
    the "init" command, of course). The join command has a few parameters, the most
    important of them being the `--token` parameter. This is the required join token,
    obtainable with the `join-token` command. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that the role is not needed for this command. This is because
    the token itself is associated with the role it has been created for. When you
    execute the join, the output provides an informational message telling you what
    role the node has joined as manager or worker. If you have inadvertently use a
    manager token to join a worker or vice versa, you can use the `leave` command
    to remove a node from the swarm, and then using the token for the actual desired
    role, rejoin the node to the swarm.
  prefs: []
  type: TYPE_NORMAL
- en: docker swarm ca
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `swarm ca` command is used when you want to view the current certificate
    for the swarm, or you need to rotate the current swarm certificate. To rotate
    the certificate, you would include the `--rotate` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `swarm ca` command can only be executed successfully on a swarm manager
    node. One reason you might use the rotate swarm certificate feature is if you
    are moving from the internal root CA to an external CA, or vice versa. Another
    reason you might need to rotate the swarm certificate is in the event of one or
    more manager nodes getting compromised. In that case, rotating the swarm certificate
    will block all other managers from being able to communicate with the manager
    that rotated the certificate or each other using the old certificate. When you
    rotate the certificate, the command will remain active, blocking until all swarm
    nodes, both managers and workers, have been updated. Here is an example of rotating
    the certificate on a very small cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2a03929d-d015-43f8-a233-3a03370983b6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since the command will remain active until all nodes have updated both the
    TLS certificate and the CA certificate, it can present an issue if there are nodes
    in the swarm that are offline. When that is a potential problem, you can include
    the `--detach` parameter, and the command will initiate the certificate rotation
    and return control immediately to the session. Be aware that you will not get
    any status as to the progress, success, or failure of the certificate rotation
    when you use the `--detach` optional parameter. You can use the node ls command
    to query the state of the certificates within the cluster to check the progress.
    Here is the full command you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ca rotate` command will continue trying to complete, either in the foreground,
    or in the background if detached. If a node was offline when the rotate is initiated,
    and it comes back online, the certificate rotation will complete. Here is an example
    of `node04` being offline when the rotate command was executed, and then a while
    later, after it came back on; check the status found it successfully rotated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5889e8b1-e526-4871-9c48-c0a45664a4c2.png)'
  prefs: []
  type: TYPE_IMG
- en: Another important point to remember is that rotating the certificate will immediately
    invalidate both of the current join tokens.
  prefs: []
  type: TYPE_NORMAL
- en: docker swarm unlock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may recall from the discussion regarding the `docker swarm init` command
    that one of the optional parameters that you can include with the `init` command
    is `--autolock`. Using this parameter will enable the autolock feature on the
    swarm cluster. What does that mean? Well, when a swarm cluster is configured to
    use auto-locking, any time the docker daemon of a manager node goes offline, and
    then comes back online (that is, is restarted) it is necessary to enter an unlock
    key to allow the node to rejoin the swarm. Why would you use the auto-lock feature
    to lock your swarm? The auto-lock feature helps to protect the mutual TLS encryption
    key of the swarm, along with the encrypt and decrypt keys used with the swarm''s
    raft logs. It is an additional security feature intended to supplement Docker
    Secrets. When the docker daemon restarts on the manager node of a locked swarm,
    you must enter the unlock key. Here is what using the unlock key looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/cb49b249-6ef8-4013-a8f4-a1aa987b8927.png)'
  prefs: []
  type: TYPE_IMG
- en: By the way, to the rest of the swarm, a manager node that has not been unlocked
    will report as down, even though the docker daemon is running. The swarm auto-lock
    feature can be enabled or disabled on an existing swarm cluster using the `swarm
    update` command, which we will take a look at shortly. The unlock key is generated
    during the swarm initialization and will be presented on the command line at that
    time. If you have lost the unlock key, you can retrieve it on an unlocked manager
    node using the `swarm unlock-key` command.
  prefs: []
  type: TYPE_NORMAL
- en: docker swarm unlock-key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `swarm unlock-key` command is much like the `swarm ca` command. The unlock-key
    command can be used to retrieve the current swarm unlock key, or it can be used
    to rotate the unlock key to a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the size of the swarm cluster, the unlock key rotation can take
    a while for all of the manager nodes to get updated.
  prefs: []
  type: TYPE_NORMAL
- en: It is a good idea to keep the current (old) key handy for a while when you rotate
    the unlock key, on the off-chance that a manager node goes offline before getting
    the updated key. That way, you can still unlock the node using the old key. Once
    the node is unlocked and receives the rotated (new) unlock key, the old key can
    be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: As you might expect, the `swarm unlock-key` command is only useful when issued
    on a manager node of a cluster with the auto-lock feature enabled. If you have
    a cluster that does not have the auto-lock feature enabled, you can enable it
    with the `swarm update` command.
  prefs: []
  type: TYPE_NORMAL
- en: docker swarm update
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several swarm cluster features that are enabled or configured when
    you initialize the cluster on the first manager node via the `docker swarm init`
    command. There may be times that you want to change which features are enabled,
    disabled, or configured after the cluster has been initialized. To accomplish
    this, you will need to use the `swarm update` command. For example, you may want
    to enable the auto-lock feature for your swarm cluster. Or, you might want to
    change the length of time that certificates are valid for. These are the types
    of changes you can execute using the `swarm update` command. Doing so might look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the list of settings that can be affected by the `swarm update` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4137a701-e2f1-4dd9-886a-7f344bcc1e65.png)'
  prefs: []
  type: TYPE_IMG
- en: docker swarm leave
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This one is pretty much what you would expect. You can remove a docker node
    from a swarm with the `leave` command. Here is an example of needing to use the
    `leave` command to correct a user error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4e74723e-4d0d-4f2a-8d68-ca2e556fe0a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Node03 was intended to be a manager node. I accidentally added the node as a
    worker. Realizing my error, I used the `swarm leave` command to remove the node
    from the swarm, putting it back into single instance mode. Then, using the *manager*
    join token, I re-added the node to the swarm as a manager. Phew! Crisis averted.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out these links for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with swarm mode tutorial: [https://docs.docker.com/engine/swarm/swarm-tutorial/](https://docs.docker.com/engine/swarm/swarm-tutorial/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `docker swarm init` command wiki doc: [https://docs.docker.com/engine/reference/commandline/swarm_init/](https://docs.docker.com/engine/reference/commandline/swarm_init/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `docker swarm ca` command wiki doc: [https://docs.docker.com/engine/reference/commandline/swarm_ca/](https://docs.docker.com/engine/reference/commandline/swarm_ca/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `docker swarm join-token` command wiki doc: [https://docs.docker.com/engine/reference/commandline/swarm_join-token/](https://docs.docker.com/engine/reference/commandline/swarm_join-token/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `docker swarm join` command wiki doc: [https://docs.docker.com/engine/reference/commandline/swarm_join/](https://docs.docker.com/engine/reference/commandline/swarm_join/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `docker swarm unlock` command wiki doc: [https://docs.docker.com/engine/reference/commandline/swarm_unlock/](https://docs.docker.com/engine/reference/commandline/swarm_unlock/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `docker swarm unlock-key` command wiki doc: [https://docs.docker.com/engine/reference/commandline/swarm_unlock-key/](https://docs.docker.com/engine/reference/commandline/swarm_unlock-key/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `docker swarm update` command wiki doc: [https://docs.docker.com/engine/reference/commandline/swarm_update/](https://docs.docker.com/engine/reference/commandline/swarm_update/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `docker swarm leave` command wiki doc: [https://docs.docker.com/engine/reference/commandline/swarm_leave/](https://docs.docker.com/engine/reference/commandline/swarm_leave/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more about Docker Secrets: [https://docs.docker.com/engine/swarm/secrets/](https://docs.docker.com/engine/swarm/secrets/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managers and workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed swarm managers a little in the previous sections, but let's
    take a closer look at what swarm managers do. The swarm managers do exactly what
    you would expect. They manage and maintain the state of the swarm cluster. They
    schedule swarm services, which we will talk about in *Swarm services* section
    of this chapter, but for now, think of swarm services as running containers. Manager
    nodes also serve up the API endpoints of the cluster, allowing for programmatic
    access via REST. Managers also direct traffic to the running services so that
    any container can be reached through any manager node without having to know which
    node is actually running the containers. As part of maintaining the state of the
    cluster, the managers will deal with the loss of nodes in the system, electing
    a new leader node in the event that the manager lost was the leader, and they
    will keep the desired number of service containers running if containers or nodes
    go down.
  prefs: []
  type: TYPE_NORMAL
- en: The best practices for the number of manager in a swarm are three, five, or
    seven. You'll note that all of these options represent an odd number of manager
    nodes. This is so that if the leader node is lost, the raft consensus algorithm
    can more easily select a new leader for the swarm. You can run a swarm cluster
    with one manager node, and that is actually a better option than having two manager
    nodes. But, for a much more highly available swarm cluster, it is recommended
    that you have at least three manager nodes. For larger clusters, having five or
    seven managers is good, but it is not recommended to have more than seven. Once
    you have more than seven managers in the same cluster, you actually experience
    degraded performance.
  prefs: []
  type: TYPE_NORMAL
- en: Another important consideration for the manager nodes is the network performance
    between them. Managers need a low-latency network connection for optimal performance.
    If you are running your swarm in AWS, for example, you probably don't want the
    managers within a swarm spread across regions. You would likely encounter issues
    with the swarm if you were to do so. If you put the managers within a swarm in
    different availability zones within a single region, you shouldn't have any network-performance-related
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: Worker nodes don't do anything except run containers. They don't have a say
    in electing new leaders when the leader node goes down. They don't handle API
    calls. They don't direct traffic. They do nothing but run containers. In fact,
    you can't have a swarm with just a worker node. On the other hand, you can have
    a swarm with just a manager node, in which case the manager will also act as a
    worker and run containers in addition to its manager duties.
  prefs: []
  type: TYPE_NORMAL
- en: 'All manager nodes are actually worker nodes as well by default. This means
    that they can and will run containers. If you want to keep your managers from
    running workloads, you need to change the node''s availability setting. Changing
    it to draining will carefully stop any running containers on the manager node
    marked as draining, and will start up those containers on other (non-draining)
    nodes. No new container workloads will be started on a node in drain mode, for
    example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There may be times when you want or need to change the role of a docker node
    in the swarm. You can promote a worker node to manager status, or you can demote
    a manager node to worker status. Here are some examples of these activities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check out the official documentation on how nodes work at [https://docs.docker.com/engine/swarm/how-swarm-mode-works/nodes/](https://docs.docker.com/engine/swarm/how-swarm-mode-works/nodes/).
  prefs: []
  type: TYPE_NORMAL
- en: Swarm services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Alright. Now you know a lot about setting up a Docker swarm cluster, and how
    its nodes go from single-engine mode into swarm mode. You also know that the significance
    of that is to free you from directly managing individual running containers. So,
    you may be starting to wonder, if I don''t manage my containers directly and individually
    now, how do I manage them? You''ve come to the right place! This is where swarm
    services come into play. swarm services allow you to define the desired state
    for your container application in terms of how many concurrent running copies
    of the container there should be. Let''s take a quick look at what commands are
    available to us in the management group for swarm services, and then we''ll talk
    about those commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/430b9977-6481-4879-916d-7a80e747488a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first thing that you''ll probably want to do is create a new service, so
    we will begin our swarm services discussion with the `service create` command.
    Here is the syntax and a basic sample of the `service create` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'OK. Let''s break down the sample `service create` command shown here. First,
    you have the management group service followed by the `create` command. Then,
    we start getting into the parameters; the first one is `--replicas`. This defines
    the number of copies of the container that should be run concurrently. Next, we
    have the `--name` parameter. This one is pretty obvious and is the name of the
    service we are creating, in this case, `submarine`. We will be able to use the
    stated name in other service commands. After the name parameter, we have the fully-qualified
    Docker image name. In this case, it is just `alpine`. It could have been something
    such as `alpine:3.8`, or `alpine:latest`, or something more qualified such as
    `tenstartups/alpine:latest`. Following the image name to use for the service is
    the command to use when running the container and the parameters to pass to that
    command—`ping` and `google.com`, respectively. So, the preceding sample `service
    create` command will launch a single container from the `alpine` image, which
    will run the `ping` command with the google.com parameter, and then name the service
    `submarine`. Here is what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3701eca6-03c6-412d-8dfd-49676e2fb619.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You now know the basics of creating docker services. But, before you get too
    excited, there''s still a lot of ground to cover for the `service create` command.
    In fact, this command has so many options that listing them all out would take
    two pages in this book. So, rather than do that, I want you to use the `--help`
    feature and enter the following command now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: I know, right? There are a *lot* of optional parameters you can use. Don't worry.
    I'm not going to leave you out to dry here. I'll give you some guidance to help
    you get a firm foundation for creating services, and then you can branch out and
    try some of the other parameters you see in `--help`.
  prefs: []
  type: TYPE_NORMAL
- en: Just so you know, the two parameters we used so far, `--replicas` and `--name`,
    are both optional. If you don't provide a number of replicas to use, the service
    will be created with a default of 1\. Also, if you don't provide a name for the
    service, a fanciful name will be made up and given to the service. This is the
    same type of default naming we saw when using the `docker container run` command
    in [Chapter 2](e66034ed-dcc0-48a8-a2ec-9466669e6649.xhtml), *Learning Docker Commands*.
    It is generally better to provide both of these options for each `service create`
    command issued.
  prefs: []
  type: TYPE_NORMAL
- en: Also, know that generally speaking, the command and command parameters for the
    image that were supplied in the preceding sample are optional as well. In this
    specific case, they are necessary because, by itself, a container run from the
    alpine image with no other command or parameters supplied will just exit. In the
    sample, that would show up as a failure to converge the service and Docker would
    perpetually try to restart the service. Stated another way, you can leave off
    the command and its parameters if the image being used has them built in (such
    as in the `CMD` or `ENTRYPOINT` instruction of the Dockerfile).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to some more create parameters now. You should recall from [Chapter
    2](e66034ed-dcc0-48a8-a2ec-9466669e6649.xhtml), *Learning Docker Commands* that
    there is a `--publish` parameter you can use on a `docker container run` command
    that defines the port exposed on the docker host and the port in the container
    that the host port is mapped to. It looked something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, you need the same functionality for a swarm service, and in their wisdom,
    Docker made the parameter used for both the `container run` command and the `service
    create` command the same: `--publish`. You can use the same abbreviated format
    we saw before, `--publish 8080:80`, or you can use a more verbose format: `--publish
    published=8080`, `target=80`. This still translates to redirect host traffic from
    port `8080` to port 80 in the container. Let''s try out another example, this
    time one that uses the `--publish` parameter. We''ll give the `nginx` image another
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This example will create a new service that runs three container replicas,
    using the `nginx` image and exposing port `80` on the containers and port `8080`
    on the hosts. Have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d43881b1-4d53-443c-916e-bb51f16581d8.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, you're getting there. Let's quickly cover three more parameters and you
    will be ready to take on the world (of swarm services, at least). First up, `--restart-window`.
    This parameter is used to tell the Docker daemon how long to wait for the container
    to start up its application before testing to see whether it is healthy. The default
    is five seconds. If you create an app in your container that will take more than
    five seconds to start up and report as healthy, you will want to include a `--restart-window`
    parameter with your `service create`. Next up, `--restart-max-attempts`. This
    parameter tells the Docker daemon how many times to keep trying to start a container
    replica that is not reporting as healthy before giving up. The default is *Never
    give up*. *Never surrender*! Finally, let's talk about the `--mode` parameter.
    The default mode for a swarm service is *replicated*. That means the Docker daemon
    will continue to stand up containers for your service until the number of concurrently
    running containers is equal to the value you provided in the `--replicas` parameter
    (or 1 if you don't provide the parameter). For example, with a `--replicas 3` parameter,
    you will get three containers running in the swarm for your service. There is
    another mode, called **global**. If you provide the `--mode global` parameter
    when you create your service, the Docker daemon will stand up exactly one container
    on every node in the cluster. If you have a six-node cluster, you will end up
    with six containers running, one per node. With a 12-node cluster, you get 12
    containers, and so on. This is a very handy option when you have services that
    provide functionality for each host, such as a monitoring app or log forwarder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review some of the other service commands you will want to know and
    use. Once you''ve created some services, you might want a list of those services.
    This can be achieved with the `service list` command. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have reviewed the list of running services, you might want more details
    about one or more of those services. To achieve this, you would use the `service
    ps` command. Have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a service has outlived its usefulness, you might want to terminate it.
    The command to do that is the `service remove` command. Here is what that looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to remove all of the services running in the swarm, you can combine
    some of these commands and execute something such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if you realize that the number of replicas currently configured is
    not set to the desired number, you can use the `service scale` command to adjust
    it. Here is how you do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](Images/354cacd5-2139-4ad7-acb7-abb6cc0f00fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That should be enough to keep you busy for a while. Before we move on [Chapter
    6](873454a4-2f8e-42df-93ab-7648545167bb.xhtml), *Docker Networking*, let''s cover
    one more topic in this chapter: accessing your container applications running
    in a swarm.'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read more about the Docker service create reference at [https://docs.docker.com/engine/reference/commandline/service_create/](https://docs.docker.com/engine/reference/commandline/service_create/).
  prefs: []
  type: TYPE_NORMAL
- en: Accessing container applications in a swarm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, now you have a swarm running with an odd number of manager nodes, and a
    number of worker nodes. You have deployed some swarm services to run your favorite
    containerized applications. What's next? Well, you just might want to access one
    or more of the applications running in your swarm. Perhaps you have deployed a
    web server application. It would be nice to be able to visit the web pages shared
    by that web server, right? Let's take a quick look and see how easy it is to do
    so.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the features that the swarm managers handle for us is to direct traffic
    to our services. In an earlier example, we set up a web service that was running
    three replicas in the swarm. The swarm I am currently using happens to have three
    manager nodes and three worker nodes. All six nodes are eligible to run workloads
    so when the service is started, three of the six nodes will end up running a container.
    If we take a look at the details of the tasks of the service using the `service
    ps` command, you can see which of the six nodes are running the web-service containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f42332f8-0d66-4aab-a195-d99bd73fc86a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, you can see that the web service containers are running on
    node 01, 02, and 04\. The wonderful thing is that you don''t need to know which
    nodes are running your service containers. You can access the service via any
    node in the swarm. Of course, you would expect to be able to access the container
    on node 01, 02, or 04, but have a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/63e01e66-7ca6-4121-9a4c-b653f2b773cb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is an unfortunate side-effect of having the ability to access a service
    from any node in the swarm. Can you think of what it might be? I won''t keep you
    in suspense for long. The side effect is that you can only assign a (host) port
    to one service in the swarm. In our example, we are using port `8080` for our
    web service. That means that we cannot use port `8080` for the host port of any
    other service we want to run in this swarm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/71ca5156-7db9-4eb0-ad77-00a558c82bdc.png)'
  prefs: []
  type: TYPE_IMG
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the following links for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: Wiki doc with a very detailed overview of deploying services on a swarm: [https://docs.docker.com/v17.09/engine/swarm/services/](https://docs.docker.com/v17.09/engine/swarm/services/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How services work: [https://docs.docker.com/engine/swarm/how-swarm-mode-works/services/](https://docs.docker.com/engine/swarm/how-swarm-mode-works/services/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker's getting started with swarm mode training: [https://docs.docker.com/v17.09/engine/swarm/swarm-tutorial/](https://docs.docker.com/v17.09/engine/swarm/swarm-tutorial/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we finally started to pull some of the pieces together and
    make some fun stuff happen. We learned how much functionality we get by enabling
    swarm mode, and creating a swarm cluster. And, we found out just how easy it is
    to set everything up, using one single `swarm init` command. Then, we learned
    how to grow and manage our swarm cluster, and finally, we learned how to run our
    containers as services within our new swarm cluster. It's been fun, right?!
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take things to the next level. In [Chapter 6](873454a4-2f8e-42df-93ab-7648545167bb.xhtml),
    *Docker Networking*, we'll learn about Docker Networking. If you're ready for
    more good stuff, turn the page.
  prefs: []
  type: TYPE_NORMAL
