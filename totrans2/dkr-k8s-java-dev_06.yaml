- en: Running Containers with Java Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 5](text00084.html) , *Creating Images with Java Applications* ,
    we learned about the structure of a Dockerfile and how to build our images. At
    this point, you should be able to create your own Docker image and start using
    it. Actually, we did run the containers several times, but without getting much
    into details. We built the image manually, using a Dockerfile, and then issuing
    a `docker build` command. We have also been using Maven to automate the build
    process. The image we have created contains our simple REST Java service. We''ve
    already been running it for the purpose of checking if it really works. This time,
    however, we are going into some more detail about running the containers from
    our images. This chapter will include the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting and stopping containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container running modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container restart policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runtime constraints on resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running containers using Maven
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting and stopping containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go back a little and begin with the basics: how to run and stop the
    Docker container manually, from the shell or the command line.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have seen in the previous chapters, to spin-up the container from the
    image, we use the `docker run` command. The running container will have its own
    file system, networking stack, and isolated process tree separate from the host.
    As you will remember from [Chapter 5](text00084.html) , *Creating Images with
    Java Applications* , every single `docker run` command creates a new container
    and executes a command specified in the Dockerfile, `CMD` , or `ENTRYPOINT` .
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the `docker run` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The command takes the image name, with the optional `TAG` or `DIGEST` . If you
    skip the `TAG` and `DIGEST` command parameters, Docker will run the container
    based on the image tagged `latest` . The `docker run` command also takes a set
    of possible options you may find useful, such as the runtime mode, detached or
    foreground, network settings, or runtime restrictions on CPU and memory. We are
    going to cover these later in this chapter. Of course, you can execute the `docker
    run` command without almost any arguments except the image name. It will run and
    take the default options defined in the image. Specifying options gives you the
    chance to override the options specified by the author of the image and also runtime
    defaults of the Docker engine.
  prefs: []
  type: TYPE_NORMAL
- en: The `COMMAND` parameter is not mandatory, the author of the image may have already
    provided a default `COMMAND` using the `CMD` instruction in the `Dockerfile` .
    The `CMD` occurs only once in a Dockerfile and it's usually the last instruction.
    When starting the container from an image, we can override the `CMD` instruction,
    simply by providing our own command or parameters as the `COMMAND` parameter for
    the `docker run` . Anything that appears after the image name in the `docker run`
    command will be passed to the container and treated as `CMD` arguments. If the
    image also specifies an `ENTRYPOINT` then the `CMD` or `COMMAND` gets appended
    as an argument to the `ENTRYPOINT` . But guess what, we can override the `ENTRYPOINT`
    as well, using the `--entrypoint` option for the `docker run` command.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To stop one or more running Docker containers we use the `docker stop` command.
    The syntax is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can specify one or more container to stop. The only option for `docker
    stop` is `-t` (`--time` ) which allows us to specify a time to wait before stopping
    a container. 10 seconds is the default value, which is supposed to be enough for
    the container to gracefully stop. To stop the container in a more brutal way,
    you can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s the difference between `docker stop` and `docker kill` ? They will
    both stop a running container. There''s an important difference though:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker stop` : The main process inside the container will first receive a
    `SIGTERM` , and after a grace period, a `SIGKILL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker kill` : The main process inside the container will be sent `SIGKILL`
    (by default) or any signal specified with option `--signal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, `docker stop` attempts to trigger a graceful shutdown by sending
    the standard POSIX signal `SIGTERM` , whereas `docker kill` just brutally kills
    the process and, therefore, shuts down the container.
  prefs: []
  type: TYPE_NORMAL
- en: Listing the running containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To list the running containers, simply execute the `docker ps` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To include all containers present on your Docker host, include the `-a` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also filter the list using `-f` option to specify a filter. The filter
    needs to be provided as a `key=value` format. Currently available filters include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id` : Filters by the container''s id'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`label` : Filters by label'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` : Filters by the container''s name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exited` : Filters by the container''s exit code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status` : Filters by status, which can be created, restarting, running, removing,
    paused, exited or dead'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volume` : When specified with volume name or mount point will include containers
    that mount specified volumes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`network` : When specified with network id or name, will include containers
    connected to the specified network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following example, which will take all containers present on the
    Docker host and filter them out by running status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Removing the containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To remove the container from the host, we use the `docker rm` command. The
    syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can specify a single container or more containers at once. If you are running
    short-term foreground processes over and over many times, these file systems can
    grow rapidly in size. There''s a solution for that: instead of cleaning manually
    by hand, tell Docker to automatically clean up the container and remove the file
    system when the container exits. You do this by adding the `--rm` flag, so that
    the container data is removed automatically after the process has finished.'
  prefs: []
  type: TYPE_NORMAL
- en: '`--rm` flag will make Docker remove container after it has been shut down.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, use the `run` command as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command tells Docker to remove the container if it's shut down.
  prefs: []
  type: TYPE_NORMAL
- en: When starting a Docker container, you can decide if you want to run the container
    in the default mode, in the foreground, or in the background, in the so called
    detached mode. Let's explain what the difference is.
  prefs: []
  type: TYPE_NORMAL
- en: Container running modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker has two container running modes, foreground and detached. Let's begin
    with the default one, the foreground mode.
  prefs: []
  type: TYPE_NORMAL
- en: Foreground
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the foreground mode, the console you are using to execute `docker run` will
    be attached to standard input, output, and error streams. This is the default;
    Docker will attach `STDIN` , `STDOUT` and `STDERR` streams to your shell console.
    If you need to, you can change this behavior and use the `-a` switch for the `docker
    run` command. As a parameter for the `-a` switch, you use the name of the stream
    you want to attach to the console. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will attach both `stdin` and `stdout` streams to your
    console.
  prefs: []
  type: TYPE_NORMAL
- en: 'The useful `docker run` options are the `-i` or `--interactive` (for keeping
    `STDIN` stream open, even if not attached) and `-t` or `-tty` (for attaching a
    `pseudo-tty` ) switches, commonly used together as `-it` which you will need to
    use to allocate a `pseudo-tty` console for the process running in the container.
    Actually, we used this option in [Chapter 5](text00084.html) , *Creating Images
    with Java Applications* , when we were running our REST service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Simply speaking, the `-it` is used combined to attach the command line to the
    container after it has started. This way you can see what's going on in the running
    container in your shell console and interact with the container, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Detached
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can start a Docker container in detached mode with a `-d` option. It''s
    the opposite of the foreground mode. The container starts up and runs in background,
    the same as a daemon or a service. Let''s try to run our rest-example in the background,
    executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After the container starts, you will be given a control and can use a shell
    or command line for executing other commands. Docker will just output the container
    ID, as you can see on the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00074.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can use the container ID to reference the container in other docker commands,
    for example, if you need to stop the container or attach to it. Our service, while
    sitting in the background, still works: the Spring Boot application listens on
    port `8080` for `HTTP` `GET` or `POST` requests. Take note that containers started
    in detached mode stop when the root process used to run the container exits. Understanding
    this is important, even if you have some process running in the background (started
    from the instruction in the Dockerfile), Docker will stop the container if the
    command that started the container finishes. In our case, Spring Boot application
    is running and listening, and, at the same time, prevents Docker from shutting
    down the container. To bring the container back from the background into the foreground
    of your console, you will need to attach to it.'
  prefs: []
  type: TYPE_NORMAL
- en: Attaching to running containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To retain control over a detached container, use `docker attach` command. The
    syntax for `docker attach` is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case this would be the ID we were given, when the container was started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'At this time, if there is something that gets printed out, such as another
    log line from our running REST service, you will see it on the console. As you
    can see, the `docker attach` command can come in handy if you need to see what
    is written to the `stdout` stream in real time. It will basically *reattach* your
    console to the process running in the container. In other words, it will stream
    the `stdout` into your screen and map the `stdin` to your keyboard, allowing you
    to enter the commands and see their output. Note that pressing the *CTRL + C*
    keyboard sequence while being attached to the container would kill the running
    process of the container, not detach from the console. To detach from the process
    use the default *CTRL+P* and *CTRL+Q* keyboard sequence. If the *CTRL + P* and
    *CTRL + Q* sequence clashes with your existing keyboard shortcuts, you can provide
    your own detach sequence by setting the `--detach-keys` option for the `docker
    attach` command. If you would like to be able to detach using *CTRL + C* , you
    may tell Docker not to send `sig-term` to the process running in the container
    by using the `sig-proxy` parameter set to `false` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If the container is running in the background, it would be nice to be able to
    monitor its behavior. Docker provides a set of features for doing that. Let's
    see how we can monitor running containers.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some ways of monitoring running Docker containers. It can be viewing
    the log files, looking at the container events and statistics, and also inspecting
    container properties. Let's begin with the powerful logging features Docker has.
    Access to the log entries is crucial, especially if you have your container running
    in the detached runtime mode. Let's see what Docker can offer when it comes to
    a logging mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most applications output their log entries to the standard `stdout` stream.
    If the container is being run in the foreground mode, you will just see it in
    the console. However, when running a container in detached mode, you will see
    nothing but the container ID on the console. However, the Docker engine collects
    all the `stdout` output from a running container in a history file on the host.
    You can display it by using the `docker logs` command. The syntax of the command
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker logs` command will output just a few last lines of the log into
    the console. As the container still works in the background (in detached mode),
    you will be given the prompt back immediately, as you can see on the following
    screenshot, presenting a fragment of the logfile from our REST service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `-f` flag acts as the same flag in Linux `tail` command, it will continuously
    display new log entries on the console. When you are done, hit *CTRL + C* to stop
    displaying log files on the console. Note that this is different from hitting
    *CTRL + C* when attached to the container, where *CTRL + C* would kill the process
    running within the container. This time, it will just stop displaying the log
    file and it's safe.
  prefs: []
  type: TYPE_NORMAL
- en: The log file is permanent and available even after the container stops, as long
    as its file system is still present on disk (until it is removed with the `docker
    rm` command). By default, the log entries are stored in a JSON file located in
    the `/var/lib/docker` directory. You can see the complete path of the log file
    using the `docker inspect` command and using a template to extract the `LogPath`
    (we are going to cover `inspect` and templates in a while).
  prefs: []
  type: TYPE_NORMAL
- en: 'We have said that, by default, the log entries will go to the JSON file. But
    this can be easily changed, because Docker utilizes the concept of logging drivers.
    By using different drivers, you can pick other storage for your containers log.
    The default driver is the `json-file` driver, which just writes out the entries
    into the JSON file. Each driver can take additional parameters. The JSON driver
    accepts, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you may have guessed, it's similar to a rolling file in our Java applications.
    The `max-size` specifies the maximum file size that can be created; after reaching
    the specified size, Docker will create a new file. You can use the size suffixes
    `k` , `m` , or `g` , where k will be for kilobytes, `m` for megabytes and `g`
    for gigabytes. Splitting a log into separate files makes it easier to transfer,
    archive, and so on. Also, searching through the log file is a lot more convenient
    if the file is smaller.
  prefs: []
  type: TYPE_NORMAL
- en: The `docker log` command only displays log entries from the latest log file.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some other log drivers available. The list includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`none` : It will just switch off logging completely'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`syslog` : It''s a `syslog` logging driver for Docker. It will write log messages
    to the system `syslog`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`journald` : Will log messages to `journald` . `systemd-journald` is a daemon
    responsible for event logging, with append-only binary files serving as its logfiles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`splunk` : Provides the writing of log messages to Splunk using `Event Http`
    Collector. Splunk can be used as an enterprise-grade log analyzer. You can read
    more about it at [https://www.splunk.com](https://www.splunk.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gelf` : Will write log entries into a GELF endpoint such as Graylog or Logstash.
    Graylog, available at [https://www.graylog.org](https://www.graylog.org) , is
    an open source log management, supporting search, analysis, and alerting across
    all of your log files. Logstash, which you can find at [https://www.elastic.co/products/logstash](https://www.elastic.co/products/logstash)
    , is a pipeline for processing any data (including log data) from any source'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fluentd` : Writes log messages to `fluentd` . Fluentd is an open source data
    collector for a unified logging layer. The main feature of Fluentd is that it
    separates data sources from backend systems by providing a unified logging layer
    in between. It''s small, fast and has hundreds of plugins that make a very flexible
    solution out of it. You can read more about `fluentd` on its website at [https://www.fluentd.org](https://www.fluentd.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gcplogs` : Will send the log entries to Google Cloud logging'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`awslogs` : This driver will write log messages to the Amazon CloudWatch logs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, again, the Docker''s pluggable architecture gives you almost
    infinite flexibility when running the container. To switch to the other log driver,
    use the `--log-driver` option for the `docker run` command. To store log entries
    in the `syslog` for example, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `docker logs` command works only for the `json-file` and `journald`
    drivers. To access logs written to another log engine, you will need to use the
    tool matching the driver you have chosen. It will often be more convenient to
    use the specialized tool for browsing log entries; actually, this is often the
    reason you choose another logging driver. For example, searching and browsing
    the logs in Logstash or Splunk is way faster than digging though the text files
    full of JSON entries.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the log entries is the convenient way of monitoring how our application
    behaves on the host. Sometimes, it could be also nice to see the properties of
    the running containers, as the mapped network port or volume being mapped and
    so on. To display the container properties, we use the `docker inspect` command,
    which is extremely useful.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `docker ps` command we have been using to list the running containers gives
    us a lot of information about containers, such as their IDs, uptime, mapped ports,
    and so on. To display more details about the running container, we can user `docker
    inspect` . The syntax of the command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the `docker inspect` command will output information about the
    container or image in a JSON array format. Because there are many properties,
    it may not be very readable. If we know what we are looking for, we can provide
    a template for processing the output, using the `-f` (or `--format` ) option.
    The template uses the template format coming from the Go language (Docker itself
    is written in Go, by the way). The simplest and the most often used template for
    the `docker inspect` command is just a short template to extract exactly the information
    you need, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As the `inspect` command accepts the Go template to form the output of the container
    or image metadata, this feature gives you almost infinite possibilities for processing
    and transforming the results. The Go templating engine is quite powerful, so,
    instead of piping the output through grep, which is quick but messy, you can use
    the template engine to further process the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument to `--format` is a just a template that we want to apply to the
    metadata of the container. In this template, we can use conditional statements,
    loops, and other Go language features. For example, the following will find the
    names of all containers with a non-zero exit code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we provide `$(docker ps -aq)` instead of the container ID or name.
    As a result, all of the running containers'' IDs will be piped to the `docker
    inspect` command, which can be quite a handy shortcut. The curly brackets `{{}}`
    mean Go template directives, anything outside of them will be printed out literally.
    The dot (`.` ) in Go templates means context. Most of the time the current context
    will be whole data structure for the metadata, but it can be rebound when needed,
    including using the `with` action. For example, these two `inspect` commands will
    print out exactly the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are inside the bound context, the dollar sign (`$` ) will always get
    you the `root` context. We can execute this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It will then output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The template engine supports logical functions, such as `and` , `or` and `not`
    ; they will return a boolean result. Also, the comparison functions are supported,
    such as `eq` (equals), `ne` (not equals), `lt` (less than), `le` (less than or
    equal to), `gt` (greater than), and `ge` (greater than or equal to). Comparison
    functions can compare strings, floats or integers. Together with the conditional
    functions such as `if` , all of these can be very useful when creating some more
    sophisticated output from the `inspect` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes the huge output of the `docker inspect` command can be quite confusing.
    Since the output comes in JSON format, the `jq` tool can be used to get an overview
    of the output and pick out interesting parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `jq` tool is available for free at [https://stedolan.github.io/jq/](https://stedolan.github.io/jq/)
    . It''s a lightweight and flexible command-line JSON processor, such as `sed`
    command for the JSON data. For example, let''s extract the container IP address
    from the metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `docker inspect` command provides useful information about
    Docker containers. Combined with the Go template features and optionally with
    the `jq` tool, it gives you a powerful tool to get the information about your
    containers and can be used further in scripting. But there's another source of
    valuable information apart from the metadata. It's runtime statistics, which we
    are going to focus on now.
  prefs: []
  type: TYPE_NORMAL
- en: Statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see the CPU, memory, disk i/o and network i/o statistics for containers,
    use the `docker stats` command. The syntax for the command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can limit the statistics measure to one or more specific containers by
    specifying a list of container IDs or names separated by a space. By default,
    if no containers are specified, the command will display statistics for all running
    containers, as you can see on the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00076.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `docker stats` command accepts options, which can include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--no-stream` : This will disable streaming stats and only pull the first result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-a` (`--all` ): This will show statistics for all (not only running) containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The statistics can be used to see if our containers behave well when running.
    The information can be useful to check if we need some constraints on the resources
    to be applied to containers, we are going to cover the runtime constraints in
    a while in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing logs, container metadata and runtime statistics, give you almost infinite
    possibilities when monitoring your running containers. Apart from this, we can
    see what's happening on your docker host globally. When the docker engine on the
    host receives a command, it will emit an event we can observe. Let's look at this
    mechanism now.
  prefs: []
  type: TYPE_NORMAL
- en: Container events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To observe the events coming to the docker engine in real time, we use the
    `docker events` command. If the container has been started, stopped, paused, and
    so on, the event will be published. This can be very useful if you would like
    to know what has happened during the container runtime. It''s a powerful monitoring
    feature. Docker containers report a huge list of events, which you can list with
    the `docker events` command. The list includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker events` command can take the `-f` switch, which will filter the
    output if you are looking for something specific. If no filter is provided, all
    events will be reported. Currently the list of possible filters includes:'
  prefs: []
  type: TYPE_NORMAL
- en: container (`container=<name or id>` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: event (`event=<event action>` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: image (`image=<tag or id>` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: plugin (experimental) (`plugin=<name or id>` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: label (`label=<key> or label=<key>=<value>` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: type (`type=<container or image or volume or network or daemon>` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: volume (`volume=<name or id>` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: network (`network=<name or id>)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: daemon (`daemon=<name or id>` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following example. The `docker events` command has been
    run in one console window, while the `docker run rest-example` has been issued
    in the separate console. As you can see in the following screenshot, `docker events`
    will report create, attach, connect and start events for our rest-example container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00077.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As a result, you will get a timestamp and the name of the event, together with
    the ID of the container that has caused an event. The `docker events` command
    can take additional options, such as `--since` and `--until` , which can be used
    to specify a timeframe that you want to get the events from. Monitoring container
    events is a great tool to see what's going on the docker host. However, there's
    more. You can also influence, how your containers behave in case of a crash, for
    example. We use container restart policies for that.
  prefs: []
  type: TYPE_NORMAL
- en: Restart policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By using the `--restart` option with the `docker run` command you can specify
    a restart policy. This tells Docker how to react when a container shuts down.
    The container then can be restarted to minimize downtime, for example if running
    on a production server. However, before we explain the Docker restart policy,
    let''s focus for a while on exit codes. The exit code is crucial information,
    it tells why the container failed to run or why it exited. Sometimes it''s related
    to the contained command you will give to the `docker run` as a parameter. When
    the `docker run` command ends with a non-zero code, the exit codes follow the
    `chroot` standard, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'exit code `125` : The `docker run` command fails by itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'exit code`126` : The supplied command cannot be invoked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'exit code `127` : The supplied command cannot be found'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other, non-zero, application dependent exit code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you may remember, in previous chapters we have been using the `docker ps`
    command to list running containers. To list the non-running containers as well,
    we can add the `-a` switch for the `docker ps` command. The exit code can be found
    in the output of the `docker ps -a` command in a Status column when a container
    completes. It''s possible to automatically restart crashed containers by specifying
    a restart policy when starting the container. Specifying the desired restart policy
    is done by the -restart switch for the `docker run` command, as in the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Currently Docker has four restart policies. Let''s get to know them now one
    by one, starting with the simplest: `no` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'no'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `no` policy is the default restart policy and simply will not restart a
    container under any case. Actually, you do not have to specify this policy, because
    this is the default behavior. Unless you have some configurable setup to run Docker
    containers, then the `no` policy can be used as an off switch.
  prefs: []
  type: TYPE_NORMAL
- en: always
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we wanted the container to be restarted no matter what exit code the command
    has, we can use the `always` restart policy. Basically, it does what it says;
    Docker will restart the container in every case. The restart policy will always
    restart the container. This is true, even if the container has been stopped before
    the reboot. Whenever the Docker service is restarted, containers using the always
    policy will also be restarted, it doesn't matter whether they were executing or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: With the `always` restart policy, the Docker daemon will try to restart the
    container **indefinitely.**
  prefs: []
  type: TYPE_NORMAL
- en: on-failure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a kind of special restart policy and probably the most often used. By
    using the `on-failure` restart policy, you instruct Docker to restart your container
    whenever it exits with a non-zero exit status and not restart otherwise. That's
    the reason we have begun explaining restart policies with the exit codes. You
    can optionally provide a number of times for Docker to attempt to restart the
    container. The syntax of this restart policy is also a little bit different, because
    using this policy, you can also specify a maximum number of tries that Docker
    will make to automatically restart the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will run the container with our REST service and will
    try to restart it five times in the case of failure before giving up. The main
    benefit of the `on-failures` restart policy is that, when an application exits
    with a successful exit code (that means there were no errors in the application;
    it just finished executing), the container will not be restarted. The number of
    restart tries for a container can be obtained via the `docker inspect` command
    we already know. For example, to get the number of restarts for a container with
    a specific ID or name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also discover the last time the container was started again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You should know that Docker uses a delay between restarting the container, to
    prevent flood-like protection. This is an increasing delay; it starts with the
    value of 100 milliseconds, then Docker will double the previous delay. In effect,
    the daemon will wait for 100 ms, then 200 ms, 400, 800 and so on, until either
    the `on-failure` limit is reached, or when you stop the container using `docker
    stop,` or execute the force removal by executing the `docker rm -f` command.
  prefs: []
  type: TYPE_NORMAL
- en: If a container is successfully restarted, the delay is reset to the default
    value of 100 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: unless-stopped
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, similar to `always` , if we want the container to be restarted regardless
    of the exit code, we can use `unless-stopped` . The `unless-stopped` restart policy
    acts the same as `always` with one exception, it will restart the container regardless
    of the exit status, but do not start it on daemon startup if the container has
    been put to a stopped state before. This means that with the `unless-stopped`
    restart policy, if the container was running before the reboot, the container
    would be restarted once the system restarted. When an application within a Docker
    container exits, that container will be also halted. If an application that is
    running within a container crashes, the container stops and that container will
    remain stopped until someone or something restarts it.
  prefs: []
  type: TYPE_NORMAL
- en: Before you apply the restart policy to your container, it's good to think first
    what kind of work the container will be used to do. That also depends on the kind
    of software that will be running on the container. A database, for example, should
    probably have the `always` or `unless-stopped` policy applied. If your container
    has some restart policy applied, it will be shown as `Restarting` or `Up` status
    when you list your container using the `docker ps` command.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a restart policy on a running container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, there''s a need to update the Docker runtime parameters after the
    container has already started, *on the fly* . An example would be if you want
    to prevent containers from consuming too many resources on the Docker host. To
    set the policy during runtime, we can use the `docker update` command. Apart from
    other runtime parameters (such as memory or CPU constraints for example, which
    we are going to discuss later in this chapter), the `docker update` command gives
    you the option to update the restart policy on a running container. The syntax
    is quite straightforward, you just need to provide the new restart policy that
    you would like the container to have and the container''s ID or name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'A new restart policy will take effect immediately after you run the `docker
    update` command on a container. On the other hand, if you execute the `update`
    command on a container that is stopped, the policy will be used when you start
    the container later on. The possible options are exactly the same as those you
    can specify when starting the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '`no` (which is default)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`always`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on-failure`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unless-stopped`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have more than one container running on the Docker host, and want to
    specify a new restart policy on all of them at once, just provide all of their
    IDs or names, separated by a space.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also see which restart policy was applied using the `docker events`
    command, which you already know from the previous section. The `docker events`
    which can be used to observe the history of runtime events that the container
    has reported, will also report the `docker update` event, providing you with details
    about what has changed. If the container has been applied the restart policy,
    the event will be published. If you want to check the restart policy of a running
    container use `docker inspect` with the container ID or name with the `--format`
    argument set for the path of the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The ability to set a restart policy on a container by container basis is great
    for those cases where your images are self-contained and you don't need to do
    more complex orchestration tasks. The restart policy is not the only parameter
    you can change on running containers.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime constraints on resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It may be useful to restrict the Docker container usage of resources when running.
    Docker gives you a many possibilities to set constraints on the memory, CPU usage
    or disk access usage. Let's begin with setting the memory constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's worth knowing that, by default, that is, if you use the default settings
    without any constraints, the running container can use all of the host memory.
    To change this behavior we can use the `--memory` (or `-m` for short) switch for
    the `docker run` command. It takes the usual suffixes `k` , `m` , or `g` for kilobytes,
    megabytes and gigabytes, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the `docker run` command with memory constraints set will be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will execute the Ubuntu image with the maximum memory
    that can be used by the container of half of a gigabyte.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not set the limit on memory that the container can allocate, this
    can lead to random issues where a single container can easily make the whole host
    system unstable and/or unusable. So it's a wise decision to always use the memory
    constraints on the container.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from user memory limit, there are also memory reservation and kernel memory
    constraints. Let's explain what a memory reservation limit is. Under normal working
    conditions, a running container can, and probably will, use as much of the memory
    as needed, up to the limit you have set using the `--memory` (`-m` ) switch for
    the `docker run` command. When memory reservation is applied, Docker will detect
    a low memory situation and will try to force the container to restrict its consumption
    up to a reservation limit. If you do not set the memory reservation limit, it
    will be exactly the same as the hard memory limit set with the `-m` switch.
  prefs: []
  type: TYPE_NORMAL
- en: Memory reservation is not a hard limit feature. There's no guarantee the limit
    won't be exceeded. The memory reservation feature will attempt to ensure that
    memory will be allocated, based on the reservation setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command sets the hard memory limit to `1g` , and then sets the
    memory reservation to half a gig. With those constraints set, when the container
    consumes memory more than `500M` and less than `1G` , Docker will attempt to shrink
    container memory less than `500M` .
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example we are going to set the memory reservation without setting
    the hard memory limit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, when the container starts, it can use as much memory
    as its processes need. The `--memory-reservation` switch setting will prevent
    the container from consuming too much memory for a long time, because every memory
    reclaim will shrink the container's memory usage to the size specified in the
    reservation.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel memory is something entirely different from the user memory, the
    main difference is that kernel memory can't be swapped out to disk. It includes
    stack pages, slab pages, sockets memory pressure and TCP memory pressure. You
    use the --kernel-memory switch to set up the kernel memory limit to constrain
    these kinds of memory. As with setting the user memory limit, just provide a number
    with a suffix such as `k` , `b` , and `g,` for kilobyte, megabyte or gigabyte
    respectively, although setting it in kilobytes may be a really rare case.
  prefs: []
  type: TYPE_NORMAL
- en: For example, every process eats some stack pages. By restricting kernel memory,
    you can prevent new processes from being started when the kernel memory usage
    is too high. In addition, because the host cannot swap the kernel memory to disk,
    the container can block the whole host service by consuming too much kernel memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting the kernel memory limit is straightforward. We can set the `--kernel-memory`
    alone, without limiting the total memory with `-m` , as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the process in the container can take memory as it
    needs, but it can only consume `100M` of kernel memory. We can also setup the
    hard memory limit, as in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, we set memory and kernel memory altogether, so the
    processes in the container can use `1G` memory in total, and this `1G` will include
    `100M` of the kernel memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more constraint related to the memory which can be useful when running
    containers, is the swappines constraint. We apply the constraint by using the
    `--memory-swappiness` switch to the `docker run` command. It can be helpful when
    you want to avoid performance drops related to memory swapping. The parameter
    for the `--memory-swappiness` switch is the percentage of anonymous memory pages
    that can be swapped out, so it takes values from `0` to `100` . Setting the value
    to zero, will, depending on your kernel version, disable swapping or use the minimal
    swap. In contrast, a value of `100` sets all anonymous pages as candidates for
    swapping out. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, we turn the swapping completely for our `ubuntu` container.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from setting the memory usage constraint, you can also instruct Docker
    how the processor power should be assigned to containers it's going to run.
  prefs: []
  type: TYPE_NORMAL
- en: Processors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By using the `-c` (or `--cpu-shares` as an equivalent) for the `docker run`
    command switch, it's possible to specify a value of shares of the CPU that a container
    can allocate. By default, every new container has 1024 shares of CPU and all containers
    get the same part of CPU cycles. This percentage can be altered by shifting the
    container's CPU share weighting relative to the weighting of all other running
    containers. But take note, that you cannot set the precise processor speed that
    a container can use. This is a **relative weight** and has nothing to do with
    the real processor speed. In fact, there is no way to say precisely that a container
    should have the right to use only 2 GHz of the host's processor.
  prefs: []
  type: TYPE_NORMAL
- en: CPU share is just a number, it's not related at all to the CPU speed.
  prefs: []
  type: TYPE_NORMAL
- en: If we start two containers and both will use 100% CPU, the processor time will
    be divided equally between the two containers. The reason for that is two containers
    will have the same number of processor shares. But if you constrain one container's
    processor shares to 512, it will receive just a half of the CPU time. This does
    not mean that it can use only half of the CPU; the proportion will only apply
    when CPU-intensive processes are running. If the other container (with `1024`
    shares) is idle, our container will be allowed to use 100% of the processor time.
    The real amount of CPU time will differ depending on the number of containers
    running on the system. It's easier to understand on a tangible example.
  prefs: []
  type: TYPE_NORMAL
- en: Consider three containers, one (let's call it `Container1` ) has `--cpu-shares`
    set for `1024` and two others (`Container2` and `Container3` ) have a `--cpu-shares`
    setting of `512` . When processes in all three containers attempt to use all of
    the CPU power, `Container1` will receive 50% of the total CPU time, because it
    has half of the CPU usage allowed in comparison to the sum of other running containers
    (`Container2` and `Container3` ). If we add a fourth container (`Container4` )
    with a `--cpu-share` of 1024, our first `Container1` will only get 33% of the
    CPU, because it now has one third of the total CPU power assigned, relatively.
    `Container2` will receive 16.5%, `Container3` also 16.5% and the last one, `Container4`
    , again, will be allowed to use 33% of the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the `-c` or `--cpu_shares` flag for the `docker run` command modifies
    the container''s CPU share weighting relative to the weighting of all other running
    containers, it does not restrict the container''s use of CPU from the host machine.
    But there''s another flag to limit the CPU usage for the container: `--cpu-quota`
    . Its default value is `100000` which means an allowance of 100% of the CPU usage.
    We can use the `--cpu-quota` to limit CPU usage , for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding command, the limit for the container will be 50% of a CPU
    resource. The `--cpu-quota` is usually used in conjunction with the `--cpu-period`
    flag for the `docker run` . This is the setting for the CPU CFS (Completely Fair
    Scheduler) period. The default period value is 100000 which is 100 milliseconds.
    Take a look at the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: It means that the container can get 50% of the CPU usage every 50 ms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Limiting CPU shares and usage is not the only processor-related constraint
    we can set on the container. We can also assign the container''s processes to
    a particular processor or processor core. The `--cpuset` switch of the `docker
    run` command comes in handy when we want to do this. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will run the `ubuntu` image and allow the container to
    use all four processor cores. To start the container and only allow usage of one
    processor core, you can change the `--cpuset` value to `1` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You can of course mix the option `--cpuset` with `--cpu_shares` to tweak you
    container's CPU constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Updating constraints on a running container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with the restart policies, the constraints can also be updated when the container
    is already running. This may be helpful, if you see your containers eating too
    much of the Docker host system resources and would like to limit this usage. Again,
    we use the `docker update` command to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with restart policies, the syntax for the `docker update` command will be
    the same as when starting the container, you specify the desired constraints as
    an argument for the docker update command and then give the container ID (taken
    from the `docker ps` command output for example) or its name. Again, if you would
    like to change the constraints on more than one container at once, just provide
    their IDs or names separated by a space. Let''s look at some examples of how to
    update constraints at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will limit the CPU shares to the value of 512\. Of course,
    you can apply CPU and memory constraints at the same time, to more than one container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will update CPU shares and memory limits to two containers,
    identified by `abbdef1231677` and `dabdff1231678` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, when updating the runtime constraints, you can also apply the desired
    restart policy in one single command, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the ability to set constraints gives you a lot of flexibility
    when running Docker containers. But it''s worth noting, that applying constraints
    is not always possible. The reason for that is the constraint setting features
    depend heavily of the internals of the Docker host, especially its kernel. For
    example, it''s not always possible to set up the kernel memory limit or `memory
    swappiness` for example, sometimes all you will get is `Your kernel does not support
    kernel memory limit or kernel does not support memory swappiness capabilities`
    messages. Sometimes those limitations can be configurable, sometimes not. For
    example if you get `WARNING: Your kernel does not support cgroup swap limit on
    Ubuntu` , you can tweak your Grub bootloader with the `cgroup_enable=memory swapaccount=1`
    setting in the Grub configuration file, this will be `/etc/default/grub` in Ubuntu,
    for example. It''s important to read logs printed out by Docker, to make sure
    your constraints are in place.'
  prefs: []
  type: TYPE_NORMAL
- en: Always take note of the warnings Docker outputs during the container startup
    or after updating your constraints on the fly, it may happen that your constraints
    will not take action!
  prefs: []
  type: TYPE_NORMAL
- en: We already know how to run and observe containers using the commands available
    from the command line. It's not very convenient, however, if you need to spin-up
    your containers during the development flow, for example for integration testing.
    The Fabric8 Docker Maven plugin we've been using in [Chapter 5](text00084.html)
    , *Creating Images with Java Applications* , to build images, comes in handy if
    we need to run containers, as well. Let's do it now.
  prefs: []
  type: TYPE_NORMAL
- en: Running with Maven
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The plugin provides two Maven goals related to starting and stopping containers.
    This will be `docker:start` and `docker:stop` . Containers are created and started
    with the `docker:start` and stopped and destroyed with the `docker:stop` . If
    you need to run the container during the integration tests, the typical use case
    will be to include those goals in Maven build phases: the `docker:start` will
    be bound to the `pre-integration-test` and `docker:stop` to the `post-integration-test`
    phase.'
  prefs: []
  type: TYPE_NORMAL
- en: Plugin configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The plugin uses the configuration from the `<run>` sub-element of the `<configuration>`
    in the `pom.xml` file. The list of the most important configuration elements is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `cmd` | Command which should be executed at the end of the container''s startup.
    If not given, the image''s default command is used. |'
  prefs: []
  type: TYPE_TB
- en: '| `entrypoint` | Entry point for the container. |'
  prefs: []
  type: TYPE_TB
- en: '| `log` | Log configuration for whether and how log messages from the running
    containers should be printed. This can also configure the log driver to use. |'
  prefs: []
  type: TYPE_TB
- en: '| `memory` | Memory limit in bytes |'
  prefs: []
  type: TYPE_TB
- en: '| n`amingStrategy` | Naming strategy for how the container name is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '`none` : Uses randomly assigned names from Docker (default)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alias` : Uses the alias specified in the image configuration. An error is
    thrown, if a container already exists with this name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `network` | The `<network>` element can be used to configure the network
    mode of the container. It knows the following sub elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<mode>` : The network mode, which can be one of the following values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bridge` : Bridged mode with the default Docker bridge (default)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`host` : Share the Docker host network interfaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container` : Connect to the network of the specified container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The name of the container is taken from the `<name>` element :'
  prefs: []
  type: TYPE_NORMAL
- en: '`custom` : Use a custom network, which must be created before using Docker
    network create'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`none` : No network will be setup'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `ports` | The`<ports>` configuration contains a list of port mappings. Each
    mapping has multiple parts, each separate by a colon. This is equivalent to the
    port mapping when using the `docker run` command with option `-p` .An example
    entry can look same as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `restartPolicy` | Provides a restart policy we''ve been discussing earlier
    in this chapter. An example entry can look same as following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `volumes` | Volume configuration for binding to host directories and from
    other containers. The example configuration could look same as following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete `<configuration>` element of our Java REST service can look same
    as following. This is a very basic example, we are only configuring the runtime
    port mapping here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Having configured our container, let's try to run it, using Maven.
  prefs: []
  type: TYPE_NORMAL
- en: Starting and stopping containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start-up the container, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Maven will build our REST service from source, build the image and start up
    the container in the background. As the output, we will be given the ID of the
    container, as you can see on the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00078.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The container is now running in the background. To test if it''s running, we
    could issue a `docker ps` to list all the running containers, or just call the
    service by executing some `HTTP` methods such as `GET` or `POST` on the mapped
    `8080` port. The port has been exposed in the`<build>` configuration element and
    exposed in the `<run>` configuration element. This is convenient, isn''t it? But
    what if we would like to see the container''s output instead of running it in
    the background? That''s also easy; let''s stop it first by issuing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'After 10 seconds (as you''ll remember, it''s a default timeout before stopping
    the container), Maven will output a statement that the container has been stopped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the container again, this time using the Maven `docker:run` goal
    instead of `docker:start` . Execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, Maven Docker plugin will run the container and we will see the Spring
    Boot banner on the console, as you can see on the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I guess you can identify the difference between `docker:start` and `docker:run`
    now. Correct, `docker:run` is the equivalent of option `-i` for the `docker run`
    command. The `docker:run` will also automatically switch on the `showLogs` option,
    so that you can see what is happening within the container. As an alternative,
    you can provide `docker.follow` as system property so that the `docker:start`
    will never return but block until *CTRL + C* is pressed, exactly the same as when
    you execute the `docker:run` Maven goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the Fabric8 Docker Maven plugin gives you the same control
    as you would have when running and stopping containers from the shell or the command
    line. But here comes the advantage of the Maven build process itself: you can
    automate things. The Docker containers can be now used during the build, the integration
    testing, and the continuous delivery flow you may have; you name it.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have learned how to manage the container's life, start it
    using different run modes (foreground and detached), stop or remove it. We also
    know how to create constraints to make our containers run exactly how we want
    them to, by limiting the CPU and RAM usage using runtime constraints. Having our
    containers running, we are now able to inspect the container's behavior in numerous
    ways, it will be reading log output, looking at events or browsing the statistics.
    If you are using Maven, and as the Java developer you probably are, you can now
    configure the Docker Maven plugin to start or stop containers for you automatically.
  prefs: []
  type: TYPE_NORMAL
- en: We know a lot about Docker already, we can build and run images. It's time to
    go further. We are going automate deployment, scaling, and management of containerized
    applications using Kubernetes. And this is the moment where the real fun begins.
  prefs: []
  type: TYPE_NORMAL
