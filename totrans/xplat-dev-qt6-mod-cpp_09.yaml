- en: '*Chapter 6*: Signals and Slots'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：信号和槽'
- en: In the previous chapters, we learned how to create GUI applications with Qt
    Widgets and Qt Quick. But to make our applications usable, we need to add a communication
    mechanism. The **signals** and **slots** mechanism is one of the distinct features
    of Qt and makes it unique from other frameworks. Signals and slots are implemented
    through Qt's meta-object system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们学习了如何使用Qt Widgets和Qt Quick创建GUI应用程序。但是为了使我们的应用程序可用，我们需要添加一个通信机制。**信号**和**槽**机制是Qt的一个独特特性，使其与其他框架不同。信号和槽是通过Qt的元对象系统实现的。
- en: In this chapter, you will learn about signals and slots in depth and how they
    work internally. You will be able to receive notifications from different classes
    and take the corresponding action.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将深入了解信号和槽以及它们的内部工作原理。您将能够从不同的类中接收通知并采取相应的行动。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Understanding Qt signals and slots
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Qt信号和槽
- en: The working mechanism of Qt signals and slots
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt信号和槽的工作机制
- en: Getting to know Qt's property system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Qt的属性系统
- en: Understanding signals and the handler event system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解信号和处理程序事件系统
- en: Understanding events and the event loop
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解事件和事件循环
- en: Managing events with an event filter
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件过滤器管理事件
- en: Drag and drop
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拖放
- en: By the end of this chapter, you will be able to communicate between C++ classes
    with QML and between QML components.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将能够在C++类与QML之间以及QML组件之间进行通信。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The technical requirements for this chapter include having the minimum versions
    of Qt (6.0.0) and Qt Creator (4.14.0) installed on the latest desktop platform
    available, such as Windows 10, Ubuntu 20.04, or macOS 10.14\.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求包括在最新的桌面平台上安装Qt（6.0.0）和Qt Creator（4.14.0）的最低版本，例如Windows 10、Ubuntu 20.04或macOS
    10.14。
- en: 'All the code in this chapter can be downloaded from the following GitHub link:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码都可以从以下GitHub链接下载：
- en: '[https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter06](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter06)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter06](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter06)'
- en: Important note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The screenshots in this chapter were taken on a Windows machine. You will see
    similar screens based on the underlying platforms on your machine.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的屏幕截图是在Windows机器上拍摄的。您将在您的机器上看到基于底层平台的类似屏幕。
- en: Understanding Qt signals and slots
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Qt信号和槽
- en: In GUI programming, when a user performs any action with any UI element, another
    element should get updated, or a certain task should be done. To achieve this,
    we want communication between objects. For example, if a user clicks the **Close**
    button on the **Title** bar, it is expected that the window closes. Different
    frameworks use different approaches to achieve this kind of communication. A **callback**
    is one of the most commonly used approaches. A callback is a function that's passed
    as an argument to another function. Callbacks can have multiple drawbacks and
    may suffer from complications in ensuring the type-correctness of callback arguments.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在GUI编程中，当用户对任何UI元素执行任何操作时，另一个元素应该得到更新，或者应该执行某个特定的任务。为了实现这一点，我们需要对象之间的通信。例如，如果用户点击**标题**栏上的**关闭**按钮，预期窗口会关闭。不同的框架使用不同的方法来实现这种通信。**回调**是最常用的方法之一。回调是作为参数传递给另一个函数的函数。回调可能有多个缺点，并且可能在确保回调参数的类型正确性方面出现复杂性。
- en: In the Qt framework, we have a substitute for this callback technique known
    as signals and slots. A signal is a message that is passed to communicate that
    the state of an object has changed. This signal may carry information about the
    change that has occurred. A slot is a special function that is invoked in response
    to a specific signal. Since slots are functions, they contain logic to perform
    a certain action. Qt Widgets have many predefined signals, but you can always
    extend your classes and add your own signals to them. Similarly, you can also
    add your own slots to handle the intended signal. Signals and slots make it easy
    to implement the observer pattern while avoiding boilerplate code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt框架中，我们有一个称为信号和槽的回调技术的替代方法。信号是传递的消息，用于传达对象状态已更改。这个信号可能携带有关已发生更改的信息。槽是在特定信号的响应中调用的特殊函数。由于槽是函数，它们包含执行某个动作的逻辑。Qt
    Widgets有许多预定义的信号，但您始终可以扩展您的类并向其添加自己的信号。同样，您也可以添加自己的槽来处理预期的信号。信号和槽使得实现观察者模式变得容易，同时避免样板代码。
- en: To be able to communicate, you must connect the corresponding signals and slots.
    Let's understand the connection mechanism and syntaxes of a signal and slot connection.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够通信，您必须连接相应的信号和槽。让我们了解信号和槽连接的连接机制和语法。
- en: Understanding syntax
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解语法
- en: 'To connect a signal to a slot, we can use `QObject::connect()`. This is a thread-safe
    function. The standard syntax is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要将信号连接到槽，我们可以使用`QObject::connect()`。这是一个线程安全的函数。标准语法如下：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding connection, the first argument is the sender object, while
    the next argument is the signal from the sender. The third argument is the receiver
    object, while the fourth is the slot method. The last argument is optional and
    describes the type of connection to be established. It determines whether the
    notification will be delivered to the slot immediately or queued for later. There
    are six different types of connections that can be made in Qt 6\. Let''s have
    a look at the connection types:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的连接中，第一个参数是发送方对象，而下一个参数是发送方的信号。第三个参数是接收方对象，而第四个是槽方法。最后一个参数是可选的，描述要建立的连接类型。它确定通知是立即传递给槽还是排队等待。在Qt
    6中可以建立六种不同类型的连接。让我们来看看连接类型：
- en: '`Qt::DirectConnection` is used; otherwise, `Qt::QueuedConnection` is used.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Qt::DirectConnection`；否则，使用`Qt::QueuedConnection`。
- en: '**Qt::DirectConnection**: In this case, both the signal and slot live in the
    same thread. The slot is called immediately after the signal is emitted.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt::DirectConnection**：在这种情况下，信号和槽都位于同一线程中。信号发射后立即调用槽。'
- en: '**Qt::QueuedConnection**: In this case, the slot lives in another thread. The
    slot is called once control returns to the event loop of the receiver''s thread.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt::QueuedConnection**：在这种情况下，槽位于另一个线程中。一旦控制返回到接收者线程的事件循环，就会调用槽。'
- en: '`Qt::QueuedConnection`, except that the signaling thread blocks until the slot
    returns. This connection must not be used if both the sender and receiver are
    in the same thread to avoid deadlock.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt::QueuedConnection`，除了发出信号的线程会阻塞，直到槽返回。如果发送者和接收者在同一线程中，则不能使用此连接以避免死锁。'
- en: '`bitwise OR`. This is used to avoid duplicate connections. The connection will
    fail if the connection already exists.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`按位或`。这用于避免重复连接。如果连接已经存在，则连接将失败。'
- en: '`Qt::BlockingQueuedConnection` to avoid deadlocks. You are sending an event
    to the same thread and then locking the thread, waiting for the event to be processed.
    Since the thread is blocked, the event will never be processed, and the thread
    will be blocked forever, causing a deadlock. Use this connection type if you know
    what you are doing. You must know the implementation details of both threads before
    using this connection type.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt::BlockingQueuedConnection`以避免死锁。您正在向同一线程发送事件，然后锁定线程，等待事件被处理。由于线程被阻塞，事件将永远不会被处理，线程将永远被阻塞，导致死锁。如果知道自己在做什么，请使用此连接类型。在使用此连接类型之前，必须了解两个线程的实现细节。'
- en: 'There are several ways to connect signals and slots. You must use the `SIGNAL()`
    and `SLOT()` macros when specifying the signal and the slot function, respectively.
    The most commonly used syntax is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种连接信号和槽的方法。在指定信号和槽函数时，必须使用`SIGNAL()`和`SLOT()`宏。最常用的语法如下：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is the original syntax that has been around since the beginning of Qt.
    However, its implementation has changed quite a few times. New features have been
    added without breaking the basic **Application Programming Interface** (**API**).
    It is recommended to use the new function pointer syntax, as shown here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是自Qt诞生以来就存在的原始语法。但是，它的实现已经多次更改。新功能已添加，而不会破坏基本的**应用程序编程接口**（**API**）。建议使用新的函数指针语法，如下所示：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There are pros and cons to both syntaxes. You can learn more about the differences
    between **string-based** and **functor-based** connections at
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种语法各有优缺点。您可以在以下链接中了解有关**基于字符串**和**基于函数对象**连接之间的区别的更多信息：
- en: '[https://doc.qt.io/qt-6/signalsandslots-syntaxes.html](https://doc.qt.io/qt-6/signalsandslots-syntaxes.html)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.qt.io/qt-6/signalsandslots-syntaxes.html](https://doc.qt.io/qt-6/signalsandslots-syntaxes.html)'
- en: 'If a connection fails, then the preceding statement returns `false`. You can
    also connect to functors or C++11 lambdas, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接失败，则前面的语句返回`false`。您还可以按如下方式连接到函数对象或C++11 lambda：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can check the return value to verify whether the signal connected to the
    slot successfully. The connection can fail if the signatures aren't compatible,
    or the signal and slot are missing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以检查返回值以验证信号是否成功连接到槽。如果签名不兼容，或者信号和槽缺失，连接可能会失败。
- en: Important note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: '`Qt::UniqueConnection` does not work for lambdas, non-member functions, and
    functors; it can only be used to connect to member functions.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Qt::UniqueConnection`不适用于lambda、非成员函数和函数对象；它只能用于连接到成员函数。'
- en: 'The signatures of signals and slots may contain arguments, and these arguments
    may have default values. You can connect a signal to a slot if the signal has
    at least as many arguments as the slot, as well as if there is a possible implicit
    conversion between the types of the corresponding arguments. Let''s look at feasible
    connections with varying numbers of arguments:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 信号和槽的签名可能包含参数，并且这些参数可能具有默认值。如果信号的参数至少与槽的参数一样多，并且相应参数的类型之间存在可能的隐式转换，则可以将信号连接到槽。让我们看一下具有不同参数数量的可行连接：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, the following one won''t work as the slot has more arguments than
    the signal:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，以下情况将无法正常工作，因为槽的参数比信号的参数多：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Every connection you make emits a signal, so duplicate connections emit two
    signals. You can break a connection using `disconnect()`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您建立的每个连接都会发射一个信号，因此重复的连接会发射两个信号。您可以使用`disconnect()`来断开连接。
- en: 'You can also use Qt with a third-party signal/slot mechanism. If you want to
    use both mechanisms for the same project, then add the following configuration
    to your Qt project (`.pro`) file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将Qt与第三方信号/槽机制一起使用。如果要在同一项目中使用两种机制，则将以下配置添加到Qt项目（`.pro`）文件中：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's create an example with a simple signal and slot connection.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的信号和槽连接的示例。
- en: Declaring signals and slots
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明信号和槽
- en: 'To create a signal and slot, you must declare the signal and slot inside your
    custom class. The header file of the class will look like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建信号和槽，必须在自定义类中声明信号和槽。类的头文件将如下所示：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, we have added `Q_OBJECT` to the class to facilitate the signals
    and slots mechanism. You can declare a signal with the `signals` keyword in your
    header file, as shown in the previous snippet. Similarly, slots can be declared
    with the `slots` keyword. Both signals and slots can have arguments. In this example,
    we used the same object for the sender and receiver to make this explanation simpler.
    In most cases, signals and slots will be located in different classes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已向类添加了`Q_OBJECT`以便于信号和槽机制。您可以在头文件中使用`signals`关键字声明信号，如前面的代码片段所示。类似地，可以使用`slots`关键字声明槽。信号和槽都可以带有参数。在此示例中，我们使用相同的对象作为发送者和接收者，以使解释更简单。在大多数情况下，信号和槽将位于不同的类中。
- en: Next, we will discuss how to connect the signal to the slot.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何将信号连接到槽。
- en: Connecting the signal to the slot
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将信号连接到槽
- en: 'Previously, we declared a custom signal and slot. Now, let''s look at how to
    connect them. You can define a signal and slot connection and emit the signal
    inside `MyClass`, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们声明了一个自定义信号和槽。现在，让我们看看如何连接它们。您可以在`MyClass`内定义信号和槽的连接，并发出信号，如下所示：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You need to emit the signal after the connection to invoke the slot. In the
    preceding example, we used the traditional way of signal and slot declaration.
    You can replace the connection with the latest syntax, as shown here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接后需要发出信号以调用槽。在前面的例子中，我们使用了信号和槽声明的传统方式。您可以将连接替换为最新的语法，如下所示：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is not only possible to connect one signal to one slot, but also to connect
    many slots and signals. Similarly, many signals can be connected to one slot.
    We will learn how to do that in the next section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以将一个信号连接到一个槽，还可以连接多个槽和信号。同样，许多信号可以连接到一个槽。我们将在下一节中学习如何做到这一点。
- en: Connecting a single signal to multiple slots
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将单个信号连接到多个槽
- en: You can connect the same signal to multiple slots. These slots will be called
    in the same order as the connections are made. Let's consider that a signal named
    `signalX()` is connected to three slots called `slotA()`, `slotB()`, and `slotC()`.
    When `signalA()` is emitted, all three slots will be invoked.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将相同的信号连接到多个槽。这些槽将按照连接的顺序依次调用。假设一个名为`signalX()`的信号连接到名为`slotA()`、`slotB()`和`slotC()`的三个槽。当发出`signalA()`时，所有三个槽都将被调用。
- en: 'Let''s look at the traditional way of making connections:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看传统的连接方式：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can also create connections as per the new syntax, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以按照新的语法创建连接，如下所示：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the next section, we will learn how to connect multiple signals to a single
    slot.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何将多个信号连接到单个槽。
- en: Connecting multiple signals to a single slot
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将多个信号连接到单个槽
- en: 'In the previous section, you learned how to create a connection between a single
    signal and multiple slots. Now, let''s look at the following code to understand
    how to connect multiple signals to a single slot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，您学习了如何在单个信号和多个槽之间创建连接。现在，让我们看一下以下代码，以了解如何将多个信号连接到单个槽：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we have used three different signals called `signalX()`, `signalY()`,
    and `signalZ()`, but there is a single slot defined as `slotX()`. When any of
    these signals are emitted, that slot is called.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了三个不同的信号，分别是`signalX()`、`signalY()`和`signalZ()`，但是只定义了一个名为`slotX()`的槽。当任何一个这些信号被发出时，都会调用该槽。
- en: In the next section, we will learn how to connect one signal to another signal.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何将一个信号连接到另一个信号。
- en: Connecting a signal to another signal
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接一个信号到另一个信号
- en: 'Sometimes, you may have to forward a signal instead of directly connecting
    to a slot. You can connect one signal to another signal as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能需要转发一个信号，而不是直接连接到一个槽。您可以按照以下方式将一个信号连接到另一个信号：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can also create connections as per the new syntax, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以按照新的语法创建连接，如下所示：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding line, we have connected `signalA()` to `signalB()`. Hence,
    when `signalA()` is emitted, `signalB()` will also be emitted and the corresponding
    slot connected to `signalB()` will be invoked. Let''s consider that we have a
    button in our GUI, and we want to forward the button click as a different signal.
    The following code snippet shows how to forward a signal:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的行中，我们已经将`signalA()`连接到`signalB()`。因此，当发出`signalA()`时，`signalB()`也将被发出，并且连接到`signalB()`的相应槽将被调用。假设我们的GUI中有一个按钮，并且我们希望将按钮点击转发为不同的信号。以下代码片段显示了如何转发信号：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding example, we forwarded the button click signal to our custom
    signal. We can call the slot that is connected to the custom signal as discussed
    earlier.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将按钮点击信号转发到我们的自定义信号。我们可以调用连接到自定义信号的槽，就像之前讨论的那样。
- en: In this section, we learned how connections are made and how to use signals
    and slots. Now, you can communicate between different classes and share information.
    In the next section, we will learn about the working mechanism behind signals
    and slots.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何进行连接以及如何使用信号和槽。现在，你可以在不同的类之间进行通信并共享信息。在下一节中，我们将学习信号和槽背后的工作机制。
- en: The working mechanism of Qt signals and slots
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt信号和槽的工作机制
- en: In the previous sections, we learned about signal and slot syntaxes and how
    to connect them. Now, we will understand how it works.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们学习了信号和槽的语法以及如何连接它们。现在，我们将了解它是如何工作的。
- en: While creating a connection, Qt looks for the index of the signal and the slot.
    Qt uses a lookup string table to find the corresponding indexes. Then, a `QObjectPrivate::Connection`
    object is created and added to the internal linked lists. Since one signal can
    be connected to multiple slots, each signal can have a list of the connected slots.
    Each connection contains the receiver's name and the index of the slot. Each object
    has a connection vector that associates with each signal in a linked list of `QObjectPrivate::Connection`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建连接时，Qt会查找信号和槽的索引。Qt使用查找字符串表来找到相应的索引。然后，创建一个`QObjectPrivate::Connection`对象并将其添加到内部链接列表中。由于一个信号可以连接到多个槽，每个信号可以有一个连接的槽列表。每个连接包含接收者的名称和槽的索引。每个对象都有一个连接向量，与`QObjectPrivate::Connection`的链接列表中的每个信号相关联。
- en: 'The following diagram illustrates how `ConnectionList` creates connections
    between sender and receiver objects:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示了`ConnectionList`如何在发件人和接收者对象之间创建连接：
- en: '![Figure 6.1 – Illustration of the connection mechanism between the sender
    and receiver'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 - 发件人和接收者之间连接机制的说明'
- en: '](img/Figure_6.1_B16231.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.1_B16231.jpg)'
- en: Figure 6.1 – Illustration of the connection mechanism between the sender and
    receiver
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 - 发件人和接收者之间连接机制的说明
- en: '`ConnectionList` is a singly linked list that contains all the connections
    from and to an object. `signalVector` contains the lists of connections for a
    given signal. Each `Connection` is also part of a *senders* linked list. Linked
    lists are used because they permit faster addition and removal of objects. Each
    object also has a reversed list of connections the object is connected to for
    automatic deletion. For detailed internal implementation, look at the latest `qobject_p.h`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConnectionList`是一个包含与对象之间所有连接的单向链表。`signalVector`包含给定信号的连接列表。每个`Connection`也是*senders*链表的一部分。使用链表是因为它们允许更快地添加和删除对象。每个对象还有一个反向连接列表，用于自动删除对象。有关详细的内部实现，请查看最新的`qobject_p.h`。'
- en: 'There are quite a few articles on how signals and slots work on the *woboq*
    website. You can also explore the Qt source code on the woboq website. Go to the
    following link if you need further information:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在*woboq*网站上有很多关于信号和槽工作原理的文章。您还可以在woboq网站上探索Qt源代码。如果需要更多信息，请访问以下链接：
- en: '[https://woboq.com/blog/how-qt-signals-slots-work.html](https://woboq.com/blog/how-qt-signals-slots-work.html).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://woboq.com/blog/how-qt-signals-slots-work.html](https://woboq.com/blog/how-qt-signals-slots-work.html)。'
- en: Now, let's learn about Qt's meta-object system.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解一下Qt的元对象系统。
- en: Qt's meta-object system
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Qt的元对象系统
- en: '**Qt''s meta-object system** is the core mechanism behind the signals and slots
    mechanism. It provides features such as inter-object communication, a dynamic
    property system, and runtime type information.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**Qt的元对象系统**是信号和槽机制背后的核心机制。它提供了诸如对象间通信、动态属性系统和运行时类型信息等功能。'
- en: 'The meta-object system is implemented with a three-part mechanism. These mechanisms
    are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 元对象系统是通过三部分机制实现的。这些机制如下：
- en: QObject
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QObject
- en: Q_OBJECT macro
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Q_OBJECT宏
- en: Meta-Object Compiler
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元对象编译器
- en: The `QObject` class is the base class of all Qt objects. It is a very powerful
    mechanism that facilitates the signals and slots mechanism. The `QObject` class
    provides a base class for objects that can take advantage of the meta-object system.
    `QObject` derived classes arrange themselves in an object tree. This creates the
    parent-children relationship between classes. When you create a `QObject` derived
    class with another `QObject` derived class as a parent, the object will be automatically
    added to the parent's `children()` list. The parent takes ownership of the object.
    GUI programming requires both runtime efficiency and a high level of flexibility.
    Qt achieved this by combining the speed of C++ with the flexibility of the Qt
    Object Model. Qt provides the required features by implementing standard C++ techniques
    based on the inheritance from QObject.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`QObject`类是所有Qt对象的基类。它是一个非常强大的机制，可以促进信号和槽机制。`QObject`类为可以利用元对象系统的对象提供了一个基类。`QObject`派生类在对象树中排列，从而在类之间创建了父子关系。当您创建一个`QObject`派生类，并将另一个`QObject`派生类作为父类时，该对象将自动添加到父类的`children()`列表中。父类将拥有该对象。GUI编程需要运行时效率和高度的灵活性。Qt通过将C++的速度与Qt对象模型的灵活性相结合来实现这一点。Qt通过基于从QObject继承的标准C++技术来提供所需的功能。'
- en: 'You can learn more about the Qt Object Model at the following link:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接了解有关Qt对象模型的更多信息：
- en: '[https://doc.qt.io/qt-6/object.html](https://doc.qt.io/qt-6/object.html).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.qt.io/qt-6/object.html](https://doc.qt.io/qt-6/object.html)。'
- en: The `Q_OBJECT` macro appears inside the private section of the class declaration.
    It is used to enable signals, slots, and other services provided by Qt's meta-object
    system.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Q_OBJECT`宏出现在类声明的私有部分。它用于启用Qt元对象系统提供的信号、槽和其他服务。'
- en: '`QObject` derived classes to implement meta-object features. It provides the
    capability to introspect the objects at runtime. By default, C++ does not have
    introspection support. Hence, Qt created `moc`. It is a code-generating program
    that handles Qt''s C++ extensions. The tool reads the C++ header files and if
    it locates the `Q_OBJECT` macro, then it creates another C++ source file with
    the meta-object code. That generated file contains the code required for the introspection.
    Both files are compiled and linked together. In addition to providing the signals
    and slots mechanism for communication between objects, the meta-object code offers
    several additional features to find the class name and inheritance details, and
    also helps with setting properties at runtime. Qt''s `moc` provides a clean way
    to go beyond the compiled language''s facilities.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`QObject`派生类用于实现元对象特性。它提供了在运行时检查对象的能力。默认情况下，C++不支持内省。因此，Qt创建了`moc`。这是一个处理Qt的C++扩展的代码生成程序。该工具读取C++头文件，如果找到`Q_OBJECT`宏，那么它会创建另一个包含元对象代码的C++源文件。生成的文件包含了内省所需的代码。这两个文件被编译和链接在一起。除了为对象之间的通信提供信号和槽机制之外，元对象代码还提供了几个额外的功能，可以找到类名和继承详情，并且还可以帮助在运行时设置属性。Qt的`moc`提供了一种超越编译语言功能的清晰方式。'
- en: You can perform type casts by using `qobject_cast()` on `QObject` derived classes.
    The `qobject_cast()` function acts similar to the standard C++ `dynamic_cast()`.
    The advantage is that it doesn't require `QObject`, but if you don't add the `Q_OBJECT`
    macro, then the signals and slots and the other meta-object system features will
    not be available. A `QObject` derived class without meta code is equivalent to
    its closest ancestor containing meta-object code. There is also a lighter version
    of the `Q_OBJECT` macro, known as `Q_GADGET`, that can be used to utilize some
    of the capabilities provided by `QMetaObject`. A class that uses `Q_GADGET` doesn't
    have signals or slots.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`qobject_cast()`在`QObject`派生类上执行类型转换。`qobject_cast()`函数类似于标准的C++ `dynamic_cast()`。优点是它不需要`QObject`，但如果您不添加`Q_OBJECT`宏，那么信号和槽以及其他元对象系统功能将不可用。没有元代码的`QObject`派生类等同于包含元对象代码的最近祖先。还有一个更轻量级的`Q_OBJECT`宏的版本，称为`Q_GADGET`，可以用于利用`QMetaObject`提供的一些功能。使用`Q_GADGET`的类没有信号或槽。
- en: We have seen a few new keywords here, such as `Q_OBJECT`, `signals`, `slots`,
    `emit`, `SIGNAL`, and `SLOT`. These are known as the Qt extensions of C++. They
    are very simple macros meant to be seen by `moc`, defined in `qobjectdefs.h`.
    Out of these, `emit` is an empty macro that is not parsed by `moc`. It is kept
    just to give the developer hints.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: You can learn about why Qt uses `moc` for signals and slots at [https://doc.qt.io/qt-6/why-moc.html](https://doc.qt.io/qt-6/why-moc.html).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about Qt's meta-object system. In the next section,
    we will discuss the `moc` generated code and discuss some of the underlying implementations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: MOC generated code
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will have a look at the code generated by `moc` in Qt6\.
    When you build the earlier signal and slot example, you will see the generated
    files under the build directory: `moc_myclass.cpp` and `moc_predefs.h`. Let''s
    open the `moc_myclass.cpp` file with a text editor:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can see that the information about the Qt Meta-Object Compiler version at
    the top of the file. Please note that all the changes that are made in this file
    will be lost on recompiling the project. So, don't modify anything in this file.
    We are looking at the file to understand the working mechanism.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the integer data of `QMetaObject`. As you can see, there are
    two columns; the first column is the count, while the second column is the index
    in this array:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this case, we have one method, and the description of the method starts at
    index 14\. You can find the number of available signals in `signalCount`. For
    each function, `moc` also saves the return type of each parameter, their type,
    and their index to the name. In each meta-object, the methods are given an index,
    beginning with 0\. They are arranged as signals, then slots, and then as other
    functions. These indexes are relative indexes and exclude the indexes of parent
    objects.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'When you look further into the code, you will find the `MyClass::metaObject()`
    function. This function returns `QObject::d_ptr->dynamicMetaObject()` for dynamic
    meta-objects. The `metaObject()` function normally returns the class'' s`taticMetaObject`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When the incoming string data matches the current class, you must convert this
    pointer into a void pointer and pass it to the outside world. If it is not the
    current class, then `qt_metacast()` of the parent class is called to continue
    the query:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Qt''s meta-object system uses the `qt_metacall()` function to access the meta-information
    for a particular `QObject` object. When we emit a signal, `qt_metacall()` is called
    and then calls the real signal function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When you call a signal, it calls the `moc` generated code, which internally
    calls `QMetaObject::activate()`, as shown in the following snippet. Then, `QMetaObject::activate()`
    looks into the internal data structures to find out about the slots that are connected
    to that signal.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the detailed implementation of this function inside `qobject.cpp`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'By doing this, you can explore the complete generated code and look at the
    symbols further. Now, let''s look at the `moc` generated code where the slot is
    called. The slot is called by its index in the `qt_static_metacall` function,
    as shown here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The array pointers to the argument are in the same format as the signal. `_a[0]`
    is not touched because everything here returns void:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This returns `true` if the signal is connected to at least one receiver; otherwise,
    it returns `false`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: When an object is destroyed, an `QObjectPrivate::senders` list is iterated,
    and all `Connection::receiver` are set to `0`. Also, `Connection::receiver->connectionLists->dirty`
    is set to `true`. Each `QObjectPrivate::connectionLists` is also iterated to remove
    the **connection** in the senders lists.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we went through some sections of the `moc` generated code and
    understood the working mechanism behind signals and slots. In the next section,
    we will learn about Qt's property system.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know Qt's property system
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Qt''s property system is similar to some other compiler vendors. However, it
    provides a cross-platform advantage and works with standard compilers supported
    by Qt on different platforms. To add a property, you must add the `Q_PROPERTY()`
    macro to the `QObject` derived class. This property acts like a class data member,
    but it provides extra features that are available through the Meta-Object System.
    A simple syntax looks as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding syntax, we used some of the most common parameters. But there
    are more parameters that are supported in the syntax. You can find out more by
    reading the Qt documentation. Let''s have a look at the following code snippet,
    which uses the `MEMBER` parameter:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding snippet, we exported a member variable as a Qt property using
    the `MEMBER` keyword. The type here is `QString`, and the `NOTIFY` signal is used
    to implement QML property binding.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's explore how to read and write properties with the Meta-Object System.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing properties with the Meta-Object System
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a class named `MyClass`, which is a subclass of `QWidget`. Let''s
    add the `Q_OBJECT` macro to its private section to enable the property system.
    In this example, we want to create a property in `MyClass` to keep track of a
    version''s value. The name of the property will be `version`, and its type will
    be `QString`, which is defined in `MyClass`. Let''s look at the following code
    snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To get the property changed notification, you have to emit `versionChanged()`
    after the `version` value is changed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the `main.cpp` file for the preceding example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code snippet, the property is set by invoking `setVersion()`.
    You can see that `versionChanged()` signal is emitted every time the version is
    changed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: You can also read a property using `QObject::property()` and write it using
    `QObject::setProperty()`. You can also query dynamic properties using `QObject::property()`,
    similar to compile time `Q_PROPERTY()` declarations.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also set the property like so:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this section, we discussed the property system. In the next section, we will
    learn about signals and slots in Qt Designer.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Using signals and slots in Qt Designer
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are using the Qt Widgets module, then you can use Qt Designer to edit
    signal and slot connections in the form. Qt default widgets come with many signals
    and slots. Let's see how we can implement signals and slots in Qt Designer without
    writing any code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'You can drag a **Dial** control and a **Slider** control onto the form. You
    can add connections via **Signals and Slots Editor** at the bottom tab, as shown
    in the following screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Creating signals and slots connections using Qt Designer'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.2_B16231.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – Creating signals and slots connections using Qt Designer
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can press *F4* or select the **Edit Signals/Slots** button
    from the top toolbar. Then, you can select the control and create a connection
    by dragging the connection to the receiver. If you have custom signals or slots
    defined for your custom class, they will be automatically displayed in **Signals
    and Slots Editor**. However, most developers prefer to define connections inside
    C++ source files.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed using Qt Designer to implement signals and slots
    in Qt Widgets. Now, let's look at how signals are handled in QML.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Understanding signals and the handler event system in QML
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we learned how to connect signals and slots inside C++ source files
    and use them with the Qt Widgets module. Now, let's look at how we can communicate
    in QML. QML has a signal and handler mechanism, similar to signals and slots.
    In a QML document, a signal is an event, and the signal is responded to through
    a signal handler. Like a slot in C++, a signal handler is invoked when a signal
    is emitted in QML. In Qt terminology, the method is a slot that is connected to
    the signal; all the methods defined in QML are created as Qt slots. Hence, there
    is no separate declaration for slots in QML. A signal is a notification from an
    object that some event has occurred. You can place logic inside JavaScript or
    a method to respond to the signal.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to write a signal handler. You can declare a signal handler
    as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, `signalName` is the name of the signal. The first letter of the signal's
    name is capitalized while writing a handler. So, the signal handler here is named
    `onSignalName`. The signal and signal handler should be defined inside the same
    object. The logic inside the signal handler is a block of JavaScript code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: For example, when the user clicks within the mouse area, the `clicked()` signal
    is emitted. To handle the `clicked()` signal, we must add the `onClicked:{…}`
    signal handler.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Signal handlers are simple functions that are invoked by the QML engine when
    an associated signal is emitted. When you add a signal to a QML object, Qt automatically
    adds a corresponding signal handler to the object definition.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by adding a custom signal to a QML document.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Adding a signal in QML
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add a signal inside your QML class, you must use the `signal` keyword. The
    syntax for defining a new signal is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following is an example of this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'A signal can be declared with or without any parameters. If no parameter is
    declared for the signal, then you can leave `()` brackets. You can emit a signal
    by invoking it as a function:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding example, we added a custom signal `composeMessage()` to the
    QML file. We used the corresponding signal handler; that is, `onComposeMessage()`.
    Then, we added a button that emits the `composeMessage()` signal when it is clicked.
    When you run this example, you will see that the signal handler is called automatically
    when the button is clicked.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to declare a signal and how to implement the
    corresponding signal handler. In the next section, we will connect the signal
    to a function.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Connecting a signal to a function
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can connect a signal to any function defined inside your QML document. You
    can use `connect()` to connect a signal either to a function or another signal.
    When a signal is connected to a function, that function is automatically invoked
    whenever the signal is emitted. This mechanism enables a signal to be received
    by a function instead of a signal handler.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, the `composeMessage()` signal is connected to the
    `transmitMessage()` function using the `connect()` function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In QML, signal handling is implemented using the following syntax:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can also remove a connection using the `disconnect()` function. You can
    disconnect the connection like so:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, let's explore how to forward a signal in QML.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Connecting a signal to a signal
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can connect a signal to another signal in QML. You can achieve this using
    the `connect()` function.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore how we can do this by looking at the following example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding example, we connected the `clicked()` signal to the `forwardButtonClick()`
    signal. You can implement the necessary logic at the root level inside the `onForwardButtonClick()`
    signal handler. You can also emit the signal from the button click handler, as
    follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this section, we discussed how to connect two signals and handle them. In
    the next section, we will discuss how to communicate between the C++ class and
    QML using signals and slots.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Defining property attributes and understanding property binding
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Previously, we learned how to define a type in C++ by registering the `Q_PROPERTY`
    of a class, which is then registered with the QML type system. It is also possible
    to create custom properties in a QML document. Property binding is a core feature
    of QML that allows us to create relationships between various object properties.
    You can declare a property in a QML document with the following syntax:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this way, you can expose a particular parameter to outside objects or maintain
    internal states more efficiently. Let''s look at the following property declaration:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When you declare a custom property, Qt implicitly creates a property-change
    signal for that property. The associated signal handler is `on<PropertyName>Changed`,
    where `<PropertyName>` is the name of the property, with the first letter capitalized.
    For the previously declared property, the associated signal handler is `onVersionChanged`,
    as shown here:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If the property is assigned a static value, then it remains constant until
    it is explicitly assigned a new value. To update these values dynamically, you
    should use property binding inside your QML document. We used simple property
    binding earlier, as shown in the following snippet:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'However, we can combine this with the property that''s exposed by the backend
    C++ class, as shown here:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the previous line, `myClass` is the backend C++ object that's registered
    with the QML engine. In this case, whenever the `versionChanged()` change signal
    is emitted from the C++ side, the QML `version` property gets updated automatically.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll discuss how to integrate signals and slots between C++ and QML.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Integrating signals and slots between C++ and QML
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++, to interact with the QML layer, you can use signals, slots, and `Q_INVOKABLE`
    functions. You can also create properties using the `Q_PROPERTY` macro. To respond
    to signals from objects, you can use the `Connections` QML type. When a property
    changes inside a C++ file, `Q_PROPERTY` automatically updates the values. If the
    property has a binding with any QML property, it will automatically update the
    property values inside QML. In this case, the signal slot mechanism is established
    automatically.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example, which uses the aforementioned mechanism:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the preceding code, we declared a Q_PROPERTY-based notification. We can
    get the new `counter` value when the `counterChanged()` signal is emitted. However,
    we used the `receiveFromQml()` function as a `Q_INVOKABLE` function so that we
    can call it directly inside the QML document. We are emitting `sendToQml()`, which
    is handled inside `main.qml`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, let''s have a look at the QML implementation:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the preceding example, we used `Connections` to connect to the C++ signal.
    On button click, we are calling the `receiveFromQml()` C++ function, where we
    are emitting the signal. We have also declared the `count` property, which also
    listens to `counterChanged()`. We handled the data inside the associated signal
    handler; that is, `onCountChanged`. We can also update the `labelCount` data based
    on the notification:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – The mechanism that was used in this example'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.3_B16231.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – The mechanism that was used in this example
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram illustrates the communication mechanism in this example.
    For explanation purposes, we have kept multiple approaches in the same example
    to explain the communication mechanism between C++ and QML.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about the signals and slots mechanism through examples.
    In the next section, we will learn about events and the event loop in Qt.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Understanding events and the event loop
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt is an event-based system, and all GUI applications are event-driven. In an
    event-driven application, there is usually a main loop that listens for events
    and then triggers a callback function when one of those events is detected. Events
    can be spontaneous or synthetic. Spontaneous events come from the outside environment.
    Synthetic events are custom events generated by the application. An event in Qt
    is a notification that represents something that has happened. Qt events are value
    types, derived from `QEvent`, which offers a type enumeration for each event.
    All events that arise inside a Qt application are encapsulated in objects that
    inherit from the `QEvent` class. All `QObject` derived classes can override the
    `QObject::event()` function in order to handle events targeted by their instances.
    Events can come from both inside and outside the application.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'When an event occurs, Qt produces an event object by constructing an appropriate
    `QEvent` subclass instance, which it then delivers to the specific instance of
    `QObject` by calling its `event()` function. Unlike the signals and slots mechanism,
    where the slots connected to the signal are usually executed immediately, an event
    must wait for its turn, until the event loop dispatches all the events that arrived
    earlier. You must select the right mechanism as per your intended implementation.
    The following diagram illustrates how events are created and managed in event-driven
    applications:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Illustration of an event-driven application using the event
    loop'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.4_B16231.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – Illustration of an event-driven application using the event loop
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: We can enter Qt's main event loop by calling `QCoreApplication::exec()`. The
    application keeps running until `QCoreApplication::exit()` or `QCoreApplication::quit()`
    are called, which terminates the loop. `QCoreApplication` can process each event
    in the GUI thread and forward events to QObjects. Please note that the events
    are not delivered immediately; instead, they're queued up in an event queue and
    processed later, one after another. The event dispatcher loops through this queue,
    converts them into `QEvent` objects, and then dispatches the events to the target
    `QObject`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'A simplified event loop dispatcher may look as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Some of the important Qt classes related to the event loop are as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '`event` queue.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event` loop.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event` loop for non-GUI based applications.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event` loop for GUI-based applications.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QThread** is used to create custom threads and manage threads.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QSocketNotifier** is used to monitor activity on a file descriptor.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event` loop.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can read about these classes in the Qt documentation. The following link
    provides further insight into the event system:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[https://wiki.qt.io/Threads_Events_QObjects](https://wiki.qt.io/Threads_Events_QObjects).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed events and Qt's event loop. In the next section,
    we will learn how to filter events with an event filter.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Managing events with an event filter
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to manage events and how to filter a specific
    event and perform a task. You can achieve event filtering by reimplementing event
    handlers and installing event filters. You can redefine what an event handler
    should do by subclassing the widget of interest and reimplementing that event
    handler.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt provides five different approaches for event processing, as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Reimplementing a specific event handler, such as `paintEvent()`
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reimplementing the `QObject::event()` function
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing an event filter on the `QObject` instance
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing an event filter on the `QApplication` instance
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subclassing `QApplication` and reimplementing `notify()`
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code handles the left mouse button click on a custom widget while
    passing all other button clicks to the base `QWidget` class:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the previous example, we filtered only the left button press event. You
    can add the required action inside the respective block. The following diagram
    illustrates the high-level event processing mechanism:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Illustration of the event filter mechanism'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.5_B16231.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – Illustration of the event filter mechanism
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'An event filter can be installed either on an application instance or a local
    object. If the event filter is installed in an `QCoreApplication` object, then
    all the events will go through this event filter. If it is installed in a `QObject`
    derived class, then the events that have been sent to that object will go through
    the event filter. Sometimes, there may not be any suitable Qt event type available
    for a specific action. In that case, you can create a custom event by creating
    a subclass from `QEvent`. You can reimplement `QObject::event()` to filter the
    intended event, as shown here:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we have created a custom event class named `MyCustomEvent` and created
    a custom type.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s filter these events by reimplementing `event()`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see, we have passed the other events to `QWidget::event()` for further
    processing. If you want to prevent the event from propagating further, then `return
    true`; otherwise, `return false`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: An event filter is an object that receives all the events that are sent to an
    object. The filter can either stop the event or forward it to the object. It screens
    the events if an object has been installed as an event filter for the watched
    object. It is also possible to monitor another object for events by using an event
    filter and performing the necessary tasks. The following example shows how to
    reimplement one of the most commonly used events – a keypress event – using the
    *event filter* approach.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following code snippet:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the preceding code, we created a class called `MainWindow` and overridden
    `eventFilter()`. Let''s install the filter on `textEdit` using `installEventFilter()`.
    You can install multiple event filters on an object. However, if multiple event
    filters are installed on a single object, the filter that was installed last will
    be activated first. You can also remove an event filter by calling `removeEventFilter()`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the preceding code, we installed an `eventFilter` on the `textEdit` object.
    Now, let''s have a look at the `eventFilter()` function:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, `textEdit` is the monitored object. Every time you press a key and if
    the `textEdit` is in focus, the event is captured. Since there may more objects
    that are children and `QMainWindow` may require the events, don't forget to pass
    the unhandled events to the base class for further event processing.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Once you've consumed the event in the `eventFilter()` function, make sure to
    `return true`. If the receiver object is deleted and you `return false`, then
    it can result in an application crash.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: You can also combine the signals and slots mechanism with the event. You can
    achieve this by filtering the event and emitting a signal that corresponds to
    that event. I hope that you have understood the event handling mechanism in Qt.
    Now, let's look at drag and drop.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Drag and drop
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about **drag and drop** (**DnD**). In a GUI application,
    DnD is a pointing device gesture in which the user selects a virtual object by
    *grabbing* it and then *releasing* it on another virtual object. The drag and
    drop operation starts when the user makes some gesture that is recognized as a
    signal to start a drag action.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss how we can implement drag and drop using Qt Widgets.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Drag and drop in Qt Widgets
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Qt Widgets-based GUI applications, where drag and drop is used, the user
    starts dragging from a particular widget and drops the dragged object onto another
    widget. This requires us to reimplement several functions and it handles the corresponding
    events. The most common functions that need to be reimplemented to achieve drag
    and drop are as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Once you''ve reimplemented the preceding functions, enable dropping on the
    target widget with the following statement:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To begin a drag, create a `QDrag` object and pass a pointer to the widget that
    begins the drag. The drag and drop operation is handled by a `QDrag` object. This
    operation requires the attached data description to be of the **Multipurpose Internet
    Mail Extensions** (**MIME**) type:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The preceding code shows how to create a drag object and set a custom MIME type.
    Here, we used `text/csv` as the MIME type. You can supply more than one type of
    MIME-encoded data with a drag and drop operation.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: To intercept drag and drop events, you can reimplement `dragEnterEvent()`. This
    event handler is called when a drag is in progress and the mouse enters the widget.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: You can find several relevant examples in the examples section in Qt Creator.
    Since Qt Widgets aren't very popular these days, we are skipping the drag and
    drop example using widgets. In the next section, we will discuss drag and drop
    in QML.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Drag and drop in QML
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we discussed drag and drop using widgets. Since QML
    is used to create modern and touch-friendly applications, drag and drop is a very
    important feature. Qt provides several convenient QML types for implementing drag
    and drop. Internally, the corresponding events are handled similarly. These functions
    are declared in the `QQuickItem` class.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `dragEnterEvent()` is also available in `QQuickItem`, and is used
    to intercept drag and drop events, as described here:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Let's discuss how to implement this using the available QML types. Using the
    `Drag` attached property, any `Item` can be made a source of drag and drop events
    within a QML scene. A `DropArea` is an invisible item that can receive events
    when an item is dragged over it. When a drag action is active on an item, any
    change that's made to its position will generate a drag event that will be sent
    to any intersecting `DropArea`. The `DragEvent` QML type provides information
    about a drag event.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows a simple drag and drop operation in QML:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the preceding code, we created a draggable item with an ID of `dragItem`.
    It contains a `MouseArea` to capture the mouse press event. Dragging is not limited
    to mouse drags. A drag action can be triggered by anything that can generate a
    drag event. A drag can be canceled by calling `Drag.cancel()` or by setting the
    `Drag.active` state to `false`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'The drop action can be completed with a drop event by calling `Drag.drop()`.
    Let''s add a `DropArea`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the preceding snippet, we used a light blue rectangle to distinguish it as
    a `DropArea` on the screen. We are catching `dragItem` when it enters the `DropArea`
    region. When `dragItem` is leaving the `DropArea` region, the drop action is disabled.
    Therefore, when the drop is unsuccessful, the item will go back to its original
    position.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about drag and drop actions and their corresponding
    events. We discussed how to implement them using the Qt Widgets module, as well
    as in QML. Now, let's summarize what we learned in this chapter.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the core concepts of signals and slots in Qt.
    We discussed different ways of connecting signals and slots. We also learned how
    to connect one signal to multiple slots and multiple signals to a single slot.
    Then, we looked at how to use them with Qt Widgets, as well as in QML, as well
    as the mechanism behind the signal and slot connection. After that, you learned
    how to communicate between C++ and QML using signals and slots.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also discussed events and event loops in Qt. We explored how to
    use events instead of the signal-slot mechanism. After doing this, we created
    a sample program with a custom event handler to capture events and filter them.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还讨论了Qt中的事件和事件循环。我们探讨了如何使用事件而不是信号槽机制。在这之后，我们创建了一个带有自定义事件处理程序的示例程序，以捕获事件并对其进行过滤。
- en: After learning about events, we implemented a simple drag and drop example.
    Now, you can communicate between classes, between C++ and QML, and implement the
    necessary actions based on events.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了事件之后，我们实现了一个简单的拖放示例。现在，您可以在类之间、在C++和QML之间进行通信，并根据事件实现必要的操作。
- en: In the next chapter, we will learn about Model View programming and how to create
    custom models.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于模型视图编程以及如何创建自定义模型。
