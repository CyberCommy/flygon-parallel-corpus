- en: '*Chapter 6*: Signals and Slots'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we learned how to create GUI applications with Qt
    Widgets and Qt Quick. But to make our applications usable, we need to add a communication
    mechanism. The **signals** and **slots** mechanism is one of the distinct features
    of Qt and makes it unique from other frameworks. Signals and slots are implemented
    through Qt's meta-object system.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about signals and slots in depth and how they
    work internally. You will be able to receive notifications from different classes
    and take the corresponding action.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Qt signals and slots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The working mechanism of Qt signals and slots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know Qt's property system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding signals and the handler event system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding events and the event loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing events with an event filter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drag and drop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to communicate between C++ classes
    with QML and between QML components.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The technical requirements for this chapter include having the minimum versions
    of Qt (6.0.0) and Qt Creator (4.14.0) installed on the latest desktop platform
    available, such as Windows 10, Ubuntu 20.04, or macOS 10.14\.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the code in this chapter can be downloaded from the following GitHub link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter06](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter06)'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The screenshots in this chapter were taken on a Windows machine. You will see
    similar screens based on the underlying platforms on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Qt signals and slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In GUI programming, when a user performs any action with any UI element, another
    element should get updated, or a certain task should be done. To achieve this,
    we want communication between objects. For example, if a user clicks the **Close**
    button on the **Title** bar, it is expected that the window closes. Different
    frameworks use different approaches to achieve this kind of communication. A **callback**
    is one of the most commonly used approaches. A callback is a function that's passed
    as an argument to another function. Callbacks can have multiple drawbacks and
    may suffer from complications in ensuring the type-correctness of callback arguments.
  prefs: []
  type: TYPE_NORMAL
- en: In the Qt framework, we have a substitute for this callback technique known
    as signals and slots. A signal is a message that is passed to communicate that
    the state of an object has changed. This signal may carry information about the
    change that has occurred. A slot is a special function that is invoked in response
    to a specific signal. Since slots are functions, they contain logic to perform
    a certain action. Qt Widgets have many predefined signals, but you can always
    extend your classes and add your own signals to them. Similarly, you can also
    add your own slots to handle the intended signal. Signals and slots make it easy
    to implement the observer pattern while avoiding boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to communicate, you must connect the corresponding signals and slots.
    Let's understand the connection mechanism and syntaxes of a signal and slot connection.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To connect a signal to a slot, we can use `QObject::connect()`. This is a thread-safe
    function. The standard syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding connection, the first argument is the sender object, while
    the next argument is the signal from the sender. The third argument is the receiver
    object, while the fourth is the slot method. The last argument is optional and
    describes the type of connection to be established. It determines whether the
    notification will be delivered to the slot immediately or queued for later. There
    are six different types of connections that can be made in Qt 6\. Let''s have
    a look at the connection types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Qt::DirectConnection` is used; otherwise, `Qt::QueuedConnection` is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt::DirectConnection**: In this case, both the signal and slot live in the
    same thread. The slot is called immediately after the signal is emitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt::QueuedConnection**: In this case, the slot lives in another thread. The
    slot is called once control returns to the event loop of the receiver''s thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt::QueuedConnection`, except that the signaling thread blocks until the slot
    returns. This connection must not be used if both the sender and receiver are
    in the same thread to avoid deadlock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bitwise OR`. This is used to avoid duplicate connections. The connection will
    fail if the connection already exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt::BlockingQueuedConnection` to avoid deadlocks. You are sending an event
    to the same thread and then locking the thread, waiting for the event to be processed.
    Since the thread is blocked, the event will never be processed, and the thread
    will be blocked forever, causing a deadlock. Use this connection type if you know
    what you are doing. You must know the implementation details of both threads before
    using this connection type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several ways to connect signals and slots. You must use the `SIGNAL()`
    and `SLOT()` macros when specifying the signal and the slot function, respectively.
    The most commonly used syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the original syntax that has been around since the beginning of Qt.
    However, its implementation has changed quite a few times. New features have been
    added without breaking the basic **Application Programming Interface** (**API**).
    It is recommended to use the new function pointer syntax, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There are pros and cons to both syntaxes. You can learn more about the differences
    between **string-based** and **functor-based** connections at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doc.qt.io/qt-6/signalsandslots-syntaxes.html](https://doc.qt.io/qt-6/signalsandslots-syntaxes.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a connection fails, then the preceding statement returns `false`. You can
    also connect to functors or C++11 lambdas, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can check the return value to verify whether the signal connected to the
    slot successfully. The connection can fail if the signatures aren't compatible,
    or the signal and slot are missing.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '`Qt::UniqueConnection` does not work for lambdas, non-member functions, and
    functors; it can only be used to connect to member functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The signatures of signals and slots may contain arguments, and these arguments
    may have default values. You can connect a signal to a slot if the signal has
    at least as many arguments as the slot, as well as if there is a possible implicit
    conversion between the types of the corresponding arguments. Let''s look at feasible
    connections with varying numbers of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the following one won''t work as the slot has more arguments than
    the signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Every connection you make emits a signal, so duplicate connections emit two
    signals. You can break a connection using `disconnect()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use Qt with a third-party signal/slot mechanism. If you want to
    use both mechanisms for the same project, then add the following configuration
    to your Qt project (`.pro`) file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let's create an example with a simple signal and slot connection.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring signals and slots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a signal and slot, you must declare the signal and slot inside your
    custom class. The header file of the class will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have added `Q_OBJECT` to the class to facilitate the signals
    and slots mechanism. You can declare a signal with the `signals` keyword in your
    header file, as shown in the previous snippet. Similarly, slots can be declared
    with the `slots` keyword. Both signals and slots can have arguments. In this example,
    we used the same object for the sender and receiver to make this explanation simpler.
    In most cases, signals and slots will be located in different classes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss how to connect the signal to the slot.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the signal to the slot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Previously, we declared a custom signal and slot. Now, let''s look at how to
    connect them. You can define a signal and slot connection and emit the signal
    inside `MyClass`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to emit the signal after the connection to invoke the slot. In the
    preceding example, we used the traditional way of signal and slot declaration.
    You can replace the connection with the latest syntax, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It is not only possible to connect one signal to one slot, but also to connect
    many slots and signals. Similarly, many signals can be connected to one slot.
    We will learn how to do that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting a single signal to multiple slots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can connect the same signal to multiple slots. These slots will be called
    in the same order as the connections are made. Let's consider that a signal named
    `signalX()` is connected to three slots called `slotA()`, `slotB()`, and `slotC()`.
    When `signalA()` is emitted, all three slots will be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the traditional way of making connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create connections as per the new syntax, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will learn how to connect multiple signals to a single
    slot.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting multiple signals to a single slot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, you learned how to create a connection between a single
    signal and multiple slots. Now, let''s look at the following code to understand
    how to connect multiple signals to a single slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have used three different signals called `signalX()`, `signalY()`,
    and `signalZ()`, but there is a single slot defined as `slotX()`. When any of
    these signals are emitted, that slot is called.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to connect one signal to another signal.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting a signal to another signal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you may have to forward a signal instead of directly connecting
    to a slot. You can connect one signal to another signal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create connections as per the new syntax, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding line, we have connected `signalA()` to `signalB()`. Hence,
    when `signalA()` is emitted, `signalB()` will also be emitted and the corresponding
    slot connected to `signalB()` will be invoked. Let''s consider that we have a
    button in our GUI, and we want to forward the button click as a different signal.
    The following code snippet shows how to forward a signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we forwarded the button click signal to our custom
    signal. We can call the slot that is connected to the custom signal as discussed
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how connections are made and how to use signals
    and slots. Now, you can communicate between different classes and share information.
    In the next section, we will learn about the working mechanism behind signals
    and slots.
  prefs: []
  type: TYPE_NORMAL
- en: The working mechanism of Qt signals and slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we learned about signal and slot syntaxes and how
    to connect them. Now, we will understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: While creating a connection, Qt looks for the index of the signal and the slot.
    Qt uses a lookup string table to find the corresponding indexes. Then, a `QObjectPrivate::Connection`
    object is created and added to the internal linked lists. Since one signal can
    be connected to multiple slots, each signal can have a list of the connected slots.
    Each connection contains the receiver's name and the index of the slot. Each object
    has a connection vector that associates with each signal in a linked list of `QObjectPrivate::Connection`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates how `ConnectionList` creates connections
    between sender and receiver objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Illustration of the connection mechanism between the sender
    and receiver'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.1_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Illustration of the connection mechanism between the sender and
    receiver
  prefs: []
  type: TYPE_NORMAL
- en: '`ConnectionList` is a singly linked list that contains all the connections
    from and to an object. `signalVector` contains the lists of connections for a
    given signal. Each `Connection` is also part of a *senders* linked list. Linked
    lists are used because they permit faster addition and removal of objects. Each
    object also has a reversed list of connections the object is connected to for
    automatic deletion. For detailed internal implementation, look at the latest `qobject_p.h`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are quite a few articles on how signals and slots work on the *woboq*
    website. You can also explore the Qt source code on the woboq website. Go to the
    following link if you need further information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://woboq.com/blog/how-qt-signals-slots-work.html](https://woboq.com/blog/how-qt-signals-slots-work.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's learn about Qt's meta-object system.
  prefs: []
  type: TYPE_NORMAL
- en: Qt's meta-object system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Qt''s meta-object system** is the core mechanism behind the signals and slots
    mechanism. It provides features such as inter-object communication, a dynamic
    property system, and runtime type information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The meta-object system is implemented with a three-part mechanism. These mechanisms
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: QObject
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Q_OBJECT macro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meta-Object Compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `QObject` class is the base class of all Qt objects. It is a very powerful
    mechanism that facilitates the signals and slots mechanism. The `QObject` class
    provides a base class for objects that can take advantage of the meta-object system.
    `QObject` derived classes arrange themselves in an object tree. This creates the
    parent-children relationship between classes. When you create a `QObject` derived
    class with another `QObject` derived class as a parent, the object will be automatically
    added to the parent's `children()` list. The parent takes ownership of the object.
    GUI programming requires both runtime efficiency and a high level of flexibility.
    Qt achieved this by combining the speed of C++ with the flexibility of the Qt
    Object Model. Qt provides the required features by implementing standard C++ techniques
    based on the inheritance from QObject.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about the Qt Object Model at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doc.qt.io/qt-6/object.html](https://doc.qt.io/qt-6/object.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The `Q_OBJECT` macro appears inside the private section of the class declaration.
    It is used to enable signals, slots, and other services provided by Qt's meta-object
    system.
  prefs: []
  type: TYPE_NORMAL
- en: '`QObject` derived classes to implement meta-object features. It provides the
    capability to introspect the objects at runtime. By default, C++ does not have
    introspection support. Hence, Qt created `moc`. It is a code-generating program
    that handles Qt''s C++ extensions. The tool reads the C++ header files and if
    it locates the `Q_OBJECT` macro, then it creates another C++ source file with
    the meta-object code. That generated file contains the code required for the introspection.
    Both files are compiled and linked together. In addition to providing the signals
    and slots mechanism for communication between objects, the meta-object code offers
    several additional features to find the class name and inheritance details, and
    also helps with setting properties at runtime. Qt''s `moc` provides a clean way
    to go beyond the compiled language''s facilities.'
  prefs: []
  type: TYPE_NORMAL
- en: You can perform type casts by using `qobject_cast()` on `QObject` derived classes.
    The `qobject_cast()` function acts similar to the standard C++ `dynamic_cast()`.
    The advantage is that it doesn't require `QObject`, but if you don't add the `Q_OBJECT`
    macro, then the signals and slots and the other meta-object system features will
    not be available. A `QObject` derived class without meta code is equivalent to
    its closest ancestor containing meta-object code. There is also a lighter version
    of the `Q_OBJECT` macro, known as `Q_GADGET`, that can be used to utilize some
    of the capabilities provided by `QMetaObject`. A class that uses `Q_GADGET` doesn't
    have signals or slots.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen a few new keywords here, such as `Q_OBJECT`, `signals`, `slots`,
    `emit`, `SIGNAL`, and `SLOT`. These are known as the Qt extensions of C++. They
    are very simple macros meant to be seen by `moc`, defined in `qobjectdefs.h`.
    Out of these, `emit` is an empty macro that is not parsed by `moc`. It is kept
    just to give the developer hints.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn about why Qt uses `moc` for signals and slots at [https://doc.qt.io/qt-6/why-moc.html](https://doc.qt.io/qt-6/why-moc.html).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about Qt's meta-object system. In the next section,
    we will discuss the `moc` generated code and discuss some of the underlying implementations.
  prefs: []
  type: TYPE_NORMAL
- en: MOC generated code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will have a look at the code generated by `moc` in Qt6\.
    When you build the earlier signal and slot example, you will see the generated
    files under the build directory: `moc_myclass.cpp` and `moc_predefs.h`. Let''s
    open the `moc_myclass.cpp` file with a text editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the information about the Qt Meta-Object Compiler version at
    the top of the file. Please note that all the changes that are made in this file
    will be lost on recompiling the project. So, don't modify anything in this file.
    We are looking at the file to understand the working mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the integer data of `QMetaObject`. As you can see, there are
    two columns; the first column is the count, while the second column is the index
    in this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we have one method, and the description of the method starts at
    index 14\. You can find the number of available signals in `signalCount`. For
    each function, `moc` also saves the return type of each parameter, their type,
    and their index to the name. In each meta-object, the methods are given an index,
    beginning with 0\. They are arranged as signals, then slots, and then as other
    functions. These indexes are relative indexes and exclude the indexes of parent
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you look further into the code, you will find the `MyClass::metaObject()`
    function. This function returns `QObject::d_ptr->dynamicMetaObject()` for dynamic
    meta-objects. The `metaObject()` function normally returns the class'' s`taticMetaObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When the incoming string data matches the current class, you must convert this
    pointer into a void pointer and pass it to the outside world. If it is not the
    current class, then `qt_metacast()` of the parent class is called to continue
    the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Qt''s meta-object system uses the `qt_metacall()` function to access the meta-information
    for a particular `QObject` object. When we emit a signal, `qt_metacall()` is called
    and then calls the real signal function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When you call a signal, it calls the `moc` generated code, which internally
    calls `QMetaObject::activate()`, as shown in the following snippet. Then, `QMetaObject::activate()`
    looks into the internal data structures to find out about the slots that are connected
    to that signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the detailed implementation of this function inside `qobject.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing this, you can explore the complete generated code and look at the
    symbols further. Now, let''s look at the `moc` generated code where the slot is
    called. The slot is called by its index in the `qt_static_metacall` function,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The array pointers to the argument are in the same format as the signal. `_a[0]`
    is not touched because everything here returns void:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This returns `true` if the signal is connected to at least one receiver; otherwise,
    it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: When an object is destroyed, an `QObjectPrivate::senders` list is iterated,
    and all `Connection::receiver` are set to `0`. Also, `Connection::receiver->connectionLists->dirty`
    is set to `true`. Each `QObjectPrivate::connectionLists` is also iterated to remove
    the **connection** in the senders lists.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we went through some sections of the `moc` generated code and
    understood the working mechanism behind signals and slots. In the next section,
    we will learn about Qt's property system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know Qt's property system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Qt''s property system is similar to some other compiler vendors. However, it
    provides a cross-platform advantage and works with standard compilers supported
    by Qt on different platforms. To add a property, you must add the `Q_PROPERTY()`
    macro to the `QObject` derived class. This property acts like a class data member,
    but it provides extra features that are available through the Meta-Object System.
    A simple syntax looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding syntax, we used some of the most common parameters. But there
    are more parameters that are supported in the syntax. You can find out more by
    reading the Qt documentation. Let''s have a look at the following code snippet,
    which uses the `MEMBER` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we exported a member variable as a Qt property using
    the `MEMBER` keyword. The type here is `QString`, and the `NOTIFY` signal is used
    to implement QML property binding.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's explore how to read and write properties with the Meta-Object System.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing properties with the Meta-Object System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a class named `MyClass`, which is a subclass of `QWidget`. Let''s
    add the `Q_OBJECT` macro to its private section to enable the property system.
    In this example, we want to create a property in `MyClass` to keep track of a
    version''s value. The name of the property will be `version`, and its type will
    be `QString`, which is defined in `MyClass`. Let''s look at the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To get the property changed notification, you have to emit `versionChanged()`
    after the `version` value is changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the `main.cpp` file for the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the property is set by invoking `setVersion()`.
    You can see that `versionChanged()` signal is emitted every time the version is
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: You can also read a property using `QObject::property()` and write it using
    `QObject::setProperty()`. You can also query dynamic properties using `QObject::property()`,
    similar to compile time `Q_PROPERTY()` declarations.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also set the property like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we discussed the property system. In the next section, we will
    learn about signals and slots in Qt Designer.
  prefs: []
  type: TYPE_NORMAL
- en: Using signals and slots in Qt Designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are using the Qt Widgets module, then you can use Qt Designer to edit
    signal and slot connections in the form. Qt default widgets come with many signals
    and slots. Let's see how we can implement signals and slots in Qt Designer without
    writing any code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can drag a **Dial** control and a **Slider** control onto the form. You
    can add connections via **Signals and Slots Editor** at the bottom tab, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Creating signals and slots connections using Qt Designer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.2_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – Creating signals and slots connections using Qt Designer
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can press *F4* or select the **Edit Signals/Slots** button
    from the top toolbar. Then, you can select the control and create a connection
    by dragging the connection to the receiver. If you have custom signals or slots
    defined for your custom class, they will be automatically displayed in **Signals
    and Slots Editor**. However, most developers prefer to define connections inside
    C++ source files.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed using Qt Designer to implement signals and slots
    in Qt Widgets. Now, let's look at how signals are handled in QML.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding signals and the handler event system in QML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we learned how to connect signals and slots inside C++ source files
    and use them with the Qt Widgets module. Now, let's look at how we can communicate
    in QML. QML has a signal and handler mechanism, similar to signals and slots.
    In a QML document, a signal is an event, and the signal is responded to through
    a signal handler. Like a slot in C++, a signal handler is invoked when a signal
    is emitted in QML. In Qt terminology, the method is a slot that is connected to
    the signal; all the methods defined in QML are created as Qt slots. Hence, there
    is no separate declaration for slots in QML. A signal is a notification from an
    object that some event has occurred. You can place logic inside JavaScript or
    a method to respond to the signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to write a signal handler. You can declare a signal handler
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, `signalName` is the name of the signal. The first letter of the signal's
    name is capitalized while writing a handler. So, the signal handler here is named
    `onSignalName`. The signal and signal handler should be defined inside the same
    object. The logic inside the signal handler is a block of JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when the user clicks within the mouse area, the `clicked()` signal
    is emitted. To handle the `clicked()` signal, we must add the `onClicked:{…}`
    signal handler.
  prefs: []
  type: TYPE_NORMAL
- en: Signal handlers are simple functions that are invoked by the QML engine when
    an associated signal is emitted. When you add a signal to a QML object, Qt automatically
    adds a corresponding signal handler to the object definition.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by adding a custom signal to a QML document.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a signal in QML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add a signal inside your QML class, you must use the `signal` keyword. The
    syntax for defining a new signal is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'A signal can be declared with or without any parameters. If no parameter is
    declared for the signal, then you can leave `()` brackets. You can emit a signal
    by invoking it as a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we added a custom signal `composeMessage()` to the
    QML file. We used the corresponding signal handler; that is, `onComposeMessage()`.
    Then, we added a button that emits the `composeMessage()` signal when it is clicked.
    When you run this example, you will see that the signal handler is called automatically
    when the button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to declare a signal and how to implement the
    corresponding signal handler. In the next section, we will connect the signal
    to a function.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting a signal to a function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can connect a signal to any function defined inside your QML document. You
    can use `connect()` to connect a signal either to a function or another signal.
    When a signal is connected to a function, that function is automatically invoked
    whenever the signal is emitted. This mechanism enables a signal to be received
    by a function instead of a signal handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, the `composeMessage()` signal is connected to the
    `transmitMessage()` function using the `connect()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In QML, signal handling is implemented using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also remove a connection using the `disconnect()` function. You can
    disconnect the connection like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's explore how to forward a signal in QML.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting a signal to a signal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can connect a signal to another signal in QML. You can achieve this using
    the `connect()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore how we can do this by looking at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we connected the `clicked()` signal to the `forwardButtonClick()`
    signal. You can implement the necessary logic at the root level inside the `onForwardButtonClick()`
    signal handler. You can also emit the signal from the button click handler, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we discussed how to connect two signals and handle them. In
    the next section, we will discuss how to communicate between the C++ class and
    QML using signals and slots.
  prefs: []
  type: TYPE_NORMAL
- en: Defining property attributes and understanding property binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Previously, we learned how to define a type in C++ by registering the `Q_PROPERTY`
    of a class, which is then registered with the QML type system. It is also possible
    to create custom properties in a QML document. Property binding is a core feature
    of QML that allows us to create relationships between various object properties.
    You can declare a property in a QML document with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way, you can expose a particular parameter to outside objects or maintain
    internal states more efficiently. Let''s look at the following property declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When you declare a custom property, Qt implicitly creates a property-change
    signal for that property. The associated signal handler is `on<PropertyName>Changed`,
    where `<PropertyName>` is the name of the property, with the first letter capitalized.
    For the previously declared property, the associated signal handler is `onVersionChanged`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If the property is assigned a static value, then it remains constant until
    it is explicitly assigned a new value. To update these values dynamically, you
    should use property binding inside your QML document. We used simple property
    binding earlier, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can combine this with the property that''s exposed by the backend
    C++ class, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the previous line, `myClass` is the backend C++ object that's registered
    with the QML engine. In this case, whenever the `versionChanged()` change signal
    is emitted from the C++ side, the QML `version` property gets updated automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll discuss how to integrate signals and slots between C++ and QML.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating signals and slots between C++ and QML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++, to interact with the QML layer, you can use signals, slots, and `Q_INVOKABLE`
    functions. You can also create properties using the `Q_PROPERTY` macro. To respond
    to signals from objects, you can use the `Connections` QML type. When a property
    changes inside a C++ file, `Q_PROPERTY` automatically updates the values. If the
    property has a binding with any QML property, it will automatically update the
    property values inside QML. In this case, the signal slot mechanism is established
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example, which uses the aforementioned mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we declared a Q_PROPERTY-based notification. We can
    get the new `counter` value when the `counterChanged()` signal is emitted. However,
    we used the `receiveFromQml()` function as a `Q_INVOKABLE` function so that we
    can call it directly inside the QML document. We are emitting `sendToQml()`, which
    is handled inside `main.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s have a look at the QML implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we used `Connections` to connect to the C++ signal.
    On button click, we are calling the `receiveFromQml()` C++ function, where we
    are emitting the signal. We have also declared the `count` property, which also
    listens to `counterChanged()`. We handled the data inside the associated signal
    handler; that is, `onCountChanged`. We can also update the `labelCount` data based
    on the notification:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – The mechanism that was used in this example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.3_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – The mechanism that was used in this example
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram illustrates the communication mechanism in this example.
    For explanation purposes, we have kept multiple approaches in the same example
    to explain the communication mechanism between C++ and QML.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about the signals and slots mechanism through examples.
    In the next section, we will learn about events and the event loop in Qt.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding events and the event loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt is an event-based system, and all GUI applications are event-driven. In an
    event-driven application, there is usually a main loop that listens for events
    and then triggers a callback function when one of those events is detected. Events
    can be spontaneous or synthetic. Spontaneous events come from the outside environment.
    Synthetic events are custom events generated by the application. An event in Qt
    is a notification that represents something that has happened. Qt events are value
    types, derived from `QEvent`, which offers a type enumeration for each event.
    All events that arise inside a Qt application are encapsulated in objects that
    inherit from the `QEvent` class. All `QObject` derived classes can override the
    `QObject::event()` function in order to handle events targeted by their instances.
    Events can come from both inside and outside the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an event occurs, Qt produces an event object by constructing an appropriate
    `QEvent` subclass instance, which it then delivers to the specific instance of
    `QObject` by calling its `event()` function. Unlike the signals and slots mechanism,
    where the slots connected to the signal are usually executed immediately, an event
    must wait for its turn, until the event loop dispatches all the events that arrived
    earlier. You must select the right mechanism as per your intended implementation.
    The following diagram illustrates how events are created and managed in event-driven
    applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Illustration of an event-driven application using the event
    loop'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.4_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – Illustration of an event-driven application using the event loop
  prefs: []
  type: TYPE_NORMAL
- en: We can enter Qt's main event loop by calling `QCoreApplication::exec()`. The
    application keeps running until `QCoreApplication::exit()` or `QCoreApplication::quit()`
    are called, which terminates the loop. `QCoreApplication` can process each event
    in the GUI thread and forward events to QObjects. Please note that the events
    are not delivered immediately; instead, they're queued up in an event queue and
    processed later, one after another. The event dispatcher loops through this queue,
    converts them into `QEvent` objects, and then dispatches the events to the target
    `QObject`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simplified event loop dispatcher may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the important Qt classes related to the event loop are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`event` queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event` loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event` loop for non-GUI based applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event` loop for GUI-based applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QThread** is used to create custom threads and manage threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QSocketNotifier** is used to monitor activity on a file descriptor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event` loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can read about these classes in the Qt documentation. The following link
    provides further insight into the event system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://wiki.qt.io/Threads_Events_QObjects](https://wiki.qt.io/Threads_Events_QObjects).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed events and Qt's event loop. In the next section,
    we will learn how to filter events with an event filter.
  prefs: []
  type: TYPE_NORMAL
- en: Managing events with an event filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to manage events and how to filter a specific
    event and perform a task. You can achieve event filtering by reimplementing event
    handlers and installing event filters. You can redefine what an event handler
    should do by subclassing the widget of interest and reimplementing that event
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt provides five different approaches for event processing, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Reimplementing a specific event handler, such as `paintEvent()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reimplementing the `QObject::event()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing an event filter on the `QObject` instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing an event filter on the `QApplication` instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subclassing `QApplication` and reimplementing `notify()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code handles the left mouse button click on a custom widget while
    passing all other button clicks to the base `QWidget` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we filtered only the left button press event. You
    can add the required action inside the respective block. The following diagram
    illustrates the high-level event processing mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Illustration of the event filter mechanism'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.5_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – Illustration of the event filter mechanism
  prefs: []
  type: TYPE_NORMAL
- en: 'An event filter can be installed either on an application instance or a local
    object. If the event filter is installed in an `QCoreApplication` object, then
    all the events will go through this event filter. If it is installed in a `QObject`
    derived class, then the events that have been sent to that object will go through
    the event filter. Sometimes, there may not be any suitable Qt event type available
    for a specific action. In that case, you can create a custom event by creating
    a subclass from `QEvent`. You can reimplement `QObject::event()` to filter the
    intended event, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have created a custom event class named `MyCustomEvent` and created
    a custom type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s filter these events by reimplementing `event()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have passed the other events to `QWidget::event()` for further
    processing. If you want to prevent the event from propagating further, then `return
    true`; otherwise, `return false`.
  prefs: []
  type: TYPE_NORMAL
- en: An event filter is an object that receives all the events that are sent to an
    object. The filter can either stop the event or forward it to the object. It screens
    the events if an object has been installed as an event filter for the watched
    object. It is also possible to monitor another object for events by using an event
    filter and performing the necessary tasks. The following example shows how to
    reimplement one of the most commonly used events – a keypress event – using the
    *event filter* approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we created a class called `MainWindow` and overridden
    `eventFilter()`. Let''s install the filter on `textEdit` using `installEventFilter()`.
    You can install multiple event filters on an object. However, if multiple event
    filters are installed on a single object, the filter that was installed last will
    be activated first. You can also remove an event filter by calling `removeEventFilter()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we installed an `eventFilter` on the `textEdit` object.
    Now, let''s have a look at the `eventFilter()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here, `textEdit` is the monitored object. Every time you press a key and if
    the `textEdit` is in focus, the event is captured. Since there may more objects
    that are children and `QMainWindow` may require the events, don't forget to pass
    the unhandled events to the base class for further event processing.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Once you've consumed the event in the `eventFilter()` function, make sure to
    `return true`. If the receiver object is deleted and you `return false`, then
    it can result in an application crash.
  prefs: []
  type: TYPE_NORMAL
- en: You can also combine the signals and slots mechanism with the event. You can
    achieve this by filtering the event and emitting a signal that corresponds to
    that event. I hope that you have understood the event handling mechanism in Qt.
    Now, let's look at drag and drop.
  prefs: []
  type: TYPE_NORMAL
- en: Drag and drop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about **drag and drop** (**DnD**). In a GUI application,
    DnD is a pointing device gesture in which the user selects a virtual object by
    *grabbing* it and then *releasing* it on another virtual object. The drag and
    drop operation starts when the user makes some gesture that is recognized as a
    signal to start a drag action.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss how we can implement drag and drop using Qt Widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Drag and drop in Qt Widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Qt Widgets-based GUI applications, where drag and drop is used, the user
    starts dragging from a particular widget and drops the dragged object onto another
    widget. This requires us to reimplement several functions and it handles the corresponding
    events. The most common functions that need to be reimplemented to achieve drag
    and drop are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve reimplemented the preceding functions, enable dropping on the
    target widget with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'To begin a drag, create a `QDrag` object and pass a pointer to the widget that
    begins the drag. The drag and drop operation is handled by a `QDrag` object. This
    operation requires the attached data description to be of the **Multipurpose Internet
    Mail Extensions** (**MIME**) type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows how to create a drag object and set a custom MIME type.
    Here, we used `text/csv` as the MIME type. You can supply more than one type of
    MIME-encoded data with a drag and drop operation.
  prefs: []
  type: TYPE_NORMAL
- en: To intercept drag and drop events, you can reimplement `dragEnterEvent()`. This
    event handler is called when a drag is in progress and the mouse enters the widget.
  prefs: []
  type: TYPE_NORMAL
- en: You can find several relevant examples in the examples section in Qt Creator.
    Since Qt Widgets aren't very popular these days, we are skipping the drag and
    drop example using widgets. In the next section, we will discuss drag and drop
    in QML.
  prefs: []
  type: TYPE_NORMAL
- en: Drag and drop in QML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we discussed drag and drop using widgets. Since QML
    is used to create modern and touch-friendly applications, drag and drop is a very
    important feature. Qt provides several convenient QML types for implementing drag
    and drop. Internally, the corresponding events are handled similarly. These functions
    are declared in the `QQuickItem` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `dragEnterEvent()` is also available in `QQuickItem`, and is used
    to intercept drag and drop events, as described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Let's discuss how to implement this using the available QML types. Using the
    `Drag` attached property, any `Item` can be made a source of drag and drop events
    within a QML scene. A `DropArea` is an invisible item that can receive events
    when an item is dragged over it. When a drag action is active on an item, any
    change that's made to its position will generate a drag event that will be sent
    to any intersecting `DropArea`. The `DragEvent` QML type provides information
    about a drag event.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows a simple drag and drop operation in QML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created a draggable item with an ID of `dragItem`.
    It contains a `MouseArea` to capture the mouse press event. Dragging is not limited
    to mouse drags. A drag action can be triggered by anything that can generate a
    drag event. A drag can be canceled by calling `Drag.cancel()` or by setting the
    `Drag.active` state to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The drop action can be completed with a drop event by calling `Drag.drop()`.
    Let''s add a `DropArea`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we used a light blue rectangle to distinguish it as
    a `DropArea` on the screen. We are catching `dragItem` when it enters the `DropArea`
    region. When `dragItem` is leaving the `DropArea` region, the drop action is disabled.
    Therefore, when the drop is unsuccessful, the item will go back to its original
    position.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about drag and drop actions and their corresponding
    events. We discussed how to implement them using the Qt Widgets module, as well
    as in QML. Now, let's summarize what we learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the core concepts of signals and slots in Qt.
    We discussed different ways of connecting signals and slots. We also learned how
    to connect one signal to multiple slots and multiple signals to a single slot.
    Then, we looked at how to use them with Qt Widgets, as well as in QML, as well
    as the mechanism behind the signal and slot connection. After that, you learned
    how to communicate between C++ and QML using signals and slots.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also discussed events and event loops in Qt. We explored how to
    use events instead of the signal-slot mechanism. After doing this, we created
    a sample program with a custom event handler to capture events and filter them.
  prefs: []
  type: TYPE_NORMAL
- en: After learning about events, we implemented a simple drag and drop example.
    Now, you can communicate between classes, between C++ and QML, and implement the
    necessary actions based on events.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about Model View programming and how to create
    custom models.
  prefs: []
  type: TYPE_NORMAL
