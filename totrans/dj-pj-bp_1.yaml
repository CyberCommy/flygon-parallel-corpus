- en: Chapter 1. Blueblog – a Blogging Platform
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。Blueblog-博客平台
- en: We are going to start with a simple blogging platform in Django. In recent years,
    Django has emerged as one of the clear leaders in web frameworks. When most people
    decide to start using a web framework, their searches lead them to either **Ruby
    on Rails** (**RoR**) or Django. Both are mature, stable, and extensively used.
    It appears that the decision to use one or the other depends mostly on which programming
    language you're familiar with. Rubyists go with RoR, Pythonistas go with Django.
    In terms of features, both can be used to achieve the same results, although they
    have different approaches to how things are done.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的Django博客平台开始。近年来，Django已经成为Web框架中的明星领导者之一。当大多数人决定开始使用Web框架时，他们的搜索结果要么是**Ruby
    on Rails**（**RoR**），要么是Django。两者都是成熟、稳定且被广泛使用的。似乎使用其中一个的决定主要取决于你熟悉哪种编程语言。Ruby程序员选择RoR，Python程序员选择Django。在功能方面，两者都可以用来实现相同的结果，尽管它们对待事物的方式有所不同。
- en: One of the most popular blogging platforms these days is Medium, widely used
    by a number of high profile bloggers. Its popularity stems from its elegant theme,
    and simple-to-use interface. I'll walk you through creating a similar application
    in Django, with a few surprise features that most blogging platforms don't have.
    This will give you a taste of things to come, and show you just how versatile
    Django can be.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如今最受欢迎的博客平台之一是Medium，被许多知名博客作者广泛使用。它的流行源于其优雅的主题和简单易用的界面。我将带你创建一个类似的Django应用程序，其中包含大多数博客平台没有的一些惊喜功能。这将让你体验到即将到来的东西，并展示Django有多么多才多艺。
- en: 'Before starting any software development project, it''s a good idea to have
    a rough roadmap of what we would like to achieve. Here''s a list of features that
    our blogging platform will have:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始任何软件开发项目之前，最好先大致规划一下我们想要实现的目标。以下是我们的博客平台将具有的功能列表：
- en: User should be able to register an account and create their blogs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够注册账户并创建他们的博客
- en: Users should be able to tweak the settings of their blogs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够调整他们博客的设置
- en: There should be simple interface for users to create and edit blog posts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该有一个简单的界面来创建和编辑博客文章
- en: Users should be able to share their blog posts on other blogs on the platform
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够在平台上的其他博客上分享他们的博客文章
- en: I know this seems like a lot of work, but Django comes with a couple of `contrib`
    packages that speed up our work considerably.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这似乎是很多工作，但Django带有一些`contrib`包，可以大大加快我们的工作速度。
- en: The contrib packages
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: contrib包
- en: 'The `contrib` packages are a part of Django that contain some very useful applications
    that the Django developers decided should be shipped with Django. The included
    applications provide an impressive set of features, including some that we''ll
    be using in this application:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`contrib`包是Django的一部分，其中包含一些非常有用的应用程序，Django开发人员决定应该随Django一起发布。这些包含的应用程序提供了令人印象深刻的功能集，包括我们将在此应用程序中使用的一些功能：'
- en: '**Admin** is a full featured CMS that can be used to manage the content of
    a Django site. The Admin application is an important reason for the popularity
    of Django. We''ll use this to provide an interface for site administrators to
    moderate and manage the data in our application'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理是一个功能齐全的CMS，可用于管理Django站点的内容。管理应用程序是Django流行的重要原因。我们将使用此功能为网站管理员提供界面，以便在我们的应用程序中进行数据的审查和管理
- en: '**Auth** provides user registration and authentication without requiring us
    to do any work. We''ll be using this module to allow users to sign up, sign in,
    and manage their profiles in our application'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Auth提供用户注册和身份验证，而无需我们做任何工作。我们将使用此模块允许用户在我们的应用程序中注册、登录和管理他们的个人资料
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are a lot more goodies in the `contrib` module. I suggest you take a look
    at the complete list at [https://docs.djangoproject.com/en/stable/ref/contrib/#contrib-packages](https://docs.djangoproject.com/en/stable/ref/contrib/#contrib-packages).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`contrib`模块中还有很多好东西。我建议你查看完整列表[https://docs.djangoproject.com/en/stable/ref/contrib/#contrib-packages](https://docs.djangoproject.com/en/stable/ref/contrib/#contrib-packages)。'
- en: I usually end up using at least three of the `contrib` packages in all my Django
    projects. They provide often-required features like user registration and management,
    and free you to work on the core parts of your project, providing a solid foundation
    to build upon.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常在所有我的Django项目中至少使用三个`contrib`包。它们提供了通常需要的功能，如用户注册和管理，并使你能够专注于项目的核心部分，为你提供一个坚实的基础来构建。
- en: Setting up our development environment
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的开发环境
- en: For this first chapter, I'll go into some details about setting up the development
    environment. For later chapters, I'll only be providing minimal instructions.
    For further details about how I setup the development environment and why, take
    a look at [Appendix](apa.html "Appendix A. Development Environment Setup Details
    and Debugging Techniques"), *Development Environment Setup Details and Debugging
    Techniques*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这第一章，我将详细介绍如何设置开发环境。对于后面的章节，我只会提供最少的说明。有关我如何设置开发环境以及原因的更多详细信息，请参阅[附录](apa.html
    "附录A.开发环境设置详细信息和调试技术")，*开发环境设置详细信息和调试技术*。
- en: Let's start by creating the directory structure for our project, setting up
    the virtual environment and configuring some base Django settings that need to
    be set up in every project. Let's call our blogging platform BlueBlog.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为我们的项目创建目录结构开始，设置虚拟环境并配置一些基本的Django设置，这些设置需要在每个项目中设置。让我们称我们的博客平台为BlueBlog。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Detailed explanations of the steps you're about to see are given in [Appendix](apa.html
    "Appendix A. Development Environment Setup Details and Debugging Techniques"),
    *Development Environment Setup Details and Debugging Techniques*. Please refer
    to that if you're unsure about why we're doing something or what a particular
    command does.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有关即将看到的步骤的详细说明，请参阅[附录](apa.html "附录A.开发环境设置详细信息和调试技术")，*开发环境设置详细信息和调试技术*。如果您对我们为什么要做某事或特定命令的作用感到不确定，请参考该文档。
- en: To start a new project, you need to first open up your terminal program. In
    Mac OS X, it is the built-in terminal. In Linux, the terminal is named separately
    for each distribution, but you should not have trouble finding it; try searching
    your program list for the word terminal and something relevant should show up.
    In Windows, the terminal program is called the command line. You'll need to start
    the relevant program depending on your operating system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using the Windows operating system, you will need to slightly modify
    the commands shown in the book. Please refer to the *Developing on Windows* section
    of [Appendix](apa.html "Appendix A. Development Environment Setup Details and
    Debugging Techniques"), *Development Environment Setup Details and Debugging Techniques*
    for details.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the relevant terminal program for your operating system and start by creating
    the directory structure for our project; `cd` (ing) into the root project directory
    using the commands shown below:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next let''s create the virtual environment, install Django, and start our project:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With that out of the way, we're ready to start developing our blogging platform.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Database settings
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open up the settings found at `$PROJECT_DIR/src/blueblog/settings.py` in your
    favorite editor and make sure that the `DATABASES` settings variable matches this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In order to initialize the database file, run the following commands:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Static files settings
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last step in setting up our development environment, is configuring the
    `staticfiles` `contrib` application. The staticfiles application provides a number
    of features that make it easy to manage the static files (css, images, JavaScript)
    of your projects. While our usage will be minimal, you should look at the Django
    documentation for staticfiles in further detail, since it is used quite heavily
    in most real world Django projects. You can find the documentation at [https://docs.djangoproject.com/en/stable/howto/static-files/](https://docs.djangoproject.com/en/stable/howto/static-files/).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: In order to set up the staticfiles application we have to configure a few settings
    in the `settings.py` file. First, make sure that `django.contrib.staticfiles`
    is added to the `INSTALLED_APPS`. Django should have done that by default.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Next, set `STATIC_URL` to whatever URL you want your static files to be served
    from. I usually leave this to the default value, `/static/`. This is the URL that
    Django will put in your templates when you use the static template tag to get
    the path to a static file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: A base template
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next let''s setup a base template that all the other templates in our application
    will inherit from. I prefer to have templates that are used by more than one application
    of a project in a directory named templates in the project source folder. To set
    that up, add `os.path.join(BASE_DIR, ''templates'')` to the `DIRS` array of the
    `TEMPLATES` config dictionary in the settings file, and then create a directory
    named templates in `$PROJECT_ROOT/src`. Next, using your favorite text editor,
    create a file named `base.html` in the new folder with the following content:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Much like Python classes inheriting from other classes, Django templates can
    also inherit from other templates. And just like Python classes can have functions
    overridden by their subclasses, Django templates can also define blocks that children
    templates can override. Our `base.html` template provides one block for inheriting
    templates to override, called **content**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The reason for using template inheritance is code reuse. We should put HTML
    that we want to be visible on every page of our site, such as headers, footers,
    copyright notices, meta tags, and so on, in the base template. Then, any template
    inheriting from it will automatically get all that common HTML included automatically,
    and we will only need to override the HTML code for the block we want to customize.
    You'll see this principal of creating and overriding blocks in base templates
    used throughout the projects in this book.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板继承的原因是代码重用。我们应该将我们希望在网站的每个页面上可见的HTML，如标题、页脚、版权声明、元标记等，放在基础模板中。然后，任何继承自它的模板将自动获得所有这些常见的HTML，我们只需要覆盖我们想要自定义的块的HTML代码。你将看到这种在本书中的项目中使用创建和覆盖基础模板中的块的原则。
- en: User accounts
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户帐户
- en: With the database setup out of the way, let's start creating our application.
    If you remember, the first thing on our list of features is to allow users to
    register accounts on our site. As I've mentioned before, we'll be using the auth
    package from the Django contrib packages to provide user account features.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库设置完成后，让我们开始创建我们的应用程序。如果你记得的话，我们功能列表中的第一件事是允许用户在我们的网站上注册帐户。正如我之前提到的，我们将使用Django
    contrib包中的auth包来提供用户帐户功能。
- en: In order to use the auth package, we'll need to add it our `INSTALLED_APPS`
    list in the settings file (found at `$PROJECT_ROOT/src/blueblog/settings.py`).
    In the settings file, find the line defining `INSTALLED_APPS` and make sure that
    the string `django.contrib.auth` is part of the list. It should be by default,
    but for some reason if it's not there, add it manually.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用auth包，我们需要在设置文件（位于`$PROJECT_ROOT/src/blueblog/settings.py`）中的`INSTALLED_APPS`列表中添加它。在设置文件中，找到定义`INSTALLED_APPS`的行，并确保字符串`django.contrib.auth`是列表的一部分。默认情况下应该是这样的，但如果不是，请手动添加。
- en: You'll see that Django has included the auth package and couple of other contrib
    applications to the list by default. A new Django project includes these applications
    by default because almost all Django projects end up using these.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到Django默认情况下包含了auth包和其他一些contrib应用程序到列表中。一个新的Django项目默认包含这些应用程序，因为几乎所有的Django项目最终都会使用它们。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you need to add the auth application to the list, remember to use quotes
    to surround the application name.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要将auth应用程序添加到列表中，请记住使用引号括起应用程序名称。
- en: We also need to make sure that the `MIDDLEWARE_CLASSES` list contains `django.contrib.sessions.middleware.SessionMiddleware`,
    `django.contrib.auth.middleware.AuthenticationMiddleware`, and `django.contrib.auth.middleware.SessionAuthenticationMiddleware`.
    These middleware classes give us access to the logged in user in our views, and
    also make sure that if I change the password for my account, I'm logged out from
    all other devices that I previously logged on to.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保`MIDDLEWARE_CLASSES`列表包含`django.contrib.sessions.middleware.SessionMiddleware`、`django.contrib.auth.middleware.AuthenticationMiddleware`和`django.contrib.auth.middleware.SessionAuthenticationMiddleware`。这些中间件类让我们在视图中访问已登录的用户，并确保如果我更改了我的帐户密码，我将从先前登录的所有其他设备中注销。
- en: As you learn more about the various contrib applications and their purpose,
    you can start removing any that you know you won't need in your project. Now,
    let's add the URLs, views and templates that allow the users to register with
    our application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你对各种contrib应用程序及其用途的了解越来越多，你可以开始删除你知道在项目中不需要的任何应用程序。现在，让我们添加允许用户在我们的应用程序中注册的URL、视图和模板。
- en: A user accounts app
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户帐户应用程序
- en: 'In order to create the various views, URLs, and templates related to user accounts,
    we''ll start a new application. To do so, type the following in your command line:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建与用户帐户相关的各种视图、URL和模板，我们将开始一个新的应用程序。要这样做，在命令行中输入以下内容：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This should create a new `accounts` folder inside the `src` folder. We'll add
    code that deals with user accounts in files found inside this folder. To let Django
    know that we want to use this application in our project, add the application
    name (accounts) to the `INSTALLED_APPS` setting variable; making sure to surround
    it in quotes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`src`文件夹内创建一个新的`accounts`文件夹。我们将在这个文件夹内的文件中添加处理用户帐户的代码。为了让Django知道我们想要在项目中使用这个应用程序，将应用程序名称（accounts）添加到`INSTALLED_APPS`设置变量中；确保用引号括起来。
- en: Account registration
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帐户注册
- en: 'The first feature we will work on is user registration. Let''s start by writing
    the code for the registration view inside `accounts/views.py`. Make sure that
    the contents of `views.py` match what is shown here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的第一个功能是用户注册。让我们从在`accounts/views.py`中编写注册视图的代码开始。确保`views.py`的内容与这里显示的内容匹配：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'I''ll explain what each line of this code is doing in a bit. But first, I''d
    like you to get to a state where you can register a new user and see for yourself
    how the flow works. Next, we''ll create the template for this view. In order to
    create the template, you first need to create a new folder called `templates`
    inside the `accounts` folder. The name of the folder is important, since Django
    automatically searches for templates in folders of that name. To create this folder,
    just type the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在稍后解释这段代码的每一行都做了什么。但首先，我希望你能达到一个状态，可以注册一个新用户并亲自看看流程是如何工作的。接下来，我们将为这个视图创建模板。为了创建模板，你首先需要在`accounts`文件夹内创建一个名为`templates`的新文件夹。文件夹的名称很重要，因为Django会自动在具有该名称的文件夹中搜索模板。要创建这个文件夹，只需输入以下命令：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, create a new file called `user_registration.html` inside the `templates`
    folder and type in the code shown below:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`templates`文件夹内创建一个名为`user_registration.html`的新文件，并输入下面显示的代码：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, remove the existing code in `blueblog/urls.py` and replace it with
    this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，删除`blueblog/urls.py`中的现有代码，并替换为以下内容：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That''s all the code we need to get user registration in our project! Let''s
    do a quick demonstration. Run the development server by typing the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在项目中需要的所有代码来实现用户注册！让我们进行一个快速演示。通过输入以下命令来运行开发服务器：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In your browser, visit `http://127.0.0.1:8000/new-user/` and you'll see a user
    registration form. Fill that in, and click submit. You'll be taken to a blank
    page on successful registration. If there are some errors the form will be shown
    again with the appropriate error messages. Let's verify that our new account was
    indeed created in our database.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，访问`http://127.0.0.1:8000/new-user/`，您将看到一个用户注册表单。填写表单并点击提交。成功注册后，您将被带到一个空白页面。如果有错误，表单将再次显示，并显示适当的错误消息。让我们验证一下我们的新账户是否确实在数据库中创建了。
- en: 'For the next step, we will need to have an administrator account. The Django
    auth contrib application can assign permissions to user accounts. The user with
    the highest level of permission is called the **super user**. The super user account
    has free reign over the application and can perform any administrator actions.
    To create a super user account, run this command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将需要一个管理员账户。Django auth contrib应用程序可以为用户账户分配权限。具有最高权限级别的用户被称为**超级用户**。超级用户账户可以自由地管理应用程序并执行任何管理员操作。要创建超级用户账户，请运行以下命令：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since you already have the `runserver` command running in your terminal, you
    will need to quit it first by pressing *Ctrl* + *C* in the terminal. You can then
    run the `createsuperuser` command in the same terminal. After running the `createsuperuser`
    command, you'll need to start the `runserver` command again to browse the site.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您已经在终端中运行了`runserver`命令，您需要先按下终端中的*Ctrl* + *C*来退出。然后您可以在同一个终端中运行`createsuperuser`命令。运行`createsuperuser`命令后，您需要再次启动`runserver`命令来浏览网站。
- en: If you want to keep the `runserver` command running and run the `createsuperuser`
    command in a new terminal window, you will need to make sure you activate the
    virtual environment for this application by running the same source `blueblogEnv/bin/activate`
    command that we ran earlier when we created our new project.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想保持`runserver`命令运行，并在新的终端窗口中运行`createsuperuser`命令，您需要确保通过运行与我们创建新项目时相同的`source
    blueblogEnv/bin/activate`命令来激活此应用程序的虚拟环境。
- en: After you have created the account visit `http://127.0.0.1:8000/admin/` and
    log in with the admin account. You will see a link titled **Users**. Click that
    and you should see a list of users registered in our app. It will include the
    user you just created.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完账户后，访问`http://127.0.0.1:8000/admin/`并使用管理员账户登录。您将看到一个名为**Users**的链接。点击该链接，您应该会看到我们应用程序中注册的用户列表。其中将包括您刚刚创建的用户。
- en: Congrats! In most other frameworks, getting to this point with a working user
    registration feature would take a lot more effort. Django, with it's batteries
    included approach, allows us to do the same with a minimum of effort.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！在大多数其他框架中，要实现一个可用的用户注册功能，需要付出更多的努力。Django以其一应俱全的方式，使我们能够以最少的努力实现相同的功能。
- en: Next, I'll explain what each line of code that you wrote does.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将解释您编写的每行代码的作用。
- en: Generic views
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用视图
- en: 'Here''s the code for the user registration view again:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用户注册视图的代码：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our view is pretty short for something that does such a lot of work. That's
    because instead of writing code from scratch to handle all the work, we use one
    of the most useful features of Django, generic views. Generic views are base classes
    included with Django that provide functionality commonly required by a lot of
    web apps. The power of generic views comes from the ability to customize them
    to a great degree with ease.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的视图对于做了这么多工作来说非常简短。这是因为我们使用了Django最有用的功能之一，即通用视图，而不是从头开始编写处理所有工作的代码。通用视图是Django提供的基类，提供了许多Web应用程序通常需要的功能。通用视图的强大之处在于能够轻松地对其进行大量定制。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about Django generic views in the documentation available
    at [https://docs.djangoproject.com/en/stable/topics/class-based-views/](https://docs.djangoproject.com/en/stable/topics/class-based-views/).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.djangoproject.com/en/stable/topics/class-based-views/](https://docs.djangoproject.com/en/stable/topics/class-based-views/)上的文档中阅读更多关于Django通用视图的信息。
- en: Here, we're using the `CreateView` generic view. This generic view can display
    a `ModelForm` using a template and on submission can either redisplay the page
    with errors if the form data was invalid or call the `save` method on the form
    and redirect the user to a configurable URL. The `CreateView` can be configured
    in a number of ways.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`CreateView`通用视图。这个通用视图可以使用模板显示`ModelForm`，并在提交时，如果表单数据无效，可以重新显示页面并显示错误，或者调用表单的`save`方法并将用户重定向到可配置的URL。`CreateView`可以以多种方式进行配置。
- en: If you want a `ModelForm` to be created automatically from some Django model,
    just set the `model` attribute to the `model` class, and the form will be generated
    automatically from the fields of the model. If you want the form only show certain
    fields from the model, use the `fields` attribute to list the fields you want,
    exactly like you'd do when using a `ModelForm`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望从某个Django模型自动生成`ModelForm`，只需将`model`属性设置为`model`类，表单将自动从模型的字段生成。如果您希望表单只显示模型的某些字段，请使用`fields`属性列出您想要的字段，就像使用`ModelForm`时所做的那样。
- en: In our case, instead of having a `ModelForm` generated automatically, we're
    providing one of our own; `UserCreationForm`. We do this by setting the `form_class`
    attribute on the view. This form, which is part of the auth contrib app, provides
    the fields and a `save` method that can be used to create a new user. As we start
    developing more complicated applications in later chapter, you'll see that this
    theme of composing solutions from small reusable parts provided by Django is a
    common practice in Django web app development, and in my opinion is one of the
    best features of the framework.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们不是自动生成`ModelForm`，而是提供了我们自己的`UserCreationForm`。我们通过在视图上设置`form_class`属性来实现这一点。这个表单是auth
    contrib应用的一部分，它提供了字段和一个`save`方法，可以用来创建一个新用户。随着我们在后面的章节中开始开发更复杂的应用程序，您会发现这种从Django提供的小型可重用部分组合解决方案的主题是Django
    Web应用程序开发中的常见做法，我认为这是框架中最好的特性之一。
- en: Finally, we define a `get_success_url` function that does a simple reverse URL
    and returns the generated URL. The `CreateView` calls this function to get URL
    to redirect the user to when a valid form is submitted and saved successfully.
    To get something up and running quickly, we left out a real success page and just
    redirected the user to a blank page. We'll fix this later.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Template and URLs
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The template, which extends the base template we created earlier simply displays
    the form passed to it by the `CreateView` using the `form.as_p` method, which
    you might have seen in the simple Django projects you may have worked on before.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: The `urls.py` file is a bit more interesting. You should be familiar with most
    of it, the parts where we include the admin site URLs and the part where we assign
    our view a URL. It's the usage of `TemplateView` that I want to explain here.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Like the `CreateView`, the `TemplateView` is another generic view provided to
    us by Django. As the name suggests, this view can render and display a template
    to the user. It has a number of customization options. The most important one
    is `template_name`, which tells it which template to render and display to the
    user.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: We could have created another view class that subclassed the `TemplateView`,
    and customized it by setting attributes and overriding functions like we did for
    our registration view. But I wanted to show you another method of using a generic
    view in Django. If you only need to customize some basic parameters of a generic
    view; in this case we only wanted to set the `template_name` parameter of the
    view, you can just pass the values as `key=value` pairs as function keyword arguments
    to the `as_view` method of the class when including it in the `urls.py` file.
    Here, we pass the template name which the view renders when the user access it's
    URL. Since we just needed a placeholder URL to redirect the user to, we simply
    use the blank `base.html` template.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This technique of customizing generic views by passing key/value pairs only
    makes sense when you're interested in customizing very basic attributes, like
    we do here. In case you want more complicated customizations, I advice you subclass
    the view, otherwise you will quickly get messy code that is difficult to maintain.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Login and logout
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With registration out of the way, let's write code to provide users with the
    ability to log in and log out. To start, the user needs some way to go to the
    login and registration pages from any page on the site. To do this, we'll need
    to add header links to our template. This is the perfect opportunity to demonstrate
    how template inheritance can lead to much cleaner and less code in our templates.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines right after the `body` tag in our `base.html` file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you open the home page for our site now (at `http://127.0.0.1:8000/`), you
    should see that we now have three links on what was previously a blank page. It
    should look similar to the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![Login and logout](img/00698_01_01.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: Click on the **Register Account** link. You'll see the registration form we
    had before, and the same three links again. Note how we only added those links
    to the `base.html` template. But since the user registration template extends
    the base template, it got those links without any effort on our part. This is
    where template inheritance really shines.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that the `href` for the login/logout links is empty.
    Let's start with the login part.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: The login view
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s define the URL first. In `blueblog/urls.py` import the login view from
    the auth app:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, add this to the `urlpatterns` list:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then create a new file inside `accounts/templates` called `login.html`. Put
    in the following content:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, open up `blueblog/settings.py` and add the following line to the end
    of the file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let's go over what we've done here. First, notice that instead of creating our
    own code to handle the login feature, we used the view provided by the auth app.
    We import it using `from django.contrib.auth.views import login`. Next, we associate
    it with the login/URL. If you remember the user registration part, we passed the
    template name to the home page view as a keyword parameter in the `as_view()`
    function. That approach is used for class-based views. For old-style view functions,
    we can pass a dictionary to the `url` function that is passed as keyword arguments
    to the view. Here, we use the template we created in `login.html`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们在这里所做的事情。首先，请注意，我们没有创建自己的代码来处理登录功能，而是使用了auth应用程序提供的视图。我们使用`from django.contrib.auth.views
    import login`导入它。接下来，我们将其与登录/URL关联起来。如果您还记得用户注册部分，我们将模板名称作为关键字参数传递给`as_view()`函数中的主页视图。这种方法用于基于类的视图。对于旧式的视图函数，我们可以将一个字典传递给`url`函数，作为关键字参数传递给视图。在这里，我们使用了我们在`login.html`中创建的模板。
- en: If you look at the documentation for the login view ([https://docs.djangoproject.com/en/stable/topics/auth/default/#django.contrib.auth.views.login](https://docs.djangoproject.com/en/stable/topics/auth/default/#django.contrib.auth.views.login)),
    you'll see that on successfully logging in, it redirects the user to `settings.LOGIN_REDIRECT_URL`.
    By default, this setting has a value of `/accounts/profile/`. Since we don't have
    such a URL defined, we change the setting to point to our home page URL instead.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看登录视图的文档（[https://docs.djangoproject.com/en/stable/topics/auth/default/#django.contrib.auth.views.login](https://docs.djangoproject.com/en/stable/topics/auth/default/#django.contrib.auth.views.login)），您会发现成功登录后，它会将用户重定向到`settings.LOGIN_REDIRECT_URL`。默认情况下，此设置的值为`/accounts/profile/`。由于我们没有定义这样的URL，我们将更改设置以指向我们的主页URL。
- en: Next, let's define the logout view.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定义登出视图。
- en: The logout view
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 登出视图
- en: 'In `blueblog/urls.py` import the logout view using `from django.contrib.auth.views
    import logout` and add the following to the `urlpatterns` list:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在`blueblog/urls.py`中使用`from django.contrib.auth.views import logout`导入登出视图，并将以下内容添加到`urlpatterns`列表中：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: And that's it. The logout view doesn't need a template; it just needs to be
    configured with a URL to redirect the user to after login them out. We just redirect
    the user back to the login page.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。登出视图不需要模板；它只需要配置一个URL，以在登出后将用户重定向到该URL。我们只需将用户重定向回登录页面。
- en: Navigation links
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导航链接
- en: 'Having added the login/logout view, we need to make the links we added in our
    navigation menu earlier take the user to those views. Change the list of links
    we had in `templates/base.html` to the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了登录/登出视图之后，我们需要让之前在导航菜单中添加的链接带用户到这些视图。将`templates/base.html`中的链接列表更改为以下内容：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will show the **Login and Register Account** links to the user if they
    aren't already logged in. If they are logged in, which we check using the `request.user.is_authenticated`
    function, they are only shown the **Logout** link. You can test all of these links
    yourself and see how little code was needed to make such a major feature of our
    site work. This is all possible because of the contrib applications that Django
    provides.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户尚未登录，这将向用户显示**登录和注册账户**链接。如果他们已经登录，我们使用`request.user.is_authenticated`函数进行检查，只会显示**登出**链接。您可以自行测试所有这些链接，并查看需要多少代码才能使我们网站的一个重要功能运行。这一切都是因为Django提供的contrib应用程序。
- en: The blog
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 博客
- en: 'With the user registration out of the way, let''s get started with the blogging
    side of the application. We''ll create a new application for the blog, so in the
    console, type in the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 用户注册已经完成，让我们开始处理应用程序的博客部分。我们将为博客创建一个新应用程序，在控制台中输入以下内容：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Add the blog application to the list of `INSTALLED_APPS` in our `settings.py`
    file. With the app created and installed, let's start with the models we'll be
    using.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将博客应用程序添加到`settings.py`文件中的`INSTALLED_APPS`列表中。应用程序创建并安装后，让我们开始使用我们将使用的模型。
- en: Models
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: 'In `blog/models.py`, type the code shown below:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在`blog/models.py`中，输入下面显示的代码：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After typing in this code, run the following commands to create the database
    tables for these models:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入此代码后，运行以下命令为这些模型创建数据库表：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will create the database tables necessary to support our new models. The
    models are pretty basic. One field type that you might not have used before is
    the **SlugField**. A slug is a piece of text that is used to uniquely identify
    something. In our case, we use two slug fields to identify both our blog and our
    blog post. Since the fields are non-editable, we'll have to write the code to
    give them some values ourselves. We'll look into that later.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建支持我们新模型所需的数据库表。模型非常基本。您可能以前没有使用过的一个字段类型是**SlugField**。Slug是用于唯一标识某物的一段文本。在我们的情况下，我们使用两个slug字段来标识我们的博客和博客文章。由于这些字段是不可编辑的，我们将不得不编写代码为它们赋一些值。我们稍后会研究这个问题。
- en: Creating a blog view
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建博客视图
- en: 'Let''s create a view where the user can setup his blog. Let''s make the form
    that the user will use to create a new blog. Create a new file `blog/forms.py`
    and enter the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个视图，用户可以在其中设置他的博客。让我们创建一个用户将用来创建新博客的表单。创建一个新文件`blog/forms.py`，并输入以下内容：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This creates a model form that allows edits to only the **title** field of our
    `Blog` model. Let's create a template and view to go along with this form.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个模型表单，允许仅对我们的`Blog`模型的**标题**字段进行编辑。让我们创建一个模板和视图来配合这个表单。
- en: 'Create a file called `blog/templates/blog_settings.html` and type in the following
    HTML code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`blog/templates/blog_settings.html`的文件，并输入以下HTML代码：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you may have noticed, I've used the `url` tag on the blog-settings named
    URL, but haven't created that URL pattern yet. We'll do that after we create the
    view, but just remember the name for later and make sure our URL gets the same
    name.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我在博客设置命名的URL上使用了`url`标签，但尚未创建该URL模式。在创建视图后，我们将这样做，但请记住名称，确保我们的URL得到相同的名称。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is no right order in which to create your view, template and URLs. It's
    up to you to decide whichever you are more comfortable with.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `blog/views.py` file, add the following code to create the view:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Modify `blueblog/urls.py`. Add this to the top of the file `from blog.views
    import NewBlogView` and add this to the `urlpatterns` list:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As a final step, we need some way for the user to access our new view. Change
    the header block in `base.html` to look like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To test our latest feature, open up the home page at `http://127.0.0.1:8000`
    and click the **Create New Blog** link. It will present a form where you can enter
    the blog title and save your new blog. The page should look similar to the following
    screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a blog view](img/00698_01_02.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: Most of the code we have added is pretty basic. The interesting part is the
    `NewBlogView`. Let's look at how it works. First of all, notice that we subclass
    it from the `CreateView` generic view. The create view allows us to easily display
    and process a form that will create a new object of the given model. To configure
    it, we can either set the `model` and `fields` attribute of the view, which the
    create view will then use to generate a model form, or we can manually create
    a model form and assign it to the view, like we've done here.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: We also configure the template that will be used to display the form. We then
    define the `form_valid` function, which the create view calls when the form is
    submitted with valid data. In our implementation, we call the model forms `save`
    method with the `commit` keyword parameter set to `False`. This tells the form
    to create a new object of our model with the data it was passed, but not to save
    the created object to the database. Then we set the owner of the new blog object
    to the logged in user and set its slug to a slugified version of the title entered
    by the user. slugify is one of the many utility functions that Django provides.
    Once we've modified the blog object per our requirement, we save it and return
    an `HttpResponseRedirect` from the `form_valid` function. This response is returned
    to the browser which then takes the user to the home page.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we've made do with a blank page with just a navigation bar as our
    home page. But it has a serious problem. Start by creating a new blog by following
    the link in the navigation bar. On successfully creating a new blog, we are redirected
    back to the home page, where we are again greeted with a link to create another
    blog. But this isn't the behavior we want. Ideally, our users should be limited
    to one blog per account.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fix this. First, we''ll restrict the blog creation view to only allow
    users to create a blog if they don''t already have one. Import `HttpResponseForbidden`
    and the `Blog` model in `blog/views.py`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add a `dispatch` method to the `NewBlogView` class with the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `dispatch` method is one of the most useful methods to override on generic
    views. It is the first method that is called when the view URL is hit, and decides
    based on the request type whether to call the `get` or `post` methods on the view
    class to process the request. Thus, if you ever want to have some code that is
    run on all request types (GET, POST, HEAD, PUT, and so on), dispatch is the best
    method to override.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we make sure that the user doesn't already have a blog object
    associated with their account. If they do, we return the `Not Allowed` response
    by using the `HttpResponseForbidden` response class. Try it out. You shouldn't
    even be able to access the new blog page now if you have already created a blog
    before and should see an error instead.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing. Try accessing the URL `http://127.0.0.1:8000/blog/new/` after
    logging out. Notice how you''ll get an `AnonymousUser` object is not iterable
    error. This is because even though you''re not logged in as a registered user,
    the code for the view still assumes that you are. Also, you should not be able
    to access the new blog page without logging in first. To fix this, first put these
    two import lines at the top of `blog/views.py`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then change the definition line of the dispatch method to match the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you try to access the page now without logging in first, you should see
    a `Page not found (404)` Django error page. If you look at the URL for that page,
    you''ll see that Django is trying to serve the `/accounts/login/` URL. That''s
    the default behavior for the `login_required` decorator. To fix this we need to
    change the value of the `LOGIN_URL` variable in our settings file. Put this in
    `blueblog/settings.py`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Try accessing `http://localhost:8000/blog/new/` now and you will be redirected
    to the login page. If you put in the correct username/password combination, you
    will be logged in and taken to the page you were trying to access before, the
    **Create New Blog** page. This functionality is provided to us for free because
    we use the built-in login view of Django.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: We'll discuss the `method_decorator` and the `login_required` decorator in later
    chapters. If you want more info on these now, look at their documentation in the
    Django docs. It does an excellent job of explaining both.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: You will find the documentation for `login_required` at [https://docs.djangoproject.com/en/stable/topics/auth/default/#the-login-required-decorator](https://docs.djangoproject.com/en/stable/topics/auth/default/#the-login-required-decorator).
    For the `method_decorator`, you can look at [https://docs.djangoproject.com/en/stable/topics/class-based-views/intro/#decorating-the-class](https://docs.djangoproject.com/en/stable/topics/class-based-views/intro/#decorating-the-class).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The home page
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s high time that we created a proper home page for our users instead of
    showing a blank page with some navigation links. Also, it seems very unprofessional
    to show users the **Create New Blog** link when it leads to an error page. Let''s
    fix all these issues by creating a home page view that contains a bit of intelligence.
    We''ll put the code for our home page view in the blog application. Technically
    it can go anywhere, but I personally like to put such views in either the main
    application of the project (the blog in this case) or create a new application
    for such common views. In your `blog/views.py` file, import the `TemplateView`
    generic view `from django.views.generic import TemplateView` and put the following
    code for the view:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Tie this new view to the home page URL by importing it in `blueblog/urls.py`
    using `from blog.views import HomeView` and changing the existing root URL config
    from `url(r'^$', TemplateView.as_view(template_name='base.html'), name='home'),`
    to `url(r'^$', HomeView.as_view(), name='home'),`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Since the `TemplateView` class is no longer required, you can remove it from
    the imports. You should already have a good idea of what we're doing here. The
    only new thing is the `TemplateView` and it's `get_context_data` method. The `TemplateView`
    is another one of Djangos built-in generic views. We configure it by providing
    a template file name and the view renders that template by passing it the dictionary
    returned by our `get_context_data` function as the context. Here, we are setting
    the `has_blog` context variable to `True` if the user has an existing blog associated
    with his account.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'With our view done, we''ll need to make a few changes to our `base.html` template
    and add a new `home.html` template. For the `base.html` template, change the code
    in the header block to match:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We''ve removed the **Create New Blog** link and replaced it with another block
    called `logged_in_nav`. The idea is that each page that inherits from the base
    template can add navigation links here to be shown to a logged in user. Finally,
    create a new file called `blog/templates/home.html` and add the following code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Just like we discussed, the home page template overrides the `logged_in_nav`
    block to add a link to create a new blog if the user doesn't have an existing
    blog, or to edit the settings for the existing blog. You can test that all of
    our changes work by visiting the home page with a user that has a blog already
    created, and a new user without a blog. You'll see that link to create a new blog
    only shows up if the user hasn't already created one.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's work on the settings view.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The blog settings view
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Put the code for the view in `blog/views.py`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You''ll need to import `UpdateView` from `django.views.generic`. Also, update
    the `get_context_data` method of the `HomeView` in the same file to match this
    one:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Change the `blog/templates/blog_settings.html` to look like the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The only change we've done is to remove the URL we defined explicitly in the
    form action before. This way, the form will always submit to whatever URL it is
    served from. This is important as we'll see later.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `blog/templates/home.html` as shown in the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Finally, import the `UpdateBlogView` in `blueblog/urls.py` and add the following
    to the `urlpatterns`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: That's it. Visit the home page with the user you used to create the blog in
    the last section and this time you'll see a link to edit your blog instead of
    creating a new one. The interesting thing to look at here in the `UpdateView`
    subclass; `UpdateBlogView`. We only defined the form class, the template name,
    the success URL and the model to get a complete working update view. With these
    things configured, and our URLs set up so that the primary key of the object we
    want to edit is passed to our view as the keyword argument named `pk`, the `UpdateView`
    displays a form tied to the instance of the model we want to edit. In the home
    view, we add the users blog to the context and use it in the home template to
    generate a URL for the update view.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: In the form, we needed to change the action attribute of the form so that on
    submit, it posted to the current page. Since we use the same template in both
    the create and update views, we need the form to submit to whatever URL it is
    rendered from. As you'll see in the upcoming projects as well, it is a common
    practice in Django to use the same template with similar views. And the way Django
    generic views are structured makes it easier to do.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Creating and editing blog posts
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create the views that users can use to create and edit blog posts. Let''s
    start with creating a new blog post. We already created the model earlier, so
    let''s start with the form and template we''ll use. In `blog/forms.py`, create
    this form:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You''ll need to import the `BlogPost` model as well. For the template, create
    a new file `blog/templates/blog_post.html`, and add the following content:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In `blog/views.py`, import the `BlogPostForm` and `BlogPost` model and then
    create the `NewBlogPostView`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In `blueblog/urls.py`, import the preceding view and add the following URL
    pattern:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And finally, change the homepage template `blog/template/home.html` to link
    to our new page:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: All of this code should be pretty familiar to you by now. We've used model forms
    and generic views to get the functionality we need, and all we needed to do was
    configure some stuff. We haven't written one line of code to create the relevant
    form fields, validate the user input, and to handle the various error and success
    scenarios.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: You can test out our new view by using the **Create New Blog Post** link in
    the navigation on the home page.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Editing blog posts
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we did before with the `Blog` model, we''ll create an edit view for the
    blog post using the same template as the create view. But first, we need to add
    a way for the user to see his blog posts with links to the edit page. To keep
    things simple, let''s add this list to our home page view. In the **HomeView**,
    edit the `get_context_data` method to match the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'At the end of `blog/templates/home.html;` after the `logged_in_nav` block ends,
    add the following code to override the content block and show the blog posts:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you visit the home page now, you''ll see a list of posts that the user has
    made. Let''s create the functionality to edit the posts. Create the following
    view in `blog/views.py`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Import this view into your `blueblog/urls.py` file and add the following pattern:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Edit the list of blog posts we created earlier in the home page template to
    add the URL for editing a post:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If you open the home page now, you''ll see that you can click on the **Edit
    Post** link and that it takes you to the editing page for the blog post. One last
    thing we need to fix is the title of the edit blog post page. You may have noticed
    that even when editing, the title said **Create New Blog Post**. In order to fix
    this, replace the `h1` tag inside `blog/templates/blog_post.html` with the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The context passed to the template by the `UpdateView` includes a variable called
    `object`. This is the instance that the user is currently editing. We check for
    the existence of this variable in the template. If we find it, we know that we're
    editing an existing blog post. If not, we know it's a new blog post being created.
    We detect this and set the title accordingly.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Viewing blog posts
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add a view to show blog posts, add the following view class to `blog/views.py`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Remember to import `DetailView` generic view from `django.views.generic`. Next,
    create the `blog/templates/blog_post_details.html` template with the following
    code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Import the details view and add the following URL pattern to the `urls.py`
    file:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, change the list of blog posts in the home page template to link to
    the post details page from the post title:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: On the home page, the blog post titles should now link to the details page.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Multiple users
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we've only been playing with a single user account and making our
    site work for that one user. Let's get to the exciting part and add sharing posts
    to other users blogs. However, once multiple users get added to the mix, there
    is one thing we should look at before moving forward.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Security
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To demonstrate the complete lack of security in our application, let's create
    a new user account. Log out using the header link and register a new account.
    Next, log in with that user. You should end up on the home page and should not
    see any blog posts in the list.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Now, type in the URL `http://127.0.0.1:8000/blog/post/1/update/`. You should
    see the blog post we created from our first user in the edit view. Change either
    the title or the body of the blog post and click save. You are redirected back
    to the home page and it appears that the save has succeeded. Log in back to the
    first account and you'll see that the title of the blog post has been updated.
    This is a serious security breach and must be fixed, otherwise, any user can edit
    the blog posts for any other user without any restrictions.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'The simple way in which we are able to solve this problem again demonstrates
    the power and simplicity of the Django framework. Add the following method to
    the `UpdateBlogPostView` class:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: That's it! Try opening `http://127.0.0.1:8000/blog/post/1/update/` again. This
    time instead of allowing you to edit the blog post of another user, you see a
    404 page.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'What this small piece of code does can be understood after looking at how the
    `UpdateView` generic view works. The generic view calls a number of small methods,
    each of which does a specific job. Here''s a list of some of the methods that
    are defined by the `UpdateView` class:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '`get_object`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_queryset`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_context_object_name`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_context_data`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_slug_field`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The thing about having small methods like these is that in order to change the
    functionality of subclasses, we can override only one of these and fulfill our
    purpose, like we've done here. Read the Django documentation to figure out what
    these and many of the other methods used by the generic views do.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: For our case, the `get_queryset` method, as the name suggests, gets the queryset
    within which the object to edit is searched for. We get the default `queryset`
    from the super method (which just returns a `self.model.objects.all()`) and return
    a version further filtered to only include blog posts owned by the currently logged
    in user. You should be familiar with relationship filters. If these are new to
    you, read the Django tutorial to familiarize yourself with the basics of filtering
    model querysets.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: The reason you now see a 404 if you try to access someone else's blog post is
    that when the `CreateView` tries to get the object to edit, it receives a queryset
    that only includes blog posts owned by the currently logged in user. Since we're
    trying to edit someone else's blog post, it's not included in that queryset. Not
    finding the object to edit, the `CreateView` returns a 404.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Sharing blog post
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The blog post sharing feature allows users to select the blog of another user
    they would like to share their blog posts with. This would allow users to gain
    more readers by sharing their content on the blogs of more popular writers, and
    readers would get to read more relevant content in one place instead of needing
    to discover more blogs.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in making sharing possible is to add a field on the `BlogPost`
    model to indicate which blogs the post is shared with. Add this field to the `BlogPost`
    model in `blog/models.py`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We are simply adding a basic Django many to many relationship field. If you'd
    like to review your knowledge of the features a many to many field provides, I
    advice you take a look at the Django tutorial again, specifically, the part that
    deals with M2M relationships.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note about the new field is that we had to specify `related_name`
    explicitly. As you might know, whenever you associate a model with another using
    any relationship field (`ForeignKey`, `OneToMany`, `ManyToMany`) Django automatically
    adds an attribute to the other model that allows easy access to the linked model.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Before we added the `shared_to` field, the `BlogPost` model already had a `ForeignKey`
    pointed at the `Blog` model. If you looked at the attributes available on the
    `Blog` model (using the shell), you would have found a `blogpost_set` attribute,
    which was a manager object that allowed access to `BlogPost` models that referenced
    that `Blog`. If we try to add the `ManyToMany` field without a `related_name`,
    Django would complain because the new relationship would also try to add a reverse
    relationship, also called `blogpost_set`. Because of this we need to give the
    reverse relationship another name.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: After defining the M2M relationship, you can now access blog posts shared with
    a blog model by using the `shared_posts` attributes `all()` method on the `Blog`
    model. We'll see an example of that later.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'After defining the new field, run the following commands to migrate your DB
    to create the new relationship:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, let''s create the view that allows the user to select a blog to share
    their post with. **Add** this to `blog/views.py`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This view is a subclass of the template view. You should have a pretty good
    idea of how it works by now. The important bit to look at here is the code inside
    the `get_context_data` method. First, we get the blog post object using the `id`
    passed in the keyword arguments gathered from the parsed URL pattern. Next, we
    get a list of all blog objects this post has been shared with. We do this because
    we don't want to confuse the user by allowing sharing to a blog that the post
    is already shared with.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code uses the Python built-in `map` method on the queryset
    of the blogs the post is shared with. `map` is one of the most useful methods
    when working with any kind of lists (or list-like objects) in Python. It takes
    as it's first argument a function that takes a single argument and returns one
    argument, and a list as it's second argument. `map` then calls the given function
    on each element in the input list and gathers the results in a final list that
    is returned. Here, we use a `lambda` to extract the ID of the blog objects that
    this post is already shared with.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can get the list of blog objects that this post can be shared with.
    We use the `exclude` method to not include the blog objects the post is already
    shared with. We pass this to the template in the context. Next, let''s take a
    look at the template that you need to create in `blog/templates/share_blog_post.html`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'There''s nothing special in this template. Let''s move on to the two URLs and
    views that this refers to, since without those we can''t render this template.
    First, let''s look at `SharepostWithBlog`, which you need to create in `blog/views.py`.
    You will need to add this import line to the top of the file as well:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The code for the view is this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Import this into `blueblog/urls.py` and add it with the following URL pattern:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Unlike all our previous views, this view doesn't fit nicely into any of the
    generic views that Django provides. But Django has a base generic view that makes
    our life easier than creating a function that handles the request.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: The `View` generic view is used whenever you need something completely custom
    to handle a request. Like all generic views, it has a dispatch method that you
    can override to intercept a request before any further processing is done. Here,
    we make sure that the user is logged in before allowing them to proceed.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: In a `View` subclass, you create methods with the same name as the request types
    you want to handle. Here, we create a `get` method as we only care about handling
    `GET` requests. The `View` class takes care of calling our method when the correct
    request method is used by the client. In our get method, we're doing a basic check
    to see if the user owns the blog post. If they do, we add the blog to the `shared_to
    ManyToMany` relationship of the `BlogPost` model.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'The last view we need to create is one to allow the user to remove a blog post
    they have already shared. The code for that is shown here:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Like the `SharePostWithBlog` view, this one subclasses the `View` generic view.
    The code is almost exactly the same as the previous view. The only difference
    is that in the previous view we used `blog_post.shared_to.add`, whereas in this
    view we use the `blog_post.shared_to.remove` method.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, import these two views into `blueblog/urls.py` and add the following
    patterns:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In order to show a link to the share this post page, edit the `home.html` template
    to change the entire code inside the `content` block to this:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: And that's it. Now when you visit the home page, each blog post should have
    a **Share Post** link next to it. When you click it, you'll see a second page
    with links to share the blog post on other user blogs. Clicking the link should
    share your post and also show a corresponding remove link on the same page. Of
    course, in order to test this, you should create a second user account and add
    a blog using that account.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing we should do is modify the `get_context_data` method of the
    **HomeView** to also include shared posts in the blog post list:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Add this to the bottom of the `content` block inside the `blog/templates/home.html`
    template:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'And that''s it, our first application is complete! If you open the home page
    now, you should see a **Share Post** link next to each blog post. Clicking this
    should open up another page where you can select which blog to share this post
    with. To test it you should create another blog with the other account we created
    earlier when we were looking at the security of our application. Once you have
    another blog configured, your share blog post page should look similar to this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing blog post](img/00698_01_03.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
- en: Clicking the title of the other blog should share the post and take you back
    to the home page. If you click the **Share Post** link again on the same post,
    you should now see a heading saying **Stop sharing with**, and the name of the
    blog you shared this post with.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: If you log in to the other account now, you should see that the post is now
    shared there, and is listed under the **Shared Blog Posts** section.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ve seen how to start our application and set it up properly
    so that we can develop things rapidly. We''ve looked at using template inheritance
    to achieve code reuse and give our site common elements such as navigation bars.
    Here''s a list of topics we have covered so far:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Basic project layout and setup with sqlite3 database
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple Django form and model form usage
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django contrib apps
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `django.contrib.auth` to add user registration and authentication to an
    application
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template inheritance
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic views for editing and displaying database objects
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database migrations
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll use the lessons we've learned here throughout the rest of the chapters
    in this book.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
