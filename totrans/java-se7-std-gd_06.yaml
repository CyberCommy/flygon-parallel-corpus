- en: Chapter 6. Classes, Constructors, and Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the heart of object-oriented programming are classes and the objects created
    from classes. The initialization of the objects occurs in constructors while the
    modification of the state of an object is carried through methods. The packaging
    of these constructors and methods is the focus of data encapsulation. The fundamentals
    of classes, constructors, methods, and data encapsulation are addressed in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We start with an introduction to classes including a discussion of how objects
    are managed in memory. Common aspects of constructors and methods are then presented
    including the concept of a signature, the passing of arguments, and the uses of
    the `this` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The usage of constructors is discussed including default constructors, how they
    are overloaded, and the use of private constructors. The Java initialization sequence
    is covered including the use of initializer lists.
  prefs: []
  type: TYPE_NORMAL
- en: Methods and how they are used is explained including how to overload them and
    the creation of accessor and mutator methods. The chapter concludes with a discussion
    of static and instance methods.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **class** is the definition of a data structure plus actions that operate
    on them which typically corresponds to a real world object or concept. A class
    is defined once but is not used directly within an application. Instead, objects
    are created (instantiated) based on a class and are allocated memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout the chapter we will illustrate the use of constructors and methods
    using the `Employee` class. A part of this class is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This definition will be expanded to explain the concepts and techniques associated
    with classes and objects.
  prefs: []
  type: TYPE_NORMAL
- en: Object creation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Objects are created using the `new` keyword. The keyword is used in conjunction
    with a classname and results in memory being allocated from the heap for the object.
    The heap is a region of memory normally located "above" the stack as discussed
    in the *Stack and heap* section in [Chapter 2](ch02.html "Chapter 2. Java Data
    Types and Their Usage"), *Java Data Types and Their Usage*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a new object is instantiated using the `new` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: Memory is allocated for the new instance of the class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A constructor is then called to perform initialization of the object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A reference to the object is returned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, two instances of the `Employee` class are created
    and references are assigned to the reference variables, `employee1` and `employee2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Each instance of a class has its own set of instance variables that are independent
    of each other. This is shown in the following diagram. Notice that both instances
    of the class contain their own copies of the instance variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Object creation](img/7324_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When a new object is created, a constructor for that object is executed. The
    purpose of a constructor is to initialize an object. This process is covered in
    the *Constructors* section. The class' methods are shared among the instances
    of the class. That is, there is only one copy of the methods.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java memory management is dynamic and automatic. When the `new` keyword is used,
    it automatically allocates memory on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, an instance of the `Employee` class is created and
    assigned to the `employee1` variable. Next, the `employee2` variable is assigned
    the value of the `employee1` variable. The effect of this assignment is that both
    reference variables point to the same object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Memory management](img/7324_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A reference variable may de-reference an instance of an object by:'
  prefs: []
  type: TYPE_NORMAL
- en: Being re-assigned to another object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting it to null
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the garbage collector determines that there are no references to it, the
    object becomes eligible for removal from the heap by a garbage collection thread
    and its memory can be re-used for other objects. This garbage collection process
    is essentially beyond the control of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Data encapsulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data encapsulation is concerned with hiding irrelevant information from the
    programmer and exposing the relevant information. Hiding the implementation details
    allow changes without affecting other parts of the program. For example, if a
    programmer wants to display a rectangle on the screen there are several approaches
    that can be used. It may involve drawing the rectangle pixel by pixel or drawing
    a series of lines. Hiding the details of the operation is referred to as data
    encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: The primary purpose of data encapsulation is to reduce the level of software
    development complexity. By hiding the details of what is needed to perform an
    operation, the use of that operation is simpler. The method is not that complex
    to use, as the user does not have to worry about the details of its implementation.
    The user can focus on what it does, not on how it does it. This, in turn, allows
    developers to do more.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the implementation of the `Employee` class. Originally,
    the instance variables were both declared as private:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The access modifier type of the `name` variable has been changed to public and
    the access modifier for the `setAge` method has been made private. This means
    that any user of the class can access the `name` field but they can only read
    the `age` of the employee. Data encapsulation has been affected when we explicitly
    decide what should and should not be exposed to the users of a class.
  prefs: []
  type: TYPE_NORMAL
- en: The details of a class and its implementation should be hidden from the user.
    This allows modification of the implementation of the class' internals without
    changing the public aspects of the class. As a general rule, instance variables
    are made private and methods are made public. Exceptions to this rule are made
    based on the needs of the class.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to control access to constructors. This topic is covered
    in the *Constructors* section.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing instance variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A reference variable holds a reference, or pointer, to an object. A field or
    variable of the object is accessed by following the object reference variable
    name with a period and then the field or method name. The following code snippet
    illustrates possible references using the `Employee` class based upon the declaration
    of `Employee` found in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we did not use the `age` field as this was declared as private to
    the `Employee` class. The use of modifiers is covered in the *Access modifiers*
    section in [Chapter 1](ch01.html "Chapter 1. Getting Started with Java"), *Getting
    Started with Java*.
  prefs: []
  type: TYPE_NORMAL
- en: Signature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The signature of a constructor or method is used to uniquely identify a constructor
    or method. A signature consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: Method or constructor name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type of the parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Order of the parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All constructors or methods within the same class must have unique signatures.
    Note that the return type of the method is not part of a signature. The following
    table shows the signatures that overload the `Employee` class constructor. The
    third and fourth constructors differ in the order of the constructor''s parameters.
    A method or constructor is said to be overloaded if there is more than one method
    or constructor with the same name, and in the same class, but with different signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Number of Arguments | Argument Types |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Employee()` | 0 |   |'
  prefs: []
  type: TYPE_TB
- en: '| `Employee(String name)` | 1 | `String` |'
  prefs: []
  type: TYPE_TB
- en: '| `Employee(String name, int zip)` | 2 | `String`, `int` |'
  prefs: []
  type: TYPE_TB
- en: '| `Employee(int zip, String name)` | 2 | `int`, `String` |'
  prefs: []
  type: TYPE_TB
- en: '| `Employee(String name, int zip, int age)` | 3 | `String`, `int`, `int` |'
  prefs: []
  type: TYPE_TB
- en: Using the this keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are four uses of the `this` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: Performing constructor chaining
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing instance variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing the current object to a method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning the current object from a method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Constructor chaining is covered in the *Overloading constructors* section.
    Let''s examine the use of the `this` keyword to access instance variables. The
    `setAge` method could have been implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code would not have the intended consequences of modifying the `age` instance
    variable. The scope of the instance variables is the entire class. The scope of
    the parameters is only the method. The parameters will have "precedence" over
    the instance variables. The effect is that the age passed to the method was assigned
    to itself. The instance variable was not modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways of correcting this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the parameter name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `this` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We could change the name of the parameter. However, devising a different name
    to designate the same thing leads to strange or awkward names. For example, we
    could have used the following method instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `initialAge` parameter will be assigned as the initial value to the member
    variable `age`. However, any number of other potentially meaningful names could
    be used. There is no standard naming convention for naming parameters of this
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach is to declare the parameter as a constant using the `final`
    keyword, as shown in the following code snippet. When we take this approach, a
    syntax error is generated because we are trying to modify the parameter. As it
    is constant we cannot change it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax error message that is generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preferred approach is to use the `this` keyword to clearly specify which
    variable is the member variable and which is the parameter. This is illustrated
    in the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this assignment statement we referenced the member variable by prefixing
    it with the `this` keyword and a period. Consider the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `this` keyword references the `age` instance variable, on the left-hand
    side of the assignment statement. On the right-hand side, the `age` parameter,
    was used. Thus, the parameter is assigned to the instance variable. Using the
    `this` keyword avoids having to devise some non-standard and potentially confusing
    name for parameters being assigned to a member variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `this` keyword can also be used to pass or return a reference to the current
    object. In the following sequence, the `validateEmployee` method is assumed to
    be a member of the `Employee` class. If a condition is met, then the current employee,
    as identified by the `this` keyword, is added to a class maintaining department
    information as referenced by the `department` variable. A reference to the current
    object is passed to the `add` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `this` keyword can also be used to return a reference to the current object.
    In the next sequence, the current object is returned by the `getReference` method
    which is assumed to be a method of the `Employee` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Passing parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within any method there may exist two types of variables—parameters and local
    variables. Parameters contain values passed to the method when it is invoked.
    Local variables are part of the method and are used to assist the method in the
    completion of its task. The techniques discussed here apply to both constructors
    and methods though we will only use methods for the examples in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters are passed as part of a parameter list. This list uses a comma to
    delimit the declaration of the type and name of a parameter. For example, the
    method in the following code snippet is passed two parameters—an integer and a
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Either a primitive data type or an object is passed to a method. The following
    terms are used to identify the data being passed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Argument: This is the variable being passed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parameter: This is the element defined within the method''s signature'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, in the following code sequence `number` and `employee1` are the
    arguments while `num` and `employee` are the corresponding parameters to the `changeValues`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In Java, only primitive data types and object references are passed to a method
    or constructor. This is performed using a technique called **passing by value**
    . When a method is called, a copy of the argument is assigned to the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: When a primitive data type is passed, only a copy of the value is passed. This
    means if the copy in the called method is changed, the original data is not changed.
  prefs: []
  type: TYPE_NORMAL
- en: When a reference variable is passed, only a copy of the reference is passed.
    The object itself is not passed or copied. At this point we have two references
    to the same object—the argument reference variable and the parameter reference
    variable. We can modify the object using either reference variable.
  prefs: []
  type: TYPE_NORMAL
- en: We can also change what the parameter references. That is, we can modify the
    parameter to reference a different object. If we modify the parameter we are not
    modifying the argument. The parameter and the argument reference variables are
    distinct variables.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following program where we pass an integer and a reference to a
    `Employee` object, to the `changeValues` method. In the method we change the integer,
    a field of the `Employee` object, and the `employee` reference variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that when we changed the value of the `num` parameter, the `main` method's
    `number` variable did not change. Also, we changed the object's `age` field using
    the `changeValues` method's `employee` reference variable. However, when we modified
    what the `changeValues` method's `employee` reference variable pointed to by creating
    a new employee, we did not change the `main` method's `employee` reference variable.
    It still references the original object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates how this works. The stack and heap reflect
    the state of the application when the `changeValues` method is started and immediately
    before it returns. For simplicity, we have ignored the `args` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing parameters](img/7324_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Passing an object by value is an efficient parameter passing technique. It is
    efficient because we are are not copying the entire object. We only copy the reference
    to the object.
  prefs: []
  type: TYPE_NORMAL
- en: Variable number of arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is possible to pass a variable number of arguments to a method. However,
    there are some restrictions:'
  prefs: []
  type: TYPE_NORMAL
- en: The variable number of parameters must all be the same type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are treated as an array within the method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They must be the last parameter of the method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand these restrictions, consider the method, in the following code
    snippet, used to return the largest integer in a list of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It is not necessary to declare methods with a variable number of parameters
    as static. We do this here so that we can call it from the static `main` method.
    In the following code sequence we invoke the method twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `largest` method assigns the first parameter, the first element of the `numbers`
    array, to `currentLargest`. It makes the assumption that the largest number is
    the first parameter. If it is not, then it will eventually be replaced. This avoids
    having to assign the smallest possible value to the `currentLargest` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The largest and smallest integers are defined in the `Integer` class as `Integer.MAX_VALUE`
    and `Integer.MIN_VALUE` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We used a for-each statement to compare each element of the numbers array to
    the largest variable. If the number is larger, then we replace `largest` with
    that number. The for-each statement is detailed in the *The for-each statement*
    section of [Chapter 5](ch05.html "Chapter 5. Looping Constructs"), *Looping Constructs*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we call the method with no arguments, as attempted below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The program will execute but a `ArrayIndexOutOfBoundsException` exception will
    be generated. This occurs because we tried to access the first element of the
    array in the method which does not exist because the array is empty. If we had
    not referenced the first element in the method, this problem would not have occurred.
    That is, a method that uses a variable number of arguments can, in most circumstances,
    be called with no arguments.
  prefs: []
  type: TYPE_NORMAL
- en: We could have implemented a version of the `largest` method that handles the
    situation where no arguments are passed. However, when nothing is passed what
    should the return value be? Any value we returned would imply that that number
    is the largest when, in fact, there is not a largest number. The best we can probably
    do is to return an exception reflecting this problem. However, this is effectively
    what the current version does. The exception, `ArrayIndexOutOfBoundsException`,
    is perhaps not as meaningful as a custom exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use other parameters in a method possessing a variable number of arguments.
    In the following example we pass a string, and zero or more floats, to a `displayAspects`
    method. The intent of the method is to display information about the element identified
    by the first argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is an example of how the method might be invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Variable arguments must be all of the same type and must be the last ones in
    the parameter list.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Immutable objects are objects whose state cannot be changed. By state, we mean
    the value of its member variables. These types of objects can simplify an application
    and are less error prone. There are several classes in the JDK core that are immutable
    including the `String` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an immutable object:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the class final which means that it cannot be extended (covered in the
    *Using the final keyword with classes* section in [Chapter 7](ch07.html "Chapter 7. Inheritance
    and Polymorphism"), *Inheritance and Polymorphism*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep the fields of the class private and ideally final
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: d. not provide any methods that modify the state of the object, that is do not
    provide setter or similar methods
  prefs: []
  type: TYPE_NORMAL
- en: d. not allow mutable field objects to be changed
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of the declaration of an immutable class representing
    a header for a page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `getDate` method created a new `Date` object based on the header's
    `date` field. Any `Date` object is mutable, so by returning a copy of the date
    as opposed to a reference to the current date, the user is unable to access and
    otherwise modify the private field. The same approach was used in the three-argument
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Constructors are used to initialize the member variables of a class. When an
    object is created, memory is allocated for the object and the constructor for
    the class is executed. This typically occurs using the `new` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Initialization of an object's instance variables is important. One of the developer's
    responsibilities is making sure that the state of an object is always valid. To
    assist in this process, constructors are executed whenever an object is created.
  prefs: []
  type: TYPE_NORMAL
- en: An alternate approach, which is not used by Java, is to use an initialization
    method that the programmer should call after an object is created. However, the
    use of such an initialization method is not a foolproof technique. The programmer
    may not be aware that the method exists, or may forget to call the method. To
    avoid these types of problems, a constructor is automatically invoked when an
    object is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The important characteristics of constructors include:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructors have the same name as the class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructor overloading is permitted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructors are not methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructors do not have a return type, not even void
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code snippet illustrates how constructors are defined. In this
    example, three overloaded constructors are defined. For the moment, we have left
    out their bodies. The intent of these constructors is to initialize the three
    instance variables that make up the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Default constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A default constructor is normally present for a class. If a class does not
    have any constructors explicitly declared, it automatically has a default constructor.
    A default constructor is a constructor that has no arguments. This is illustrated
    in the following code snippet, for the `Employee` class where no constructors
    are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The default constructor will essentially initialize its instance variables
    to 0 as explained in the *Initializing identifiers* section in [Chapter 2](ch02.html
    "Chapter 2. Java Data Types and Their Usage"), *Java Data Types and Their Usage*.
    The values assigned to member variables are found in the following table which
    is duplicated from [Chapter 2](ch02.html "Chapter 2. Java Data Types and Their
    Usage"), *Java Data Types and Their Usage*, for your convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Data Type | Default Value (for fields) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| boolean | false |'
  prefs: []
  type: TYPE_TB
- en: '| byte | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| char | ''\u0000'' |'
  prefs: []
  type: TYPE_TB
- en: '| short | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| int | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| long | 0L |'
  prefs: []
  type: TYPE_TB
- en: '| float | 0.0f |'
  prefs: []
  type: TYPE_TB
- en: '| double | 0.0d |'
  prefs: []
  type: TYPE_TB
- en: '| String (or any object) | null |'
  prefs: []
  type: TYPE_TB
- en: 'However, we can also add an explicit default constructor, as shown in the following
    code snippet. The default constructor is a constructor that has no arguments.
    As we can see, we are free to initialize the fields of the class to whatever values
    we choose. For those fields that we do not initialize, the JVM will initialize
    them to zeroes as detailed above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of the `this` keyword. In this context it is used to unambiguously
    specify that the variables following the period are class member variables, and
    not some other local variables. Here, there are no other variables that might
    cause confusion. The `this` keyword was detailed in the *Using the this keyword*
    section. It is a common practice to use the `this` keyword with member variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the programmer adds a constructor to the class, then the class will no longer
    have a default constructor added automatically. The programmer must explicitly
    add a default constructor for the class to have one. In the following declaration
    of the `Employee` class, the default constructor has been left out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to create an object using the default constructor, as shown in the
    following code snippet, then we will get a syntax error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The error message that is generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a general rule, always add a default constructor to a class. This is particularly
    important when the class is a base class.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading the constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Constructors can be overloaded. By overloading the constructors, we provide
    the users of the class with more flexibility in how an object can be created.
    This can simplify the development process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overloaded constructors have the same name but different signatures. The definition
    of a signature was provided in the *Signature* section, discussed earlier. In
    the following version of the `Employee` class we provide four constructors. Notice
    how each constructor assigns default values for those member variables not passed
    with the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This example duplicates work between the constructors. An alternate approach,
    shown as follows, uses the `this` keyword to reduce this duplication of effort
    and simplify the overall process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `this` keyword is used at the beginning of a constructor with
    an argument list. The effect is to call the same class' constructor that matches
    the signature used. In this example, each of the first three constructors calls
    the last constructor. This is called **constructor chaining** . All of the work
    is performed in the last constructor reducing the amount of repeated work being
    performed and chances for errors, especially when new fields are added.
  prefs: []
  type: TYPE_NORMAL
- en: This can be even more productive if the field variables are checked within a
    constructor prior to their assignment. For example, if we need to verify that
    the name meets a specific set of naming criteria, it only needs to be performed
    in one location instead of each constructor that is passed a name.
  prefs: []
  type: TYPE_NORMAL
- en: Private constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A constructor can be declared as private which serves to hide it from the user.
    This may be done to:'
  prefs: []
  type: TYPE_NORMAL
- en: Restrict access to some, but not all, of the class' constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hide all of the constructors from a user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some situations, we may desire to make constructors private or protected
    (See [Chapter 7](ch07.html "Chapter 7. Inheritance and Polymorphism"), *Inheritance
    and Polymorphism*, for a discussion of the `protected` keyword) to limit access
    to certain initialization sequences. For example, a private constructor may be
    used to initialize fields of a class in a less rigorous manner. As we are invoking
    the constructor from other constructors, we may be more confident of the values
    being assigned and do not feel that extensive checking of its parameters is needed.
  prefs: []
  type: TYPE_NORMAL
- en: It is not uncommon to find classes where all of the constructors are declared
    as private. This restricts the creation of objects by a user to the public methods
    of the class. The `java.util.Calendar` class is an example of such a class. The
    only way to obtain an instance of this class is to use its static `getInstance`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The use of private constructors is used to control the number of instances of
    the class that can be created by an application. The singleton design pattern
    dictates that only one instance of a class is ever created. This design pattern
    can be supported by making all of its constructors private and providing a public
    `getInstance` method that creates a single instance of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following illustrates this approach for the `Employee` class. The constructor
    is made private and the `getInstance` method insures that only a single object
    is ever created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first time the `getInstance` method is called the `instance` variable is
    null, which results in a new `Employee` object being created. In subsequent calls
    to the `getInstance` method, `instance` will not be null and a new `Employee`
    object is not created. The current reference to the single object is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a "constructor" has a return type, it is actually a method that happens
    to have the same name as the class. This is true even if the return type is `void`,
    as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a new instance of the `Employee` class and then apply the `Employee`
    method against this object, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: While this is legal, it is not good style and can be confusing. In addition,
    as we saw in the *Java naming conventions* section in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Java"), *Getting Started with Java*, the naming conventions for methods
    suggest that the initial word of a method's name should begin with a lowercase
    letter.
  prefs: []
  type: TYPE_NORMAL
- en: Java initialization sequence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Constructors are concerned with the initialization of the fields of an object.
    However, there are two other approaches that can be used to complement the use
    of constructors. The first is to use instance variable initializers. Using the
    `Employee` class we can initialize the age to 21, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If we initialize an instance variable in this manner, we do not have to initialize
    it in a constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second approach is to use an initialization block. This type of block is
    executed before the constructor is executed. The following code snippet illustrates
    this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Initialization blocks are useful when more complex initialization sequences
    are needed which cannot be supported with the simpler instance variable initializers.
    This initialization can also be performed in a constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, there are several ways of initializing member variables. If we use one
    or more of these techniques to initialize the same variable, then we may wonder
    in what order they are performed. The actual initialization sequence is a bit
    more complex than described here. However, the general order is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The zeroing of fields performed when the object is instantiated
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The initialization of final and static variables
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The assignment of instance variables initializers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The execution of initialization blocks
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code within a constructor
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: More detail about the initialization sequence can be found in the Java Language
    Specification ([http://docs.oracle.com/javase/specs/](http://docs.oracle.com/javase/specs/)).
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **method** is a group of statements used to complete a specific task. A method
    has a return value, a name, a set of parameters, and a body. Parameters are passed
    to a method and are used to perform an action. If a value is to be returned from
    a method, the return statement is used. A method may have zero or more return
    statements. A method that returns void may use a return statement but the statement
    does not have an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Defining methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Methods are defined as part of the class definition and normally follow the
    declaration of the instance variables. The method declaration specifies a return
    type. The return type `void` means that the method does not return a value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Java naming convention for methods specifies that the first word is not
    capitalized but subsequent words are capitalized. Method names should be verbs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the method returns `boolean` and is passed two integer
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'All methods within the same program must have unique signatures. Signatures
    are discussed in the *Signature* section, discussed earlier. Note that the return
    type of the method is not part of a signature. As an example, consider the declarations
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The signatures for both of these methods are identical. The return type is
    not used. If we attempt to declare both methods in the `Employee` class we will
    get the following syntax error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Calling methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax used for invoking methods appears similar to using instance variables.
    Instance methods will always execute against an object. The normal syntax uses
    the name of the object followed by a period and then the name of the method and
    any parameters that are needed. In the following example, the `getAgeInMonths`
    method is invoked against the `employee` reference variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Static methods are invoked using either the class name or an object. Consider
    the following declarations for a static variable called `entityCode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the method calls in the following code snippet will invoke the same method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it is not good practice to use a reference variable to invoke a static
    method. Instead, always use the classname. Attempts to use an object will result
    in the following syntax warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Static methods are detailed in the *Instance and static class members* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'A parameter list may be empty if no parameters are passed to a method. In the
    following simplified method, the age of an employee is returned in months. No
    parameters are passed to the method and an integer is returned. The method is
    simplified as the actual value would need to consider the current date and the
    date of birth for the employee:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Overloading methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiple methods with the same name are permitted in Java. This provides a convenient
    technique for implementing methods that differ in argument types. Overloaded methods
    all have the same method name. The methods are differentiated in that each overloaded
    method must have a unique signature. Signatures are discussed in the earlier *Signature*
    section. Recall that the return type of the method is not part of a signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet illustrates the overloading of a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Care must be taken when calling an overloaded method, as the compiler may be
    unable to determine which method to use. Consider the following declarations of
    the `max` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code sequence illustrates situations that will give the compiler
    problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The second and fourth assignment statements will match the method call with
    the three long argument method. This is expected for the second one. For the fourth
    assignment, only one of the arguments is long but it uses the three long argument
    method anyway. The problem with these assignments is that the method returns `long`
    and not `int`. It is unable to assign a float value to a `int` variable without
    a loss of precision, as indicated by the following syntax error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The last assignment cannot find an acceptable overloaded method. The following
    syntax error message results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Closely related to overloading is the process of overriding a method. With overriding,
    the signatures of two methods are identical but they reside in different classes.
    This topic is covered in the *Overriding Methods* section in [Chapter 7](ch07.html
    "Chapter 7. Inheritance and Polymorphism"), *Inheritance and Polymorphism*.
  prefs: []
  type: TYPE_NORMAL
- en: Accessors/mutators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An accessor method is one that reads or accesses a variable of a class. A mutator
    method is one that modifies a variable of a class. These methods are usually public
    and the variables are normally declared as private. This is an important part
    of data encapsulation. Private data is hidden from the user but access is provided
    through methods.
  prefs: []
  type: TYPE_NORMAL
- en: There is a consistent naming convention that you should use with accessor and
    mutator methods. This convention uses the private member variable name as a base
    and prefixes the base with either a get or set prefix. The get method returns
    the value of the variable while the set method takes an argument that is assigned
    to the private variable. In both methods, the member variable name is capitalized.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach is illustrated for the private `age` field of the `Employee`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the return type of `getAge` is `int` and is also the parameter type
    of the `setAge` method. This is the standard format of accessors and mutators.
    Accessor methods are commonly referred to as getters and mutator methods are referred
    to as setters.
  prefs: []
  type: TYPE_NORMAL
- en: Private data is frequently encapsulated by making it private and providing public
    methods to access it. Fields that have private or non-existent setters are referred
    to as **read-only fields** . Fields that have private or non-existent getters
    are referred to as **write-only fields** , but are not as common. The chief reason
    for getters and setters is to restrict access and provide additional processing
    of the fields.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we might have a `getWidth` method that returns the width of a `Rectangle`
    class. However, the value returned may be dependent on the unit of measure being
    used. It may return a value depending on whether another unit of measurement field
    is set to inches, centimeters or pixels. In a security conscious environment,
    we might want to restrict what can be read or written dependent upon the user
    or perhaps the time of day.
  prefs: []
  type: TYPE_NORMAL
- en: Instance and static class members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of variables or methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An instance variable is declared as a part of the class and is associated with
    an object. A static variable is declared in the same way, except that it is preceded
    by the `static` keyword. When an object is created, it has its own set of instance
    variables. However, all objects share a single copy of static variables.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it makes sense to have a single variable that can be shared and accessed
    by all instances of a class. When used with a variable, it is called a **class
    variable** and is local to the class itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following `Employee` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Each `Employee` object will have its own copies of the `name`, `zip`, and `age`
    variables. All `Employee` objects may share the same `minimumAge` variable. The
    use of a single copy of a variable insures that all of the class can access and
    use the same value, and space is conserved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram illustrates the allocation of the two objects in the
    heap. Each object has its own set of instance variables. The single static variable
    is shown allocated above the heap in its own special area of memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Instance and static class members](img/7324_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There is only one copy of each method for a class regardless of whether the
    method is an instance method or a static method. A static method is declared the
    same way as an instance method, except that the `static` keyword precedes the
    declaration of the method. The static `setMinimumAge` method, in the following
    code snippet, illustrates the declaration of a static method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'All instance methods must execute against an object. It is not possible to
    execute against the name of a class as it is possible with a static method. Instance
    methods are designed to access or modify instance variables. As such, it needs
    to execute against an object that possesses instance variables. If we attempt
    to execute an instance method against a classname, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'It will result in the following syntax error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: A static method can execute against either an object or the class name. Static
    methods may not access instance variables or call instance methods. As a static
    method can execute against a classname this means that it can execute even though
    there may not be any objects in existence. If there are no objects, then there
    cannot be any instance variables. Thus, static methods cannot access instance
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: A static method may not call an instance method. If it were able to access an
    instance method, then it would indirectly be able to access an instance variable.
    As there may not be any objects in existence, the calling of instance methods
    by a static method is not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: An instance method may access a static variable or call a static method. Static
    variables are always present. Thus, there is no reason why an instance method
    should not be able to access static variables and methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the relationship between static/instance variables
    and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Variable |   | Method |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | Instance | Static | Instance | Static |'
  prefs: []
  type: TYPE_TB
- en: '| Instance method | ![Instance and static class members](img/7324EN_06_05.jpg)
    | ![Instance and static class members](img/7324EN_06_05.jpg) | ![Instance and
    static class members](img/7324EN_06_05.jpg) | ![Instance and static class members](img/7324EN_06_05.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Static method | ![Instance and static class members](img/7324EN_06_06.jpg)
    | ![Instance and static class members](img/7324EN_06_05.jpg) | ![Instance and
    static class members](img/7324EN_06_06.jpg) | ![Instance and static class members](img/7324EN_06_05.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we examined many of the important aspects of a class. This included
    how memory is managed when an instance of a class is created, the initialization
    process, and how methods can be invoked to use a class.
  prefs: []
  type: TYPE_NORMAL
- en: There are several issues relevant to both constructors and methods. These were
    discussed before the details of constructors and methods were detailed and included
    the use of the `this` keyword, passing parameters, and signatures. Constructors
    and various initialization techniques were illustrated including the order that
    these initializations take place. The declaration of methods was also discussed
    including how to overload methods.
  prefs: []
  type: TYPE_NORMAL
- en: We also examined the difference between instance and static, variables, and
    methods. Throughout the chapter we illustrated how memory is allocated.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about the basics of classes we are ready to address
    the topics of inheritance and polymorphism, as discussed in the next chapter.
    In that chapter we will expand upon how memory is allocated, the initialization
    sequence, and introduce new topics, such as overriding methods.
  prefs: []
  type: TYPE_NORMAL
- en: Certification objectives covered
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The certification objectives covered in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating methods with arguments and return values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the `static` keyword to methods and fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an overloaded method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differentiating between default and user-defined constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying access modifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying encapsulation principles to a class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining the effect upon object references and primitive values when they
    are passed into methods that change the values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the following declares a method that takes a float and an integer returns
    an array of integers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `public int[] someMethod(int i, float f) { return new` `int[5];}`
  prefs: []
  type: TYPE_NORMAL
- en: b. `public int[] someMethod(int i, float f) { return new int[];}`
  prefs: []
  type: TYPE_NORMAL
- en: c. `public int[] someMethod(int i, float f) { return new int[i];}`
  prefs: []
  type: TYPE_NORMAL
- en: d. `public int []someMethod(int i, float f) { return new int[5];}`
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if you try to compile and run the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: a. Syntax error – `main` is not declared correctly.
  prefs: []
  type: TYPE_NORMAL
- en: b. Syntax error – the variable parameters cannot be used as it is in the `println`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: c. Syntax error – `someMethod` needs to be declared as static.
  prefs: []
  type: TYPE_NORMAL
- en: d. The program will execute without errors.
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following statements about overloaded methods are true?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Static methods cannot be overloaded.
  prefs: []
  type: TYPE_NORMAL
- en: b. The return value is not considered when overloading a method.
  prefs: []
  type: TYPE_NORMAL
- en: c. Private methods cannot be overloaded.
  prefs: []
  type: TYPE_NORMAL
- en: d. An overloaded method cannot throw exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Given the following code, which of the following statements are true?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: a. A syntax error will occur because void cannot be used with a constructor.
  prefs: []
  type: TYPE_NORMAL
- en: b. A syntax error will occur because the first two constructors are not unique.
  prefs: []
  type: TYPE_NORMAL
- en: c. The class does not have a default constructor.
  prefs: []
  type: TYPE_NORMAL
- en: d. No syntax errors will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following keywords cannot be used when declaring a class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `public`
  prefs: []
  type: TYPE_NORMAL
- en: b. `private`
  prefs: []
  type: TYPE_NORMAL
- en: c. `protected`
  prefs: []
  type: TYPE_NORMAL
- en: d. `package`
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that the following classes are in the same package, which statements
    are true?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: a. `sc.method1()` will generate a syntax error.
  prefs: []
  type: TYPE_NORMAL
- en: b. `sc.method2()` will generate a syntax error.
  prefs: []
  type: TYPE_NORMAL
- en: c. `sc.method3()` will generate a syntax error.
  prefs: []
  type: TYPE_NORMAL
- en: d. `sc.method4()` will generate a syntax error.
  prefs: []
  type: TYPE_NORMAL
- en: e. No syntax errors will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: What is the output of the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: a. `5 5 string 2 string 1`
  prefs: []
  type: TYPE_NORMAL
- en: b. `6 6 string 2 string 2`
  prefs: []
  type: TYPE_NORMAL
- en: c. `5 5 string 2 string 2`
  prefs: []
  type: TYPE_NORMAL
- en: d. `6 5 string 2 string 1`
  prefs: []
  type: TYPE_NORMAL
