- en: Classes, Objects, and Data Structures
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at organizing, formatting, and commenting on classes.
    We will also look at writing clean C# objects and data structures that respect
    the Law of Demeter. In addition, we will look at immutable objects and data structures
    and the interfaces and classes that define immutable collections in the `System.Collections.Immutable`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following broad topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Organizing classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commenting for document generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cohesion and coupling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Law of Demeter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable objects and data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you progress through this chapter, you will learn the following skills:'
  prefs: []
  type: TYPE_NORMAL
- en: How to effectively organize your classes using namespaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your classes will become smaller and more meaningful as you learn to program
    them with only a single responsibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it comes to writing your own APIs, you will be able to provide good developer
    documentation by providing comments that aid document generation tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any programs you write will be easy to modify and extend due to their high cohesion
    and low coupling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, you will be able to apply the Law of Demeter and write and use immutable
    data structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's start by looking at how we can effectively organize our classes by
    using namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can access the code for this chapter on GitHub, at [https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH03](https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH03).
  prefs: []
  type: TYPE_NORMAL
- en: Organizing classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will notice that the hallmark of a clean project is that it will have well-organized
    classes. And folders will be used to group classes that belong together. Further,
    the classes in the folders will be enclosed within namespaces that match the assembly
    name and folder structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each interface, class, struct, and enum should have its own source file in
    the correct namespace. Source files should be logically grouped together in the
    appropriate folders and the namespaces for the source files should match the assembly
    name and folder structure. The following screenshot demonstrates a clean folder
    and file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1dc5cf04-4924-414d-88a9-62c6305c9757.png)'
  prefs: []
  type: TYPE_IMG
- en: It is a bad idea to have more than one interface, class, struct, or enum in
    an actual source file. The reason for this is that it can make locating items
    difficult, despite the fact that we have IntelliSense to assist us.
  prefs: []
  type: TYPE_NORMAL
- en: 'When thinking about your namespaces, it is a good idea to follow the Pascal
    casing sequence of company name, product name, technology name, and then plural
    names for components separated by spaces. See the following for an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The reason for starting with the company name is that it helps to avoid namespace
    classes. So, if Microsoft and FakeCompany both have a namespace called `System`,
    which `System` you desire to use can be differentiated by the company name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, any items of code that are able to be reused in multiple projects are
    best placed in separate assemblies that can be accessed by multiple projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When using tests in your code, such as when doing **Test-Driven Development**
    (**TDD**), it is always best to keep your test classes in separate assemblies.
    Test assemblies should always be given the name of the assembly they are testing
    with the namespace `Tests` appended to the end of the assembly name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You should never put tests for different assemblies in the same test assembly
    as each other. Always keep them separate.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the namespace and type should not use the same name as this can
    produce compiler conflicts. When pluralizing namespaces, you can forego pluralizing
    for company names, product names, and acronyms.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, here are the rules to keep in mind when organizing classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Follow the Pascal casing sequence of company name, product name, technology
    name, and plural names for components separated by spaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Place reusable items of code in separate assemblies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't use the same name for the namespace and type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't pluralize company and product names and acronyms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll move on to the responsibility of classes.
  prefs: []
  type: TYPE_NORMAL
- en: A class should have only one responsibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Responsibility is the work that has been assigned to the class. In the SOLID
    set of principles, the S stands for **Single Responsibility Principle** (**SRP**). When
    applied to a class, SRP states that the class must only work on a single aspect
    of the feature being implemented. The responsibility of that single aspect should
    be fully encapsulated within the class. Therefore, you should never apply more
    than one responsibility to a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example to understand why:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, for the `MultipleResponsibilities` class,
    we have our cryptography functionalities implemented with the `DecryptString`
    and the `EncryptString` methods. We also have file access implemented with the
    `ReadTextFromFile` and `SaveTextToFile` methods. This class breaks the SRP principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we need to break this class up into two classes, one for cryptography and
    the other for file access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we can now see from the preceding code, by moving the `EncryptString` and
    `DecryptString` methods to their own `Cryptography` class in the core security
    namespace, we have made it easy to reuse the code to encrypt and decrypt strings
    across different products and technology groups. The `Cryptography` class also
    complies with SRP.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we can see that the `SecurityAlgorithm` parameter of
    the `Cryptography` class is an enum and has been placed in its own source file.
    This helps to keep code clean, minimal, and well organized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the following `TextFile` class, we again abide by SRP and have a nice
    reusable class that is in the appropriate core filesystem namespace. The `TextFile`
    class is reusable across different products and technology groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We've looked at the organization and the responsibility of classes. Now let's
    take a look at commenting on classes for the benefit of other developers.
  prefs: []
  type: TYPE_NORMAL
- en: Commenting for documentation generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Documenting your source code is always a good idea, whether it is an internal
    project or external software that will be used by other developers. Internal projects
    suffer because of developer turnover and often poor, or little to no documentation
    available to help new developers get up to speed. Many third-party APIs fail to
    get off the ground or uptake is slower than expected, often with adopters abandoning
    the APIs through frustration because of the poor state of the developer documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is always a good idea to include copyright notices at the top of each source
    code file and to comment on your namespaces, interfaces, classes, enums, structs,
    methods, and properties. Your copyright comments should be first in the source
    file, above the `using` statements and take the form of a multiline comment that
    starts with `/*` and ends with `*/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code sample provides an example of a documented namespace and
    class with documented methods. You will see that the documentation comments for
    the namespace and contained members start with the documentation comment `///`
    and are directly above the item being commented on. When you type the three forward
    slashes, Visual Studio automatically generates the XML tags based on the line
    below.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the preceding code, the namespace only has a summary and so
    does the class, but both methods contain a summary, a couple of parameter comments,
    and a return comment.
  prefs: []
  type: TYPE_NORMAL
- en: The following table contains the different XML tags that you can use in your
    documentation comments.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tag** | **Section** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| `<c>` | `<c>` | Formats text as code |'
  prefs: []
  type: TYPE_TB
- en: '| `<code>` | `<code>` | Provides source code as output |'
  prefs: []
  type: TYPE_TB
- en: '| `<example>` | `<example>` | Provides an example |'
  prefs: []
  type: TYPE_TB
- en: '| `<exception>` | `<exception>` | Describes the exceptions that can be thrown
    by the method |'
  prefs: []
  type: TYPE_TB
- en: '| `<include>` | `<include>` | Includes XML from an external file |'
  prefs: []
  type: TYPE_TB
- en: '| `<list>` | `<list>` | Adds a list or table |'
  prefs: []
  type: TYPE_TB
- en: '| `<para>` | `<para>` | Adds structure to text |'
  prefs: []
  type: TYPE_TB
- en: '| `<param>` | `<param>` | Describes the parameter of a constructor or method
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<paramref>` | `<paramref>` | Tags a word to identify it is a parameter |'
  prefs: []
  type: TYPE_TB
- en: '| `<permission>` | `<permission>` | Describes the security accessibility of
    the member |'
  prefs: []
  type: TYPE_TB
- en: '| `<remarks>` | `<remarks>` | Provides additional information |'
  prefs: []
  type: TYPE_TB
- en: '| `<returns>` | `<returns>` | Describes the return type |'
  prefs: []
  type: TYPE_TB
- en: '| `<see>` | `<see>` | Adds a hyperlink |'
  prefs: []
  type: TYPE_TB
- en: '| `<seealso>` | `<seealso>` | Adds a *see also* entry |'
  prefs: []
  type: TYPE_TB
- en: '| `<summary>` | `<summary>` | Summarizes the type or member |'
  prefs: []
  type: TYPE_TB
- en: '| `<value>` | `<value>` | Describes the value |'
  prefs: []
  type: TYPE_TB
- en: '| `<typeparam>` |  | Describes the type parameter |'
  prefs: []
  type: TYPE_TB
- en: '| `<typeparamref>` |  | Tags a word to identify it as a type parameter |'
  prefs: []
  type: TYPE_TB
- en: From the preceding table, it is clear that you have plenty of scope for documenting
    your source code. So it is a good idea to make the best use of the available tags
    to document your code. The better the documentation, the quicker and easier it
    will be for other developers to get up to speed with using the code.
  prefs: []
  type: TYPE_NORMAL
- en: It is now time to look at cohesion and coupling.
  prefs: []
  type: TYPE_NORMAL
- en: Cohesion and coupling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a well-designed C# assembly, code will be correctly grouped together. This
    is known as **high cohesion**. **Low cohesion** is when you have code grouped
    together that does not belong together.
  prefs: []
  type: TYPE_NORMAL
- en: You want related classes to be as independent as possible. The more dependent
    one class is on another class, the higher the coupling. This is known as **tight
    coupling**. The more independent classes are of one another, the lower the cohesion.
    This is known as low cohesion.
  prefs: []
  type: TYPE_NORMAL
- en: So, in a well-defined class, you want high cohesion and low coupling. We'll
    now look at examples of tight coupling followed by low coupling.
  prefs: []
  type: TYPE_NORMAL
- en: An example of tight coupling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following code example, the `TightCouplingA` class breaks encapsulation
    and makes the `_name` variable directly accessible. The `_name` variable should
    be private and modified only by the properties of methods within its enclosing
    class. The `Name` property provides `get` and `set` methods to validate the `_name`
    variable, but this is pretty pointless as those checks can be bypassed and the
    properties not called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, in the following code, the `TightCouplingB` class creates
    an instance of `TightCouplingA`. It then introduces tight coupling between the
    two classes by directly accessing the `_name` member variable and setting it to
    `null`, and then directly accessing to print its value to the debug output window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now let's look at the same simple example using a low coupling.
  prefs: []
  type: TYPE_NORMAL
- en: An example of low coupling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we have two classes, `LooseCouplingA` and `LooseCouplingB`.
    `LooseCouplingA` declares a private instance variable named `_name`, and this
    variable is set via a public property.
  prefs: []
  type: TYPE_NORMAL
- en: '`LooseCouplingB` creates an instance of `LooseCouplingA` and gets and sets
    the value of `Name`. Because the `_name` data member cannot be set directly, the
    checks on setting and getting the value of that data member are performed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And so we have an example of loose coupling. Let''s have a look at the two
    classes called `LooseCouplingA` and `LooseCouplingB` that show this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `LooseCouplingA` class, we declare the `_name` field as private and
    so prevent the data from being directly modified. The `_name` data is made indirectly
    accessible by the `Name` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `LooseCouplingB` class is unable to directly access the `_name` variable
    of the `LooseCouplingB` class, and so modifies the data member via a property.
  prefs: []
  type: TYPE_NORMAL
- en: Well, we've looked at coupling and now know how to avoid tightly coupled code
    and implement loosely coupled code. So now, it is time for us to look at some
    examples of low cohesion and high cohesion.
  prefs: []
  type: TYPE_NORMAL
- en: An example of low cohesion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a class has more than one responsibility, it is said to be a low cohesive
    class. Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the preceding class has at least three responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to and disconnecting from a data source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting data and transforming it ready for report insertion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a report and printing it out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will see clearly how this breaks the SRP. Next, we will break this class
    down into three classes that adhere to the SRP.
  prefs: []
  type: TYPE_NORMAL
- en: An example of high cohesion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we are going to break down the `LowCohesion` class into three
    classes that obey the SRP. These will be called `Connection`, `DataProcessor`,
    and `ReportGenerator`. Let's see how much cleaner the code is after we implement
    the three classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following class, you can see that the only methods in that class are
    related to connecting to a data source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The class itself is named `Connection`, so this is an example of a high cohesive
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, the `DataProcessor` class contains two methods that
    process data by extracting data from the data source and transforming that data
    for insertion into the report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So this is another example of a highly cohesive class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, the `ReportGenerator` class only has methods associated
    with generating and outputting the report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Again, this is another example of a highly cohesive class.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at each of the three classes, we can see that they contain only methods
    that pertain to their single responsibility. And so each of the three preceding
    classes is highly cohesive.
  prefs: []
  type: TYPE_NORMAL
- en: It is now time to look at how we design our code for change by using interfaces
    in place of classes so that code can be injected into constructors and methods
    using dependency injection and inversion of control.
  prefs: []
  type: TYPE_NORMAL
- en: Design for change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When designing for change, you should change the *what* to the *how*.
  prefs: []
  type: TYPE_NORMAL
- en: The *what* is the requirement of the business. As any seasoned person involved
    in a role within software development will tell you that requirements frequently
    change. As such, the software has to be adaptable to meet those changes. The business
    is not interested in *how* the requirements are implemented by the software and
    infrastructure teams, only that the requirements are met precisely on time and
    on budget.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the software and infrastructure teams are more focused on
    *how* those business requirements are to be met. Regardless of the technology
    and processes that are adopted for the project to implement the requirements,
    the software and target environment must be adaptable to changing requirements.
  prefs: []
  type: TYPE_NORMAL
- en: But that is not all. You see, software versions often change with bug fixes
    and new features. As new features are implemented and refactoring takes place,
    the software code becomes deprecated and eventually obsolete. On top of that,
    software vendors have a road map of their software that forms part of their application
    life cycle management. Eventually, software versions get to the point where they
    are retired and no longer supported by the vendor. This can force a major migration
    from the current version, which will no longer be supported, to the new supported
    version, and this can bring with it breaking changes that must be addressed.
  prefs: []
  type: TYPE_NORMAL
- en: Interface-oriented programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Interface-Oriented Programming** (**IOP**) helps us to program polymorphic
    code. Polymorphism in OOP is defined as different classes having their own implementations
    of the same interface. And so, by using interfaces, we can morph our software
    to meet the needs of the business.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a database connection example. An application may be required
    to connect to different data sources. But how can the database code remain the
    same no matter what database is employed? Well, the answer lies in the use of
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: You have different database connection classes that implement the same database
    connection interface, but they each have their own versions of the implemented
    methods. This is known as polymorphism. The database then accepts a database connection
    parameter that is of the database connection interface type. You can then pass
    into the database any database connection type that implements the database connection
    interface. Let's code this example so that it makes things a little more clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a simple .NET Framework console application. Then update
    the `Program` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, the `Main()` method creates a new instance of the `Program` class
    and then calls the `InterfaceOrientedProgrammingExample()` method. In that method,
    we instantiate two different database connections, one for MongoDB and one for
    SQL Server. We then instantiate the database with a MongoDB connection, open the
    database connection, and then close it. Then we instantiate a new database using
    the same variable and pass in a SQL Server connection, then open the connection
    and close the connection. As you can see, we only have one `Database` class with
    a single constructor, yet the `Database` class will work with any database connection
    that implements the required interface. So, let''s add the `IConnection` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface has only two methods called `Open()` and `Close()`. Add the MongoDB
    class that will implement this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the class implements the `IConnection` interface. Each method
    prints out a message to the console. Now add that `SQLServerConnection` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The same goes for the `Database` class. It implements the `IConnection` interface,
    and for each method invocation, a message is printed to the console. And now for
    the `Database` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Database` class accepts an `IConnection` parameter. This sets the `_connection`
    member variable. The `OpenConnection()` method opens the database connection,
    and the `CloseConnection()` method closes the database connection. Well, it''s
    time to run the program. You should see the following output in the console window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So now, you can see the advantage of programming to interfaces. You can see
    how they enable us to extend the program without having to modify the existing
    code. That means that if we need to support more databases, then all we have to
    do is write more connection objects that implement the `IConnection` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how interfaces work, we can look at how to apply them to dependency
    injection and inversion of control. Dependency injection helps us to write clean
    code that is loosely coupled and easy to test, and inversion of control enables
    the interchanging of software implementations as required, as long as those implementations
    implement the same interface.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection and inversion of control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C#, we have the ability to address changing software needs using **Dependency
    Injection** (**DI**) and **Inversion of Control** (**IoC**). These two terms do
    have different meanings but are often used interchangeably to mean the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: With IoC, you program a framework that accomplishes tasks by calling modules.
    An IoC container is used to keep a register of modules. These modules are loaded
    when requested by the user or configuration requests them.
  prefs: []
  type: TYPE_NORMAL
- en: DI removes internal dependencies from classes. Dependent objects are then injected
    by an external caller. An IoC container uses DI to inject dependent objects into
    an object or method.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will find some useful resources that will help you to understand
    IoC and DI. You will then be able to use these techniques in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we can implement our own simple DI and IoC without any third-party
    frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: An example of DI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we are going to roll our own simple DI. We will have an `ILogger`
    interface that will have a single method with a string parameter. We will then
    produce a class called `TextFileLogger` that implements the `ILogger` interface
    and outputs a string to a text file. Finally, we will have a `Worker` class that
    will demonstrate constructor injection and method injection. Let's look at the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following interface has a single method that will be used for implementing
    classes to output a message according to the implementation of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TexFileLogger` class implements the `ILogger` interface and outputs the
    message to a text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Worker` class provides an example of constructor DI and method DI. Notice
    that the parameter is an interface. So, any class that implements that interface
    can be injected at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DependencyInject` method runs the example to show DI in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see with the code we've just looked at, we start by producing a new
    instance of the `TextFileLogger` class. This object is then injected into the
    constructor of the worker. We then call the `DoSomeWork` method and pass in the `TextFileLogger` instance.
    In this simple example, we have seen how to inject code into a class via its constructor
    and via methods.
  prefs: []
  type: TYPE_NORMAL
- en: What is good about this code is it removes the dependency between the worker
    and the `TextFileLogger` instance. This makes it easy for us to replace the `TextFileLogger` instance
    with any other type of logger that implements the `ILogger` interface. So we could
    have used, for example, an event viewer logger or even a database logger. Using
    DI is a good way to reduce coupling in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen DI at work, we should also look at IoC. And we'll do that
    now.
  prefs: []
  type: TYPE_NORMAL
- en: An example of IoC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we are going to register dependencies with an IoC container.
    We will then use DI to inject the necessary dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we have an IoC container. The container registers the
    dependencies to be injected in a dictionary, and reads values from the configuration
    metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a container, and we use the container to configure metadata,
    register types, and create instances of dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Next up, we will look at how to limit an object's knowledge to knowing only
    about its close relatives using the Law of Demeter. This will help us to write
    a clean C# code that avoids the use of navigation trains.
  prefs: []
  type: TYPE_NORMAL
- en: The Law of Demeter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Law of Demeter aims to remove navigation trains (dot counting), and it also
    aims to provide good encapsulation with loosely coupled code.
  prefs: []
  type: TYPE_NORMAL
- en: 'A method that understands a navigation train breaks the Law of Demeter. For
    example, have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Each unit of code should have a limited amount of knowledge. That knowledge
    should only be of relevant code that is closely related. With the Law of Demeter,
    you must tell and not ask. Using this law, you may only call methods of objects
    that are one or more of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Passed as arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created locally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Globals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Law of Demeter can be difficult, but there are advantages to
    telling rather than asking. One such benefit is the decoupling of your code.
  prefs: []
  type: TYPE_NORMAL
- en: It is good to see a bad example that breaks the Law of Demeter, along with one
    that obeys the Law of Demeter, so we will see this in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: A good and a bad example (chaining) of the Law of Demeter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the good example, we have the report instance variable. On the report variable
    object instance, the method to open the connection is called. This does not break
    the law.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is a `Connection` class with a method that opens a connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Database` class creates a new `Connection` object and opens a connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Report` class, a `Database` object is instantiated and then a connection
    to the database is opened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have seen good code that obeys the Law of Demeter. But the following
    is code that breaks this law.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Example` class, the Law of Demeter is broken because we introduce method
    chaining, as in `report.Database.Connection.Open()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this bad example, the `Database` getter is called on the report instance
    variable. This is acceptable. But then a call is made to the `Connection` getter
    that returns a different object. This breaks the Law of Demeter, as does the final
    call to open the connection.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable objects and data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Immutable types are normally thought of as just value types. With value types,
    it makes sense that when they are set, you don't want them to change. But you
    can also have immutable object types and immutable data structure types. Immutable
    types are a type whose internal state does not change once they have been initialized.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of immutable types does not astonish or surprise fellow programmers
    and so conforms to the **principle of least astonishment** (**POLA**). The POLA
    conformity of immutable types adheres to any contracts made between clients, and
    because it is predictable, programmers will find it easy to reason about its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Since immutable types are predictable and do not change, you are not going to
    be in for any nasty surprises. So you don't have to worry about any undesirable
    effects due to them being altered in some way. This makes immutable types ideal
    for sharing between threads as they are thread-safe and there is no need for defensive
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: When you create an immutable type and use object validation, you have a valid
    object for the lifetime of that object.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at an example of an immutable type in C#.
  prefs: []
  type: TYPE_NORMAL
- en: An example of an immutable type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now going to look at an immutable object. The `Person` object in the
    following code has three private member variables. The only time these can be
    set is during the creation time in the constructor. Once set, they are unable
    to be modified for the rest of the object''s lifetime. Each variable is only readable
    via read-only properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now we have seen how easy it is to write immutable objects and data structures,
    we will look at data and methods in objects.
  prefs: []
  type: TYPE_NORMAL
- en: Objects should hide data and expose methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The state of your object is stored in member variables. These member variables
    are data. Data should not be directly accessible. You should only provide access
    to data via exposed methods and properties.
  prefs: []
  type: TYPE_NORMAL
- en: Why should you hide your data and expose your methods?
  prefs: []
  type: TYPE_NORMAL
- en: Hiding data and exposing methods is known in the OOP world as encapsulation.
    Encapsulation hides the inner workings of a class from the outside world. This
    makes it easy to be able to change value types without breaking existing implementations
    that rely on the class. Data can be made read/writable, writable, or read-only
    providing more flexibility to you regarding data access and usage. You can also
    validate input and so prevent data from receiving invalid values. Encapsulating
    also makes testing your classes much easier, and you can make your classes more
    reusable and extendable.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: An example of encapsulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code example shows an encapsulated class. The `Car` object is
    mutable. It has properties that get and set the data values once they have been
    initialized by the constructor. The constructor and the set properties perform
    the validation of the parameter arguments. If the value is invalid, an invalid
    argument exception is thrown, otherwise the value is passed back and the data
    value is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The benefit of the preceding code is that if you need to change the validation
    for the code that gets or sets the data values, you can do so without breaking
    the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Data structures should expose data and have no methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structures differ from classes in that they use value equality in place of reference
    equality. Other than that, there is not much difference between a struct and a
    class.
  prefs: []
  type: TYPE_NORMAL
- en: There is a debate as to whether a data structure should make the variables public
    or hide them behind get and set properties. It is purely down to you which you
    choose, but personally I always think it best to hide data even in structs and
    only provide access via properties and methods. There is one caveat in terms of
    having clean data structures that are safe, and that is that once created, structs
    should not allow themselves to be mutated by methods and get properties. The reason
    for this is that changes to temporary data structures will be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at a simple data structure example.
  prefs: []
  type: TYPE_NORMAL
- en: An example of data structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code is a simple data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the data structure is not that much different from a class in
    that it has a constructor and properties.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we come to the end of the chapter and will now review what we've
    learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about organizing our namespaces in folders and packages,
    and how good organization can help to prevent namespace classes. We then moved
    on to classes and responsibility and looked at why classes should only have one
    responsibility. We also looked at cohesion and coupling and why it is important
    to have high cohesion and low coupling.
  prefs: []
  type: TYPE_NORMAL
- en: Good documentation requires public members to be correctly commented on in documentation
    tools, and we saw how to do this using XML comments. The importance of why you
    should design for change was also discussed with basic examples of DI and IoC.
  prefs: []
  type: TYPE_NORMAL
- en: The Law of Demeter showed you how to not to talk to strangers, but only immediate
    friends, and how to avoid chaining. And finally, we looked at objects and data
    structures and what they should hide and what they should make public.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will briefly cover functional programming in C# and
    how to write clean methods that are small. We will also learn to avoid having
    more than two parameters in our methods, as methods with many parameters can become
    unwieldy. Plus we will learn to avoid duplication which can be a troublesome source
    of bugs when fixed in one location, but still exist elsewhere in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we organize our classes in C#?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many responsibilities should a class have?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you comment on your code for document generators?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does cohesion mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does coupling mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should cohesion be high or low?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should coupling be tight or loose?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What mechanisms are available that help you design for change?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is DI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is IoC?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name one benefit of using immutable objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What should objects hide and show?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What should structures hide and show?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more detail in regard to understanding the different kinds of cohesion and
    coupling, check out [https://www.geeksforgeeks.org/software-engineering-coupling-and-cohesion/](https://www.geeksforgeeks.org/software-engineering-coupling-and-cohesion/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Many tutorials on IoC can be found at](https://www.tutorialsteacher.com/ioc/)
    [https://www.tutorialsteacher.com/ioc/](https://www.tutorialsteacher.com/ioc/)[. ](https://www.tutorialsteacher.com/ioc/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
