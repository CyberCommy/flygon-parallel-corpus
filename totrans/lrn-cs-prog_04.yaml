- en: '*Chapter 4:* Understanding the Various User-Defined Types'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章：*理解各种用户定义类型'
- en: In the previous chapter, we learned about control statements and exceptions
    in C#. In this chapter, we will explore the user-defined types in C#. We will
    learn how to create custom user types using classes, structures, and enumerations.
    We will explore what fields, properties, methods, indexers, and constructors are
    in a class. We will study the access modifiers in C# and learn how to use them
    to define the visibility of types and members. We will also learn about two important
    keywords in C#—`this` and `static`—and understand the `ref`, `in`, and `out` parameter
    modifiers for methods.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了C#中的控制语句和异常。在本章中，我们将探讨C#中的用户定义类型。我们将学习如何使用类、结构和枚举来创建自定义用户类型。我们将探讨类中的字段、属性、方法、索引器和构造函数。我们将研究C#中的访问修饰符，并学习如何使用它们来定义类型和成员的可见性。我们还将学习C#中的两个重要关键字“this”和“static”，并了解方法的“ref”、“in”和“out”参数修饰符。
- en: 'We will explore the following topics in detail:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细探讨以下主题：
- en: Classes and objects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和对象
- en: Structures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构
- en: Enumerations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: Namespaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: Good knowledge of these concepts is necessary to understand the **object-oriented
    programming** (**OOP**) concepts that we will cover in the next chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些概念的良好了解对于理解我们将在下一章中涵盖的**面向对象编程**（**OOP**）概念是必要的。
- en: Classes and objects
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和对象
- en: Before we go further, it is important that you understand these two key concepts.
    A class is a template or a blueprint that specifies the form of an object. It
    contains both data and code that operates on that data. An object is an instance
    of a class. Classes are defined using the `class` keyword and a type that is a
    class is a reference type. The default value for a variable of a reference type
    is `null`. You can assign it as a reference to an instance of the type. Instances—that
    is, objects—are created using the `new` operator.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，重要的是你理解这两个关键概念。类是指定对象形式的模板或蓝图。它包含操作该数据的数据和代码。对象是类的一个实例。类是使用`class`关键字和一个类的类型是引用类型来定义的。引用类型的变量的默认值是`null`。您可以将其分配为类型实例的引用。实例
    - 也就是对象 - 是使用`new`运算符创建的。
- en: Information box
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 信息框
- en: The terms *class* and *object* are often used interchangeably in different technical
    documentations. They are not the same and it is improper to use them as so. The
    class is the blueprint that specifies the memory layout of objects and defines
    functionalities that operate with that memory. Objects are the actual entities
    created and operated according to the blueprint.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*类*和*对象*在不同的技术文档中经常可以互换使用。它们并不相同，这样使用是不正确的。类是指定对象的内存布局并定义与该内存操作的功能的蓝图。对象是根据蓝图创建和操作的实际实体。
- en: 'Take a look at the following code snippet to understand how a class is defined.
    In this example, we are creating an `Employee` class with three fields to represent
    the ID, first name, and last name of an employee:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码片段，以了解如何定义类。在这个例子中，我们创建了一个`Employee`类，其中包含三个字段，用于表示员工的ID、名字和姓氏：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will use the `new` keyword to create an instance of the class. The `new`
    operator allocates memory for an object and returns a reference to it at runtime.
    This reference is then stored in the variable that specifies the object's name.
    The object is stored on the heap, and the reference to the object is stored in
    the stack storage location corresponding to the named variable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`new`关键字来创建类的实例。`new`运算符在运行时为对象分配内存并返回对其的引用。然后，将该引用存储在指定对象名称的变量中。对象存储在堆上，对象的引用存储在与命名变量对应的堆栈存储位置上。
- en: 'To create an object of the `Employee` class, we will use the following statement:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`Employee`类的对象，我们将使用以下语句：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To access the members of a class (fields, properties, methods) using an object,
    we use the dot (`.`) operator. Hence, to assign values to the fields of the object
    (`obj`), we will use the following statements:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象访问类的成员（字段、属性、方法），我们使用点（`.`）运算符。因此，要为对象的字段赋值（`obj`），我们将使用以下语句：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following diagram shows, conceptually, what is happening here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表概念上显示了这里发生的情况：
- en: '![Figure 4.1 – The conceptual memory layout for the preceding Employee object'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 - 先前雇员对象的概念内存布局'
- en: '](img/Figure_4.1._B12346.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.1._B12346.jpg)'
- en: Figure 4.1 – The conceptual memory layout for the preceding Employee object
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 - 先前雇员对象的概念内存布局
- en: The **obj** variable of the **Employee** type is allocated on the stack. However,
    the stack does not contain the actual **Employee** object but only a reference
    to it. The object is allocated on the heap and the address of the object is stored
    on the stack so that by using the **obj** variable we can access the object that
    is located on the heap.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**Employee**类型的**obj**变量被分配在堆栈上。但是，堆栈不包含实际的**Employee**对象，而只包含对它的引用。对象分配在堆上，并且对象的地址存储在堆栈上，因此通过**obj**变量我们可以访问位于堆上的对象。'
- en: 'Two different instances of a class are two different objects. A reference to
    an object can be assigned to multiple variables. In this case, modifications to
    the object through one variable will be visible through the other variable. This
    is shown in the following example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 类的两个不同实例是两个不同的对象。对象的引用可以分配给多个变量。在这种情况下，通过一个变量对对象的修改将通过另一个变量可见。这在以下示例中显示：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we have created a first instance of the `Employee` class and only assigned
    a value to `EmployeeId`. Then, we created a second instance and assigned values
    to the first and last name, skipping the identifier. These are two different objects,
    residing in different locations in memory.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了`Employee`类的第一个实例，并且只为`EmployeeId`赋了一个值。然后，我们创建了第二个实例，并为名字和姓氏赋值，跳过了标识符。这是两个不同的对象，驻留在内存中的不同位置。
- en: The properties of an employee are stored in the class in member fields. These
    will be discussed next.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 员工的属性存储在类的成员字段中。接下来将讨论这些。
- en: Fields
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段
- en: These are variables declared directly inside a class and are, therefore, members
    of the class. Fields are used for storing the state of the object, which is data
    that must live for more than the period of the execution of a class method and
    that should be accessible from multiple methods. Variables that are not used outside
    the scope of a single method should be defined as local variables and not class
    fields.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是直接在类内声明的变量，因此是类的成员。字段用于存储对象的状态，这是必须在类方法执行期间存活并且应该从多个方法中访问的数据。不在单个方法范围之外使用的变量应该被定义为局部变量而不是类字段。
- en: In the preceding section, `EmployeeId`, `FirstName`, and `LastName` are the
    mentioned fields. These are called **instance fields** because they belong to
    the instance of the class, meaning that each object has its own instance of these
    fields. On the other hand, *static fields* belong to the class and are shared
    by all instances of the class. Static members will be discussed in a later section
    of this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，`EmployeeId`、`FirstName`和`LastName`是提到的字段。这些被称为**实例字段**，因为它们属于类的实例，这意味着每个对象都有自己的这些字段的实例。另一方面，*静态字段*属于类，并且被所有类的实例共享。静态成员将在本章的后面部分讨论。
- en: These fields have been declared `public`, which means they can be accessed by
    anyone. This is, however, a bad practice. Fields should usually be declared as
    either `private` (to be accessible only to the class members) or `protected` (to
    also be accessible to the derived classes). This ensures better encapsulation,
    which will be discussed further in the next chapter. Fields can be accessed both
    for reading and writing using methods, properties, and indexers. We will discuss
    these in the following sections.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段已被声明为`public`，这意味着任何人都可以访问它们。然而，这是一个不好的做法。字段通常应该声明为`private`（只能被类成员访问）或者`protected`（也可以被派生类访问）。这确保了更好的封装，这将在下一章进一步讨论。字段可以通过方法、属性和索引器进行读取和写入。我们将在下面的部分讨论这些。
- en: 'Fields that are declared with the `const` specifiers are called **constants**.
    Only built-in types can be constants. Constants are always initialized with a
    literal and are values known at compile time that cannot be changed at runtime:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 用`const`修饰符声明的字段称为**常量**。只有内置类型可以是常量。常量始终使用字面值初始化，并且是在编译时已知的值，不能在运行时更改：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Constant fields are substituted for their literal value in the intermediate
    language code, which means you cannot pass a constant field by reference. But
    this has another, more subtle implication: if the constant value is referred in
    assemblies other than the one in which the type is defined and the literal value
    of the constant is changed in a future version, the assemblies referring the constant
    will continue to have the old version until they are recompiled.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 常量字段在中间语言代码中被其字面值替换，这意味着不能通过引用传递常量字段。但这还有另一个更微妙的含义：如果常量值在类型定义的程序集之外的程序集中被引用，并且常量的字面值在将来的版本中被更改，那么引用常量的程序集将继续具有旧版本，直到它们被重新编译。
- en: For instance, if an integer constant defined in assembly A was initially set
    to 42 and it was referred in assembly B, then the value 42 will have been stored
    in assembly B. Changing the value of the constant to something else (let's say
    100) will not be reflected in assembly B, which will continue to store the old
    value until it is recompiled with the new version of assembly A.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果在A程序集中定义了一个整数常量并且初始值为42，然后在B程序集中引用了它，那么值42将被存储在B程序集中。将常量的值更改为其他值（比如100）将不会反映在B程序集中，它将继续存储旧值，直到使用新版本的A程序集重新编译。
- en: Fields can also be declared with the `readonly` specifier. These fields can
    only be initialized in a constructor and their value cannot be changed later on.
    They can be thought of as **runtime constants**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 字段也可以用`readonly`修饰符声明。这些字段只能在构造函数中初始化，它们的值以后不能被改变。它们可以被看作是**运行时常量**。
- en: 'In the following example, the `EmployeeId` field is a `readonly` field that
    is initialized in the constructor. Only the first and last name fields can be
    changed for an instance of the class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，`EmployeeId`字段是一个在构造函数中初始化的`readonly`字段。类的实例只能改变姓和名字段：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we have seen how to work with fields, let's learn about methods.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到如何使用字段，让我们学习一下方法。
- en: Methods
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: Methods are a series of one or more statements that are executed when the method
    is invoked. Instance methods require an object in order to be called. Static methods
    belong to the class and are not called using an object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是在调用方法时执行的一个或多个语句的系列。实例方法需要对象才能被调用。静态方法属于类，不使用对象调用。
- en: 'A method has a so-called *signature* that consists of several parts:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 方法有一个所谓的*签名*，由几个部分组成：
- en: '`private` by default.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认为`private`。
- en: '`virtual`, `abstract`, `sealed`, or `static`: These are all optional and will
    be discussed in later sections.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virtual`、`abstract`、`sealed`或`static`：这些都是可选的，将在后面的部分讨论。'
- en: '`void` if the method does not return any value.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果方法不返回任何值，则为`void`。
- en: '**A name**: This must be a valid identifier.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名字**：这必须是一个有效的标识符。'
- en: '`ref`, `in`, or `out` specifier.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ref`、`in`或`out`修饰符。'
- en: 'In the following example, we will add a method to our `Employee` class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们将在`Employee`类中添加一个方法：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we have added a method called `GetEmployeeName()`. The access modifier
    is `public`, which allows this method to be called from any part of the code.
    The return type is `string` as the method is returning the name of the employee
    by concatenating the `FirstName` and `LastName` fields separated by a space.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个名为`GetEmployeeName()`的方法。访问修饰符是`public`，这允许从代码的任何部分调用这个方法。返回类型是`string`，因为该方法通过连接`FirstName`和`LastName`字段并用空格分隔返回员工的名字。
- en: Methods that simply consist of evaluating an expression, and perhaps returning
    the result of the evaluation, can be written using an alternative syntax called
    `member => expression;` form and are supported for all class members, not just
    methods, but also fields, properties, indexers, constructors, and finalizers.
    The type of the result value of the expression evaluation must match the return
    type of the method.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the implementation of the `GetEmployeeName()` method
    using an expression body definition:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Overloaded methods** are multiple methods that have the same name but a different
    signature. Such methods can exist. The return type of these methods is not a part
    of the signature in the context of method overloading. This means that you cannot
    have two methods with the same list of parameters but with different return values.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, `GetEmployeeName(bool)` is an overloaded method for
    the previous `GetEmployeeName()` method:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This method has the same name but a different list of parameters. It takes a
    Boolean value that indicates whether the last name should be put first, or else
    returns the name with the first name followed by the last name, just like the
    previous method did.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A constructor is a special method defined in a class that is called when we
    instantiate an object for the class. Constructors are used to initialize the members
    of the class upon the object's creation. A constructor cannot have a return type
    and has the same name as the class. Multiple constructors with different parameters
    may exist.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: A constructor without any parameters is called a *default constructor*. Such
    a constructor is provided by the compiler to all classes. The default constructor
    is created at compile time and initializes the member variables to their default
    value. The default value is 0 for numeric data types, `false` for `bool`, and
    `null` for reference types. If we define our own constructor, the compiler will
    no longer provide the default constructor.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: A constructor can have an access modifier. The default access modifier of a
    constructor is `private`. However, this modifier makes it impossible to instantiate
    the class from outside the class itself. In most cases, the access modifier of
    a constructor is defined as `public` since a constructor is generally called from
    outside of the class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: A private constructor is useful in certain situations. An example is when implementing
    the singleton pattern.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to understand all the concepts covered so far with the help of the
    following example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We have extended our `Employee` class and included a constructor in it. This
    constructor will accept three parameters to initialize the value of all three
    fields: `EmployeeId`, `FirstName`, and `LastName`. When creating an instance of
    the class, you must specify proper arguments for the class constructor:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Upon execution, this program will give the output shown in the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – A screenshot of the console showing the output of the preceding
    snippet'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.2._B12346.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – A screenshot of the console showing the output of the preceding
    snippet
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Objects can be initialized in a declarative manner using the so-called *object
    initializer*. You invoke a constructor and, apart from providing the necessary
    arguments to the constructor, you also provide a list of initialization statements
    for accessible members, such as fields, properties, or indexers, within curly
    braces.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering the `Employee` class without a user-defined constructor, having
    the default (parameterless) constructor provided by the compiler, we can write
    the following code to initialize an instance of the class:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So far in this chapter, we have used fields to store the state of an object.
    The C# language provides an alternative to fields: properties, which is the topic
    of the next section.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A property is a combination of a field and a method to access that field. They
    look like fields but are actually methods called **accessors**. Properties make
    it possible to read or write the class state in a simple manner and hide the implementation
    details, including verification code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是字段和访问该字段的方法的组合。它们看起来像字段，但实际上是称为**访问器**的方法。属性使得以简单的方式读取或写入类状态成为可能，并隐藏实现细节，包括验证代码。
- en: The two accessors that properties define are called `get` (which is used to
    return a value from the property) and `set` (which is used to assign a new value).
    Within the context of the `set` accessor, the `value` keyword defines the value
    being accessed (which is the value assigned from the user code).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 属性定义的两个访问器称为`get`（用于从属性返回值）和`set`（用于分配新值）。在`set`访问器的上下文中，`value`关键字定义正在访问的值（即从用户代码分配的值）。
- en: 'In the following example, the `Employee` class shown earlier in this chapter
    is rewritten so that the employee ID, first name, and last name are private fields
    made available to the class clients using properties:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，本章前面显示的`Employee`类被重写，以便员工ID、名和姓是私有字段，通过属性对类客户端可用：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Using the property''s `get` and `set` accessors is actually transparent. You
    do not invoke them explicitly, but use the properties just as though they were
    fields. The following example shows how the three properties of the `Employee`
    class are to be accessed for both writing and reading:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，使用属性的`get`和`set`访问器是透明的。您不会显式调用它们，而是像字段一样使用属性。以下示例显示了如何访问`Employee`类的三个属性进行读写：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The implementation of the properties shown in the preceding code is straightforward—it
    just returns or sets the value of a private field. However, accessors are just
    like any other method, so you can write any code, such as parameter verification,
    as in the following example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中显示的属性的实现是直接的——它只返回或设置私有字段的值。但是，访问器就像任何其他方法一样，因此您可以编写任何代码，例如参数验证，如下例所示：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'On the other hand, a property is not required to refer to a corresponding field.
    A property may return values that are not read from one field or that are calculated
    from evaluating different fields. The following example shows a property, `Name`,
    that concatenates the value of the `FirstName` and `LastName` properties:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，属性不需要引用相应的字段。属性可以返回不从一个字段中读取的值，或者可以从评估不同字段计算出的值。以下示例显示了一个`Name`属性，它连接了`FirstName`和`LastName`属性的值：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that in the case of this property, the `set` accessor is missing. Both
    the `get` and `set` accessors are optional. However, at least one must be implemented.
    On the other hand, a write-only property does not have much value and you might
    want to implement such functionalities as a regular method. Also, the `get` and
    `set` accessors may have different access modifiers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个属性的情况下，缺少`set`访问器。`get`和`set`访问器都是可选的。但是，至少必须实现一个。另一方面，只写属性没有太多价值，您可能希望将这些功能实现为常规方法。此外，`get`和`set`访问器可以具有不同的访问修饰符。
- en: Implementing properties in this manner is cumbersome because you need to explicitly
    define private fields that you do not use elsewhere other than in the properties.
    Moreover, each property has to explicitly implement the `get` and `set` accessors,
    basically repeating the same code over and over again. It is possible to achieve
    the same result with a shorter syntax using *auto-implemented properties*. These
    are properties for which the compiler will provide a private field and the implementation
    of the `get` and `set` accessors, as we did earlier.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式实现属性是很麻烦的，因为您需要明确定义除了属性之外其他地方不使用的私有字段。此外，每个属性都必须明确实现`get`和`set`访问器，基本上是一遍又一遍地重复相同的代码。可以使用*自动实现的属性*以更短的语法实现相同的结果。这些属性是编译器将提供私有字段和`get`和`set`访问器的实现，就像我们之前做的那样。
- en: 'The `Employee` class is re-written with auto-implemented properties, as in
    the following code. This very much resembles our first implementation where we
    were using public fields:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Employee`类使用自动实现的属性进行了重写，如下所示。这非常类似于我们第一次实现时使用公共字段的情况：'
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you do not want to set the values of these properties, you can declare only
    the `get` accessor `public`. In such cases, the `set` accessor would probably
    be `private` and you would provide values through the constructor. Such an example
    is shown here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想设置这些属性的值，可以只声明`get`访问器为`public`。在这种情况下，`set`访问器可能是`private`，并且您将通过构造函数提供值。这里显示了一个示例：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Properties can be implemented using expression body definitions. The `Name`
    property shown earlier can be implemented as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用表达式主体定义来实现属性。前面显示的`Name`属性可以实现如下：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is a read-only property that only has the `get` accessor. However, you
    can explicitly implement both the `get` and `set` accessors as expression body
    members. This is shown in the following listing:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个只有`get`访问器的只读属性。但是，您可以显式实现`get`和`set`访问器作为表达式主体成员。这在以下清单中显示：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Auto-implemented properties can also be initialized using the syntax shown
    in the following example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 自动实现的属性也可以使用以下示例中显示的语法进行初始化：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The value of the `EmployeeId` property is initialized with `1`. Unless otherwise
    explicitly set, all instances of the `Employee` class will have `EmployeeId` set
    to `1`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmployeeId`属性的值被初始化为`1`。除非另行明确设置，`Employee`类的所有实例都将`EmployeeId`设置为`1`。'
- en: 'If you are implementing a read-only property using an expression body definition,
    you do not need to specify the `get` accessor. The syntax, in this case, is as
    follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用表达式主体定义实现只读属性，则不需要指定`get`访问器。在这种情况下，语法如下：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This, however, looks very similar to the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这看起来与以下内容非常相似：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There is a big difference between these syntaxes:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语法之间存在很大的区别：
- en: In the former example, where `=>` is used, `EmployeeId` is a *read-only public
    property* with an *expression body definition*.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the latter example, where `=` is used, `EmployeeId` is a *public field* with
    an *initializer*.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a special form of property that can take parameters and allow access
    to class instances using the operator `[]`. These are called **indexers** and
    are discussed in the following section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Indexers
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An indexer allows an object to be indexed like an array. An indexer defines
    a `get` and `set` accessor, similar to a property. An indexer does not have an
    explicit name. It is created by using the `this` keyword. An indexer has one or
    more parameters, which can be of any type. As in the case of properties, the `get`
    and `set` accessors are usually simple and consist of a single statement that
    returns or sets a value.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the `ProjectRoles` class contains a mapping of the
    project IDs and roles that an employee has in each project. This mapping is private
    but access to it is available through an indexer:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The indexer is defined with the `public string this[int projectId]` syntax,
    which contains the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: An access modifier
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of the indexer, which is `string`
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `this` keyword and the list of parameters in square brackets `[]`
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `get` and `set` accessors are implemented in the same way as for a regular
    property. This `ProjectRoles` class can be used as follows within the `Employee`
    class:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can access the employee roles using the `Roles[i]` syntax, just as if `Roles`
    was an array. In this example, the parameter is not an index in the array but
    a project identifier, which is actually the key to the dictionary of projects
    and roles. The parameters can be of any type, not just numerical types:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output from executing this sample code is shown in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Console output from executing the preceding code snippet'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.3._B12346.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – Console output from executing the preceding code snippet
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Indexers, including read-only indexers, can be implemented with expression body
    definitions. However, there are no auto-implemented indexers; they have to be
    implemented explicitly.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, indexers are defined using the `this` keyword. However, this keyword
    has other meanings outside the scope of indexers. This topic will be discussed
    in the next section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The this keyword
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `this` keyword is used to represent the current instance of a class. When
    a method is called, the reference of the calling object is passed to it using
    `this`. This is not done explicitly, but behind the scenes by the compiler.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'The `this` keyword has two important purposes:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: To qualify class members when parameters or local variables with the same name
    exist
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To pass a reference to the current instance as a parameter to another method
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the following implementation of the `Employee` class:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, the parameters of the constructor have the same name as the
    fields of the class. C# allows us to use the same name for the parameter and instance
    variable. Since the parameter name is local to a method, the local name takes
    precedence over the instance variable. To alleviate this situation, we use the
    `this` keyword to refer to the instance variable for the current method invocation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have seen the `this` keyword used for referring to the current instance
    of a class and for declaring indexes. However, it is used for yet another purpose,
    and that is declaring extension methods. These will be discussed in [*Chapter
    8*](B12346_08_Final_JC_ePub.xhtml#_idTextAnchor154), *Advanced Topics*. For now,
    let''s look at another important keyword: `static`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: The static keyword
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `static` keyword can be used to declare classes or class members. These
    differ from what we have seen so far because you do not create instances of static
    classes or do not need objects to access static members. We will explore these
    in detail in the following subsections.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Static members
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态成员
- en: Fields, properties, methods, and constructors can be declared `static`. Indexers
    and finalizers cannot be declared `static`. A static member does not belong to
    the object (as in the case of an instance member) but rather to the type itself.
    Therefore, you cannot access a static member through an object but through the
    type name.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 字段、属性、方法和构造函数可以声明为`static`。索引器和终结器不能声明为`static`。静态成员不属于对象（如实例成员的情况），而是属于类型本身。因此，您不能通过对象访问静态成员，而是通过类型名称。
- en: 'In the following example, we have an implementation of the `Employee` class
    that has a static field called `id` and a static method called `Create()`. The
    static field is storing the value of the next employee ID, and the static method
    is used to create a new instance of the class because the constructor is `private`
    and therefore it can only be called from within the class:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们有一个`Employee`类的实现，其中有一个名为`id`的静态字段和一个名为`Create()`的静态方法。静态字段存储下一个员工ID的值，静态方法用于创建类的新实例，因为构造函数是`private`，因此只能从类内部调用：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can call the `Create()` method as follows to instantiate a new object of
    this class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按以下方式调用`Create()`方法来实例化这个类的新对象：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first object created like this will have `EmployeeID` set to `1`, the second
    one will have `EmployeeID` set to `2`, and so on. Notice that we used the `Employee.Create()`
    syntax to call the static method.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样创建的第一个对象将`EmployeeID`设置为`1`，第二个对象将`EmployeeID`设置为`2`，依此类推。请注意，我们使用了`Employee.Create()`语法来调用静态方法。
- en: Static classes
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态类
- en: A `static` class is also declared using the `static` keyword. A `static` class
    cannot be instantiated. Since we cannot create instances of a `static` class,
    we access the class members using the class name itself. All members of a static
    class must themselves be static. A static class is basically the same as a non-static
    class, with a `private` constructor and all members declared as `static`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`类也使用`static`关键字声明。`static`类不能被实例化。由于我们无法创建`static`类的实例，因此我们使用类名本身来访问类成员。静态类的所有成员本身必须是静态的。静态类基本上与非静态类相同，具有`private`构造函数和所有成员声明为`static`。'
- en: A `static` class is typically used to define methods that operate only on their
    parameters (if any) and do not rely on class fields. This is often the case with
    utility classes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类通常用于定义仅在其参数（如果有）上操作并且不依赖于类字段的方法。这通常是实用类的情况。
- en: 'The following example shows a static class called `MassConverters`, which contains
    static methods to convert between kilograms and pounds:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例显示了一个名为`MassConverters`的静态类，其中包含用于在千克和磅之间转换的静态方法：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Because static classes cannot be instantiated, the `this` keyword has no meaning
    within the context of such a class. An attempt to use it would result in a compiler
    error.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因为静态类不能被实例化，所以`this`关键字在这样的类的上下文中没有意义。尝试使用它将导致编译器错误。
- en: The static constructor
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态构造函数
- en: 'A class can have a static constructor, whether the class itself is static or
    not. A static constructor has no parameters or access modifiers and cannot be
    called by the user. A static constructor is called by the CLR automatically in
    the following instances:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以有静态构造函数，无论类本身是否是静态的。静态构造函数没有参数或访问修饰符，用户无法调用它。CLR在以下情况下自动调用静态构造函数：
- en: In a static class when the first static member of the class is accessed for
    the first time
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在静态类中，当第一次访问类的第一个静态成员时
- en: In a non-static class when the class is instantiated for the first time
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在非静态类中，当类首次实例化时
- en: Static constructors are useful for initializing static fields. For instance,
    a `static readonly` field can only be initialized during declaration or in the
    static constructor. This is useful especially when the values are taken from configuration
    files, for writing entries to a log file, or for writing wrappers for unmanaged
    code, when the static constructor can call the `LoadLibrary()` API.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 静态构造函数对于初始化静态字段非常有用。例如，`static readonly`字段只能在声明期间或在静态构造函数中初始化。当值来自配置文件时，用于将条目写入日志文件，或者用于编写非托管代码的包装器时，静态构造函数可以调用`LoadLibrary()`API，这是非常有用的。
- en: 'In the following example, the previous implementation of the `Employee` class
    is modified such that a static constructor is provided to initialize the value
    of the static `id` field. This constructor is reading the ID of the next employee
    from an application file or initializes it with `1` if the file is not found.
    Every time a new instance of the class is created, the value of the next employee
    ID is written to this file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，修改了`Employee`类的先前实现，提供了一个静态构造函数来初始化静态`id`字段的值。这个构造函数从应用程序文件中读取下一个员工的ID，如果找不到文件，则将其初始化为`1`。每次创建类的新实例时，下一个员工ID的值都将写入此文件：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you run the following code several times, the first time the IDs of the
    two employees will be `1` and `2`, then `3` and `4`, and so forth:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您多次运行以下代码，第一次两个员工的ID将是`1`和`2`，然后是`3`和`4`，依此类推：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: So far, we have seen how to create methods and constructors. In the next section,
    we will learn about the different ways you can pass parameters to them.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何创建方法和构造函数。在下一节中，我们将学习有关将参数传递给它们的不同方法。
- en: The ref, in, and out parameters
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用、输入和输出参数
- en: When we pass an argument to a method, it is passed by a value. This means a
    copy is made. If the type is a value type, then the value of the argument is copied
    into the method parameter. If the type is a reference type, then the reference
    is copied to the method parameter. When you change the parameter value, it changes
    the local copy. This means changes in arguments of value types are not propagated
    to the caller. As for arguments of reference types, you can change the referred
    object on the heap but you cannot change the reference itself. This behavior can
    be altered using the `ref`, `in`, and `out` keywords.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The ref keyword
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ref` keyword allows us to create a *call-by-reference mechanism* rather
    than a call-by-value mechanism. A `ref` keyword is specified when we declare and
    invoke the method. The use of the `ref` keyword alters the parameter so that it
    becomes an alias for an argument, which must be a variable. This means you cannot
    pass a property or an indexer (which is actually a method) as an argument for
    a `ref` parameter. A `ref` parameter must be initialized prior to the method call.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code sample:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this program, we have defined a `Swap` method to swap two integer values.
    We are using the `ref` keyword to declare the method parameters. We defined this
    method as `static` so that we can invoke it without an object reference. Inside
    the `Main` method, we have initialized two integer variables.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'While invoking the `Swap` method, we have also used the `ref` keyword with
    argument names. These `ref` parameters are passed as a reference and the actual
    value of the `num1` and `num2` variables will be swapped. The change is reflected
    in the variables in the `Main` method. The output of this program is shown in
    the following screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Console showing the values of num1 and num2 before and after
    swapping'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.4._B12346.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Console showing the values of num1 and num2 before and after swapping
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ref` keyword can be used to specify a reference return value. In this
    case, it must be present in the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: In the method signature, before the return type.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the return statement, between the `return` keyword and the returned value.
    Such a value is called a *ref return value*.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the declaration of a local variable that will receive the returned reference,
    before the variable's type. Such a variable is called a *ref local variable*.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before the call to the method with a `ref` return.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, the `Project` class has a member field of the `Employee`
    type. A reference to an `Employee` instance is set in the constructor. The `GetOwner()`
    method returns a reference to the member field:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This can be used as follows to retrieve and change the owner of a project.
    In the following code, notice the use of the `ref` keyword in the declaration
    of the local variable and the invocation of the `GetOwner()` method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output of this program is shown in the following screenshot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – A screenshot of the output from the previous snippet'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.5._B12346.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – A screenshot of the output from the previous snippet
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'When using `ref` to return a value, you must be aware of the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: It is not possible to return a reference to a local variable.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not possible to return a reference to `this`.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible to return references to class fields but also to properties without
    a `set` accessor.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible to return a reference to `ref`/`in`/`out` parameters.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning by reference breaks the encapsulation because the caller gets full
    access to the state, or parts of the state, of an object.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now look at the `in` keyword.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The in keyword
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `in` keyword is very similar to the `ref` keyword. It causes an argument
    to be passed by reference. However, the key difference is that an `in` argument
    cannot be modified by the called method. An `in` parameter is basically a `readonly
    ref` parameter. Should the called method try to modify the value, the compiler
    will issue an error. A variable that is passed as an `in` argument must be initialized
    before being passed as an argument in a method called.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sample shows a method that takes two `in` arguments. Any attempt
    to change their value results in a compiler error:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Specifying the `in` keyword when passing the arguments to the method is optional.
    In the preceding example, this is omitted.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The `in` specifier is mostly intended for passing references to value type objects
    on hot paths, that is, functions that are called repeatedly. When you pass a value
    type object to a function, a copy of the value is made on the stack. Typically,
    this does not pose any performance concerns but, when it is happening over and
    over again, performance issues arise. By using the `in` specifier, a read-only
    reference to the object is passed, thereby avoiding the copy.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of the `in` specifier is the communication of the clear design
    intent that a parameter is not supposed to be modified by a method.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The out keyword
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `out` keyword is similar to the `ref` keyword. The difference is that a
    variable passed as an `out` argument does not have to be initialized before the
    method called, but the method taking an `out` parameter must assign a value to
    it before returning. The `out` keyword must be present both in the method definition
    and in the invocation of the method, before the argument.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Returning an output value is useful in situations when a method needs to return
    more than one value, or when it needs to return a value but also information about
    whether the execution was successful or not. An example is `int.TryParse()`, which
    returns a Boolean indicating whether the parsing was successful and the actual
    parsed value as an `out` parameter.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how it works, let''s take a look at the following example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We have defined a `static` method to return the square of an integer. The `Square`
    method will accept two parameters. The `int` parameter will be an integer value
    and it will return the square of the input number via the `out` parameter output.
    It can be used as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Upon execution, the output of this program will be `100`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: A variable that is used as an `out` argument can be declared inline in the method
    invocation. This produces simpler and more compact code. The scope of the inline
    variable is the scope in which the method is being invoked.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code can be simplified as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There are some restrictions when using these parameter specifiers, which will
    be explained in the following section.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Understanding their limitations
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the `ref`, `in`, and `out` parameters, you must be aware of several
    limitations. These keywords cannot be used with the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Async methods, defined with the `async` modifier.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterator methods, which include either `yield return` or `yield break`.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, the `ref`, `in`, and `out` keywords are not considered a
    part of the method signature in the context of overload resolution. That means
    you cannot have two overloads of the same method: one that takes a `ref` argument
    and one that takes the same argument as an `out` parameter. However, it is possible
    to have overloaded methods if one has a value parameter, and the other has a `ref`,
    `in`, or `out` parameter:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: All the methods that we have seen so far in this book have a fixed number of
    arguments. The language, however, allows us to define methods that can take a
    variable number of arguments. This topic is discussed next.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Methods with a variable number of arguments
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have only seen methods that take zero or a fixed number of arguments.
    However, it is also possible to define methods that take any number of arguments
    of the same type. To do so, you must have an argument that is a single-dimensional
    array preceded by the `params` keyword. This parameter does not have to be the
    only parameter of the method, but no further parameters are allowed after it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we have two methods—`Any()` and `All()`—that take
    a variable number of Boolean values and return a Boolean value, indicating whether
    any of them is `true`, and respectively, whether all of them are `true`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Both of these methods can be invoked with zero, one, or any other number of
    arguments, as shown here:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The way the arguments are provided for a method call is flexible. We will look
    at existing possibilities next.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Named and optional arguments
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In all of the examples we have seen so far, the arguments for a method call
    were provided in the order of the parameter declaration in the method signature.
    These are called *positional arguments* because they are evaluated based on the
    position they are given. Moreover, all the parameters were mandatory, which means
    that an invocation cannot occur unless an argument is supplied for each parameter
    in the parameters list.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'However, C# supports two more types of arguments: *optional arguments* and
    *named arguments*. These are often used together and enable us to supply only
    some arguments for the parameters in a list of optional parameters. These can
    be used with methods, indexers, constructors, and delegates.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Optional arguments
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When declaring a method, constructor, indexer, or delegate, we can specify
    a default value for a parameter. When such a parameter exists, supplying an argument
    for it upon the member invocation is optional. If none is provided, the compiler
    will use the default one. A default value for a parameter must be one of the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: A constant expression
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An expression of the `new T()` form, where `T` is a value type
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An expression of the `default(T)` form, where `T` is also a value type
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method can have both required and optional parameters. If optional parameters
    are present, they must follow all the non-optional parameters. A non-optional
    parameter cannot follow an optional parameter.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following implementation of the `Point` structure:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The constructor takes two parameters, both of them having the default value
    `0`. This means they are both optional. We can invoke the constructor in any of
    the following forms:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the first example, no argument to the constructor of `Point` is supplied,
    so the compiler will use `0` for both `x` and `y`. In the second example, a single
    argument is supplied and that will be used to bind to the first constructor parameter.
    Therefore, `x` will be `1` and `y` will be `0`. In the third and last example,
    two arguments are supplied, and they are bound to `x` and `y` in this order. Therefore,
    `x` is 1 and `y` is `2`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Named arguments
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Named arguments enable us to invoke a method specifying the arguments by their
    name and not by their position in the parameters list. Arguments can be specified
    in any order and, in combination with default arguments, we can specify only some
    arguments for a method invocation. Named arguments are provided by specifying
    the parameter name followed by a colon (`:`) and the value.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following examples:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The first three constructor invocations are equivalent; `p1`, `p2`, and `p3`
    represent the same point. The invocation of the constructor uses one or more named
    arguments but the effect is the same. When constructing `p4`, on the other hand,
    only the value for `y` is specified. Therefore, `x` will be `0` and `y` will be
    `2`. Lastly, `p5` is created by specifying only a named argument for `x`. Therefore,
    `x` will be `1` and `y` will be `0`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Access modifiers
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An access modifier is used to define the visibility of a type or member in
    C#. It specifies what other parts of the code in the assembly or other assemblies
    can access the type or the type member. C# defines six types of access modifiers,
    as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '`public`: A public field can be accessed by any part of the code in the same
    assembly or in another assembly.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected`: A protected type or member can be accessed only in the current
    class and in a derived class.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`internal`: An internal type or member is accessible only within the current
    assembly.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected internal`: This is a combination of `protected` and `internal` access
    levels. A protected internal type or member is accessible in the current assembly
    or in a derived class.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private`: A private type or member can be accessed only inside the class or
    struct. This is the least-accessible level defined in C#.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private protected`: This is a combination of `private` and `protected` access
    levels. A private protected type or type member is accessible by code in the same
    class, or in a derived class, but only within the same assembly.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying to access a type or type member outside its access level will result
    in a compile-time error.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different kinds of rules for accessibility that apply to types and
    type members:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '`public` or `internal` (which is the default). Derived classes, on the other
    hand, cannot have greater accessibility than their base types. That means if you
    have an `internal` class `B`, you cannot derive from it a `public` class `D`.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public`, `internal`, or `private`. These rules apply to nested structs and
    classes. The default access level for class and struct members is `private`. A
    nested type that is `private` is accessible only from the enclosing type. The
    accessibility of a member cannot be greater than the type that contains it.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, the type of a field, property, or event must be at least as accessible
    as the field itself. Similarly, the return type of a method, indexer, or delegate,
    as well as the type of its parameters, cannot be less accessible than the member
    itself.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '`public` and `static`. Finalizers cannot have accessibility modifiers. Interfaces
    defined directly in a namespace can be `public` or `internal` (which is the default).
    Access modifiers cannot be applied to any interface members, which are implicitly
    `public`. In a similar manner, enumeration members are implicitly `public` and
    cannot have access specifiers. Delegates are like classes and structs – their
    default access is `internal` when defined directly in a namespace, and `private`
    when nesting in another type.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows various uses of access modifiers for types and type
    members:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We have learned in this chapter how to define custom classes. In all the examples
    so far, the entire class was defined in a single place. However, it is possible
    to split a class across several different definitions, in the same or different
    files, which is what we will look at in the next section.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Partial classes
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A partial class allows us to divide our class into multiple class definitions,
    which is useful when a class becomes very large or when we want to separate a
    class logically into multiple parts. This enables technologies such as WPF to
    work better because the user code and the code written by the IDE designers are
    separated into different source files.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Each part can be defined in a different source file using the `partial` keyword.
    This keyword must appear immediately before the `class` keyword. The parts must
    be available at compile time. During compilation, the parts are combined into
    a single type.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: The `partial` keyword can be applied not only to classes, but also structures,
    interfaces, and methods. The same rules apply to all of them.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the `partial` class is shown here:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here, we split the class definition into two `partial` classes. Both `partial`
    classes contain some properties. We can instantiate the `partial` class and use
    its properties similar to a normal class. Refer to the following code snippet:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following list contains properties of partial types, as well as rules for
    them:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: All the parts must have the same accessibility.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different parts may specify a different base interface. The final type will
    implement all the listed interfaces.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If multiple parts specify a base class then it must be the same base class,
    as multiple inheritances are not supported in C#. A base class can be specified
    only on one part. It is optional on the others.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes of all the parts are merged together at compile type. The final type
    will have all the attributes used on all the part declarations.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested classes can also be partial.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods can also be partial. This enables us to provide the signature in one
    part of a `partial` class or structure and the implementation in another. This
    is useful in IDEs to provide method hooks that developers may or may not implement.
    If a partial method does not have an implementation, it is removed from the class
    definition at compile time. Partial methods cannot have an access modifier and
    are implicitly private. Also, a partial method cannot return a value; the return
    type of a partial method must be `void`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Structures
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The content of this chapter so far has been focused on classes. Types that
    are defined as classes are reference types. However, in .NET and C#, there is
    another category of types: **value types**. Value types have value semantics,
    meaning that the value of the object, and not a reference to the object, is copied
    on assignment.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Value types are defined using the `struct` keyword instead of `class`. In most
    aspects, structures are identical to classes and the characteristics presented
    in this chapter for classes apply to structures too. However, there are several
    key differences:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Structures do not support inheritance. Although a structure can implement any
    number of interfaces, it cannot derive from another structure. For this reason,
    structure members cannot have the `protected` access modifier. Also, a structured
    method or property cannot be `abstract` or `virtual`.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A structure cannot declare a default (parameterless) constructor.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structures can be instantiated without using the `new` operator.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a structure declaration, fields cannot be initialized unless they are declared
    `const` or `static`.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s consider the following example where we define a structure called `Point`
    with two integer fields:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can instantiate this either using the `new` operator, which would call the
    default constructor initializing all the member fields with their default value,
    or directly, without the `new` operator. In this case, the member fields would
    remain uninitialized. This could be useful for performance reasons, but such an
    object cannot be used until all of its fields are properly initialized:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The preceding code uses the `new` operator to create an instance of the type.
    On the other hand, in the following example, the object is created without the
    `new` operator:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'While structures and classes have many things in common, they also differ in
    several key aspects. It is important to understand when you should use classes
    and when you should use structures. A structure should be used in the following
    cases:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: When it represents a single value (such as a point, a GUID, and so on)
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it is small (typically no larger than 16 bytes)
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it is immutable
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it is short-lived
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it is not used frequently in boxing and unboxing operations (which alter
    performance)
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all the other cases, types should be defined as classes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: A variable of a value type cannot be assigned a `null` value. However, for situations
    when no value is a valid value for a value type, a nullable value type (denoted
    as `T?` using shorthand syntax) can be used. Nullable types were discussed in
    [*Chapter 2*](B12346_02_Final_JC_ePub.xhtml#_idTextAnchor036), *Data Types and
    Operators*.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows an example of a nullable `Point` variable assigned with
    `null`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: It is often mentioned in the literature that instances of value types are stored
    on the stack. This statement is only partially true. The stack is an implementation
    detail; it is not part of the characteristics of value types. Local variables
    or temporaries of value types are indeed stored on the stack (unless they are
    not closed over outer variables of a lambda or an anonymous method) and not part
    of an iterator block.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, they are typically stored on the heap. However, this is entirely
    an implementation and compiler detail and, in fact, value types can be stored
    in many places: in the stack, in a CPU register, on the FPU frame, on the heap
    managed by the garbage collector, on the loader heap of the AppDomain, or in the
    thread-local storage (if the variable has the `ThreadStorage` attribute).'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: When a value type object (the storage location contains the value directly)
    is assigned to a reference type object (the storage location contains a reference
    to the actual value), the process of boxing occurs. The other way around the process
    is called unboxing. We have discussed these two previously in this book, in [*Chapter
    2*](B12346_02_Final_JC_ePub.xhtml#_idTextAnchor036), *Data Types and Operators*.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we have two variables of the `Point` value type and we want to check whether
    they are equal. To do so, we invoke the `Equals()` method that is defined in the
    `System.Object` base class. When we do this, boxing occurs because the parameter
    of `Equals` is an object, that is, a reference type. Boxing may become a performance
    issue if it is performed very often. There are two ways to avoid boxing for a
    value type.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: The first solution is to implement the `IEquatable<T>` interface that contains
    a single `Equals(T)` method. This method allows both value and reference types
    to implement a way that determines whether two objects are equal. This interface
    is used by generic collections for testing for equality in various methods. Therefore,
    for performance reasons, it should be implemented by all types that might be stored
    in generic collections.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the `Point` structure that implements `IEquatable<T>`
    is as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this example, you should notice that the generic type parameter for `IEquatable`
    is the type itself, `Point`. This is a technique called the *curiously recurring
    template pattern*. The class implements `Equals(Point)`, checking the properties
    of the type. However, it also overrides the `System.Object` virtual methods, `Equals()`
    and `GetHashCode()`, making sure the two implementations are consistent.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'When implementing the `IEquatable<T>` interface, you should keep the following
    in mind:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '`Equals(T)` and `Equals(object)` must return consistent results.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value is comparable, then it should implement `IComparable<T>` too.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the type implements `IComparable<T>`, then it should implement `IEquatable<T>`
    too.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second solution is to overload the `==` and `!=` operators. This can be
    done as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In this case, we will no longer use `Equals()` to compare values, but the two
    operators `==` and `!=`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: It is, however, possible to both implement `IEquatable<T>` and overload the
    comparison operators, if you want to be able to check for equality both ways.
    We will discuss operator overloading in more detail in [*Chapter 5*](B12346_05_Final_JC_ePub.xhtml#_idTextAnchor103),
    *Object-Oriented Programming in C#*.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An enumeration is a set of named integral constants. We use the `enum` keyword
    to declare an enumeration. An enumeration is a value type. Enumerations are useful
    when we want to use a limited number of integral values for some particular purpose.
    Defining and using an enumeration has several advantages:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: We use named constants instead of literal values. This makes the code more readable
    and easier to maintain.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you use IDEs, such as Visual Studio, you can see the list of possible values
    that can be assigned to a variable.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It enforces type safety for using numerical constants.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example shows an enumeration called `Priority` with four possible
    values:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Each element of an enumeration stands for an integer value. By default, the
    first identifier is assigned to zero (`0`). The value of each successive identifier
    will increase by one. It is also possible to specify explicit values for each
    element. The following rules apply:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: These values must be within the range of the underlying type.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The values do not have to be consecutive or in order.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple identifiers with the same numerical value can be defined.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The enumeration, as defined, is semantically equivalent to the following, where
    values are specified explicitly:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As mentioned earlier, each element of the enumeration can have any numerical
    value. The following example shows a definition of the `Priority` enumeration.
    Where some elements do have explicit values, others are calculated based on them:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this implementation, `Low` is 10, `Normal` is 11, `Important` is 20, and
    `Urgent` is 21.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'The default underlying type of an enumeration is `int`, but any integral type
    can be specified as the underlying type. The `char` type cannot be the underlying
    type for an enumeration. In the following example, `byte` is the underlying type
    for `Priority`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To use an element of an enumeration, you specify the enumeration name followed
    by a dot (`.`) and the element name, such as `Priority.Normal`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Any value of the underlying type can be assigned to an enumeration variable,
    even if an element with a corresponding numerical value does not exist. This is
    only possible with a cast. However, the literal `0` is implicitly convertible
    to any enumeration type without the need for a cast:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'On the other hand, there is no implicit conversion between an enumeration and
    an integral type. To obtain the integer value of an enum identifier, we must use
    an explicit cast, as shown here:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Because all the references to the elements of an enumeration are replaced at
    compile time with their literal values, changing the values of the enumeration
    elements will affect referencing assemblies. When the enum type is used in other
    assemblies, the numerical values will be stored in those assemblies. Changes in
    the enumeration will not be reflected in the dependent assemblies unless they
    are recompiled.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'Should you need to parse an enumeration value from a string, you can use the
    generic `Enum.TryParse()` method, as in the following example:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'However, if you want to parse from a string ignoring the case, then you need
    to use a non-generic overload of the same method, as shown here:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In this example, the string `"normal"` is parsed, ignoring the case to identify
    a possible value of the `Priority` enumeration. The value returned in the output
    parameter is `Priority.Normal`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have mentioned namespaces several times in this book already without explaining
    what they really are. Namespaces are used to organize your code in logical units.
    A namespace defines a declaration space that contains types. This declaration
    space has a name that is part of a type's name. For instance, the .NET type `String`
    is declared in the `System` namespace. The complete name of the type is `System.String`.
    This is called the fully-qualified name of the type. Typically, we use only the
    unqualified name of the type (`String`, in this case), because we use `using`
    directives to bring declarations into the current scope from a particular namespace.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'Namespaces are used for two main purposes:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: To help organize the code. Typically, types that belong together are declared
    in the same namespace.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To avoid possible name collisions for types. A program may rely on different
    libraries and it's not unlikely that types with the same name exist in two or
    more of these libraries. By using namespaces with a high degree of uniqueness,
    the chance for name collisions is drastically reduced.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces are introduced with the `namespace` keyword. They are implicitly
    public and you cannot use access modifiers when declaring them. A namespace can
    contain any number of types (classes, structures, enumerations, or delegates).
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example shows how to define a namespace, called `chapter_04`:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Namespaces can be nested; one namespace can contain other namespaces. An example
    is shown in the following snippet, where the `chapter_04` namespace contains a
    nested namespace called `demo`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In this example, the fully qualified name of the `foo` type is `chapter_04.demo.foo`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'For brevity, nested namespaces can be declared with a shorthand syntax: instead
    of multiple namespace declarations, only one is necessary. The name of the namespace
    is the concatenation of all the namespace names, separated by a dot. The previous
    declaration is equivalent to the following:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To use an instance of this `foo` type, you would have to use its fully-qualified
    name, as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'To avoid this, you can use a `using` directive, specifying the namespace name
    as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: A `using` directive can only be present at a namespace level (not locally to
    a method or type). Typically, you put them at the beginning of a source file,
    in which case its types are available throughout the entire source code defined
    in that file. Alternatively, you can specify them in a particular namespace, in
    which case its types will only be available to that namespace.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'A namespace is said to be open-ended. This means that you can have multiple
    namespace declaration with the same name, either in the same or different source
    files. In this case, all these declarations represent the same namespace and contribute
    to the same declaration space. The following snippet demonstrates an example of
    this case:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'There is an implicit namespace that is the root of all namespaces (and contains
    all namespaces and types that are not declared in a named namespace). This namespace
    is called `global`. If you need to include it to specify a fully qualified name,
    then you must separate it with `::` and not with a dot, as in `global::System.String`.
    This can be necessary in situations where namespace names collide. Here is an
    example:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In this example, without the `global::` alias, the user-defined `chapter_04.System.Console`
    type would be used in the `Main()` function, instead of the expected `System.Console`
    type.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the user-defined types in C#. We learned
    about classes and structures that help us to create custom user types in C#. We
    also learned how to create and use fields, properties, methods, indexers, and
    constructors inside a class, and we learned about the `this` and `static` keywords.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: We explored the concepts of access modifiers and understood how we can define
    various levels of access to types and members. We also learned about `ref`, `in`,
    and `out` parameter modifiers, as well as methods with a variable number of arguments.
    Last but not least, we learned about namespace and how to use them to organize
    code and avoid name collisions.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about **Object-Oriented Programming** (**OOP**)
    concepts. We will explore the building blocks of OOP—encapsulation, inheritance,
    polymorphism, and abstraction. We will also learn about abstract classes and interfaces.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Test what you learned
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a class and what is an object?
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between classes and structures?
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a read-only field?
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are expression body definitions?
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a default constructor and what is a static constructor?
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are auto-implemented properties?
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are indexers and how are they defined?
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a static class and what can it contain?
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the parameter specifiers and how do they differ?
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are enumerations and when are they useful?
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
