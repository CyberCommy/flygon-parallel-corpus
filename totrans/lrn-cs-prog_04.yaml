- en: '*Chapter 4:* Understanding the Various User-Defined Types'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about control statements and exceptions
    in C#. In this chapter, we will explore the user-defined types in C#. We will
    learn how to create custom user types using classes, structures, and enumerations.
    We will explore what fields, properties, methods, indexers, and constructors are
    in a class. We will study the access modifiers in C# and learn how to use them
    to define the visibility of types and members. We will also learn about two important
    keywords in C#—`this` and `static`—and understand the `ref`, `in`, and `out` parameter
    modifiers for methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore the following topics in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes and objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good knowledge of these concepts is necessary to understand the **object-oriented
    programming** (**OOP**) concepts that we will cover in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Classes and objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we go further, it is important that you understand these two key concepts.
    A class is a template or a blueprint that specifies the form of an object. It
    contains both data and code that operates on that data. An object is an instance
    of a class. Classes are defined using the `class` keyword and a type that is a
    class is a reference type. The default value for a variable of a reference type
    is `null`. You can assign it as a reference to an instance of the type. Instances—that
    is, objects—are created using the `new` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Information box
  prefs: []
  type: TYPE_NORMAL
- en: The terms *class* and *object* are often used interchangeably in different technical
    documentations. They are not the same and it is improper to use them as so. The
    class is the blueprint that specifies the memory layout of objects and defines
    functionalities that operate with that memory. Objects are the actual entities
    created and operated according to the blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code snippet to understand how a class is defined.
    In this example, we are creating an `Employee` class with three fields to represent
    the ID, first name, and last name of an employee:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will use the `new` keyword to create an instance of the class. The `new`
    operator allocates memory for an object and returns a reference to it at runtime.
    This reference is then stored in the variable that specifies the object's name.
    The object is stored on the heap, and the reference to the object is stored in
    the stack storage location corresponding to the named variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an object of the `Employee` class, we will use the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the members of a class (fields, properties, methods) using an object,
    we use the dot (`.`) operator. Hence, to assign values to the fields of the object
    (`obj`), we will use the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram shows, conceptually, what is happening here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The conceptual memory layout for the preceding Employee object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.1._B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – The conceptual memory layout for the preceding Employee object
  prefs: []
  type: TYPE_NORMAL
- en: The **obj** variable of the **Employee** type is allocated on the stack. However,
    the stack does not contain the actual **Employee** object but only a reference
    to it. The object is allocated on the heap and the address of the object is stored
    on the stack so that by using the **obj** variable we can access the object that
    is located on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two different instances of a class are two different objects. A reference to
    an object can be assigned to multiple variables. In this case, modifications to
    the object through one variable will be visible through the other variable. This
    is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have created a first instance of the `Employee` class and only assigned
    a value to `EmployeeId`. Then, we created a second instance and assigned values
    to the first and last name, skipping the identifier. These are two different objects,
    residing in different locations in memory.
  prefs: []
  type: TYPE_NORMAL
- en: The properties of an employee are stored in the class in member fields. These
    will be discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: Fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These are variables declared directly inside a class and are, therefore, members
    of the class. Fields are used for storing the state of the object, which is data
    that must live for more than the period of the execution of a class method and
    that should be accessible from multiple methods. Variables that are not used outside
    the scope of a single method should be defined as local variables and not class
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding section, `EmployeeId`, `FirstName`, and `LastName` are the
    mentioned fields. These are called **instance fields** because they belong to
    the instance of the class, meaning that each object has its own instance of these
    fields. On the other hand, *static fields* belong to the class and are shared
    by all instances of the class. Static members will be discussed in a later section
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: These fields have been declared `public`, which means they can be accessed by
    anyone. This is, however, a bad practice. Fields should usually be declared as
    either `private` (to be accessible only to the class members) or `protected` (to
    also be accessible to the derived classes). This ensures better encapsulation,
    which will be discussed further in the next chapter. Fields can be accessed both
    for reading and writing using methods, properties, and indexers. We will discuss
    these in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fields that are declared with the `const` specifiers are called **constants**.
    Only built-in types can be constants. Constants are always initialized with a
    literal and are values known at compile time that cannot be changed at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Constant fields are substituted for their literal value in the intermediate
    language code, which means you cannot pass a constant field by reference. But
    this has another, more subtle implication: if the constant value is referred in
    assemblies other than the one in which the type is defined and the literal value
    of the constant is changed in a future version, the assemblies referring the constant
    will continue to have the old version until they are recompiled.'
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if an integer constant defined in assembly A was initially set
    to 42 and it was referred in assembly B, then the value 42 will have been stored
    in assembly B. Changing the value of the constant to something else (let's say
    100) will not be reflected in assembly B, which will continue to store the old
    value until it is recompiled with the new version of assembly A.
  prefs: []
  type: TYPE_NORMAL
- en: Fields can also be declared with the `readonly` specifier. These fields can
    only be initialized in a constructor and their value cannot be changed later on.
    They can be thought of as **runtime constants**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the `EmployeeId` field is a `readonly` field that
    is initialized in the constructor. Only the first and last name fields can be
    changed for an instance of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen how to work with fields, let's learn about methods.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Methods are a series of one or more statements that are executed when the method
    is invoked. Instance methods require an object in order to be called. Static methods
    belong to the class and are not called using an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'A method has a so-called *signature* that consists of several parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`private` by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`virtual`, `abstract`, `sealed`, or `static`: These are all optional and will
    be discussed in later sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void` if the method does not return any value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A name**: This must be a valid identifier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ref`, `in`, or `out` specifier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, we will add a method to our `Employee` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have added a method called `GetEmployeeName()`. The access modifier
    is `public`, which allows this method to be called from any part of the code.
    The return type is `string` as the method is returning the name of the employee
    by concatenating the `FirstName` and `LastName` fields separated by a space.
  prefs: []
  type: TYPE_NORMAL
- en: Methods that simply consist of evaluating an expression, and perhaps returning
    the result of the evaluation, can be written using an alternative syntax called
    `member => expression;` form and are supported for all class members, not just
    methods, but also fields, properties, indexers, constructors, and finalizers.
    The type of the result value of the expression evaluation must match the return
    type of the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the implementation of the `GetEmployeeName()` method
    using an expression body definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Overloaded methods** are multiple methods that have the same name but a different
    signature. Such methods can exist. The return type of these methods is not a part
    of the signature in the context of method overloading. This means that you cannot
    have two methods with the same list of parameters but with different return values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, `GetEmployeeName(bool)` is an overloaded method for
    the previous `GetEmployeeName()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This method has the same name but a different list of parameters. It takes a
    Boolean value that indicates whether the last name should be put first, or else
    returns the name with the first name followed by the last name, just like the
    previous method did.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A constructor is a special method defined in a class that is called when we
    instantiate an object for the class. Constructors are used to initialize the members
    of the class upon the object's creation. A constructor cannot have a return type
    and has the same name as the class. Multiple constructors with different parameters
    may exist.
  prefs: []
  type: TYPE_NORMAL
- en: A constructor without any parameters is called a *default constructor*. Such
    a constructor is provided by the compiler to all classes. The default constructor
    is created at compile time and initializes the member variables to their default
    value. The default value is 0 for numeric data types, `false` for `bool`, and
    `null` for reference types. If we define our own constructor, the compiler will
    no longer provide the default constructor.
  prefs: []
  type: TYPE_NORMAL
- en: A constructor can have an access modifier. The default access modifier of a
    constructor is `private`. However, this modifier makes it impossible to instantiate
    the class from outside the class itself. In most cases, the access modifier of
    a constructor is defined as `public` since a constructor is generally called from
    outside of the class.
  prefs: []
  type: TYPE_NORMAL
- en: A private constructor is useful in certain situations. An example is when implementing
    the singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to understand all the concepts covered so far with the help of the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We have extended our `Employee` class and included a constructor in it. This
    constructor will accept three parameters to initialize the value of all three
    fields: `EmployeeId`, `FirstName`, and `LastName`. When creating an instance of
    the class, you must specify proper arguments for the class constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon execution, this program will give the output shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – A screenshot of the console showing the output of the preceding
    snippet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.2._B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – A screenshot of the console showing the output of the preceding
    snippet
  prefs: []
  type: TYPE_NORMAL
- en: Objects can be initialized in a declarative manner using the so-called *object
    initializer*. You invoke a constructor and, apart from providing the necessary
    arguments to the constructor, you also provide a list of initialization statements
    for accessible members, such as fields, properties, or indexers, within curly
    braces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering the `Employee` class without a user-defined constructor, having
    the default (parameterless) constructor provided by the compiler, we can write
    the following code to initialize an instance of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So far in this chapter, we have used fields to store the state of an object.
    The C# language provides an alternative to fields: properties, which is the topic
    of the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A property is a combination of a field and a method to access that field. They
    look like fields but are actually methods called **accessors**. Properties make
    it possible to read or write the class state in a simple manner and hide the implementation
    details, including verification code.
  prefs: []
  type: TYPE_NORMAL
- en: The two accessors that properties define are called `get` (which is used to
    return a value from the property) and `set` (which is used to assign a new value).
    Within the context of the `set` accessor, the `value` keyword defines the value
    being accessed (which is the value assigned from the user code).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the `Employee` class shown earlier in this chapter
    is rewritten so that the employee ID, first name, and last name are private fields
    made available to the class clients using properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the property''s `get` and `set` accessors is actually transparent. You
    do not invoke them explicitly, but use the properties just as though they were
    fields. The following example shows how the three properties of the `Employee`
    class are to be accessed for both writing and reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the properties shown in the preceding code is straightforward—it
    just returns or sets the value of a private field. However, accessors are just
    like any other method, so you can write any code, such as parameter verification,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, a property is not required to refer to a corresponding field.
    A property may return values that are not read from one field or that are calculated
    from evaluating different fields. The following example shows a property, `Name`,
    that concatenates the value of the `FirstName` and `LastName` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the case of this property, the `set` accessor is missing. Both
    the `get` and `set` accessors are optional. However, at least one must be implemented.
    On the other hand, a write-only property does not have much value and you might
    want to implement such functionalities as a regular method. Also, the `get` and
    `set` accessors may have different access modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing properties in this manner is cumbersome because you need to explicitly
    define private fields that you do not use elsewhere other than in the properties.
    Moreover, each property has to explicitly implement the `get` and `set` accessors,
    basically repeating the same code over and over again. It is possible to achieve
    the same result with a shorter syntax using *auto-implemented properties*. These
    are properties for which the compiler will provide a private field and the implementation
    of the `get` and `set` accessors, as we did earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Employee` class is re-written with auto-implemented properties, as in
    the following code. This very much resembles our first implementation where we
    were using public fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do not want to set the values of these properties, you can declare only
    the `get` accessor `public`. In such cases, the `set` accessor would probably
    be `private` and you would provide values through the constructor. Such an example
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Properties can be implemented using expression body definitions. The `Name`
    property shown earlier can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a read-only property that only has the `get` accessor. However, you
    can explicitly implement both the `get` and `set` accessors as expression body
    members. This is shown in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Auto-implemented properties can also be initialized using the syntax shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The value of the `EmployeeId` property is initialized with `1`. Unless otherwise
    explicitly set, all instances of the `Employee` class will have `EmployeeId` set
    to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are implementing a read-only property using an expression body definition,
    you do not need to specify the `get` accessor. The syntax, in this case, is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This, however, looks very similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a big difference between these syntaxes:'
  prefs: []
  type: TYPE_NORMAL
- en: In the former example, where `=>` is used, `EmployeeId` is a *read-only public
    property* with an *expression body definition*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the latter example, where `=` is used, `EmployeeId` is a *public field* with
    an *initializer*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a special form of property that can take parameters and allow access
    to class instances using the operator `[]`. These are called **indexers** and
    are discussed in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Indexers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An indexer allows an object to be indexed like an array. An indexer defines
    a `get` and `set` accessor, similar to a property. An indexer does not have an
    explicit name. It is created by using the `this` keyword. An indexer has one or
    more parameters, which can be of any type. As in the case of properties, the `get`
    and `set` accessors are usually simple and consist of a single statement that
    returns or sets a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the `ProjectRoles` class contains a mapping of the
    project IDs and roles that an employee has in each project. This mapping is private
    but access to it is available through an indexer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The indexer is defined with the `public string this[int projectId]` syntax,
    which contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An access modifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of the indexer, which is `string`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `this` keyword and the list of parameters in square brackets `[]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `get` and `set` accessors are implemented in the same way as for a regular
    property. This `ProjectRoles` class can be used as follows within the `Employee`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can access the employee roles using the `Roles[i]` syntax, just as if `Roles`
    was an array. In this example, the parameter is not an index in the array but
    a project identifier, which is actually the key to the dictionary of projects
    and roles. The parameters can be of any type, not just numerical types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from executing this sample code is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Console output from executing the preceding code snippet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.3._B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – Console output from executing the preceding code snippet
  prefs: []
  type: TYPE_NORMAL
- en: Indexers, including read-only indexers, can be implemented with expression body
    definitions. However, there are no auto-implemented indexers; they have to be
    implemented explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, indexers are defined using the `this` keyword. However, this keyword
    has other meanings outside the scope of indexers. This topic will be discussed
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The this keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `this` keyword is used to represent the current instance of a class. When
    a method is called, the reference of the calling object is passed to it using
    `this`. This is not done explicitly, but behind the scenes by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `this` keyword has two important purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: To qualify class members when parameters or local variables with the same name
    exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To pass a reference to the current instance as a parameter to another method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the following implementation of the `Employee` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the parameters of the constructor have the same name as the
    fields of the class. C# allows us to use the same name for the parameter and instance
    variable. Since the parameter name is local to a method, the local name takes
    precedence over the instance variable. To alleviate this situation, we use the
    `this` keyword to refer to the instance variable for the current method invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have seen the `this` keyword used for referring to the current instance
    of a class and for declaring indexes. However, it is used for yet another purpose,
    and that is declaring extension methods. These will be discussed in [*Chapter
    8*](B12346_08_Final_JC_ePub.xhtml#_idTextAnchor154), *Advanced Topics*. For now,
    let''s look at another important keyword: `static`.'
  prefs: []
  type: TYPE_NORMAL
- en: The static keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `static` keyword can be used to declare classes or class members. These
    differ from what we have seen so far because you do not create instances of static
    classes or do not need objects to access static members. We will explore these
    in detail in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Static members
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Fields, properties, methods, and constructors can be declared `static`. Indexers
    and finalizers cannot be declared `static`. A static member does not belong to
    the object (as in the case of an instance member) but rather to the type itself.
    Therefore, you cannot access a static member through an object but through the
    type name.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we have an implementation of the `Employee` class
    that has a static field called `id` and a static method called `Create()`. The
    static field is storing the value of the next employee ID, and the static method
    is used to create a new instance of the class because the constructor is `private`
    and therefore it can only be called from within the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call the `Create()` method as follows to instantiate a new object of
    this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The first object created like this will have `EmployeeID` set to `1`, the second
    one will have `EmployeeID` set to `2`, and so on. Notice that we used the `Employee.Create()`
    syntax to call the static method.
  prefs: []
  type: TYPE_NORMAL
- en: Static classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `static` class is also declared using the `static` keyword. A `static` class
    cannot be instantiated. Since we cannot create instances of a `static` class,
    we access the class members using the class name itself. All members of a static
    class must themselves be static. A static class is basically the same as a non-static
    class, with a `private` constructor and all members declared as `static`.
  prefs: []
  type: TYPE_NORMAL
- en: A `static` class is typically used to define methods that operate only on their
    parameters (if any) and do not rely on class fields. This is often the case with
    utility classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a static class called `MassConverters`, which contains
    static methods to convert between kilograms and pounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Because static classes cannot be instantiated, the `this` keyword has no meaning
    within the context of such a class. An attempt to use it would result in a compiler
    error.
  prefs: []
  type: TYPE_NORMAL
- en: The static constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A class can have a static constructor, whether the class itself is static or
    not. A static constructor has no parameters or access modifiers and cannot be
    called by the user. A static constructor is called by the CLR automatically in
    the following instances:'
  prefs: []
  type: TYPE_NORMAL
- en: In a static class when the first static member of the class is accessed for
    the first time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a non-static class when the class is instantiated for the first time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static constructors are useful for initializing static fields. For instance,
    a `static readonly` field can only be initialized during declaration or in the
    static constructor. This is useful especially when the values are taken from configuration
    files, for writing entries to a log file, or for writing wrappers for unmanaged
    code, when the static constructor can call the `LoadLibrary()` API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the previous implementation of the `Employee` class
    is modified such that a static constructor is provided to initialize the value
    of the static `id` field. This constructor is reading the ID of the next employee
    from an application file or initializes it with `1` if the file is not found.
    Every time a new instance of the class is created, the value of the next employee
    ID is written to this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the following code several times, the first time the IDs of the
    two employees will be `1` and `2`, then `3` and `4`, and so forth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have seen how to create methods and constructors. In the next section,
    we will learn about the different ways you can pass parameters to them.
  prefs: []
  type: TYPE_NORMAL
- en: The ref, in, and out parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we pass an argument to a method, it is passed by a value. This means a
    copy is made. If the type is a value type, then the value of the argument is copied
    into the method parameter. If the type is a reference type, then the reference
    is copied to the method parameter. When you change the parameter value, it changes
    the local copy. This means changes in arguments of value types are not propagated
    to the caller. As for arguments of reference types, you can change the referred
    object on the heap but you cannot change the reference itself. This behavior can
    be altered using the `ref`, `in`, and `out` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: The ref keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ref` keyword allows us to create a *call-by-reference mechanism* rather
    than a call-by-value mechanism. A `ref` keyword is specified when we declare and
    invoke the method. The use of the `ref` keyword alters the parameter so that it
    becomes an alias for an argument, which must be a variable. This means you cannot
    pass a property or an indexer (which is actually a method) as an argument for
    a `ref` parameter. A `ref` parameter must be initialized prior to the method call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this program, we have defined a `Swap` method to swap two integer values.
    We are using the `ref` keyword to declare the method parameters. We defined this
    method as `static` so that we can invoke it without an object reference. Inside
    the `Main` method, we have initialized two integer variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'While invoking the `Swap` method, we have also used the `ref` keyword with
    argument names. These `ref` parameters are passed as a reference and the actual
    value of the `num1` and `num2` variables will be swapped. The change is reflected
    in the variables in the `Main` method. The output of this program is shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Console showing the values of num1 and num2 before and after
    swapping'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.4._B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Console showing the values of num1 and num2 before and after swapping
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ref` keyword can be used to specify a reference return value. In this
    case, it must be present in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the method signature, before the return type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the return statement, between the `return` keyword and the returned value.
    Such a value is called a *ref return value*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the declaration of a local variable that will receive the returned reference,
    before the variable's type. Such a variable is called a *ref local variable*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before the call to the method with a `ref` return.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, the `Project` class has a member field of the `Employee`
    type. A reference to an `Employee` instance is set in the constructor. The `GetOwner()`
    method returns a reference to the member field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be used as follows to retrieve and change the owner of a project.
    In the following code, notice the use of the `ref` keyword in the declaration
    of the local variable and the invocation of the `GetOwner()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this program is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – A screenshot of the output from the previous snippet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.5._B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – A screenshot of the output from the previous snippet
  prefs: []
  type: TYPE_NORMAL
- en: 'When using `ref` to return a value, you must be aware of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It is not possible to return a reference to a local variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not possible to return a reference to `this`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible to return references to class fields but also to properties without
    a `set` accessor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible to return a reference to `ref`/`in`/`out` parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning by reference breaks the encapsulation because the caller gets full
    access to the state, or parts of the state, of an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now look at the `in` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The in keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `in` keyword is very similar to the `ref` keyword. It causes an argument
    to be passed by reference. However, the key difference is that an `in` argument
    cannot be modified by the called method. An `in` parameter is basically a `readonly
    ref` parameter. Should the called method try to modify the value, the compiler
    will issue an error. A variable that is passed as an `in` argument must be initialized
    before being passed as an argument in a method called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sample shows a method that takes two `in` arguments. Any attempt
    to change their value results in a compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Specifying the `in` keyword when passing the arguments to the method is optional.
    In the preceding example, this is omitted.
  prefs: []
  type: TYPE_NORMAL
- en: The `in` specifier is mostly intended for passing references to value type objects
    on hot paths, that is, functions that are called repeatedly. When you pass a value
    type object to a function, a copy of the value is made on the stack. Typically,
    this does not pose any performance concerns but, when it is happening over and
    over again, performance issues arise. By using the `in` specifier, a read-only
    reference to the object is passed, thereby avoiding the copy.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of the `in` specifier is the communication of the clear design
    intent that a parameter is not supposed to be modified by a method.
  prefs: []
  type: TYPE_NORMAL
- en: The out keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `out` keyword is similar to the `ref` keyword. The difference is that a
    variable passed as an `out` argument does not have to be initialized before the
    method called, but the method taking an `out` parameter must assign a value to
    it before returning. The `out` keyword must be present both in the method definition
    and in the invocation of the method, before the argument.
  prefs: []
  type: TYPE_NORMAL
- en: Returning an output value is useful in situations when a method needs to return
    more than one value, or when it needs to return a value but also information about
    whether the execution was successful or not. An example is `int.TryParse()`, which
    returns a Boolean indicating whether the parsing was successful and the actual
    parsed value as an `out` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how it works, let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We have defined a `static` method to return the square of an integer. The `Square`
    method will accept two parameters. The `int` parameter will be an integer value
    and it will return the square of the input number via the `out` parameter output.
    It can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Upon execution, the output of this program will be `100`.
  prefs: []
  type: TYPE_NORMAL
- en: A variable that is used as an `out` argument can be declared inline in the method
    invocation. This produces simpler and more compact code. The scope of the inline
    variable is the scope in which the method is being invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code can be simplified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: There are some restrictions when using these parameter specifiers, which will
    be explained in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding their limitations
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the `ref`, `in`, and `out` parameters, you must be aware of several
    limitations. These keywords cannot be used with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Async methods, defined with the `async` modifier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterator methods, which include either `yield return` or `yield break`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, the `ref`, `in`, and `out` keywords are not considered a
    part of the method signature in the context of overload resolution. That means
    you cannot have two overloads of the same method: one that takes a `ref` argument
    and one that takes the same argument as an `out` parameter. However, it is possible
    to have overloaded methods if one has a value parameter, and the other has a `ref`,
    `in`, or `out` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: All the methods that we have seen so far in this book have a fixed number of
    arguments. The language, however, allows us to define methods that can take a
    variable number of arguments. This topic is discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: Methods with a variable number of arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have only seen methods that take zero or a fixed number of arguments.
    However, it is also possible to define methods that take any number of arguments
    of the same type. To do so, you must have an argument that is a single-dimensional
    array preceded by the `params` keyword. This parameter does not have to be the
    only parameter of the method, but no further parameters are allowed after it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we have two methods—`Any()` and `All()`—that take
    a variable number of Boolean values and return a Boolean value, indicating whether
    any of them is `true`, and respectively, whether all of them are `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these methods can be invoked with zero, one, or any other number of
    arguments, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The way the arguments are provided for a method call is flexible. We will look
    at existing possibilities next.
  prefs: []
  type: TYPE_NORMAL
- en: Named and optional arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In all of the examples we have seen so far, the arguments for a method call
    were provided in the order of the parameter declaration in the method signature.
    These are called *positional arguments* because they are evaluated based on the
    position they are given. Moreover, all the parameters were mandatory, which means
    that an invocation cannot occur unless an argument is supplied for each parameter
    in the parameters list.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, C# supports two more types of arguments: *optional arguments* and
    *named arguments*. These are often used together and enable us to supply only
    some arguments for the parameters in a list of optional parameters. These can
    be used with methods, indexers, constructors, and delegates.'
  prefs: []
  type: TYPE_NORMAL
- en: Optional arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When declaring a method, constructor, indexer, or delegate, we can specify
    a default value for a parameter. When such a parameter exists, supplying an argument
    for it upon the member invocation is optional. If none is provided, the compiler
    will use the default one. A default value for a parameter must be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A constant expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An expression of the `new T()` form, where `T` is a value type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An expression of the `default(T)` form, where `T` is also a value type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method can have both required and optional parameters. If optional parameters
    are present, they must follow all the non-optional parameters. A non-optional
    parameter cannot follow an optional parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following implementation of the `Point` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor takes two parameters, both of them having the default value
    `0`. This means they are both optional. We can invoke the constructor in any of
    the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, no argument to the constructor of `Point` is supplied,
    so the compiler will use `0` for both `x` and `y`. In the second example, a single
    argument is supplied and that will be used to bind to the first constructor parameter.
    Therefore, `x` will be `1` and `y` will be `0`. In the third and last example,
    two arguments are supplied, and they are bound to `x` and `y` in this order. Therefore,
    `x` is 1 and `y` is `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Named arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Named arguments enable us to invoke a method specifying the arguments by their
    name and not by their position in the parameters list. Arguments can be specified
    in any order and, in combination with default arguments, we can specify only some
    arguments for a method invocation. Named arguments are provided by specifying
    the parameter name followed by a colon (`:`) and the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The first three constructor invocations are equivalent; `p1`, `p2`, and `p3`
    represent the same point. The invocation of the constructor uses one or more named
    arguments but the effect is the same. When constructing `p4`, on the other hand,
    only the value for `y` is specified. Therefore, `x` will be `0` and `y` will be
    `2`. Lastly, `p5` is created by specifying only a named argument for `x`. Therefore,
    `x` will be `1` and `y` will be `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Access modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An access modifier is used to define the visibility of a type or member in
    C#. It specifies what other parts of the code in the assembly or other assemblies
    can access the type or the type member. C# defines six types of access modifiers,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public`: A public field can be accessed by any part of the code in the same
    assembly or in another assembly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected`: A protected type or member can be accessed only in the current
    class and in a derived class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`internal`: An internal type or member is accessible only within the current
    assembly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected internal`: This is a combination of `protected` and `internal` access
    levels. A protected internal type or member is accessible in the current assembly
    or in a derived class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private`: A private type or member can be accessed only inside the class or
    struct. This is the least-accessible level defined in C#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private protected`: This is a combination of `private` and `protected` access
    levels. A private protected type or type member is accessible by code in the same
    class, or in a derived class, but only within the same assembly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying to access a type or type member outside its access level will result
    in a compile-time error.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different kinds of rules for accessibility that apply to types and
    type members:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public` or `internal` (which is the default). Derived classes, on the other
    hand, cannot have greater accessibility than their base types. That means if you
    have an `internal` class `B`, you cannot derive from it a `public` class `D`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public`, `internal`, or `private`. These rules apply to nested structs and
    classes. The default access level for class and struct members is `private`. A
    nested type that is `private` is accessible only from the enclosing type. The
    accessibility of a member cannot be greater than the type that contains it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, the type of a field, property, or event must be at least as accessible
    as the field itself. Similarly, the return type of a method, indexer, or delegate,
    as well as the type of its parameters, cannot be less accessible than the member
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: '`public` and `static`. Finalizers cannot have accessibility modifiers. Interfaces
    defined directly in a namespace can be `public` or `internal` (which is the default).
    Access modifiers cannot be applied to any interface members, which are implicitly
    `public`. In a similar manner, enumeration members are implicitly `public` and
    cannot have access specifiers. Delegates are like classes and structs – their
    default access is `internal` when defined directly in a namespace, and `private`
    when nesting in another type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows various uses of access modifiers for types and type
    members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We have learned in this chapter how to define custom classes. In all the examples
    so far, the entire class was defined in a single place. However, it is possible
    to split a class across several different definitions, in the same or different
    files, which is what we will look at in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Partial classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A partial class allows us to divide our class into multiple class definitions,
    which is useful when a class becomes very large or when we want to separate a
    class logically into multiple parts. This enables technologies such as WPF to
    work better because the user code and the code written by the IDE designers are
    separated into different source files.
  prefs: []
  type: TYPE_NORMAL
- en: Each part can be defined in a different source file using the `partial` keyword.
    This keyword must appear immediately before the `class` keyword. The parts must
    be available at compile time. During compilation, the parts are combined into
    a single type.
  prefs: []
  type: TYPE_NORMAL
- en: The `partial` keyword can be applied not only to classes, but also structures,
    interfaces, and methods. The same rules apply to all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the `partial` class is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we split the class definition into two `partial` classes. Both `partial`
    classes contain some properties. We can instantiate the `partial` class and use
    its properties similar to a normal class. Refer to the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following list contains properties of partial types, as well as rules for
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: All the parts must have the same accessibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different parts may specify a different base interface. The final type will
    implement all the listed interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If multiple parts specify a base class then it must be the same base class,
    as multiple inheritances are not supported in C#. A base class can be specified
    only on one part. It is optional on the others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes of all the parts are merged together at compile type. The final type
    will have all the attributes used on all the part declarations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested classes can also be partial.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods can also be partial. This enables us to provide the signature in one
    part of a `partial` class or structure and the implementation in another. This
    is useful in IDEs to provide method hooks that developers may or may not implement.
    If a partial method does not have an implementation, it is removed from the class
    definition at compile time. Partial methods cannot have an access modifier and
    are implicitly private. Also, a partial method cannot return a value; the return
    type of a partial method must be `void`.
  prefs: []
  type: TYPE_NORMAL
- en: Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The content of this chapter so far has been focused on classes. Types that
    are defined as classes are reference types. However, in .NET and C#, there is
    another category of types: **value types**. Value types have value semantics,
    meaning that the value of the object, and not a reference to the object, is copied
    on assignment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Value types are defined using the `struct` keyword instead of `class`. In most
    aspects, structures are identical to classes and the characteristics presented
    in this chapter for classes apply to structures too. However, there are several
    key differences:'
  prefs: []
  type: TYPE_NORMAL
- en: Structures do not support inheritance. Although a structure can implement any
    number of interfaces, it cannot derive from another structure. For this reason,
    structure members cannot have the `protected` access modifier. Also, a structured
    method or property cannot be `abstract` or `virtual`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A structure cannot declare a default (parameterless) constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structures can be instantiated without using the `new` operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a structure declaration, fields cannot be initialized unless they are declared
    `const` or `static`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s consider the following example where we define a structure called `Point`
    with two integer fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can instantiate this either using the `new` operator, which would call the
    default constructor initializing all the member fields with their default value,
    or directly, without the `new` operator. In this case, the member fields would
    remain uninitialized. This could be useful for performance reasons, but such an
    object cannot be used until all of its fields are properly initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code uses the `new` operator to create an instance of the type.
    On the other hand, in the following example, the object is created without the
    `new` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'While structures and classes have many things in common, they also differ in
    several key aspects. It is important to understand when you should use classes
    and when you should use structures. A structure should be used in the following
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: When it represents a single value (such as a point, a GUID, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it is small (typically no larger than 16 bytes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it is immutable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it is short-lived
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it is not used frequently in boxing and unboxing operations (which alter
    performance)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all the other cases, types should be defined as classes.
  prefs: []
  type: TYPE_NORMAL
- en: A variable of a value type cannot be assigned a `null` value. However, for situations
    when no value is a valid value for a value type, a nullable value type (denoted
    as `T?` using shorthand syntax) can be used. Nullable types were discussed in
    [*Chapter 2*](B12346_02_Final_JC_ePub.xhtml#_idTextAnchor036), *Data Types and
    Operators*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows an example of a nullable `Point` variable assigned with
    `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: It is often mentioned in the literature that instances of value types are stored
    on the stack. This statement is only partially true. The stack is an implementation
    detail; it is not part of the characteristics of value types. Local variables
    or temporaries of value types are indeed stored on the stack (unless they are
    not closed over outer variables of a lambda or an anonymous method) and not part
    of an iterator block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, they are typically stored on the heap. However, this is entirely
    an implementation and compiler detail and, in fact, value types can be stored
    in many places: in the stack, in a CPU register, on the FPU frame, on the heap
    managed by the garbage collector, on the loader heap of the AppDomain, or in the
    thread-local storage (if the variable has the `ThreadStorage` attribute).'
  prefs: []
  type: TYPE_NORMAL
- en: When a value type object (the storage location contains the value directly)
    is assigned to a reference type object (the storage location contains a reference
    to the actual value), the process of boxing occurs. The other way around the process
    is called unboxing. We have discussed these two previously in this book, in [*Chapter
    2*](B12346_02_Final_JC_ePub.xhtml#_idTextAnchor036), *Data Types and Operators*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have two variables of the `Point` value type and we want to check whether
    they are equal. To do so, we invoke the `Equals()` method that is defined in the
    `System.Object` base class. When we do this, boxing occurs because the parameter
    of `Equals` is an object, that is, a reference type. Boxing may become a performance
    issue if it is performed very often. There are two ways to avoid boxing for a
    value type.
  prefs: []
  type: TYPE_NORMAL
- en: The first solution is to implement the `IEquatable<T>` interface that contains
    a single `Equals(T)` method. This method allows both value and reference types
    to implement a way that determines whether two objects are equal. This interface
    is used by generic collections for testing for equality in various methods. Therefore,
    for performance reasons, it should be implemented by all types that might be stored
    in generic collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the `Point` structure that implements `IEquatable<T>`
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you should notice that the generic type parameter for `IEquatable`
    is the type itself, `Point`. This is a technique called the *curiously recurring
    template pattern*. The class implements `Equals(Point)`, checking the properties
    of the type. However, it also overrides the `System.Object` virtual methods, `Equals()`
    and `GetHashCode()`, making sure the two implementations are consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'When implementing the `IEquatable<T>` interface, you should keep the following
    in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Equals(T)` and `Equals(object)` must return consistent results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value is comparable, then it should implement `IComparable<T>` too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the type implements `IComparable<T>`, then it should implement `IEquatable<T>`
    too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second solution is to overload the `==` and `!=` operators. This can be
    done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we will no longer use `Equals()` to compare values, but the two
    operators `==` and `!=`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: It is, however, possible to both implement `IEquatable<T>` and overload the
    comparison operators, if you want to be able to check for equality both ways.
    We will discuss operator overloading in more detail in [*Chapter 5*](B12346_05_Final_JC_ePub.xhtml#_idTextAnchor103),
    *Object-Oriented Programming in C#*.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An enumeration is a set of named integral constants. We use the `enum` keyword
    to declare an enumeration. An enumeration is a value type. Enumerations are useful
    when we want to use a limited number of integral values for some particular purpose.
    Defining and using an enumeration has several advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: We use named constants instead of literal values. This makes the code more readable
    and easier to maintain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you use IDEs, such as Visual Studio, you can see the list of possible values
    that can be assigned to a variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It enforces type safety for using numerical constants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example shows an enumeration called `Priority` with four possible
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Each element of an enumeration stands for an integer value. By default, the
    first identifier is assigned to zero (`0`). The value of each successive identifier
    will increase by one. It is also possible to specify explicit values for each
    element. The following rules apply:'
  prefs: []
  type: TYPE_NORMAL
- en: These values must be within the range of the underlying type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The values do not have to be consecutive or in order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple identifiers with the same numerical value can be defined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The enumeration, as defined, is semantically equivalent to the following, where
    values are specified explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned earlier, each element of the enumeration can have any numerical
    value. The following example shows a definition of the `Priority` enumeration.
    Where some elements do have explicit values, others are calculated based on them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In this implementation, `Low` is 10, `Normal` is 11, `Important` is 20, and
    `Urgent` is 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default underlying type of an enumeration is `int`, but any integral type
    can be specified as the underlying type. The `char` type cannot be the underlying
    type for an enumeration. In the following example, `byte` is the underlying type
    for `Priority`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'To use an element of an enumeration, you specify the enumeration name followed
    by a dot (`.`) and the element name, such as `Priority.Normal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Any value of the underlying type can be assigned to an enumeration variable,
    even if an element with a corresponding numerical value does not exist. This is
    only possible with a cast. However, the literal `0` is implicitly convertible
    to any enumeration type without the need for a cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, there is no implicit conversion between an enumeration and
    an integral type. To obtain the integer value of an enum identifier, we must use
    an explicit cast, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Because all the references to the elements of an enumeration are replaced at
    compile time with their literal values, changing the values of the enumeration
    elements will affect referencing assemblies. When the enum type is used in other
    assemblies, the numerical values will be stored in those assemblies. Changes in
    the enumeration will not be reflected in the dependent assemblies unless they
    are recompiled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Should you need to parse an enumeration value from a string, you can use the
    generic `Enum.TryParse()` method, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you want to parse from a string ignoring the case, then you need
    to use a non-generic overload of the same method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the string `"normal"` is parsed, ignoring the case to identify
    a possible value of the `Priority` enumeration. The value returned in the output
    parameter is `Priority.Normal`.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have mentioned namespaces several times in this book already without explaining
    what they really are. Namespaces are used to organize your code in logical units.
    A namespace defines a declaration space that contains types. This declaration
    space has a name that is part of a type's name. For instance, the .NET type `String`
    is declared in the `System` namespace. The complete name of the type is `System.String`.
    This is called the fully-qualified name of the type. Typically, we use only the
    unqualified name of the type (`String`, in this case), because we use `using`
    directives to bring declarations into the current scope from a particular namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Namespaces are used for two main purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: To help organize the code. Typically, types that belong together are declared
    in the same namespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To avoid possible name collisions for types. A program may rely on different
    libraries and it's not unlikely that types with the same name exist in two or
    more of these libraries. By using namespaces with a high degree of uniqueness,
    the chance for name collisions is drastically reduced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces are introduced with the `namespace` keyword. They are implicitly
    public and you cannot use access modifiers when declaring them. A namespace can
    contain any number of types (classes, structures, enumerations, or delegates).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example shows how to define a namespace, called `chapter_04`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Namespaces can be nested; one namespace can contain other namespaces. An example
    is shown in the following snippet, where the `chapter_04` namespace contains a
    nested namespace called `demo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the fully qualified name of the `foo` type is `chapter_04.demo.foo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For brevity, nested namespaces can be declared with a shorthand syntax: instead
    of multiple namespace declarations, only one is necessary. The name of the namespace
    is the concatenation of all the namespace names, separated by a dot. The previous
    declaration is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'To use an instance of this `foo` type, you would have to use its fully-qualified
    name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid this, you can use a `using` directive, specifying the namespace name
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: A `using` directive can only be present at a namespace level (not locally to
    a method or type). Typically, you put them at the beginning of a source file,
    in which case its types are available throughout the entire source code defined
    in that file. Alternatively, you can specify them in a particular namespace, in
    which case its types will only be available to that namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'A namespace is said to be open-ended. This means that you can have multiple
    namespace declaration with the same name, either in the same or different source
    files. In this case, all these declarations represent the same namespace and contribute
    to the same declaration space. The following snippet demonstrates an example of
    this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an implicit namespace that is the root of all namespaces (and contains
    all namespaces and types that are not declared in a named namespace). This namespace
    is called `global`. If you need to include it to specify a fully qualified name,
    then you must separate it with `::` and not with a dot, as in `global::System.String`.
    This can be necessary in situations where namespace names collide. Here is an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: In this example, without the `global::` alias, the user-defined `chapter_04.System.Console`
    type would be used in the `Main()` function, instead of the expected `System.Console`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the user-defined types in C#. We learned
    about classes and structures that help us to create custom user types in C#. We
    also learned how to create and use fields, properties, methods, indexers, and
    constructors inside a class, and we learned about the `this` and `static` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: We explored the concepts of access modifiers and understood how we can define
    various levels of access to types and members. We also learned about `ref`, `in`,
    and `out` parameter modifiers, as well as methods with a variable number of arguments.
    Last but not least, we learned about namespace and how to use them to organize
    code and avoid name collisions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about **Object-Oriented Programming** (**OOP**)
    concepts. We will explore the building blocks of OOP—encapsulation, inheritance,
    polymorphism, and abstraction. We will also learn about abstract classes and interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Test what you learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a class and what is an object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between classes and structures?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a read-only field?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are expression body definitions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a default constructor and what is a static constructor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are auto-implemented properties?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are indexers and how are they defined?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a static class and what can it contain?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the parameter specifiers and how do they differ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are enumerations and when are they useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
