- en: '*Chapter 12*: Debugging Your Programs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No program is perfect on the first try. In this chapter, we'll learn how to
    debug our programs using **GDB** and **Valgrind**. With the latter tool, Valgrind,
    we can find **memory leaks** in our programs.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also take a look at what memory leaks are, what they can cause, and how
    to prevent them. Debugging programs and looking at memory is an important step
    to understanding system programming fully.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting GDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stepping inside functions with GDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Investigating memory with GDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying variables during runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using GDB on a program that forks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging programs with multiple threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding a simple memory leak with Valgrind
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding buffer overflows with Valgrind
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you'll need the GBD tool, Valgrind, the GCC compiler, a generic
    Makefile, and the Make tool.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't installed GDB and Valgrind yet, you can do so now. Follow these
    instructions depending on your distributions. If you don't have `sudo` installed
    or don't have `sudo` privileges, you can switch to root using `su` instead (and
    leave out the `sudo` part).
  prefs: []
  type: TYPE_NORMAL
- en: 'For Debian and Ubuntu systems, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For CentOS, Fedora, and Red Hat systems, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: All the code samples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch12](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch12).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following link to see the Code in Action videos: [https://bit.ly/3rvAvqZ](https://bit.ly/3rvAvqZ)'
  prefs: []
  type: TYPE_NORMAL
- en: Starting GDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll learn the basics of **GDB**, the **GNU debugger**. We'll
    learn how to start GDB, how to set a breakpoint, and how to step forward in a
    program, one step at a time. We'll also learn what **debugging symbols** are and
    how we enable them.
  prefs: []
  type: TYPE_NORMAL
- en: GDB is the most popular debugger for Linux and other Unix-like systems. It allows
    you to examine—and change—variables on the fly, step through instructions one
    at a time, view the code as the program is running, read return values, and much
    more.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to use a debugger can save you many hours of frustration. Instead
    of guessing what the problem is with your program, you can follow the execution
    with GDB and spot the error. This can save you a lot of time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll need the GCC compiler, the Make tool, and the GDB tool.
    For installation instructions for GDB, see the *Technical requirements* section
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll use GDB on a working program. There are no bugs here.
    Instead, we want to focus on how to do some basic things in GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following small program in a file and save it as `loop.c`. Later,
    we will examine the program using GDB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can use GDB to its fullest, we need to enable `Makefile` in the same
    directory as the `loop.c` program. Notice we added the `-g` option to `CFLAGS`.
    These debugging symbols make it possible to see the code as we execute it in GDB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to compile the program using our new Makefile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try the program before we move on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'From the same directory as `loop` and `loop.c`, start GDB with the loop program
    by typing the following (the source code, `loop.c`, is needed to display the code
    within GBD):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You are now presented with some copyright text and version information. Down
    at the bottom, there''s a prompt saying `(gdb)`. This is where we type our commands.
    Let''s run the program and see what happens. We run the program by simply typing
    `run` and hitting *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'That didn''t really tell us much; we could have just run the program directly
    from the terminal. So, this time we set a `include` line. Instead, GDB automatically
    sets it on the first logical place where there is actual code. A breakpoint is
    where the execution should stop in the code so that we''ll have a chance to investigate
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can rerun the program. This time the execution will stop at line 6 (the
    breakpoint):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can start watching over the `y` variable using the `watch` command. GDB
    will then tell us every time `y` is updated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can execute the next statement in the code by using the `next` command.
    To avoid having to type `next` every time we want to move forward in the code,
    we can just hit *Enter*. Doing so will make GDB execute the last command. Notice
    the updated `y` variable. Also, notice that we see the code we are executing for
    every step we take:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The line of code being displayed is the next statement that is to be executed.
    So, from the previous step, we see that the next line to execute is line 10, which
    is `y = (y*3)-x`. So let''s hit *Enter* here, and that will update the `y` variable,
    and the **watchpoint** will tell us about it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we go any further, let''s examine the content of the `text` character
    array and the `x` variable. We print the content of variables and arrays with
    the `print` command. Here we see that the `text` array is filled with **null characters**
    after the actual text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s continue the execution. After the process has exited in the last step,
    we can exit GDB with `quit`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've just learned all the basics of GDB. With these commands, we can do a lot
    of debugging. There are a few more things to learn, but we've already come a long
    way.
  prefs: []
  type: TYPE_NORMAL
- en: We started the GDB program with the `loop` program. To prevent GDB from running
    through the entire program without investigating things, we set a breakpoint using
    the `break` command. In our example, we set the break on a line, using `break
    1`. It's also possible to set a breakpoint on a specific function, such as `main()`.
    We can do this with the `break main` command.
  prefs: []
  type: TYPE_NORMAL
- en: Once the breakpoint was in place, we could run the program with `run`. We then
    watched over the `y` variable with `watch`. We executed one statement at a time,
    using the `next` command. We also learned how to print variables and arrays using
    the `print` command.
  prefs: []
  type: TYPE_NORMAL
- en: For all of this to be possible, we had to compile the program with the `-g`
    option to GCC. That enables debugging symbols. But, to see the actual code in
    GDB, we also need the source code file.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GDB has some nice built-in help. Start GDB without a program. Then type `help`
    at the `(gdb)` prompt. This will give you a list of different classes of commands.
    If we want to read more about breakpoints, we type `help breakpoints`. This gives
    you a long list of breakpoint commands, for example, `break`. To read more about
    the `break` command, type `help break`.
  prefs: []
  type: TYPE_NORMAL
- en: Stepping inside a function with GDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we use the `next` command in a program with a function, it will simply
    execute the function and move on. However, there's another command called `step`
    that will enter the function, step through it, and then return to `main()` again.
    In this recipe, we'll examine the difference between `next` and `step`.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to step into a function with GDB will help you debug an entire program,
    including its functions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll need the GDB tool, the GCC compiler, the Makefile we
    wrote in the *Starting GDB* recipe in this chapter, and the Make tool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll write a small program that has a function. Then, we''ll
    step into that function with GDB, using the `step` command:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `area-of-circle.c`. The program
    takes the radius of a circle as an argument and prints its area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program using the Makefile from the *Starting GDB* recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try it out before stepping through it with GDB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to step through the program with GDB. Start GDB with the `area-of-circle`
    program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by setting a breakpoint at the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we run the program. To specify an argument to a program while inside GDB,
    we set the argument at the `run` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s move ahead one step with the `next` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the previous step, the next statement to execute will be
    the `atof()` function. This is a standard library function, so we don''t have
    any debugging symbols or source code for it. Therefore, we can''t see anything
    inside the function. However, we can still step inside it. Once we are inside
    the function, we can let it execute and finish using the `finish` command. This
    will tell us the function''s **return value**, which can be very handy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we do another `next`, which will take us to our `area` function. We want
    to step inside the `area` function, so we use `step` here. This will tell us that
    the value it was called with is 9\. Since there isn''t much left to do inside
    the area function but to return, we can type `finish` to get its return value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, we can walk through the rest of the program with `next`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the `step` command, we step inside a function. However, functions from
    the standard library don't have any debugging symbols or source code available;
    therefore, we can't see what's happening inside them. If we wanted to, we could
    get the source code and compile it with debugging symbols; Linux is, after all,
    open source.
  prefs: []
  type: TYPE_NORMAL
- en: But even when we don't see what's happening inside a function, it can still
    be valuable to step inside them since we can get their return value with `finish`.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating memory with GDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With GDB, we can learn more about how things work under the hood, for example,
    strings. A **string** is an array of characters terminated by a null character.
    In this recipe, we'll investigate a character array with GDB and see how the null
    character ends a string.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to examine the memory using GDB can be really handy if you encounter
    weird **bugs**. Instead of guessing or looping over each character in C, we can
    directly examine them in GDB.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll need the Makefile we wrote in the *Starting GDB* recipe.
    You'll also need the GCC compiler and the Make tool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll write a simple program that fills a character array
    with the character *x*. Then we''ll copy a new, shorter string on top of that
    and finally print the string. It''s only the newly copied string that is printed,
    even if all the *x* characters are still there. With GDB, we can confirm this
    fact:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `memtest.c`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program using the Makefile from the *Starting GDB* recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run it as we would with any other program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start GDB with our `memtest` program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s examine what''s really inside the `text` array using GDB. First,
    we set a breakpoint on `main()`, then we run the program and step forward in the
    program with `next` until after the `strcpy()` function has been executed. Then,
    we examine the `x` command in GDB (`x` for eXamine). We must also tell GDB to
    examine 20 bytes and print the content using decimal notation. The `x` command
    will therefore be `x/20bd text`. To interpret the decimals to characters, see
    the ASCII table we talked about in [*Chapter 2*](B13043_02_Final_SK_ePub.xhtml#_idTextAnchor050),
    *Making Your Programs Easy to Script,* at [https://github.com/PacktPublishing/B13043-Linux-System-Programming-Cookbook/blob/master/ch2/ascii-table.md](https://github.com/PacktPublishing/B13043-Linux-System-Programming-Cookbook/blob/master/ch2/ascii-table.md):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To examine the memory using GDB, we used the `x` command. `20bd` says the size
    we want to read is 20, and we want to present it in groups of bytes (the `b`)
    and print the content using decimal notation (the `d`). With this command, we
    get a nice-looking table that shows us every character in the array printed as
    a decimal number.
  prefs: []
  type: TYPE_NORMAL
- en: The content of the memory—when translated to characters—is `Hello\0xxxxxxxxxxxxxx`.
    The null character separates the *Hello* string from all the *x* characters. There's
    a lot to learn by using GDB and examining the memory during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of just printing the content as decimal notation, it's also possible
    to print as regular characters (`c`), hexadecimal notation (`x`), floating points
    (`f`), and so on. These letters are the same as for `printf()`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can learn more about how to use the `x` command by typing `help x` while
    inside GDB.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying variables during runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With GDB it's even possible to modify variables during runtime. This can be
    very handy for experimentation. Instead of changing the source code and recompiling
    the program, you can change the variable with GDB and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to change variables and arrays during runtime can speed up your
    debugging and experimentation phase.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll need the `memtest.c` program from the previous recipe.
    You'll also need the Makefile from the *Starting GDB* recipe in this chapter,
    the Make tool, and the GCC compiler.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll continue using the program from the previous recipe.
    Here, we''ll replace the **null character** in the sixth place with another character
    and the last character with a null character:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t yet compiled the `memtest` program from the previous recipe,
    do so now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Start GDB with the `memtest` program you just compiled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Start by setting a breakpoint at `main()` and run the program. Step forward
    to just after the `strcpy()` function using `next`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Before changing the array, let''s print it first using the `x` command like
    in the previous recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know what the content looks like, we can replace the null character
    at the sixth position—the fifth actually, we start counting from 0—with a `y`.
    We also replace the last position with a null character. Setting `set` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s continue running the rest of the program. Instead of stepping forward
    with the `next` command one step at a time, we can use the `continue` command
    to let the program run until the end. Notice that the `printf()` function will
    now print the string `Helloyxxxxxxxxxxxxxx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the `set` command in GDB, we managed to change the content of the `text`
    array during runtime. With the `set` command, we removed the first null character
    and inserted a new one at the end, making it a long valid string. Since we had
    removed the null character after *Hello*, `printf()` then printed the entire string.
  prefs: []
  type: TYPE_NORMAL
- en: Using GDB on a program that forks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using GDB to debug a program that **forks** will automatically follow the **parent
    process**, just like a regular non-forking program. But it's possible to follow
    the **child process** instead, which is what we will learn in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to follow the child process is important in debugging since many
    programs spawn child processes. We don't want to limit ourselves to only non-forking
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll need the Makefile from the *Starting GDB* recipe in
    this chapter, the Make tool, and the GCC compiler.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll write a small program that forks. We''ll put a `for`
    loop inside the child to confirm whether we are inside the child or the parent.
    On the first run in GDB, we''ll run through the program like we usually would.
    This will make GDB follow the parent process. Then, in the next run, we''ll follow
    the child process instead:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `forking.c`. The code is
    similar to the `forkdemo.c` program we wrote in [*Chapter 6*](B13043_06_Final_SK_ePub.xhtml#_idTextAnchor245),
    *Spawning Processes and Using Job Control*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try the program before we run it in GDB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'On the first run through GDB, we''ll run it like we usually would. This will
    make GDB follow the parent process automatically. Begin with starting GDB with
    the `forking` program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the breakpoint at `main()` as usual and run it. Then, we''ll step forward
    with the next command until we see the *Counter in child* text. That will prove
    that we are indeed in the parent process since we never stepped through the `for`
    loop. Also, notice that GDB tells us that the program has forked and detached
    from the child process (meaning we are in the parent process). GDB also prints
    the PID of the child process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run through the program again. But this time, we will tell GDB
    to follow the child process instead. Start GDB with the `forking` program as before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the breakpoint at `main()` as we did before. After that, we tell GDB to
    follow the child process using the `set` command as we''ve seen before. Only this
    time, we set something called `follow-fork-mode`. We set it to `child`. Then run
    the program as usual:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, move forward one step at a time with the `next` command twice. The program
    will now fork, and GDB will tell us that it''s attaching to the child process
    and detaching from the parent process. This means that we are now inside the child
    process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s move forward a bit again to see that we end up inside the `for` loop,
    which is inside the child process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With `set follow-fork-mode`, we can tell GDB which process to follow when the
    program forks. This is handy for debugging daemons that fork. You can set `follow-fork-mode`
    to either `parent` or `child`. The default is `parent`. The process that we don't
    follow will continue to run as usual.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's also `follow-exec-mode`, which tells GDB which process to follow if
    the program calls an `exec()` function.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about `follow-exec-mode` and `follow-fork-mode`, you can
    use the `help set follow-exec-mode` and `help set follow-fork-mode` commands inside
    GDB.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging programs with multiple threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's possible to view threads in a program using GBD and also to jump between
    **threads**. Knowing how to jump between the threads in a program will make threaded
    programs easier to debug. Writing threaded programs can be hard, but with GDB
    it's easier to make sure they are working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we'll use the `first-threaded.c` program from [*Chapter 11*](B13043_11_Final_SK_ePub.xhtml#_idTextAnchor460),
    *Using Threads in Your Programs*. There's a copy of the source code in this chapter's
    GitHub directory.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also need the GCC compiler.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll look at the threads from the `first-threaded.c` program
    using GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by compiling the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we run the program through the debugger, let''s first run it to recap
    how the program works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know how the programs works, let''s start it up in GDB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s set a breakpoint at `main()` as we have done previously. Then we run
    it with the same two numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we move forward using the `next` command. Once a thread has started, GDB
    will notify us with the text *New thread*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can print information about the current threads using the `info threads`
    command. Notice that this will also tell us what function the threads are currently
    executing. The number before the word *Thread* on each line is GDB''s thread ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s switch over to thread number 3, which is currently executing the
    `isprime` function. We switch threads with the `thread` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'While inside the thread, we can print the content of variables, move forward
    using the `next` command, and so on. Here we also see that the other thread is
    starting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like we could follow a child process, we can follow a thread. It's a bit
    of a different approach with threads, but still. Once each thread started, GDB
    notified us about it. We could then print information about the currently running
    threads using the `info threads` command. That command gave us a thread ID for
    each thread, its address, and what frame or function it was currently on. We then
    jumped to thread 3 using the `thread` command. Once we were inside the thread,
    we could print the content of the `number` and `j` variables, move forward in
    the code, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are more things you could do with threads in GDB. To find more commands
    regarding threads, you can use the following commands inside GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '`help thread`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`help info threads`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a lot of information about GDB at [https://www.gnu.org/software/gdb](https://www.gnu.org/software/gdb),
    so check it out for more in-depth information.
  prefs: []
  type: TYPE_NORMAL
- en: Finding a simple memory leak with Valgrind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Valgrind** is a neat program for finding **memory leaks** and other memory-related
    bugs. It can even tell you if you put too much data inside an allocated memory
    area. These can all be hard bugs to find without a tool like Valgrind. Even if
    a program leaks memory or puts too much data in a memory area, it can still run
    fine for a long time. That''s what makes those bugs so hard to find. But with
    Valgrind, we can check the program for all sorts of memory-related problems.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll need the Valgrind tool installed on your computer. If
    you haven't already installed it, you can follow the instructions listed in the
    *Technical requirements* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also need the Make tool, the GCC compiler, and the Makefile from the
    *Starting GDB* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll write a program that allocates memory using `calloc()`
    but never frees it with `free()`. We then run the program through Valgrind and
    see what it says about it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following program and save it as `leak.c`. First, we create a pointer
    to a character. Then we allocate 20 bytes of memory using `calloc()` and return
    its address to `c`. Then we copy a string into that memory and print the content
    using `printf()`. However, we never free the memory using `free()`, which we always
    should:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we run the program as we normally would. Everything works just fine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we run the program through Valgrind. Under `HEAP SUMMARY`, it will tell
    us that there are 20 bytes still allocated when the program exits. Under `LEAK
    SUMMARY`, we also see that there are 20 bytes *definitely lost*. What this means
    is that we forgot to free the memory using `free()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Open up `leak.c` and add `free(c);` just before `return 0;`. Then, recompile
    the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rerun the program in Valgrind. This time, there won''t be any bytes lost or
    in use when the program exits. We also see that there have been two allocations,
    and they were both freed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The reason Valgrind said we had two allocations even though we only allocated
    one block of memory is that other functions in the program have allocated memory.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the output from Valgrind, we also saw the text *All heap blocks
    were freed*, meaning we have freed all memory using `free()`.
  prefs: []
  type: TYPE_NORMAL
- en: Valgrind doesn't strictly require debugging symbols; we can test just about
    any program for memory leaks. For example, we can run `valgrind cat leak.c`, and
    Valgrind will check `cat` for memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a lot more you can do with Valgrind. Check out its manual page with
    `man valgrind`. There's also a lot of useful information at [https://www.valgrind.org](https://www.valgrind.org).
  prefs: []
  type: TYPE_NORMAL
- en: Finding buffer overflows with Valgrind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Valgrind can also help us find **buffer overflows**. That is when we put more
    data in a buffer than it can hold. Buffer overflows are the cause of many security
    bugs and are hard to detect. But with Valgrind, it gets a little easier. It might
    not be 100% accurate at all times, but it's a really good help along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to find buffer overflows will make your program more secure.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll need the GCC compiler, the Make tool, and the Makefile
    from the *Starting GDB* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll write a small program that copies too much data into
    a buffer. We''ll then run the program through Valgrind and see how it points out
    the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `overflow.c`. The program
    allocates 20 bytes with `calloc()`, then copies a string of 26 bytes into that
    buffer. It then frees up the memory using `free()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we run the program like we normally would. Most likely, we won''t see
    any problems with it. It will just work. That''s why these kinds of bugs are so
    hard to find:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run the program through Valgrind and see what it has to say about
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the program writes data outside of the allocated memory, Valgrind will
    detect it as invalid writes and invalid reads. We can even follow how many bytes
    are written after the allocated memory and its addresses. This will make it even
    easier to find the problem in the code. We might have allocated several buffers,
    but here we clearly see that it's the buffer of 20 bytes that's overflowed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a more detailed output, you can add `-v` to Valgrind, for example, `valgrind
    -v ./overflow`. This will output several pages of detailed output.
  prefs: []
  type: TYPE_NORMAL
