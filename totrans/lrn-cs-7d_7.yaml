- en: Day 07 - Understanding Object-Oriented Programming with C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today we are on day seven of our seven-day learning series. Yesterday (day six),
    we went through a few advanced topics and we discussed attributes, generics, and
    LINQ. Today, we will start learning **object-oriented programming** (**OOP**)
    using C#.
  prefs: []
  type: TYPE_NORMAL
- en: This will be a practical approach to OOP, while covering all the aspects. You
    will benefit even without having any basic knowledge of OOP and move on to confidently
    practicing this easily in the workplace.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing object relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OOP is one of the programming paradigms that is purely based on objects. These
    objects contain data (please refer to day sevenÂ for more details).
  prefs: []
  type: TYPE_NORMAL
- en: When we do the classification of programming languages it is called programming
    paradigm. For more information refer to [https://en.wikipedia.org/wiki/Programming_paradigm](https://en.wikipedia.org/wiki/Programming_paradigm).
  prefs: []
  type: TYPE_NORMAL
- en: OOP has come into consideration to overcome the limitations of earlier programming
    approaches (consider the procedural language approach).
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, I define OOP as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A modern programming language in which we use objects as building blocks to
    develop applications.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of examples of objects in our surroundings and in the real
    world, we have various aspects that are the representation of objects. Let us
    go back to our programming world and think about a program that is defined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A program is a list of instructions that instructs the language compiler on
    what to do.*'
  prefs: []
  type: TYPE_NORMAL
- en: To understand OOP more closely, we should know about earlier programming approaches,
    mainly procedural programming, structured programming, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Structured programming**: This is a term coined by Edsger W. Dijkstra in
    1966\. Structured programming is a programming paradigm that solves a problem
    to handle 1000 lines of code and divides these into small parts. These small parts
    are mostly called subroutine, block structures, `for` and `while` loops, and so
    on. Known languages that use structured programming techniques are ALGOL, Pascal,
    PL/I, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Procedural programming**: A paradigm derived from structured programming
    and simply based on how we make a call (known as a procedural call). Known languages
    that use procedural programming techniques are COBOL, Pascal, C. A recent example
    of the Go programming language was published in 2009.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main problem with these two approaches is that programs are not well manageable
    once they grow. Programs with more complex and large code bases make these two
    approaches strained. In short, the maintainability of the code is tedious with
    the use of these two approaches. To overcome such problems now, we have OOP, which
    has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing Object relations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start our discussion on OOP, first we should understand relationships.
    In the real world, objects have relationships between them and hierarchies as
    well. There are the following types of relationships in object-oriented programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Association**: Association represents a relationship between objects in a
    manner that all objects have their own life cycle. In association, there is no
    owner of these objects. For example, a person in a meeting. Here, the person and
    the meeting are independent; there is no parent of them. A person can have multiple
    meetings and a meeting can combine multiple persons. The meeting and persons are
    both independently initialized and destroyed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregation and composition are both types of association.
  prefs: []
  type: TYPE_NORMAL
- en: '**Aggregation**: Aggregation is a specialized form of association. Similar
    to association, objects have their own life cycle in aggregations, but it involves
    ownership that means a child object cannot belong to another parent object. Aggregation
    is a one-way relationship where the lives of objects are independent from each
    other. For example, the child and parent relationship is an aggregation, because
    every child has parent but it''s not necessary that every parent has child.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composition**: Composition is a relationship of *death* that represents the
    relationship between two objects and one object (child) depends on another object
    (parent). If the parent object is deleted, all its children automatically get
    deleted. For example, a house and a room. One house has multiple rooms. But a
    single room cannot belong to multiple houses. If we demolished the house, the
    room would automatically delete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the coming sections, we will discuss all features of OOP in detail. Also,
    we will understand implementing these features using C#.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance is one of the most important features/concepts of OOP. It is self-explanatory
    in name; inheritance inherits features from a class. In simple words, inheritance
    is an activity performed at compile-time as instructed with the help of the syntax.
    The class that inherits another class is known as the child or derived class,
    and the class which is being inherited is known as the base or parent class. Here,
    derived classes inherit all the features of base classes either to implement or
    to override.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming sections, we will discuss inheritance in detail with code examples
    using C#.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance as a feature of OOP helps you to define a child class. This child
    class inherits the behavior of the parent or base class.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting a class means reusing the class. In C#, inheritance is symbolically
    defined using the colon (*:*) sign.
  prefs: []
  type: TYPE_NORMAL
- en: 'The modifier (refer to [Chapter 2](part0032.html#UGI00-cd07d0bec7404d1cb3fdb41e48e5618f),
    *Day 02 - Getting Started with C#*) tells us what the scope of the reuse of the
    base class for derived classes is. For instance, consider that class *B* inherits
    class *A.* Here, class *B* contains all the features of class *A* including its
    own features. Refer the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00102.gif)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding figure, the derived class (that is, *B*) inherits all the features
    by ignoring modifiers. Features are inherited whether these are public or private.
    These modifiers come in to consideration when these features are going to be implemented.
    At the time of implementation only public features are considered. So, here, public
    features, that is, *A*, *B*, and *C* will be implemented but private features,
    that is, *B,* will not be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Types of inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up until this point, we have got the idea about inheritance. Now, it''s time
    to discuss inheritance types; inheritance is of the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single inheritance:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a widely used type of inheritance. Single inheritance is when a class
    inherits another class. A class that inherits another class is called a child
    class and the class which is being inherited is called a parent or base class.
    In the child class, the class inherits features from one parent class only.
  prefs: []
  type: TYPE_NORMAL
- en: C# only supports single inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can inherit classes hierarchically (as we will see in the following section),
    but that is a single inheritance in nature for a derived class. Refer the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00103.gif)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram is a representation of a single inheritance that shows
    *Class B* (inherited class) inheriting *Class A* (base class). *Class B* can reuse
    all features that is, *A*, *B*, and *C,* including its own feature, that is, D.
    Visibility or reusability of members in inheritance depends on the protection
    levels (this will be discussed in the coming section, *Member visibility in inheritance*).
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiple inheritance:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiple inheritance happens when a derived class inherits multiple base classes.
    Languages such as C++ support multiple inheritance. C# does not support multiple
    inheritance, but we can achieve multiple inheritance with the help of interfaces.
    If you are curious to know that why C# does not support multiple inheritance,
    refer to this official link at [https://blogs.msdn.microsoft.com/csharpfaq/2004/03/07/why-doesnt-c-support-multiple-inheritance/](https://blogs.msdn.microsoft.com/csharpfaq/2004/03/07/why-doesnt-c-support-multiple-inheritance/).
    Refer to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00104.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram is a representation of multiple inheritance (not possible
    in C# without the help of interfaces), which shows that *Class C* (derived class)
    inherits from two base classes (*A* and *B*). In multiple inheritance, the derived
    *Class C* will have all the features of both *Class A* and *Class B*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hierarchical inheritance:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hierarchical inheritance happens when more than one class inherits from one
    class. Refer to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00105.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, *Class B* (derived class) and *Class C* (derived class)
    inherit from *Class A* (base class). With the help of hierarchical inheritance,
    *Class B* can use all the features of *Class A*. Similarly, *Class C* can also
    use all the features of *Class A*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Multilevel inheritance:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a class is derived from a class that is already a derived class, it is
    called multilevel inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: In multi-level inheritance, the recently derived class owns the features of
    all the earlier derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this, a derived class can have its parent and a parent of the parent class.
    Refer to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00106.gif)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram represents multilevel inheritance and shows that *Class
    C* (recently derived class) can reuse all the features of *Class B* and *Class
    A*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hybrid inheritance:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hybrid inheritance is a combination of more than one inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: C# does not support hybrid inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Combination of multiple and multilevel inheritance is a hierarchical inheritance,
    where a parent class is a derived class and a recently derived class inherits
    multiple parent classes. There can be more combinations. Refer to the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00107.gif)'
  prefs: []
  type: TYPE_IMG
- en: The preceding image, representing hybrid inheritance, shows the combination
    hierarchical and multiple inheritance. You can see that *Class A* is a parent
    class and all the other classes are derived from *Class A,* directly or indirectly.
    Our derived *Class E* can reuse all the features of Class *A*, *B*, *C,* and *D*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicit inheritance:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the types in .NET implicitly inherit from `system.object` or its derived
    classes. For more information on implicit inheritance, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/inheritance#implicit-inheritance](https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/inheritance#implicit-inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: Member visibility in inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed earlier, in inheritance, derived classes can reuse the functionality
    of the parent class and use or modify the members of its parent class. But these
    members can be reused or modified as per their access modifier or visibility (for
    more details refer to [Chapter 4](part0119.html#3HFIU0-cd07d0bec7404d1cb3fdb41e48e5618f),
    *Day 04 - Discussing C# Class Members*).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will briefly discuss member visibility in inheritance.
    In any type of inheritance (that is possible in C# language) the following members
    cannot be inherited by base classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static constructors**: A static constructor is one that initializes the static
    data (refer to the *Modifier* section of [Chapter 4](part0119.html#3HFIU0-cd07d0bec7404d1cb3fdb41e48e5618f),
    *Day 04: Discussing C# Class Members*). The importance of static constructors
    is that these are called before the creation of the first instance of a class
    or any other static members called or referred to in some operations. Being a
    static data initializer, a static constructor cannot be inherited by a derived
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instance constructor**: It is not a static constructor; whenever you create
    a new instance of a class, a constructor is called, which is the instance class.
    A class can have multiple constructors. As the instance constructor is used to
    create an instance of a class, it is not inherited by the derived class. For more
    information on constructors, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Finalizers**: These are just destructors of classes. These are used or called
    by garbage collectors at runtime to destroy the instances of a class. As finalizers
    are called only once and are per class, these cannot be inherited by a derived
    class. For more information on destructors or finalizers, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/destructors](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/destructors).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Derived classes can reuse or inherit all the members of the base class, but
    their usage or visibility depends upon their access modifiers (refer to [Chapter
    4](part0119.html#3HFIU0-cd07d0bec7404d1cb3fdb41e48e5618f), *Day 04 - Discussing
    C# Class Members*). Different visibility of these members depends upon the following
    accessibility modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Private**: If a member is `private`, the visibility of a `private` member
    is restricted to its derived class; `private` members are available in derived
    classes if the derived class nests to its base class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00108.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding image shows the visibility of a private method for a derived class.
    The private method is visible in the derived class if the class is nested within
    its base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the class is not nested within its parent/base class, then you can see the
    following compile-time exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00109.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we have `ChildClass`, which inherits from `BaseClass`.
    Here, we cannot use private members of `BaseClass` as `ChildClass` is not nested
    within `BaseClass`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Protected**: If a member is a protected modifier, it is only visible to the
    derived class. These members will not be available or visible while you''re using
    the using the instance of a base class, because these are defined as protected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot depicts how a protected member can be accessible/visible
    using the base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00110.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, the protected member, `EditorName` is visible in
    `ChildClass` because it inherits `BaseClass`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows that the protected members are not accessible
    using the instance of `BaseClass` in `ChildClass`. If you try to do so, you will
    get a compile-time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00111.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Internal**: Members with internal modifiers are only available in the derived
    classes of the same assembly as of the base class. These members can''t be available
    for derived classes that belong to other assemblies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following code-snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows the visibility of an internal member. Here, `ChildClass`
    belongs to the `Lib` assembly, which is where `BaseClass` exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if `BaseClass` exists in an assembly other than `Lib`, then
    internal members will not accessible; see the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00112.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows a compile-time error that tells that the internal
    members are inaccessible, as they are not available in the same assembly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Public**: Public members are available or visible in derived classes and
    can be used further.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following code-snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00113.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous code, you should notice that we added a `new` keyword with
    the `Display()` method of the `ChildClassYounger` class. This is because we have
    a method with the same name in the parent class (that is, `ChildClass`). If we
    don''t add the `new` keyword, we''ll see a compile-time warning, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00114.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: By applying the `new` keyword, you hide the `ChildClass.Display()` member that
    is inherited from `ChildClass`. In C#, this concept is called method hiding.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you learned about inheritance in detail and went through
    its various types. You also learned inherited member's visibility. In this section,
    we will implement inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inheritance is representation of an **IS-A** relation, which suggests that
    `Author` **IS-A** `Person` and `Person` **IS-A** `Human`, so `Author` **IS-A**
    `Human`. Let''s understand this in a code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have a base class, `Person` and three derived classes,
    namely `Author`, `Editor`, and `Reviewer`. This shows single inheritance. The
    following is the implementation of the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we instantiated a single class and called details; each
    class inherits the `Person` class and, hence, all its members. This produces the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00115.gif)'
  prefs: []
  type: TYPE_IMG
- en: Implementing multiple inheritance in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already discussed in the previous section that C# does not support multiple
    inheritance. But we can achieve multiple inheritance with the help of interfaces
    (refer to [Chapter 2](part0032.html#UGI00-cd07d0bec7404d1cb3fdb41e48e5618f), *Day
    02 â Getting Started with C#*). In this section, we will implement multiple inheritance
    using C#.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider the code snippet of the previous section, which implements single
    inheritance. Let's rewrite the code by implementing interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces represent **Has-A**/**Can-Do** relationship, which indicates that
    `Publisher` **Has-A** `Author` and `Author` **Has-A** `Book`. In C#, you can assign
    an instance of a class to any variable that is of the type of the interface or
    the base class. In view of OOP, this concept is referred to as polymorphism (refer
    to the *Polymorphism* section for more details).
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s create an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s implement the `IBook` interface to derive the `Author` class, which
    inherits the `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00116.gif)'
  prefs: []
  type: TYPE_IMG
- en: The preceding image shows the output of the implemented code using interfaces.
    All the members of the interface are accessible to the child class; there is no
    need for special implementation when you are instantiating a child class. The
    instance of a child class is able to access all the visible members. The important
    point in the preceding implementation is in the `((IBook)author).Detail();` statement,
    where we explicitly cast the instance of child class to the interface to get the
    implementation of the interface member. By default, it provides the implementation
    of a class member, so we need explicitly tell the compiler that we need an interface
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Abstraction is the process where relevant data is shown by hiding irrelevant
    or unnecessary information. For example, if you purchase a mobile phone, you'd
    not be interested in the process of how your message is delivered or how your
    call connects another number, but you'd be interested to know that whenever you
    press the call button on your phone, it should connect your call. In this example,
    we hide those features that do not interest the user and provide those features
    that interest the user. This process is called abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C#, abstraction can be implemented with the use of:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Abstract class is half-defined that means it provides a way to override members
    to its child classes. We should use base classes in the project where we need
    have a need same member to all its child classes with own implementations or want
    to override. For an example if we have an abstract class Car with an abstract
    method color and have child classes HondCar, FordCar, MarutiCar etc. in this case
    all child classes would have color member but with different implementation because
    color method would be overridden in the child classes with their own implementations.
    The point to be noted here - abstract classes represent IS-A relation.
  prefs: []
  type: TYPE_NORMAL
- en: You can also revisit our discussion of abstract class during Day04 section 'abstract'
    and code-examples to understand the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Features of abstract class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In previous section we learned about abstract classes, here are the few features
    of abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract class can't be initialized that means, you cannot create an object
    of abstract class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract class is meant to act as a base class so, other classes can inherit
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you declared an abstract class then by design it must be inherited by other
    classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An abstract class can have both concrete or abstract methods. Abstrcat methods
    should be implemented in the child class that inherited abstract class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An interface does not contain functionality or concrete members. You can call
    this is a contract for the class or structure that will implement to define the
    signatures of the functionality. With the use of interface, you make sure that
    whenever a class or struct implement it that class or struct is going to use the
    contract of the interface. For an instance if ICalculator interface has method
    Add() that means whenever a class or structure implement this interface it provides
    a specific contractual functionality that is addition.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on interface, refer: [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/index](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/index)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interface can only have these members:'
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Features of interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Followings are the main features of interfaces
  prefs: []
  type: TYPE_NORMAL
- en: Interface is internal by default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All member of interface is public by default and there is no need to explicitly
    apply public modifier to the members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, to abstract class, interface also cannot be instantiated. They can
    only implement and the class or structure that implement it should implement all
    the members.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface cannot contain any concrete method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interface can be implemented by another interface, a class or struct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class or struct can implement multiple interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class can inherit abstract class or a normal class and implement an interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will implement abstraction using abstract class. Let''s
    consider following code-snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Above code-snippet contains only one public method that is responsible to display
    the operations. Display() method is one that gets the details of author , editor
    and reviewer of a book. At first glance, we can say that above code is with different
    classes of different implementation. But, actually we are abstracting our code
    with the help of abstract class, the child or derived classes then providing the
    details whatever the demand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We have an abstract class Team with an abstract method GetDetail() this is
    the method that is responsible to get the details of team. Now, think what this
    team include, this team build with Author, Editor and a Reviewer. So, we have
    following code-snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: BookAuthor class inherits Team and override the GetDetail() method. This method
    further call a private method Display() that is something user would not be aware.
    As user will call only GetDetail() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In similar way, we have BookEditor and BookReviewer classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, classes will only reveal one method, that is, `GetDetail()`
    to provide the required details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following will be the output when this code will be called from the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00117.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encapsulation is a process where data is not directly accessible to user. When
    you want to restrict or hide the direct access to data from client or user, that
    activity or a process is known as encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: When we say information hiding that means hiding an information that doesn't
    require for user or user is not interested in the information for example - when
    you buy a bike you'd not be interested to know how it's engine works, how fuel
    supply exists internally, but you're interested about the mileage of bike and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Information hiding is not a data hiding but it is an implementation hiding
    in C# for more information refer: [http://blog.ploeh.dk/2012/11/27/Encapsulationofproperties/](http://blog.ploeh.dk/2012/11/27/Encapsulationofproperties/).'
  prefs: []
  type: TYPE_NORMAL
- en: In C# when functions and data combined in a single unit (called class) and you
    cannot access the data directly is called encapsulation. In C# class, access modifiers
    are applied to members, properties to avoid the direct access of data to other
    cases or users.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss about encapsulation in detail.
  prefs: []
  type: TYPE_NORMAL
- en: What are access modifier in C#?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in previous section, encapsulation is a concept of hiding information
    from the outer world. In C#, we have access modifier or access specifiers that
    helps us to hide the information. These access modifiers help you to define the
    scope and visibility of a class member.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the access modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: Public
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protected internal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have already gone through all the preceding access modifiers during day four.
    Please refer to section *Access modifier* and their accessibility to revise how
    these modifier works and help us to define the visibility.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will implement encapsulation in C# 7.0\. Think a scenario
    where we need to provide the information of an `Author` including recent published
    book. Consider following code-snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code-snippet that is showing the implementation of encapsulation,
    we are hiding our fields that user would not want to know. As the main motto is
    to show the recent publication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the code for client, that need the information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code-snippet is to get the required information only. User would
    not be aware of how the information is fetching/retrieving from class.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00118.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding image is showing the exact output, you will see after execution
    of previous code.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In simple words, polymorphism means having many forms. In C#, we can express
    one interface with multiple functions as polymorphism. Polymorphism is taken from
    Greek-word that has meaning of *many-shapes*.
  prefs: []
  type: TYPE_NORMAL
- en: All types in C# (including user-defined types) inherit from object hence every
    type in C# is polymorphic.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed polymorphism means many forms. These forms can be of functions
    where we implement function of same name having same parameters in different forms
    in derived classes. Also, polymorphism is having the capability to provide different
    implementation of methods that are implemented with same name.
  prefs: []
  type: TYPE_NORMAL
- en: In coming sections, we will discuss the various types of polymorphism including
    their implementation using C# 7.0.
  prefs: []
  type: TYPE_NORMAL
- en: Types of polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C#, we have two types of polymorphism and these types are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compile-time polymorphism**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Compile-time polymorphism is also famous as early binding or overloading or
    static binding. It determines at compile-time and meant for same function name
    with different parameters. Compile-time or early binding is further divided into
    two more types and these types are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Function Overloading**'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Function overloading as name is self-explanatory function is overloaded. When
    you declare function with same name but different parameters, it is called as
    function overloading. You can declare as many overloaded functions as you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider following code-snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is a representation of overloading, `Math` class is having
    a method `Add()` with an overload the parameters of type double. These methods
    in meant to separate behaviour. Consider following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet is using both the methods. Following is the output
    of the preceding implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00119.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you analyse previous result you will find the overloaded method that accepts
    double parameters provides accurate results that is, 99 because we supplied decimal
    values and it adds decimals. On the other had `Add` method with integer type parameter,
    apply round of to double and convert them into integer so, it displays the wrong
    result. However previous example is not related to correct calculations but this
    tells about the compile-time polymorphism using function overloading.
  prefs: []
  type: TYPE_NORMAL
- en: '**Operator Overloading**'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator loading is a way to redefine the actual functionality of a particular
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is important while you're working with user-defined complex types where
    direct use of in-built operators is impossible.
  prefs: []
  type: TYPE_NORMAL
- en: We have already discussed operator overloading in details during [Chapter 2](part0032.html#UGI00-cd07d0bec7404d1cb3fdb41e48e5618f),
    *Day 02 â Getting Started with C#* section - *Operator Overloading* - refer to
    this section if you want to revise operator overloading.
  prefs: []
  type: TYPE_NORMAL
- en: Run-time polimorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run-time polymorphism is also famous as late binding or overriding or dynamic
    binding. We can achieve run-time polymorphism by overriding methods in C#. The
    virtual or abstract methods can be overridden in derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: In C# abstract classes provide a way to implement run-time polymorphism where
    we override abstract methods in derived classes. The `virtual` keyword is also
    a way to override method in derive class. We discussed `virtual` keyword during
    [Chapter 2](part0032.html#UGI00-cd07d0bec7404d1cb3fdb41e48e5618f), *Day 02 â Getting
    Started with C#* (refer if you want to revise it).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00120.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding image is showing output of a program example implementing of abstract
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also implement run-time polymorphism using abstract class and virtual
    methods, consider following code-snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00121.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our method `ShowDetail()` displays the member name of a particular type.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s implement polymorphism in a complete, consider the following code-snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code-snippet is a representation of polymorphism, that is building
    different teams. It produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00122.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding image is showing results from a program that represents the implementation
    of polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Hands on Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the unsolved questions from today''s study:'
  prefs: []
  type: TYPE_NORMAL
- en: What is OOP?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why we should use OOP language over procedural language?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define inheritance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many type of inheritance is available in general?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why we can't implement multiple inheritance in C#?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How we can achieve multiple inheritance in C#.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define inherited member visibility with the help of a short program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define hiding and elaborate with the help of a short program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is overriding?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When to use hiding and when to use overriding, elaborate with the help of a
    short program (hint: refer to - [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords))'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is implicit inheritance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between abstract class and interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is encapsulation, elaborate it with the help of a short program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define access modifiers or access specifiers that are helpful in encapsulation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is abstraction? Elaborate it with a real-world example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What is the difference between encapsulation and abstraction with the help
    of a real-world example. (hint: [https://stackoverflow.com/questions/16014290/simple-way-to-understand-encapsulation-and-abstraction](https://stackoverflow.com/questions/16014290/simple-way-to-understand-encapsulation-and-abstraction))'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When to use abstract class and interface elaborate with the help of short program.
    (hint: [https://dzone.com/articles/when-to-use-abstract-class-and-intreface](https://dzone.com/articles/when-to-use-abstract-class-and-intreface))'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What is the difference between abstract and virtual functions? (hint: [https://stackoverflow.com/questions/391483/what-is-the-difference-between-an-abstract-function-and-a-virtual-function](https://stackoverflow.com/questions/391483/what-is-the-difference-between-an-abstract-function-and-a-virtual-function))'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define polymorphism in C#?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many types of polymorphism, implement using a short program using C# 7.0?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define late binding and early binding with the use of real world example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prove this with the help of a program - In C# every type is a polymorphic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between overloading and overriding?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Revisiting Day 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we are at the stage where we conclude the final day that is, day seven
    of our 7-days learning series. Today, we have gone through concepts of OOP paradigm
    where we started with object relationship and get an overview of association,
    aggregation and composition and then we discussed structural and procedural language.
    We discussed all four features that is, encapsulation, abstraction, inheritance,
    and polymorphism of OOP. We also implemented OOP concepts using C# 7.0.
  prefs: []
  type: TYPE_NORMAL
- en: Tomorrow, on day eight we will be starting a real-world application that will
    help us to revise all our concepts till today. If you want to revise now, please
    go ahead and take a look in previous day's learning.
  prefs: []
  type: TYPE_NORMAL
- en: What next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Today we concluded our 7^(th) days of 7-days learning series. During this journey,
    we have started with very basic and then gradually adapted the advanced terms
    but this is just a beginning there are more to grab. I tried to combine almost
    all things here for next step, I suggest you should learn these:'
  prefs: []
  type: TYPE_NORMAL
- en: Multi- threading
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Constructor chaining
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Indexers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extension methods
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Advanced regular expression
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Advanced unsafe code implementation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Advanced concepts of garbage collection
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For more advance topics, please refer to following:'
  prefs: []
  type: TYPE_NORMAL
- en: C# 7.0 and .NET Core Cookbook ([https://www.packtpub.com/application-development/c-7-and-net-core-cookbook](https://www.packtpub.com/application-development/c-7-and-net-core-cookbook))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[http://questpond.over-blog.com/](http://questpond.over-blog.com/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Functional C# ([https://www.packtpub.com/application-development/functional-c](https://www.packtpub.com/application-development/functional-c))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multithreading with C# Cookbook - Second Edition ([https://www.packtpub.com/application-development/multithreading-c-cookbook-second-edition](https://www.packtpub.com/application-development/multithreading-c-cookbook-second-edition))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
