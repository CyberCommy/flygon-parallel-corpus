- en: Chapter 7. Becoming a Master – A Complete Configuration Guide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By the time you reach this chapter, you will have had already gone through all
    the concepts that are in the scope of this book. This chapter will build upon
    everything learned from the previous chapters, use some basics, and present you
    with real-life use cases where Ansible can come in handy. The chapter will show
    you how you can use Ansible to solve simple, as well as complex, problems and
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: One playbook, different applications, multiple targets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might come across scenarios where different environments need different
    settings or deployment steps, for example, deploying to different environments
    such as Development, QA, Stage, or Production. There might be small changes in
    the deployment scheme, for instance, a QA instance of a web application points
    to a local instance of a database, while the Production deployment points to a
    different database server.
  prefs: []
  type: TYPE_NORMAL
- en: Another scenario could be one in which you are to deploy an application that
    you built for different distributions (for example, those that are RPM based and
    Debian based). In this scenario, deployment will be different, as both the platforms
    use different application managers. RPM based distributions use the Yum or DNF
    package management utility, while Debian based distributions use the DPKG utility
    for package management. Also, the resultant package that is created will be different
    – one is `.rpm` while the other is `.deb`.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, even through the target platform is different and the deployment
    schemes or configurations differ from each other, all these can be handled in
    one playbook by means of defining roles.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move to a few practical scenarios. In the first scenario, you need to
    deploy an application consisting of a backend database (MySQL) and a frontend
    web application. The web application queries the backend database and serves the
    data as requested by the user. Both the web application and MySQL database are
    to be deployed on different machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s divide the installation and configuration tasks into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**System preparation**: This is a common task for both the web application
    system and database server. Both systems need to first be prepared for installation.
    Preparation might involve tasks like configuring repositories and updating the
    system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deploy**: This includes deploying both the database and web application,
    followed by any configuration changes that are required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you analyze the categories, system preparation is common to both the systems,
    while the deploy jobs are specific to each application. In such a scenario, you
    can segregate the jobs into roles. You can have three roles – one "common" role,
    which executes on both the machines, and one role each for both the database and
    web application, respectively. This makes the Ansible playbook more modular and
    easy to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an Ansible playbook based on the above analysis of the problem
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '`db-webapp-role.yaml`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding playbook calls different roles – `common`, `webapp`, and `database`
    and executes them on the corresponding host groups. The `common` role is executed
    on all the host groups (that is, on both `webapp` and `database`). This is then
    followed by executing the individual roles on specific host groups. The following
    are the roles that are called by the preceding play:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Role** : `common`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is a `common` role, which will be executed on all the target hosts. It
    configures a repository that serves packages and dependencies to the target machine.
    The role configures this repository and updates all the packages installed on
    the target machine to their latest versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following role will be executed only on the hosts specified under the database
    group in the inventory file. This will install the MySQL database and copy over
    a configuration file, which will configure the database and create the required
    tables on the target host. It will also ensure the MYSQL service is running on
    the target host. As per the Ansible play, this role will be executed on the target
    host post successful completion of the `common` role:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Role**: `database`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following role is specific to deploying the web application on the webapp
    group of hosts in the inventory file. The role will execute upon successful completion
    of the `common` role as per the Ansible play:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Role**: `webapp`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Ansible roles – using tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible playbooks are meant to be modular and capable of being used in different
    environments whenever required. For this purpose, roles were introduced. However,
    just using roles may not be enough, as you may want to use different roles for
    different environments on the same host. Okay, this sounds confusing. Let's dive
    into a scenario.
  prefs: []
  type: TYPE_NORMAL
- en: You can integrate your Ansible playbooks with your continuous deployment system,
    which helps developers deploy the application whenever they want during the development
    cycle. During this cycle, they might want to set up the system and configure the
    application in a manner appropriate to the stage of development. Since the application
    is being developed, not all features may be complete while deploying on the development
    environment. However, once the application is complete, the developer might want
    to do a complete run of Ansible to replicate the production or QE environment,
    thus ensuring the application runs with all the settings as required on the production
    host. In this case, there are two different environments–development and QE-ready.
  prefs: []
  type: TYPE_NORMAL
- en: Since the deployment is done on the same host, and there are multiple roles
    that can be executed, you can use tags. You can couple a role with a tag. Thus,
    by specifying the tag from the command line, Ansible knows which role to execute.
  prefs: []
  type: TYPE_NORMAL
- en: One simple way to demonstrate this is as follows. Let's say you have an application
    which, when required to be deployed in a development environment, you clone the
    code from your Git Hub repository and run the `install.sh` script. Also in the
    development environment, you have some relaxed security policies, say SeLinux
    is set to permissive mode. The same application, when passed to QE, should be
    packaged in RPM and then installed. Also, the security relaxations are not allowed,
    hence SeLinux needs to stay in enforcing mode. Since a developer will have one
    development instance, he or she will have to execute both the roles on the same
    instance. In this case, the developer can use tags to use different roles as and
    when required for deploying the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an Ansible playbook along with the roles that demonstrate
    the preceding scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Role** : `development`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Role** : `qe_ready`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding two roles are a part of the same Ansible playbook and will be
    called as per required based on the tag you specify. The following Ansible play
    demonstrates how to bind a role to a specific tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ansible Play** : `demo-tag.yaml`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `development` role is now binded to the `development` tag while the `qe_ready`
    role is binded to the `qe` tag. An Ansible playbook can be executed by specifying
    tags using the `-t` flag in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Getting infrastructure information and hosting it centrally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, you created a `dmidecode` module that collected system
    information from the target machines and returned a JSON output. The module also
    allowed you to toggle a flag "save" to `true` if you wished to store the output
    in a JSON file on the target machine itself.
  prefs: []
  type: TYPE_NORMAL
- en: Storing system information on respective target machines does not serve much
    purpose, as the data still resides on the target machines, and to access the data,
    one needs to log in to a different machine and then parse the respective JSON
    files. To handle this, the book introduced you to callbacks, which help get back
    the JSON data and store it as JSON files on the controller node (that is, the
    node from where you are executing the Ansible playbook).
  prefs: []
  type: TYPE_NORMAL
- en: However, even after doing so, the problem is not completely resolved. You did
    manage to collect the data from your infrastructure nodes, but accessibility still
    remains an issue.
  prefs: []
  type: TYPE_NORMAL
- en: One needs access to the controller machine to access all the files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a real-world scenario, you cannot grant access to everyone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if you plan to give access to select individuals, your availability remains
    a bottleneck
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To handle this, one solution can be to host all these JSON files to a central
    server from where one can download the required JSON files, parse them, and generate
    reports. A better solution to this problem, however, can be to index the data
    in a central Elasticsearch instance, which then serves the data over a RESTful
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Elasticsearch** is an open source search engine built on top of Apache Lucene.
    Elasticsearch is written in Java and uses Lucene internally for indexing and searching.
    It aims to make full-text search easy by hiding the complexities of Lucene behind
    a simple RESTful API.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Source: Elasticsearch documentation from [www.elastic.co](http://www.elastic.co).'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will not go into depth about what Elasticsearch is and how it functions,
    as this is beyond the scope of this book. For details about Elasticsearch, you
    can refer to either the online documentation or *Mastering ElasticSearch* ([https://www.packtpub.com/web-development/mastering-elasticsearch-second-edition](https://www.packtpub.com/web-development/mastering-elasticsearch-second-edition)),
    published by *Packt Publishing*.
  prefs: []
  type: TYPE_NORMAL
- en: Back to the issue of indexing data in Elasticsearch and serving it over an HTTP,
    API can be a solution to the problem at hand. For this to work, you'll have to
    write a callback plugin that interacts with an Elasticsearch instance and indexes
    the JSON data, which can then be served over API. Python provides a library, `pyes`,
    to interact with an Elasticsearch instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s name the callback plugin `loges.py` and store it in the `callback_plugins`
    directory in the root of the Ansible play, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Post creating this callback plugin, if you run the Ansible play `dmidecode.yaml`,
    upon successful run, the JSON output will be indexed in the Elasticsearch instance
    and should be available through the API. Data will be indexed in the index named
    `infra` with the document type `dmidecode`. Every indexed document will have a
    unique ID, which, in this case, would be the `Hostname` or `IP`, whichever is
    applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dynamic inventory of just launched instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Ansible playbook, or even individual modules, are executed against target
    hosts commonly specified in an inventory file. Their most basic use is to have
    a static inventory file (for example, hosts) containing a list of all the target
    host IPs or hostnames against which the Ansible play has to be executed. However,
    in the real world, things might not be this dead simple. For instance, you might
    be required to launch a new instance on Cloud – say OpenStack or AWS – or launch
    a basic virtual machine and then deploy your application using the Ansible playbook.
    In this case, the target IP is unknown until the instance is launched, and therefore
    a static inventory file would not serve the purpose.
  prefs: []
  type: TYPE_NORMAL
- en: One of the major benefits of running Ansible programmatically and using the
    Ansible API was to handle runtime variables such as the target IP, in this case.
    This is a scenario where you can take full advantage of using the Python API to
    run the Ansible playbook while creating a dynamic inventory.
  prefs: []
  type: TYPE_NORMAL
- en: For generating a dynamic inventory file, the Jinja2 template can be used. Jinja2
    is fully supported by Ansible and can be used to create any template you want.
    Jinja2 is a vast topic in itself and cannot be covered in detail, as it is beyond
    the scope of this book. However, this specific scenario will touch upon Jinja2
    and how it can be used in conjunction with Ansible. In the above case, the Jinja2
    template will be used to render the inventory file at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Let's revisit the example from [Chapter 4](ch04.html "Chapter 4. Exploring API"),
    *Exploring API*, where an Ansible playbook, `webserver.yaml`, was programmatically
    executed on an inventory file, `hosts`. Contrary to the example in [Chapter 4](ch04.html
    "Chapter 4. Exploring API"), *Exploring API*, the inventory file will be rendered
    at runtime in the following example. This comes in handy while performing end-to-end
    automation, starting from launching instances and deploying applications.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the `launch_instance` function is only used to represent
    some code that can launch an instance or a virtual machine. The function, when
    called, returns a list of IPs associated with the launched instances. The returned
    list is cached in a variable, `target`, and is then used to render the inventory
    file. The following code section...:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '...is the Jinja2 template that is rendered by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The rendered inventory is then written into a temporary file using the following
    piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This creates an inventory file at runtime with IPs of the target machines (newly
    launched instances), as returned by the `launch_instance` method.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible through a bastion host
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the real world, production servers are normally configured to prevent SSH
    connections from outside their own private network. This is to reduce the number
    of possible attack vectors and also to keep the access point to a bare minimum.
    This helps in limiting access, creating better logging, and increases security.
    This is a common security practice and is implemented by using a bastion host.
  prefs: []
  type: TYPE_NORMAL
- en: A bastion host is specifically designed to withstand attacks. Normally, the
    bastion host runs only one service. Other services are either removed or disabled
    in order to minimize threats.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, with a bastion host coming into the picture, Ansible is not
    able to directly SSH to the target host from the controller node. It needs to
    proxy its commands through the bastion host in order to reach the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, all you need is to modify three files in your Ansible play
    root directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hosts`: Inventory file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible.cfg`: Ansible''s configuration files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssh.cfg`: SSH configurations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The inventory file includes a group, `bastion`, alongside the usual target
    hosts. The following code is a sample inventory `hosts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Ansible uses SSH for almost all its operations, the next step is to configure
    SSH. SSH by itself allows us to customize the settings as per the requirement.
    To configure SSH for this particular Ansible play, you need to create an `ssh.cfg`
    file with the following contents in the root of the Ansible playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding SSH configuration proxies all the commands to the nodes in network
    `172.16.*` through our Bastion host `10.68.214.8`. The control setting `ControlPersist`
    allows SSH to reuse the already established connection, thus improving performance
    and speeding up the Ansible playbook execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the SSH is configured, you need to tell Ansible to use this SSH configuration.
    For this, you need to create an `ansible.cfg` file in the root of the Ansible
    play with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Ansible will now use the above configuration to use `ssh.cfg` as the SSH configuration
    file and hence proxy the commands through the bastion host.
  prefs: []
  type: TYPE_NORMAL
- en: Happy managers = happy you
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until this point, this chapter has been about implementing Ansible for management,
    deployment, and configuration. Well, there is one more point that still remains
    – reporting.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of a long playbook execution, you may have the application deployed
    and you may have the audit data for your infrastructure or anything that the playbook
    was designed to do. Additionally, you can have logs for the playbook execution.
    However, let's say that at the end of day, you are asked to provide a report.
    You now have to sit down and create reports and fill out an Excel spreadsheet,
    as this is what your manager demands – an overview of the state of things as they
    are. This is something that can again be achieved by extending Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you did a playbook run and what you get is run logs on `stdout`. The question
    now becomes: how do you make an Excel report out of it? Yes, you guessed it right
    – the callback plugin comes to the rescue. You can write your own custom callback
    plugins that can help you record your Ansible play results and create a spreadsheet
    out of them. This would reduce the overhead task of creating reports manually.'
  prefs: []
  type: TYPE_NORMAL
- en: The report might vary for different use cases, as not one single report fits
    all. Hence, you will have to write callback plugins for the different kinds of
    report you want to generate. Some prefer an HTML-based report, while some prefer
    Excel spreadsheets.
  prefs: []
  type: TYPE_NORMAL
- en: The following example reuses the `dmidecode` module from [Chapter 3](ch03.html
    "Chapter 3. Digging Deeper into Ansible Modules"), *Digging Deeper into Ansible
    Modules*. The module is used to generate a JSON output, which is good for machine
    processing. However, JSON is not something one would like to read through manually
    for a report. Representing the data in an Excel spreadsheet makes much more sense,
    while creating a report as a spreadsheet is more reader-friendly and gives the
    complete picture at a glance. Someone with a non-technical background can also
    read data from an Excel sheet without much hassle.
  prefs: []
  type: TYPE_NORMAL
- en: The following is a callback module that creates an Excel sheet, reads the JSON
    output generated by executing the `dmidecode` module, and appends data for each
    host in the Excel spreadsheet. It is written in Python and uses the `openpyxl`
    library to create the Excel spreadsheet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding callback module is just an example of how you can represent data
    in an Excel spreadsheet and generate reports. The callback module can be extended
    to fill in more details as required in the report. The preceding module only adds
    the host, serial number, and manufacturer of the host machine.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that since the above callback module appends data to the same Excel
    spreadsheet, Ansible should execute tasks one host at a time. Therefore, you should
    set the fork as `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done by using the `--forks` flag. The following bit of code is
    how the Ansible playbook was executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the generated Excel report:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Happy managers = happy you](images/B04624_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter took you through various real-life scenarios in which Ansible can
    be used and how you can extend Ansible to suit your needs. The chapter started
    with the basics of Ansible such as defining roles and using tags. The chapter
    then gradually progressed to more complex scenarios, building upon examples from
    the previous chapters. The chapter also included a very common scenario in which
    Ansible required custom configurations in order to proxy the tasks through a bastion
    host. The chapter also gave you an idea of how you can exploit Ansible to automate
    some routine tasks like reporting.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, this chapter combined everything learned from the previous chapters
    and provided real-life scenarios and use cases of the same.
  prefs: []
  type: TYPE_NORMAL
