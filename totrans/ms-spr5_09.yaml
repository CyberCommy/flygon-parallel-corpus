- en: Spring Cloud
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at some of the important patterns related to
    developing Cloud-Native applications and implementing them using projects under
    the umbrella of Spring Cloud. We will look at the following features:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Implementing centralized microservice configuration with Spring Cloud Config
    Server
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Spring Cloud Bus to synchronize configuration across microservice instances
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Feign to create declarative REST clients
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing client-side load balancing using Ribbon
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Name server using Eureka
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing API Gateway using Zuul
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing distributed tracing using Spring Cloud Sleuth and Zipkin
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Hystrix to implement fault tolerance
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Spring Cloud
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 4](c4e1908a-b086-428c-8862-6474eb92f04a.xhtml), *Evolution toward
    Microservices and Cloud-Native Applications*, we discussed the problems with monolithic
    applications and how architectures evolved toward microservices. However, microservices
    have their own sets of challenges:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Organizations adopting microservice architectures also need to make challenging
    decisions around the consistency of microservices without affecting the innovation
    capabilities of the microservice teams.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smaller applications mean more builds, releases, and deployments. This is usually
    addressed using more automation.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservice architectures are built based on a large number of smaller, fine-grained
    services. There are challenges associated with managing configuration and availability
    of these services.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging issues becomes more difficult because of the distributed nature of
    applications.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To reap maximum benefits from microservice architectures, microservices should
    be Cloud-Native--easily deployable on the Cloud. In [Chapter 4](c4e1908a-b086-428c-8862-6474eb92f04a.xhtml),
    *Evolution toward Microservices and Cloud-Native Applications*, we discussed the
    characteristics of Twelve-Factor Apps--patterns that are typically considered
    good practices in Cloud-Native applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Cloud aims to provide solutions to some commonly encountered patterns
    when building systems on the Cloud. Some of the important features include the
    following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to manage distributed microservice configuration
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service registration and discovery using Name servers
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load balancing across multiple instances of microservices
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More fault-tolerant services using circuit breakers
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API Gateways for aggregation, routing, and caching
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed tracing across microservices
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to understand that Spring Cloud is not a single project. It
    is a group of subprojects aimed at solving the problems associated with applications
    deployed on the Cloud.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Some important Spring Cloud subprojects are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring Cloud Config**: Enables centralized external configuration across
    different microservices across different environments.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Cloud Netflix**: Netflix is one of the early adopters of microservice
    architecture. A number of internal Netflix projects were open sourced under the
    umbrella of Spring Cloud Netflix. Examples include Eureka, Hystrix, and Zuul.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Cloud Bus**: Makes it easier to build the integration of microservices
    with a lightweight message broker.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Cloud Sleuth**: Along with Zipkin, this provides distributed tracing
    solutions.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Cloud Data Flow**: Provides capabilities for building orchestration
    around microservice applications. Provides a DSL, GUI, and REST API.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Cloud Stream**: Provides a simple declarative framework to integrate
    Spring-based (and Spring Boot)-based applications with message brokers such as
    Apache Kafka or RabbitMQ.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A few things are common to all projects under the Spring Cloud umbrella:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: They solve some of the common problems with developing applications on the Cloud
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They provide great integration with Spring Boot
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are typically configured with simple annotations
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They make extensive use of auto-configuration
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Cloud Netflix
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Netflix is one of the first organizations to start making the switch from monolithic
    to microservice architectures. Netflix has been very open about documenting this
    experience. Some of the internal Netflix frameworks are open sourced under the
    umbrella of Spring Cloud Netflix. As defined on the Spring Cloud Netflix website
    ([https://cloud.spring.io/spring-cloud-netflix/](https://cloud.spring.io/spring-cloud-netflix/)):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Netflix provides Netflix OSS integrations for Spring Boot apps
    through autoconfiguration and binding to the Spring environment and other Spring
    programming model idioms.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the important projects under the Spring Cloud Netflix umbrella are
    as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '**Eureka**: The Name server that provides service registration and discovery
    capabilities for microservices.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hystrix**: Capabilities to build fault-tolerant microservices through circuit
    breakers. Also provides a dashboard.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feign**: Declarative REST Client makes it easy to call services created with
    JAX-RS and Spring MVC.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ribbon**: Provides client-side load balancing capabilities.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zuul**: Provides typical API Gateways capabilities, such as routing, filtering,
    authentication, and security. It can be extended with custom rules and filters.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demo microservices setup
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use two microservices to demonstrate concepts in this chapter:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '**Microservice A**: A simple microservice exposing two services--one to retrieve
    a message from the configuration file and another `random service` providing a
    list of random numbers.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service consumer microservice**: A simple microservice exposing a simple
    calculation service called the `add` service. The `add` service consumes the `random
    service` from **Microservice A** and adds the numbers up.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows the relationship between the microservices and the
    services that are exposed:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f95530f-f378-4100-8d83-68178a2f2052.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: Let's quickly set up these microservices.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Microservice A
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use Spring Initializr ([https://start.spring.io](https://start.spring.io))
    to get started with Microservice A. Choose GroupId, ArtifactId, and the frameworks,
    as shown in the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5c2a4b9-d95c-4bfb-a393-60b6f51486ee.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: 'We will create a service to expose a set of random numbers:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Important things to note are as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '`@RequestMapping("/random") public List<Integer> random()`: Random service
    returns a list of random numbers'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private int generateRandomNumber() {`: Generates random numbers between 0
    and 1000'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following snippet shows a sample response from the service at `http://localhost:8080/random`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, we would want to create a service to return a simple message from the
    application configuration in `application.properties`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a simple application configuration with one property--`message`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A few important things to note are as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '`@ConfigurationProperties("application")`: Defines a class defining `application.properties`.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private String message`: Defines one property--`message`. The value can be
    configured in `application.properties` with `application.message` as the key.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s configure `application.properties`, as shown in the following snippet:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A couple of important things to note are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '`spring.application.name=microservice-a`: `spring.application.name` is used
    to give a name to the application'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application.message=Default Message`: Configures a default message for `application.message`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a controller to read the message and return it, as shown in the
    following snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Important things to note are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '`@Autowired private ApplicationConfiguration configuration`: Autowires `ApplicationConfiguration`
    to enable reading the configured message value.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestMapping("/message") public Map<String, String> welcome()`: Exposes
    a simple service at the URI/`message`.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map.put("message", configuration.getMessage())`: The service returns a map
    with one entry. It has a key message and the value is picked up from the `ApplicationConfiguration`.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the service is executed at `http://localhost:8080/message`, we get the
    following response:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Service consumer
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s set up another simple microservice to consume the `random service` exposed
    by Microservice A. Let''s use Spring Initializr ([https://start.spring.io](https://start.spring.io))
    to initialize the microservice, as shown in the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40200b6e-6840-47ea-94e5-41933a590a89.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: 'Let''s add the service to consume `random service`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Important things to note are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '`@Value("${number.service.url}") private String numberServiceUrl`: We would
    want the number service URL to be configurable in application properties.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestMapping("/add") public Long add()`: Exposes a service at the URI `/add`.
    The `add` method calls the number service using `RestTemplate` and has the logic
    to sum the numbers returned in the response.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s configure `application.properties`, as shown in the following snippet:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Important things to note are as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '`spring.application.name=service-consumer`: Configures a name for the Spring
    Boot application'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`server.port=8100`: Uses `8100` as the port for service consumer'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number.service.url=http://localhost:8080/random`: Configures the number service
    URL for use in the add service'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the service is called at the URL `http://localhost:8100/add`, the following
    response is returned:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is an extract from the log of Microservice A:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The log shows that `random service` from Microservice A returned `5` numbers.
    The `add` service in the service consumer added them up and returned a result
    `2890`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: We now have our example microservices ready. In the next steps, we will add
    Cloud-Native features to these microservices.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Ports
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create six different microservices applications and
    components. To keep things simple, we will use specific ports for specific applications.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the ports that we would reserve for use by the different
    applications created in this chapter:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '| **Microservice component** | **Port(s) used** |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| Microservice A | `8080` and `8081` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| Service consumer microservice | `8100` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| Config Server (Spring Cloud Config) | `8888` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| Eureka server (Name server) | `8761` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| Zuul API Gateway Server | `8765` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| Zipkin Distributed Tracing Server | `9411` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: We have two of our microservices ready. We are ready to Cloud-enable our microservices.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Centralized microservice configuration
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Cloud Config provides solutions to externalize the configuration of a
    microservice. Let's first understand the need to externalize microservice configuration.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Problem statement
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In microservice architectures, we typically have a number of small microservices
    interacting with each other instead of a set of big monolithic applications. Each
    microservice is typically deployed in multiple environments--development, testing,
    load test, staging, and production. In addition, there can be multiple instances
    of microservices in different environments. For example, a specific microservice
    might be handling heavy load. There might be multiple production instances for
    that microservice in production.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration of an application typically contains the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '**Database configuration**: Details needed to connect to the database'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message broker configuration**: Any configuration needed to connect to AMQP
    or similar resources'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External services configuration**: Other services that the microservice needs'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservice configuration**: Typical configuration related to the business
    logic of the microservice'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each instance of a microservice can have its own configuration--different databases,
    different external services it consumes, among others. For example, if a microservice
    is deployed in five environments and there are four instances in each environment,
    the microservice can have a total of 20 different configurations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows typical configurations needed for Microservice A.
    We are looking at two instances in development, three instances in QA, one instance
    in the stage, and four instances in production:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45098e73-511a-4ffa-b328-1d75af0ed801.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: Solution
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintaining configurations for different microservices separately would make
    it difficult for the operations team. The solution, as shown in the following
    figure, is to create a centralized **Configuration Server:**
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e0b5e0b-9d9f-43c0-9b90-f45f180b24a8.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: The centralized **Configuration Server** holds all the configuration belonging
    to all the different microservices. This helps in keeping the configuration separate
    from the application deployable.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The same deployable (EAR or WAR) can be used in different environments. However,
    all configuration (things that vary between different environments) will be stored
    in the centralized configuration server.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: An important decision that needs to be made would be to decide whether there
    are separate instances of centralized configuration servers for different environments.
    Typically, you would want access to your production configuration to be more restrictive
    compared to other environments. At a minimum, we recommend a separate centralized
    configuration server for production. Other environments can share one instance
    of the configuration server.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Options
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following screenshot shows the options provided in Spring Initializer for
    Cloud Config Servers:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7de9ab8a-1b96-4a33-8537-ffa0e4ccf592.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we will configure a Cloud Config Server using Spring Cloud
    Config.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Config
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Cloud Config provides support for centralized microservice configuration.
    It is a combination of two important components:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring Cloud Config Server**: Provides support for exposing centralized configuration
    backed up by a version control repository--GIT or subversion'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Cloud Config Client**: Provides support for applications to connect
    to Spring Cloud Config Server'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows a typical microservice architecture using Spring
    Cloud Config. The configuration for multiple microservices is stored in a single
    **GIT** repository:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79fd2b15-8bbf-4ed8-aad9-ff7e3d01615f.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: Implementing Spring Cloud Config Server
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following figure shows the updated implementation of Microservice A and
    service consumer with Spring Cloud Config. In the following figure, we will integrate
    Microservice A with Spring Cloud Config in order to retrieve its configuration
    from the local Git repository:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6c0b98f-7daf-4148-93f0-7ccb6a9969c2.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: 'Implementing Spring Cloud Config needs the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Spring Cloud Config server.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up a local Git repository and connecting it to Spring Cloud Config server.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating Microservice A to use the configuration from Cloud Config Server--using
    Spring Cloud Config Client.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up Spring Cloud Config Server
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s set up the Cloud Config Server using Spring Initializr ([http://start.spring.io](http://start.spring.io)).
    The following screenshot shows GroupId and ArtifactId to choose. Make sure that
    you select Config Server as a dependency:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13a42290-1416-41f5-a85b-bbdaeb6d73ce.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: 'If you want to add the Config Server to an existing application, use the dependency
    shown here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once the project is created, the first step is to add the `EnableConfigServer`
    annotation. The following snippet shows the annotation added to `ConfigServerApplication`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Connecting Spring Cloud Config Server to a local Git repository
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Config Server needs to be connected to a Git repository. To keep things
    simple, let's connect to a local Git repository.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 配置服务器需要连接到一个Git存储库。为了保持简单，让我们连接到一个本地Git存储库。
- en: You can install Git for your specific operating system from [https://git-scm.com](https://git-scm.com).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://git-scm.com](https://git-scm.com)为您的特定操作系统安装Git。
- en: The following commands help you set a simple local Git repository.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可帮助您设置一个简单的本地Git存储库。
- en: 'Switch to a directory of your choice after installing Git. Execute the following
    commands on a terminal or Command Prompt:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Git后切换到您选择的目录。在终端或命令提示符上执行以下命令：
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a file called `microservice-a.properties` in the `git-localconfig-repo`
    folder with the content shown here:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在`git-localconfig-repo`文件夹中创建一个名为`microservice-a.properties`的文件，内容如下：
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Execute the following commands to add and commit `microservice-a.properties`
    to a local Git repository:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令将`microservice-a.properties`添加并提交到本地Git存储库：
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that we have the local Git repository ready with our configuration, we
    would need to connect the Config Server to it. Let''s configure `application.properties`
    in `config-server`, as shown here:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了具有我们配置的本地Git存储库，我们需要将配置服务器连接到它。让我们按照这里所示配置`config-server`中的`application.properties`：
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Some important things to note are as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一些重要的事项如下：
- en: '`server.port=8888`: Configures the port for Config Server. `8888` is typically
    the most commonly used port for Config Server.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server.port=8888`：配置配置服务器的端口。`8888`通常是配置服务器最常用的端口。'
- en: '`spring.cloud.config.server.git.uri=file:///in28Minutes/Books/MasteringSpring/git-localconfig-repo`:
    Configures the URI to the local Git repository. If you want to connect to a remote
    Git repository, you can configure the URI of the Git repository here.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.cloud.config.server.git.uri=file:///in28Minutes/Books/MasteringSpring/git-localconfig-repo`：配置到本地Git存储库的URI。如果要连接到远程Git存储库，可以在这里配置Git存储库的URI。'
- en: 'Start the server. When you hit the URL `http://localhost:8888/microservice-a/default`,
    you will see the following response:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 启动服务器。当您访问URL`http://localhost:8888/microservice-a/default`时，您将看到以下响应：
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Some important things to understand are as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一些重要的事项如下：
- en: '`http://localhost:8888/microservice-a/default`: The URI format is `/{application-name}/{profile}[/{label}]`.
    Here, the `application-name` is `microservice-a` and the profile is `default`.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8888/microservice-a/default`：URI格式为`/{application-name}/{profile}[/{label}]`。这里，`application-name`是`microservice-a`，配置文件是`default`。'
- en: The service returns the configuration from `microservice-a.properties` since
    we are using the default profile. You can see it in the response in the `propertySources`>`name`
    field.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们使用默认配置文件，该服务将从`microservice-a.properties`返回配置。您可以在`propertySources`>`name`字段的响应中看到它。
- en: '`"source":{"application.message":"Message From Default Local Git Repository"}`:
    The content of the response is the content of the property file.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"source":{"application.message":"Message From Default Local Git Repository"}`：响应的内容是属性文件的内容。'
- en: Creating an environment-specific configuration
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建特定于环境的配置
- en: Let's create a specific configuration for Microservice A for the `dev` environment.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`dev`环境为Microservice A创建一个特定的配置。
- en: 'Create a new file in `git-localconfig-repo` with the name `microservice-a-dev.properties`
    with the content shown here:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在`git-localconfig-repo`中创建一个名为`microservice-a-dev.properties`的新文件，内容如下：
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Execute the following commands to `add` and `commit` `microservice-a-dev.properties`
    to the local Git repository:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令将`microservice-a-dev.properties`添加并提交到本地Git存储库：
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When you hit the URL `http://localhost:8888/microservice-a/dev`, you will see
    the following response:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当您访问URL`http://localhost:8888/microservice-a/dev`时，您将看到以下响应：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The response contains the `dev` configuration from `microservice-a-dev.properties`.
    The configuration from the default property file (`microservice-a.properties`)
    is also returned. Properties configured in `microservice-a-dev.properties` (environment-specific
    properties) have higher priority than the defaults configured in `microservice-a.properties`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 响应包含来自`microservice-a-dev.properties`的`dev`配置。还返回了默认属性文件（`microservice-a.properties`）中的配置。在`microservice-a-dev.properties`中配置的属性（特定于环境的属性）优先级高于在`microservice-a.properties`中配置的默认属性。
- en: Similar to `dev`, a separate configuration for Microservice A can be created
    for different environments. If there is a need for multiple instances in a single
    environment, a tag can be used to differentiate. A URL of the format `http://localhost:8888/microservice-a/dev/{tag}`
    can be used to retrieve configuration based on the specific tag.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`dev`，可以为不同的环境创建Microservice A的单独配置。如果在单个环境中需要多个实例，可以使用标签进行区分。可以使用格式为`http://localhost:8888/microservice-a/dev/{tag}`的URL来根据特定标签检索配置。
- en: The next step is to connect Microservice A to the Config Server.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将Microservice A连接到配置服务器。
- en: Spring Cloud Config Client
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud配置客户端
- en: 'We will use Spring Cloud Config Client to connect `Microservice A` to `Config
    Server`. The dependency is shown here. Add the following code to the `pom.xml`
    file of `Microservice A`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Spring Cloud配置客户端将`Microservice A`连接到`配置服务器`。依赖项如下所示。将以下代码添加到`Microservice
    A`的`pom.xml`文件中：
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Dependencies for Spring Cloud are managed differently from Spring Boot. We
    will use dependency management to manage dependencies. The following snippet will
    ensure that the correct version of all Spring Cloud dependencies is used:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud的依赖项与Spring Boot的管理方式不同。我们将使用依赖项管理来管理依赖项。以下代码段将确保使用所有Spring Cloud依赖项的正确版本：
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Rename `application.properties` in `Microservice A` to `bootstrap.properties`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Microservice A`中的`application.properties`重命名为`bootstrap.properties`。
- en: 'Configure it as shown here:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这里所示进行配置：
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since we would want `Microservice A` to connect to `Config Server`, we provide
    the URI of `Config Server` using `spring.cloud.config.uri`. Cloud Config Server
    is used to retrieve the configuration for microservice A. Hence, the configuration
    is provided in `bootstrap.properties`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望`微服务A`连接到`Config Server`，因此我们使用`spring.cloud.config.uri`提供`Config Server`的URI。
    Cloud Config Server用于检索微服务A的配置。因此，配置在`bootstrap.properties`中提供。
- en: '**Spring Cloud Context**: Spring Cloud introduces a few important concepts
    for the Spring application deployed in the Cloud. The Bootstrap Application Context
    is an important concept. It is the parent context for the microservice application.
    It is responsible for loading an external configuration (for example, from Spring
    Cloud Config Server) and Decrypting Configuration Files (external and local).
    The Bootstrap context is configured using bootstrap.yml or bootstrap.properties.
    We had to change the name of application.properties to bootstrap.properties in
    Microservice A earlier because we want Microservice A to use the Config Server
    for bootstrapping.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Cloud Context**：Spring Cloud为部署在云中的Spring应用程序引入了一些重要概念。引导应用程序上下文是一个重要概念。它是微服务应用程序的父上下文。它负责加载外部配置（例如，来自Spring
    Cloud Config Server）和解密配置文件（外部和本地）。引导上下文使用bootstrap.yml或bootstrap.properties进行配置。我们之前必须将application.properties的名称更改为Microservice
    A中的bootstrap.properties，因为我们希望Microservice A使用Config Server进行引导。'
- en: 'An extract from the log when Microservice A is restarted is shown here:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Microservice A重新启动时日志中的提取如下所示：
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `Microservice A` service is using the configuration from `Spring Config
    Server` at `http://localhost:8888`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`微服务A`服务正在使用来自`Spring Config Server`的配置，地址为`http://localhost:8888`。'
- en: 'The following is the response when `Message Service` at `http://localhost:8080/message`
    is invoked:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`http://localhost:8080/message`上的`消息服务`时，以下是响应：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The message is picked up from the `localconfig-repo/microservice-a.properties`
    file.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 消息是从`localconfig-repo/microservice-a.properties`文件中提取的。
- en: 'You can set the active profile to `dev` to pick up the dev configuration:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将活动配置设置为`dev`以获取dev配置：
- en: '[PRE25]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The configuration for the service consumer microservice can also be stored in
    `local-config-repo` and exposed using Spring Config Server.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 服务消费者微服务的配置也可以存储在`local-config-repo`中，并使用Spring Config Server公开。
- en: Spring Cloud Bus
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud Bus
- en: Spring Cloud Bus makes it seamless to connect microservices to lightweight message
    brokers, such as Kafka and RabbitMQ.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Bus使得将微服务连接到轻量级消息代理（如Kafka和RabbitMQ）变得轻松。
- en: The need for Spring Cloud Bus
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud Bus的需求
- en: 'Consider an example of making a configuration change in a microservice. Let''s
    assume that there are five instances of `Microservice A` running in production.
    We would need to make an emergency configuration change. For example, let''s make
    a change in `localconfig-repo/microservice-a.properties`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个在微服务中进行配置更改的例子。假设在生产环境中有五个运行中的`微服务A`实例。我们需要进行紧急配置更改。例如，让我们在`localconfig-repo/microservice-a.properties`中进行更改：
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For `Microservice A` to pick up this configuration change, we need to invoke
    a `POST` request on `http://localhost:8080/refresh`. The following command can
    be executed at command prompt to send a `POST` request:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`微服务A`获取此配置更改，我们需要在`http://localhost:8080/refresh`上调用`POST`请求。可以在命令提示符处执行以下命令以发送`POST`请求：
- en: '[PRE27]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You will see the configuration change reflected at `http://localhost:8080/message`.
    The following is the response from the service:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在`http://localhost:8080/message`看到配置更改的反映。以下是服务的响应：
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We have five instances of Microservice A running. The change in configuration
    is reflected only for the instance of the Microservice A where the URL is executed.
    The other four instances will not receive the configuration change until the refresh
    request is executed on them.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有五个运行中的Microservice A实例。配置更改仅对执行URL的Microservice A实例反映。其他四个实例在执行刷新请求之前将不会接收配置更改。
- en: If there are a number of instances of a microservice, then executing the refresh
    URL for each instance becomes cumbersome since you would need to do this for every
    configuration change.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个微服务实例，则对每个实例执行刷新URL变得很麻烦，因为您需要对每个配置更改执行此操作。
- en: Propogating configuration changes using Spring Cloud Bus
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Bus传播配置更改
- en: The solution is to use Spring Cloud Bus to propagate the configuration change
    to multiple instances over a message broker such as RabbitMQ.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用Spring Cloud Bus通过消息代理（如RabbitMQ）向多个实例传播配置更改。
- en: 'The following figure shows how different instances of a microservice (actually,
    they can be completely different microservices as well) are connected to a message
    broker using Spring Cloud Bus:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了不同实例的微服务（实际上，它们也可以是完全不同的微服务）如何使用Spring Cloud Bus连接到消息代理：
- en: '![](img/be9ea549-8fe5-4744-be5a-3a007351da74.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be9ea549-8fe5-4744-be5a-3a007351da74.png)'
- en: Each microservice instance will register with the Spring Cloud Bus at application
    startup.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务实例将在应用程序启动时向Spring Cloud Bus注册。
- en: When refresh is called on one of the microservice instances, Spring Cloud Bus
    will propagate a change event to all the microservice instances. The microservice
    instances will request the updated configuration from the configuration server
    on receiving the change event.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当刷新调用一个微服务实例时，Spring Cloud Bus将向所有微服务实例传播更改事件。微服务实例在接收更改事件时将从配置服务器请求更新的配置。
- en: Implementation
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: We will use RabbitMQ as the message broker. Ensure that you have installed and
    started up RabbitMQ before proceeding further.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用RabbitMQ作为消息代理。在继续之前，请确保已安装并启动了RabbitMQ。
- en: Installation instructions for RabbitMQ are provided at [https://www.rabbitmq.com/download.html](https://www.rabbitmq.com/download.html).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ的安装说明请参见[https://www.rabbitmq.com/download.html](https://www.rabbitmq.com/download.html)。
- en: 'The next step is to add connectivity to Spring Cloud Bus for `Microservice
    A`. Let''s add the following dependency in the `pom.xml` file of Microservice
    A:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can run `Microservice A` on different ports by providing the port as one
    of the startup VM arguments. The following screenshot shows how you can configure
    the server port as the VM argument in Eclipse. The value configured is `-Dserver.port=8081`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40b004ac-c709-40f6-8f50-9b0b4b602ac5.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: 'We will run Microservice A on ports `8080` (default) and `8081`. The following
    is an extract from the log when Microservice A is restarted:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: All instances of `Microservice A` are registered with `Spring Cloud Bus` and
    listen to events on the Cloud Bus. The default configuration of RabbitMQ Connection
    is a result of the magic of autoconfiguration.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update `microservice-a.properties` with a new message now:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Commit the file and fire a request to refresh the configuration on one of the
    instances, let''s say port `8080`, using the URL `http://localhost:8080/bus/refresh`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following is an extract from the log of the second instance of `Microservice
    A` running on port `8081`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can see that even though the refresh URL is not called on port `8081`, the
    updated message is picked up from the Config Server. This is because all instances
    of Microservice A are listening on the Spring Cloud Bus for change events. As
    soon as the refresh URL is called on one of the instances, it triggers a change
    event and all other instances pick up the changed configuration.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the configuration change reflect in both instances of Microservice
    A at `http://localhost:8080/message` and `http://localhost:8081/message`. The
    following is the response from the service:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Declarative REST Client - Feign
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Feign helps us create REST clients for REST services with minimum configuration
    and code. All you need to define is a simple interface and use proper annotations.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '`RestTemplate` is typically used to make REST service calls. Feign helps us
    write REST clients without the need for `RestTemplate` and the logic around it.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Feign integrates well with Ribbon (client-side load balancing) and Eureka (Name
    server). We will look at this integration later in the chapter.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Feign, let''s add the Feign starter to the `pom.xml` file of service
    consumer microservice:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We need to add `dependencyManagement` for Spring Cloud to the `pom.xml` file
    as this is the first Cloud dependency that service consumer microservice is using:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The next step is to add the annotation in order to enable scanning for Feign
    clients to `ServiceConsumerApplication`. The following snippet shows the usage
    of the `@EnableFeignClients` annotation:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We need to define a simple interface to create a Feign client for a `random
    service`. The following snippet shows the details:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Some important things to note are as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '`@FeignClient(name ="microservice-a", url="localhost:8080")`: The `FeignClient`
    annotation is used to declare that a REST client with the given interface needs
    to be created. We are hardcoding the URL of `Microservice A` for now. Later, we
    will look at how we can connect this to a Name server and eliminate the need for
    hardcoding.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestMapping(value = "/random", method = RequestMethod.GET)`: This specific
    GET service method is exposed at the URI `/random`.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public List<Integer> getRandomNumbers()`: This defines the interface of the
    service method.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s update `NumberAdderController` to use `RandomServiceProxy` in order
    to call the service. The following snippet shows the important details:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'A couple of important things to note are as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '`@Autowired private RandomServiceProxy randomServiceProxy`: `RandomServiceProxy`
    is autowired in.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<Integer> numbers = randomServiceProxy.getRandomNumbers()`: Look at how
    simple it is to use the Feign client. No playing around with `RestTemplate` anymore.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we invoke the `add` service in service consumer microservice at `http://localhost:8100/add`,
    you will get the following response:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'GZIP compression can be enabled on Feign requests by configuring it, as shown
    in the following snippet:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Load balancing
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices are the most important building blocks of Cloud-Native architectures.
    Microservice instances are scaled up and down based on the load of a specific
    microservice. How do we ensure that the load is equally distributed among the
    different instances of microservices? That's where the magic of load balancing
    comes in. Load balancing is important in order to ensure that the load is equally
    distributed among the different instances of microservices.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Ribbon
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As shown in the following figure, Spring Cloud Netflix Ribbon provides client-side
    load balancing using round robin execution among the different instances of a
    microservice:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb2fee3a-ecb1-46be-acaa-6e61b51f88f7.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
- en: Implementation
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will add Ribbon to service consumer microservice. The service consumer microservice
    will distribute the load among two instances of Microservice A.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with adding the Ribbon dependency to the `pom.xml` file of service
    consumer microservice:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we can configure the URLs for the different instances of Microservice
    A. Add the following configuration to `application.properties` in service consumer
    microservice:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We will then specify the `@RibbonClient` annotation on the service proxy--`RandomServiceProxy`
    in this example. The `@RibbonClient` annotation is used to specify declarative
    configuration for a ribbon client:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When you restart the service consumer microservice and hit the add service
    at `http://localhost:8100/add`, you will get the following response:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This request is handled by an instance of `Microservice A` running on port
    `8080`, An extract from the log is shown here:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When we hit the add service again at the same URL, `http://localhost:8100/add`
    we get the following response:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'However, this time, the request is handled by an instance of `Microservice
    A` running on port `8081`. An extract from the log is shown here:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We have now successfully distributed the load among the different instances
    of `Microservice A`. While this can be improved further, this is a good start.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'While round robin (`RoundRobinRule`) is the default algorithm used by Ribbon,
    there are other options available:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '`AvailabilityFilteringRule` will skip servers that are down and that have a
    number of concurrent connections.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WeightedResponseTimeRule` will pick the server based on the response times.
    If a server takes a long time to respond, it will get fewer requests.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The algorithm to be used can be specified in the application configuration:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `microservice-a` is the name of the service we specified in the `@RibbonClient(name="microservice-a")`
    annotation.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the architecture for the components we have set
    up already:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/420f239b-4d07-43cf-9da0-45c96c08afd5.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
- en: The Name server
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservice architectures involve a number of smaller microservices interacting
    with each other. Adding to this, there can be multiple instances of each microservice.
    Maintaining the external service connections and configurations manually would
    be difficult as new instances of microservices are dynamically created and destroyed.
    Name servers provide features of service registration and service discovery. Name
    servers allow microservices to register themselves and also discover the URLs
    to other microservices they want to interact with.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of hard coding microservice URLs
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous example, we added the following configuration to `application.properties`
    in the service consumer microservice:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This configuration represents all instances of Microservice A. Take a look
    at these situations:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: A new instance of Microservice A is created
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An existing instance of Microservice A is no longer available
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservice A is moved to a different server
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all these instances, the configuration needs to be updated and the microservices
    refreshed in order to pick up the changes.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Workings of Name server
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Name server is an ideal solution for the preceding situation. The following
    diagram shows how Name servers work:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22015697-765e-438b-a8f4-5e285ca86d00.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
- en: All microservices (different microservices and all their instances) will register
    themselves with the Name server as each microservice starts up. When a service
    consumer wants to get the location of a specific microservice, it requests the
    Name server.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: A unique microservice ID is assigned to each microservice. This is used as a
    key in the register request and the lookup request.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Microservices can automatically register and unregister themselves. Whenever
    a service consumer looks up the Name server with a microservice ID, it will get
    the list of the instances of that specific microservice.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Options
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following screenshot shows the different options available for service
    discovery in Spring Initializr ([http://start.spring.io](http://start.spring.io)):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e421967-7dbf-41d7-b286-de6c55fe5371.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
- en: We are going to use Eureka as the Name server for service discovery in our example.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The implementation of Eureka for our example involves the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Setting up `Eureka Server`.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating `Microservice A` instances to register with `Eureka Server`.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating service consumer microservice to use the Microservice A instances registered
    with `Eureka Server`.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up a Eureka Server
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use Spring Initializr ([http://start.spring.io](http://start.spring.io))
    to set up a new project for Eureka Server. The following screenshot shows the
    GroupId, ArtifactId, and Dependencies to be selected:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34156e01-00c7-40d9-b4f6-7a0d97564ee1.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to add the `EnableEurekaServer` annotation to the `SpringBootApplication`
    class. The following snippet shows the details:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The following snippet shows the configuration in `application.properties`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We are using port `8761` for `Eureka Naming Server`. Launch `EurekaServerApplication`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'A screenshot of the Eureka dashboard at `http://localhost:8761` is shown here:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bae8f703-7072-4d30-9565-3856e9361326.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
- en: As of now, there are no applications registered with Eureka. In the next step,
    let's register `Microservice A` and other services with Eureka.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Registering microservices with Eureka
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To register any microservice with the Eureka Name server, we would need to
    add the dependency on Eureka Starter project. The following dependency needs to
    be added to the `pom.xml` file of Microservice A:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The next step is to add `EnableDiscoveryClient` to the `SpringBootApplication`
    classes. An example of `MicroserviceAApplication` is shown here:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Spring Cloud Commons hosts the common classes used in different Spring Cloud
    implementations. A good example is the `@EnableDiscoveryClient` annotation. Different
    implementations are provided by Spring Cloud Netflix Eureka, Spring Cloud Consul
    Discovery, and Spring Cloud Zookeeper Discovery.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'We will configure the URL of the naming server in the application configuration.
    For Microservice A, the application configuration is in the local Git repository
    file, `git-localconfig-repomicroservice-a.properties`:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'When both instances of `Microservice A` are restarted, you will see these messages
    in the log of `Eureka Server`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'A screenshot of the Eureka Dashboard at `http://localhost:8761` is shown as
    follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7a2ac1a-75f3-4e97-9c80-acdc3626c287.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
- en: Two instances of `Microservice A` are now registered with `Eureka Server`. Similar
    updates can be done on `Config Server` in order to connect it to `Eureka Server`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we would want to connect the service consumer microservice
    to pick up URLs of instances of Microservice A from the Eureka server.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the service consumer microservice with Eureka
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Eureka starter project needs to be added as a dependency in the `pom.xml`
    file of the service consumer microservice:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Currently, the URLs of the different instances of `Microservice A` are hardcoded
    in the service consumer microservice, as shown here, in `application.properties`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'However, now we would not want to hardcode Microservice A URLs. We would want
    the service consumer microservice to get the URLs from `Eureka Server`. We do
    that by configuring the URL of `Eureka Server` in the `application.properties`
    of the service consumer microservice. We will comment out the hardcoding of the
    Microservice A URLs:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next, we will add `EnableDiscoveryClient` on the `ServiceConsumerApplication`
    class, as shown here:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Once the service consumer microservice is restarted, you will see that it will
    register itself with `Eureka Server`. The following is an extract from the log
    of `Eureka Server`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In `RandomServiceProxy`, we have already configured a name for `microservice-a`
    on the Feign client, as shown here:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The service consumer microservice will use this ID (Microservice A) to query
    `Eureka Server` for instances. Once it gets the URLs from `Eureka Service`, it
    will invoke the service instance selected by Ribbon.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: When the `add` service is invoked at `http://localhost:8100/add`, it returns
    an appropriate response.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a quick review of the different steps involved:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: As each instance of Microservice A starts up, it registers with `Eureka Name
    Server`.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The service consumer microservice requests `Eureka Name Server` for instances
    of Microservice A.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The service consumer microservice uses the Ribbon client-side load balancer
    to decide the specific instance of Microservice A to call.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The service consumer microservice calls a specific instance of Microservice
    A.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The biggest advantage of `Eureka Service` is that service consumer microservice
    is now decoupled from Microservice A. Whenever new instances of Microservice A
    come up or an existing instance goes down, the service consumer microservice does
    not need to be reconfigured.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: API Gateways
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Microservices have a number of cross-cutting concerns:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication, authorization, and security**: How do we ensure that the
    microservice consumers are who they claim to be? How do we ensure that the consumers
    have the right access to microservices?'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rate limits** : There might be different kinds of API plans for consumers
    and different limits (the number of microservice invocations) for each plan. How
    do we enforce the limits on a specific consumer?'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic routing**: Specific situations (for example, a microservice is down)
    might need dynamic routing.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service aggregation**: The UI needs for a mobile are different from the desktop.
    Some microservice architectures have service aggregators tailored for a specific
    device.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fault tolerance**: How do we ensure that failure in one microservice does
    not cause the entire system to crash?'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When microservices talk directly with each other, these concerns have to be
    addressed by individual microservices. This kind of architecture might be difficult
    to maintain because each microservice might handle these concerns differently.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common solutions is to use an API Gateway. All service calls
    to and between microservices should go through an API Gateway. API Gateway typically
    provide these features for microservices:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and security
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate limiting
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insights and monitoring
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic routing and static response handling
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load shedding
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregation of responses from multiple services
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing client-side load balancing with Zuul
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Zuul is part of the Spring Cloud Netflix project. It is an API Gateway service
    that provides the capabilities of dynamic routing, monitoring, filtering, security,
    and more.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing Zuul as an API Gateway involves the following:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a new Zuul API Gateway Server.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring Service Consumer to use Zuul API Gateway.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up a new Zuul API Gateway Server
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use Spring Initializr ([http://start.spring.io](http://start.spring.io))
    to set up a new project for Zuul API Gateway. The following screenshot shows the
    GroupId, ArtifactId, and Dependencies to be selected:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1245756e-84eb-45bb-968b-6f3f1a365335.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to enable Zuul proxy on the Spring Boot application. This
    is done by adding the `@EnableZuulProxy` annotation on the `ZuulApiGatewayServerApplication`
    class. The following snippet shows the details:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We will run Zuul Proxy on port `8765`. The following snippet shows the configuration
    needed in `application.properties`:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We are configuring the port for Zuul proxy and connecting it to the Eureka Name
    server as well.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Zuul custom filters
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Zuul provides options to create custom filters to implement typical API Gateway
    functionality, such as authentication, security, and tracing. In this example,
    we will create a simple logging filter to log every request. The following snippet
    shows the details:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'A few important things to note are as follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '`SimpleLoggingFilter extends ZuulFilter`: `ZuulFilter` is the base abstract
    class to create filters for Zuul. Any filter should implement the four methods
    listed here.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public String filterType()`: Possible return values are `"pre"` for prerouting
    filtering, `"route"` for routing to an origin, `"post"` for postrouting filters,
    and `"error"` for error handling. In this example, we would want to filter before
    the request is executed. We return a value `"pre"`.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public int filterOrder()`: Defines the precedence for a filter.'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public boolean shouldFilter()`: If the filter should only be executed in certain
    conditions, the logic can be implemented here. If you would want the filter to
    always be executed, return `true`.'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public Object run()`: The method to implement the logic for the filter. In
    our example, we are logging the request method and the URL of the request.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we start up the Zuul server by launching `ZuulApiGatewayServerApplication`
    as a Java application, you will see the following log in `Eureka Name Server`:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This shows that `Zuul API gateway` is up and running. `Zuul API gateway` is
    also registered with `Eureka Server`. This allows microservice consumers to talk
    to the Name server to get details about `Zuul API gateway`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the Eureka dashboard at `http://localhost:8761`.
    You can see that instances of `Microservice A`, `service consumer`, and `Zuul
    API Gateway` are now registered with `Eureka Server`:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0c5df38-8927-4286-8d5a-1ee980808a23.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
- en: 'The following is an extract from the `Zuul API gateway` log:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: By default, all services in Microservice A and the service consumer microservice
    are enabled for reverse proxying by Zuul.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Invoking microservices through Zuul
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's invoke `random service` through the service proxy now. The direct URL
    to a random microservice is `http://localhost:8080/random`. This is exposed by
    Microservice A, whose application name is `microservice-a`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: 'The URL structure to call a service through `Zuul API Gateway` is `http://localhost:{port}/{microservice-application-name}/{service-uri}`.
    So, the `Zuul API Gateway` URL for `random service` is `http://localhost:8765/microservice-a/random`.
    When you invoke `random service` through API Gateway, you get a response shown
    here. The response is similar to what you would typically get when directly calling
    the random service:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The following is an extract from the `Zuul Api Gateway` log. You can see that
    the `SimpleLoggingFilter` that we created in `Zuul API Gateway` is executed for
    the request:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `add` service is exposed by service consumer, whose application name is
    service-consumer and the service URI is `/add`. So, the URL to execute the `add`
    service through the API Gateway is `http://localhost:8765/service-consumer/add`.
    The response from the service is shown here. The response is similar to what you
    would typically get when directly calling the `add` service:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The following is an extract from the `Zuul API Gateway` log. You can see that
    the initial `add` service call is going through the API Gateway:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `add` service calls `random service` on `Microservice A`. While the initial
    call to add service goes through the API Gateway, the call from add service (service
    consumer microservice) to `random service` (Microservice A) is not routed through
    API Gateway. In an ideal world, we would want all the communication to take place
    through API Gateway.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, let's make the requests from the service consumer microservice
    go through the API Gateway as well.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Configuring service consumer to use Zuul API gateway
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code shows the existing configuration of `RandomServiceProxy`,
    which is used to call `random service` on `Microservice A`. The name attribute
    in the `@FeignClient` annotation is configured to use the application name of
    Microservice A. The request mapping uses the `/random` URI:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, we want the call to go through the API Gateway. We would need to use the
    application name of the API Gateway and the new URI of `random service` in the
    request mapping. The following snippet shows the updated `RandomServiceProxy`
    class:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'When we invoke the add service at `http://localhost:8765/service-consumer/add`,
    we will see the typical response:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'However, now we will see more things happen on `Zuul API gateway`. The following
    is an extract from the `Zuul API gateway` log. You can see that the initial add
    service call on the service consumer, as well as the `random service` call on
    `Microservice A`, are now being routed through the API Gateway:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We saw a basic implementation of a simple logging filter on `Zuul API Gateway`.
    A similar approach can be used to implement filters for other cross-cutting concerns.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: Distributed tracing
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In typical microservice architectures, there are a number of components involved.
    A few of them are listed here:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Different microservices
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API Gateway
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming server
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration server
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A typical call may involve more than four or five components. These are the
    important questions to ask:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: How can we debug issues?
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we find out the root cause of a specific problem?
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A typical solution is centralized logging with a dashboard. Have all microservice
    logs consolidated in one place and offer a dashboard on top of it.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Distributed tracing options
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following screenshot shows the options for distributed tracing on the Spring
    Initializr website:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0c33890-b5cd-4c97-8ced-c4743479d3d1.png)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
- en: In this example, we will use a combination of Spring Cloud Sleuth and Zipkin
    Server to implement Distributed Tracing.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Spring Cloud Sleuth and Zipkin
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Spring Cloud Sleuth** provides features to uniquely trace a service call
    across different microservice components. **Zipkin** is a distributed tracing
    system that''s used to gather data needed to troubleshoot latency issues in microservices.
    We will be implementing a combination of Spring Cloud Sleuth and Zipkin to implement
    Distributed Tracing.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps involved:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: Integrate Microservice A, API Gateway, and the service consumer with Spring
    Cloud Sleuth.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up Zipkin Distributed Tracing Server.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Integrate Microservice A, API Gateway, and the service consumer with Zipkin.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Integrating microservice components with Spring Cloud Sleuth
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we call the add service on the service consumer, it will invoke Microservice
    A through API Gateway. To be able to track the service call across different components,
    we would need something unique assigned to the request flow across components.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Sleuth provides options to track a service call across different
    components using a concept called **span**. Each span has a unique 64-bit ID.
    The unique ID can be used to trace the call across components.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows the dependency for `spring-cloud-starter-sleuth`:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We need to add the preceding dependency on Spring Cloud Sleuth to the following
    three projects listed:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: Microservice A
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service consumer
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zuul API Gateway Server
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will start with tracing all the service requests across microservices. To
    be able to trace all the requests, we will need to configure an `AlwaysSampler`
    bean, as shown in the following snippet:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `AlwaysSampler` bean needs to be configured in the following microservice
    application classes:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '`MicroserviceAApplication`'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ServiceConsumerApplication`'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZuulApiGatewayServerApplication`'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we invoke the `add` service at `http://localhost:8765/service-consumer/add`,
    we will see the typical response:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'However, you will start to see a few more details in the log entries. A simple
    entry from the service consumer microservice log is shown here:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '`[service-consumer,d8866b38c3a4d69c,d8866b38c3a4d69c,true]`: The first value
    `service-consumer` is the application name. The key part is the second value--`d8866b38c3a4d69c`.
    This is the value that can be used to trace this request across other microservice
    components.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some other entries from the `service consumer` log:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The following is an extract from the `Microservice A` log:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The following is an extract from the `Zuul API Gateway` log:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: As you can see in the preceding log extracts, we can use the second value in
    the log--called span ID--to trace the service call across microservice components.
    In this example, the span ID is `d8866b38c3a4d69c`.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: However, this requires searching through logs of all the microservice components.
    One option is to implement a centralized log using something like an **ELK** (**Elasticsearch**,
    **Logstash**, and **Kibana**) stack. We will take the simpler option of creating
    a Zipkin Distributed Tracing service in the next step.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Zipkin Distributed Tracing Server
  id: totrans-483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use Spring Initializr ([http://start.spring.io](http://start.spring.io))
    to set up a new project. The following screenshot shows the GroupId, ArtifactId,
    and Dependencies to be selected:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b420b0f-5cb4-428f-a65a-e10742c7db39.png)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
- en: 'Dependencies include the following:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '**Zipkin Stream**: Multiple options exist to configure a Zipkin server. In
    this example, we will keep it simple by creating a standalone service listening
    on events and storing information in the memory.'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zipkin UI**: Provides a dashboard with the search functionality.'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stream Rabbit**: Used to bind the Zipkin stream with a RabbitMQ service.'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In production, you would want to have a more robust infrastructure. One option
    is to connect a permanent data store to the Zipkin Stream Server.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will add the `@EnableZipkinServer` annotation to the `ZipkinDistributedTracingServerApplication`
    class to enable auto-configuration for the Zipkin server. The following snippet
    shows the details:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We will use port `9411` to run the tracing server. The following snippet shows
    the configuration that needs to be added in the `application.properties` file:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'You can launch the Zipkin UI dashboard at `http://localhost:9411/`. The following
    is a screenshot of that. There is no data shown, as none of the microservices
    are connected to Zipkin yet:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4233d9fb-0328-42ed-80aa-6511bdf7ba01.png)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
- en: Integrating microservice components with Zipkin
  id: totrans-497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need to connect all the microservice components that we want to trace
    with `Zipkin server`. Here is the list of components we will start with:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: Microservice A
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service consumer
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zuul API Gateway Server
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All we need to do is add dependencies on `spring-cloud-sleuth-zipkin` and `spring-cloud-starter-bus-amqp`
    to the `pom.xml` file of the preceding projects:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Go ahead and execute the `add` service at `http://localhost:8100/add`. You
    can now see the details on the Zipkin dashboard. The following screenshot shows
    some of the details:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d8762f1-b0e0-480f-b201-64c3f10e556f.png)'
  id: totrans-505
  prefs: []
  type: TYPE_IMG
- en: 'The first two rows show the failed requests. The third row shows the details
    of a successful request. We can further dig in by clicking on the successful row.
    The following screenshot shows the details displayed:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/252a0775-6164-4905-8a47-8dc2daafedd8.png)'
  id: totrans-507
  prefs: []
  type: TYPE_IMG
- en: 'pent on each service. You can further dig in by clicking on the service bar.
    The following screenshot shows the details displayed:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98dae146-dfd7-48ad-b66d-9dc7a5a59e16.png)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
- en: In this section, we added distributed tracing for our microservices. We will
    now be able to visually track everything that is happening with our microservices.
    This will make it easy to track down and debug issues.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: Hystrix - fault tolerance
  id: totrans-511
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservice architectures are built with a number of microservice components.
    What if one microservice goes down? Would all dependent microservices fail and
    make the entire system collapse? Or would the error be gracefully handled and
    a degraded minimum functionality provided to the user? These questions decide
    the success of microservice architectures.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: Microservice architectures should be resilient and be able to handle service
    errors gracefully. Hystrix provides fault-tolerant capabilities to microservices.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-514
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will add Hystrix to our service consumer microservice and enhance the add
    service to return a basic response even when Microservice A is down.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with adding Hystrix Starter to the `pom.xml` file of service
    consumer microservice. The following snippet shows the dependency details:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Next, we would enable Hystrix auto-configuration by adding the `@EnableHystrix`
    annotation to the `ServiceConsumerApplication` class. The following snippet shows
    the details:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '`NumberAdderController` exposes a service with request mapping `/add`. This
    uses `RandomServiceProxy` to fetch random numbers. What if this service fails?
    Hystrix provides a fallback. The following snippet shows how we can add a fallback
    method to a request mapping. All we need to do is add the `@HystrixCommand` annotation
    to the `fallbackMethod` attribute, defining the name of the fallback method--in
    this example, `getDefaultResponse`:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Next, we define the `getDefaultResponse()` method with the same return type
    as the `add()` method. It returns a default hardcoded value:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Let''s bring down Microservice A and invoke `http://localhost:8100/add`. You
    will get the following response:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: When `Microservice A` fails, the service consumer microservice handles it gracefully
    and offers reduced functionality.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-527
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Cloud makes it easy to add Cloud-Native features to your microservices.
    In this chapter, we looked at some of the important patterns in developing Cloud-Native
    applications and implemented them using various Spring Cloud projects.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that the field of developing Cloud-Native applications
    is still in its inception phase--in its first few years. It would need more time
    to mature. Expect some evolution in patterns and frameworks in the years to come.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will shift our attention to Spring Data Flow. Typical
    use cases on the cloud include real-time data analytics and data pipelines. These
    use cases involve the flow of data between multiple microservices. Spring Data
    Flow provides patterns and best practices for distributed streaming and data pipelines.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
