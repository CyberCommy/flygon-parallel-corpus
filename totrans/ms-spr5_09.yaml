- en: Spring Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at some of the important patterns related to
    developing Cloud-Native applications and implementing them using projects under
    the umbrella of Spring Cloud. We will look at the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing centralized microservice configuration with Spring Cloud Config
    Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Spring Cloud Bus to synchronize configuration across microservice instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Feign to create declarative REST clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing client-side load balancing using Ribbon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Name server using Eureka
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing API Gateway using Zuul
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing distributed tracing using Spring Cloud Sleuth and Zipkin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Hystrix to implement fault tolerance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Spring Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 4](c4e1908a-b086-428c-8862-6474eb92f04a.xhtml), *Evolution toward
    Microservices and Cloud-Native Applications*, we discussed the problems with monolithic
    applications and how architectures evolved toward microservices. However, microservices
    have their own sets of challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: Organizations adopting microservice architectures also need to make challenging
    decisions around the consistency of microservices without affecting the innovation
    capabilities of the microservice teams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smaller applications mean more builds, releases, and deployments. This is usually
    addressed using more automation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservice architectures are built based on a large number of smaller, fine-grained
    services. There are challenges associated with managing configuration and availability
    of these services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging issues becomes more difficult because of the distributed nature of
    applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To reap maximum benefits from microservice architectures, microservices should
    be Cloud-Native--easily deployable on the Cloud. In [Chapter 4](c4e1908a-b086-428c-8862-6474eb92f04a.xhtml),
    *Evolution toward Microservices and Cloud-Native Applications*, we discussed the
    characteristics of Twelve-Factor Apps--patterns that are typically considered
    good practices in Cloud-Native applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Cloud aims to provide solutions to some commonly encountered patterns
    when building systems on the Cloud. Some of the important features include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to manage distributed microservice configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service registration and discovery using Name servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load balancing across multiple instances of microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More fault-tolerant services using circuit breakers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API Gateways for aggregation, routing, and caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed tracing across microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to understand that Spring Cloud is not a single project. It
    is a group of subprojects aimed at solving the problems associated with applications
    deployed on the Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some important Spring Cloud subprojects are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring Cloud Config**: Enables centralized external configuration across
    different microservices across different environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Cloud Netflix**: Netflix is one of the early adopters of microservice
    architecture. A number of internal Netflix projects were open sourced under the
    umbrella of Spring Cloud Netflix. Examples include Eureka, Hystrix, and Zuul.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Cloud Bus**: Makes it easier to build the integration of microservices
    with a lightweight message broker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Cloud Sleuth**: Along with Zipkin, this provides distributed tracing
    solutions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Cloud Data Flow**: Provides capabilities for building orchestration
    around microservice applications. Provides a DSL, GUI, and REST API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Cloud Stream**: Provides a simple declarative framework to integrate
    Spring-based (and Spring Boot)-based applications with message brokers such as
    Apache Kafka or RabbitMQ.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A few things are common to all projects under the Spring Cloud umbrella:'
  prefs: []
  type: TYPE_NORMAL
- en: They solve some of the common problems with developing applications on the Cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They provide great integration with Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are typically configured with simple annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They make extensive use of auto-configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Cloud Netflix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Netflix is one of the first organizations to start making the switch from monolithic
    to microservice architectures. Netflix has been very open about documenting this
    experience. Some of the internal Netflix frameworks are open sourced under the
    umbrella of Spring Cloud Netflix. As defined on the Spring Cloud Netflix website
    ([https://cloud.spring.io/spring-cloud-netflix/](https://cloud.spring.io/spring-cloud-netflix/)):'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Netflix provides Netflix OSS integrations for Spring Boot apps
    through autoconfiguration and binding to the Spring environment and other Spring
    programming model idioms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the important projects under the Spring Cloud Netflix umbrella are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Eureka**: The Name server that provides service registration and discovery
    capabilities for microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hystrix**: Capabilities to build fault-tolerant microservices through circuit
    breakers. Also provides a dashboard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feign**: Declarative REST Client makes it easy to call services created with
    JAX-RS and Spring MVC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ribbon**: Provides client-side load balancing capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zuul**: Provides typical API Gateways capabilities, such as routing, filtering,
    authentication, and security. It can be extended with custom rules and filters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demo microservices setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use two microservices to demonstrate concepts in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Microservice A**: A simple microservice exposing two services--one to retrieve
    a message from the configuration file and another `random service` providing a
    list of random numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service consumer microservice**: A simple microservice exposing a simple
    calculation service called the `add` service. The `add` service consumes the `random
    service` from **Microservice A** and adds the numbers up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows the relationship between the microservices and the
    services that are exposed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f95530f-f378-4100-8d83-68178a2f2052.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's quickly set up these microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice A
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use Spring Initializr ([https://start.spring.io](https://start.spring.io))
    to get started with Microservice A. Choose GroupId, ArtifactId, and the frameworks,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5c2a4b9-d95c-4bfb-a393-60b6f51486ee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will create a service to expose a set of random numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RequestMapping("/random") public List<Integer> random()`: Random service
    returns a list of random numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private int generateRandomNumber() {`: Generates random numbers between 0
    and 1000'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following snippet shows a sample response from the service at `http://localhost:8080/random`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next, we would want to create a service to return a simple message from the
    application configuration in `application.properties`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a simple application configuration with one property--`message`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@ConfigurationProperties("application")`: Defines a class defining `application.properties`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private String message`: Defines one property--`message`. The value can be
    configured in `application.properties` with `application.message` as the key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s configure `application.properties`, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring.application.name=microservice-a`: `spring.application.name` is used
    to give a name to the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application.message=Default Message`: Configures a default message for `application.message`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a controller to read the message and return it, as shown in the
    following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Autowired private ApplicationConfiguration configuration`: Autowires `ApplicationConfiguration`
    to enable reading the configured message value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestMapping("/message") public Map<String, String> welcome()`: Exposes
    a simple service at the URI/`message`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map.put("message", configuration.getMessage())`: The service returns a map
    with one entry. It has a key message and the value is picked up from the `ApplicationConfiguration`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the service is executed at `http://localhost:8080/message`, we get the
    following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Service consumer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s set up another simple microservice to consume the `random service` exposed
    by Microservice A. Let''s use Spring Initializr ([https://start.spring.io](https://start.spring.io))
    to initialize the microservice, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40200b6e-6840-47ea-94e5-41933a590a89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s add the service to consume `random service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Value("${number.service.url}") private String numberServiceUrl`: We would
    want the number service URL to be configurable in application properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestMapping("/add") public Long add()`: Exposes a service at the URI `/add`.
    The `add` method calls the number service using `RestTemplate` and has the logic
    to sum the numbers returned in the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s configure `application.properties`, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring.application.name=service-consumer`: Configures a name for the Spring
    Boot application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`server.port=8100`: Uses `8100` as the port for service consumer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number.service.url=http://localhost:8080/random`: Configures the number service
    URL for use in the add service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the service is called at the URL `http://localhost:8100/add`, the following
    response is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an extract from the log of Microservice A:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The log shows that `random service` from Microservice A returned `5` numbers.
    The `add` service in the service consumer added them up and returned a result
    `2890`.
  prefs: []
  type: TYPE_NORMAL
- en: We now have our example microservices ready. In the next steps, we will add
    Cloud-Native features to these microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Ports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create six different microservices applications and
    components. To keep things simple, we will use specific ports for specific applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the ports that we would reserve for use by the different
    applications created in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Microservice component** | **Port(s) used** |'
  prefs: []
  type: TYPE_TB
- en: '| Microservice A | `8080` and `8081` |'
  prefs: []
  type: TYPE_TB
- en: '| Service consumer microservice | `8100` |'
  prefs: []
  type: TYPE_TB
- en: '| Config Server (Spring Cloud Config) | `8888` |'
  prefs: []
  type: TYPE_TB
- en: '| Eureka server (Name server) | `8761` |'
  prefs: []
  type: TYPE_TB
- en: '| Zuul API Gateway Server | `8765` |'
  prefs: []
  type: TYPE_TB
- en: '| Zipkin Distributed Tracing Server | `9411` |'
  prefs: []
  type: TYPE_TB
- en: We have two of our microservices ready. We are ready to Cloud-enable our microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Centralized microservice configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Cloud Config provides solutions to externalize the configuration of a
    microservice. Let's first understand the need to externalize microservice configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Problem statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In microservice architectures, we typically have a number of small microservices
    interacting with each other instead of a set of big monolithic applications. Each
    microservice is typically deployed in multiple environments--development, testing,
    load test, staging, and production. In addition, there can be multiple instances
    of microservices in different environments. For example, a specific microservice
    might be handling heavy load. There might be multiple production instances for
    that microservice in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration of an application typically contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Database configuration**: Details needed to connect to the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message broker configuration**: Any configuration needed to connect to AMQP
    or similar resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External services configuration**: Other services that the microservice needs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservice configuration**: Typical configuration related to the business
    logic of the microservice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each instance of a microservice can have its own configuration--different databases,
    different external services it consumes, among others. For example, if a microservice
    is deployed in five environments and there are four instances in each environment,
    the microservice can have a total of 20 different configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows typical configurations needed for Microservice A.
    We are looking at two instances in development, three instances in QA, one instance
    in the stage, and four instances in production:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45098e73-511a-4ffa-b328-1d75af0ed801.png)'
  prefs: []
  type: TYPE_IMG
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintaining configurations for different microservices separately would make
    it difficult for the operations team. The solution, as shown in the following
    figure, is to create a centralized **Configuration Server:**
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e0b5e0b-9d9f-43c0-9b90-f45f180b24a8.png)'
  prefs: []
  type: TYPE_IMG
- en: The centralized **Configuration Server** holds all the configuration belonging
    to all the different microservices. This helps in keeping the configuration separate
    from the application deployable.
  prefs: []
  type: TYPE_NORMAL
- en: The same deployable (EAR or WAR) can be used in different environments. However,
    all configuration (things that vary between different environments) will be stored
    in the centralized configuration server.
  prefs: []
  type: TYPE_NORMAL
- en: An important decision that needs to be made would be to decide whether there
    are separate instances of centralized configuration servers for different environments.
    Typically, you would want access to your production configuration to be more restrictive
    compared to other environments. At a minimum, we recommend a separate centralized
    configuration server for production. Other environments can share one instance
    of the configuration server.
  prefs: []
  type: TYPE_NORMAL
- en: Options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following screenshot shows the options provided in Spring Initializer for
    Cloud Config Servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7de9ab8a-1b96-4a33-8537-ffa0e4ccf592.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we will configure a Cloud Config Server using Spring Cloud
    Config.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Cloud Config provides support for centralized microservice configuration.
    It is a combination of two important components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring Cloud Config Server**: Provides support for exposing centralized configuration
    backed up by a version control repository--GIT or subversion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Cloud Config Client**: Provides support for applications to connect
    to Spring Cloud Config Server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows a typical microservice architecture using Spring
    Cloud Config. The configuration for multiple microservices is stored in a single
    **GIT** repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79fd2b15-8bbf-4ed8-aad9-ff7e3d01615f.png)'
  prefs: []
  type: TYPE_IMG
- en: Implementing Spring Cloud Config Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following figure shows the updated implementation of Microservice A and
    service consumer with Spring Cloud Config. In the following figure, we will integrate
    Microservice A with Spring Cloud Config in order to retrieve its configuration
    from the local Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6c0b98f-7daf-4148-93f0-7ccb6a9969c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Implementing Spring Cloud Config needs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Spring Cloud Config server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up a local Git repository and connecting it to Spring Cloud Config server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating Microservice A to use the configuration from Cloud Config Server--using
    Spring Cloud Config Client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up Spring Cloud Config Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s set up the Cloud Config Server using Spring Initializr ([http://start.spring.io](http://start.spring.io)).
    The following screenshot shows GroupId and ArtifactId to choose. Make sure that
    you select Config Server as a dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13a42290-1416-41f5-a85b-bbdaeb6d73ce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to add the Config Server to an existing application, use the dependency
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the project is created, the first step is to add the `EnableConfigServer`
    annotation. The following snippet shows the annotation added to `ConfigServerApplication`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Connecting Spring Cloud Config Server to a local Git repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Config Server needs to be connected to a Git repository. To keep things
    simple, let's connect to a local Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: You can install Git for your specific operating system from [https://git-scm.com](https://git-scm.com).
  prefs: []
  type: TYPE_NORMAL
- en: The following commands help you set a simple local Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to a directory of your choice after installing Git. Execute the following
    commands on a terminal or Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `microservice-a.properties` in the `git-localconfig-repo`
    folder with the content shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the following commands to add and commit `microservice-a.properties`
    to a local Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the local Git repository ready with our configuration, we
    would need to connect the Config Server to it. Let''s configure `application.properties`
    in `config-server`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Some important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`server.port=8888`: Configures the port for Config Server. `8888` is typically
    the most commonly used port for Config Server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring.cloud.config.server.git.uri=file:///in28Minutes/Books/MasteringSpring/git-localconfig-repo`:
    Configures the URI to the local Git repository. If you want to connect to a remote
    Git repository, you can configure the URI of the Git repository here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start the server. When you hit the URL `http://localhost:8888/microservice-a/default`,
    you will see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Some important things to understand are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8888/microservice-a/default`: The URI format is `/{application-name}/{profile}[/{label}]`.
    Here, the `application-name` is `microservice-a` and the profile is `default`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service returns the configuration from `microservice-a.properties` since
    we are using the default profile. You can see it in the response in the `propertySources`>`name`
    field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"source":{"application.message":"Message From Default Local Git Repository"}`:
    The content of the response is the content of the property file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an environment-specific configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a specific configuration for Microservice A for the `dev` environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file in `git-localconfig-repo` with the name `microservice-a-dev.properties`
    with the content shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the following commands to `add` and `commit` `microservice-a-dev.properties`
    to the local Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When you hit the URL `http://localhost:8888/microservice-a/dev`, you will see
    the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The response contains the `dev` configuration from `microservice-a-dev.properties`.
    The configuration from the default property file (`microservice-a.properties`)
    is also returned. Properties configured in `microservice-a-dev.properties` (environment-specific
    properties) have higher priority than the defaults configured in `microservice-a.properties`.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to `dev`, a separate configuration for Microservice A can be created
    for different environments. If there is a need for multiple instances in a single
    environment, a tag can be used to differentiate. A URL of the format `http://localhost:8888/microservice-a/dev/{tag}`
    can be used to retrieve configuration based on the specific tag.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to connect Microservice A to the Config Server.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Config Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use Spring Cloud Config Client to connect `Microservice A` to `Config
    Server`. The dependency is shown here. Add the following code to the `pom.xml`
    file of `Microservice A`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Dependencies for Spring Cloud are managed differently from Spring Boot. We
    will use dependency management to manage dependencies. The following snippet will
    ensure that the correct version of all Spring Cloud dependencies is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Rename `application.properties` in `Microservice A` to `bootstrap.properties`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure it as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Since we would want `Microservice A` to connect to `Config Server`, we provide
    the URI of `Config Server` using `spring.cloud.config.uri`. Cloud Config Server
    is used to retrieve the configuration for microservice A. Hence, the configuration
    is provided in `bootstrap.properties`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring Cloud Context**: Spring Cloud introduces a few important concepts
    for the Spring application deployed in the Cloud. The Bootstrap Application Context
    is an important concept. It is the parent context for the microservice application.
    It is responsible for loading an external configuration (for example, from Spring
    Cloud Config Server) and Decrypting Configuration Files (external and local).
    The Bootstrap context is configured using bootstrap.yml or bootstrap.properties.
    We had to change the name of application.properties to bootstrap.properties in
    Microservice A earlier because we want Microservice A to use the Config Server
    for bootstrapping.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An extract from the log when Microservice A is restarted is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `Microservice A` service is using the configuration from `Spring Config
    Server` at `http://localhost:8888`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the response when `Message Service` at `http://localhost:8080/message`
    is invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The message is picked up from the `localconfig-repo/microservice-a.properties`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set the active profile to `dev` to pick up the dev configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The configuration for the service consumer microservice can also be stored in
    `local-config-repo` and exposed using Spring Config Server.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Bus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Cloud Bus makes it seamless to connect microservices to lightweight message
    brokers, such as Kafka and RabbitMQ.
  prefs: []
  type: TYPE_NORMAL
- en: The need for Spring Cloud Bus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider an example of making a configuration change in a microservice. Let''s
    assume that there are five instances of `Microservice A` running in production.
    We would need to make an emergency configuration change. For example, let''s make
    a change in `localconfig-repo/microservice-a.properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For `Microservice A` to pick up this configuration change, we need to invoke
    a `POST` request on `http://localhost:8080/refresh`. The following command can
    be executed at command prompt to send a `POST` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the configuration change reflected at `http://localhost:8080/message`.
    The following is the response from the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We have five instances of Microservice A running. The change in configuration
    is reflected only for the instance of the Microservice A where the URL is executed.
    The other four instances will not receive the configuration change until the refresh
    request is executed on them.
  prefs: []
  type: TYPE_NORMAL
- en: If there are a number of instances of a microservice, then executing the refresh
    URL for each instance becomes cumbersome since you would need to do this for every
    configuration change.
  prefs: []
  type: TYPE_NORMAL
- en: Propogating configuration changes using Spring Cloud Bus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The solution is to use Spring Cloud Bus to propagate the configuration change
    to multiple instances over a message broker such as RabbitMQ.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows how different instances of a microservice (actually,
    they can be completely different microservices as well) are connected to a message
    broker using Spring Cloud Bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be9ea549-8fe5-4744-be5a-3a007351da74.png)'
  prefs: []
  type: TYPE_IMG
- en: Each microservice instance will register with the Spring Cloud Bus at application
    startup.
  prefs: []
  type: TYPE_NORMAL
- en: When refresh is called on one of the microservice instances, Spring Cloud Bus
    will propagate a change event to all the microservice instances. The microservice
    instances will request the updated configuration from the configuration server
    on receiving the change event.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use RabbitMQ as the message broker. Ensure that you have installed and
    started up RabbitMQ before proceeding further.
  prefs: []
  type: TYPE_NORMAL
- en: Installation instructions for RabbitMQ are provided at [https://www.rabbitmq.com/download.html](https://www.rabbitmq.com/download.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to add connectivity to Spring Cloud Bus for `Microservice
    A`. Let''s add the following dependency in the `pom.xml` file of Microservice
    A:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run `Microservice A` on different ports by providing the port as one
    of the startup VM arguments. The following screenshot shows how you can configure
    the server port as the VM argument in Eclipse. The value configured is `-Dserver.port=8081`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40b004ac-c709-40f6-8f50-9b0b4b602ac5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will run Microservice A on ports `8080` (default) and `8081`. The following
    is an extract from the log when Microservice A is restarted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: All instances of `Microservice A` are registered with `Spring Cloud Bus` and
    listen to events on the Cloud Bus. The default configuration of RabbitMQ Connection
    is a result of the magic of autoconfiguration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update `microservice-a.properties` with a new message now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Commit the file and fire a request to refresh the configuration on one of the
    instances, let''s say port `8080`, using the URL `http://localhost:8080/bus/refresh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an extract from the log of the second instance of `Microservice
    A` running on port `8081`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can see that even though the refresh URL is not called on port `8081`, the
    updated message is picked up from the Config Server. This is because all instances
    of Microservice A are listening on the Spring Cloud Bus for change events. As
    soon as the refresh URL is called on one of the instances, it triggers a change
    event and all other instances pick up the changed configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the configuration change reflect in both instances of Microservice
    A at `http://localhost:8080/message` and `http://localhost:8081/message`. The
    following is the response from the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Declarative REST Client - Feign
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Feign helps us create REST clients for REST services with minimum configuration
    and code. All you need to define is a simple interface and use proper annotations.
  prefs: []
  type: TYPE_NORMAL
- en: '`RestTemplate` is typically used to make REST service calls. Feign helps us
    write REST clients without the need for `RestTemplate` and the logic around it.'
  prefs: []
  type: TYPE_NORMAL
- en: Feign integrates well with Ribbon (client-side load balancing) and Eureka (Name
    server). We will look at this integration later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Feign, let''s add the Feign starter to the `pom.xml` file of service
    consumer microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add `dependencyManagement` for Spring Cloud to the `pom.xml` file
    as this is the first Cloud dependency that service consumer microservice is using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to add the annotation in order to enable scanning for Feign
    clients to `ServiceConsumerApplication`. The following snippet shows the usage
    of the `@EnableFeignClients` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to define a simple interface to create a Feign client for a `random
    service`. The following snippet shows the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Some important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@FeignClient(name ="microservice-a", url="localhost:8080")`: The `FeignClient`
    annotation is used to declare that a REST client with the given interface needs
    to be created. We are hardcoding the URL of `Microservice A` for now. Later, we
    will look at how we can connect this to a Name server and eliminate the need for
    hardcoding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestMapping(value = "/random", method = RequestMethod.GET)`: This specific
    GET service method is exposed at the URI `/random`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public List<Integer> getRandomNumbers()`: This defines the interface of the
    service method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s update `NumberAdderController` to use `RandomServiceProxy` in order
    to call the service. The following snippet shows the important details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Autowired private RandomServiceProxy randomServiceProxy`: `RandomServiceProxy`
    is autowired in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<Integer> numbers = randomServiceProxy.getRandomNumbers()`: Look at how
    simple it is to use the Feign client. No playing around with `RestTemplate` anymore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we invoke the `add` service in service consumer microservice at `http://localhost:8100/add`,
    you will get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'GZIP compression can be enabled on Feign requests by configuring it, as shown
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Load balancing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices are the most important building blocks of Cloud-Native architectures.
    Microservice instances are scaled up and down based on the load of a specific
    microservice. How do we ensure that the load is equally distributed among the
    different instances of microservices? That's where the magic of load balancing
    comes in. Load balancing is important in order to ensure that the load is equally
    distributed among the different instances of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Ribbon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As shown in the following figure, Spring Cloud Netflix Ribbon provides client-side
    load balancing using round robin execution among the different instances of a
    microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb2fee3a-ecb1-46be-acaa-6e61b51f88f7.png)'
  prefs: []
  type: TYPE_IMG
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will add Ribbon to service consumer microservice. The service consumer microservice
    will distribute the load among two instances of Microservice A.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with adding the Ribbon dependency to the `pom.xml` file of service
    consumer microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can configure the URLs for the different instances of Microservice
    A. Add the following configuration to `application.properties` in service consumer
    microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then specify the `@RibbonClient` annotation on the service proxy--`RandomServiceProxy`
    in this example. The `@RibbonClient` annotation is used to specify declarative
    configuration for a ribbon client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When you restart the service consumer microservice and hit the add service
    at `http://localhost:8100/add`, you will get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This request is handled by an instance of `Microservice A` running on port
    `8080`, An extract from the log is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'When we hit the add service again at the same URL, `http://localhost:8100/add`
    we get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this time, the request is handled by an instance of `Microservice
    A` running on port `8081`. An extract from the log is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We have now successfully distributed the load among the different instances
    of `Microservice A`. While this can be improved further, this is a good start.
  prefs: []
  type: TYPE_NORMAL
- en: 'While round robin (`RoundRobinRule`) is the default algorithm used by Ribbon,
    there are other options available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AvailabilityFilteringRule` will skip servers that are down and that have a
    number of concurrent connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WeightedResponseTimeRule` will pick the server based on the response times.
    If a server takes a long time to respond, it will get fewer requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The algorithm to be used can be specified in the application configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `microservice-a` is the name of the service we specified in the `@RibbonClient(name="microservice-a")`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the architecture for the components we have set
    up already:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/420f239b-4d07-43cf-9da0-45c96c08afd5.png)'
  prefs: []
  type: TYPE_IMG
- en: The Name server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservice architectures involve a number of smaller microservices interacting
    with each other. Adding to this, there can be multiple instances of each microservice.
    Maintaining the external service connections and configurations manually would
    be difficult as new instances of microservices are dynamically created and destroyed.
    Name servers provide features of service registration and service discovery. Name
    servers allow microservices to register themselves and also discover the URLs
    to other microservices they want to interact with.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of hard coding microservice URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous example, we added the following configuration to `application.properties`
    in the service consumer microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This configuration represents all instances of Microservice A. Take a look
    at these situations:'
  prefs: []
  type: TYPE_NORMAL
- en: A new instance of Microservice A is created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An existing instance of Microservice A is no longer available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservice A is moved to a different server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all these instances, the configuration needs to be updated and the microservices
    refreshed in order to pick up the changes.
  prefs: []
  type: TYPE_NORMAL
- en: Workings of Name server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Name server is an ideal solution for the preceding situation. The following
    diagram shows how Name servers work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22015697-765e-438b-a8f4-5e285ca86d00.png)'
  prefs: []
  type: TYPE_IMG
- en: All microservices (different microservices and all their instances) will register
    themselves with the Name server as each microservice starts up. When a service
    consumer wants to get the location of a specific microservice, it requests the
    Name server.
  prefs: []
  type: TYPE_NORMAL
- en: A unique microservice ID is assigned to each microservice. This is used as a
    key in the register request and the lookup request.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices can automatically register and unregister themselves. Whenever
    a service consumer looks up the Name server with a microservice ID, it will get
    the list of the instances of that specific microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following screenshot shows the different options available for service
    discovery in Spring Initializr ([http://start.spring.io](http://start.spring.io)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e421967-7dbf-41d7-b286-de6c55fe5371.png)'
  prefs: []
  type: TYPE_IMG
- en: We are going to use Eureka as the Name server for service discovery in our example.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The implementation of Eureka for our example involves the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up `Eureka Server`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating `Microservice A` instances to register with `Eureka Server`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating service consumer microservice to use the Microservice A instances registered
    with `Eureka Server`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up a Eureka Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use Spring Initializr ([http://start.spring.io](http://start.spring.io))
    to set up a new project for Eureka Server. The following screenshot shows the
    GroupId, ArtifactId, and Dependencies to be selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34156e01-00c7-40d9-b4f6-7a0d97564ee1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to add the `EnableEurekaServer` annotation to the `SpringBootApplication`
    class. The following snippet shows the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The following snippet shows the configuration in `application.properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We are using port `8761` for `Eureka Naming Server`. Launch `EurekaServerApplication`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A screenshot of the Eureka dashboard at `http://localhost:8761` is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bae8f703-7072-4d30-9565-3856e9361326.png)'
  prefs: []
  type: TYPE_IMG
- en: As of now, there are no applications registered with Eureka. In the next step,
    let's register `Microservice A` and other services with Eureka.
  prefs: []
  type: TYPE_NORMAL
- en: Registering microservices with Eureka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To register any microservice with the Eureka Name server, we would need to
    add the dependency on Eureka Starter project. The following dependency needs to
    be added to the `pom.xml` file of Microservice A:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to add `EnableDiscoveryClient` to the `SpringBootApplication`
    classes. An example of `MicroserviceAApplication` is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Spring Cloud Commons hosts the common classes used in different Spring Cloud
    implementations. A good example is the `@EnableDiscoveryClient` annotation. Different
    implementations are provided by Spring Cloud Netflix Eureka, Spring Cloud Consul
    Discovery, and Spring Cloud Zookeeper Discovery.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will configure the URL of the naming server in the application configuration.
    For Microservice A, the application configuration is in the local Git repository
    file, `git-localconfig-repomicroservice-a.properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'When both instances of `Microservice A` are restarted, you will see these messages
    in the log of `Eureka Server`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'A screenshot of the Eureka Dashboard at `http://localhost:8761` is shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7a2ac1a-75f3-4e97-9c80-acdc3626c287.png)'
  prefs: []
  type: TYPE_IMG
- en: Two instances of `Microservice A` are now registered with `Eureka Server`. Similar
    updates can be done on `Config Server` in order to connect it to `Eureka Server`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we would want to connect the service consumer microservice
    to pick up URLs of instances of Microservice A from the Eureka server.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the service consumer microservice with Eureka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Eureka starter project needs to be added as a dependency in the `pom.xml`
    file of the service consumer microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Currently, the URLs of the different instances of `Microservice A` are hardcoded
    in the service consumer microservice, as shown here, in `application.properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'However, now we would not want to hardcode Microservice A URLs. We would want
    the service consumer microservice to get the URLs from `Eureka Server`. We do
    that by configuring the URL of `Eureka Server` in the `application.properties`
    of the service consumer microservice. We will comment out the hardcoding of the
    Microservice A URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add `EnableDiscoveryClient` on the `ServiceConsumerApplication`
    class, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the service consumer microservice is restarted, you will see that it will
    register itself with `Eureka Server`. The following is an extract from the log
    of `Eureka Server`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In `RandomServiceProxy`, we have already configured a name for `microservice-a`
    on the Feign client, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The service consumer microservice will use this ID (Microservice A) to query
    `Eureka Server` for instances. Once it gets the URLs from `Eureka Service`, it
    will invoke the service instance selected by Ribbon.
  prefs: []
  type: TYPE_NORMAL
- en: When the `add` service is invoked at `http://localhost:8100/add`, it returns
    an appropriate response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a quick review of the different steps involved:'
  prefs: []
  type: TYPE_NORMAL
- en: As each instance of Microservice A starts up, it registers with `Eureka Name
    Server`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The service consumer microservice requests `Eureka Name Server` for instances
    of Microservice A.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The service consumer microservice uses the Ribbon client-side load balancer
    to decide the specific instance of Microservice A to call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The service consumer microservice calls a specific instance of Microservice
    A.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The biggest advantage of `Eureka Service` is that service consumer microservice
    is now decoupled from Microservice A. Whenever new instances of Microservice A
    come up or an existing instance goes down, the service consumer microservice does
    not need to be reconfigured.
  prefs: []
  type: TYPE_NORMAL
- en: API Gateways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Microservices have a number of cross-cutting concerns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication, authorization, and security**: How do we ensure that the
    microservice consumers are who they claim to be? How do we ensure that the consumers
    have the right access to microservices?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rate limits** : There might be different kinds of API plans for consumers
    and different limits (the number of microservice invocations) for each plan. How
    do we enforce the limits on a specific consumer?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic routing**: Specific situations (for example, a microservice is down)
    might need dynamic routing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service aggregation**: The UI needs for a mobile are different from the desktop.
    Some microservice architectures have service aggregators tailored for a specific
    device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fault tolerance**: How do we ensure that failure in one microservice does
    not cause the entire system to crash?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When microservices talk directly with each other, these concerns have to be
    addressed by individual microservices. This kind of architecture might be difficult
    to maintain because each microservice might handle these concerns differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common solutions is to use an API Gateway. All service calls
    to and between microservices should go through an API Gateway. API Gateway typically
    provide these features for microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate limiting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insights and monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic routing and static response handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load shedding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregation of responses from multiple services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing client-side load balancing with Zuul
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Zuul is part of the Spring Cloud Netflix project. It is an API Gateway service
    that provides the capabilities of dynamic routing, monitoring, filtering, security,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing Zuul as an API Gateway involves the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a new Zuul API Gateway Server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring Service Consumer to use Zuul API Gateway.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up a new Zuul API Gateway Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use Spring Initializr ([http://start.spring.io](http://start.spring.io))
    to set up a new project for Zuul API Gateway. The following screenshot shows the
    GroupId, ArtifactId, and Dependencies to be selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1245756e-84eb-45bb-968b-6f3f1a365335.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to enable Zuul proxy on the Spring Boot application. This
    is done by adding the `@EnableZuulProxy` annotation on the `ZuulApiGatewayServerApplication`
    class. The following snippet shows the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We will run Zuul Proxy on port `8765`. The following snippet shows the configuration
    needed in `application.properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We are configuring the port for Zuul proxy and connecting it to the Eureka Name
    server as well.
  prefs: []
  type: TYPE_NORMAL
- en: Zuul custom filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Zuul provides options to create custom filters to implement typical API Gateway
    functionality, such as authentication, security, and tracing. In this example,
    we will create a simple logging filter to log every request. The following snippet
    shows the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SimpleLoggingFilter extends ZuulFilter`: `ZuulFilter` is the base abstract
    class to create filters for Zuul. Any filter should implement the four methods
    listed here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public String filterType()`: Possible return values are `"pre"` for prerouting
    filtering, `"route"` for routing to an origin, `"post"` for postrouting filters,
    and `"error"` for error handling. In this example, we would want to filter before
    the request is executed. We return a value `"pre"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public int filterOrder()`: Defines the precedence for a filter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public boolean shouldFilter()`: If the filter should only be executed in certain
    conditions, the logic can be implemented here. If you would want the filter to
    always be executed, return `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public Object run()`: The method to implement the logic for the filter. In
    our example, we are logging the request method and the URL of the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we start up the Zuul server by launching `ZuulApiGatewayServerApplication`
    as a Java application, you will see the following log in `Eureka Name Server`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This shows that `Zuul API gateway` is up and running. `Zuul API gateway` is
    also registered with `Eureka Server`. This allows microservice consumers to talk
    to the Name server to get details about `Zuul API gateway`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the Eureka dashboard at `http://localhost:8761`.
    You can see that instances of `Microservice A`, `service consumer`, and `Zuul
    API Gateway` are now registered with `Eureka Server`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0c5df38-8927-4286-8d5a-1ee980808a23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is an extract from the `Zuul API gateway` log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: By default, all services in Microservice A and the service consumer microservice
    are enabled for reverse proxying by Zuul.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking microservices through Zuul
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's invoke `random service` through the service proxy now. The direct URL
    to a random microservice is `http://localhost:8080/random`. This is exposed by
    Microservice A, whose application name is `microservice-a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The URL structure to call a service through `Zuul API Gateway` is `http://localhost:{port}/{microservice-application-name}/{service-uri}`.
    So, the `Zuul API Gateway` URL for `random service` is `http://localhost:8765/microservice-a/random`.
    When you invoke `random service` through API Gateway, you get a response shown
    here. The response is similar to what you would typically get when directly calling
    the random service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an extract from the `Zuul Api Gateway` log. You can see that
    the `SimpleLoggingFilter` that we created in `Zuul API Gateway` is executed for
    the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The `add` service is exposed by service consumer, whose application name is
    service-consumer and the service URI is `/add`. So, the URL to execute the `add`
    service through the API Gateway is `http://localhost:8765/service-consumer/add`.
    The response from the service is shown here. The response is similar to what you
    would typically get when directly calling the `add` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an extract from the `Zuul API Gateway` log. You can see that
    the initial `add` service call is going through the API Gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `add` service calls `random service` on `Microservice A`. While the initial
    call to add service goes through the API Gateway, the call from add service (service
    consumer microservice) to `random service` (Microservice A) is not routed through
    API Gateway. In an ideal world, we would want all the communication to take place
    through API Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, let's make the requests from the service consumer microservice
    go through the API Gateway as well.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring service consumer to use Zuul API gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code shows the existing configuration of `RandomServiceProxy`,
    which is used to call `random service` on `Microservice A`. The name attribute
    in the `@FeignClient` annotation is configured to use the application name of
    Microservice A. The request mapping uses the `/random` URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want the call to go through the API Gateway. We would need to use the
    application name of the API Gateway and the new URI of `random service` in the
    request mapping. The following snippet shows the updated `RandomServiceProxy`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'When we invoke the add service at `http://localhost:8765/service-consumer/add`,
    we will see the typical response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'However, now we will see more things happen on `Zuul API gateway`. The following
    is an extract from the `Zuul API gateway` log. You can see that the initial add
    service call on the service consumer, as well as the `random service` call on
    `Microservice A`, are now being routed through the API Gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: We saw a basic implementation of a simple logging filter on `Zuul API Gateway`.
    A similar approach can be used to implement filters for other cross-cutting concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In typical microservice architectures, there are a number of components involved.
    A few of them are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Different microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API Gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A typical call may involve more than four or five components. These are the
    important questions to ask:'
  prefs: []
  type: TYPE_NORMAL
- en: How can we debug issues?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we find out the root cause of a specific problem?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A typical solution is centralized logging with a dashboard. Have all microservice
    logs consolidated in one place and offer a dashboard on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed tracing options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following screenshot shows the options for distributed tracing on the Spring
    Initializr website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0c33890-b5cd-4c97-8ced-c4743479d3d1.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we will use a combination of Spring Cloud Sleuth and Zipkin
    Server to implement Distributed Tracing.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Spring Cloud Sleuth and Zipkin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Spring Cloud Sleuth** provides features to uniquely trace a service call
    across different microservice components. **Zipkin** is a distributed tracing
    system that''s used to gather data needed to troubleshoot latency issues in microservices.
    We will be implementing a combination of Spring Cloud Sleuth and Zipkin to implement
    Distributed Tracing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps involved:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrate Microservice A, API Gateway, and the service consumer with Spring
    Cloud Sleuth.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up Zipkin Distributed Tracing Server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Integrate Microservice A, API Gateway, and the service consumer with Zipkin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Integrating microservice components with Spring Cloud Sleuth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we call the add service on the service consumer, it will invoke Microservice
    A through API Gateway. To be able to track the service call across different components,
    we would need something unique assigned to the request flow across components.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Sleuth provides options to track a service call across different
    components using a concept called **span**. Each span has a unique 64-bit ID.
    The unique ID can be used to trace the call across components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows the dependency for `spring-cloud-starter-sleuth`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add the preceding dependency on Spring Cloud Sleuth to the following
    three projects listed:'
  prefs: []
  type: TYPE_NORMAL
- en: Microservice A
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service consumer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zuul API Gateway Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will start with tracing all the service requests across microservices. To
    be able to trace all the requests, we will need to configure an `AlwaysSampler`
    bean, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AlwaysSampler` bean needs to be configured in the following microservice
    application classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MicroserviceAApplication`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ServiceConsumerApplication`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZuulApiGatewayServerApplication`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we invoke the `add` service at `http://localhost:8765/service-consumer/add`,
    we will see the typical response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you will start to see a few more details in the log entries. A simple
    entry from the service consumer microservice log is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '`[service-consumer,d8866b38c3a4d69c,d8866b38c3a4d69c,true]`: The first value
    `service-consumer` is the application name. The key part is the second value--`d8866b38c3a4d69c`.
    This is the value that can be used to trace this request across other microservice
    components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some other entries from the `service consumer` log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an extract from the `Microservice A` log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an extract from the `Zuul API Gateway` log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding log extracts, we can use the second value in
    the log--called span ID--to trace the service call across microservice components.
    In this example, the span ID is `d8866b38c3a4d69c`.
  prefs: []
  type: TYPE_NORMAL
- en: However, this requires searching through logs of all the microservice components.
    One option is to implement a centralized log using something like an **ELK** (**Elasticsearch**,
    **Logstash**, and **Kibana**) stack. We will take the simpler option of creating
    a Zipkin Distributed Tracing service in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Zipkin Distributed Tracing Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use Spring Initializr ([http://start.spring.io](http://start.spring.io))
    to set up a new project. The following screenshot shows the GroupId, ArtifactId,
    and Dependencies to be selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b420b0f-5cb4-428f-a65a-e10742c7db39.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Dependencies include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zipkin Stream**: Multiple options exist to configure a Zipkin server. In
    this example, we will keep it simple by creating a standalone service listening
    on events and storing information in the memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zipkin UI**: Provides a dashboard with the search functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stream Rabbit**: Used to bind the Zipkin stream with a RabbitMQ service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In production, you would want to have a more robust infrastructure. One option
    is to connect a permanent data store to the Zipkin Stream Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will add the `@EnableZipkinServer` annotation to the `ZipkinDistributedTracingServerApplication`
    class to enable auto-configuration for the Zipkin server. The following snippet
    shows the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use port `9411` to run the tracing server. The following snippet shows
    the configuration that needs to be added in the `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'You can launch the Zipkin UI dashboard at `http://localhost:9411/`. The following
    is a screenshot of that. There is no data shown, as none of the microservices
    are connected to Zipkin yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4233d9fb-0328-42ed-80aa-6511bdf7ba01.png)'
  prefs: []
  type: TYPE_IMG
- en: Integrating microservice components with Zipkin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need to connect all the microservice components that we want to trace
    with `Zipkin server`. Here is the list of components we will start with:'
  prefs: []
  type: TYPE_NORMAL
- en: Microservice A
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service consumer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zuul API Gateway Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All we need to do is add dependencies on `spring-cloud-sleuth-zipkin` and `spring-cloud-starter-bus-amqp`
    to the `pom.xml` file of the preceding projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Go ahead and execute the `add` service at `http://localhost:8100/add`. You
    can now see the details on the Zipkin dashboard. The following screenshot shows
    some of the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d8762f1-b0e0-480f-b201-64c3f10e556f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first two rows show the failed requests. The third row shows the details
    of a successful request. We can further dig in by clicking on the successful row.
    The following screenshot shows the details displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/252a0775-6164-4905-8a47-8dc2daafedd8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'pent on each service. You can further dig in by clicking on the service bar.
    The following screenshot shows the details displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98dae146-dfd7-48ad-b66d-9dc7a5a59e16.png)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we added distributed tracing for our microservices. We will
    now be able to visually track everything that is happening with our microservices.
    This will make it easy to track down and debug issues.
  prefs: []
  type: TYPE_NORMAL
- en: Hystrix - fault tolerance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservice architectures are built with a number of microservice components.
    What if one microservice goes down? Would all dependent microservices fail and
    make the entire system collapse? Or would the error be gracefully handled and
    a degraded minimum functionality provided to the user? These questions decide
    the success of microservice architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice architectures should be resilient and be able to handle service
    errors gracefully. Hystrix provides fault-tolerant capabilities to microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will add Hystrix to our service consumer microservice and enhance the add
    service to return a basic response even when Microservice A is down.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with adding Hystrix Starter to the `pom.xml` file of service
    consumer microservice. The following snippet shows the dependency details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we would enable Hystrix auto-configuration by adding the `@EnableHystrix`
    annotation to the `ServiceConsumerApplication` class. The following snippet shows
    the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '`NumberAdderController` exposes a service with request mapping `/add`. This
    uses `RandomServiceProxy` to fetch random numbers. What if this service fails?
    Hystrix provides a fallback. The following snippet shows how we can add a fallback
    method to a request mapping. All we need to do is add the `@HystrixCommand` annotation
    to the `fallbackMethod` attribute, defining the name of the fallback method--in
    this example, `getDefaultResponse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the `getDefaultResponse()` method with the same return type
    as the `add()` method. It returns a default hardcoded value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s bring down Microservice A and invoke `http://localhost:8100/add`. You
    will get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: When `Microservice A` fails, the service consumer microservice handles it gracefully
    and offers reduced functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Cloud makes it easy to add Cloud-Native features to your microservices.
    In this chapter, we looked at some of the important patterns in developing Cloud-Native
    applications and implemented them using various Spring Cloud projects.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that the field of developing Cloud-Native applications
    is still in its inception phase--in its first few years. It would need more time
    to mature. Expect some evolution in patterns and frameworks in the years to come.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will shift our attention to Spring Data Flow. Typical
    use cases on the cloud include real-time data analytics and data pipelines. These
    use cases involve the flow of data between multiple microservices. Spring Data
    Flow provides patterns and best practices for distributed streaming and data pipelines.
  prefs: []
  type: TYPE_NORMAL
