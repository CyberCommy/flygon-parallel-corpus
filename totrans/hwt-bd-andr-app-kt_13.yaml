- en: 13\. RxJava and Coroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will introduce you to doing background operations and data manipulations
    with RxJava and coroutines. It covers how to use RxJava to retrieve data from
    an external API and how to do that with coroutines. You'll also learn how to manipulate
    and display the data using RxJava operators and LiveData transformations.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to use RxJava to manage network
    calls in the background and use RxJava operators to transform data. You will also
    be able to perform network tasks in the background using Kotlin coroutines and
    manipulate data with LiveData transformations.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have now learned the basics of Android app development and implemented features
    such as RecyclerViews, notifications, fetching data from web services, and services.
    You've also gained skills in the best practices for testing and persisting data.
    In the previous chapter, you learned about dependency injection. Now, you will
    be learning about background operations and data manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Some Android applications work on their own. However, most apps would need a
    backend server to retrieve or process data. These operations may take a while,
    depending on the internet connection, device settings, and server specifications.
    If long-running operations are run in the main UI thread, the application will
    be blocked until the tasks are completed. The application might become unresponsive
    and might prompt the user to close it and stop using it.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this, tasks that can take an indefinite amount of time must be run
    asynchronously. An asynchronous task means it can run in parallel to another task
    or in the background. For example, while fetching data from a data source asynchronously,
    your UI can still display or interact with the users.
  prefs: []
  type: TYPE_NORMAL
- en: You can use libraries like RxJava and coroutines for asynchronous operations.
    We'll be discussing both of them in this chapter. Let's get started with RxJava.
  prefs: []
  type: TYPE_NORMAL
- en: RxJava
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RxJava is a Java implementation of **Reactive Extensions** (**Rx**), a library
    for reactive programming. In reactive programming, you have data streams that
    can be observed. When the value changes, your observers can be notified and react
    accordingly. For example, let's say clicking on a button is your observable and
    you have observers listening to it. If the user clicks on that button, your observers
    can react and do a specific action.
  prefs: []
  type: TYPE_NORMAL
- en: RxJava makes asynchronous data processing and handling errors simpler. Writing
    it the usual way is tricky and error-prone. If your task involves a chain of asynchronous
    tasks, it will be more complicated to write and debug. With RxJava, it can be
    done more easily and you will have less code, which is more readable and maintainable.
    RxJava also has a wide range of operators that you can use for transforming data
    into the type or format you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'RxJava has three main components: observables, observers, and operators. To
    use RxJava, you will need to create observables that emit data, transform the
    data using RxJava operators, and subscribe to the observables with observers.
    The observers can wait for the observables to produce data without blocking the
    main thread.'
  prefs: []
  type: TYPE_NORMAL
- en: Observables, Observers, and Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's understand the three main components of RxJava in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Observables**'
  prefs: []
  type: TYPE_NORMAL
- en: An observable is a source of data that can be listened to. It can emit data
    to its listeners.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Observable` class represents an observable. You can create observables
    from lists, arrays, or objects with the `Observable.just` and `Observable.from`
    methods. For example, you can create observables with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There are more functions that you can use to create observables, such as `Observable.create`,
    `Observable.defer`, `Observable.empty`, `Observable.generate`, `Observable.never`,
    `Observable.range`, `Observable.interval`, and `Observable.timer`. You can also
    make a function that returns an `observable`. Learn more about creating observables
    at [https://github.com/ReactiveX/RxJava/wiki/Creating-Observables](https://github.com/ReactiveX/RxJava/wiki/Creating-Observables).
  prefs: []
  type: TYPE_NORMAL
- en: Observables can be either hot or cold. Cold observables emit data only when
    they have subscribers listening. Examples are database queries or network requests.
    Hot observables, on the other hand, emits data even if there are no observers.
    Examples of this are UI events in Android like mouse and keyboard events.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have created an observable, the observers can start listening to the
    data the observable will send.
  prefs: []
  type: TYPE_NORMAL
- en: '**Operators**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operators allow you to modify and compose the data you get from the observable
    before passing it to the observers. Using an operator returns another observable
    so you can chain operator calls. For example, let''s say you have an observable
    that emits the numbers from 1 to 10\. You can filter it to only get even numbers
    and transform the list into another list containing each item''s square. To do
    that in RxJava, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The output of the preceding code will be a data stream with the values 4, 16,
    36, 64, and 100\.
  prefs: []
  type: TYPE_NORMAL
- en: '**Observers**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Observers subscribe to observables and are notified when the observers emit
    data. They can listen to the next value or error emitted by the observable. The
    `Observer` class is the interface for observers. It has four methods that you
    can override when making an observer:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onComplete`: When the observable has finished sending data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onNext`: When the observable has sent new data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onSubscribe`: When an observer is subscribed to an observable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onError`: When the observable encountered an error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To subscribe to an observable, you can call `Observable.subscribe()` passing
    in a new instance of the `Observer` interface. For example, if you want to subscribe
    to an observable of even numbers from `2` to `10`, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With this code, the observer will print the next integer. It will also print
    text when it has subscribed, when the observable is completed, and when it encounters
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: '`Observable.subscribe()` has different overloaded functions wherein you can
    pass the `onNext`, `onError`, `onComplete`, and `onSubscribe` parameters. These
    functions return a `disposable` object. You can call its `dispose` function when
    closing an activity to prevent memory leaks. For example, you can use a variable
    for the `disposable` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `onDestroy` function of the activity where you''ve made the observable,
    you can call `disposable.dispose()` to stop the observers from listening to the observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Aside from the observables, observers, and operators, you also need to learn
    about RxJava schedulers, which will be covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Schedulers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, RxJava is synchronous. This means all processes are done in the
    same thread. There are some tasks that take a while, such as database and network
    operations, which need to be made asynchronous or run in parallel in another thread.
    To do that, you need to use schedulers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Schedulers allow you to control the thread where the actions will be running.
    There are two functions you can use: `observeOn` and `subscribeOn`. You can set
    which thread your observable will run on with the `subscribeOn` function. The
    `observeOn` function allows you to set where the next operators will be executed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you have the `getData` function, which fetches data from the
    network and returns an observable, you can subscribe to `Schedulers.io` and observe
    the Android main UI thread with `AndroidSchedulers.mainThread()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`AndroidSchedulers` is part of RxAndroid, which is an extension of RxJava for
    Android. You will need RxAndroid to use RxJava in Android app development.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to add RxJava and RxAndroid to your
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Adding RxJava to Your Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can add RxJava to your project by adding the following code to your `app/build.gradle`
    file dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will add both the RxJava and RxAndroid libraries to your Android project.
    The RxAndroid library already includes RxJava but it is better to still add the
    RxJava dependency as the one bundled with RxAndroid might not be the latest version.
  prefs: []
  type: TYPE_NORMAL
- en: Using RxJava in an Android Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RxJava has several benefits, one of which is handling long-running operations
    such as network requests in a non-UI thread. The result of a network call can
    be converted to an observable. You can then create an observer that will subscribe
    to the observable and present the data. Before displaying the data to the user,
    you can transform the data with RxJava operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Retrofit, you can convert the response to an RxJava observable
    by adding a call adapter factory. First, you would need to add `adapter-rxjava3`
    in your `app/build.gradle` file dependencies with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, you can use `RxJava3CallAdapterFactory` as the call adapter in your
    `Retrofit` instance. You can do that with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, your Retrofit methods can return `Observable` objects that you can listen
    to in your code. For example, in your `getMovies` Retrofit method that calls your
    movie endpoint, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's try what you have learned so far by adding RxJava to an Android project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.01: Using RxJava in an Android Project'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this chapter, you will be working with an application that displays popular
    movies using The Movie Database API. Go to [https://developers.themoviedb.org/](https://developers.themoviedb.org/)
    and register for an API key. In this exercise, you will be using RxJava to fetch
    the list of all popular movies from the movie/popular endpoint, regardless of
    year:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project in Android Studio. Name your project `Popular Movies` and
    use the package name `com.example.popularmovies`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the location where you want to save the project, then click the `Finish` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `AndroidManifest.xml` and add the `INTERNET` permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will allow you to use the device's internet connection to do network calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your `app/build.gradle` file and add the kotlin-parcelize plugin at the
    end of the plugins block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will allow you to use Parcelable for the model class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following in the `android` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These will allow you to use Java 8 for your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following dependencies in your `app/build.gradle` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: These lines will add the RecyclerView, Glide, Retrofit, RxJava, RxAndroid, and
    Moshi libraries to your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `dimens.xml` file in the `res/values` directory and add a `layout_margin`
    dimension value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will be used for the vertical and horizontal margins of the views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new layout file named `view_movie_item.xml` and add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This layout file, containing the movie poster and title text, will be used for
    each movie in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `activity_main.xml`. Replace the Hello World TextView with RecyclerView:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This RecyclerView will be displaying the list of movies. It will be using `GridLayoutManager`
    with two columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new package, `com.example.popularmovies.model`, for your model class.
    Make a new model class named `Movie` with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will be the model class representing a `Movie` object from the API.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new activity named `DetailsActivity` with `activity_details.xml` as
    the layout file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `AndroidManifest.xml` file and add `MainActivity` as the value for
    the `parentActivityName` attribute of `DetailsActivity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This will add an up icon in the details activity to go back to the main screen.
  prefs: []
  type: TYPE_NORMAL
- en: Open `activity_details.xml`. Add the required views. (The code below is truncated
    for space. Refer to the file linked below for the full code that you need to add.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This will add the poster, title, release, and overview on the details screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `DetailsActivity` and add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will display the poster, title, release, and overview of the movie selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an adapter class for the movie list. Name the class `MovieAdapter`.
    Add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This class will be the adapter for your RecyclerView.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `ViewHolder` for your class after the `onBindViewHolder` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This will be the `ViewHolder` used by `MovieAdapter` for the RecyclerView.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below the `MovieViewHolder` declaration, add `MovieClickListener`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This interface will be used when clicking on a movie to view the details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another class named `PopularMoviesResponse` in the `com.example.popularmovies.model`
    package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This will be the model class for the response you get from the API endpoint
    for popular movies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new package, `com.example.popularmovies.api`, and add a `MovieService`
    interface with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This will define the endpoint you will be using to retrieve the popular movies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `MovieRepository` class with a constructor for `movieService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `apiKey` (with the value of the API key from The Movie Database API)
    and a `fetchMovies` function to retrieve the list from the endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an application class named `MovieApplication` with a property for `movieRepository`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This will be the application class for the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Override the `onCreate` function of the `MovieApplication` class and initialize
    `movieRepository`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Set `MovieApplication` as the value for the `android:name` attribute of the
    application in the `AndroidManifest.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `MovieViewModel` class with a constructor for `movieRepository`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Add properties for `popularMovies`, `error`, and `disposable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `fetchPopularMovies` function. Inside the function, get the popular
    movies from `movieRepository`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This will fetch the popular movies asynchronously in the `Schedulers.io` thread
    when subscribed and will return an observable and with operators on the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Override the `onCleared` function of the `MovieViewModel` and dispose of the `disposable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This will dispose of the `disposable` when the ViewModel has been cleared, like
    when the activity has been closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `MainActivity` and add define a field for the movie adapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This will have a listener that will open the details screen when a movie is
    clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `onCreate` function, set the adapter for the `movie_list` `RecyclerView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `getMovies` function on `MainActivity`. Inside, initialize `movieRepository`
    and `movieViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the `getMovies` function, add an observer to the `popularMovies`
    and `error` LiveData from `movieViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the `onCreate` function of the `MainActivity` class, call the
    `getMovies()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `openMovieDetails` function to open the details screen when clicking
    on a movie from the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your application. You will see that the app will display a list of popular
    movie titles:![Figure 13.1: How the Popular Movies app will look'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_13_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.1: How the Popular Movies app will look'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on a movie, and you will see its details, such as its release date and
    an overview:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.2: The movie details screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_13_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.2: The movie details screen'
  prefs: []
  type: TYPE_NORMAL
- en: You have learned how to use RxJava to retrieve the response from an external
    API. In the next section, you will convert the data you fetched into the data
    that you need to display with RxJava operators.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying Data with RxJava Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you have an observable that emits data, you can use operators to modify
    the data before passing it to the observers. You can use a single operator or
    a chain of operators to get the data that you want. There are different types
    of operators that you can use, such as transforming operators and filtering operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Transforming operators can modify items from the observable into your preferred
    data. The `flatMap()` operator transforms the items into an observable. In *Exercise
    13.01,* *Using RxJava in an Android Project*, you transformed the observable of
    `PopularMoviesResponse` into an observable of `Movies` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Another operator that can transform data is `map`. The `map(x)` operator applies
    a function `x` to each item and returns another observable with the updated values.
    For example, if you have an observable of a list of numbers, you can transform
    it into another observable list with each number multiplied by 2 with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Filtering operators allow you to select only some of the items. With `filter()`,
    you can select items based on a set condition. For example, you can filter odd
    numbers with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `first()` and `last()` operators allow you to get the first and last item,
    while with `take(n)` or `takeLast(n)`, you can get *n* first or last items. There
    are other filtering operators such as `debounce()`, `distinct()`, `elementAt()`,
    `ignoreElements()`, `sample()`, `skip()`, and `skipLast()`.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other RxJava operators you can use. Let's try to use RxJava operators
    in an Android project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.02: Using RxJava Operators'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous exercise, you used RxJava to fetch the list of popular movies
    from The Movie Database API. Now, before displaying them in RecyclerView, you
    will be adding operators to sort the movies by title and only get the movies released
    last month:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Popular Movies` project you did in *Exercise 13.01,* *Using RxJava
    in an Android Project*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `MovieViewModel` and navigate to the `fetchPopularMovies` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will be modifying the app to only display popular movies for this year.
    Replace `.map { it.results }` with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This will convert the Observable of `MovieResponse` into an observable of Movies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the `toList()` call, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This will select only the movies released in the previous month.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application. You will see that the other movies are no longer displayed.
    Only those released this year will be on the list:![Figure 13.3: The app with
    the year’s popular movies'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_13_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.3: The app with the year''s popular movies'
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll also notice that the movies displayed are not in alphabetical order.
    Sort the movies by using the `sorted` operator before the `toList()` call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This will sort the movies based on their titles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application. You will see that the list of movies is now sorted alphabetically
    by title:![Figure 13.4: The app with the year’s popular movies sorted by title'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_13_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.4: The app with the year''s popular movies sorted by title'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the `toList()` call, use the `map` operator to map the list of movies
    into another list whose title is in uppercase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application. You will see that the movie titles are now in uppercase letters:![Figure
    13.5: The app with the movie titles in uppercase'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_13_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.5: The app with the movie titles in uppercase'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the `toList()` call, use the `take` operator to only get the first four
    movies from the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application. You will see that the RecyclerView will only show four movies:![Figure
    13.6: The app with only four movies'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_13_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.6: The app with only four movies'
  prefs: []
  type: TYPE_NORMAL
- en: Try other RxJava operators and run the application to see the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have learned how to use RxJava operators to manipulate the retrieved response
    from an external API before displaying them in the RecyclerView.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to use coroutines instead of RxJava
    to get data from an external API.
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coroutines were added in Kotlin 1.3 for managing background tasks such as making
    network calls and accessing files or databases. Kotlin coroutines are Google's
    official recommendation for asynchronous programming on Android. Their Jetpack
    libraries, such as LifeCycle, WorkManager, and Room, now include support for coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: With coroutines, you can write your code in a sequential way. The long-running
    task can be made into a suspending function, which when called can pause the thread
    without blocking it. When the suspending function is done, the current thread
    will resume execution. This will make your code easier to read and debug.
  prefs: []
  type: TYPE_NORMAL
- en: 'To mark a function as a suspending function, you can add the `suspend` keyword
    to it; for example, if you have a function that calls the `getMovies` function,
    which fetches `movies` from your endpoint and then displays it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You can make the `getMovies()` function a suspending function by adding the
    `suspend` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, the calling function will invoke `getMovies` and pause. After `getMovies`
    returns a list of movies, it will resume its task and display the movies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suspending functions can only be called in suspending functions or from a coroutine.
    Coroutines have a context, which includes the coroutine dispatcher. Dispatchers
    specify what thread the coroutine will use. There are three dispatchers you can
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dispatchers.Main`: Used to run on Android''s main thread'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dispatchers.IO`: Used for network, file, or database operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dispatchers.Default`: Used for CPU-intensive work'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To change the context for your coroutine, you can use the `withContext` function
    for the code that you want to use a different thread with. For example, in your
    suspending function, `getMovies`, which gets movies from your endpoint, you can
    use `Dispatchers.IO`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will cover how to create coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Coroutines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create a coroutine with the `async` and `launch` keywords. The `launch`
    keyword creates a coroutine and doesn't return anything. On the other hand, the
    `async` keyword returns a value that you can get later with the `await` function.
  prefs: []
  type: TYPE_NORMAL
- en: '`async` and `launch` must be created from `CoroutineScope`, which defines the
    lifecycle of the coroutine. For example, the coroutine scope for the main thread
    is `MainScope`. You can then create coroutines with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create your own `CoroutineScope` instead of using `MainScope`
    by creating one with `CoroutineScope` and passing in the context for the coroutine.
    For example, to create `CoroutineScope` for use on a network call, you can define
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The coroutine can be canceled when the function is no longer needed, like when
    you close the activity. You can do that by calling the `cancel` function from
    `CoroutineScope`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'A ViewModel also has a default `CoroutineScope` for creating coroutines: `viewModelScope`.
    Jetpack''s LifeCycle also has the `lifecycleScope` that you can use. `viewModelScope`
    is canceled when the ViewModel has been destroyed; `lifecycleScope` is also canceled
    when the lifecycle is destroyed. Thus, you no longer need to cancel them.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will be learning how to add coroutines to your project.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Coroutines to Your Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can add coroutines to your project by adding the following code to your
    `app/build.gradle` file dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`kotlinx-coroutines-core` is the main library for coroutines while `kotlinx-coroutines-android`
    adds support for the main Android thread.'
  prefs: []
  type: TYPE_NORMAL
- en: You can add coroutines in Android when making a network call or fetching data
    from a local database.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re using Retrofit 2.6.0 or above, you can mark the endpoint function
    as a suspending function with `suspend`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can create a coroutine that will call the suspending function `getMovies`
    and display the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use LiveData for the response of your coroutines. LiveData is
    a Jetpack class that can hold observable data. You can add LiveData to your Android
    project by adding the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Let's try to use coroutines in an Android project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.03: Using Coroutines in an Android App'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will be using coroutines to fetch the list of popular
    movies from The Movie Database API. You can use the `Popular Movies` project in
    the previous exercise or make a copy of it:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Popular Movies` project in Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `app/build.gradle` file and remove the following dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: These dependencies will no longer be needed as you will be using coroutines
    instead of RxJava.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `app/build.gradle` file, add the dependencies for the Kotlin coroutines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: These will allow you to use coroutines in your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, add the dependencies for the ViewModel and LiveData extension libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `MovieService` interface and replace it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This will mark `getPopularMovies` as a suspending function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `MovieRepository` and add the movies and error LiveData for the list of movies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `fetchMovies` function with a suspending function to retrieve the
    list from the endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the contents of `MovieViewModel` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The `fetchPopularMovies` function has a coroutine, using `viewModelScope`, that
    will fetch the movies from `movieRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MovieApplication` file. In the `onCreate` function, remove the line
    containing `addCallAdapterFactory`. It should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Open the `MainActivity` class. Delete the `getMovies` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `onCreate` function, remove the call to `getMovies`. Then, at the end
    of the `onCreate` function, create `movieViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, add an observer to the `getPopularMovies` and `error` LiveData
    from `movieViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This will update the activity's RecyclerView with the movies fetched. The list
    of movies is filtered using Kotlin's `filter` function to only include movies
    released this year. They are then sorted by title using Kotlin's `sortedBy` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application. You will see that the app will display a list of popular
    movie titles from the current year, sorted by title:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.7: The app displaying popular movies released this year, sorted
    by title'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_13_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.7: The app displaying popular movies released this year, sorted by
    title'
  prefs: []
  type: TYPE_NORMAL
- en: You have used coroutines and LiveData to retrieve and display a list of popular
    movies from a remote data source without blocking the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: Before passing the LiveData into the UI for display, you can also transform
    the data first. You will learn about that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming LiveData
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, the LiveData you pass from the ViewModel to the UI layer needs to
    be processed first before displaying. For example, you can only select a part
    of the data or do some processing on it first. In the previous exercise, you filtered
    the data to only select popular movies from the current year.
  prefs: []
  type: TYPE_NORMAL
- en: To modify LiveData, you can use the `Transformations` class. It has two functions,
    `Transformations.map` and `Transformations.switchMap`, that you can use.
  prefs: []
  type: TYPE_NORMAL
- en: '`Transformations.map` modifies the value of LiveData into another value. This
    can be used for tasks like filtering, sorting, or formatting the data. For example,
    you can transform `movieLiveData` into string LiveData from the movie''s title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: When `movieLiveData` changes value, `movieTitleLiveData` will also change based
    on the movie's title.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `Transformations.switchMap`, you can transform the value of a LiveData
    into another LiveData. This is used when you want to do a specific task involving
    a database or network operation with the original LiveData. For example, if you
    have a LiveData representing a movie `id` object, you can transform that to movie
    LiveData by applying the function `getMovieDetails`, which returns LiveData of
    movie details from the `id` object (such as from another network or database call):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Let's use LiveData transformations on the list of movies fetched using coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.04: LiveData Transformations'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will be transforming the LiveData list of movies before
    passing them to the observers in the `MainActivity` file:'
  prefs: []
  type: TYPE_NORMAL
- en: In Android Studio, open the `Popular Movies` project you worked on in the previous
    exercise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `MainActivity` file. In the `movieViewModel.popularMovies` observer
    in the `onCreate` function, remove the filter and `sortedBy` function calls. The
    code should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This will now display all movies in the list without them being sorted by title.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application. You should see all movies (even those from the past year),
    not sorted by title:![Figure 13.8: The app with unsorted popular movies'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_13_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.8: The app with unsorted popular movies'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MovieViewModel` class and update `popularMovies` with LiveData transformations
    to filter and sort the movies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This will select the movies released last month and sort them by title before
    passing them to the UI observer in `MainActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application. You will see that the app shows a list of popular movies
    from the current year, sorted by title:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.9: The app with the movies released this year sorted by title'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_13_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.9: The app with the movies released this year sorted by title'
  prefs: []
  type: TYPE_NORMAL
- en: You have used LiveData transformations to modify the list of movies to select
    only the ones released this year. They were also sorted by title before passing
    them to the observers in the UI layer.
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines Channels and Flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your coroutine is fetching a stream of data or you have multiple data sources
    and you process the data one by one, you can use either Channel or Flow.
  prefs: []
  type: TYPE_NORMAL
- en: Channels allow you to pass data between different coroutines. They are a hot
    stream of data. It will run and emit values the moment they are called, even when
    there's no listeners. Flows, meanwhile, are cold asynchronous streams. They only
    emit values when the values are collected.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about Channels and Flows, you can go to [https://kotlinlang.org](https://kotlinlang.org).
  prefs: []
  type: TYPE_NORMAL
- en: RxJava versus Coroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both RxJava and coroutines can be used for doing background tasks in Android,
    such as network calls or database operations.
  prefs: []
  type: TYPE_NORMAL
- en: Which one should you use then? While you can use both in your application, for
    example, RxJava for one task and coroutines for another, you can also use them
    together with `LiveDataReactiveStreams` or `kotlinx-coroutines-rx3`. This, however,
    will increase the number of dependencies you use and the size of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, RxJava or coroutines? The following table shows the differences between
    the two:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10: Differences between coroutines and RxJava'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_13_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.10: Differences between coroutines and RxJava'
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 13.01: Creating a TV Guide App'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lot of people watch television. Most of the time, though, they are not sure
    what TV shows are currently on the air. Suppose you wanted to develop an app that
    can display a list of these shows from The Movie Database API's `tv/on_the_air`
    endpoint using Kotlin coroutines and LiveData.
  prefs: []
  type: TYPE_NORMAL
- en: 'The app will have two screens: the main screen and the details screen. On the
    main screen, you will display a list of the TV shows that are on the air. The
    TV shows will be sorted by name. Clicking on a TV show will open the details screen,
    which displays more information about the selected TV show.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Steps for completion:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project in Android Studio and name it `TV Guide`. Set its package name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `INTERNET` permission in the `AndroidManifest.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the Java 8 compatibility and the dependencies for the RecyclerView, Glide,
    Retrofit, RxJava, RxAndroid, Moshi, ViewModel, and LiveData libraries in your
    `app/build.gradle` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `layout_margin` dimension value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `view_tv_show_item.xml` layout file with `ImageView` for the poster
    and `TextView` for the name of the TV show.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `activity_main.xml` file, remove the Hello World TextView and add a RecyclerView
    for the list of TV shows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a model class, `TVShow`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new activity named `DetailsActivity` with `activity_details.xml` as
    the layout file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `AndroidManifest.xml` file and add the `parentActivityName` attribute
    in the `DetailsActivity` declaration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `activity_details.xml`, add the views for the details of the TV show.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `DetailsActivity`, add the code for displaying the details of the TV show selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `TVShowAdapter` adapter class for the list of TV shows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another class named `TVResponse` for the response you get from the API
    endpoint for the TV shows on air.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `TelevisionService` class for adding the Retrofit method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `TVShowRepository` class with a constructor for `tvService`, and properties
    for `apiKey` and `tvShows`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a suspending function to retrieve the list of TV shows from the endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `TVShowViewModel` class with a constructor for `TVShowRepository`.
    Add a `getTVShows` function that returns the LiveData for the list of TV shows
    and `fetchTVShows` that fetches the list from the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an application class named `TVApplication` with a property for `TVShowRepository`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `TVApplication` as the value for the application in the `AndroidManifest.xml`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `MainActivity` and add the code to update the RecyclerView when the LiveData
    from `ViewModel` updates its value. Add a function that will open the details
    screen when clicking on a TV show from the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run your application. The app will display a list of TV shows. Clicking on
    a TV show will open the details activity, which displays the show details. The
    main screen and details screen will be similar to the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.11: The main screen and details screen of the TV Guide app'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_13_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.11: The main screen and details screen of the TV Guide app'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: http://packt.live/3sKj1cp'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused on doing background operations with RxJava and coroutines.
    Background operations are used for long-running tasks such as accessing data from
    the local database or a remote server.
  prefs: []
  type: TYPE_NORMAL
- en: 'You started with the basics of RxJava: observables, observers, and operators.
    Observables are the data sources that provide data. The observers listen to observables;
    when an observable emits data, observers can react accordingly. Operators allow
    you to modify data from an observable to the data you need before it can be passed
    to the observers.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you learned how to make RxJava calls asynchronous with schedulers. Schedulers
    allow you to set the thread through which the required action will be done. The
    `subscribeOn` function is used for setting which thread your observable will run
    on, and the `observeOn` function allows you to set where the next operators will
    be executed. You then fetched data from an external API with RxJava and used RxJava
    operators to filter, sort, and make modifications to the data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you learned about using Kotlin coroutines, which is Google's recommended
    solution for asynchronous programming. You can make a background task into a suspending
    function with the `suspend` keyword. Coroutines can be started with the `async`
    or `launch` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: You've learned how to create suspending functions and how to start coroutines.
    You also used dispatchers to change the thread where a coroutine runs. Finally,
    you used coroutines for doing network calls and modified the data retrieved with
    the LiveData transformation functions `map` and `switchMap`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about architecture patterns. You will learn
    about patterns such as **MVVM** (**Model-View-ViewModel**) and how you can improve
    the architecture of your app.
  prefs: []
  type: TYPE_NORMAL
