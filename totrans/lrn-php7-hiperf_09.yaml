- en: Appendix B. MVC and Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered the names of some of the frameworks in different chapters, but we
    did not discuss them. In today's world, we don't invent the wheel again; we build
    upon the tools that are already built, tested, and widely used. So, as best practice,
    if there is nothing available to fulfill the requirements, we can build it using
    a framework that suits the requirements best.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The MVC design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laravel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lumen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apigility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MVC design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Model View Controller** (**MVC**) is a design pattern widely used in different
    programming languages. Most PHP frameworks use this design pattern. This pattern
    divides the application into three layers: Model, View, and Controller. Each one
    of these has separate tasks, and they are all interconnected. There are different
    visual representations for MVC, but an overall and simple representation can be
    seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The MVC design pattern](graphics/B05225_AppendixB_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's discuss each part of the MVC design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The model layer is the backbone of the application and handles the data logic.
    Mostly, it is considered that model is responsible for CRUD operations on a database,
    which may or may not be true. As we mentioned previously, model is responsible
    for the data logic, which means that data validation operations can also be performed
    here. In simple words, models provide an abstraction for the data. The remaining
    application layers don't know or care how and from where the data comes or how
    an operation is performed on data. It is the model's responsibility to take care
    of all data logic.
  prefs: []
  type: TYPE_NORMAL
- en: In today's complex framework structures, the overall MVC structure is changed,
    and not only do models handle data operations, but also, every other application
    logic is handled by models. The method followed is fat models and slim controllers,
    which means keep all the application logic in models and the controllers as clean
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Views are what is visible to end users. All data related to this user and public
    is displayed in the views, so views can be called the visual representation of
    the models. Views need data to display. It asks for some specific data or action
    from the controller. Views do not know or want to know from where the controller
    gets this data; it just asks the controller to get it. Controller knows who to
    ask for this specific data and communicates with the specific model. It means
    that views do not have any direct link to models. However, in the earlier diagram,
    we linked model to view directly. This is because in the advanced systems nowadays,
    views can directly take data from models. For example, Magento controllers can't
    send data back to views. For the data (that is, to get data directly from the
    database) and/or to communicate with models, views communicate with blocks and
    helper classes. In modern practices, views can be connected to models directly.
  prefs: []
  type: TYPE_NORMAL
- en: Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Controllers respond to actions performed by a user in the views and respond
    to the view. For example, a user fills a form and submits it. Here, the controller
    comes in the middle and starts taking action on the submission of the form. Now,
    the controller will first check whether the user is allowed to make this request
    or not. Then, the controller will take the appropriate action, such as communicating
    with the model or any other operation. In a simple analogy, the controller is
    the middle man between views and models. As we mentioned before in the models
    section, controllers should be slim. So, mostly, controllers are only used to
    handle the requests and communicate with models and views. All kinds of data operations
    are performed in models.
  prefs: []
  type: TYPE_NORMAL
- en: The MVC design pattern's sole job is to separate the responsibilities of different
    parts in an application. So, models are used to manage the application data. Controllers
    are used to take actions on user inputs, and views are responsible for the visual
    representation of data. As we mentioned before, MVC separates the responsibilities
    of each part, so it does not matter whether it accesses the model from controllers
    or views; the only thing that matters is that views and controllers should not
    be used to perform operations on data, as it is the model's responsibility, and
    controllers should not be used to view any kind of data by the end user as this
    is the view's responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Laravel is one of the most popular PHP frameworks, and according to the Laravel
    official website, it is a framework for Web Artisans. Laravel is beautiful, powerful,
    and has tons of features that can enable developers to write efficient and quality
    code. The Laravel official documentation is well written and very easy to understand.
    So, let's play a little with Laravel.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Installation is very easy and simple. Let''s use Composer to install Laravel.
    We discussed Composer in Appendix A. Issue the following command in the terminal
    to install and create a project in Laravel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If Composer is not installed globally on the system, place `composer.phar`
    in a directory where Laravel should be installed and issue the following command
    in the terminal at the root of this directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, Laravel will be downloaded, and a new project with the name `packt` will
    be created. Also, Composer will download and install all the dependencies for
    the project.
  prefs: []
  type: TYPE_NORMAL
- en: Open the browser and head to the project's URL, and we will be welcomed with
    a nice simple page saying **Laravel 5**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of the writing of this book, Laravel 5.2.29 is the latest version available.
    However, if Composer is used, then every time the `composer update` command is
    used, Laravel and all other components will be automatically updated.
  prefs: []
  type: TYPE_NORMAL
- en: Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Laravel provides tons of features, and we will only discuss a few here.
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Laravel provides powerful routing. Routes can be grouped, and prefixes, namespaces,
    and middleware can be defined for route groups. Also, Laravel supports all HTTP
    methods, including `POST`, `GET`, `DELETE`, `PUT`, `OPTIONS`, and `PATCH`. All
    the routes are defined in the `routes.php` file in the application''s `app` folder.
    Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we created a new routes group. This will be only
    used when the URL has a prefixed customer. For example, if a URL is similar to
    `domain.com/customer`, this group will be used. We also used a customer namespace.
    Namespacing allows us to use standard PHP namespaces and divide our files in subfolders.
    In the preceding example, all customer controllers can be placed in the Customer
    subfolder in the `Controllers` directory, and the controller will be created as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So, namespacing a route group enables us to place our controller files in subfolders,
    which are easy to manage. Also, we used the web middleware. Middleware provides
    a way to filter the request before entering the application, which enables us
    to use it to check whether a user is logged in or not, the CSRF protection, or
    whether there are any other actions that can be performed in a middleware and
    need to be performed before the request is sent to application. Laravel comes
    with a few middleware, including `web`, `api`, `auth`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a route is defined as `GET`, no `POST` request can be sent to this route.
    It is very convenient, which enables us to not worry about the request method
    filtering. However, HTML forms do not support the HTTP methods like `DELETE`,
    `PATCH`, and `PUT`. For this, Laravel provides method spoofing, in which a hidden
    form field with `name _method` and the value of the HTTP method is used to make
    this request possible. For example, in our routes group, to make the request possible
    to delete a route, we need a form similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When the preceding form is submitted, it will work, and the delete route will
    be used. Also, we created a CSRF hidden field, which is used for CSRF protection.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Laravel routing is very interesting, and it is a big topic. More in-depth detail
    can be found at [https://laravel.com/docs/5.2/routing](https://laravel.com/docs/5.2/routing).
  prefs: []
  type: TYPE_NORMAL
- en: Eloquent ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Eloquent ORM provides active records to interact with the database. To use
    Eloquent ORM, we have to just extend our models from the Eloquent model. Let''s
    have a look at a simple user model, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it; we have a model that can handle all the CRUD operations now. Note
    that we commented the `$table property` and did the same for `$primaryKey`. This
    is because Laravel uses a plural name of the class to look for the table unless
    the table is defined with the protected `$table property`. In our case, Laravel
    will look for table name users and use it. However, if we want to use a table
    named `customers`, we can just uncomment the line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, Laravel thinks that a table will have a primary key with the column
    name `id`. However, if another column is needed, we can override the default primary
    key, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Eloquent models also make it easy for timestamps. By default, if the table
    has the `created_at` and `updated_at` fields, then these two dates will be generated
    automatically and saved. If no timestamps are required, these can be disabled,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Saving data to the table is easy. The table columns are used as properties
    of the models, so if our `customer` table has columns such as `name`, `email`,
    `phone`, and so on, we can set them as follows in our `customer` controller, mentioned
    in the routing section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we added the `save` action to our controller. Now,
    if a `POST` or `GET` request is made along the form data, Laravel assigns all
    the form-submitted data to a Request object as properties with the same names
    as that of the form fields. Then, using this request object, we can access all
    the data submitted by the form either using `POST` or `GET`. After assigning all
    the data to model properties (the same names as those of table columns), we can
    just call the save method. Now, our model does not have any save method, but its
    parent class, which is the Eloquent model, has this method defined. However, we
    can override this `save` method in our `model` class in case we need some other
    features in this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fetching data from the Eloquent model is also easy. Let''s try an example.
    Add a new action to the `customer` controller, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We used the `all()` static method in the model, which is basically defined
    in the Eloquent model, which, in turn, fetches all the data in our `customers`
    table. Now, if we want to get a single customer by the primary key, we can use
    the `find($id)` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will fetch the customer with the ID `3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating is simple, and the same `save()` method is used, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will update the customer with the ID `3`. First, we loaded the `customer`,
    then we assigned new data to its properties, and then we called the same `save()`
    method. Deleting the model is simple and easy and can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We first loaded the customer with the ID `3`, and then we called the `delete`
    method, which will delete the customer with the ID `3`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Laravel's Eloquent models are very powerful and provide lots of features. These
    are well explained in the documentation at [https://laravel.com/docs/5.2/eloquent](https://laravel.com/docs/5.2/eloquent).
    The Laravel database section is also worth reading and can be found at [https://laravel.com/docs/5.2/database](https://laravel.com/docs/5.2/database).
  prefs: []
  type: TYPE_NORMAL
- en: Artisan CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Artisan is the command-line interface provided with Laravel, and it has some
    nice commands that can be used for quicker operations. It has lots of commands,
    and a full list can be seen using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will list all the options and commands available.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `php artisan` command should be run in the same directory in which the `artisan`
    file is located. It is placed at the root of the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the basic commands are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`make:controller`: This command creates a new controller in the `Controllers`
    folder. The command can be used as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If a namespaced controller is required, as it happened before with the `Customer`
    namespace, it can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This command will create `CustomerController` in the `Customer` folder. If the
    `Customer` folder is not available, it will create the folder as well.
  prefs: []
  type: TYPE_NORMAL
- en: '`make:model`: This creates a new model in the `app` folder. The syntax is the
    same as the `make:controller` command, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For the namespaced models, it can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This will create the `Customer` model in the `Customer` folder and use the `Customer`
    namespace for it.
  prefs: []
  type: TYPE_NORMAL
- en: '`make:event`: This creates a new `event` class in the `Events` folder. It can
    be used as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`make:listener`: This command creates a new listener for an event. This can
    be used as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will create a new listener for our `MyEvent` event. We
    have to always mention the event for which we need to create a listener using
    the `--event` option.
  prefs: []
  type: TYPE_NORMAL
- en: '`make:migration`: This command creates a new migration in the database/migrations
    folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`php artisan migrate`: This runs all the available migrations that are not
    executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`php artisan optimize`: This command optimizes the framework for better performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`php artisan down`: This puts the application in maintenance mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`php artisan up`: This command brings the application back live from the maintenance
    mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`php artisan cache:clear`: This command clears the application cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`php artisan db:seed`: This command seeds the database with records.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`php artisan view:clear`: This clears all the compiled view files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More detail about the Artisan console or Artisan CLI can be found in the documentation
    at [https://laravel.com/docs/5.2/homestead](https://laravel.com/docs/5.2/homestead).
  prefs: []
  type: TYPE_NORMAL
- en: Migrations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Migrations is another powerful feature in Laravel. In migrations, we define
    the database schemas—whether it creates tables, removes tables, or adds/updates
    columns in the tables. Migrations are very convenient in deployment and act as
    version control for the database. Let''s create a migration for our customer table
    that is not available in the database yet. To create a migration, issue the following
    command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A new file in the `database/migrations` folder will be created with the filename
    `create_customer_table` prefixed with the current date and a unique ID. The class
    is created as `CreateCustomerTable`. This is a class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The class will have two public methods: `up()` and `down()`. The `up()` method
    should have all the new schemas for the table(s). The `down()` method is responsible
    for reversing the executed migration. Now, lets add the `customers` table schema
    to the `up()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `up()` method, we defined the schema and table name. Columns for the
    table are individually defined, including the column size. The `increments()`
    method defines the autoincrement column, which, in our case, is the `id` column.
    Next, we created three string columns for `name`, `email`, and `phone`. Then,
    we used the `timestamps()` method, which creates the `created_at` and `updated_at`
    timestamp columns. In the `down()` method, we just used the `drop()` method of
    the `Schema` class to drop out the `customers` table. Now, we need to run our
    migrations using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will not only run our migration but will also run all
    those migrations that are not executed yet. When a migration is executed, Laravel
    stores the migration name in a table called `migrations`, from where Laravel decides
    which migrations it has to execute and which to skip.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we need to roll back the latest executed migration, we can use the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This will roll back to the last batch of migrations. To roll back all the migrations
    of the application, we can use the reset command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This will roll back the complete application migrations.
  prefs: []
  type: TYPE_NORMAL
- en: Migrations make it easy for deployment because we won't need to upload the database
    schemas every time we create some new changes in the tables or database. We will
    just create the migrations and upload all the files, and after this, we will just
    execute the migration command, and all the schemas will be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Blade templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Laravel comes with its own template language called Blade. Also, Blade template
    files support plain PHP code. Blade template files are compiled to plain PHP files
    and are cached until they are changed. Blade also supports layouts. For example,
    the following is our master page layout in Blade, placed in the `resources/views/layout`
    folder with the name `master.blade.php`. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we had a section for the sidebar that defines a `content`
    section. Also, we had `@yield`, which displays the contents of a section. Now,
    if we want to use this layout, we will need to extend it in the child template
    files. Let''s create the `customers.blade.php` file in the `resources/views/`
    folder and place the following code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be seen in the preceding code, we extended the `master` layout and then
    placed contents in every section of the `master` layout. Also, it is possible
    to include different templates in another template. For example, let''s have two
    files, `sidebar.blade.php` and `menu.blade.php`, in the `resources/views/includes`
    folder. Then, we can include these files in any template, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We used `@include` to include a template. The dot (`.`) indicates a folder
    separation. We can easily send data to Blade templates or views from our controllers
    or routers. We have to just pass the data as an array to a view, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `count` is available in our `customers` view file and can be accessed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, Blade uses double curly braces to echo a variable. For control structures
    and loops, let''s have another example. Let''s send data to the `customers` view,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our `customers` view file will be similar to the following if we want
    to display all the `customers` data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: All the preceding syntax looks familiar as it is almost the same as plain PHP.
    However, to display a variable, we have to use double curly braces `{{}}`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A nice and easy-to-read documentation for Blade templates can be found at [https://laravel.com/docs/5.2/blade](https://laravel.com/docs/5.2/blade).
  prefs: []
  type: TYPE_NORMAL
- en: Other features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We only discussed a few basic features in the previous section. Laravel has
    tons of other features, such as Authentication and Authorization, which provide
    an easy way to authenticate and authorize users. Also, Laravel provides a powerful
    caching system, which supports file-based cache, the Memcached, and Redis cache.
    Laravel also provides events and listeners for these events, which is very convenient
    when we want to perform a specific action and when a specific event occurs. Laravel
    supports localization, which enables us to use localized contents and multiple
    languages. Laravel also supports task scheduling and queues, in which we schedule
    some tasks to run at a specific time and queue some tasks to be run when their
    turn arrives.
  prefs: []
  type: TYPE_NORMAL
- en: Lumen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lumen is a micro-framework provided by Laravel. Lumen is mainly intended to
    create stateless APIs and has a minimal set of features of Laravel. Also, Lumen
    is compatible with Laravel, which means that if we just copy our Lumen application
    to Laravel, it will work fine. The installation is simple. Just use the following
    Composer command to create a Lumen project, and it will download all the dependencies,
    including Lumen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will download Lumen and then create our API application.
    After this, rename `.env.example` as `.env`. Also, create a 32-characters-long
    app key and place it in the `.env` file. Now, the basic application is ready to
    use and create APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lumen is almost the same as Laravel, but some Laravel features are not included
    by default. More details can be found at [https://lumen.laravel.com/docs/5.2](https://lumen.laravel.com/docs/5.2).
  prefs: []
  type: TYPE_NORMAL
- en: Apigility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apigility is built and developed by Zend in Zend Framework 2\. Apigility provides
    an easy to use GUI to create and manage APIs. It is very easy to use and is capable
    of creating complex APIs. Let''s start by installing Apigility using Composer.
    Issue the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will download Apigility and its dependencies, including
    Zend Framework 2, and will set up our project named `packt`. Now, issue the following
    command to enable the development mode so that we can have access to the GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the URL as [yourdomain.com/packt/public](http://yourdomain.com/packt/public),
    and we will see a beautiful GUI, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Apigility](graphics/B05225_AppendixB_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s create our first API. We will call this API "`books`", which will
    return a list of books. Click on the **New API** button, as shown in the preceding
    picture, and a popup will be displayed. In the text box, enter `books` as the
    API name and click on `Create` button; the new API will be created. When the API
    is created, we will be presented with the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Apigility](graphics/B05225_AppendixB_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Apigility provides easy ways to set other properties for the API, such as versioning
    and authentication. Now, let''s create an RPC service by clicking on the **New
    Service** button in the left sidebar. Also, we can click on the **Create a new
    one** link in the **RPC** section in the preceding screenshot. We will be presented
    with the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Apigility](graphics/B05225_AppendixB_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding screenshot, we created an RPC service named `get`
    in the `books` API. The route URI entered is `/books/get`, which will be used
    to call this RPC service. When we click on the `Create service` button, the API
    creation successful message will be displayed, and also, the following screen
    will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Apigility](graphics/B05225_AppendixB_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As can be seen in the preceding screenshot, the allowed HTTP method for this
    service is only **GET**. Let's keep this as it is, but we can select all or any
    of them. Also, we want to keep **Content Negotiation Selector** as `Json`, and
    our service will accept/receive all the content in the JSON format. Also, we can
    select different media types and content types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we should add some fields to our service that will be used. Click on
    the **Fields** tab, and we will see the **Fields** screen. Click on the **New
    Field** button, and we will be presented with the following popup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Apigility](graphics/B05225_AppendixB_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As can be seen in the preceding screenshot, we can set all the properties for
    a field, such as the **Name**, **Description**, whether it is required or not,
    and some other settings, including an error message if the validation fails. After
    we created two fields, **title** and **author**, we will have a screen similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Apigility](graphics/B05225_AppendixB_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As can be seen in the preceding screen, we can add validators and filters to
    each individual field too.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As this is just an introductory topic for Apigility, we will not cover validators
    and filters and some other topics in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next topic is documentation. When we click on the **Documentation** tab,
    we will see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Apigility](graphics/B05225_AppendixB_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we will document our service, add some description, and also can generate
    the response body for documentation purposes. This is very important as it will
    enable others to better understand our APIs and services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to get the all the books from somewhere. It can be either from
    the database or from another service or any other source. However, for now, we
    will just use an array of books for test purposes. If we click on the **Source**
    tab, we will find that our code for the service is placed at `module/books/src/books/V1/Rpc/Get/GetController.php`.
    Apigility created a module for our API `books` and then placed all the source
    code in this module in different folders according to the version of our API,
    which is V1 by default. We can add more versions, such as V2 and V3, to our APIs.
    Now, if we open the `GetController` file, we will find some code and an action
    called `getAction` according to our route URI. The code is as follows, and the
    highlighted code is the one we added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we used `ContentNegotiation\ViewModel`, which is responsible
    for responding with the data in the format that we selected in the service setup,
    which is JSON in our case. Then, we created a simple `$books` array with the fieldnames
    we created for the service and assigned our values to them. Then, we returned
    them using the `ViewModel` object, which handles the response data conversion
    to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s test our API. As our service can accept `GET` requests, we will
    just type our URL in the browser with the `books/get` URI, and we will see the
    JSON response. It is best to check the API with tools such as RestClient or Postman
    for Google Chrome, which provides an easy-to-use interface to make different types
    of requests to APIs. We tested it with Postman and got the response shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Apigility](graphics/B05225_AppendixB_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Also note that we set our service to accept only `GET` requests. So, if we send
    a request other than `GET`, we will get an `HTTP Status code 405 methods not allowed`
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Apigility is very powerful and provides tons of features, such as RESTFul APIs,
    HTTP authentication, database connected services with easy-to-create DB connectors,
    and a selection of tables for a service. While using Apigility, we need not worry
    about the API, service structure security, and other things, as Apigility does
    this for us. We need to only concentrate on the business logic of the APIs and
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apigility can't be covered completely in this Appendix. Apigility has lots of
    features that can be covered in a complete book. Apigility's official documentation
    at [https://apigility.org/documentation](https://apigility.org/documentation)
    is a good place to get started and read more about this.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this Appendix, we discussed the basics of the MVC design pattern. We also
    discussed the Laravel framework and some of its good features. We introduced you
    to the Laravel-based micro-framework, Lumen. At the end, we had a small introduction
    to Apigility and created a test API and web service.
  prefs: []
  type: TYPE_NORMAL
- en: In IT, things get obsolete in a very short time span. It is always required
    to study upgraded tools and find new ways and techniques for the best approaches
    in programming. Therefore, one should not stop after completing this book and
    start studying new topics and also the topics that are not covered completely
    in this book. Until this point, you will have the knowledge that you can use to
    set up high-performance environments for high-performance applications. We wish
    you good luck and success in PHP-ing!
  prefs: []
  type: TYPE_NORMAL
