- en: Error Checking and Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will describe how we can check for errors and handle them
    gracefully. We will start by explaining the exit status concept, followed by a
    number of functional checks with the `test` command. After that, we will start
    using shorthand notation for `test` command. The next part of this chapter is
    dedicated to error handling: we will use `if-then-exit` and `if-then-else` to
    handle simple errors. In the final part of this chapter, we will present some
    ways in which we can prevent errors from occurring in the first place, since prevention
    is better than remediation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands will be introduced in this chapter: `mktemp`, `true`,
    and `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Error checking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error prevention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Only the Ubuntu virtual machine is needed for this chapter. If you have never
    updated your machine, now might be a good time! The `sudo apt update && sudo apt
    upgrade -y` command upgrades your machine with all tools completely. If you choose
    to do this, make sure that you reboot your machine so that upgraded kernels are
    loaded. On Ubuntu, if the` /var/log/reboot-required` file is present, you can
    be sure a reboot is, well, *required*.
  prefs: []
  type: TYPE_NORMAL
- en: 'All scripts for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter09](https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter09).'
  prefs: []
  type: TYPE_NORMAL
- en: Error checking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we spent some time explaining how we could capture
    and use *user input* in our scripts. While this makes our scripts much more dynamic
    and, by extension, much more practical, we also introduce a new concept: **human
    error.** Let''s say you''re writing a script where you want to present the user
    with a yes/no question. You might expect a reasonable user to use any of the following
    as an answer:'
  prefs: []
  type: TYPE_NORMAL
- en: y
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: n
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Y
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: N
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Yes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'yes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'no'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'YES'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NO'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While Bash allows us to check for all values we can think of, sometimes a user
    will still be able to *break* the script by supplying input you do not expect.
    An example of this would be the user answering the yes/no question in their native
    language: `ja`, `si`, `nei`, or any of the countless other possibilities. In practice,
    you will find that you can *never* think of every possible input a user will provide.
    That being the way it is, the best solution is to handle the most common expected
    input, and catch all other input with a generic error message which tells the
    user *how to correctly supply the answer*. We''ll see how we can do that later
    on in this chapter, but first, we''ll start by looking at how we can even determine
    if an error has occurred by checking the **exit status** of a command.'
  prefs: []
  type: TYPE_NORMAL
- en: Exit status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The exit status, commonly also referred to as *exit codes* or *return codes*,
    is the way Bash communicates the successful or unsuccessful termination of a process
    to its parent. In Bash, all processes are *forked* from the shell that calls them.
    The following diagram illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee93b0e8-d32a-41ec-ace1-c7e41a598265.png)'
  prefs: []
  type: TYPE_IMG
- en: When a command runs, such as `ps -f` in the preceding diagram, the current shell
    is copied (including the environment variables!), and the command runs in the
    copy, called the *fork*. After the command/process is done, it terminates the
    fork and returns the exit status to the shell that it was initially forked from
    (which, in the case of an interactive session, will be your user session). At
    that point, you can determine whether the process was executed successfully by
    looking at the exit code. As explained in the previous chapter, an exit code of
    0 is considered OK, while all other codes should be treated as NOT OK. Because
    the fork is terminated, we need the return code, otherwise we will have no way
    of communicating the status back to our session!
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we have already seen how to grab the exit status in an interactive
    session in the previous chapter (hint: we looked at the content of the `$?` variable!),
    let''s see how we can do the same in a script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Going through the script, we start with the shebang and header. Since we don''t
    use user input in this script, the usage is just the script name. The first command
    we run is `mktemp`. This command is used to create a temporary *file* with a random
    name, which could be useful is we needed to have a place on disk for some temporary
    data. Alternatively, if we supplied the `-d` flag to `mktemp`, we would create
    a temporary *directory* with a random name. Because the random name is sufficiently
    long and we should always have write permissions in `/tmp/`, we would expect the
    `mktemp` command to almost always succeed and thus return an exit status of 0\.
    We save the return code to the `mktemp_rc` variable by running the variable assignment
    **directly after the command**. In that lies the biggest weakness with return
    codes: we only have them available directly after the command completes. If we
    do anything else after, the return code will be set for that action, overwriting
    the previous exit status!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we run a command which we expect to always fail: `mkdir /home/`. The
    reason we expect this to fail is because on our system (and on pretty much every
    Linux system), the `/home/` directory already exists. In this case, it cannot
    be created again, which is why the command fails with an exit status of 1\. Again,
    directly after the `mkdir` command, we save the exit status into the `mkdir_rc`
    variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to check to see whether our assumptions are correct. Using
    `echo`, we print the values of both variables along with some text so that we
    know where we printed which value. One last thing to note here: we used *double
    quotes* for our sentence containing variables. If we used *single quotes*, the
    variables would not be *expanded* (the Bash term for substituting the variable
    name with its value). Alternatively, we could omit the quotes altogether, and
    `echo` would perform as desired as well, however that could start presenting issues
    when we start working with redirection, which is why we consider it good form
    to always use double quotes when dealing with strings containing variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Functional checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we know how we can check the exit status of a process to determine if it
    was successful. However, that is not the only way we can validate the success/failure
    of commands. For most commands that we run, we could also perform a functional
    check to see if we were successful. In the previous script, we tried to create
    the `/home/` directory. But what if we were more concerned with the existence
    of the `/home/` directory, instead of the exit status of the process?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script shows how we can perform *functional checks* on the state
    of our system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We start the preceding script with the usual plumbing. Next, we want to create
    a directory with `mkdir`. We grab the exit status and store it in a variable.
    Next, we use the `test` command (which we briefly explored in the previous chapter)
    to validate whether `/tmp/temp_dir/` is a directory (and thus, if it was created
    **sometime**). We then print the return codes with `echo`, in the same fashion
    as we did for return-code.sh.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we run the script twice. Here is where something interesting happens.
    The first time we run the script, the `/tmp/temp_dir/` directory does not exist
    on the filesystem and is created. Because of this, the exit code for the `mkdir`
    command is 0\. Since it was successfully created, `test -d` also succeeds and
    gives us back an exit status of 0, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the second run of the script, the `mkdir` command does not successfully
    complete. This is expected, because the first run of the script already created
    the directory. Since we did not delete it in between the runs, the second run
    of `mkdir` is unsuccessful. However, `test -d` still runs fine: **the directory
    exists**, even though it was not created in that run of the script.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating scripts, make sure you think long and hard about how you want
    to check for errors. Sometimes, return codes will be what you need: this is the
    case when you need to be sure that the command has been run successfully. Other
    times, however, a functional check might be a better fit. This is often the case
    when it is the end result that matters (for example, a directory must exist),
    but it does not matter so much what caused the desired state.'
  prefs: []
  type: TYPE_NORMAL
- en: Test shorthand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `test` command is one of the most important commands we have in our shell
    scripting arsenal. Because shell scripts can often be fragile, especially where
    user input is concerned, we want to make these as robust as possible. While explaining
    every aspect of the `test` command would take a whole chapter, the following are
    the things `test` can do:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether a file exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether a directory exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether a variable is not empty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether two variables have the same values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether FILE1 is older than FILE2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether INTEGER1 is greater than INTEGER2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And so on and on and on—this should give you at least an impression of things
    you can check with `test`. In the *Further reading* section, we have included
    an extensive source on test. Make sure to give it a look, as it will definitely
    help in your shell scripting adventures!
  prefs: []
  type: TYPE_NORMAL
- en: 'For most scripting and programming languages, there is no such thing as a `test`
    command. Obviously, tests are just as important in those languages but, unlike
    Bash, tests are often directly integrated with the `if-then-else` logic (which
    we will discuss in the next part of this chapter). Luckily for us, Bash has a
    shorthand for the `test` command, which brings it a lot closer to the syntax of
    other languages: `[` and `[[`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following code to get a better idea of how we can replace the `test`
    command with this shorthand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, after the plumbing we started with the previously introduced
    `test` syntax. Next, we replaced the word test with `[`, and ended the line with `]`.
    This is the part that Bash has in common with other scripting/programming languages.
    Note that, unlike most languages, Bash requires a **whitespace after [ and before
    ]**! Finally, we used the extended shorthand syntax, starting with `[[` and ending
    with `]]`. When we print the return codes, they all return `0`, which means that
    all tests succeeded, even with the different syntaxes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference between [ ] and [[ ]] is minor, but can be very important. Simply
    said, the simple shorthand syntax of [ ] can introduce problems when variables
    or paths have whitespace in them. In this case, the test considers the whitespace
    the delimiter, which means the string `hello there` becomes two arguments instead
    of one (`hello + there`). There are other differences, but in the end our advice
    is really simple: **use the extended shorthand syntax of [[ ]]**. For more information,
    see the *Further reading* section on test.'
  prefs: []
  type: TYPE_NORMAL
- en: Variable refresher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a little bonus, we have a slight improvement for the `test-shorthand.sh`
    script. In the previous chapter, we explained that, if we have to use the same
    value multiple times in a script, we''re better off making it a variable. If the
    value of the variable does not change during the script''s execution and is not
    influenced by user input, we use a CONSTANT. Take a look at how we would incorporate
    that in our previous script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: While the end result is the same, this script is more robust if we ever want
    to change it. Furthermore, it shows us that we can use variables in the `test`
    shorthand, which will automatically be expanded by Bash.
  prefs: []
  type: TYPE_NORMAL
- en: Bash debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have one more trick up our sleeve to prove that values are expanded properly:
    running the Bash script **with debug logging**. Look at the following execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you compare this to the actual script, you will see that the script text
    `test -d ${DIRECTORY}` is resolved to `test -d /tmp/` at runtime. This is because,
    instead of running `bash test-shorthand-variable.sh`, we're running `bash -x test-shorthand-variable.sh`.
    In this case, the `-x` flag tells Bash to *print commands and their arguments
    as they are executed—*a very handy thing to remember if you're ever building scripts
    and unsure why the script is not doing what you expect it to do!
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have looked at how we can check for errors. However, besides checking
    for errors, there is an aspect to this which is just as important: handling errors.
    We''ll initially combine our previous experience with `if` and `test` to exit
    on errors, before we go on to introduce much smarter ways to handle errors!'
  prefs: []
  type: TYPE_NORMAL
- en: if-then-exit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you might recall from the previous chapter, the `if-then` construct used
    by Bash is common to (almost) all programming languages. In its basic form, the
    idea is that you test for a condition (IF), and if that condition is true, you
    do something (THEN).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a very basic example: if `name` is longer than or equal to 2 characters,
    then `echo "hello ${name}"`. In this case, we assume that a name has to be, at
    the very least, 2 characters. If it is not, the input is invalid and we do not
    give it a "hello".'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following script, `if-then-exit.sh`, we will see that our goal is to
    print the contents of a file using `cat`. However, before we do that, we check
    if the file exists, and if it doesn''t, we exit the script with a message to the
    caller that specifies what went wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of this script should be clear by now. We used the *extended shorthand
    syntax* for the test, as we will do in the rest of this book. The `-f` flag is
    described in the man page of `test` as *FILE exists and is a regular file*. However,
    we ran into a little issue here: we want to print the file (with `cat`), but only
    if the file exists; otherwise, we want to print the message with `echo`. Later
    in this chapter, when we introduce `if-then-else`, we''ll see how we can do this
    with a positive test. At the moment though, we want the test to give us a TRUE
    if the file we''re checking **is not** an existing file. In this case, semantically
    speaking, we''re doing the following: IF the file does not exist, THEN print a
    message and EXIT. The test syntax in Bash does not have a flag for this. There
    is, luckily, one powerful construct we can use: the exclamation mark, !, which
    negates/reverses the test!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: if [[ -f /tmp/file ]]; then *do-something* -> *do-something* is executed if
    the file /tmp/file exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if [[ ! -f /tmp/file ]]; then *do-something* -> *do-something* is executed if
    the file /tmp/file **does not** exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if [[ -n ${variable} ]]; then *do-something* -> *do-something* is executed if
    the variable ${variable} is not empty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if [[ ! -n ${variable} ]]; then *do-something* -> *do-something* is executed
    if the variable ${variable} is **not** not empty (so, the double negative means
    do-something is only executed if the variable is in fact empty)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if [[ -z ${variable} ]]; then *do-something* -> *do-something* is executed if
    the variable ${variable} is empty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if [[ ! -z ${variable} ]]; then *do-something* -> *do-something* is executed
    if the variable ${variable} is **not** empty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you should be aware, the last four examples overlap. This is because the
    flags `-n` (nonzero) and `-z` (zero) are already each other's opposites. Since
    we can negate the test with !, this means that `-z` is equal to `! -n`, and `!
    -z` is the same as `-n`. In this case, it would not matter if you used `-n` or
    ! `-z`. We would advise you to use the specific flag if it is available, before
    using a negation with another flag.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get back to our script. When we found that the file did not exist by using
    the negated file exists test, we then printed the helpful message to the caller
    and exited the script. In this case, we never reached the `cat` command, but since
    the file does not exist anyway, the `cat` would never have succeeded. If we'd
    let the execution continue to that point, we would be presented with an error
    message by `cat`. In the case of `cat`, this message is no worse than our own
    message, but for some other commands, error messages are definitely not always
    as clear as we'd like; in this case, a check of our own with a clear message is
    not a bad thing!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s another example, where we use if and test to look at the status code
    which we''ll catch in a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first functional part of this script, we tried to create the top-level
    directory `/temporary_dir/`. Since only root has these privileges, and we''re
    neither running this as the root user nor with `sudo`, the `mkdir` fails. When
    we catch the exit status in the `mkdir_rc` variable, we do not know the exact
    value (we could print it if we wanted it), but we know one thing for sure: it
    is not `0`, which is reserved for successful execution. So, we have two options
    here: we can check if the exit status *is not equal to 0*, or if the status code
    *is equal to 1* (which is actually what `mkdir` reports back to the parent shell
    in this case). We generally prefer **checking for the absence of success**, instead
    of checking for a specific type of failure (as denoted by different return codes,
    such as 1, 113, 127, 255, and so on). If we only stop on an exit code of 1, we
    would continue the script in all cases where we do not get a 1: this would hopefully
    be a 0, but we''re not sure of that. And, in general, anything that is not successful
    warrants stopping a script!'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this situation, checking if the return code is not `0`, we''re using an
    integer (remember, a fancy word for *number*) comparison. If we check `man test`,
    we can see that the `-ne` flag is described as `INTEGER1 -ne INTEGER2: INTEGER1
    is not equal to INTEGER2`. So, for our logic, that would mean that, if the return
    code caught in the variable is **n**ot **e**qual to `0`, the command did not succeed
    successfully and we should stop. Remember that we could also use the `-eq` (**eq**ual
    to) flag and negate it with `!` for the same effect.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In its current form, the script is a little longer than it strictly needs to
    be. We first store the return code in a variable, and then we compare that variable.
    What we can also do is directly use the exit status in the `if-test` construction,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'While this *only* saves us a single line (the variable assignment), it also
    saves us an unnecessary variable. You can see that we changed the test to comparing
    0 to $?. We know that we want to check the execution anyway, so we might as well
    do it right away. Should we need to do it later, we would still need to save it
    in a variable, because remember: the exit status is only available directly after
    running a command. After that point, it has been overridden by the exit status
    of later commands.'
  prefs: []
  type: TYPE_NORMAL
- en: if-then-else
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By now, you''ll hopefully have a feeling for how useful `if-then` logic is.
    However, you might feel like something is missing still. If that is the case,
    you would be right! An `if-then` construct is not complete without the ELSE statement.
    The `if-then-else` construct allows us to specify what should happen if the test
    in the if-clause does **not** equal true. Semantically, it could be translated
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: IF condition, THEN do-something, ELSE (otherwise) do-something-else
  prefs: []
  type: TYPE_NORMAL
- en: 'We can illustrate this very easily by taking one of our earlier scripts, `if-then-exit.sh`,
    and optimizing both the flow of the script and the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this is starting to look like something! We moved our `cat` command into
    the `if-then-else` logic block. Now, it feels (and is!) like a single command:
    if the file does not exist, print an error message and exit, otherwise, print
    its contents. It is a little weird that we used the then block for the error situation,
    though; by convention, that is reserved for the success condition. We can make
    our script a little more intuitive by swapping the then and else blocks; however,
    we will also need to invert our test condition. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The changes we made in this script are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We replaced the hard-coded FILE constant with a user input variable `file_name`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We removed the ! which inverts the `test`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We swapped the then and else execution blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As it is now, the script first checks if the file exists, and if it does, it
    prints its contents (success scenario). If the file does not exist, the script
    prints an error message and exits with an exit code of 1 (failure scenario). In
    practice, `else` is often reserved for failure scenarios, and `then` for the success
    scenario. However, these are not golden rules and could differ, based on the types
    of test you have available. If you''re ever writing a script and you want to use
    the else block for the success scenario, go right ahead: as long as you''re sure
    it''s the right choice for your situation, there is definitely no shame in it!'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that within an `if-then-else` block, the commands we
    execute in then or else are always preceded by two whitespaces. In scripting/programming,
    this is called indenting. It serves only a single function in Bash: to improve
    readability. By indenting those commands with two spaces, we know they''re part
    of the then-else logic. In that same manner, it is much easier to see where the
    `then` ends and the `else` begins. Note that, in some languages, notably Python,
    whitespace is part of the programming language syntax and cannot be omitted!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Until this point, we have only used `if-then-else` logic for error detection,
    followed by an exit `1`. However, in some cases, both *then* and *else* can be
    used to accomplish the goal of the script, instead of one of them being used for
    error handling. Take a look at the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We use this script to make sure that a file exists and is empty. Basically,
    there are two scenarios: the file exists (and *might* not be empty) or it does
    not exist. In our **if** test, we check to see if the file exists. If it does,
    we replace it with an empty file by copying `/dev/null` (which is always empty)
    to the location given by the user. Otherwise, if the file does not exist, we simply
    create it using `touch`.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the script's execution, the first time we run this script,
    the file does not exist and is created with `touch`. In the next run of the script,
    directly after, the file does exist (since it was created in the first run). This
    time, we can see in the debug that `cp` is used. Because we want to make sure
    whether either of these actions succeeded, we include an extra **if** block, which
    handles exit status checking, as we have seen before.
  prefs: []
  type: TYPE_NORMAL
- en: Shorthand syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By now, we''ve seen a few uses of an if block to see if our previous commands
    ran successfully. While the functionality is great, using 5-7 lines after each
    command where you suspect errors could occur really adds to the total script length!
    Even more of an issue will be readability: if half the script is error checking,
    it might be very hard to get to the bottom of the code. Fortunately, there is
    a way in which we can check for errors directly after a command. We can accomplish
    this with the || command, which is the Bash version of a logical OR. Its counterpart,
    &&, is the implementation of a logical AND. To illustrate this, we''ll introduce
    two new commands: `true` and `false`. If you take a look at the respective man
    pages, you''ll find the clearest answer you can possibly get:'
  prefs: []
  type: TYPE_NORMAL
- en: 'true: Do nothing, successfully'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'false: Do nothing, unsuccessfully'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following script illustrates how we use || and && to create a logical application
    flow. If logical operators are unfamiliar terrain, check out the link in the *Further
    reading* section under *Logical operators* first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we expect, the code after && is only executed if the command before returns
    an exit code of 0, while the code after || is only executed if the exit code is
    **not** 0 (so, most often, 1). If you look closely, you can actually see this
    happening in the debug of the script. You can see `true` being executed twice,
    as well as `false`. However, the first `echo` we actually end up seeing is after
    the first true, whereas the second `echo` we see is after the second false! We've
    highlighted this in the preceding code for your convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how can we use this to handle errors? An error will give an exit status
    that is anything other than 0, so this is comparable to the `false` command. In
    our example, the code after the logical operator || was printed after the false.
    This makes sense, because either `false` OR `echo` should succeed. In this case,
    since `false` (by default) fails, `echo` is executed. In the following simple
    example, we''ll show you how we would use the || operator in a script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We try to `cat` a file that we do not have permissions to (which is a good thing,
    since `/etc/shadow` contains the hash passwords for all users on the system).
    When we do this normally, we receive the exit status of 1, as you can see from
    our manual `cat`. However, in our script, we use `exit 123`. If our logical operator
    does its job, we will not exit with the default `1`, but instead with exit status
    123\. When we call the script, we get the same `Permission denied` error, but
    this time when we print the return code, we see the expected `123`.
  prefs: []
  type: TYPE_NORMAL
- en: If you really want to confirm that the code after || is only executed if the
    first part fails, run the script with `sudo`. In this case, you will see the contents
    of `/etc/shadow`, since root has those permissions and the exit code will be 0
    instead of the earlier 1 and 123.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can also use && if you only want to execute code when you're
    entirely sure the first command has finished successfully. To handle potential
    errors in a really graceful manner, it would be best to combine `echo` and `exit`
    after the ||. In the next example, on one of the next few pages, you will see
    how this is achieved! We will use that way of handling errors in the rest of this
    book, so don't worry about the syntax just yet – you will encounter it many more
    times before this book is over.
  prefs: []
  type: TYPE_NORMAL
- en: Error prevention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, you should have a firm grasp on how we can handle (user input)
    error. Obviously, context is everything here: depending on the situation, some
    errors are handled in different ways. There is one more important subject in this
    chapter, and that is *error prevention*. While knowing how to handle errors is
    one thing, it would be even better if we can prevent errors during script execution
    altogether.'
  prefs: []
  type: TYPE_NORMAL
- en: Checking arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we noted in the previous chapter, when you''re dealing with positional arguments
    passed to your script, a few things are very important. One of them is whitespace,
    which signifies the boundary between arguments. If we need to pass an argument
    to our script that contains whitespace, we need to wrap that argument in single
    or double quotes, otherwise it will be interpreted as multiple arguments. Another
    important aspect of positional arguments is getting exactly the right number of
    arguments: not too few, but definitely not too many either.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By starting our scripts (that use positional arguments) with a check on the
    number of arguments passed, we can validate if the user called the script correctly.
    Otherwise, we can instruct the user on how to correctly call it! The following
    example shows you how we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To properly illustrate this principle and some others we have seen before,
    we''ve created a rather large and complicated script (compared to what you have
    seen before). To make it easy to understand this, we''ll cut it up into pieces
    and discuss each piece sequentially. We''ll start with the header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The shebang and most fields should feel natural right now. When specifying
    positional parameters, however, we like to enclose them within **<>** if they''re
    **required**, and **[]** if they''re **optional** (which they are if they have
    a default value, for instance, which we will see at the end of this chapter).
    This is a common pattern in scripting and you would do well to follow it! The
    next part of the script is the actual check for the number of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The magic in this section comes from the $# combination. Similar to the $?
    exit status construct, $# is resolved to the number of arguments that have been
    passed to the script. Because this is an integer, we can compare it, using the
    `-ne` and `-eq` flags of `test`, to the number of arguments we need: three. Anything
    that is *not three* will not work for this script, which is why we build the check
    in this manner. If the *test is positive* (which means a negative result!), we
    perform the `then-logic`, which tells the user that they called the script incorrectly.
    To prevent that from happening again, the correct way to use the script is passed
    as well. We use one more trick here, the `$0` signs. This resolves to the script
    name, which is why, in the case of incorrect calling, the script name is printed
    nicely next to the actual expected arguments, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of this check and the hint to the user, we would expect the user to
    call this script incorrectly only once. Because we have not started processing
    the script''s functionality yet, we will not have a situation where half the tasks
    in the script have been completed, even though we would know **at the start of
    the script** that it would never complete, since it is missing information that
    the script needs. Let''s move on to the next part of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As a recap, we can see that we assigned positional user input to a variable
    name we chose to represent the thing it is saving. Because we need to use the
    absolute path of the final file more than once, we combine two of the variables
    based on user input to form the absolute path to the file. The next part of the
    script contains the actual functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For both the file and the directory, we do a similar check: we check if the
    directory/file is already there, or if we need to create it. By using the || shorthand
    with `echo` and `exit`, we check if `mkdir` and `touch` return an exit status
    of 0\. Remember, if they return *anything other than 0*, everything after the
    || and within the curly braces will be executed, in this case exiting the script!'
  prefs: []
  type: TYPE_NORMAL
- en: The last part contains the *redirection* of the echo to the file. Simply said,
    the output of echo is redirected into a file. Redirection will be discussed in
    depth in [Chapter 12](15141e02-be0c-4709-90f4-a172809217c4.xhtml), *Using Pipes
    and Redirection in Scripts*. For now, accept that the text we used for `${file_content}`
    will be written to the file (as you can check yourself).
  prefs: []
  type: TYPE_NORMAL
- en: Managing absolute and relative paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is an issue we have not discussed yet: running scripts with absolute
    and relative paths. This might seem like a trivial difference, but it most certainly
    is not. Most commands you run, while directly interactive or from within a script
    you call, use your current working directory as their current working directory.
    You might have expected commands in a script to default to the directory where
    the script is, but since the script is nothing more than a fork of your current
    shell (as explained at the beginning of this chapter), it also inherits the current
    working directory. We can best illustrate this by creating a script which copies
    a file to a relative path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The script itself is pretty easy – check if a directory is present, otherwise
    create it. You can check for errors on `mkdir` by using our shorthand error handling.
    Next, copy a known file (`/var/log/dpkg.log`) to the `dpkg` directory. The first
    time we run it, we''re in the same directory as the script. We can see the `dpkg`
    directory that was created there and the file copied inside it. Then, we move
    our current working directory to `/tmp/` and we run the script again, this time
    using the absolute path instead of the relative path of the first call. Now, we
    can see that the `dpkg` directory is created at `/tmp/dpkg/`! Not really unexpected,
    but how could we `avoid` this? Just a single line at the beginning of the script
    will fix this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As the code execution should show, we now do everything relative to the script
    location. This is made possible by a little bit of Bash magic combined with the
    `dirname` command. This command is pretty simple as well: it prints the directory
    name from whatever we pass, in this case, $0\. As you might remember, $0 resolves
    to the script name as it is called. From /tmp/, this is the absolute path; if
    we call it from another directory, it might be a relative path. If we are in the
    same directory as the script, `dirname`, $0 will result in `.`, which means we
    `cd` to the current directory. This is not really needed, but it does not do any
    harm either. This seems like a small payoff for a much more robust script, which
    we can now call from wherever we want!'
  prefs: []
  type: TYPE_NORMAL
- en: For now, we won't go into details regarding the `$(...)` syntax. We will further
    discuss this in [Chapter 12](15141e02-be0c-4709-90f4-a172809217c4.xhtml), *Using
    Pipes and Redirection in Scripts*. At this point, remember that this allows us
    to get a value which we can pass to `cd` in a single line.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with y/n
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the beginning of this chapter, we presented you with something to think
    about: asking the user to agree or disagree with something by stating yes or no.
    As we discussed, there are many possible answers we can expect a user to give.
    Realistically, there are five ways a user could give us a *yes*: y, Y, yes, YES,
    and Yes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same goes for *no*. Let''s see how we could check this without using any
    tricks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'While this works, it is not really a very workable solution. Even worse, if
    the user happens to have Caps Lock on while they''re trying to type *Yes*, we
    will end up with *yES*! Do we need to include that as well? The answer is, of
    course, no. Bash has a nifty little feature called **parameter expansion**. We
    will explain this in much more depth in [Chapter 16](89ec6d77-023a-482a-bd93-23e3945002bf.xhtml),
    *Bash Parameter Substitution and Expansion*, but for now, we can give you a preview
    of what it is capable of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of five checks for each answer, we now use two: one for the full word
    (yes/no) and one for the short one-letter answer (y/n). But, how does the answer
    *YES* work, when we have only specified *yes*? The solution to this question lies
    in the ,, and ^^, which we have included inside the variable. So, instead of ${reply_variable},
    we used ${reply_variable,,} and ${reply_variable^^}. In the case of ,,, the variable
    is first resolved to its value and then converted to *all lowercase letters*.
    Because of this, all three answers – *YES, Yes, and yes* – can be compared with
    *yes*, as that is how Bash will expand them. You might take a guess at what ^^
    does: it converts the content of the string to uppercase, which is why we can
    compare it to NO, even though we give the answer no.'
  prefs: []
  type: TYPE_NORMAL
- en: Always try to place yourself in the users' shoes. They are dealing with many
    different tools and commands. In most of these cases, logic as given for dealing
    with different ways of writing yes/no has been integrated. This can make even
    the most friendly system administrator a bit lazy and train them to go for the
    one-letter answer. But you wouldn't want to punish the sysadmin that actually
    listens to you, either! So, make a point of dealing with the most *reasonable*
    answers in a friendly manner.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed many aspects of errors in Bash scripts. First,
    error **checking** was described. To start with, we explained that an exit status
    is a way for commands to communicate whether their execution was considered a
    success or failure. The `test` command and its shorthand `[[...]]` notation were
    introduced. This command allows us to perform functional checks in our scripts.
    Examples of this are comparing strings and integers, and checking if a file or
    directory is created and accessible/writable. We gave a quick refresher on variables,
    followed by a short introduction to running a script with the debug flag, `-x`,
    set.
  prefs: []
  type: TYPE_NORMAL
- en: The second part of this chapter dealt with error **handling**. We described
    the (unofficial) `if-then-exit` construct, which we use to check command execution
    and exit if it failed. In the examples that followed, we saw that we do not always
    have to write return code to variables when we want to check them; we can use
    $? directly in a test case. Going on, we gave a preview of how we can use `if-then-else`
    logic to handle errors in a better way. We ended the second part of this chapter
    by presenting the shorthand syntax for error handling, which we will continue
    to use throughout the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the third and final part of this chapter, we explained error **prevention**.
    We learned how we can check if the arguments are correct and how we can avoid
    issues with absolute and relative paths when calling our script. In the final
    part of this chapter, we answered the question we posed at the beginning: How
    can we best deal with yes/no input from the user? By using some simple Bash parameter
    expansions (which will be further explained in the last chapter of this book),
    we were able to simply facilitate multiple answering styles for the users of our
    script.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands were introduced in this chapter: `mktemp`, `true`, and `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why do we need an exit status?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between exit status, exit code, and return code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which flag do we use with test to test for the following?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An existing directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A writable file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An existing symbolic link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the preferred shorthand syntax for `test -d /tmp/`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we print debug information in a Bash session?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we check whether a variable has content?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Bash format for grabbing a return code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of `||` and `&&`, which is the logical AND and which is the OR?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Bash format for grabbing the number of arguments?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we make sure that it does not matter from which working directory the
    user calls the script?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do Bash parameter expansions help us when dealing with user input?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources might be interesting if you''d like to go deeper into
    the subjects of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The test** **command**: [http://wiki.bash-hackers.org/commands/classictest](http://wiki.bash-hackers.org/commands/classictest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bash debugging**: [http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_03.html](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_03.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logical operators**: [https://secure.php.net/manual/en/language.operators.logical.php](https://secure.php.net/manual/en/language.operators.logical.php)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
