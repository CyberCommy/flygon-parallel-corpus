- en: '*Chapter 2*: Exploring TypeScript'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll dive deeper into the TypeScript language. We'll learn
    about TypeScript's explicit type declaration syntax, as well as about the many
    built-in types in TypeScript and their purpose.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also learn how to create our own types and build applications adhering
    to object-oriented principles. Finally, we'll review some of the latest features
    added to the language, such as optional chaining and nullish coalescing.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a strong understanding of the TypeScript
    language, which will allow you to read and understand existing TypeScript code
    with ease. You will also know enough about the language to produce high-quality
    code that achieves your application goals and is reliable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are types?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring TypeScript types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding classes and interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the latest features and configuring the compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The requirements for this chapter are the same as in [*Chapter 1*](B15508_01_Final_JC_ePub.xhtml#_idTextAnchor017),
    *Understanding TypeScript*. You should have a basic understanding of JavaScript
    and web technologies. You will once again be using Node and **Visual Studio Code**
    (**VSCode**).
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository is again at [https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node).
    Use the code in the `Chap2` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before continuing, let''s set up for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to your `HandsOnTypeScript` folder and create a new folder called `Chap2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open VSCode and go to `Chap2` folder you just created. Then, select **View**
    | **Terminal** and enable the terminal window within your VSCode window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type the `npm init` command, as in [*Chapter 1*](B15508_01_Final_JC_ePub.xhtml#_idTextAnchor017),
    *Understanding TypeScript*, to initialize the project for `npm`, and accept all
    the defaults.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type the `npm install typescript` command, as in [*Chapter 1*](B15508_01_Final_JC_ePub.xhtml#_idTextAnchor017),
    *Understanding TypeScript*, to install TypeScript.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we're ready to get started.
  prefs: []
  type: TYPE_NORMAL
- en: What are types?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **type** is a reusable set of rules. A type may include properties and functions
    (capabilities). It can also be shared and reused over and over again. When you
    reuse a type, you are creating an **instance** of it. This means that you are
    creating an example of your type that has specific values for properties. In TypeScript,
    as the name implies, types are very important. They're the main reason why the
    language was created in the first place. Let's take a look at how types work in
    TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: How do types work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned previously, JavaScript does have types. Number, string, Boolean,
    array, and so on are all types in JavaScript. However, those types are not explicitly
    set during declaration; they are only inferred at runtime. In TypeScript, types
    are normally set during declaration. It is possible to allow the compiler to infer
    your type. However, the type the compiler chooses may not be the one you desire
    since it isn't always obvious. In addition to the types supported by JavaScript,
    TypeScript has its own unique types and also allows you to create your own types.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to realize about types in TypeScript is that they are handled
    by their shape and not by their type name. This means the name of a type is not
    that important for the TypeScript compiler, but the properties it has and their
    types are important.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `shape.ts` and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing you should notice is that we have a class called `Person` with
    a property called `name`. Below that, you see that we have a variable called `jill`
    that is of the `{ name: string }` type. This is a little weird because, as you
    can see, this type declaration is not an actual type name; it''s more like a type
    definition. But the compiler has no issues with it and does not complain. In TypeScript,
    it is possible to define and declare a type at the same time. Additionally, below
    that, you can see that we have another variable called `person` of the `Person`
    type and we set that to `jill`. Again, the compiler does not complain, and everything
    seems OK.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compile this code and run it to see what happens. Type the following
    lines in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve run the commands, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – The shape.ts output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.01_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – The shape.ts output
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the code compiles and runs without issue. This demonstrates
    that in TypeScript, the compiler looks at the shape of a type and is not concerned
    with its name at all. You will see in later chapters, as we dig more deeply into
    TypeScript types, why it is so important to be aware of this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring TypeScript types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll look at some of the core types available in TypeScript.
    Using these types will give you error checking and compiler warnings that can
    help improve your code. They will also provide information about your intent to
    other developers that may be on your team. So, let's continue and see how these
    types work.
  prefs: []
  type: TYPE_NORMAL
- en: The any type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `any` type is a dynamic type that can be set to any other type. If you declare
    a variable to be of the `any` type, this means that you can set it to anything
    and reset it to anything else later as well. It is in effect no type because the
    compiler will not check it on your behalf. This is the key fact to remember about
    `any` – the compiler will not intercede and warn you of issues at development
    time. Therefore, if possible, using the `any` type should be avoided. It may seem
    weird that a language that was built to be statically typed would have such a
    feature, but it is a necessity under certain circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: In a large application, it is not always possible for a developer to control
    the types that come into their code. For example, if a developer is relying on
    a web service API call to get data, that data's type may be controlled by some
    other team or even a different company entirely. This is also true during interop,
    when code relies on data from a different programming language – for example,
    when a company maintains a legacy system in another language while building out
    its new system in a different language. Situations like these require type flexibility
    and an escape hatch from the type system.
  prefs: []
  type: TYPE_NORMAL
- en: It is important not to abuse the `any` type. You should be careful to only use
    it when you know you have no other alternative – for example, when type information
    is not clear or can change. There are a few alternatives to using the `any` type,
    however. Depending on the circumstance, you may be able to use interfaces, generics,
    unions, or the `unknown` type instead. We'll cover the rest of these possibilities
    later, but for now, let's go over the `unknown` type next.
  prefs: []
  type: TYPE_NORMAL
- en: The unknown type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `unknown` type is a type released in TypeScript version 3\. It is similar
    to `any` in that once a variable of this type is declared, a value of any type
    can be set to it. That value can subsequently be changed to any other type. So,
    I could start by setting my variable to a string type and then later set it to
    number. However, you cannot call any of its members or set the variable as a value
    to another variable without first checking what its type really is. I'll show
    an example of this as follows. The only time you can set `unknown` to something
    else without first checking its type is when you set an `unknown` type to another
    `unknown` or an `any` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of `any` and then we''ll see why the `unknown`
    type is preferable to using the `any` type (it is in fact recommended by the TypeScript
    team over using `any`):'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at an example of the issue with using `any`. Go to
    VSCode and create a file called `any.ts`, and then type the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this code using the following commands, you will see the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – any run result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.02_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – any run result
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `val` is of the `any` type, we can set it to whatever we like and later
    call `push` into it since `push` is a method of `Array`. However, this is obvious
    only because we, as developers, are aware that `Array` has a method called `push`
    in it. What if we accidentally called something that does not exist on `Array`?
    Replace the previous code with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the TypeScript compiler again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 2.3 – any failing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.03_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – any failing
  prefs: []
  type: TYPE_NORMAL
- en: For this simple example, this error is unlikely, but in a large application,
    it is an easy error to make, even if the mistake is simply to mistype something.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a similar example using `unknown`:'
  prefs: []
  type: TYPE_NORMAL
- en: First, comment out your code inside of `any.ts` and delete the `any.js` file
    (as we will use the same variable names, if you do not, it will cause conflict
    errors).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: We'll learn about something called namespaces later that can eliminate these
    sorts of conflicts, but it's a little too soon to introduce them now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a new file called `unknown.ts` and add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that VSCode gives you an error, immediately complaining about
    the `push` function. This is weird since obviously, `Array` has a method called
    `push` in it. This behavior shows how the `unknown` type works. You can consider
    the `unknown` type to be sort of like a label more than a type, and underneath
    that label is the actual type. However, the compiler cannot figure out the type
    on its own, so we need to explicitly prove the type to the compiler ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use type guards to prove that `val` is of a certain type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we've wrapped our `push` call with a test to see whether `val`
    is an instance of `Array`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have established this to be true, the call to `push` can proceed without
    error, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.4 – unknown'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.04_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – unknown
  prefs: []
  type: TYPE_NORMAL
- en: This mechanism is a bit cumbersome since we always have to test the type before
    calling members. However, it is still preferable instead of using the `any` type
    and a lot safer since it is checked by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Intersection and union types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remember when we started this section by saying that the TypeScript compiler
    focuses on type shape and not the name? This mechanism allows TypeScript to support
    what''s called `obj` that has two types associated with it. You will recall that
    in TypeScript, we can not only declare named types as a variable''s type but also
    dynamically define and declare a type at the same time. In the following code,
    each type is a distinct type, but the `&` keyword is used to merge the two into
    a single type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try running this code and displaying the result on the console. Create
    a new file called `intersection.ts` and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you compile and run this code, you will see an object that contains both
    the name and age properties together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Intersection result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.05_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – Intersection result
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, both IntelliSense and the compiler accept the code and the final
    object has both properties. This is an intersection type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other type is similar and is called the `union` type. In the case of unions,
    instead of merging types, we are using them in an "or" fashion, where it''s one
    type or another. Let''s look at an example. Create a new file called `union.ts`
    and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `unionObj` variable is declared to be of the null type or `{ name: string
    }`, by the use of the `|` character. If you compile and run this code, you''ll
    see that it accepts both type values. This means that the type value can be either
    null or an object of the `{ name: string }` type.'
  prefs: []
  type: TYPE_NORMAL
- en: Literal types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Literal** types are similar to union types, but they use a set of hardcoded
    string or number values. Here''s a simple example of string literals that is fairly
    self-explanatory. As you can see, we have a bunch of hardcoded strings as the
    type. This means that only values that are the same as any of these strings will
    be accepted for the literal variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the compiler is happy to receive any of the values on the list
    and even reset them. However, it will not allow the setting of a value that is
    not on the list. This will give a compile error. Let''s see an example of this.
    Update the code as shown by resetting the literal variable to `john`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we set the literal variable to `john`, and compiling gives the following
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – A literal error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.06_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – A literal error
  prefs: []
  type: TYPE_NORMAL
- en: A numeric literal is also possible in the same way, but the values are made
    of numbers instead of strings.
  prefs: []
  type: TYPE_NORMAL
- en: Type aliases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Type aliases are used very frequently in TypeScript. This is simply a method
    to give a different name to a type and most of the time it is used to provide
    a shorter simpler name to some complex type. For example, here''s one possible
    usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we take a long numeric literal type and give it a shorter name
    of `Points`. Then, we declare `score` as the `Points` type and give it a value
    of `20`, which is one of the possible values for `Points`. And of course, if we
    tried to set score to, let's say, `99`, compilation would fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of aliases would be for object literal type declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Since the type declaration is very long and does not have a name, as, for example,
    a class would, we use an alias instead. Type aliasing can be used for just about
    any type in TypeScript, including things such as functions and generics, which
    we'll explore further later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Function return types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For completeness'' sake, I wanted to show one example of a function return
    declaration. It''s quite similar to a typical variable declaration. Create a new
    file called `functionReturn.ts` and add this into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `runMore` function takes a parameter of the `number` type and returns a
    number. The parameter declaration is just like any variable declaration, but the
    function return comes after the parentheses and indicates what type is returned
    by the function. If a function returns nothing, then you can either not declare
    any type for the return or you can declare `void` to be more explicit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of returning `void`. Comment out the `runMore` function
    and console log, and then compile and run this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The two functions return nothing but write their given parameters to the console,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Function void results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.07_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7 – Function void results
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, their internal `console.log` statements do run. However, trying
    to grab a return value results in `undefined` since nothing is being returned.
  prefs: []
  type: TYPE_NORMAL
- en: So, function return type declaration is quite similar to variable declarations.
    Now, let's take a look at using functions as types.
  prefs: []
  type: TYPE_NORMAL
- en: Functions as types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It may seem a bit odd but in TypeScript, a type can also be an entire function
    signature. That is to say that in the previous section, we saw how functions can
    accept parameters based on types and also return a type. Well, this definition
    is also known as a function signature. In TypeScript, this signature can also
    act as a type for an object's properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of this. Create a new file called `functionSignature.ts`
    and add the following code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line shows us a function type that we will be using in this code.
    The `Run` type alias is only there to make it easier to reuse the long function
    signature. The actual function type is `(miles: number) => boolean`. This looks
    odd, but it''s nothing more than a slimmed-down function signature. So, the only
    things needed then are the parentheses to indicate parameters, the `=>` symbol,
    which indicates that this is a function, and then the return type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code after the function definition line, you have the declaration of
    the `runner` variable as the `Run` type, which is again a function. This function
    simply checks whether the person has run more than 10 miles, and returns `true`
    if they have and `false` if they have not. Then, at the bottom of the code, the
    `console.log` statement writes out the result of the function call. You should
    see this once compiled and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Function type result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.08_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 – Function type result
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, calling `runner` with a parameter of `9` would make the function
    return `false`, which is correct. With static typing, it is important to be able
    to type all the ways we can return data, which means not only variables but also
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: The never type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This type is going to sound quite strange at first. A `never` type is used to
    indicate a function that never returns (completes), or a variable that is not
    set to anything, not even `null`. At first glance, this sounds like the `void`
    type. However, they are not at all the same. In `void`, a function does return,
    in the complete sense of the word, it just does not return any value (it returns
    `undefined`, which is no value). In the case of `never`, the function does not
    finish at all. Now, this seems totally useless but it's actually quite useful
    for indicating intent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, let''s look at an example. Create a file called `never.ts` and add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this function returns a `union` type that is either `never`
    or a Boolean. Now, we could have only indicated the Boolean and the code would
    still work. However, in this function, we are throwing an error if the person
    is over a certain age, indicating that this is an unexpected `age` value. So,
    since encapsulation is a high-level principle for writing good-quality code, it
    is beneficial to indicate explicitly that a failure of the function to return
    could occur without needing the developer to know about the internals of how the
    function works. `never` provides that communication.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the many built-in types in TypeScript. We
    were able to see why using these types can improve our code quality and help us
    catch errors early on in the coding cycle. In the next section, we'll learn about
    how we can use TypeScript to create our own types, and also follow object-oriented
    programming principles.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding classes and interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already briefly looked at classes and interfaces in previous sections.
    Let's take a deeper look, in this section, and see why these types can help us
    write better code. Once we complete this section, we will be better prepared to
    write more readable, reusable code with fewer bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At a base level, classes in TypeScript look just like classes in JavaScript.
    They are a container for a related set of fields and methods that can be instantiated
    and reused. However, classes in TypeScript support extra features for encapsulation
    that JavaScript does not. Let's take a look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `classes.ts` and enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this example shows a simple class that, with the exception of
    the static typing, is just like what you might see in JavaScript. Firstly, you
    have a name for the class so that it can be reused. Next, you have a constructor,
    which is used to initialize any fields that the class might have and do any other
    setup for the class instance (again, an instance is just a specific example of
    our class with its own unique values for fields). Then, you have a single variable
    called `msg` declared and a function called `speak` that writes the `msg` value
    to the console. We then create an instance of our class. Finally, we set the `msg`
    field to a value of `hello` and call the `speak` method. Now, let's look at how
    classes differ between TypeScript and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Access modifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We stated previously that one of the main principles of object-oriented development
    is encapsulation, or information hiding. Well, if we take a look at the code again
    clearly, we are not hiding the `msg` variable as it is exposed and editable outside
    of the class. So, let''s see what TypeScript allows us to do about this. Let''s
    update the code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we updated the constructor with a keyword called `private`.
    This method of declaring a constructor parameter and also adding an access modifier
    is doing several things in one line. Firstly, it is telling the compiler that
    the class has a field called `msg` of the `string` type that should be `private`.
    Normally, this sort of declaration is done in a line above or below the constructor
    separately, which is totally valid to do, but TypeScript allows us to use a shortcut
    by adding it to the constructor parameter. Additionally, by adding this to the
    constructor, you can see that it allows our `msg` field to be set at instantiation
    time with the `new Person("hello")` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what does setting something to `private` actually do? By setting the field
    to `private`, we make it inaccessible from outside of the class. The result of
    this is that `tom.msg = "hello"` no longer works and causes an error. Try removing
    the comments and compile again. You should see this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Classes error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.09_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.9 – Classes error
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it complains that a private member, `msg`, cannot be accessed
    from outside of the class. Now, we only applied our modifier to a field, but note
    that access modifiers can be applied to any member field or function.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, ECMAScript 2020 will support private fields via the
    `#` symbol. However, only fields are supported, and it is such a new standard
    that browser support is limited as of the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s learn about the `readonly` modifier. This one is relatively straightforward;
    it causes a field to become read-only after it has been set one time in the constructor.
    So, update the code as follows and add `readonly` to the declaration of the `msg`
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you do this, IntelliSense complains because, in the `speak` function, we
    are attempting to change the value of `msg` even though it has already been set
    once through the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The `private` and `readonly` access modifiers are not the only modifiers available
    in TypeScript. There are several other types of access modifiers. However, they
    will make more sense if we explain them in the context of inheritance later.
  prefs: []
  type: TYPE_NORMAL
- en: Getters and setters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another feature of classes is actually available in both TypeScript and JavaScript:
    **getters** and **setters**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Getter**: A property that allows modification or validation of a related
    field before returning it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Setter**: A property that allows modification or computation of a value before
    setting to a related field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In some other languages, these types of properties are known as computed properties.
    Let''s look at an example. Create another file called `getSet.ts` and add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There's a fair amount happening here, so let's go over it before compiling and
    running. First, you can see that our `message` field is not available in the constructor
    but is a `private` field, and therefore not accessible directly from outside our
    class. The only initializer the constructor takes is our `name` field. After that,
    you can see the `Message` property is a getter because its name is prefixed with
    the `get` keyword. In the getter, we test to see whether our `message` field value
    has the speaker's name in it, and if it does not, we throw an exception to indicate
    an unwanted situation. The setter, also called `Message`, is indicated by the
    `set` keyword and this property receives a string and adds the speaker's name
    if needed by checking whether it is missing from the `message` field. Note that
    although both `getter` and `setter` look like functions, they are not. When they
    are called later in code, they are called just like a field would be called without
    the parentheses. So then, toward the end of the code, the speaker object is instantiated
    to a new speaker with a name of `john` and its `Message` property is set to `hello`.
    Thereafter, the message is written to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we want to compile this code so that we can run it, but we need to do something
    a bit differently this time. The TypeScript compiler has options that it can take
    in order to customize its behavior. In the case of this example, getters and setters
    and the `includes` function are only available in ES5 and ES6, respectively. If
    you're not familiar with it, the `includes` function checks whether a string is
    a substring of a larger string. So, let's tell the TypeScript compiler that it
    needs to compile to a newer JavaScript target than ES3, which is the default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the new compile command you''ll need (we''ll go over the `tsc` compiler
    options in more depth later, including using a configuration file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can run the command. Once again, it''s as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'So, you now get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – getSet output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.10_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10 – getSet output
  prefs: []
  type: TYPE_NORMAL
- en: 'To drive the point home further, let''s try switching the `speaker.Message
    = "hello"` line to `speaker.message = "hello"`. If you compile, you should see
    this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Message field error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.11_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.11 – Message field error
  prefs: []
  type: TYPE_NORMAL
- en: Can you guess why this failed? Yes, this occurred because `message` is a `private`
    field and cannot be accessed from outside our class.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why I mentioned `getters` and `setters` here when they
    are available in regular JavaScript too. If you look at the example, you can see
    that the `message` field is `private` and the `getter` and `setter` properties
    are `public` (note that when you are not explicitly declaring access modifiers,
    the default is `public`). So, to allow good encapsulation, it is a best practice
    to hide our field and only expose it when needed via a getter and/or setter or
    some function that allows modification of the field. Also remember, when deciding
    on an access level to your members, that you want to start with the most restrictive
    capabilities first and then become less restrictive as needed. Additionally, by
    allowing field access via accessors, we can do all sorts of checks and modifications,
    as we've done in our example, so that we have ultimate control over what comes
    in and out of our class.
  prefs: []
  type: TYPE_NORMAL
- en: Static properties and methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, let's discuss **static** properties and methods. When you mark something
    as static inside of a class, you are saying that this member is a member of the
    class type and not of the class instance. Therefore, it can be accessed without
    needing to create an instance of a class, but instead by prefixing with the class
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example. Create a new file called `staticMember.ts` and add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you attempt to compile this code, it will fail, stating that `typeName`
    is a static member of the `ClassA` type. Again, static members must be called
    using the class name. Here are the fixed versions of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we reference `typeName` with the class name. So then, the question
    is why might I want to use a static member instead of an instance member? Under
    certain circumstances, it may be useful to share data across class instances.
    For example, I might want to do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the case of this example, I am trying to determine the last class instance
    that has called the `run` function at any given time. This can be straightforward
    by using a static member. Another point to be aware of is that inside a class,
    static members can be called by both static members and instance members. However,
    static members cannot call instance members.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have learned about classes and their features in this section. This will
    help us design our code for encapsulation, which will enhance its quality. Next,
    we will learn about interfaces and contract-based coding.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In object-oriented programming design, another important principle is abstraction.
    The goal of abstraction is to reduce complexity and the tight coupling of code
    by not exposing the internal implementation (we've already covered abstraction
    in [*Chapter 1*](B15508_01_Final_JC_ePub.xhtml#_idTextAnchor017), *Understanding
    TypeScript*). One way of doing this is to use **interfaces** to show only the
    signature of a type, as opposed to its internal workings. An interface is also
    sometimes called a contract, since having specific types for parameters and return
    types enforces certain expectations between both the user and the creator of the
    interface. So, another way of thinking about interfaces is as strict rules about
    what can come out of and go into a type instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, interfaces are just a set of rules. In order to have working code, we
    need an implementation of those rules to get any work done. So, let''s show an
    example of an interface with implementation to get started. Create a new file
    called `interfaces.ts` and add the following interface definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This interface defines an `Employee` type that we will create instances for
    later. As you can see, there is no implementation of the `getUniqueId` function,
    just its signature. The implementation comes later when we define it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the implementation to the `interfaces.ts` file. Insert the following
    code, which creates two instances of the `Employee` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we create an instance by instantiating an object literal called `linda`,
    setting the two field names – `name` and `id` – and then implementing the `getUniqueId`
    function. Later, we console log the `linda.getUniqueId` call. After that, we create
    another object, called `pam`, based on the same interface. However, not only does
    it have different field values, but its implementation of `getUniqueId` is also
    different than the `linda` object. This is the main use of interfaces: to allow
    for a single structure across objects but to enable different implementations.
    In this way, we provide strict rules about what the type structure is, but also
    allow some flexibility in terms of how functions go about doing their work. Here''s
    the output of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Employee interface results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.12_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.12 – Employee interface results
  prefs: []
  type: TYPE_NORMAL
- en: Another possible use of interfaces is when using third-party APIs. Sometimes,
    the type information is not well documented and all you're getting back is untyped
    JSON or the object type is extremely large and has many fields you will never
    use. It is quite tempting, under these circumstances, to just use `any` as the
    type and be done with it. However, you should prefer providing a type declaration
    if at all possible.
  prefs: []
  type: TYPE_NORMAL
- en: What you can do under these circumstances is to create an interface that has
    only the fields that you know and care about. Then, you can declare your data
    type to be of this type. At development time, TypeScript will not be able to check
    the type since for API network call's data will be coming in at runtime. But regardless,
    since TypeScript only cares about the shape of any given type, it will ignore
    the fields not mentioned in your type declaration and as long as the data comes
    in with the fields you defined in your interface, the runtime will not complain
    and you will maintain development time type safety. However, please do be careful
    to handle `null` or `undefined` fields appropriately, by allowing them to use
    unions or testing for those types.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about interfaces and the differences between interfaces
    and classes. We will be able to use interfaces to abstract away the implementation
    details of a class and therefore produce loose coupling between our code and therefore
    better code quality. In the next section, we will learn about how classes and
    interfaces allow us to perform inheritance and therefore code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll learn about **inheritance**. Inheritance in object-oriented
    programming is a method for doing code reuse. This will shrink our application
    code size and make it more readable. Also, generally, shorter code tends to have
    fewer bugs. So, all these factors will improve our app quality once we get started
    building.
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated, inheritance is primarily about allowing code reuse. Inheritance
    is also conceptually designed to be like real-life inheritance so that the logical
    flow of inheritance relationships can be intuitive and easier to understand. Let''s
    look at an example of this now. Create a file called `classInheritance.ts` and
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Quick note if you've never seen back ticks, ``, and `${}` before. It's called
    string interpolation and is simply a quick and easy way to insert string values
    inside strings by embedding objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, there is a base class, also known as a parent, called `Vehicle`.
    This class acts as the main container for source code that is being reused later
    by whatever classes inherit from it, also known as children. The child classes
    inherit from `Vehicle` by using the `extends` keyword. One thing to notice that''s
    important is that in the constructor for each child class, you see that the first
    line of code is the call to `super`. `super` is the name of the instance of the
    parent class that a child is inheriting from. So, in this case, that would be
    the `Vehicle` class. Now, as you can see, each child is passing a different number
    of wheels to the parent''s `wheelCount` variable via the parent''s constructor.
    Then, at the end of the code, an instance of each child, `Motorcycle` and `Automobile`,
    is created and the `showNumberOfWheels` function is called. If we compile and
    run this code, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – The classInheritance result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.13_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.13 – The classInheritance result
  prefs: []
  type: TYPE_NORMAL
- en: 'So then, each child provides a different number of wheels to the parent `wheelCount`
    variable, although they cannot access the variable directly. Now, let''s say that
    there was a reason why the child classes would want to access the `wheelCount`
    variable of the parent directly. For example, let''s say that if a flat tire occurred,
    an updated wheel count would be necessary. What could we do? Well, let''s try
    creating a function unique to each child class that tries to update `wheelCount`.
    Let''s see what happens. Update the code by adding a new function, `updateWheelCount`,
    to the `Motorcycle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As a test, if we update only the `Motorcycle` class and add an `updateWheelCount`
    function as shown, we get an error. Can you guess why? It''s because we are trying
    to access a private member of the parent class. So, therefore, even when child
    classes inherit their members from a parent, they still do not have access to
    that parent''s `private` members. This is the right behavior, again to promote
    encapsulation. So then, what do we do? Well, let''s try editing the code again
    to allow this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Do you see the small change we made? That's right, we changed the `wheelCount`
    parameter on the `Vehicle` parent class constructor to be of the `protected` accessor
    type. `protected` allows the class and any inheriting classes to have access to
    the member.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to the next topic, let''s introduce the concept of `namespaces.ts`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this code, even before compiling, VSCode IntelliSense is
    already complaining that `FirstClass` cannot be found. This is because it is hidden
    from `namespace B`, since it is only defined in `namespace A`. This is the purpose
    of namespaces, to hide information within one scope, away from other scopes.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about inheriting from classes. Class inheritance
    is a very important tool for reusing code. In the next section, we'll look at
    using abstract classes, which is a more flexible way of doing inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned previously, interfaces can be useful for defining contracts, but
    they have no implementation for working code themselves. Classes have working
    implementations, but sometimes only a signature is required. It is possible, for
    certain situations, that we may want to have both in one object type. For these
    types of scenarios, you would use an `abstractClass.ts` and copy and paste our
    code from our `classInheritance.ts` file into it. If you do this, you might get
    some errors, since the two files both have the same class and variable names.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in our new `abstractClass.ts` file, we are going to update it with namespaces
    and modify the `Vehicle` class to be abstract. Add the namespace and update the
    `Vehicle` class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: So, to start, we've obviously wrapped all the code within a bracket called `namespace
    AbstractNamespace` (note that a namespace can have any name; it does not need
    `namespace` in the name). Again, this is merely a container that allows us to
    control scoping so that the members of our `abstractClass.ts` file do not bleed
    out into the global scope, and thereby affect other files.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the new `Vehicle` code, we have a `new` keyword before the class
    called `abstract`. This is what indicates that the class will be an abstract one.
    You can also see that we have a new function called `updateWheelCount`. This function
    has an `abstract` keyword in front of it, which indicates that it will have no
    implementation within the `Vehicle` class and needs to be implemented by an inheriting
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, after the `Vehicle abstract` class, we want our child classes that are
    inheriting from it. So, add the `Motorcycle` and `Automobile` classes below the
    `Vehicle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the classes, we instantiate them and call their respective `updateWheelCount`
    methods, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the implementation of the `abstract` member `updateWheelCount`
    is in the child classes. This is the capability that an abstract class provides.
    An abstract class can act both as a regular class, providing member implementations,
    and as an interface, providing only the rules for implementation for a child class.
    Note that since an abstract class can have abstract members, you cannot instantiate
    an abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, if you look at the `Automobile` class, you can see that it has
    its own implementation of `showNumberOfWheels`, even though this function is not
    abstract. This demonstrates something called **overriding**, which is the ability
    of a child's member to create a unique implementation of the parent's member.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the different kinds of class-based inheritance.
    Learning about inheritance will allow us to reuse more of our code, reducing both
    code size and potential bugs. In the next section, we'll learn about doing inheritance
    with interfaces and how it's different from class-based inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As explained earlier, **interfaces** are a way of setting agreed-upon rules
    for a type. They will allow us to separate implementation from definition and
    therefore provide abstraction, which again is a powerful object-oriented programming
    principle that will give us higher-quality code. Let's learn about how to use
    interfaces to inherit explicitly and in a well-structured way.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript interfaces provide a set of type signatures for an interface''s
    members but have no implementation themselves. Now, we did show some examples
    of using standalone interfaces, but this time, let''s see how we can use interfaces
    as a means of doing inheritance and code reuse. Create a new file called `interfaceInheritance.ts`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'After the namespace, you can see that there is an interface called `Thing`,
    and after that, the `Vehicle` interface is defined and it inherits from `Thing`
    using the `extends` keyword. I put this into the example to show that interfaces
    can also inherit from other interfaces. The `Thing` interface has two members
    – `name` and `getFullName` – and as you can see, although `Vehicle` extends `Thing`,
    there is no mention of those members anywhere inside of `Vehicle`. This is because
    `Vehicle` is an interface and therefore cannot have any implementation. However,
    if you look at the following code, at the `Motorcycle` class, you can see that,
    since this class extends `Vehicle`, the implementations are there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'So, if we compile and run this code, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – The interfaceInheritance result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.14_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.14 – The interfaceInheritance result
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces do not provide a means to do code reuse directly, as they have no
    implementation. However, it is still advantageous for code reuse because the structure
    of interfaces provides definite expectations around what code will receive and
    return. Hiding the implementation behind an interface is also beneficial in terms
    of doing encapsulation and abstraction, which are also important principles of
    object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: When using TypeScript, take full advantage of inheritance models from object-oriented
    programming that are available to you in TypeScript. Use interfaces to abstract
    implementation details. Use `private` and `protected` to help encapsulate data.
    Remember, when the time comes to compile and convert your code into JavaScript,
    the TypeScript compiler will do any translation work for you to get things back
    into the prototypical style. But while in development mode, you should take advantage
    of all the capabilities that TypeScript provides to enhance your development experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we learned about inheritance and how it can be used for code
    reuse. We learned about how to do inheritance with the three major container types:
    classes, abstract classes, and interfaces. You will see, once we begin coding
    our app, why being able to do code reuse is such a critical element in large application
    development. In the next section, we will cover generics, which will use the types
    that we learned about in this section.'
  prefs: []
  type: TYPE_NORMAL
- en: Learning generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Generics** allows a type definition to include an associated type that can
    be chosen by the user of the generic type, instead of being dictated by the type
    creator. In this way, there are structures and rules, but still some amount of
    flexibility. Generics will definitely come into play later when we code with React,
    so let''s learn about them here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generics can be used for functions, classes, and interfaces. Let''s look at
    an example of generics with functions. Create a file called `functionGeneric.ts`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If we start at the top, we see a function called `getLength<T>`. This function
    is using a generic that tells the compiler that wherever it sees the `T` symbol,
    it can expect any possible type. Now, internally, our function implementation
    checks to see whether the `arg` parameter has a field called `length` and then
    tries to grab it. If it does not, it just returns `0`. Finally, toward the bottom,
    you can see that the `getLength` function is called two times: once for a number
    and another time for a string. Additionally, you can see that for `number`, it
    explicitly has the `<number>` type indicator, whereas for `string`, it does not.
    This is there only to show that you can be explicit, but the compiler can usually
    figure out which type you meant based on the usage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The thing with this example is that there''s extra code in order to check for
    the `length` field. This makes the code busy and longer than it needs to be. Let''s
    update this code to prevent calls of this function if an argument does not have
    a `length` property. First, comment out the code we just wrote and add the following
    new code below it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This code is quite similar except we use an `HasLength` interface to constrain
    what types are allowed. Constraining generic types is done with the `extends`
    keyword. By writing `T extends HasLength`, we are telling the compiler that whatever
    `T` is, it must inherit from or be of the `HasLength` type, which effectively
    means that it must have the `length` property. Therefore, when the two previous
    calls are made, it fails for `number` types, since they don't have a `length`
    property, but works for `string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at an example that uses interfaces and classes. Let''s create
    a file called `classGeneric.ts` and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: So, we can see that we have an interface called `Wheels`, which provides wheel
    information. We can also see that the `Vehicle` interface takes a generic of type
    `T`, meaning any specific type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Subsequently, we see that the `Automobile` class implements the `Vehicle` interface
    with the generic as the `Wheel` type, which associates `Wheel` to `Automobile`.
    Then, finally, we see that the `Chevy` class extends `Automobile`, providing some
    default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'After all these types are defined, we create one instance of the `Chevy` class
    and log some output from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This code compiles and runs successfully and gives the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – The classGeneric.ts result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.15_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.15 – The classGeneric.ts result
  prefs: []
  type: TYPE_NORMAL
- en: You can see that our inheritance hierarchy is several levels deep, but our code
    is able to successfully return a valid result. Although specific details in real-world
    code may be different, nevertheless, the multi-level type hierarchy shown here
    is something that can happen quite frequently in object-oriented programming design.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about using generics on both functions and class
    types. Generics are commonly used in React development, as well as some Node packages.
    So, they will be of use once we start coding in later chapters. In the next section,
    we'll take a look at several miscellaneous items to round out this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the latest features and configuring the compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about some newer features in TypeScript, as well
    as how to configure the TypeScript compiler. By learning about these newer features,
    we will be able to write cleaner and easier-to-read code, which, of course, will
    be beneficial for working with the app in a team. By using the configuration options
    of TypeScript, we can have the compiler work in the way we think is best for our
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Optional chaining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at `null` objects. Let''s create a file called `optionalChaining.ts`
    and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If we look at this code, we can see that there are several types being used
    together. `car` has a property of `wheels`, and `wheels` has a property of `count`.
    So, later when we log, you can see that calls are being chained together. For
    example, the last `console.log` line refers to `car?.wheels?.count`. This is called
    optional chaining. The question mark indicates that the object could possibly
    be `null` or `undefined`. If it is `null` or `undefined`, then the code will end
    at that object, returning whichever value the object or property is, and not continue
    to the rest of the properties, but without causing an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we wrote the bottom console code the old way, we would have to do a
    great deal of code testing in order to make sure that we would not cause an error
    by calling something that is potentially `undefined`. We would use the ternary
    operation and it could look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, this is both difficult to write and read. So then, by using optional
    chaining, we allow the compiler to stop as soon as `null` or `undefined` is found
    and just pass that back. This saves us from writing a bunch of verbose, potentially
    error-prone code.
  prefs: []
  type: TYPE_NORMAL
- en: Nullish coalescing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Nullish coalescing is simply a shortcut of the ternary operator. So, it''s
    pretty straightforward and it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The double question marks work from left to right. The statement means if `val1`
    is not `null` or `undefined` and has an actual value, then return that value.
    However, if `val1` does not have a value, return `val2`. So, in this case, compiling
    and running would result in `10` being written to the console.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering whether this is the same thing as the `||` operator. It's
    somewhat similar but more constrained. The logical or operator, when it is used
    in this manner, is checking for "truthyness." In JavaScript, this is a concept
    where a large set of possible values can be considered "truthy" or "falsey." For
    example, `0`, `true` or `false`, `undefined`, and `""` all have true or false
    equivalency in JavaScript. However, in the case of nullish coalescing, only `null`
    or `undefined` specifically are being checked.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript configurations can be passed in via the command line or, more commonly,
    through a file called `tsconfig.json`. If you use the command line, then call
    the compiler like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This tells TypeScript to ignore any `tsconfig.json` file and just use the command-line
    options – in this case, the `–lib` option, which states which version of JavaScript
    is being used during development, and compiles only this one file. If you just
    put `tsc` onto the command line, TypeScript will look for a `tsconfig.json` file
    and use that configuration and compile all `ts` files it finds.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many options, so we won''t cover all of them here. However, let''s
    review a few of the most important ones (when we start coding, I''ll provide a
    sample `tsconfig.json` file to use):'
  prefs: []
  type: TYPE_NORMAL
- en: '`--lib`: This is used to indicate which JavaScript version you will use during
    development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--target`: This indicates which version of JavaScript you want to emit out
    into `.js` files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--noImplicitAny`: Does not allow the `any` type, without explicitly declaring
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--outDir`: This is the directory where JavaScript files will be saved to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--outFile`: This is the final JavaScript filename.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--rootDirs`: This is an array that stores the `.ts` file source code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--exclude`: This is an array of folders and files to exclude from compilation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--include`: This is an array of folders and files to include in compilation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section provided just a brief overview of some newer features of TypeScript,
    as well as some configuration-related information. Nevertheless, these newer features
    and the ability to configure TypeScript are very important and will be used extensively
    once we start writing code in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the TypeScript language. We learned about
    the many different types that exist in the language and also how to create our
    own types. We also learned about how to use TypeScript to create object-oriented
    code. It was a large and complex chapter but will be absolutely necessary knowledge
    for when we begin building our app.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will review some of the most important features in traditional
    JavaScript. We will also learn about some of the newer features in the latest
    versions of the language. Since TypeScript is a true superset of JavaScript, it
    is important to have an up-to-date understanding of JavaScript in order to make
    maximal usage of TypeScript.
  prefs: []
  type: TYPE_NORMAL
