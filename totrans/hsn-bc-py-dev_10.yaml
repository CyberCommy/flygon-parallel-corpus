- en: Frontend Decentralized Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to write a decentralized application
    that has a GUI frontend. This is a desktop decentralized application. People can
    interact with a smart contract using buttons and text fields. It is a step forward
    from the Truffle console or a `web3.py` script. While writing this GUI frontend,
    we will learn about the best practices when dealing with a smart contract, which
    are how to deal with latency and how to provide added value in a decentralized
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to learn about the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Qt GUI library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Qt for Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crash course on Qt for Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the smart contract for the Twitter-like application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the GUI for the Twitter-like application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the Qt GUI library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Qt library is a C++ framework that was designed to create a multi-platform
    application. In Linux, this library is the foundation for the KDE desktop. Its
    counterpart is the GTK+ library, the foundation for Gnome desktop. However, the
    Qt library has stepped up its game. You can use the Qt library to create applications
    on Android and iOS. People have sometimes mistaken the Qt library as a library
    that only creates GUI applications. However, the Qt library comprises non-GUI
    libraries as well, for example, data storage, multimedia, and networking. The
    Qt library even contains a threading library! In the past, you could create an
    open source application for free with the Qt library. However, if you want to
    create a proprietary application with the Qt library, you must pay for the license.
    You can now have a bit more flexibility when it comes to using the Qt library.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a proprietary application with the Qt library for free, but only
    if you provide a relinking mechanism for Qt libraries, provide a license copy,
    and explicitly acknowledge Qt usage, among other things, as described at [https://www.qt.io/download](https://www.qt.io/download).
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a GUI library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has a plethora of GUI libraries to choose from. This includes Tkinter,
    Phoenix (wxPython), PyGObject, PyQt, Qt for Python (PySide2), among many others.
    Deciding which GUI library should be used for a Python application is sometimes
    subjective.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter is a Python GUI library, but the UI is not slick and polished. PyGObject
    is a good choice only if you want to write a desktop application in Linux, because
    it uses GTK+. There is support for GTK+ in Windows and Mac, but it's not native.
  prefs: []
  type: TYPE_NORMAL
- en: I am going to choose the Qt for Python ([https://www.qt.io/qt-for-python](https://www.qt.io/qt-for-python))
    library. This is the official Python binding for the Qt library from Qt itself.
    Be careful, though; there is another Python binding for the Qt library from another
    company. This library is called PyQt, and the company is Riverbank. These libraries
    both support the latest Qt library, which is Qt 5.
  prefs: []
  type: TYPE_NORMAL
- en: There are differences between these two libraries. If you want to write and
    sell a proprietary application using PyQt, you must purchase a license from Riverbank.
    However, you don't need to do that with Qt for Python, although that comes with
    its own set of restrictions. For example, you must provide a relinking mechanism
    for Qt libraries. There are books written covering PyQt, but there are none for
    Qt for Python at the time of writing this book.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, the reliable Python binding for Qt could only be obtained from Riverbank.
    However, in the middle of this year, Qt announced its Python binding for its latest
    Qt library (Qt 5.11). Qt is quite serious about promoting this Python binding.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Qt for Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, you must install Qt 5.11\. Go to [https://www.qt.io/download](https://www.qt.io/download).
    While downloading the library, you have two types of license to choose from—commercial
    and open source. In this case, you must choose the open source option:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are on the Linux platform, you will download the following file: `qt-unified-linux-x64-3.0.5-online.run`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is an installer. If you run it, you will get the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d60f27ee-0d99-4025-9ba1-4b4d3437bac1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click Next. You will then be greeted with a login screen. Create a new account
    if you don''t have one; it''s free. After that, log in through the following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f84f73ff-6695-4b22-bc40-8188bbd00527.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, you will see the installer''s welcome screen. From here, click Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/fb5b7151-45e7-4929-b1e0-f9b1bf4127ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Specify where you want to install the Qt library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/87570186-4634-4eda-b86e-3ff6e7f42090.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then choose Qt 5.11.2 or the latest stable release:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/a071062f-b3e1-473d-8de6-e07fa933ffd9.png)'
  prefs: []
  type: TYPE_IMG
- en: It will be a while before the installer finishes doing its job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the Qt 5 installation process is finished, you can install the Python
    binding to Qt using the following command lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to write a smart contract and a decentralized application with
    this virtual environment. We need to install the `populus`, `vyper`, and `web3`
    libraries as usual:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add Vyper support to `project.json` by changing the value of the `"compilation"` key
    to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The latest version of Vyper is 0.1.0b6, and it breaks Populus. The developer
    needs some time to fix it. If the bug has not been fixed while you are reading
    this book, you could patch Populus yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check whether the bug has been fixed or not using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In our case, the bug has not been fixed.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s patch Populus to fix the bug using the following command lines.
    Make sure you are still in the same directory (`qt-venv/src/populus`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Crash course on Qt for Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write a simple application using our GUI library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `hello.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run it using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You will now see a blank window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/235e96c8-e28b-4cf0-915e-a4c9f8138b4b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s go through this file to better understand Qt for Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `sys` import is from the standard Python library. This is required because
    we want to get the arguments from the command line when we launch this GUI application
    script. Then we import `QApplication` and `QWidget` from `PySide2.QtWidgets`.
  prefs: []
  type: TYPE_NORMAL
- en: What is `PySide2`? It comes from `PySide`, which is a Python binding for Qt
    4\. `PySide2` is a Python binding for Qt 5\. `PySide` was released in 2009 by
    Nokia (the former owner of Qt). Previously, Nokia failed to reach an agreement
    with Riverbank to make the `PyQt` license LGPL. Consequently, Nokia decided to
    create its own Python binding for Qt and named it `PySide`. The ownership of Qt
    moved from Nokia to the Qt company. The Qt company decided to beef up their effort
    to develop this Python binding for Qt, especially after Qt 5 was released.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two classes we import from `PySide2.QtWidgets`, which are `QApplication`
    and `QWidget`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QApplication` is a class designed to manage GUI application flows and its
    settings. It checks your desktop configuration, such as the font, and passes it
    to the GUI. It also understands the incoming objects from the desktop, for example,
    when you copy text from the text editor and paste it to the GUI application. There
    can only be one `QApplication` in your GUI script:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We create an instance of `QApplication` and pass the command-line argument.
    Most of the time, you would not use any command-line argument. You could pass
    the command-line argument if you want to tell the GUI application to use a different
    style or display text from right to left to cater to Arabic users, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second class we import from `PySide2.QtWidgets` is `QWidget`. This is the
    base class of any widget you will ever use when creating a GUI application, such
    as a button, a text field, a slider, or a label. If you construct the base class,
    you would get an empty window. This is similar to UIView in iOS. We then resize
    the window:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `window.show()` method, we display the window object and then enter
    the main loop with `app.exec_(*)*`. This is where the `QApplication` will dispatch
    all events from the desktop to the GUI. We wrap this process inside `sys.exit()`
    so we can get the return code from `QApplication`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we add another widget, we must learn about the concept of layout. We
    will use two layouts, which are `QHBoxLayout` and `QVBoxLayout`. These two layouts
    are enough to create a GUI application. There are other layouts, such as `QGridLayout` and `QFormLayout`,
    among many others, but we do not need them. `QHBoxLayout` and `QVBoxLayout` are
    like flexbox in CSS. You place widgets in a container that uses `QHBoxLayout`,
    and then all widgets will be put in a horizontal line. Let''s take a look at an
    example. Name this script `hello_horizontal_layout.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ll explain the code line by line. We start by importing the libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Other than the classes we imported in the previous script, we import `QHBoxLayout`
    (the horizontal layout) and two widgets (`QPushButton` and `QLabel`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We initialize `QApplication` followed by four widgets (two buttons and two
    labels). `QPushButton` and `QLabel` receives a string as first argument for their
    label. Here, we just constructed four widgets, but we haven''t displayed them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code constructs the horizontal layout with the `QHBoxLayout`
    class. Then we will fill the layout with four widgets that we have previously constructed.
    In this situation, `hello_button` will be the leftmost widget in the layout while
    `world_label` will be the rightmost widget. Then, we construct a `window` object
    and tell it to use our horizontal layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This statement will put our widgets inside the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we display the window, execute the `QApplication` instance, and run it
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You will then see the following result, four widgets displayed from left to
    right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b85254b2-eda6-48ca-b1e4-96d0b2c50812.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To get a vertical layout, create another script and name it `hello_vertical_layout.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, instead of `HBoxLayout`, you use `QVBoxLayout` to get a vertical layout.
    Run the script using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You will then see four widgets displayed in the window from top to bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ec67b26b-72b6-4180-9ca5-3998417b474b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to combine horizontal and vertical layout, you can embed a horizontal
    layout inside of the vertical layout, and vice versa. To do this, create a script
    named `hello_vertical_horizontal_layout.py`. Refer to the code file in the following
    GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_07/crash_course_qt_for_python/hello_vertical_horizontal_layout.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_07/crash_course_qt_for_python/hello_vertical_horizontal_layout.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The thing you need to notice here is that you need to add a nested layout with
    the `addLayout` method from a layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Be careful here! You embed a layout into another layout using the `addLayout`
    method, not `addWidget`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following script to view the nested layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Doing this will give you the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c23bbbe3-9723-4a64-9cf5-7fc52b559a0e.png)'
  prefs: []
  type: TYPE_IMG
- en: Other widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a script to show more varieties of widgets. To begin, name the
    script `hello_varieties.py`. Refer to the code file in the following GitLab link
    for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_07/crash_course_qt_for_python/hello_varieties.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_07/crash_course_qt_for_python/hello_varieties.py).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of the script can be viewed in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s dissect the code line by line. We start by importing libraries using
    the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we import many new types of widgets, such as `QGroupBox`, `QSpinBox`,
    `QLineEdit`, `QRadioButton`, and `QComboBox`. There are a lot of widgets in Qt,
    we just don''t have time to discuss all of them. Then, we initialize all of the
    widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'These are new types of widget. Let''s discuss these new widgets and their unique
    properties. `QSpinBox` is a box that you use to choose a number. You can spin
    this widget by clicking the top or bottom arrow. `QLineEdit` is a text field,
    while `QRadioButton` is a radio button and `QComboBox` is a select box. Then,
    we initialize the horizontal layout and the vertical layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We put some widgets into the vertical layout and put some other widgets into
    the horizontal layout. Then, we need to put these layouts in a bigger container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We now create two group boxes with the `QGroupBox` class. The first group box
    got a vertical layout, while the other group box got a horizontal layout. A group
    box is like a container with a border. This is similar to `<div>` in HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To contain these two group boxes, we need another layout. Here, we use a vertical
    layout. The rest is as usual. We construct a window, give it a layout, then display
    it before launching the `QApplication` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following script to see many different types of widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You would then see a screen that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/786f68a9-db6a-4d58-a7a6-d3c336a8c2f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Callback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have created many widgets and layouts.Now we need to give
    a widget a job to do, by which I mean what we want a button to do when it is being
    clicked. Currently, a button would not do anything if it is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a simple script to explain how we can give a callback to a button
    for the clicking event. Name it `hello_connect_simple.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script contains the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through this code line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Other than the usual libraries you import, you must import `QtCore`. `QtCore`
    provides a way for widgets to communicate. So, if you want to enable a button
    to communicate with a label such as "After I have been clicked, please set your
    label to this string", you need to import `QtCore`. Then you create widgets and
    put the widgets inside a layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You instantiate the `QApplication` class, create a button and a label, then
    put the widgets inside a vertical layout.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding lines of code, we create a function to set the text in a label.
    `setText` is a method of `QLabel` for changing the label. In the next line, we
    connect a clicked signal of a button to this function. This means that if we click
    `QPushButton`, `set_text_in_world_label` will be executed. `QPushButton` has signals
    other than clicked, such as pressed and released. Then, we create a window widget,
    and show it with the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script to test the callback that we have created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the script, you will get the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bc900870-ade7-4bfa-95dd-e803b4c503f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you then click the button, the label widget will change the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b963ca54-d6dc-4772-a6e6-3e722dc642ef.png)'
  prefs: []
  type: TYPE_IMG
- en: The button does not have a parameter to be sent to the callback function. But
    another widget may have parameters to be sent to the callback function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a script to illustrate this option. Name the script `hello_connect_param.py`.
    The content of the script can be viewed in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Focus on these lines to see how we can have a parameter in a callback that
    a widget has:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Our callback function has a parameter. The `textChanged` signal of the line
    edit widget has a parameter. When we change the text in the line edit widget,
    the text will be sent to the callback function.
  prefs: []
  type: TYPE_NORMAL
- en: This line, `hello_line_edit.textChanged.connect(set_world_label)`, is equivalent
    to `hello_line_edit.connect(QtCore.SIGNAL('textChanged(QString)'), set_world_label)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the script to test the callback that has a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As you type in the line edit, the text in the label widget changes as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/59b87d5e-2426-434b-95e7-0c3333042c03.png)'
  prefs: []
  type: TYPE_IMG
- en: We use a callback because we want to manipulate the text before we set it to
    a label widget. However, if you want to send the text parameter from the line
    edit widget to the label widget directly, you don't have to create a dedicated
    function, you can use `signal` and `slot`.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, remove the callback, then change this `line hello_line_edit.textChanged.connect(set_world_label)` to
    `hello_line_edit.connect(QtCore.SIGNAL('textChanged(QString)'), world_label, QtCore.SLOT('setText(QString)'))`.
  prefs: []
  type: TYPE_NORMAL
- en: As you type the text in the line edit, your text will be displayed in the label
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: You can also change that line to `QtCore.QObject.connect(hello_line_edit, QtCore.SIGNAL('textChanged(QString)'),
    world_label, QtCore.SLOT('setText(QString)'))`.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you see the pattern here. If widget A wants to communicate with widget
    B, widget A will use `signal` to connect with widget B's `slot`. Of course, you
    can swap the `slot` part with a custom callback on which you call the API of widget
    B.
  prefs: []
  type: TYPE_NORMAL
- en: This `signal` and `slot` concept is general and not limited to GUI widgets.
    It means that you can define a custom `signal` and custom `slot`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a script to illustrate this new concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s dissect this script. We import the libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Slot and signal functionality comes from the `QtCore` class. You can create
    a `slot` function with the `Slot` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create a class that is a child of `QObject` in order to create
    a `signal` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You must instantiate this class. `signal` must be part of an instance, not
    a class. You can then connect it with a `slot` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The last part is to send the parameter from `signal` to `slot`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the script to test whether the callback still works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Threading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use a thread in Qt, we can use the `QThread` class from `QtCore`. Hopefully,
    you can see a pattern here. `QtCore` has many functionalities beyond creating
    widgets. Threading is important because when building a decentralized application
    we will have to wait for quite some time for the transaction to be confirmed.
    Depending on how generous you are with the gas and the traffic in Ethereum, the
    wait could be anything from a few minutes to half an hour. We don't want the GUI
    application to freeze for a minute, let alone half an hour.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a simple script to demonstrate how we create a thread using `QThread`.
    Name the script `hello_thread.py`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You will then subclass `QThread` inside the class where you write what you want
    to do inside the `run` method. To utilize this threading class, you instantiate
    the class and then call the `start` method. Then you can do all the things you
    want to do in the main application while waiting for the threading class to do
    its job. If you want to wait for the threading class to finish the job, you can
    call its `wait` method from the threading class.
  prefs: []
  type: TYPE_NORMAL
- en: Threading is a vast subject. We haven't discussed mutex or thread safety, but
    we will not need to for our decentralized application.
  prefs: []
  type: TYPE_NORMAL
- en: Some people feel dread at the thought of using threading in their application.
    The alternative is using single-threaded concurrent code using the `asyncio` library.
    That's perfectly fine, but in this case, we will use threading.
  prefs: []
  type: TYPE_NORMAL
- en: We have everything we need to know about how to use Qt library to build a Python
    desktop application. Before we write our GUI decentralized application, we need
    to write a smart contract because without this, there would be no decentralized
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the smart contract for the Twitter–like application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now going to build a censorship resistant, Twitter-like application.
    This means that even the owner of the smart contract could not delete a tweet
    from the user of the smart contract. This Twitter-like application is very simple;
    there is no option of following, liking, or retweeting; it just consists of tweets.
    In addition, the user cannot delete their tweets and they must be less than 32
    bytes, which is even shorter than the original tweet limit in Twitter!
  prefs: []
  type: TYPE_NORMAL
- en: 'We now come back to our Populus project to modify our `project.json` file.
    Add this to `project.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This is the smart contract. Create a `TwitterOnBlockchain.vy` file inside the `twitter_like_projects/contracts`
    directory*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This is a very short smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start from the struct data type variable declaration and the mapping of
    the address to this struct data type variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `tweets` variable is a mapping data type from an address to an array of
    `messages` and `index`. An array of `messages` has the length of 10 `bytes32`
    data type variables, which means that each account or address can have a maximum
    of 10 tweets in this smart contract. `index` is a pointer to the array of `messages`.
    Each time we create a tweet, `index` is increased by 1 so it can point to the
    next slot in the array of `messages`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `write_a_tweet` function is a method to create a tweet. This simply consists
    of inserting a tweet inside an array of `messages` with some guards to avoid an
    overbound error.
  prefs: []
  type: TYPE_NORMAL
- en: Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the test for this smart contract. You can save the test file in `tests/test_twitter_on_blockchain.py`.
    Refer to the code file in the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_07/twitter_on_blockchain/tests/test_twitter_on_blockchain.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_07/twitter_on_blockchain/tests/test_twitter_on_blockchain.py).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block shows the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This test ensures that the `index` starts at zero and will be increased by one
    after the user tweets in this smart contract. It also checks that the tweet is
    kept inside the array of `messages`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's reflect on that for a moment. If you look at the smart contract, the owner
    could not censor the tweets from anyone. The owner could not even delete the smart
    contract, so neither the government nor the mafia could pressure the owner of
    the smart contract to censor tweets. Compare this situation to one in which the
    owner of an application uses a traditional web application. The owner of the application
    could censor tweets by deleting entries from the database. Alternatively, the
    government or the mafia could apply pressure to the owner of the application to
    censor the tweets, or the government or the mafia could take down the hosting
    server. In the case of blockchain, this means that people need to take down half
    of the 10,000 nodes to be able to disrupt the Ethereum blockchain in order to
    destroy the smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the things that makes blockchain special—**censorship resistance**.
    This does not mean it cannot be censored, but it is very hard to be censored.
    In order to shut down this smart contract, the government would have to ban the
    Ethereum network itself. Alternatively, they could install spyware in all citizens' computers
    and make sure they don't access this smart contract. On top of that, censorship
    resistance does not mean it protects privacy. The government can still figure
    out who writes what.
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy the smart contract, run Ganache, compile the smart contract, and
    then deploy the smart contract to Ganache using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Fixtures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we develop a decentralized GUI application, let''s write a script to
    put some fixtures in the smart contract. Fixtures are like sample data. This makes
    developing an application a more pleasurable experience. Call the script `fixtures.py`.
    Refer to the code file in the following GitLab for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_07/dapp/fixtures.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_07/dapp/fixtures.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s dissect this script line by line. We import the `Web3` class and the `HTTPProvider` class
    from `web3`. We use `HTTPProvider` because we want to use Ganache. Then we import `wait_for_transaction_receipt` from
    the `populus` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we have the private keys from the first three accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t need the private key of the first account or the account that launched
    the smart contract; we only need the second and the third account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the `abi` that you can get from the compilation of the smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: You put the address of the smart contract in the `address.txt` file. You received
    the address when you deployed the smart contract through Populus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you construct a smart contract object based on the smart contract''s address
    and `abi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: For each account, you create 10 tweets. Each tweet is something like 'Tweet
    1', 'Tweet 2', and so on. These fixtures enable us to check the tweets without
    having to create one first. It's beneficial to check the functionality of the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Building the GUI frontend for the Twitter–like application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's build a decentralized GUI application. Name the script `twitter_dapp.py`.
    Refer to the code file in the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_07/dapp/twitter_dapp.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_07/dapp/twitter_dapp.py)[:](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_07/dapp/twitter_dapp.py)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s dissect this script line by line. Here, we import the necessary classes
    and set our `web3` object to Ganache, which serves the smart contract in port `7545` of
    localhost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define the `abi` as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We then create a smart contract object by providing the address of the smart
    contract and the `abi`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a helper function that removes `''\x00''` from a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, our tweet data type in a smart contract is `bytes32`, which will
    append `\x00` until it reaches 32 bytes. Consequently, if you set this `bytes32`
    variable a `''messi''` string that has 5 bytes, it will be `''messi\x00\x00\x00\x00...\x00''`.
    This utility function will strip `\x00` from the string so that we can get `''messi''`
    back. Then , we move into the threading class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This is a thread class that aims to read the data from the blockchain. But isn't
    reading data supposed to be fast, because we are using Ganache and we don't need
    to involve the miners? If your blockchain node is in the same computer as your
    GUI frontend script, then this threading class is not needed. However, what if
    you put your blockchain node in the cloud? Perhaps you don't have enough space
    in your local computer, and that makes you do this. This kind of setup will introduce
    latency in your program, so it is a good idea to use a thread to wait for the
    result from the blockchain in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: '`fetched_posts` is a signal that will send the list of tweets to a slot that
    we will define later. Inside the `run` method, we get the index first so we know
    how many tweets the tweeter has posted. Due to the fact that what we get from
    the smart contract is a byte, we decode it first before we send the tweet to the
    `slot` function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is a thread class that we use for creating a transaction
    in the smart contract. To use this thread class, we need a private key. Remember,
    we need to sign a transaction with a private key. However, we also need the address
    so we can get the nonce. We can ask the user to input the address as well, but
    it will be superfluous. We can derive the address from the private key by using
    the `account = w3.eth.account.privateKeyToAccount(''0x''+self.private_key)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'After getting the address, we get the `nonce` with this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we then build the transaction, sign the transaction, and send the
    transaction to the blockchain. We then wait for the transaction to be confirmed.
    After that, we emit the signal to the `slot` function, which we will define later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to create a GUI. We set the window title, subclass the `QWidget`,
    and set up the private group box where we will request private key from a user.
    We will add a writing button widget and configure a group box to display tweets.
    We then prepare a group box to display bookmarks and add all of them to a vertical
    layout. In addition, we create two threading instances. For each threading instance,
    we connect their signals to the `slot` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we create a group box on which we place line edits to receive
    the private key. We also put a label to display a notice when the private key
    that's entered is valid. Here, we use `QFormLayout`, not `QHBoxLayout` or `QVBoxLayout`.
    `QFormLayout` is very useful for creating a two-column layout. The first column
    is usually used as a container for labels, while the second column is usually
    used as container for inputs, such as line edits. So with this layout, we use
    the `addRow` method, and this accepts one or two arguments. If the number of arguments
    is two, then the arguments will be the widget on the left column and the widget
    on the right column. We then add a private key label and a line edit, followed
    by an OK dialog button and a notice label. For the dialog button, we connect the
    clicked signal to a method called `checkPrivateKey`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following method, we create a push button inside a horizontal layout.
    We connect the clicked signal to a method called `writeANewTweet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following method, we create a group box to show tweets. First, there
    is a line edit to accept the address of the tweeter. This is accompanied by a
    button for fetching tweets and bookmarking the address. The callbacks will be
    defined later. We also put a layout inside the layout to display all the tweets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following method, we create a group box to display bookmarks. This bookmarks
    layout is just a normal vertical layout. We read the bookmarks from the text file,
    and then we process the lines. Basically, the process is to remove the new lines
    from the text line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the `slot` function for fetching the tweets. It uses threading to do
    the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the `slot` function that adds the address of the tweeter to the bookmark
    text file. After adding the bookmark to the bookmark the text file, it updates
    the bookmark layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'In this method, we launch an input dialog that has only one line edit. After
    getting the input, we send the input to the threading class before running it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a callback function that checks whether the private key is valid or
    not. If it is valid (the address can be derived from the private key), we set
    the notice label to success:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'These two methods are to be used to fill tweets in the tweets layout. First,
    we clear the tweets in the vertical layout. We can get each widget from the layout
    with `takeAt` method. There is no method to delete all child widgets of the layout;
    we have to iterate them one by one. If the widget exists, we can delete it. After
    clearing all the tweets from the layout, we fill the layout with new tweets using
    the `addWidget` method. The same strategy is being used when dealing with bookmarks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The same strategy is used in the two following methods. We clear the bookmark
    widgets from the bookmarks layout by iterating them one by one and deleting the
    widget. Then we fill the bookmarks inside the bookmarks layout through the `addWidget` method.
    One difference between dealing with tweets and bookmarks is that we configure
    the label in the bookmark section so it can be selected using the mouse. The method
    responsible for this is the `setTextInteractionFlags` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameter is the current flag of the label that''s masked with the `Qt.TextSelectableByMouse` flag.
    If you use this code without masking it with the previous value, `label_field.setTextInteractionFlags(QtCore.Qt.TextSelectableByMouse)`,
    you can delete all current label selection configuration flags that the label
    widget has. Most of the time, you don''t want to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a callback to set the success message in the label widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, finally we launch the GUI frontend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Type the second address into Ganache to fetch the tweets that we set when executing
    the fixtures script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/eccfeb78-199b-4329-bd8e-952e27de8d5e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Type the private key and click OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5fb32e88-8755-48ff-97f7-3413f31e2e20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Write a new tweet button. It will launch a dialog box. Then type in
    your tweet and click on OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c26c07c0-3654-49ad-8886-244c215e91b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After typing a new tweet and confirming it, you will get a success message.
    Then you can click the button (Bookmark it!) to save the address into the `bookmarks`
    text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7461dd09-d39a-44d5-baaa-e282dcb70e94.png)'
  prefs: []
  type: TYPE_IMG
- en: If you want to build a frontend for a smart contract or a decentralized application,
    you need to keep two things in mind. First, handle the blocking function (sending
    transactions to the blockchain and waiting for them) gracefully either using threading
    or single-threaded coroutines (using the `asyncio` library). Secondly, while the
    smart contract handles the core things (censorship resistance messages), you could
    add more value to your decentralized application. The added value in our example
    application is the bookmark utility. Can you add a bookmark functionality in the
    smart contract? Of course you can. But if you put the functionality in the smart
    contract, you lose privacy, because everyone can read your bookmarks.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, you cannot put every feature in the smart contract because of
    the limitations of the smart contract. So if you want to add sentiment analysis
    using machine learning, it is best to do this outside the smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to build a GUI frontend for a smart contract
    and how to use Qt for Python or the `PySide2` library, which utilizes the Qt 5
    library. We set time aside to learn how to build a GUI application using Qt for
    Python. Starting with a simple application, we took into the layout, various widgets,
    signals and slots, and threading, and we finally gained an understanding of how
    to use the `PySide2` library. We built our smart contract to simulate Twitter
    in a simple way, delighting in the censorship resistance of this Twitter-like
    application. Next, we built the GUI frontend. This GUI application uses all the
    concepts you have learned so far. We used threading to connect to the blockchain
    so that the GUI would not freeze. We also added additional value through the ability
    to bookmark in our GUI application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you are going to learn how to create an ERC20 token. This
    is what makes Ethereum popular among developers. Tokens can be used as a substitute
    for money in certain environments.
  prefs: []
  type: TYPE_NORMAL
