- en: C++, RAII, and the GSL Refresher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will provide an overview of some of the recent advancements
    of C++ that are leveraged in this book. We will start by providing an overview
    of the changes made to C++ in the C++17 specification. We will then briefly cover
    a C++ design pattern called **Resource Acquisition Is Initialization** (**RAII**),
    how it is used by C++, and why it is so important to not only C++ but many other
    languages that leverage the same design pattern. This chapter will conclude with
    an introduction to the **Guideline Support Library** (**GSL**) and how it can
    help to increase the reliability and stability of system programming by helping
    to adhere to the C++ Core Guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Discussing the advancements made in C++17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outlining RAII
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the GSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to compile and execute the examples in this chapter, the reader must
    have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Linux-based system capable of compiling and executing C++17 (for example,
    Ubuntu 17.10+)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GCC 7+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake 3.6+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To download all of the code in this chapter, including the examples and code
    snippets, go to the following link: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: A brief overview of C++17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this section is to provide a brief overview of C++17 and the features
    added to C++. For a more comprehensive and in-depth look at C++17, please see
    the *Further reading* section of this chapter, which list additional books from
    Packt Publishing on the topic.
  prefs: []
  type: TYPE_NORMAL
- en: Language changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There were several changes made to the C++17 language and syntax. The following
    are some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Initializers in if/switch statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C++17, it is now possible to define a variable and initialize it in the
    definition of an `if` and `switch` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `i` variable is defined and initialized inside
    the `if` statement using a semicolon (`;`) inside the branch itself. This is especially
    useful for C- and POSIX-style functions that return error codes, as the variable
    that stores the error code can be defined in the proper context.
  prefs: []
  type: TYPE_NORMAL
- en: What makes this feature so important and useful is that the variable is only
    defined when the condition is met. That is, in the preceding example, `i` only
    exists if `i` is greater than `0`.
  prefs: []
  type: TYPE_NORMAL
- en: This is extremely helpful in ensuring that variables are available when they
    are valid, helping to reduce the likelihood of working with an invalid variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same type of initialization can occur with `switch` statements as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `i` variable is created only in the context of
    the `switch` statement. Unlike the `if` statement, the `i` variable exists for
    all cases, meaning the `i` variable is available in the `default` state, which
    could represent the invalid state.
  prefs: []
  type: TYPE_NORMAL
- en: Additions to compile-time facilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With C++11, `constexpr` was added as a statement to the compiler that a variable,
    function, and so on, can be evaluated at compile time and optimized, reducing
    the complexity of the code at runtime and improving performance overall. In some
    cases, the compiler was smart enough to extend `constexpr` statements to other
    components, including branch statements, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have created a `constexpr` variable, and we only output
    `Hello World` to `stdout` if `constexpr` is `true`. Since, in this example, it''s
    always true, the compiler will remove the branch from the code entirely, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code loads a couple of registers and calls `std::cout` without
    checking whether `val` is true, since the compiler completely removed the code
    from the resulting binary. The issue with C++11 was that the author could assume
    that this type of optimization was taking place, when in fact it might not be.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent this type of error, C++17 adds a `constexpr` `if` statement, which
    tells the compiler to specifically optimize the branch at compile time. If the
    compiler cannot optimize the `if` statement, an explicit compile-time error will
    occur, telling the user that optimization could not be done, providing the user with
    an opportunity to fix the issue (instead of assuming the optimization was taking
    place when in fact it might not be), for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have a more complicated `if` statement that leverages
    both a compile-time `constexpr` optimization as well as an `if` statement initializer.
    The resulting binary is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the branch has been removed from the resulting binary, and more
    specifically, if the expression was not a constant, the compiler would have thrown
    an error stating that this code could not be compiled as stated.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that this result is not the same binary as previously as
    one might expect. It would appear that GCC 7.3 has some additional improvements
    to make in its optimization engine, as the `constexpr` `i` variable that was defined
    and initialized inside the binary was not removed (as stack space was allocated
    for `i` in this code when it didn't need to be).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another compile-time change was a different version of the `static_assert`
    compile-time function. In C++11, the following was added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The goal of the `static_assert` function is to ensure that certain compile-time
    assumptions are true. This is especially helpful when programming a system to
    do things such as making sure a structure is a specific size in bytes, or that
    a certain code path is taken, depending on the system you''re compiling for. The
    problem with this assert was that it required the addition of a description that
    would be output during compile time, which likely just describes the assertion
    in English without providing any additional information. In C++17, another version
    of this assert was added, which removed the need for the description, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A welcome change to C++17 is the addition of nested namespaces. Prior to C++17,
    nested namespaces had to be defined on different lines, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we define a message that is output to `stdout` in
    a nested namespace. The problem with this syntax is obvious—it takes up a lot
    of space. In C++17, this limitation was removed by giving us the ability to declare
    nested namespaces on the same line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are able to define a nested namespace without the
    need for separate lines.
  prefs: []
  type: TYPE_NORMAL
- en: Structured bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'My favorite addition to C++17 is something called **structured bindings**.
    Prior to C++17, complex structures, such as a struct or `std::pair`, could be
    used to return more than one value as the output of a function, but the syntax
    was cumbersome, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `give_me_a_pair()` function returns `std::pair`
    with a `The answer is:` string and an integer of `42`. The result of this function
    is stored in a variable named `p` in the `main` function, and `std::get()` is
    needed to get the first and second portion of `std::pair`. This code is both cumbersome
    and inefficient without aggressive optimizations, as additional function calls
    are needed to retrieve the results of `give_me_a_pair()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++17, structured bindings provide us with a means to retrieve individual
    fields of a struct or `std::pair`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `give_me_a_pair()` function returns the same `std::pair`
    as before, but this time, we retrieve the results of `give_me_a_pair()` using
    structured bindings. The `msg` and `answer` variables are initialized to the results
    of `std::pair`, providing us with direct access to the results without the need
    for `std::get()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same is also possible with structures, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we create a structure that is returned by `give_me_a_struct()`.
    The results of this function are acquired using structured bindings instead of
    `std::get()`.
  prefs: []
  type: TYPE_NORMAL
- en: Inline variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A more controversial addition to C++17 is the inclusion of inline variables.
    As time progresses, more and more header-only libraries are being developed by
    various members of the C++ community. These libraries offer the ability to provide
    complex functionality to C++ without the need to install and link against the
    library (simply include the library and you're done). The issue with these types
    of libraries is that they have to play fancy tricks to include global variables
    in the library itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inline variables remove this issue, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the `msg` variable is declared as `inline`. This
    type of variable can be defined in a header (that is, a `.h` file) and included
    several times without multiple definitions being defined during linking. It should
    be noted that inline variables also remove the need for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Often, a global variable is needed by multiple source files and the preceding
    pattern is used to expose the variable to all of these source files. The preceding
    code is added to a header file that is included by all of the source files and
    then one source file actually defines the variable, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Although this works, this approach is cumbersome and it's not always clear which
    source file should actually define the variable. Using inline variables removes
    this issue, as the header both defines the variable and exposes the symbol to
    all of the source files that need it, removing the ambiguity.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in the library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to changes to the language's syntax, some library changes were also
    made. The following are some of the notable changes.
  prefs: []
  type: TYPE_NORMAL
- en: String View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As will be discussed in the *GSL* section of this chapter, there is a push within
    the C++ community to remove direct access to both pointers and arrays. Most segfaults
    and vulnerabilities discovered in applications can be attributed to the mishandling
    of pointers and arrays. As programs become more and more complex, and modified
    by multiple people without a complete picture of the application and how it uses
    each and every pointer and/or array, the likelihood of an error being introduced
    increases.
  prefs: []
  type: TYPE_NORMAL
- en: To address this, the C++ community has adopted the C++ Core Guidelines: [https://github.com/isocpp/CppCoreGuidelines](https://github.com/isocpp/CppCoreGuidelines).
  prefs: []
  type: TYPE_NORMAL
- en: The goal of the C++ Core Guidelines is to define a set of best practices that
    help to prevent common mistakes that are made when programming with C++, to limit
    the total number of errors that are introduced into a program. C++ has been around
    for years and, although it has a lot of facilities to prevent mistakes, it still
    maintains backward-compatibility, allowing old programs to coexist with new ones.
    The C++ Core Guidelines helps new and expert users navigate the many features
    that are available to help create safer and more robust applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the features that was added to C++17 in support of this effort is the
    `std::string_view{}` class. `std::string_view` is a wrapper around a character
    array, similar to `std::array`, that helps to make working with basic C strings
    safer and easier, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we create `std::string_view{}` and initialize it
    to an ASCII C string. We then output the string to `stdout` using `std::cout`.
    Like `std::array`, `std::string_view{}` provides accessors to the underlying array,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `front()` and `back()` functions can be used to
    get the first and last character in the string, while the `at()` function can
    be used to get any character in the string; if the index is out of range (that
    is, the index provided to `at()` is longer than the string itself), an `std::out_of_range{}`
    exception is thrown. Finally, the `data()` function can be used to get direct
    access to the underlying array. Although, this function should be used with care,
    as its use negates the safety benefits of `std::string_view{}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the accessors, the `std::string_view{}` class provides information
    about the size of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `size()` function returns the total number of
    characters in the string, while the `empty()` function returns `true` if `size()
    == 0` and `false` otherwise. `The max_size()` function defines the maximum size
    `std::string_view{}` can hold, which in most cases is unattainable or realistic.
    In the preceding example, the maximum string size is more than a million terabytes
    in size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike a `std::array`, the `std::string_view{}` provides the ability to reduce
    the size of the view of the string by removing characters from the front or back
    of the string, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `remove_prefix()` and `remove_suffix()` functions
    are used to remove one character from both the front and back of the string, resulting
    in `ello Worl` being outputted to `stdout`. It should be noted that this simply
    changes the starting character and repositions the ending null character pointer
    without having to reallocate memory. For more advanced functionality, `std::string{}`
    should be used, but it comes with the resulting performance hits of additional
    memory allocations.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to access substrings, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we access the `Hello` substring using the `substr()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to compare strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Like the `strcmp()` function, the compare function returns `0` when the two
    strings are compared, and a difference when they do not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, search functions are provided as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of this example are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `find()` function returns the location in the string of the first occurrence
    of `Hello` which in this case is `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rfind()` returns the location of the last occurrence of the provided string,
    which, in this case, is `24`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find_first_of()` and `find_last_of()` find the first and last occurrence of
    any of the characters provided (not the string as a whole). In this case, `H` is
    in the provided string, and `H` is the first character in `msg`, which means `find_first_of()`
    returns `0` since the `0` is the first index in the string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of `find_last_of()`, `l` is the last-occurring letter, at position
    `33`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find_first_not_of()` and `find_last_not_of()` are the opposite of `find_first_of()`
    and `find_last_of()`, returning the first and last occurrence of any character
    not in the provided string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::any, std::variant, and std::optional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Other welcome additions to C++17 are the `std::any{}`, `std::variant{}`, and
    `std::optional{}` classes. `std::any{}` is capable of storing any value at any
    time. Special accessors are needed to retrieve the data in `std::any{}`, but they
    are capable of holding any value in a type-safe manner. To accomplish this, `std::any{}`
    leverages an internal pointer, and memory must be allocated each time the type
    is changed, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we create `std::any{}` and set it to an `int` with
    the value of `42`, a double with the value of `4.2`, and a struct with the value
    of `42`.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::variant` is more like a type-safe union. A union reserves storage space
    for all of the types that are stored within the union at compile time (so no allocations
    is needed, but all of the possible types must be known at compile time). The problem
    with a standard C union is that there is no way to know what type is stored at
    any given time. Storing both an int and a `double` at the same time is problematic,
    since using both simultaneously will lead to corruption. With `std::variant`,
    this type of issue can be avoided, as `std::variant` is aware of what type it
    is currently storing, and attempting to access the data as a different type is
    not allowed (hence, `std::variant` is type-safe), for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `std::variant` is used to store both an `integer`
    and a `double`, and we can safely retrieve the data in `std::variant` without
    corruption.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::optional` is a nullable value type. A pointer is a nullable reference
    type in which the pointer is either invalid or is valid and stores a value. To
    make a pointer value, memory must be allocated (or at least pointed to). `std::optional`
    is a value type, meaning the memory for `std::optional` doesn''t have to be allocated,
    and under the hood, construction is only performed when the optional is valid,
    removing the overhead of constructing a default value type when it is not actually
    set. For complex objects, this not only provides the ability to determine whether
    an object is valid, it allows us to skip construction in the invalid case, which
    increases performance, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we create a simple class that stores an `integer`.
    In this class, we output a string to stdout when the class is constructed. We
    then create an instance of this class using `std::optional`. We attempt to access
    this `std::optional` before and after we actually set the class to a valid value.
    As shown, the class is not constructed until we actually set the class to a valid
    value. Since `sts::unique_ptr` used to be the common method for creating optionals,
    it should be no surprise that `std::optional` shares a common interface.
  prefs: []
  type: TYPE_NORMAL
- en: Resource Acquisition Is Initialization (RAII)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RAII is arguably one of the more notable differences between C and C++. RAII
    sets the foundation and design patterns for the entire C++ library, and has been
    the inspiration for countless other languages. This simple concept provides C++
    with an unmatched level of safety when compared to C, and this concept will be
    leveraged throughout this book when C and POSIX must be used in place of C++ (for
    example, when a C++ alternative either doesn't exist or is incomplete).
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea behind RAII is simple. If a resource is allocated, it is allocated
    during the construction of an object, and when the object is destroyed, the resource
    is released. To accomplish this, RAII leverages the construction and destruction
    features of C++, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we create a class that, on construction and destruction,
    outputs to `stdout`. As shown, when the class is instantiated, the class is constructed,
    and when the class loses focus, the class is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple concept can be leveraged to guard a resource, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, a pointer is allocated when `myclass{}` is constructed,
    and freed when `myclass{}` is destroyed. This pattern provides many advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: So long as the instance of `myclass{}` is visible (that is, can be accessed),
    the pointer is valid. So, any attempt to access the memory in the class is guaranteed
    to be safe as the deallocation of the memory only occurs when the scope of the
    class is lost, which would result in an inability to access the class (assuming
    pointers and references to the class are not used).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No leaking of memory can occur. If the class is visible, the memory that the
    class allocated will be valid. Once the class is no longer visible (that is, loses
    scope), the memory is freed and no leak occurs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifically, RAII ensures that the acquisition of a resource occurs at the
    initialization of the object, and the release of the resources occurs when the
    object is no longer needed. As will be shown later on in [Chapter 7](9ce08850-517a-42c0-9dcc-f30b94d96498.xhtml),
    *A Comprehensive Look at Memory Management*, `std::unique_ptr[]` and `std::shared_ptr{}`
    leverage this exact design pattern (although, these classes go above and beyond
    the preceding example to enforce ownership in addition to acquisition).
  prefs: []
  type: TYPE_NORMAL
- en: 'RAII does not just apply to pointers; it can be used for any resource that
    must be acquired and then released, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we create a class that opens a file and stores its
    handle on construction, and then closes the file on destruction and releases the
    handle. In the main function, we create an instance of the class that is both
    constructed and destructed as normal, leveraging RAII to prevent the file from
    leaking.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the normal case, we create a second class, which attempts to
    open a file that doesn't exist. In this case, an exception is thrown. The important
    thing to note here is the destructor is not called for this second instance. The
    is because the construction failed and threw an exception. As a result, no resource
    was acquired, thus, no destruction is required. That is, the acquisition of the
    resource is directly tied to the initialization of the class itself, and a failure
    to construct the class safely prevents the destruction of a resource that was
    never allocated in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: RAII is a simple yet powerful feature of C++ that is leveraged extensively in
    C++, and this design pattern will be expanded upon in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The Guideline Support Library (GSL)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As stated before, the goal of the C++ Core Guidelines is to provide a set of
    best practices associated with programming C++. The GSL is a library designed
    to assist in maintaining compliance with these guidelines. In general, there are
    some overall themes associated with the GSL:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pointer ownership**: Defining who owns a pointer is a simple way to prevent
    memory leaks and pointer corruption. In general, the best way to define ownership
    is through the use of `std::unique_ptr{}` and  `std::shared_ptr{}`, which will
    be explained in depth in [Chapter 7](9ce08850-517a-42c0-9dcc-f30b94d96498.xhtml),
    *A Comprehensive Look at Memory Management*, but in some cases, these cannot be
    used and the GSL helps to deal with these edge cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expectation management**: The GSL also helps to define what a function should
    expect for input and what it ensures for output, with the goal being to transition
    these concepts to C++ contracts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No pointer arithmetic**: Pointer arithmetic is one of the leading causes
    of program instability and vulnerabilities. Removing pointer arithmetic (or at
    least confining pointer arithmetic to well-tested support libraries) is a simple
    way to remove these types of issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointer ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Classical C++ doesn''t distinguish between who owns a pointer (that is, the
    code or object responsible for releasing the memory associated with a pointer)
    and who is simply accessing memory using a pointer, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we allocate a pointer to an integer, and then pass
    that pointer to a function called `init()`, which initializes the pointer. Finally,
    we delete the pointer after it has been used by the `init()` function. If the
    `init()` function were located in another file, it would not be clear whether
    the `init()` function should delete the pointer. Although in this simple example
    it might be obvious that this is not the case, in complicated projects with lots
    of code, this intent can be lost. Future modifications to such code can result
    in improper use of pointers whose ownership is not well-defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome this, the GSL provides a `gsl::owner<>{}` decoration that is used
    to document whether a given variable is an owner of the pointer, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we document that `p` in the `main` function is the
    owner of the pointer, meaning once `p` is no longer needed, the pointer should
    be released. Another issue with the preceding example is that the `init()` function
    expects the pointer to not be null. If the pointer were null, a null dereference
    would occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two common methods for overcoming the possibility of a null dereference.
    The first choice would be to check for a `nullptr` and throw an exception. The
    problem with this approach is you would have to perform this null pointer check
    on every function. These types of checks are costly and clutter code. The other
    option is to use a `gsl::not_null<>{}` class. Like `gsl::owner<>{}`, `gsl::not_null<>{}`
    is a decoration that can be compiled out of the code when debugging is not used.
    However, if debugging is enabled, `gsl::not_null<>{}` will throw an exception,
    `abort()`, or in some cases, refuse to compile if the variable is set to null.
    Using `gsl::not_null<>{}`, it is possible for a function to state explicitly whether
    or not null pointers are allowed and safely handled, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we create a pointer using `std::unique_ptr{}`, and
    then pass the resulting pointer to a function called `test()`. The `test()` function
    does not support a null pointer, and therefore states this using `gsl::not_null<>{}`.
    In turn, the `test()` function returns `gsl::not_null<>{}`, telling the user that
    the `test()` function ensures that the result of the function is not null (which
    is why the `test` function doesn't support a null pointer in the first place).
  prefs: []
  type: TYPE_NORMAL
- en: Pointer arithmetic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Pointer arithmetic** is a common source of bugs that lead to instability
    and vulnerabilities. For this reason, the C++ Core Guidelines discourages the
    use of this type of arithmetic. Here are some examples of pointer arithmetic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The last example is likely the most surprising. The subscript operator is,
    in fact, pointer arithmetic, and its use can lead to out-of-range bugs. To overcome
    this, the GSL provides the `gsl::span{}` class, which gives us a safe interface
    for working with pointers, including arrays, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how the preceding example works:'
  prefs: []
  type: TYPE_NORMAL
- en: We create an array and initialize it with a set of integers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a span into that array so that we can interact with the array safely.
    We output the array to `stdout` using a range-based `for` loop (as a span includes
    an iterator interface).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We output the array a second time to `stdout`, using a traditional index and
    subscript operator (that is, the `[]` operator). The difference with this subscript
    operator is each array access is checked for out-of-range errors. To demonstrate
    this, we attempt to access the array out of bounds and `gsl::span{}` throws a
    `gsl::fail_fast{}` exception. It should be noted that `GSL_THROW_ON_CONTRACT_VIOLATION`
    is used to tell the GSL to throw exceptions, instead of executing `std::terminate`
    or ignoring the bounds checks completely.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In addition to `gsl::span{}`, the GSL also contains specializations of `gsl::span{}`,
    which help us when working with common types of arrays. For example, the GSL provides
    `gsl::cstring_span{}`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`gsl::cstring_span{}` is a `gsl::span{}` that contains a standard C-style string.
    In the preceding example, we load `gsl::cstring_span{}` with a standard C-style
    string, using the `gsl::ensure_z()` function to ensure the string ends in a null
    character before continuing. We then output the standard C-style string using
    a regular `std::cout call`, and also by using a range-based loop.'
  prefs: []
  type: TYPE_NORMAL
- en: Contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ contracts provide the user with a means to state what a function expects
    as input, and what that function ensures as output. Specifically, a C++ contract
    documents a contract between the author of an API and the user of the API, it
    also provides compile-time and runtime validation of that contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'Future versions of C++ will have built-in support for contracts, but until
    then, the GSL provides a library-based implementation of C++ contracts by providing
    the `expects()` and `ensures()` macros, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we use the `Expects()` macro and pass it as `false`.
    Like the `assert()` function that is provided by the standard C library, the `Expects()`
    macro fails on `false`. Unlike `assert()`, `Expects()` will execute `std::terminate()`
    even when debugging is disabled, if the expression passed to `Expects()` evaluates
    to `false`. In the preceding example, we state that `Expects()` should throw a
    `gsl::fail_fast{}` exception instead of executing `std::terminate()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Ensures()` macro is the same as `Expects()`, with the only difference
    being the name, which is meant to document the contract''s output instead of its
    input, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we create a function that expects the input to be
    greater than or equal to `0` and less than `41`. The function then operates on
    the input and ensures the resulting output is always less than `42`. A properly-written
    function will define its expectations such that the `Ensures()` macros will never
    trigger. Instead, the `Expects()` checks will likely trigger instead, if the input
    would lead to an output that violates the contract.
  prefs: []
  type: TYPE_NORMAL
- en: Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The GSL also provides some helper utilities that are useful in creating a more
    reliable and readable code. One example of these utilities is the `gsl::finally{}`
    API, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`gsl::finally{}` provides a simple means to execute code just prior to a function
    exiting, by leveraging a C++ destructor. This is helpful when a function has to
    perform cleanup before exiting. It should be noted that `gsl::finally{}` is most
    useful in the presence of exceptions. Often, cleanup code is forgotten when an
    exception is fired, preventing the cleanup logic from ever executing. The `gsl::finally{}`
    API will always execute, even if an exception is fired, so long as it is defined
    just prior to performing an action that might generate an exception.'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we also include a useful macro that allows the use of
    `___` to define the name of the `gsl::finally{}` to use. Specifically, the user
    of `gsl::finally{}` must store an instance of the `gsl::finally{}` object so that
    the object can be destroyed on exiting the function, but having to name the `gsl::finally{}`
    object is cumbersome and pointless, as there are no APIs to interact with the
    `gsl::finally{}` object (its only purpose is to execute on `exit`). This macro
    provides a simple way of saying, *I don't care what the variable's name is*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other utility that the GSL provides are `gsl::narrow<>()` and `gsl::narrow_cast<>()`,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these APIs are the same as a regular `static_cast<>()`, with the only
    difference being that `gsl::narrow<>()` performs an overflow check while `gsl::narrow_cast<>()`
    is just a synonym for `static_cast<>()`, which documents that a narrowing of an
    integer is taking place (that is, converting an integer with a larger number of
    bits into an integer with fewer bits), for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we attempt to convert a 64-bit integer into a 32-bit
    integer using the `gsl::narrow<>()` function, which performs an overflow check.
    Since an overflow does occur, an exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we provided an overview of some of the recent advancements
    in C++ that are leveraged in this book. We started with an overview of the changes
    made to C++ in the C++17 specification. We then briefly covered a C++ design pattern
    called RAII, and how it is used by C++. Finally, we introduced the GSL and how
    it can help to increase the reliability and stability of system programming by
    helping to adhere to the C++ Core Guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go over UNIX-specific topics such as UNIX processes
    and signals, and a comprehensive overview of the System V specification, which
    is used to define how programs are written for UNIX on Intel CPUs.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are structured bindings?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What changes did C++17 make to nested namespaces?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What changes did C++17 make to the `static_assert()` function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an `if` statement initializer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does RAII stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is RAII used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does `gsl::owner<>{}` do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of `Expects()` and `Ensures()`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
