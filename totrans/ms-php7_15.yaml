- en: Testing the Important Bits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing quality software is a technically challenging and expensive activity.
    The technically challenging part comes from the need to understand and implement
    more than one type of application testing. Whereas, the expensive part comes from
    the fact that proper testing usually yields more code than the code we are testing,
    which translates to more time needed to get the job done.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike developers, businesses don't care as much about technicalities, as they
    care about reducing cost. This is where the two worlds clash at the expense of
    quality. While both understand the implications of a *technical debt* concept,
    rarely few take it seriously. Web applications come to mind as a nice example
    of this clash. The good enough UX and design is often sufficient to meet the needs
    of shareholders, while many of the internals and far-from-the-eye parts of the
    software are left untested.
  prefs: []
  type: TYPE_NORMAL
- en: Check out [https://en.wikipedia.org/wiki/Technical_debt](https://en.wikipedia.org/wiki/Technical_debt)
    for more information on the technical debt concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many types of testing we can apply to our application, some of which
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional Testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance Testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usability Testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acceptance Testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It would be unjust to say that one is more important than the other, as each
    addresses a very distinct segment of the application. The current state of the
    PHP ecosystem and tooling indicates *unit*, *functional*, and *performance testing* to
    be among the popular ones. In this chapter, we will take a quick look at a few
    of the tools and libraries that accommodate these types of testing:'
  prefs: []
  type: TYPE_NORMAL
- en: PHPUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: phpspec
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jMeter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software that a typical programmer believes to be thoroughly tested has often
    had only about 55 to 60 percent of its logic paths executed. Using automated support,
    such as coverage analyzers, can raise that roughly to 85 to 90 percent. It is
    nearly impossible to test software at the level of 100 percent of its logic paths.
  prefs: []
  type: TYPE_NORMAL
- en: '- Facts and Fallacies of Software Engineering book.'
  prefs: []
  type: TYPE_NORMAL
- en: PHPUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHPUnit is a representative of unit testing frameworks, whose overall idea is
    to provide a *strict contract* over an isolated piece of code that must be satisfied.
    This piece of code is what we call *unit*, which translates to the class and its
    methods in PHP. Using the *assertions* functionality, the PHPUnit framework verifies
    that these units behave as expected. The benefit of unit testing is that its early
    problem detection helps mitigate *compound* or *down-the-line* errors that might
    not be obvious initially. The more possible paths of a program the unit test covers,
    the better.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the PHPUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHPUnit can be installed as, provisionally named, a tool or a library. Both
    are the same things actually, just differing in a way we install and use them.
    The *tool* version is really just a PHP *phar* archive we can run via console,
    which then provides a set of console commands we can execute globally. The *library*
    version on the other hand is a set of PHPUnit libraries packed as a Composer package,
    as well as a binary that gets dumped into the project's `vendor/bin/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that we are using the Ubuntu 16.10 (Yakkety Yak) installation, installing
    the PHPUnit as a tool is easy via the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us the final output, much like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/04a8301f-9170-475d-9cf6-9f06da6b1be5.png)'
  prefs: []
  type: TYPE_IMG
- en: The PHPUnit becomes a system-wide accessible console tool, not related to any
    project specifically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing PHPUnit as a library is easy as running the following console command
    within the root of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us the final output, much like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c9cf5e36-7f37-4e8f-be79-813ff7590a43.png)'
  prefs: []
  type: TYPE_IMG
- en: This installs all the PHPUnit library files within our project's `vendor/phpunit/`
    directory, as well as the `phpunit` executable file under the `vendor/bin/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a sample application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start writing some PHPUnit test scripts, let's go ahead and create
    a very simple application consisting of merely a few files. This will allow us
    to focus on the essence of writing a test later on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test driven development** (**TDD**), such as the one done with PHPUnit, encourages
    writing tests before the implementations. This way, the tests set the expectations
    for the functionality and not the other way around. This approach requires a certain
    level of experience and discipline, which might not sit well with newcomers to
    PHPUnit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we are making a part of the web shopping functionality,
    thus dealing with product and category entities for a start. The first class we
    address is the `Product` model. We will do so by creating the `src\Foggyline\Catalog\Model\Product.php`
    file, with its content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Product` class relies on the constructor for setting up the product''s
    ID, title, price, and tax rate. Other than that, there is no actual logic to the
    class, aside from the simple getter methods. With the `Product` class in place,
    let''s go ahead and create a `Category` class. We will add it to the `src\Foggyline\Catalog\Model\Category.php`
    file, with its content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Category` class relies on the constructor for setting up the category title
    and its products. Other than that, there is no logic in it, aside from the two
    getter methods, which merely return the values set through the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To spice things up a bit, for testing purposes, let''s go ahead and create
    a dummy `Layer` class as a part of the `src\Foggyline\Catalog\Model\Layer.php`
    file, with its content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We will use this class merely as an example, with the code coverage analysis
    later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `Product` and `Category` models, let''s go ahead and create the `Block\Category\View`
    class as a part of the `src\Foggyline\Catalog\Block\Category\View.php` file, with
    its content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the `render()` method to render the entire category page. The
    page itself consists of a category title, and a container of all of its products
    with their individual titles and prices. Now that we have our truly basic application
    classes outlined, let''s add a simple PSR4 type loader to the `autoload.php` file,
    with its content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we set up the entry point to our application as a part of the `index.php`
    file, with its content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will be using this utterly simple application across other types of tests
    as well, so it's worth keeping its files and structure in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Writing test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Getting started with writing PHPUnit tests requires grasping a few basic concepts,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The setUp() method**: Analogous to the constructor, this is where we create
    the objects against which we will perform the test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The tearDown() method**: Analogous to the destructor, this is where we clean
    up objects against which we performed the test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The test*() methods**: Every public method whose name begins with test, for
    example, `testSomething()`, `testItAgain()`, and so on, is considered a single
    test. The same effect can be achieved by adding the `@test` annotation in a method''s
    docblock; although, this seems to be a less used case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The @depends annotation**: This allows expressing dependencies between the
    test methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assertions**: The heart of the PHPUnit, this set of methods allows us to reason
    about correctness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `vendor\phpunit\phpunit\src\Framework\Assert\Functions.php` file contains
    an extensive list of the `assert*` function declarations, such as `assertEquals()`,
    `assertContains()`, `assertLessThan()`, and others, totaling to over 90 different
    assert functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these in mind, let''s go ahead and write the `src\Foggyline\Catalog\Test\Unit\Model\ProductTest.php`
    file, with its content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Our `ProductTest` class is using a `setUp()` method to set up an instance of
    a `Product` class. The two `test*()` methods then use the PHPUnit's built-in `assertEquals()`
    method to test the value of the product title and price.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then add the `src\Foggyline\Catalog\Test\Unit\Model\CategoryTest.php` file,
    with its content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Our `CategoryTest` class is using a `setUp()` method to set up an instance of
    a `Category` class, along with the two products passed onto the `Category` class
    constructor. The two `test*()` methods then use the PHPUnit's built-in `assertCount()` and
    `assertEquals()` methods to test the instantiated values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then add the `src\Foggyline\Catalog\Test\Unit\Block\Category\ViewTest.php`
    file, with its content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Our `ViewTest` class is using a `setUp()` method to set up an instance of a
    `Category` class, alongside with the two products passed onto the `Category` class
    constructor. The two `test*()` methods then use the PHPUnit's built-in `assertContains()` method
    to test the presence of the value that should be returned through the category
    view `render()` method call.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then add the `phpunit.xml` file, with its content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `phpunit.xml` configuration file supports quite a robust list of options.
    Using the bootstrap attribute of a PHPUnit element, we are instructing the PHPUnit
    tool to load the `autoload.php` file prior to running the tests. This ensures
    that our PSR4 autoloader will kick in, and that our test classes will see our
    classes within the `src/Foggyline` directory. The `foggyline` test suite we defined
    within `testsuites` uses the directory option to specify, in regex form, the path
    to our unit tests. The path we used was such so that all of the files under both
    `src/Foggyline/Catalog/Test/Unit/` and possibly `src/Foggyline/Checkout/Test/Unit/`
    directories are picked up.
  prefs: []
  type: TYPE_NORMAL
- en: Check out [https://phpunit.de/manual/current/en/appendixes.configuration.html](https://phpunit.de/manual/current/en/appendixes.configuration.html)
    for more information on `phpunit.xml` configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: Executing tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running the test suite we have just written is as easy as executing the `phpunit` command
    within our project root directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon execution, `phpunit` will look for the `phpunit.xml` file and act accordingly.
    This means that `phpunit` will know where to look for the test files. Successfully
    executed tests show an output like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/371e6760-3391-4cf7-9c0d-91f1ba2ae855.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, the unsuccessfully executed tests show an output like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e1bdf825-0c30-4e10-bdc1-a40343b12fb6.png)'
  prefs: []
  type: TYPE_IMG
- en: We can easily modify one of the test classes, as we did with the preceding `ViewTest`,
    in order to trigger and observe the reactions of `phpunit` to failures.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The great thing about PHPUnit is its code coverage reporting functionality.
    We can easily add code coverage to our testing suite just by extending the `phpunit.xml`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we added the `filter` element, with an extra `whitelist` and `logging`
    element. We can now trigger the testing again, but, this time, with a slightly
    modified command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us the final output, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4d9fe7f1-a837-4d1c-b5c1-44817ffd4ced.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `log/report` directory should now be filled with HTML report files. If
    we expose it to the browser, we can see a nicely generated report with valuable
    pieces of information about our code base, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b05dae90-7045-4860-b173-4e4b77db6144.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding screenshot shows a code coverage percentage across the `src/Foggyline/Catalog/`
    directory structure. Drilling further down into a `Model` directory, we see our
    `Layer` class having 0% code coverage, which is expected, as we haven''t written
    any test for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/55600582-e0c2-488f-afd6-7a0f177a8f85.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Drilling further down into the actual `Product` class itself, we can see the
    PHPUnit code coverage outlining each and every line of code covered by our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/968f95fa-563d-412a-92c7-c1a14a8fe066.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Looking directly into the actual `Layer` class gives us a nice visual on the
    lack of any code coverage within this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bdf1bb00-292b-4d00-b8a7-fd7356d68d5b.png)'
  prefs: []
  type: TYPE_IMG
- en: Code coverage provides valuable visual and statistical information about the
    amount of code we have covered with tests. Although this information is easily
    misinterpreted, having 100% code coverage is by no means a measure of our individual
    test quality. Writing quality tests requires the writer, that is, the developer,
    to have a clear understanding of what exactly is the unit testing. It goes to
    say that we can easily have 100% code coverage, with 100% passing tests, and yet
    fail to address certain test cases or paths of logic.
  prefs: []
  type: TYPE_NORMAL
- en: Behat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Behat is an open source and free testing framework based on a notion of **behavior-driven
    developmen**t (**BDD**). The great benefit of the BDD frameworks, including Behat,
    is that a significant portion of the functional documentation gets poured into
    the actual user stories we end up testing. That is, to some extent, the documentation
    itself becomes a test.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Behat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much like PHPUnit, Behat can be installed as a tool and library. The tool version
    being the `.phar` archive, we can download it from the official GitHub repository,
    where the library version comes packed as a Composer package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that we are using the Ubuntu 16.10 (Yakkety Yak) installation, installing
    the Behat as a tool is easy through the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5f379429-0c4c-42f1-ac5b-7c579c618288.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Installing Behat as a library is as easy as running the following console command
    within the root of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us the final output, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/43752f4f-bd6e-462d-a7d7-15ffa43ff2dc.png)'
  prefs: []
  type: TYPE_IMG
- en: The Behat library now becomes available under the `vendor/behat` directory and
    its console tool executable under the `vendor/bin/behat` file.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a sample application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sample application for Behat testing is the same one we used for PHPUnit
    testing. We will merely extend it a bit by adding an extra class to it. Given
    the lack of any real "behavior" in our PHPUnit sample application, our extension
    here will include a dummy shopping cart functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we will add the `src\Foggyline\Checkout\Model\Cart.php` file, with
    its content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Leaving the original `index.php` file as it is, let''s go ahead and create
    the `index_2.php` file, with its content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We won't actually be needing this one for testing, but it goes to show how our
    dummy cart can be utilized.
  prefs: []
  type: TYPE_NORMAL
- en: Writing test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Getting started with writing the Behat tests requires grasping a few basic
    concepts, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gherkin language**: This is a whitespace, business-readable, domain-specific
    language created for behavior descriptions, with the ability to be used for a
    project’s documentation and automated test at once through its *Given-When-Then*
    concept.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Features**: This is a list of one or more scenarios saved under the `*.feature`
    file. By default, the Behat features are to be stored and found in the `features/`
    directory relative to our project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scenarios**: These are the core Gherkin structures, consisting of one or
    more steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Steps**: These are also known as *Givens*, *Whens*, and *Thens.* Indistinguishable
    to Behat, they should be distinguishable to developers as they are carefully selected
    for their purpose. The *Given* steps put the system in a known state, prior to any
    user interaction. The *When* steps describe the key action that the user performs.
    The *Then* step observes the outcomes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these in mind, let's go ahead and write and kick off our Behat tests.
  prefs: []
  type: TYPE_NORMAL
- en: The `vendor\phpunit\phpunit\src\Framework\Assert\Functions.php` file contains
    an extensive list of `asert*` function declarations, such as `assertEquals()`,
    `assertContains()`, `assertLessThan()`, and others, totaling to over 90 different
    assert functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the root of our project directory, if we run the `behat --init` console
    command, it will generate a `features/` directory, and, within it, a `features/bootstrap/FeatureContext.php`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The newly created `features/` directory is where we write our tests. Ignoring
    the newly generated `FeatureContext` for the moment, let''s go ahead and create
    our first `.feature`. As we mentioned earlier, Behat tests are written in a special
    format called **Gherkin**. Let''s go ahead and write down our `features/checkout-cart.feature`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can see the `Given`, `When`, and `Then` keywords being put to use. However, there are
    also several occurrences of `And`. When there are several `Given`, `When`, and
    `Then `steps, we are free to use additional keywords such as `And` or `But` to
    flag a step, thus allowing our Scenario to be read more fluently. Behat does not
    differentiate any of these keywords; they are only meant to be differentiated
    and experienced by the developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can update our `FeatureContext` class with the tests, that is, steps,
    from `checkout-cart.feature`. All it takes is to run the following command, and
    the Behat tool will do this for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2a34934f-93ba-4ab4-b84c-53f756ab8238.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After executing this command, Behat automatically appends all the missing step
    methods into our `FeatureContext` class, which now looks like the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to go in and edit these stub methods to reflect on the classes
    we are testing this behavior against. This means replacing all of the `throw new
    PendingException()` expressions with the proper logic and assertions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the use of the PHPUnit framework for asserting. Using Behat does not mean
    we have to stop using the PHPUnit library. It would be a shame not to reuse the
    wast number of the assert functions available in PHPUnit. Adding it to the project
    is easy, as shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Executing tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we sort out all of the stub methods within the `features\bootstrap\FeatureContext.php`
    file, we can simply run the `behat` command in our project root to execute tests.
    This should give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/44c110d7-c8bc-4560-9bbc-aec1b47d8a2f.png)'
  prefs: []
  type: TYPE_IMG
- en: The output indicates a total of 2 scenarios and 14 different steps, all of which
    are confirmed to be working.
  prefs: []
  type: TYPE_NORMAL
- en: phpspec
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like Behat, **phpspec** is an open source and free testing framework based on
    the notion of BDD. However, its approach to testing is quite different than that
    of Behat; we may even say it sits somewhere in the middle of PHPUnit and Behat.
    Unlike Behat, phpspec does not use the Gherkin format stories to describe its
    tests. Doing so, phpspec shifts its focus on internal, rather than external application
    behavior. Much like PHPUnit, phpspec allows us to instantiate objects, call its
    methods, and perform various assertions on the results. The part where it differs
    is in its "think of specification", and not of "think of test" approach.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up phpspec
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much like PHPUnit and Behat, phpspec can be installed as a tool and a library.
    The tool version being the `.phar` archive, we can download it from the official
    GitHub repository, whereas the library version comes packed as a Composer package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that we are using the Ubuntu 16.10 (Yakkety Yak) installation, installing
    phpspec as a tool is easy, as shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ef2066ec-088b-48de-b2a5-7206e8191db5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Installing phpspec as a library is as easy as running the following console
    command within the root of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us the final output, which looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/24ee6529-fe86-49f2-9f22-3870641305eb.png)'
  prefs: []
  type: TYPE_IMG
- en: The phpspec library now becomes available under the `vendor/phpspec` directory
    and its console tool is executable under the `vendor/bin/phpspec` file.
  prefs: []
  type: TYPE_NORMAL
- en: Writing test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Getting started with writing phpspec tests requires grasping a few basic concepts,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The it_*() and its_*() methods**: This object behavior is made up of individual
    examples, each one being flagged with the `it_*()` or `its_*()` methods. We can
    have one or more of these methods defined per single specification. Each defined
    method gets triggered when a test is run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Matchers methods**: These are analogous to assertions in PHPUnit. They describe
    how an object should behave.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object construction methods**: Every object we describe in phpspec is not
    a separate variable, but is `$this`. Sometimes, however, getting the proper `$this` variable
    requires managing constructor parameters. This is where the `beConstructedWith()`, `beConstructedThrough()`, `let()`,
    and `letGo()` methods come in handy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The let() method**: This runs before each example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The letGo() method**: This runs after each example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The matchers are likely something we will have most contact with, so it is
    worth knowing there are several different matchers in phpspec, all of which implement
    the `Matcher` interface declared in the `src\PhpSpec\Matcher\Matcher.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Using the `phpspec describe` command, we can create a specification for either
    one of the existing or new concrete classes we are yet to write. Since we already
    have our project set, let's go ahead and generate a specification for our `Cart`
    and `Product` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will do so by running the following two commands within the root directory
    of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The first command generates the `spec/Foggyline/Checkout/Model/CartSpec.php`
    file, with its initial content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The second command generates the `spec/Foggyline/Catalog/Model/ProductSpec.php`
    file, with its initial content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated `CartSpec` and `ProductSpec` classes are nearly identical. The difference
    lies in the concrete classes they reference through the `shouldHaveType()` method
    call. Moving forward, we will try to write a few simple tests only for the `Cart`
    and `Product` models. That being said, let''s go ahead and modify our `CartSpec`
    and `ProductSpec` classes to reflect upon the use of matchers: the `it_*()` and
    `its_*()` functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will modify the `spec\Foggyline\Checkout\Model\CartSpec.php` file with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We will modify the `spec\Foggyline\Catalog\Model\ProductSpec.php` file with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are making use of the `let()` method, as it triggers before any of
    the `it_*()` or `its_*()` methods are executed. Within the `let()` method, we
    are calling `beConstructedWith()` with arguments we would normally pass to a `new
    Product(...)` expression. This builds our product instance, and allows all of the
    `it_*()` or `its_*()` methods to execute successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Check out [http://www.phpspec.net/en/stable/manual/introduction.html](http://www.phpspec.net/en/stable/manual/introduction.html)
    for more information on the advanced phpspec concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Executing tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running only a `phpspec run` command at this point will likely fail with something
    like a class ... does not exist message, because phpspec assumes a PSR-0 mapping
    by default. To be able to work with the application we have done so far, we need
    to tell phpspec to include our `src/Foggyline/*` classes. We can do so either
    through a `phpspec.yml` configuration file, or using the `--bootstrap` option.
    Since we have already created the `autoload.php` file, let''s go ahead and run phpspec
    by bootstrapping this file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b59deaed-e5a6-4198-a326-81ec14e65c38.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have involved these two specs using `phpspec describe` on the existing class.
    We could easily pass on the non-existing class name to the same command, as per
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Guest\Cart` class does not really exist in our `src/` directory. phpspec
    has no trouble creating a `spec/Foggyline/Checkout/Model/Guest/CartSpec.php` specification
    file, just like it did for `Cart` and `Product`. However, running the phpspec
    describe now raises a class ... does not exist error message, along with the interactive
    generator, as per the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/eebb8e02-8603-49e6-83d0-34ea130bd066.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As a result, the `src\Foggyline\Checkout\Model\Guest\Cart.php` file is additionally
    generated with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'While all of these are simple examples, it goes to show that phpspec works
    both ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating specifications based on existing concrete classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating concrete classes based on a specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running our test now should give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/76813f42-6a63-4d83-8854-b19eb771672d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, lets''s deliberately fail a test by changing the `its_title_should_be_like()`
    method of `spec\Foggyline\Catalog\Model\ProductSpec.php` into the following line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the test now should give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1a5261f7-36c4-4c25-9872-1793b9ebed46.png)'
  prefs: []
  type: TYPE_IMG
- en: There is much more to be said about phpspec. Things such as Stubs, Mocks, Spies,
    templates, and extensions further enrich our phpspec testing experience. This
    section, however, focuses on the basics to get us started.
  prefs: []
  type: TYPE_NORMAL
- en: jMeter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Apache jMeter is a free and open source application designed for load and
    performance testing. The functionality of jMeter extends across many different
    applications, servers, and protocol types. In the context of web applications,
    we might be tempted to compare it to the browser. However, jMeter works with HTTP
    and https at a protocol level. It does not render HTML or execute JavaScript.
    Although jMeter is primarily a GUI application, it can easily be installed and
    have its tests run in console mode. This makes it a convenient tool of choice
    for quickly building our tests in GUI mode, and then running them on a server
    console later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that we are using the Ubuntu 16.10 (Yakkety Yak) installation, installing
    jMeter as a tool is easy, as shown in the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this might not give us the latest version of jMeter, in which case,
    we can get one from the official jMeter download page ([http://jmeter.apache.org/download_jmeter.cgi](http://jmeter.apache.org/download_jmeter.cgi)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Using this second method of installation, we will find the jMeter executable
    at `apache-jmeter-3.2/bin/jmeter`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we used a simple project with a few classes in the `src/Foggyline` directory
    to demonstrate the use of PHPUnit, Behat, and phpspec testing. Those, however,
    can't quite serve the purpose of this type of testing. Since we don't have any
    HTML pages to showcase in the browser, our focus with jMeter is on kicking off
    a simple built-in web test plan in order to understand its components and how
    we can run it later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing jMeter tests for web applications requires a basic understanding of
    several key concepts, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Thread Group**: This defines a pool of users who execute a specific test
    case against our web server. The GUI allows us to control the several Thread Group
    options, as shown in the following screenshot:![](assets/2eea3707-2530-4ab6-951a-343829a39dbb.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP Request Defaults**: This sets the default values that our HTTP Request
    controllers use. The GUI allows us to control the several HTTP Request Defaults
    options, as shown in the following screenshot:![](assets/74b84049-bc01-4933-b3cb-206566e9b0bd.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP Request**: This sends the HTTP/HTTPS request to a web server. The GUI
    allows us to control the several HTTP Request options, as shown in the following
    screenshot:![](assets/3bcaef6d-9709-4d6a-a590-e845d143232f.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP Cookie Manager**: This stores and sends cookies, just like a web browser
    does. The GUI allows us to control the several HTTP Cookie Manager options, as
    shown in the following screenshot:![](assets/7e73cd63-0927-4f0e-8d4d-6d52285cd564.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP Header Manager**: This adds or overrides HTTP request headers. The GUI
    allows us to control the several HTTP Header Manager options, as shown in the
    following screenshot:![](assets/4207e9af-8c39-469f-9d06-58d70086b159.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graph Results**: This generates a graph with all the sample times plotted
    out. The GUI allows us to control the several Graph Results options, as shown
    in the following screenshot:![](assets/6bb97a85-ff3e-46ab-ad0b-c237b2d243e8.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should never use the Graph Results listener component during production load
    tests as it consumes a lot of memory and CPU resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The great thing about jMeter is that it already provides several different
    test plan templates. We can easily generate a Web Test Plan simply by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the File | Templates... menu under the main application menu, as shown
    here:![](assets/5bd910de-fbc2-4d8b-80cc-b51bac504e64.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This in turn triggers the Templates selection screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a8bf6e16-7286-4ceb-b0ec-d89552aaf584.png)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on the Create button should kick off a new test plan, as shown in the
    following screenshot:![](assets/56d47f1a-24c4-4d61-8e5e-2b150e90c8ed.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While the test is just fine as it is, let''s go ahead and change a few things
    before we run it:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on View Results Tree and click on Remove.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on build-web-test-plan and Add | Listener | Graph Results, then set Filename
    to `jmeter-result-tests.csv`, as follows:![](assets/279110e8-eb42-481d-8e62-4de00d400eaf.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Scenario 1 and edit Loop Count to value `2`:![](assets/0cbe46a8-b7b1-4dbf-8509-52a74c08acfa.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With these modifications in place, let's click on File | Save under the main
    menu and name our test `web-test-plan.jmx`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Out test is now ready to be run. While the test itself won't be load testing
    our own server in this case, rather [example.org](http://example.org), the value
    of this exercise lies in understanding how to build the test via a GUI tool, run
    it via console, and generate the test results log for later inspection.
  prefs: []
  type: TYPE_NORMAL
- en: Executing tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running a jMeter test via a console is quite easy, as the following command
    shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `-n` parameter, also works with `--nongui`, stands for run JMeter in nongui
    mode. Whereas,, the `-t` parameter that also works with `--testfile`, stands for the
    jmeter test(.jmx) file to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting output should look the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6259fa47-a861-47f1-b4c5-bd77f2737c1f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A quick look into the `jmeter-result-tests.csv` file reveals the structure
    and data captured:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7e4cb059-f943-48c3-8350-2ce468321f3c.png)'
  prefs: []
  type: TYPE_IMG
- en: While the example demonstrated here relies on a default test plan with some
    minor modifications, the overall capabilities of Apache jMeter can enrich the
    whole testing experience by multiple factors.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we very briefly scratched the surface of some of the
    most popular types of PHP application testing. The test driven development (TDD)
    and behaviour driven development comprise of a very large and important chunk
    of it. Luckily, the PHP ecosystem provides two excellent frameworks, PHPUnit and
    Behat, which makes these types of testing easy to work with. Although fundamentally
    different, PHPUnit and Behat complete each other in a sense that they ensure our
    application is tested both from the smallest unit of functionality to a logical outcome
    of overall functionality point of view. phpspec on the other hand seems to sit
    in the middle of the two, trying to address these two challenges in its own uniform
    way. We further glossed over Apache jMeter, seeing how easy it is to kick off
    a performance test with a simple web test plan. This allows us to take an important
    step forward and confirms that our application not only works, but works fast
    enough to meet user expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we will take a closer look at the debugging, tracing, and profiling
    PHP applications.
  prefs: []
  type: TYPE_NORMAL
