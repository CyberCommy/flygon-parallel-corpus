- en: Chapter 3. Conditions Attached
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I suppose we can say that we are now into the fine print of the script. These
    are the details that are written into our scripts using conditions to test if
    a statement should run or not. We are now ready to add some intelligence in scripts
    so our scripts become more robust, easier to use, and more reliable. Conditional
    statements can be written with simple command-line lists of `AND` or `OR` commands
    together or, more often, within traditional `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple decision paths using command-line lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying user input with lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the test shell built-in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating conditional statements using `if`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending `if` with `else`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More conditions with `elif`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the `backup.sh` script using `elif`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using case statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Script – front-end with `grep`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple decision paths using command-line lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have used command-line lists both in [Chapter 1](part0014_split_000.html#DB7S1-747571d9b4814e1dbffcdef2eb0dec8d
    "Chapter 1. What and Why of Scripting with Bash"), *What and Why of Scripting
    with Bash* of this book and in some of the scripts found in [Chapter 2](part0020_split_000.html#J2B81-747571d9b4814e1dbffcdef2eb0dec8d
    "Chapter 2. Creating Interactive Scripts"), *Creating Interactive Scripts*. Lists
    are one of the simplest conditional statements that we can create and so we thought
    that it was appropriate to use them in the earlier examples before fully explaining
    them here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Command-line lists are two or more statements that are joined using either
    the `AND` or `OR` notations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`&&`: `AND`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`||`: `OR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where the two statements are joined using the `AND` notation, the second command
    only runs if the first command succeeds. Whereas, with the `OR` notation the second
    command will run only if the first command fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'The decision of the success or failure of a command is taken by reading the
    exit code from the application. A zero represents a successful application completion
    and anything other than a zero will represent a failure. We can test the success
    or failure of an application by reading the exit status by means of the system
    variables `$?`. This is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to ensure that a script is run from a user''s home directory, we
    can build this into the script''s logic. This can be tested from the command line
    and it does not have to be in a script. Consider the following command-line example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The double vertical bars denote an `OR` list. This ensures that the second statement
    is only executed when the first statement is not true. In simple terms, if we
    are not currently in the home directory we will be by the end of the command-line
    list. We will see more on the test command soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can build this into almost any command that we want and not just test. For
    example, we can query to see if a user is logged into the system, if they are
    then we can use the `write` command to directly message their console. Similar
    as before, we can test this in the command line prior to adding it to the script.
    This is shown in the following command-line example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If we use this in a script, it is almost certain that we will replace the username
    with a variable. In general, if we have to refer to the same value more than once
    then a variable is a good idea. In this case, we are searching for the `pi` user.
  prefs: []
  type: TYPE_NORMAL
- en: When we break the command-line list down, we first use the `who` command to
    list the users who are logged on. We pipe the list to `grep` to search for the
    desired username. We are not interested in the output from the search, just the
    success or failure. With this in mind, we redirect all our output to `/dev/null`.
    The double ampersand indicates that the second statement in the list runs only
    if the first returns true. If the `pi` user is logged on, we use `write` to message
    the user. The following screenshot illustrates this command and the output.
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple decision paths using command-line lists](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Verifying user input with lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this script, we will ensure that a value has been supplied to the first positional
    parameter. We can modify the `hello2.sh` script that we created in [Chapter 1](part0014_split_000.html#DB7S1-747571d9b4814e1dbffcdef2eb0dec8d
    "Chapter 1. What and Why of Scripting with Bash"), *What and Why of Scripting
    with Bash*, to check for user input before displaying the `hello` text.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can copy the `hello2.sh` script to `hello4.sh` or simply create a new script
    from scratch. There will not be a lot a typing and the script will be created
    as `$HOME/bin/hello4.sh`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Verifying user input with lists](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can ensure that the script is executable with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can then run the script with or without arguments. The `test` statement is
    looking for the `$1` variable to be zero bytes. If it is, then we will not see
    the `hello` statement; otherwise it will print the **Hello** message. In simple
    terms, we will see the `hello` message if we supply a name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output that you will see when you do not
    supply a parameter to the script, followed by the supplied parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Verifying user input with lists](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using the test shell builtin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is probably time for us to pull over to the side of the scripting highway
    and look a little more at this command `test`. This is both a shell builtin and
    a file executable in its own right. Of course, we will have to hit the built-in
    command first, unless we specify the full path to the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the test command is run without any expressions to evaluate, then the
    test will return false. So, if we run the test as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The exit status will be `1`, even though no error output is shown. The `test`
    command will always return either `True` or `False` or `0` or `1`, respectively.
    The basic syntax of `test` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can inverse the `test` command with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to include multiple expressions, these can be `AND` or `OR` together
    using the `-a` and `-o` options, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also write in a shorthand version replacing the test with square brackets
    to surround the expression as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Testing strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can test for the equality or inequality of two strings. For example, one
    of the ways to test the root user is using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also write this using the square bracket notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Equally, we could test for a non-root account with the following two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can also test for zero values and non-zero values of strings. We saw this
    in an earlier example in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test if a string has a value, we could use the `-n` option. We can check
    to see if the current connection is made via SSH by checking for the existence
    of a variable in the user''s environment. We show this using `test` and square
    brackets in the following two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If this is true, then the connection is made with SSH; if it is false, then
    the connection is not via SSH.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw earlier, testing for a zero string value is useful when deciding
    if a variable is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, more simply, we could use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: A true result for this query means that no input parameters have been supplied
    to the script.
  prefs: []
  type: TYPE_NORMAL
- en: Testing integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As well as, testing string values of bash scripts can test for integer values
    and whole numbers. Another way of testing input of a script is to count the numbers
    of positional parameters and also test that the number is above `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Or using the brackets, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When in relationship, top positional parameters the variable `$#` represents
    the number of parameters passed to the script. To test equality of integer values,
    the `-eq` option is used and not the `=` symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Testing file types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While testing for values we can test for the existence of a file or file type.
    For example, we may only want to delete a file if it is a symbolic link. I use
    this while compiling a kernel. The `/usr/src/linux` directory should be a symbolic
    link to the latest kernel source code. If I download a newer version before compiling
    the new kernel, I need to delete the existing link and create a new link. Just
    in case someone has created the `/usr/src/linux` directory, we can test it as
    a link before removing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-h` option tests that the file has a link. Other options include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-d`: This shows that it''s a directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-e`: This shows that the file exists in any form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-x`: This shows that the file is executable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f`: This shows that the file is a regular file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-r`: This shows that the file is readable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p`: This shows that the file is a named pipe'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-b`: This shows that the file is a block device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-c`: This shows that the file is a character device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More options do exist, so delve into the main pages as you need. We will use
    different options throughout the book; thus, giving you practical and useful examples.
  prefs: []
  type: TYPE_NORMAL
- en: Creating conditional statements using if
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen so far, it is possible to build simple conditions using command-line
    lists. These conditionals can be written both with and without a test. As the
    complexity of the tasks increases, it will be easier to create statements using
    `if`. This certainly will ease both the readability of the script and the logic
    layout. To a degree, it also matches the way in which we think and speak, `if`
    is a semantic in our spoken language as it is within the bash script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though it will take up more than a single line in the script, with an
    `if` statement we can achieve more and make the script more legible. With that
    said, let''s look at creating `if` conditions. The following is an example of
    a script using an `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The code within the `if` statement will run only when the condition evaluates
    to true and the end of the `if` block is denoted with `fi` - `if` backwards. The
    color coding in `vim` can be useful to aide readability, which you may see in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating conditional statements using if](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Within the script, we can easily add in multiple statements to run when the
    condition is true. In our case, this includes exiting the script with an error
    indicated, as well as, the `usage` statement to assist the user. This ensures
    that we only display the **Hello** message if we have supplied a name to be welcomed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can view the script execution both with and without the argument in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating conditional statements using if](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To help us understand the layout of the `if` conditional statement, the following
    illustration demonstrates the syntax using a pseudo-code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating conditional statements using if](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Indenting the code is not required but it helps readability and is highly recommended.
    Adding the `then` statement to the same line as the `if`, again, assists in the
    readability of the code and the semi-colon is required to separate the `if` from
    the `then`.
  prefs: []
  type: TYPE_NORMAL
- en: Extending if with else
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a script is required to continue regardless of the result of the `if`
    condition, it is often necessary to deal with both conditions of the evaluation.
    What to do when it is true, as well as, false. This is where we can make use of
    the `else` keyword. This allows the execution of one block of code when the condition
    is true and another when the condition is evaluated as false. The pseudo-code
    for this is shown in the next illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extending if with else](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we consider extending the `hello5.sh` script that we created earlier, it
    is easily possible to allow for correct execution regardless of the parameter
    being present or not. We can recreate this as `hello6.sh`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The script sets a named variable now, it helps readability and we can assign
    the correct value to `$name` from the input parameter or from the `read` prompt,
    either way the script is working well and starting to take shape.
  prefs: []
  type: TYPE_NORMAL
- en: More conditions with elif
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Moving onto where we require a greater degree of control, we can use the `elif`
    keyword. Unlike `else`, `elif` requires an additional condition to be tested for
    each `elif`. In this way, we can provide for different circumstances. We can add
    in as many `elif` conditions as required. The following shows a pseudo-code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: A script may make life easier for the operator by providing a simplified selection
    for a more complex code. Even though the script becomes gradually more complex
    to meet the requirements, to the operator the execution is greatly simplified.
    It is our job to enable users to run more complex operations easily from the command
    line when creating scripts. Often, this will necessitate the addition of more
    complexity to our scripts; however, we will be rewarded with the reliability of
    the scripted application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the backup2.sh using elif
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can revisit the script that we created to run the earlier backup. This script,
    `$HOME/bin/backup.sh`, prompts the user for the file type and the directory to
    store the backup. The tools used for the backup are `find` and `cp`.
  prefs: []
  type: TYPE_NORMAL
- en: With this new found knowledge, we can now allow the script to run the backup
    using the command `tar` and the level of compression selected by the operator.
    There is no requirement, to select the file type as the complete home directory
    will be backed up with the exclusion of the backup directory itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The operator can select the compression based on three letters `H`, `M`, and
    `L`. The selection will affect the options passed to the `tar` command and the
    backup file created. The selection of high will be using `bzip2` compression,
    medium using `gzip` compression and low creating an uncompressed `tar` archive.
    The logic exists in the extended `if` statement that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the user selection, we can configure the correct options for the `tar`
    command. As we have three conditions to evaluate the `if`, `elif`, and `else`
    statements are appropriate. To see how the variables are configured we can view
    the following extract from the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete script can be created as `$HOME/bin/backup2.sh` and should read
    as the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the script we need to select `H`, `M`, or `L` in upper-case
    as this is how the selection is made within the script. The following screenshot
    shows the initial script execution where the selection for `M` has been made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the backup2.sh using elif](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using case statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than using multiple `elif` statements, a `case` statement may provide
    a simpler mechanism when evaluations are made on a single expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic layout of a `case` statement is listed below using pseudo-code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The statement layout that we see is not dissimilar to `switch` statements that
    exist in other languages. In bash, we can use the `case` statement to test for
    simple values, such as strings or integers. Case statements can cater for a side
    range of letters, such as `[a-f]` or `a` through to `f`, but they cannot easily
    deal with integer ranges such as `[1-20]`.
  prefs: []
  type: TYPE_NORMAL
- en: The `case` statement will first expand the expression and then it will try to
    match it in turn with each item. When a match is found, all the statements are
    executed until the `;;`. This indicates the end of the code for that match. If
    there is no match, the case `else` statement indicated by the `*` will be matched.
    This needs to be the last item in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following script `grade.sh`, used to evaluate grades:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The script first uses an `if` statement to check that exactly two arguments
    have been supplied to the script. If they are not supplied, the script will exit
    with an error state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `case` statement then expands the expression, which is the value of the
    `$2` variable in this example. This represents the grade that we supply. We then
    try to match first against the letters `A` through to `C` in both upper-case and
    lower-case. `[A-C]` is used to match `A` or `B` or `C`. The vertical bar then
    adds an additional `OR` to compare with `a`, `b`, or `c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We make similar tests for other supplied grades `A` through to `F`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot show the script execution with different grades:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using case statements](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Script – building a front-end with grep
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a finale to this chapter, we can group a few features that we have learned
    together and build a script that prompts the operator for a filename, a search
    string, and an operation to carry out with the `grep` command. We can create the
    script as `$HOME/bin/search.sh` and don''t forget to make it executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by checking for exactly three input arguments using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The next check uses a command-line list to exit the script if the file argument
    is not a regular file using `test -f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `case` statement allows for three operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Counting the matching lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing the matching lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing all but the matching lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the search of `/etc/ntp.conf` file for lines
    beginning with the string server. We choose the count option in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Script – building a front-end with grep](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important and time consuming tasks in scripting is building
    all of the conditional statements that we need to make the script usable and robust.
    There is an 80-20 rule that is often spoken of. This is where 20 percent of your
    time is spent in writing the main script and 80 percent of the time is spent to
    ensure all of the possible eventualities that are correctly handled in the script.
    This is what I refer to as the procedural integrity of the script, where we try
    to cover each scenario carefully and accurately.
  prefs: []
  type: TYPE_NORMAL
- en: We started by looking at a simple test with command-line lists. If the actions
    needed are simple, then these provide great functionality and are easily added.
    Where more complexity is required, we will add `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `if` statements, we can extend them as required using the `else` and
    `elif` keywords. Don't forget that `elif` keywords need their own conditions to
    evaluate.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw how we can use `case` where a single expression needs to be
    evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will understand the importance of reading in from already
    prepared code snippets. We will create a sample `if` statement that can be saved
    as code snippets to be read into the script at the time of editing.
  prefs: []
  type: TYPE_NORMAL
