- en: Implementing RESTful Services with Node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing a server with Express
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting request parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving static files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing secure connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding security safeguards with Helmet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing CORS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding authentication with JWT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tying it all together – building a REST server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we looked at a set of important basic Node techniques.
    In this chapter, we will use them to set up a basic server with `Express` and
    build on that until we get to produce a RESTful server that's appropriate for
    a **Services Oriented Architecture** (**SOA**) setup.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a server with Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While you can work with plain vanilla `Node` and do everything, today `Express`
    is surely the most used `Node` framework, allowing you to easily develop servers
    by providing a whole bunch of basic functionality. First, let's install it and
    check it's working, and then move on to constructing services and more.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll start by doing the basic installation of `Express` so
    that we can use it in later sections for more advanced work.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about `Express` at [https://expressjs.com/](https://expressjs.com/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s install `Express` and make sure that it works. Installation is basically
    trivial because it''s just another `npm` package, so you just need a simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can add a `--verbose` optional parameter to the `npm` command to get a more
    verbose output and be able to see that things are happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s redo our basic test server from the previous chapter, but using
    `Express`. And, yes, this is way overkill for such a simple feature, but we just
    want to check that we set everything up in the right fashion! Refer to the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running this server is practically the same as with our very basic `Node` one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do the same tests as earlier, and note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the `/` address gets back a `Server alive` message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other paths produce a 404 (Not Found) error:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to access other paths (or `/`, but not with `GET`) will return a `404`
    error and a HTML error screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26f05363-d552-4848-9734-5c8e64c40ded.png)'
  prefs: []
  type: TYPE_IMG
- en: The basic Express configuration shows an error screen for 404 (Not Found) errors
  prefs: []
  type: TYPE_NORMAL
- en: The key line is the `app.get("/", (req, res) => ...)` call. Basically, after
    having created the application object (`app`) you can specify a route (in this
    case, `/`), a HTTP method (such as `.get()`, `.post()`, `.put()`, and `.delete()`),
    and a whole lot more.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://expressjs.com/en/4x/api.html#app.METHOD](https://expressjs.com/en/4x/api.html#app.METHOD)
    for more on the available methods.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use `.all()` as a catch-all for every possible method, and a function
    that will get called when the user hits that particular path. In our case, no
    matter what the request (`req`) is, the response (`res`) is constant, but obviously
    you'd want to do more for an actual service!
  prefs: []
  type: TYPE_NORMAL
- en: It goes without saying that you will surely have more than one route, and possibly
    process not only `GET` methods. You can certainly add many more routes and methods,
    and we'll get to more advanced routing in upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: The other interesting line is `app.listen()`, which specifies what port to listen
    to, and a function that will be executed when the server starts up; in our case,
    it's just a log message.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have managed to get our server running, let's implement some other
    usual server functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Adding middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Express` bases all of its functionality on a key concept: *middleware*. If
    you work with plain vanilla Node, you have to write a single large *request handler* that
    will have to take care of all of the requests your server may receive. By using
    middleware, `Express` lets you break down this process into smaller pieces, in
    a more functional, pipeline-ish sort of way. If you need to check security, log
    requests, handle routing, and so on, all will be done by appropriately placed
    middleware functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s understand how `Express` differs from `Node`, see how we can
    add some basic middleware of our own, and only then move on to apply the usual
    functions for common needs. Refer to the following diagram for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8a129e0-6943-46e0-a7e1-9bb702789148.png)'
  prefs: []
  type: TYPE_IMG
- en: Standard processing, in absence of the Express middleware handling – your code
    must do all of the processing
  prefs: []
  type: TYPE_NORMAL
- en: 'In standard processing (see the preceding diagram), `Node` gets requests from
    internet clients, passes them to your code for processing, gets the generated
    response, and passes it along to the original client. Your code must handle everything
    in what amounts, basically, to a very large function, dealing with security, encryption,
    routing, errors, and so on. If you add `Express` to the mix, the process changes
    a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62196a34-5120-48f6-8a5e-5d17adbcfbdb.png)'
  prefs: []
  type: TYPE_IMG
- en: When Express is added, it handles requests by passing them to a middleware stack
    to produce the response
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you set up a series of functions that will be called in order
    by `Express`, and each function will deal with a specific aspect of the overall
    process, simplifying the overall logic. Moreover, you won't have to directly deal
    with common problems (say, CORS or zipping, to mention just a few) because there
    are plenty of `Express` packages that already provide such functions; all you
    have to do is add them to the stack, at the appropriate place.
  prefs: []
  type: TYPE_NORMAL
- en: To get a better idea of how this works, in this recipe let's develop a very
    basic request logger (we'll learn about it in depth in the *Adding HTTP logging
    with Morgan* section of [Chapter 5](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml),
    *Testing and Debugging Your Server*) and an error reporter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to add some middleware, you have to place it in the correct order
    among all of the functions that you define. For example, if you want to log something,
    you'd probably want to do it before any processing is done, so you'd add that
    definition at the top of your stack, or very near to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Middleware functions receive three parameters: the incoming HTTP request (let''s
    call it `req`, as we''ve been doing so far), the outgoing HTTP response (`res`),
    and a function that you must call when you want processing to continue with the
    next piece of middleware in the stack (`next()`). When your middleware gets called,
    it must either send a response (by using `res.send()`, `res.sendFile()`, or `res.end()`)
    or call `next()` so that the following functions in the stack will get the chance
    to produce the answer.'
  prefs: []
  type: TYPE_NORMAL
- en: Error functions are a bit different, and they add an error (`err`) parameter
    to the three we just listed; having four parameters is what marks the function
    as an error processor in the eyes of `Express`. If everything works fine, `Express`
    skips the error middleware, but if an error occurs, `Express` will skip every
    function until it gets to the first available error function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s jump to the end and view our complete middleware example, which will
    be as follows; we''ll explain how it works in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with our logger. We want it to apply to every path so that we
    can just omit the path. An alternative would be writing `app.use("*", ...)`, which
    means exactly the same; we''ll also use it as an example. Your logic could do
    anything, and since we want to log requests, we can just list the current timestamp,
    the `request` method, and the requested path. Afterwards—and this is the most
    important thing—since we haven''t finished dealing with the request, calling `next()`
    is mandatory, or the request will end up in a processing limbo, never sending
    anything to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we want to have some errors, let''s define that the `DELETE` methods
    aren''t to be accepted, so `next()` will be called, but passing an error object;
    other requests will just get a simple text answer. Our main request processing
    code could then be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, our error processing code will log the error, and send back a `500`
    status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You'll note the need for disabling the `no-unused-vars` ESLint rule. Recognizing
    errors just by the function signature is not a very good practice, and if you
    are setting your error handler at the end of the stack so that there's no other
    function to call, the next parameter will be unused and cause an error. There
    is some talk of solving this situation in upcoming versions of `Express`, but
    for now the point is moot.
  prefs: []
  type: TYPE_NORMAL
- en: The error code we just showed, basic as it is, could be used in practically
    every Node server you write. We will be using it as is in our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve set everything up; now, let''s see our code working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use some curl requests to test this; let''s use `GET`, `POST`, and `DELETE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The logged output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, we now know how to write our own middleware, but it so happens that `Express`
    provides lots of ready-made functions. Let's give them a whirl and look at how
    we can use them for several common needs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting request parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get to a basic problem: how do you get the request parameters? In our
    earlier example, in the *Working with streams to process requests* section of
    the previous chapter, we did it by hand, working with the request stream to get
    the body, and using parsing functions to extract the parameters. However, `Express`
    already provides some middleware you can use before any other function in your
    stack that needs parameters, either from the body or the URL itself. So in this
    recipe, let''s see how we can access the request parameters, which is a very basic
    need.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see what it takes to access the parameters. First, you have to require
    the `body-parser` module and ask for the options you want; we''ll get into that
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Since you want the parameters to be parsed before any processing, the `app.use()`
    line will be at the top of your stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, getting into more detail, the `body-parser` module provides four parsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A URL-encoded body parser*, just like we''re using here, to read about the
    differences in using `extended` true or false. Checkout [https://github.com/expressjs/body-parser](https://github.com/expressjs/body-parser) for
    more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A JSON body parser*, as in `bodyParser.json()`, to process requests with `Content-Type` is
    done through `application/json`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A raw body parser*, as with `bodyParser.raw()`, to process `application/octet-stream`
    contents by default, though this can be changed by providing a `type` option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A text body parser*, like `bodyParser.text()`, to process `text/plain` content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The three latter parsers may provide extra options; check the documentation
    for more on that. Note, however, that if you have to deal with multipart bodies,
    then you cannot rely on a body-parser; see [https://github.com/expressjs/body-parser](https://github.com/expressjs/body-parser) for
    some alternatives, and see what suits you.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We only had to add a couple of lines, and everything was set up. We can see
    our code working by either changing our logger from the previous section, or by
    writing code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'URL parameters are automatically separated by `Express` into `req.query`, and
    `req.body` will be parsed by `bodyParser`. We can try a couple of service calls,
    a `GET` and a `POST`, to cover all cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the first case (`GET`), we can see that `req.query` is an object with the
    three query parameters, while in the second case (`POST`) there are no query parameters,
    but the `req.body` provides the single parameter (`name`) we provided.
  prefs: []
  type: TYPE_NORMAL
- en: This should convince you of the merits of Express' design, based on a middleware
    stack, but let's go through some more examples, such as working with static files,
    routing, security, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Serving static files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are planning to create a set of REST services, but it's very possible that
    your server will also have to serve some static files, such as images, PDFs, and
    so on. On principle, you could do this by hand by setting specific routes for
    each static asset, and then writing a function that would read the required file
    and stream its contents to the client; we did something like that in the *Working
    with streams to process requests* section in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is such a common and reiterative task that `Express` provides
    a simpler solution; let's look at how we can simply serve static files.
  prefs: []
  type: TYPE_NORMAL
- en: An even better solution would be to have another server, such as nginx, in your
    stack and have it handle static files. Standard servers are much better at handling
    this type of simple request, and will leave your Node code free to handle more
    complex, demanding tasks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s suppose we want to have some flag icons served for an application. I
    did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: I created, at the same level as the `/out` directory into which the output files
    go, a `/flags` directory with some subdirectories: `/flags/america/north`, `/flags/america/south`,
    and `/flags/europe`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I placed some free flag icons by *GoSquared*, taken from [https://www.gosquared.com/resources/flag-icons/](https://www.gosquared.com/resources/flag-icons/) in
    those directories. For variety, the flags are accessible at the `/static` path,
    which doesn't actually exist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I wrote the following code; this is the basic server from earlier, with just
    some added code (in bold font) to deal with static files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you want to read more about serving static files, check out Node's documentation
    at [https://expressjs.com/en/starter/static-files.html](https://expressjs.com/en/starter/static-files.html).
  prefs: []
  type: TYPE_NORMAL
- en: '`app.use()`, in this case, gets a special function, `express.static()`, which
    takes care of sending files in the given path, with some headers for caching;
    let''s get into the details:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter to `app.use()` is the base of the path that the user will
    select; note that it doesn't need to exist in the actual directory, as in other
    examples we have seen. We could write `app.use()` if we want to accept all HTTP
    methods, by the way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first parameter to `express.static()` specifies the path where the files
    are found. I''m using the `path.join()` function to find out the actual path:
    `/flags` at the same level as `/out`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter to `express.static()` lets you add options; in our case,
    I'm sending some caching headers so that browsers will know that the file can
    be safely cached for 30 days.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The format for the `maxAge` parameter can be in a format understood by the `ms`
    package ([https://github.com/zeit/ms](https://github.com/zeit/ms)), which is able
    to convert date and time strings into the equivalent milliseconds, which is standard
    for JS.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever the user specifies a path starting with `/static`, it is converted
    into the equivalent starting from `/flags`, and if the file is found, it will
    be sent back, with the caching headers included. Check out the following screenshot
    for an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4a1be1a-646c-43ea-9144-6db7632119b0.png)'
  prefs: []
  type: TYPE_IMG
- en: A static flag icon, served from a non-existing path, /static, mapped to an actual
    path
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to send static files for some specific reason, without using the
    method shown in the preceding section, you can use routing and the `res.sendFile()`
    method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you access [http://127.0.0.1:8080/uruguay](http://127.0.0.1:8080/uruguay/),
    you''ll get my home country''s flag, and [http://127.0.0.1:8080/license](http://127.0.0.1:8080/license)
    will retrieve the MIT license for the icon set I chose; see the latter in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e7eb6ab-c3f6-4e04-98ad-790ad85067fc.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing a different route that sends back a text file
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you wouldn't use this method if you had lots of static files to provide,
    but if you have only a few, then this alternative solution works very well.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that I didn't add headers for caching, but it can certainly
    be done. Read more on `res.sendFile()` at [https://expressjs.com/en/api.html#res.sendFile](https://expressjs.com/en/api.html#res.sendFile),
    in particular the `immutable` and `headers` options.
  prefs: []
  type: TYPE_NORMAL
- en: Adding routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No matter what kind of server you are building (a RESTful one, as we plan to
    do, or any other kind), you'll have to deal with routing, and `Node` and `Express`
    together provide easy ways of doing this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our database from the *Working with a database* section in the
    previous chapter, in a RESTful fashion, we should provide the following routes,
    allowing for the given methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/countries` (`GET` to obtain the list of all countries, and `POST` to create
    a new country)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/countries/someCountryId` (`GET` to access a country, `PUT` to update one,
    and `DELETE` to delete one)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/regions` (`GET` to get all regions of all countries, `POST` to create a new
    region)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/regions/someCountryId` (`GET` to get all regions of a given country)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/regions/someCountryId/someRegionId` (`GET` to access a region, `PUT` to update
    one, `DELETE` to delete one)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/cities` (`GET` to get all cities – but we won''t really want to allow this
    because of the resulting set size!—plus `POST` to create a new one)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/cities/someCityId` (`GET` to access a city, `PUT` to update one, and `DELETE`
    to delete a city)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could also allow for extra parameters, for example, to allow paging a result
    set, or to enable some filtering, but what we care about now is setting up the
    routes. You could set up all of the necessary routes in the main file, as we have
    been doing in our short examples so far, but as you start adding more and more
    routes, some organization is needed to avoid ending up with a thousands-of-lines-long
    main file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Thanks to `Express`, we won''t need too much code, with only two new lines
    to enable our routing; check out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `router_home.js` module could have the first level of route branching,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: And, going down one more level, we'd have three more files specifying the next
    levels. For example, routing for countries would be as follows. You'll note a
    weird extra route, `/URUGUAY`, which I added just to show you that we can have
    more routes than a RESTful server would require!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The regions routing file will be as shown in the following code, and we''ll
    skip the cities routing since it''s quite similar to countries routing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can read more about `Express` routing at [https://expressjs.com/en/starter/basic-routing.html](https://expressjs.com/en/starter/basic-routing.html)
    and [https://expressjs.com/en/guide/routing.html](https://expressjs.com/en/guide/routing.html).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, our so-called *RESTful server* is, at least for now, a total joke,
    since it just returns constant answers, doing nothing at all, but the key parts
    are practically all here. First, let's analyze its structure. When you write `app.use(somePath,
    aRouter)`, it means that all of the routes starting with the given path will be
    taken up by the provided router, which will take care of the routes from the given
    path onward. First, we write a basic router starting at `/`, and then break down
    the routes by path (`/countries`, `/regions`, and `/cities`), writing a router
    for each one. These latter routers will go deeper in the paths, until all of your
    routes are mapped out.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it clear: when the server receives a request for, say, `/regions/uy`,
    the request is first handled by our main router (at `routing.js`), which passes
    it to the home router (`router_home.js`), which passes it to the final router
    (`router_regions.js`), where the request is eventually handled.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s move on to the routes by themselves. There are two kind of routes
    here: *constant* routes such as `/countries` and *variable* routes such as `/regions/uy/4`,
    which include some varying items, such as `uy` and `4`, in this case. When you
    write a route such as `/regions/:country/:id`, Express will pick out the varying
    parts (here, `:country` and `:id`) and make them available as properties of the
    `req.params` object (`req.params.country` and `req.params.id`) so that you can
    use them in your logic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use regular expressions to define a path, but remember the joke:
    a programmer has a problem; a programmer decides to solve it using regular expressions;
    a programmer now has *two* problems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we implement some requests on the preceding path, we''ll see the functioning
    router; all we will be lacking is the actual RESTful code to produce some useful
    results, but we''ll get to that later in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Of course, trying some methods that aren't allowed will produce an error; try
    doing a `DELETE` request for `/regions` and you'll see what I mean. We now know
    how to do any kind of routing, but we still must be able to receive JSON objects,
    allow for CORS if needed, and some other considerations, so let's keep working
    and start by enabling secure connections with HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing secure connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sending data over HTTPS instead of HTTP is a good security practice, and actually
    mandatory if your server ever has to send sensitive, secure data over the web.
    There are many kinds of attacks that are avoided by setting up an encrypted connection
    with the client browser, so let's see how we can implement secure connections
    with `Node` and `Express`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will cover how to enable HTTPS so that our server becomes
    more secure.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to enable HTTPS connections, so we'll have to do a bit of work to install
    everything we need.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in this installation will be getting yourself a certificate that
    properly validates the site that you own. Buying it goes beyond this book, so
    let's do a workaround by generating our own self-signed certificates—which, of
    course, aren't really secure, but will let us do all of the required configuration!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we want to set up our `www.modernjsbook.com` site. Working
    in Linux, you can create the necessary certificate files by executing the following
    commands and answering some questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After doing this, you will end up with three files: a **Certificate Signing
    Request** (**CSR**), a KEY (Private Key), and a self-signed certificate (CRT)
    file, as follows; in real life, a **Certificate Authority** (**CA**) would be
    the actual signer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you set up your server, you must read in those files (which should
    reside in a safe, read-only directory for added security) and pass their contents
    as options. We will use the `fs` module to do this, as in previous examples, and
    since reading the files is done only when the server is loaded, `fs.readFileSync()`
    can be used. Take look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Why port `8443`? The reason has to do with security, and we saw why in the *Checking
    Node's setup* section of the previous chapter; it's the same motive that we had
    behind using port `8080` instead of port `80`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running the preceding code is enough to get encrypted connections to your server.
    (Of course, if you use self-signed certificates, the end user will get warnings
    about the lack of actual security, but you would get valid certificates, wouldn't
    you?) We can see the result of this in the following screenshot—and keep in mind
    that with real certificates, the user would get no alerts about your unsafe site!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fea9c51-8b9a-48c8-932e-25aba90d2bb0.png)'
  prefs: []
  type: TYPE_IMG
- en: Installing certificates and using HTTPS instead of HTTP generates a secure server.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, since we made up the certificate by ourselves, Google Chrome doesn't
    really like the site!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also force HTTP users to work with HTTPS by running a *second* server,
    this time with HTTP, and redirecting all traffic to our first server, which is
    secure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: A `Node` server can only listen to a single port, so you'd run this server as
    a separate instance. Now, if you try to use HTTP to access your server, you'll
    be redirected automatically, a good practice!
  prefs: []
  type: TYPE_NORMAL
- en: Adding secure connections is simple; let's keep on working on more security
    aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Adding security safeguards with Helmet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Out of the box, `Express` is a very good tool for building your RESTful server,
    or to provide any other kind of service. However, unless you take some extra precautions,
    Express doesn't apply all security best practices, which may doom your server.
    Not everything is lost, in any case, because there are some packages that can
    help you with those practices, and `Helmet` (at [https://helmetjs.github.io/](https://helmetjs.github.io/))
    is one of the best for this.
  prefs: []
  type: TYPE_NORMAL
- en: Don't think of `Helmet`—or any other similar package, by the way—as a magic
    silver bullet that will somehow solve all of your possible present and future
    security headaches! Use it as a step in the right direction, but you must keep
    on top of possible menaces and security holes, and not trust any single package
    to manage everything.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given that it works with `Express`, `Helmet` is also a piece of middleware.
    Its installation and setup are rather easy, fortunately. Using `npm` takes care
    of the first part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting `Helmet` to work is just a matter of adding it at the top of the middleware
    stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You''re all set! By default, `Helmet` enables the following list of security
    measures, all of which imply adding, changing, or removing specific headers from
    your response to a request. For more documentation on specific headers or options,
    check out [https://helmetjs.github.io/docs/](https://helmetjs.github.io/docs/):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Module** | **Effect** |'
  prefs: []
  type: TYPE_TB
- en: '| `dnsPrefetchControl`  | Sets the `X-DNS-Prefetch-Control` header to the disable
    browsers prefetching (requests done before the user has even clicked on a link)
    to prevent privacy implications for users, who may seem to be visiting pages they
    actually aren''t visiting ([https://helmetjs.github.io/docs/dns-prefetch-control](https://helmetjs.github.io/docs/dns-prefetch-control)).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `frameguard ` | Sets the `X-Frame-Options` header to prevent your page from
    being shown in an iframe, and thus avoids some *clickjacking* attacks that may
    cause you to unwittingly click on hidden links ([https://helmetjs.github.io/docs/frameguard/](https://helmetjs.github.io/docs/frameguard/)).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `hidePoweredBy ` | Removes the `X-Powered-By` header, if present, so that
    would-be attackers won''t know what technology powers the server, making targeting
    and taking advantage of vulnerabilities a bit harder ([https://helmetjs.github.io/docs/hide-powered-by](https://helmetjs.github.io/docs/hide-powered-by))
    |'
  prefs: []
  type: TYPE_TB
- en: '| `hsts ` | Sets the `Strict-Transport-Security` header so that browsers will
    keep using HTTPS instead of switching to the insecure HTTP. ([https://helmetjs.github.io/docs/hsts/](https://helmetjs.github.io/docs/hsts/))
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ieNoOpen ` | Sets the `X-Download-Options` header to prevent old versions
    of Internet Explorer from downloading untrusted HTML in your pages ([https://helmetjs.github.io/docs/ienoopen](https://helmetjs.github.io/docs/ienoopen)).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `noSniff` | Sets the `X-Content-Type-Options` header to prevent browsers
    from trying to *sniff* (guess) the MIME type of a downloaded file, to disable
    some attacks ([https://helmetjs.github.io/docs/dont-sniff-mimetype](https://helmetjs.github.io/docs/dont-sniff-mimetype)).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `xssFilter` | Sets the `X-XSS-Protection` header to disable some forms of
    **Cross-side scripting** (**XSS**) attacks, in which you could unwittingly run
    JS code on your page by clicking a link ([https://helmetjs.github.io/docs/xss-filter](https://helmetjs.github.io/docs/xss-filter)).
    |'
  prefs: []
  type: TYPE_TB
- en: 'You can also opt to enable some extra options, if they apply to your requirements.
    For notes on how to do this, check out Helmet''s documentation at [https://helmetjs.github.io/docs/](https://helmetjs.github.io/docs/):
    the package, now at version 3.12.0, is often updated, and a plain `npm install`
    may not be enough to enable the newer features. Take a look at the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Module** | **Effect** |'
  prefs: []
  type: TYPE_TB
- en: '| `contentSecurityPolicy`  | Lets you configure the `Content-Security-Policy`
    header to specify what things are allowed to be on your page, and where they may
    be downloaded from ([https://helmetjs.github.io/docs/xss-filter](https://helmetjs.github.io/docs/xss-filter)).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `expectCt` | Allows you to set the `Expect-CT` header to require **Certificate
    Transparency** (**CT**), to detect possibly invalid certificates or authorities
    ([https://helmetjs.github.io/docs/expect-ct/](https://helmetjs.github.io/docs/expect-ct/)).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `hpkp` | Lets you configure the `Public-Key-Pins` header to prevent some
    possible *person-in-the-middle attacks*, by detecting possibly compromised certificates
    ([https://helmetjs.github.io/docs/hpkp/](https://helmetjs.github.io/docs/hpkp/)).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `noCache`  | Sets several headers to prevent users from using old cached
    versions of files, which might have vulnerabilities or errors, despite newer versions
    being available ([https://helmetjs.github.io/docs/nocache/](https://helmetjs.github.io/docs/nocache/)).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `referrerPolicy`  | Lets you set the `Referrer-Policy` header to make browsers
    hide information as to the origin of a request, avoiding some possible privacy
    problems ([https://helmetjs.github.io/docs/referrer-policy](https://helmetjs.github.io/docs/referrer-policy)).
    |'
  prefs: []
  type: TYPE_TB
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is not much more to be said about using `Helmet`. After you add it to
    the middleware stack, and configure what to enable or disable, possibly giving
    some options as detailed in the documentation, `Helmet` will simply verify that
    the headers included in any response follow the security considerations that we
    listed in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do a quick check. If you run our `hello_world.js` server, the response
    for [http://localhost:8080/](http://127.0.0.1:8080) will include these headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The same results, but running `helmet_world.js`, which is essentially the same
    code but adding `Helmet`, shows more headers, as shown in the following code snippet
    in bold text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You would get even more headers if you were to individually enable some of
    the optional features, but the difference is clear: we managed to add some security
    controls with essentially almost zero coding!'
  prefs: []
  type: TYPE_NORMAL
- en: As with all security measures, it's necessary to follow Helmet's functionality
    so that you can possibly add or remove some new middleware options, and protect
    your server against new menaces.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing CORS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever the browser requests some resource from a server, there are some validation
    rules that apply. For many of these interactions, which only ask for information
    and do not attempt to produce any kind of change in the server, there is no limitation,
    and the requests are always allowed, as in the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '*CSS styles* are required via a `<link rel="stylesheet">` tag'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Images* are required via an `<img>` tag'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JS code* is required via a `<script>` tag'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Media* requests via the `<audio>` or `<media>` tags'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For other types of requests, the **Same Origin Policy** or **Single Origin Policy** (**SOP**)
    limits requests to those that are sent to the same origin (meaning the protocol,
    as in `http://`, host name, as in `modernjsbook.com`, and port, as in `:8080`),
    refusing any other request that doesn't match one or more of the origin URL elements.
    This impacts, for example, all Ajax requests, which will be duly rejected.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you are willing to accept requests from some or all servers, you
    can apply **Cross Origin Resource Sharing** (**CORS**) to enable such requests.
    Basically, CORS defines an interaction style that lets the server decide whether
    to allow a cross origin request; instead of blocking every request (as SOP would
    imply) or allowing all of them (a huge security breach!), rules can be applied
    to decide one way or the other.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to read the current specification for CORS, see the Fetch Living
    Standard document at [https://fetch.spec.whatwg.org/](https://fetch.spec.whatwg.org/),
    specifically Section 3.2\. A good article about CORS can be found at [https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start enabling CORS. Basically, it is just a matter of dealing with
    some requests by examining some data in their headers and sending back some other
    headers to the browser so that it will know what to expect. This type of process
    is very easily solved by applying middleware, and a package for this already exists
    (`cors`), which can be installed easily with the help of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can enable CORS for all routes or only a few. The first way only requires
    two lines of code (in bold, in the following code), telling `Express` to apply
    the middleware right at the top, for all requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also enable it specifically for any given route. Picking one example
    from earlier in this chapter, you could have specified CORS for attempts to get
    a city; the change would have been minimal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, some requests require a *pre-flight* check, which means that the browser,
    before sending the actual request, will send an `OPTIONS` request to verify whether
    the original request can be accepted. To enable this, you should enable CORS for
    whatever route, as in the following example, or generically, with a single `app.options(''*'',
    cors())` line at the beginning of your middleware stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest way to verify that CORS is enabled is by simulating calls from
    different sources using `curl` or a similar tool. (We'll be seeing more of this
    in the following chapter, when we get to do some testing.) We can make it even
    simpler by writing up a small web page that will do a cross-domain `GET`, adding
    a dummy header to force CORS, and checking the network traffic. Our page is simplicity
    itself—totally *no frills*!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be running our CORS server at `www.corsserver.com:8080` (I''m actually
    hacking the `/etc/hosts` file on my own machine so that the server is actually
    in my machine itself), and we''ll use the Web Server for Chrome to load and run
    our page. Check out the following screenshot for the results of doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d38f9da2-1c3f-4e63-8beb-bc4706daf2ce.png)'
  prefs: []
  type: TYPE_IMG
- en: Performing a simple cross domain GET shows that our server got an OPTIONS request,
    followed by the GET request afterwards
  prefs: []
  type: TYPE_NORMAL
- en: Using CORS is safer than other alternatives, including the old stalwart JSONP
    (*JSON with Padding*, a way to enable getting information across domains), so
    adding it to your server should be mandatory. However, as we've seen, it's simplicity
    itself with just a tad of Express middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Adding authentication with JWT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For any server-based application, one challenge that must be solved is authentication,
    and our RESTful server therefore will need a solution for that. In traditional
    web pages, sessions and cookies may be used, but if you are using an API, there's
    no guarantee that requests will come from a browser; in fact, they may very well
    come from another server. Adding this to the fact that HTTP is stateless, and
    that RESTful services are also supposed to be so, we need another mechanism, and
    **JSON Web Tokens** (**JWT**) is an often used solution.
  prefs: []
  type: TYPE_NORMAL
- en: JWT is sometimes read aloud as *JOT*; see Section 1 of the RFC at [https://www.rfc-editor.org/info/rfc7519](https://www.rfc-editor.org/info/rfc7519).
  prefs: []
  type: TYPE_NORMAL
- en: The idea with JWT is that the client will first exchange valid credentials (such
    as username and password) with a server and get back a token, which will afterwards
    give them access to the server's resources. Tokens are created using cryptological
    methods, and are far longer and more obscure than usual passwords. However, tokens
    are small enough to be sent as body parameters or a HTTP header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sending the token in the URL as a query parameter is a bad security practice!
    And, given that the token isn''t actually a part of a request, putting it in the
    body also doesn''t fit very well, so opt for a header; the recommended one is
    `Authorization: Bearer`.'
  prefs: []
  type: TYPE_NORMAL
- en: After getting the token, it must be supplied with every API call, and the server
    will check it before proceeding. The token may include all information about the
    user so that the server won't have to query a database again to re-validate the
    request. In that sense, a token works like the security passes you are given at
    the front desk of a restricted building; you have to prove your identity once
    to the security officer, but afterwards you can move through the building by only
    showing the pass (which will be recognized and accepted) instead of having to
    go through the whole identification procedure again and again.
  prefs: []
  type: TYPE_NORMAL
- en: Check out [https://jwt.io/](https://jwt.io/) for online tools that allow you
    to work with JWT, and also lots of information about tokens.
  prefs: []
  type: TYPE_NORMAL
- en: We won't be getting into the details of a JWT's creation, format, and so on;
    read the documentation if you are interested, because we will be working with
    libraries that will handle all such details for us. (We may just keep in mind
    that the token includes a *payload* with some *claims* related to the client or
    the token itself, like an expiration or issue date, and may include more information
    if we need to—but don't include secret data, because the token can be read.)
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, let's create a basic server that will be able to first issue
    a JWT to a valid user, and second check the presence of the JWT for specific routes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at how we can add authentication. To work with JWT, we''ll be using
    `jsonwebtoken` from [https://github.com/auth0/node-jsonwebtoken](https://github.com/auth0/node-jsonwebtoken).
    Install it with the help of the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Our code example for JWT will be larger than in previous examples, and it should
    be separated into many files. However, I avoided doing this in order to make it
    clearer. First, we''ll need to make some declarations, and the key lines are in
    bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Almost everything is standard, except for the `validateUser()` function and
    the `SECRET_JWT_KEY` string. The latter will be used to sign the tokens, and most
    definitely shouldn't be in the code itself! (If somebody could hack their way
    into the source code, your secret would be out; rather, set the key in an environment
    variable, and get the value from there.)
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the function, checking if a user exists and if their password is correct
    is simple to do, and can be achieved in many ways, such as by accessing a database,
    active directory, service, and so on. Here, we''ll just make do with a hardcoded
    version, which accepts only a single user. The `validate_user.js` source code
    is, then, quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get back to our server. After the initial definitions, we can place
    the routes that need no tokens. Let''s have a `/public` route, and also a `/gettoken` route
    to get a JWT for later. In the latter, we''ll see whether the `POST` included
    `user` and `password` values in its body, and if they are a valid user by means
    of the `validateUser()` function we showed in the preceding code. Any problems
    will mean a `401` status will be sent, while if the user is correct, a token will
    be created, expiring in one hour''s time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the unprotected routes are out of the way, let''s add some middleware
    to verify that a token is present. We expect, according to the JWT RFC, to have
    an `Authorization: Bearer somejwttoken` header included, and it must be accepted.
    If no such header is present, or if it''s not in the right format, a 401 status
    will be sent. If the token is present, but it''s expired or has any other problem,
    a 403 status will be sent. Finally, if there''s nothing wrong, the `userid` field
    will be extracted from the payload, and attached to the request object so that
    future code will be able to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s have some protected routes (in fact, a single one, `/private`,
    just for this example), followed by error checking and setting up the whole server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We're done! Let's see how this all comes together.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can start by testing the `/public` and `/private` routes, without any token.
    The former won''t cause any problems, but the latter will be caught by our token
    testing code and rejected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try to get a token. Check out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Another way of testing this would be going to [https://jwt.io/](https://jwt.io/)
    and creating a JWT, including `userid:"fkereki"` in the payload, and using `modernJSbook`
    as the secret key. You would have to calculate the expiration date (`exp`) by
    yourself, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking the token at [https://jwt.io](https://jwt.io) shows the following
    payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `iat` attribute shows that the JWT was issued on 5/20/2018, close to 2:00
    P.M. and the `exp` attributes show that the token is set to expire one hour (3,600
    seconds) later. If we now repeat the curl request to `/private`, but adding the
    appropriate header, it will be accepted. However, if you wait (at least an hour!),
    the result will be different; the JWT checking middleware will detect the expired
    token, and a 403 error will be produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: With this code, we now have a way to add authentication to our RESTful server.
    If you want, you could go further and add specific authorization rules so that
    some users would get access to some features, while others would be restricted.
    Now, let's try to bring everything together, and build ourselves a small REST
    set of services.
  prefs: []
  type: TYPE_NORMAL
- en: Tying it all together – building a REST server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, let's write at least a part of a complete RESTful server for
    our world database that we started using in the *Working with a database* section
    of the previous chapter, according to the routing scheme that we saw in the *Adding
    Routes* section earlier in this chapter. We'll focus on just working with Regions,
    but only for the sake of brevity; Countries and Cities are very similar in terms
    of coding, and the full code is provided with this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our REST services will send JSON answers and require tokens for authorization.
    We will enable CORS so that we can access them from different web pages. The routes
    we will process will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /regions` will provide all regions of all countries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /regions/:country` will return all regions of the given country'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /regions/:country/:region` will return a single region'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE /regions/:country/:region` will let us delete a given region'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST /regions/:country` will allow us to create a new region'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT /regions/:country/:region` will let us create or update a given region'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dealing with countries and cities is quite similar, with only a couple of exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: Because of the size of the result set, we won't accept `GET` `/cities` requests
    to provide all cities in the world; only `GET` `/cities/:city` will be permitted.
    An alternative would be accepting the request, but sending back a `405` status
    code, `Method not allowed`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since country codes cannot be assigned at will, we won't allow `POST /countries`.
    Instead, `PUT` `/countries/:country` will be required to add a new country, as
    well as for updating an existing one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each type of request will produce the appropriate HTTP status codes; we'll see
    that in the following sections. Also, `GET` requests will be sent JSON results,
    and `POST` requests will be sent the location of the newly created entity; more
    on this later.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at how we can write our server. We''ll start with some basic code,
    skipping parts that we already saw earlier, such as CORS and JWT handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Handling routing is quite standard. Since routes are simple and few, we may
    put them in the same source file; otherwise, we''d set up separate files for different
    sets of routes. The handlers for the routes will certainly go in another file
    (`"restful_regions.js"`) so as not to obscure the main server code. Note that
    country and region codes are, if present, part of the URL; whenever the name for
    a region is needed, it goes in the body parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s look at some more code that we''ve already seen to finish up
    the server, error handling and setting up the server itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Let's move on and see how it works. We'll show the code for handling routes
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have four kinds of requests, let's split our study of the server code
    appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Handling GETs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw previously, there are three possible routes to handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/regions` to get all regions of all countries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/regions/UY` to get all regions of a given country—in this case, Uruguay (`UY`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/regions/UY/11` to get a specific region of a country—here, region 11 of Uruguay'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can handle all three cases in a similar way by just changing the `SQL SELECT`
    we''ll be doing. Handling the results, however, will require a special case, as
    we''ll note in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The special case we mentioned in the preceding code is asking for something
    like `/regions/XYZZY`, and providing a wrong country code. In this case, instead
    of sending an empty set (which could imply that the country does exist, as it
    doesn't seem to have any regions) we can send a `404`, so the second `if` statement
    (country provided, region absent) does a special check before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this code working with several examples. Getting `/regions` with
    no further parameter provides a largish output (22 MB), so adding parameters to
    allow for filtering or paging could be in order:'
  prefs: []
  type: TYPE_NORMAL
- en: I removed the HTTPS, CORS, and mainly the JWT code from the server to make the
    examples simpler to follow. Doing this meant that I haven't received extra headers,
    and have avoided having to provide a JWT in each call. Yes, I cheated a bit, but
    the source code provided with the book includes everything, so don't worry about
    it!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'A request for a specific country (such as `/regions/UY`) produces an answer
    very much like the one that we received previously, but including only the regions
    in the country `UY` (Uruguay) and a request for a single region gets a single
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can try for an error; check out the following screenshot and note
    the 404 status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28a633c1-96fa-402a-9210-15273201047a.png)'
  prefs: []
  type: TYPE_IMG
- en: Asking our RESTful server for regions in a non-existent country produces a 404
    error
  prefs: []
  type: TYPE_NORMAL
- en: Handling DELETEs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deleting a region is simple, except that you must check beforehand whether
    the region has any cities or not. We could solve this by implementing a cascading
    deletion so that when you delete a region, all of its cities get deleted as well,
    or we may forbid the deletion outright. In our case, I opted for the latter, but
    it could be argued that the former is also valid, and would require not very complex
    logic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Why are we checking for cities by ourselves, instead of letting the DB server
    do it by using foreign keys? The reason is simple: I wanted to show some code
    that went a bit beyond a single SQL statement. The very same argument could be
    done for cascade deletions, which you could implement with a hand-crafted SQL
    sentence, or by setting up special rules in your database. And, let me state that
    for an actual application, letting the DB do the work would actually be preferable!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test this in a similar way. Deleting a region without cities works,
    while attempting to do it for a region with cities or for a non-existing region
    fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'See the different status codes that may be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: 204, if a region was deleted with no problems—and in that case, no text response
    is sent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 404, if the requested region doesn't exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 405, if the request couldn't be accepted (because the regions had cities)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, you might change the workings of the service and, for example, provide
    for a cascading delete operation if a certain parameter was provided, as in `http://some.server/regions/uy/23?cascade=true`.
    Also, for some services, this operation may happen without even asking for it;
    a user might have a set of preferences, and whenever a user is to be deleted,
    you should also delete their preferences. This would depend on the desired semantics
    of the service.
  prefs: []
  type: TYPE_NORMAL
- en: Handling PUTs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `PUT` request means that an existing resource is to be updated. In our case,
    a pre-condition is that the specified region must exist; otherwise, a `404` error
    would be appropriate. If the region exists, then we can update it and send a `204`
    status. If `MySQL` detects that no changes have been made to the region, it lets
    you know that the `UPDATE` didn''t change anything; you could either send a `204`
    (as I chose to) or a `409` error, but in any case, you are certain that the region
    has the data you want. We''ll also have to do some parameter checking; in this
    case, just to make sure that a name is given, but the data validation logic could
    be much more complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This is easy to test, since there are only two situations (either the region
    exists or it doesn''t), plus a sanity check in case the name is missing. Let''s
    add the missing tilde to a region first; just like before, no content will be
    received because of the 204 status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The two error cases (non-existent region, missing name) are quickly taken care
    of. The former case is detected by `MySQL`, while the latter is caught by the
    initial `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Handling `PUT` is just about the simplest case; let's finish our study of the
    server by taking a close look at the most complex request, a `POST`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling POSTs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, handling `POST` requests is a bit more complex, since you are supposed
    to say to which collection (in this case, a country''s) you want to add the new
    resource, and the logic is supposed to do everything, including assigning an ID.
    This means that our code will be a bit longer, since we''ll be adding the need
    to find an unused region code. There will be another difference: when the resource
    is created, the URI for the new resource should be returned in the `Location`
    header, so that will be another extra requirement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, once again, we''ll have some data validation, as with `PUT` requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the logic that requires the most queries. We must (1) check that the
    country exists, (2) determine the maximum region ID for that country, and only
    then (3) insert the new region and return a 201 status to the user. We can test
    this in a similar way to what we did for `PUT`, so let''s look at a simple case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Argentina has 24 provinces, numbered from 1 to 24 in the `regions` table, so
    if we add a new one, it should be #25, and the `Location` header in the answer
    proves that this is so. (We are only returning the route, without the server and
    port, but we could easily add those pieces of data.) Doing a `GET` confirms that
    the `POST` succeeded.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have set up a barebones RESTful server with `Express`, but there is much
    more—enough for a book of its own! Let's finish this chapter by taking a very
    quick glance at several ideas and tools that you might want to consider for your
    own projects.
  prefs: []
  type: TYPE_NORMAL
- en: Accepting JSON data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have used `POST` parameters in our examples, but it's also possible to receive,
    parse, and process JSON input. (This can make it easier to call a REST service,
    because at the frontend it's very likely you'll be able to readily produce an
    object with the desired parameters for the request.) Use `express.json()` as middleware,
    and the request body will include the data from the JSON parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [http://expressjs.com/en/4x/api.html#express.json](http://expressjs.com/en/4x/api.html#express.json)
    for more information on this.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the PATCH method for partial updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PUT method makes you update a complete entity, but sometimes you want to
    affect only a few fields, and in this case you can allow the `PATCH` method. `PATCH`
    is similar to `PUT`, but lets you update only some attributes. Adding support
    for this method is not complex, and is very similar to the `PUT` logic, so you
    may provide a more powerful server with relatively little extra coding.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about PATCH at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH) and
    if you care about its specification, at [https://datatracker.ietf.org/doc/rfc5789/](https://datatracker.ietf.org/doc/rfc5789/).
  prefs: []
  type: TYPE_NORMAL
- en: Using Restify instead of Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While `Express` is a very popular and widely used package that can be used to
    build any kind of server, if you specifically want just a REST server and no other
    feature, you may consider using other packages, such as `Restify`. The advantages
    of such a change have to do with the orientation of the package, which provides
    similar features to `Express`, but requires a bit less code in order to accomplish
    a RESTful deployment. Some well-known users of `Restify` are `npm` and Netflix,
    but the list is much longer.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about `Restify` at [http://restify.com/](http://restify.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Allowing filtering, sorting, and pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since REST is basically a style and not a specification for services, there
    are aspects that aren't specified, and you have some leeway as to their implementation.
    Three common requirements are *filtering* (so you don't get all entities, but
    just those that satisfy some condition), *sorting* (so that entities are included
    in some order), and *pagination* (because showing hundreds or thousands of entities
    at once isn't practical). Of course, these three requirements interact with each
    other; if you sort and filter, then paging should apply to the sorted filtered
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of these requirements can be handled by adding some query parameters (or
    possibly headers), but you''ll have to study a bit to understand what''s the best
    way for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Filtering* may be specified with a format such as `filter=price[lt]220`, which
    would specify that a given attribute (`price`) must be less than (`lt`) a value
    (`200`). Building up more complex expressions involving logical operators such
    as `and`, `or`, and `not`, plus optional parentheses, can also be done, at the
    cost of more complex parsing and interpreting at the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Sorting* may be specified by parameters such as `sortby=price,name` to order
    first by `price` and then by `name`. You can add other options to allow for ascending
    or descending sorting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Paging* can be done by using the `limit` and `offset` parameters, with the
    same interpretation that''s used in SQL `SELECT` statements (see [https://dev.mysql.com/doc/refman/8.0/en/select.html](https://dev.mysql.com/doc/refman/8.0/en/select.html)
    for more on that) or by specifying a page size and the page number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the handling of these options to your REST server will make it more powerful,
    and enable the client to send more specific, optimized requests. There is one
    more extension that you may want; being able to select extra, related entities,
    so read on.
  prefs: []
  type: TYPE_NORMAL
- en: Using GraphQL instead of REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST services are standard and easy to use, but may imply some overhead, mostly
    when you don't need just a single entity, but also some related ones; for example,
    how would you get a country and all of its regions? With our current design, you'd
    have to do separate calls and join the results by yourself, or otherwise extend
    your routes yourself. For example, you would do this for `/regions/uy?include=cities`
    so that the server would add—to each region in `UY`—an array with its cities.
    While this solution may be apt for a small example like the one we're using, for
    bigger, more complex databases, with tables related among themselves in many ways,
    it could easily get out of hand.
  prefs: []
  type: TYPE_NORMAL
- en: There is, however, another option. `GraphQL` is a data query language that was
    developed by Facebook, and it lets you define, at the client, the structure of
    the data you require; the server will do whatever is needed to produce exactly
    that. `GraphQL` lets you get many related resources with a single request by following
    references to build a complex structure, and sending it along with the minimum
    delay. You also get tools to help you define your data schema and perform online
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a very short example, taken from the documentation of GraphQL''s
    own site, at [http://graphql.org/learn/queries/](http://graphql.org/learn/queries/).
    Given a database of *Star Wars* movies, you could write the following query that
    wants to get the hero from a couple of movies, and for each one, the name, the
    list of movies they appear in, and all of their friends'' names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this query is as follows. Note how the object structure follows
    your specification in the query, and that repeated fields, or foreign key access,
    were all solved by the `GraphQL` server, and in a single request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: While totally outside the scope of this chapter (we wanted a RESTful server,
    after all), `GraphQL` is a very valid alternative for applications that need to
    work with complex, linked structures, which would require too much processing
    and communication time otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about `GraphQL`, check out the official site at [https://graphql.org/](https://graphql.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a microservice-based architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you're able to develop a server by following the structure in this
    chapter, working in an SOA might evolve into a microservices organization, in
    which the server, instead of being a monolithic piece of code that can provide
    multiple services, is organized as a set of distinct mini-servers, loosely coupled,
    connected by a lightweight protocol, and each having a single responsibility.
    Services may be created by different groups, even using different languages or
    libraries, that are only dependent on following a given interface so that other
    services may freely interact with them as needed.
  prefs: []
  type: TYPE_NORMAL
- en: This structure, based on independent smaller pieces, greatly helps with scalability,
    modularity, and even development and testing. If changes are needed, their impact
    will be smaller, and strategies such as continuous delivery and deployment become
    feasible. Developing the microservices themselves is readily done, and the necessary
    techniques for doing this are mainly the ones that we saw in this chapter. Only
    adding the requests from one microserver to another to gather all of the required
    information is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: A couple of good starting points on the benefits of a microservice-based architecture
    are the articles by Martin Fowler at [https://martinfowler.com/microservices/](https://martinfowler.com/microservices/) and
    by Chris Richardson at [http://microservices.io/patterns/microservices.html](http://microservices.io/patterns/microservices.html).
  prefs: []
  type: TYPE_NORMAL
