- en: AJAX, HTML5, and Client-Side Attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](part0021.html#K0RQ0-d48f8b63a8cc440fbc92835fec01cc38), *Introduction
    to Penetration Testing and Web Applications*, we reviewed what AJAX and HTML5
    do and how they work. In this chapter, we will look deeper into their security
    aspects and how they can introduce or extend vulnerabilities in web applications
    and thereby pose new challenges for penetration testers.
  prefs: []
  type: TYPE_NORMAL
- en: As stated in [Chapter 1](part0021.html#K0RQ0-d48f8b63a8cc440fbc92835fec01cc38),
    *Introduction to Penetration Testing and Web Applications*, AJAX is a combination
    of technologies, mainly JavaScript, XML and web services, which allow asynchronous
    HTTP communication between client and server.
  prefs: []
  type: TYPE_NORMAL
- en: Crawling AJAX applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In an AJAX-based application, the links that the crawler can identify depend
    on the application''s logic flow. In this section, we will talk about three tools
    that can be used to crawl AJAX applications:'
  prefs: []
  type: TYPE_NORMAL
- en: The AJAX Crawling Tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sprajax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AJAX Spider OWASP ZAP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with any automated task, crawling AJAX applications must be carefully configured,
    logged, and monitored, as they may cause calls to unexpected functions and trigger
    undesired effects on the application, affecting the contents of the database,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: AJAX Crawling Tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**AJAX Crawling Tool** (**ACT**) is used to enumerate AJAX applications. It
    can be integrated with web application proxies. Once crawled, the links are visible
    in the proxy interface. From there, you can test the application for vulnerabilities.
    To set up and use ACT, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the ACT from the following URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://code.google.com/p/fuzzops-ng/downloads/list](https://code.google.com/p/fuzzops-ng/downloads/list)'
  prefs: []
  type: TYPE_NORMAL
- en: 'After downloading ACT, start it from the bash shell using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will produce the output shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00228.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Specify the target URL, and set the proxy setting to chain it with your proxy.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, use the ZAP proxy running on port `8010` on the localhost. You
    also need to specify the browser type. To start the crawling, click on the Crawl
    menu and select the Start Crawl option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the ACT starts **spidering** the application, new links will be visible
    in the proxy window, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00229.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Sprajax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Sprajax** is a web application scanner specifically designed for applications
    built using AJAX frameworks. It''s a black box security scanner, which means that
    it doesn''t need to be preconfigured with details of the target application. It
    works by first identifying the AJAX framework used, which helps it to create test
    cases with fewer false positives. Sprajax can also identify typical application
    vulnerabilities such as XSS and SQL injections. It first identifies the functions,
    and then fuzzes them by sending random values. **Fuzzing** is the process of sending
    multiple probes to the target and analyzing their behavior in order to detect
    when one of the probes triggers a vulnerability. The URL for *OWASP Sprajax Project*
    is [https://www.owasp.org/index.php/Category:OWASP_Sprajax_Project](https://www.owasp.org/index.php/Category:OWASP_Sprajax_Project).'
  prefs: []
  type: TYPE_NORMAL
- en: Besides ACT and Sprajax, Burp Suite proxy and OWASP ZAP provide tools to crawl
    an AJAX website, but manually crawling the application is a major part of the
    reconnaissance process as the AJAX-based application may contain many hidden URLs
    which are only exposed if the logic of the application is understood.
  prefs: []
  type: TYPE_NORMAL
- en: The AJAX Spider – OWASP ZAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An AJAX Spider comes integrated with OWASP ZAP. It uses a simple methodology
    where it follows all of the links that it can find through a browser, even the
    ones generated by the client-side code, which helps it effectively spider a wide
    range of applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The AJAX Spider can be invoked from the Attack menu, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00230.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, there are parameters to configure before the Spider starts the crawling
    process. You can select the web browser to be used by the plugin. In the Options
    tab, you can also define the number of browser windows to open, crawl depth, and
    the number of threads. Be careful when modifying these options, as it can slow
    down the crawling:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00231.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the crawling starts, a browser window opens and ZAP will automatically
    browse through the application while the results populate in the AJAX Spider tab
    in the bottom pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00232.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Analyzing the client-side code and storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have previously addressed how the increase in the client-side code can lead
    to potential security issues. AJAX uses **XMLHttpRequest** (**XHR**) objects to
    send asynchronous requests to the server. These XHR objects are implemented using
    client-side JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to learn more about the client-side code. Viewing the
    source by pressing the *Ctrl* + *U* shortcut will reveal the underlying JavaScript
    that creates the XHR objects. If the web page and script are large, analyzing
    the application by viewing the source won't be helpful and/or practical.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about the actual request sent by the script, you can use a web
    application proxy and intercept the traffic, but the request will reach the proxy
    after passing through a number of processes in the client's script code, which
    may include validation, encoding, encryption, and other modifications that will
    complicate your understanding of how the application works.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will use the web browser''s built-in developer tools to
    analyze the behavior of the client-side code and how it affects what is seen in
    the page and what the server receives from the application. All major modern web
    browsers include tools to debug client-side code in web applications, although
    some may have more features than others. All of them include the following basic
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: An object inspector for elements in the page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A console output to display errors, warnings, and log messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A script code debugger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A network monitor to analyze the requests and responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A storage manager for cookies, cache, and HTML5 local storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the browsers follow the design of the original Firefox plugin Firebug.
    We will cover Firefox's web developer tools, as it is the one included in Kali
    Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Browser developer tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Firefox, as in all of the major browsers, developer tools can be activated
    using the *F12* key; other key combinations can also be used in Firefox, namely
    *Ctrl* + *C* and *Ctrl* + *I*. The following screenshot shows the settings panel,
    where you can select the tools that you want to have visible as well as other
    preferences such as color theme, available buttons, and key bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00233.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Inspector panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Inspector panel, seen in the following screenshot, shows the HTML elements
    contained in the current page and their properties and style settings. You can
    change those properties and styles and remove or add elements as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00234.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Debugger panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Debugger panel is where you can get a deeper look at the actual JavaScript
    code. It includes a debugger where you can set breakpoints or execute the script
    step by step, while analyzing the flow of the client-side code and identifying
    vulnerable code. Each script can be viewed individually via the drop-down menu.
    The Watch side panel will display the values of the variables as they change during
    the execution of the script. The breakpoints set are visible beneath the Breakpoints
    panel, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00235.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A recent addition to the Debugger panel is the ability to format source code
    in a way that is more readable, as many JavaScript libraries are loaded as a single
    line of text. In Firefox, this option is called Prettify Source, and it can be
    activated per file by right-clicking over the code and selecting it from the context
    menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00236.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Console panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Console panel displays logs, errors, and warnings triggered by the HTML
    elements and the execution of script code. It also includes a JavaScript command-line
    interpreter, which is visible at the bottom of the window. It allows you to execute
    JavaScript code within the context of the current website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00237.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Network panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Network panel shows all of the network traffic generated by the current
    web page. It lets you see where the page is communicating to and what requests
    it is making. It also includes a visual representation of how much time it takes
    to respond to and load each request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00238.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you select any request, you will see the detail of the headers and body
    as well as the response and cookies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00239.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Storage panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Storage panel is also a recent addition, created to allow interaction with
    the HTML5 storage options and cookies. Here you can browse and edit cookies, web
    storage, indexed databases, and cache storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00240.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The DOM panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The DOM panel lets you view and change the values of all DOM elements in the
    context of the current page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00241.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: HTML5 for penetration testers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The latest version of the HTML standard comes with many new features that may
    help the developers prevent security flaws and attacks on their applications.
    However, it also poses new challenges for the design and implementation of new
    functionality, which may lead to applications opening up new and unexpected opportunities
    to attackers due to the use of not-yet-fully understood new technology.
  prefs: []
  type: TYPE_NORMAL
- en: In general, penetration testing an HTML5 application is no different than testing
    any other web application. In this section, we will cover some of the key features
    of HTML5, their implication for penetration testing, and some ways that applications
    implementing these features can be attacked.
  prefs: []
  type: TYPE_NORMAL
- en: New XSS vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cross-Site Scripting** (**XSS**) is a major issue in HTML5 applications,
    as JavaScript is used to interact with all of the new features from client-side
    storage to WebSockets to Web Messaging.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, HTML includes new elements and tags that may be used as attack vectors
    for XSS.
  prefs: []
  type: TYPE_NORMAL
- en: New elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Video and audio are new elements that can be put into web pages using the `<video>`
    and `<audio>` tags, these tags can also be used in an XSS attack with the `onerror`
    property, just as `<img>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: New properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Form elements have new properties that can be used to execute JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `autofocus` property specifies that the `<input>` element should get the
    focus automatically when the page loads, and `onfocus` sets the event handler
    for when the `<input>` element gets the focus. Combining these two actions ensures
    the execution of the script when the page loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'An event will be triggered when a change (value modification) is done to the
    form with the `form1` ID. The handler for that event is the `XSS` payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The form's action indicates the place where the form's data is going to be sent.
    In this example, a button is setting the action to an XSS payload when it is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Local storage and client databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before HTML5, the only mechanism allowing web applications to store information
    on the client side was a cookie. There were also some workarounds, such as Java
    and Adobe Flash, which brought many security concerns along with them. HTML5 now
    has the capability of storing structured and nonstructured persistent data in
    the client with two new features: Web Storage and IndexedDB.'
  prefs: []
  type: TYPE_NORMAL
- en: As a penetration tester, you need to be aware of any usage of client-side storage
    by the application. If the information stored there is sensitive, make sure that
    it is properly protected and encrypted. Also, test whether stored information
    is used for operations further along in the application, and if it can be tampered
    with to generate an XSS scenario, for example. Finally, check to be sure that
    such information is correctly validated on input and sanitized on output.
  prefs: []
  type: TYPE_NORMAL
- en: Web Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Web Storage** is HTML5''s way of allowing the applications to store non-structured
    information on the client other than cookies. Web Storage can be of two types:
    `localStorage`, which doesn''t have an expiration, and `sessionStorage`, which
    is deleted when the session ends. Web Storage is managed by the `window.localStorage`
    and `window.sessionStorage` by the JavaScript objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how Web Storage, the `localStorage` type in
    this case, can be seen using the browser''s developer tools. As can be seen in
    the screenshot, information is stored using pairs of keys and values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00242.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: IndexedDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For structured storage (information organized in tables containing elements
    of the same type), HTML5 has **IndexedDB**.
  prefs: []
  type: TYPE_NORMAL
- en: Before IndexedDB, Web SQL Database was also used as part of HTML5, but that
    was deprecated in 2010.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows an example of an indexed database stored by
    a web application and seen using the browser''s developer tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00243.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Web Messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Web Messaging** permits communication between two documents that do not require
    DOM, and it can be used across domains (sometimes called, **Cross-Domain Messaging**).
    For an application to receive messages, it needs to set up an event handler that
    processes the incoming messages. The event triggered on receiving a message has
    the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data`: The message data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`origin`: The domain name and port of the sender'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastEventId`: The unique ID of the current message event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`source`: This contains a reference to the document''s window that originated
    the message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ports`: This is an array containing any `MessagePort` objects sent with the
    message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows an event handler that does a proper origin validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maybe the most radical addition in HTML5 is the introduction of **WebSockets**
    as a persistent bidirectional communication between the client and server over
    the HTTP protocol, which is a stateless protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned in [Chapter 1](part0021.html#K0RQ0-d48f8b63a8cc440fbc92835fec01cc38),
    *Introduction to Penetration Testing and Web Applications*, WebSockets communication
    starts with the handshake between client and server. In the code shown in the
    following screenshot, taken from Damn Vulnerable Web Sockets ([https://github.com/snoopysecurity/dvws](https://github.com/snoopysecurity/dvws)),
    you can see a basic JavaScript implementation of WebSockets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00244.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This code starts a WebSockets connection as soon as the HTML document is loaded.
    It then sets the event handlers for when the connection is established, when a
    message arrives, and when the connection closes or an error occurs. When the page
    loads the request to initiate the connection, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00245.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the connection is accepted, the server will respond as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00246.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that `Sec-WebSocket-Key` in the request and `Sec-WebSocket-Accept` in
    the response are used only for the sake of the handshake and starting the connection.
    They are not an authentication or authorization control. This is something to
    which a penetration tester must pay attention. WebSockets, by themselves, don't
    provide any authentication or authorization control; this needs to be done at
    the application level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the connection implemented in the previous example is not encrypted.
    This means that it can be sniffed and/or intercepted through **man-in-the-middle**
    (**MITM**) attacks. The next screenshot presents a traffic capture with Wireshark
    showing the exchange between client and server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00247.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The first two packets are the WebSockets handshake. After that, the message
    interchange starts. In this case, the client sends a name and the server responds
    `Hello <NAME> :) How are you?`. The data sent from client to server should be
    masked, as per the protocol definition (RFC 6455, [http://www.rfc-base.org/txt/rfc-6455.txt](http://www.rfc-base.org/txt/rfc-6455.txt)),
    and the server must close the connection if it receives a non-masked message.
    On the contrary, messages from server to client are not masked, and the client
    closes the connection if masked data is received. **Masking** is not to be considered
    a security measure, as the masking key is included within the packet frame.
  prefs: []
  type: TYPE_NORMAL
- en: Intercepting and modifying WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web proxies such as Burp Suite and OWASP ZAP can record WebSockets communication.
    They are also able to intercept and allow the addition of incoming and outgoing
    messages. OWASP ZAP also allows resending messages and use of the Fuzzer tool
    to identify vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Burp Suite''s proxy, there is a tab that shows the history of WebSockets
    communication. The regular Intercept option in the proxy can be used to intercept
    and modify incoming and outgoing messages. It doesn''t include the capability
    of using Repeater to resend a message. The following screenshot shows a message
    being intercepted in Burp Suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00248.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'OWASP ZAP also has a special history tab for WebSockets. In that tab, one can
    set up breakpoints (like Burp Suite''s Intercept) by right-clicking on any of
    the messages and selecting Break... . A new dialog will pop up where the break
    parameters and conditions can be set, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00249.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When right-clicking on messages, there is also a Resend option, which opens
    the selected message for modification and resending. This works for both incoming
    and outgoing traffic. Thus, when resending an outgoing message, OWASP ZAP will
    deliver the message to the browser. The next screenshot shows the Resend dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00250.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you right-click the text in Resend, one of the options that appears is to
    fuzz that message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next screenshot shows how to add fuzzing strings to the default location.
    Here we are adding only a small set of XSS tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00251.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we run the Fuzzer, the corresponding tab opens and shows the successful
    results (that is, the results that got a response resembling a vulnerable application):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00252.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Other relevant features of HTML5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As said before, HTML5 incorporates many features in different areas that may
    affect the application's security posture. In this section we will briefly cover
    other features presented by HTML5 that may also have an impact on how and where
    we look for security flaws.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Origin Resource Sharing (CORS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When enabled in a server, the header `Access-Control-Allow-Origin` is sent
    in requests. This header tells the client that the server allows requests through
    XMLHttpRequest from origins (domains and ports) other than the one hosting the
    application. Having the following header allows requests from any source, making
    it possible for an attacker to use JavaScript to bypass CSRF protection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Geolocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern web browsers can grab geographic location data from the devices in which
    they are installed, be it the Wi-Fi network in a computer or the GPS and cellular
    information in a mobile phone. An application using HTML5 and vulnerable to XSS
    may expose location data of its users.
  prefs: []
  type: TYPE_NORMAL
- en: Web Workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Web Workers** are JavaScript code running in the background that have no
    access to the DOM of the page calling them. Apart from being able to run local
    tasks in the client, they can use the XMLHttpRequest object to perform in-domain
    and CORS requests.'
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, it's becoming increasingly popular for web applications to use JavaScript
    code in order to use a client's processing power to mine cryptocurrencies. Most
    of the time, it is because these applications have been compromised. Web Workers
    present a unique opportunity for attackers if the application is vulnerable to
    XSS, especially if it uses user input to send messages to Web Workers or to create
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'AppSec Labs has created a toolkit, *HTML5 Attack Framework* ([https://appsec-labs.com/html5/](https://appsec-labs.com/html5/)),
    for testing specific features of HTML5 applications such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Clickjacking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CORS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML5 DoS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web Messaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage Dumper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bypassing client-side controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all of the capabilities of modern web applications on the client side,
    it's sometimes easier for developers to delegate checks and controls to client
    code executed by the browser, thus freeing the server of that extra processing.
    At first, this may seem like a good idea; that is, letting the client handle all
    of the data presentation, validation of user input, and formatting and use the
    server only to process business logic. However, when the client is a web browser,
    which is a multipurpose tool that is not used exclusively for one application,
    and which can use a proxy to tunnel all communications that can then be tampered
    with and controlled by the user, developers need to reinforce all security-related
    tasks such as authentication, authorization, validation, and integrity checks
    on the server side. As a penetration tester, you will find plenty of applications
    that fail to do this consistently.
  prefs: []
  type: TYPE_NORMAL
- en: A very common scenario is when applications show or hide GUI elements and/or
    data depending on the user's profile and privilege level. Many times, all of these
    elements and data are already retrieved from the server, and they are just disabled
    or hidden using style properties in the HTML code. An attacker or penetration
    tester could then use the Inspector option from the browser's developer tools
    to change those properties and gain access to the hidden elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review an example of this using *Mutillidae II''s Client-side Control
    Challenge* (Others | Client-side "Security" Controls). It is a form with many
    input fields of different types, some of them disabled, hidden, or moving when
    you want to write on them. If you just fill some of them in and click Submit,
    you will get an error. You need to complete all of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00253.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Press the *F12* key to open the developer tools, or right-click on one of the
    disabled fields and select Inspect Element. The latter will also open the developer
    tools, but it will locate you within Inspector as well, and in the area specific
    to the element that you selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00254.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see, for example, that the Disabled Text Box has a property `disabled`
    with a value of `1`. One may think that changing the value to `0` should enable
    it, but that''s not how it works. Having such property with any value makes the
    browser show the input as disabled. So double-click on the property name and delete
    it. Now you can add text to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00255.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can continue altering the properties of all of the fields so that you can
    fill them. You will also find a Password field. If you inspect it, you will see
    that even when it shows only dots in the page, it actually contains a cleartext
    value, which in a real-application may be an actual password:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00256.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, when you complete all of the fields and click Submit again, an alert
    pops up saying that some field doesn''t have the correct format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00257.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This message can be traced by going to the Debugger panel in the developer
    tools, and then by entering an exclamation mark `!` in the search box to search
    in all of the files, followed by part of the text you are seeking. The function
    in `index.php` does the validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00258.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice how this function uses regular expressions to validate the inputs, and
    these regular expressions are formed so that they only match one character string.
    Here, you can do two things—you can set a breakpoint after the regular expressions
    are defined and change their values in runtime, and/or you can fill all of the
    fields with values that match those checks so that the request can be sent and
    then intercept the request with a proxy and edit it in the proxy. We will now
    do the latter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00259.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can enter any value you want in any field. You can even add or remove fields
    if you believe that it's relevant to your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, using the browser's developer tools, you can easily enable, disable, show,
    or hide any element in a web page. It also lets you monitor, analyze, and control
    the execution flow of JavaScript code. Even if there is a complex validation process
    that is inefficient timewise to alter or bypass, you can adjust the input out
    to it and use a proxy to alter it once the request leaves the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Mitigating AJAX, HTML5, and client-side vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key to preventing client-side vulnerabilities, or at least to minimizing
    their impact, is *never to trust external information*, be it from a client application,
    web service, or the server inputs. These must always be validated before processing
    them, and all of the data being shown to users must be properly sanitized and
    formatted before displaying it in any format (such as HTML, CSV, JSON, and XML).
    It is a good practice to do a validation layer on the client-side, but that cannot
    be a replacement for server-side validation.
  prefs: []
  type: TYPE_NORMAL
- en: The same thing happens with authentication and authorization checks. Some effort
    can be made to reduce the number of invalid requests that reach the server, but
    the server-side code must verify that the requests that reach it are indeed valid
    and allowed to proceed to the user's session that is sending such requests.
  prefs: []
  type: TYPE_NORMAL
- en: For AJAX and HTML5, correctly configuring the server and parameters, such as
    cross origin, content-type headers, and cookie flags will help in preventing a
    good number of attacks from causing damage.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about crawling AJAX applications. We then moved
    on to reviewing the changes that HTML5 poses to penetration testers in terms of
    new functionality and new attack vectors. Then, we reviewed some techniques that
    let you bypass security controls implemented on the client-side. In the final
    section, we reviewed some key issues to take into account in order to prevent
    AJAX, HTML5, and client-side vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about more everyday security flaws in web
    applications.
  prefs: []
  type: TYPE_NORMAL
