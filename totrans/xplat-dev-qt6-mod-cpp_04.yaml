- en: '*Chapter 3*: GUI Design Using Qt Widgets'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt Widgets is a module that offers a set of **user interface** (**UI**) elements
    for building classic UIs. In this chapter, you will be introduced to the **Qt
    Widgets** module and will learn about basic widgets. We will look at what widgets
    are and the various kinds that are available for creating **graphical UIs** (**GUIs**).
    In addition to this, you will be introduced to layouts with **Qt Designer**, and
    you will also learn how to create your own custom controls. We will take a close
    look into what Qt can offer us when it comes to designing sleek-looking GUIs with
    ease. At the beginning of this chapter, you will be introduced to the types of
    widgets provided by Qt and their functionalities. After that, we will walk through
    a series of steps and design our first form application using Qt. You will then
    learn about Style Sheets, **Qt Style Sheets** (**QSS files**), and theming.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following main topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Qt widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a UI with Qt Designer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Qt Style Sheets and custom themes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring custom styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using widgets, windows, and dialogs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the basics of GUI elements and
    their corresponding C++ classes, how to create your own UI without writing a single
    line of code, and how to customize the look and feel of your UI using Style Sheets.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technical requirements for this chapter include Qt 6.0.0 MinGW 64-bit,
    Qt Creator 4.14.0, and Windows 10/Ubuntu 20.04/macOS 10.14\. All the code used
    in this chapter can be downloaded from the following GitHub link: [https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter03](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter03).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The screenshots used in this chapter are taken from a Windows environment. You
    will see similar screens based on the underlying platforms in your machine.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Qt widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A widget is the basic element of a GUI. It is also known as a `QObject`. `QWidget`
    is a basic widget and is the base class of all UI widgets. It contains most of
    the properties required to describe a widget, along with properties such as geometry,
    color, mouse, keyboard behavior, tooltips, and so on. Let''s have a look at `QWidget`
    inheritance hierarchy in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – QWidget class hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.1_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – QWidget class hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the Qt widget names are self-explanatory and can be identified easily
    as they start with *Q*. Some of them are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QPushButton` is used to command an application to perform a certain action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QCheckBox` allows the user to make a binary choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QRadioButton` allows the user to make only one choice from a set of mutually
    exclusive options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QFrame` displays a frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QLabel` is used to display text or an image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QLineEdit` allows the user to enter and edit a single line of plain text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QTabWidget` is used to display pages related to each tab in a stack of tabbed
    widgets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One of the advantages of using Qt Widgets is its parenting system. Any object
    that inherits from `QObject` has a parent-child relationship. This relationship
    makes many things convenient for developers, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: When a widget is destroyed, all its children are destroyed as well due to the
    parent-children hierarchy. This avoids memory leaks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find children of a given `QWidget` class by using `findChild()` and
    `findChildren()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Child widgets in a `Qwidget` automatically appear inside the parent widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A typical C++ program terminates when the main returns, but in a GUI application
    we can't do that, or the application will be unusable. Thus, we will need the
    GUI to be present until the user closes the window. To accomplish this, the program
    should run in a loop till this happens. The GUI application waits for user input
    events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use `QLabel` to display a text with a simple GUI program, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember to add the following line to the `helloworld.pro` file to enable the
    Qt Widgets module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QT += widgets`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to run `qmake` after you make changes to your `.pro` file. If you
    are using the command line, then proceed with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, hit the **Run** button to build and run the application. You will soon
    see a UI with **Hello World!** displayed, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Simple GUI application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.2_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Simple GUI application
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also run the application from the command line on Windows, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the application from the command line on Linux distributions, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In command-line mode, you may see a few error dialogs if the libraries are not
    found in the application path. You can copy the Qt libraries and plugin files
    to that binary folder to resolve the issue. To avoid these issues, we will stick
    to Qt Creator to build and run our sample programs.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to create a simple GUI using the Qt Widgets
    module. In the next section, we will explore the available widgets and creating
    a UI with Qt Designer.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a UI with Qt Designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get familiar with Qt Designer''s interface before we start learning
    how to design our own UI. The following screenshot shows different sections of
    **Qt Designer**. We will gradually learn about these sections while designing
    our UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Qt Designer UI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.3_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Qt Designer UI
  prefs: []
  type: TYPE_NORMAL
- en: The Qt Widgets module comes with ready-to-use widgets. All these widgets can
    be found under the **Widget Box** section. Qt provides an option to create a UI
    by a drag-and-drop method. Let's explore these widgets by simply dragging them
    from the **Widget Box** area and dropping them into the **Form Editor** area.
    You can do this by grabbing an item and then pressing and releasing the mouse
    or trackpad over the intended region. Don't release your mouse or trackpad until
    the item reaches the **Form Editor** area.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows different types of widgets available in the
    **Widget Box** section. We have added several ready-made widgets such as **Label**,
    **Push Button**, **Radio Button**, **Check Box**, **Combo Box**, **Progress Bar**,
    and **Line Edit** into the **Form Editor** area. These widgets are very commonly
    used widgets. You can explore the widget-specific properties in **Property Editor**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Different types of GUI widgets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.4_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Different types of GUI widgets
  prefs: []
  type: TYPE_NORMAL
- en: 'You can preview your UI by selecting the **Preview…** option under the **Form**
    menu, as shown in the following screenshot, or you can hit *Ctrl* + *R*. You will
    see a window with the UI preview:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Previewing your custom UI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.5_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – Previewing your custom UI
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the created C++ code for your UI by selecting the **View C++ Code…**
    option under the **Form** menu, as shown in the following screenshot. You will
    see a window with the generated code. You can reuse the code while creating a
    dynamic UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Option to view corresponding C++ code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.6_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – Option to view corresponding C++ code
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we got familiar with the Qt Designer UI. You can also find
    the same interface embedded in `.ui` file. In the next section, you will learn
    about different types of layouts and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Managing layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt provides a set of convenient layout management classes to automatically arrange
    child widgets within another widget to ensure that the UI remains usable. The
    `QLayout` class is the base class of all layout managers. You can also create
    your own layout manager by reimplementing the `setGeometry()`, `sizeHint()`, `addItem()`,
    `itemAt()`, `takeAt()`, and `minimumSize()` functions. Please note that once the
    layout manager is deleted, the layout management will also stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list provides a brief description of the major layout classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QVBoxLayout` lines up widgets vertically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QHBoxLayout` lines up widgets horizontally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QGridLayout` lays widgets out in a grid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QFormLayout` manages forms of input widgets and their associated labels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QStackedLayout` provides a stack of widgets where only one widget is visible
    at a time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QLayout` uses multiple inheritances by inheriting from `QObject` and `QLayoutItem`.
    The subclasses of `QLayout` are `QBoxLayout`, `QGridLayout`, `QFormLayout`, and
    `QStackedLayout`. `QVBoxLayout` and `QHBoxLayout` are inherited from `QBoxLayout`
    with the addition of orientation information.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's use the Qt Designer module to lay out a few `QPushButtons`.
  prefs: []
  type: TYPE_NORMAL
- en: QVBoxLayout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `QVBoxLayout` class, widgets are arranged vertically, and they are aligned
    in the layout from top to bottom. At this point, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag four push buttons onto the **Form Editor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the push buttons and select the push buttons by pressing the *Ctrl* key
    on your keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Form** toolbar, click on the vertical layout button. You can find this
    by hovering on the toolbar button that says **Lay Out Vertically**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can see the push buttons get arranged vertically in a top-down manner in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Layout management with QVBoxLayout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.7_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – Layout management with QVBoxLayout
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also dynamically add a vertical layout through C++ code, as shown in
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This program illustrates how to use a vertical layout object. Note that the
    `QWidget` instance, `widget`, will become the main window of the application.
    Here, the layout is set directly as the top-level layout. The first push button
    added to the `addWidget()` method occupies the top of the layout, while the last
    push button occupies the bottom of the layout. The `addWidget()` method adds a
    widget to the end of the layout, with a stretch factor and alignment.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't set the parent window in the constructor, then you will have to
    use `QWidget::setLayout()` later to install the layout and reparent to the `widget`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at the `QHBoxLayout` class.
  prefs: []
  type: TYPE_NORMAL
- en: QHBoxLayout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `QHBoxLayout` class, widgets are arranged horizontally, and they are
    aligned from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag four push buttons onto the **Form Editor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the push buttons and select the push buttons by pressing the *Ctrl* key
    on your keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Form** toolbar, click on the horizontal layout button. You can find
    this by hovering on the toolbar button that says **Lay Out Horizontally**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can see the push buttons get arranged horizontally in a left-to-right manner
    in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Layout management with QHBoxLayout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.8_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – Layout management with QHBoxLayout
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also dynamically add a horizontal layout through C++ code, as shown
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example demonstrates how to use a horizontal layout object. Similar
    to the vertical layout example, the `QWidget` instance will become the main window
    of the application. In this case, the layout is set directly as the top-level
    layout. By default, the first push button added to the `addWidget()` method occupies
    the leftmost side of the layout, while the last push button occupies the rightmost
    side of the layout. You can change the direction of growth when widgets are added
    to the layout by using the `setDirection()` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at the `QGridLayout` class.
  prefs: []
  type: TYPE_NORMAL
- en: QGridLayout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `QGridLayout` class, widgets are arranged in a grid by specifying the
    number of rows and columns. It resembles a grid-like structure with rows and columns,
    and widgets are inserted as items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag four push buttons onto the **Form Editor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the push buttons and select the push buttons by pressing the *Ctrl* key
    on your keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Form** toolbar, click on the grid layout button. You can find this
    by hovering on the toolbar button that says **Lay Out in a Grid**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can see the push buttons get arranged in a grid in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Layout management with QGridLayout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.9_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – Layout management with QGridLayout
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also dynamically add grid layout through C++ code, as shown in the
    following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet explains how to use a grid layout object. The layout concept
    remains the same as in the previous sections. You can explore `QFormLayout` and
    `QStackedLayout` layouts from the Qt documentation. Let's proceed to the next
    section on how to create your custom widget and export it to the Qt Designer module.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt provides ready-to-use essential `QLabel` as our first custom widget. A custom
    widget collection can have multiple custom widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to build your first Qt custom widgets library:'
  prefs: []
  type: TYPE_NORMAL
- en: To create a new Qt custom widget project in Qt, click on the **File menu** option
    on the menu bar or hit *Ctrl* + *N*. Alternatively, you can also click on the
    **New Project** button located on the **Welcome** screen. Select the **Other Project**
    template and then select **Qt Custom Designer Widget**, as shown in the following
    screenshot:![Figure 3.10 – Creating a custom widget library project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.10_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – Creating a custom widget library project
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, you will be asked to choose the project name and project location.
    You can navigate to the desired project location by clicking the `MyWidgets`.
    Then, click on the **Next** button to proceed to the next screen. The following
    screenshot illustrates this step:![Figure 3.11 – Creating custom controls library
    project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.11_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – Creating custom controls library project
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, you can select a kit from a set of kits to build and run your
    project. To build and run the project, at least one kit must be active and selectable.
    Select the default **Desktop Qt 6.0.0 MinGW 64-bit** kit. Click on the **Next**
    button to proceed to the next screen. The following screenshot illustrates this
    step:![Figure 3.12 – Kit selection screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.12_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – Kit selection screen
  prefs: []
  type: TYPE_NORMAL
- en: In this step, you can define your custom widget class name and inheritance details.
    Let's create our own custom label with the class name `MyLabel`. Click on the
    **Next** button to proceed to the next screen. The following screenshot illustrates
    this step:![Figure 3.13 – Creating a custom widget from an existing widget's screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.13_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – Creating a custom widget from an existing widget's screen
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, you can add more custom widgets to create a widget collection.
    Let's create our own custom frame with the class name `MyFrame`. You can add more
    information to the **Description** tab or can modify it later. Click on the checkbox
    that says **The widget is a container** to use the frame as a container. Click
    on the **Next** button to proceed to the next screen. The following screenshot
    illustrates this step:![Figure 3.14 – Creating a custom widget container
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.14_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14 – Creating a custom widget container
  prefs: []
  type: TYPE_NORMAL
- en: In this step, you can specify the collection class name and the plugin information
    to automatically generate the project skeleton. Let's name the collection class
    `MyWidgetCollection`. Click on the **Next** button to proceed to the next screen.
    The following screenshot illustrates this step:![Figure 3.15 – Option to specify
    plugin and collection class information
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.15_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15 – Option to specify plugin and collection class information
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to add your custom widget project to the installed version
    control system. You may skip version control for this project. Click on the **Finish**
    button to create the project with the generated files. The following screenshot
    illustrates this step:![Figure 3.16 – Project management screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.16_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.16 – Project management screen
  prefs: []
  type: TYPE_NORMAL
- en: Expand the `mylabel.h` file. We will modify the contents to extend the functionalities.
    Add a `QDESIGNER_WIDGET_EXPORT` macro before the custom widget class name to ensure
    the class is exported properly in the `#include <QtDesigner>` to the header file
    after you insert the macro. The following screenshot illustrates this step:![Figure
    3.17 – Modifying the custom widget from the created skeleton
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.17_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.17 – Modifying the custom widget from the created skeleton
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: On some platforms, the build system may remove the symbols required by Qt Designer
    module to create new widgets, making them unusable. Using the `QDESIGNER_WIDGET_EXPORT`
    macro ensures that the symbols are retained on those platforms. This is important
    while creating a cross-platform library. There are no side effects on other platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `mylabelplugin.h` file. You will find that the plugin class is
    inherited from a new class named `QDesignerCustomWidgetInterface`. This class
    allows Qt Designer to access and create custom widgets. Please note that you must
    update the header file as follows to avoid deprecated warnings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#include <QtUiPlugin/QDesignerCustomWidgetInterface>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find several functions auto created in `mylabelplugin.h`. Don''t remove
    these functions. You can specify the values in the `name()`, `group()`, and `icon()`
    functions that appear in the Qt Designer module. Note that if you don''t specify
    an icon path in `icon()`, then Qt Designer will use the default Qt icon. The `group()`
    function is illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see in the following code snippet that `isContainer()` returns `false`
    in `MyLabel` and `true` in `MyFrame`, since `MyLabel` is not designed to hold
    other widgets. Qt Designer calls `createWidget()` to obtain an instance of `MyLabel`
    or `MyFrame`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a widget with a defined geometry or any other properties, you specify
    these in the `domXML()` method. The function returns an `MyLabel` width as `100`
    `16` px, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s have a look at the `MyWidgets.pro` file. It contains all the information
    required by `qmake` to build the custom widget collection library. You can see
    in the following code snippet that the project is a library type and is configured
    to be used as a plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We have gone through the custom widget creation process. Let's run `qmake` and
    build the library in the `inside release` folder. On the Windows platform, you
    can manually copy the `mywidgetcollectionplugin.dll` created plugin library to
    the `D:\Qt\6.0.0\mingw81_64\plugins\designer` path. This path and extension vary
    for different operating systems:![Figure 3.18 – Option to build your custom widget
    library
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.18_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.18 – Option to build your custom widget library
  prefs: []
  type: TYPE_NORMAL
- en: We have created our custom plugin. Now, close the plugin project and click on
    the `designer.exe` file present inside `D:\Qt\6.0.0\mingw81_64\bin`. You can see
    `MyFrame` under the **Custom Widgets** section, as shown in the following screenshot.
    Click on the **Create** button or use a widget template. You can also register
    your own form as a template by doing platform-specific modifications. Let's use
    the Qt Designer-provided widget template:![Figure 3.19 – Custom container in the
    new form screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.19_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.19 – Custom container in the new form screen
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see our custom widgets in the left-side **Widget Box** section, at
    the bottom. Drag the **MyLabel** widget to the form. You can find created properties
    such as **multiLine** and **fontCase** along with **QLabel** properties under
    **Property Editor**, as illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.20 – Exported widgets available in Qt Designer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.20_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.20 – Exported widgets available in Qt Designer
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also find detailed instructions with examples in the following Qt documentation
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doc.qt.io/qt-6/designer-creating-custom-widgets.html](https://doc.qt.io/qt-6/designer-creating-custom-widgets.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have successfully created your custom widgets with new
    properties. You can create complex custom widgets by combining multiple widgets.
    In the next section, you will learn how to customize the look and feel of widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Qt Style Sheets and custom themes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section, we created our custom widget, but the widget still has
    a native look. Qt provides several ways to customize the look and feel of the
    UI. A `{}` and separated by semicolons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have look at the simple `QPushButton` Style Sheet syntax, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QPushButton { color: green; background-color: rgb (193, 255, 216);}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also change the look and feel of widgets by applying Style Sheet in
    Qt Designer with the stylesheet editor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Qt Designer module and create a new form. Drag and place a push button
    on the form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, right-click on the push button or anywhere in the form to get the context
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on the **Change styleSheet…** option, as shown in the following
    screenshot:![Figure 3.21 – Adding Style Sheet using Qt Designer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.21_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.21 – Adding Style Sheet using Qt Designer
  prefs: []
  type: TYPE_NORMAL
- en: 'We have used the following Style sheet to create the previous look and feel.
    You can also change a Style Sheet from the `QWidget` properties in **Property
    Editor**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, only `Push Button` will get the style described in
    the Style Sheet, and all other widgets will have the native styling. You can also
    create different styles for each push button and apply the styles to respective
    push buttons by mentioning their object names in the Style Sheet, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QPushButton#pushButtonID`'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about Style Sheet and their usage, read the documentation at
    the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doc.qt.io/qt-6/stylesheet-reference.html](https://doc.qt.io/qt-6/stylesheet-reference.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doc.qt.io/qt-6/stylesheet-syntax.html](https://doc.qt.io/qt-6/stylesheet-syntax.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doc.qt.io/qt-6/stylesheet-customizing.html](https://doc.qt.io/qt-6/stylesheet-customizing.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Using a QSS file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can combine all Style Sheet code in a defined `.qss` file. This helps in
    ensuring the look and feel is maintained across the application in all screens.
    QSS files are analogous to `.css` files, which contain the definitions for the
    look and feel of GUI elements such as color, background color, font, and mouse
    interaction behaviors. They can be created and edited with any text editor. You
    can create a new Style Sheet file with the `.qss` file extension and then add
    it to the resource file (`.qrc`). You may or may not have `.ui` files for all
    projects. The GUI controls can be created dynamically through code. You can apply
    a Style Sheet to a widget or to a whole application, as shown in the following
    code snippet. This is how we do it for a custom widget or form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how we apply it for the whole application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding program illustrates how to use a Style Sheet file for the entire
    Qt GUI application. You need to add the .`qss` file into the resources. Open the
    .`qss` file using `QFile` and pass the customized QSS rules as an argument to
    the `setStyleSheet()` method on the `QApplication` object. You will see all screens
    will have the Style Sheet applied to them.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about customizing the look and feel of an application
    using Style Sheets, but there are more ways to change an application's look and
    feel. These approaches depend on your project need. In the next section, you will
    learn about custom styles.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring custom styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt provides several `QStyle` subclasses that emulate the styles of the different
    platforms supported by Qt. These styles are readily available with the Qt GUI
    module. You can build your own `QStyle` for rendering the Qt widgets to ensure
    their look and feel, as per native widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a Unix distribution, you can get a Windows-style UI for your application
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can set a style on an individual widget using the `QWidget::setStyle()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can customize the look and feel of your GUI by creating a custom style.
    There are two different approaches to creating a custom style. In a static approach,
    you can subclass the `QStyle` class and reimplement virtual functions to deliver
    the desired behavior, or rewrite the `QStyle` class from scratch. `QCommonStyle`
    is generally used as a base class instead of `QStyle`. In a dynamic approach,
    you can subclass `QProxyStyle` and modify the behavior of your system style at
    runtime. You can also develop style-aware custom widgets by using `QStyle` functions
    such as `drawPrimitive()`, `drawItemText()`, and `drawControl()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section is an advanced Qt topic. You need to understand Qt in depth to
    create your own style plugin. You can skip this section if you are a beginner.
    You can learn about the QStyle classes and custom styles in the Qt documentation
    at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doc.qt.io/qt-6/qstyle.html](https://doc.qt.io/qt-6/qstyle.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Using a custom style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several ways to apply a custom style in a Qt application. The easiest
    way is to call the `QApplication::setStyle()` static function before creating
    a `QApplication` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also apply a custom style as a command-line argument, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Custom styles can be difficult to implement but can be faster and more flexible.
    QSS is easy to learn and implement, but the performance may get affected, especially
    at the application launch time, as the QSS parsing may take time. You can choose
    the approach convenient to you or your organization. We have learned how to customize
    the GUI. Now, let's understand what widgets, windows, and dialogs are in the last
    section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using widgets, windows, and dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A widget is a GUI element that can be displayed on the screen. This could include
    labels, push buttons, list views, windows, dialogs, and so on. All widgets display
    certain information to a user on the screen, and most of them allow user interactions
    through the keyboard or mouse.
  prefs: []
  type: TYPE_NORMAL
- en: A window is a top-level widget that doesn't have another parent widget. Generally,
    windows have a title bar and border unless any window flags are specified. The
    window style and certain policies are determined by the underlying windowing system.
    Some of the common window classes in Qt are `QMainWindow`, `QMessageBox`, and
    `QDialog`. A main window usually follows a predefined layout for desktop applications
    that comprises a menu bar, a toolbar, a central widget area, and a status bar.
    `QMainWindow` requires a central widget even if it is just a placeholder. Other
    components can be removed in a main window. *Figure 3.22* illustrates the layout
    structure of `QMainWindow`. We typically call the `show()` method to display a
    widget or main window.
  prefs: []
  type: TYPE_NORMAL
- en: '`QMenuBar` is present at the top of `QMainWindow`. You can add menu options
    such as `QMenuBar`, there is `QToolBar`. `QDockWidget` provides a widget that
    can be docked inside `QMainWindow` or floated as a top-level window. The central
    widget is the primary view area where you can add your form or child widgets.
    Create your own view area with child widgets and then call `setCentralWidget()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.22 – QMainWindow layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.22_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.22 – QMainWindow layout
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '`QMainWindow` shouldn''t be confused with `QWindow`. `QWindow` is a convenient
    class that represents a window in the underlying windowing system. Usually, applications
    use `QWidget` or `QMainWindow` for their UI. However, it is possible to render
    directly to `QWindow`, if you want to keep minimal dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dialogs are temporary windows that are used to provide notifications or receive
    user inputs and usually have `QMessageBox` is a type of dialog that is used to
    show information and alerts or to ask a question to the user. Typically, the `exec()`
    method is used to show a dialog. The dialog is shown as a modal dialog and is
    blocking in nature until the user closes it. A simple message box can be created
    with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The takeaway is that all of these are widgets. Windows are the top-level widgets,
    and dialogs are a special kind of window.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explained the fundamentals of the Qt Widgets module and how to
    create a custom UI. Here, you learned to design and build GUIs with Qt Designer.
    Traditional desktop applications are usually built with Qt Designer. Features
    such as custom widget plugins allow you to create and use your own widget collection
    with Qt Designer. We also discussed customizing the look and feel of your application
    with style sheets and styles, as well as looking at the uses of and differences
    between widgets, windows, and dialogs. Now, you can create a GUI application with
    your own custom widgets with extended functionalities and create your own themes
    for your desktop application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss `QtQuick` and QML. Here, you will learn
    about `QtQuick` controls, Qt Quick Designer, and how to build a custom QML application.
    We will also discuss an alternate option of using Qt Quick for GUI design rather
    than widgets.
  prefs: []
  type: TYPE_NORMAL
