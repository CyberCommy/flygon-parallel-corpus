- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is a monolith?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A monolith is a software application that is created in a single block. This
    application runs as a single process. It can only be deployed in unison, although
    multiple identical copies can be created.
  prefs: []
  type: TYPE_NORMAL
- en: '**What problems can monoliths run into?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As they grow, monoliths can experience the following problems:'
  prefs: []
  type: TYPE_NORMAL
- en: The code becomes too big and difficult to read.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalability problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The need to coordinate deployments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bad usage of resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's not possible to use conflicting technologies for different situations (for
    example, different versions of the same library, or two programming languages).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single bug and deployment can affect the whole system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Can you describe the microservice architecture?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The microservice architecture is a collection of loosely coupled specialized
    services that work in unison to provide a comprehensive service.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the most important property of a microservice?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The most important property of a microservice is that they can be deployed independently
    so that they can be developed independently.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the main challenges that we need to overcome when migrating from
    a monolith to a microservice?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Possible challenges include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Big changes are needed that require us to change the way the services operate,
    including the culture of the teams. This can result in training, which is costly.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging a distributed system is more complicated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to plan changes so that they don't interrupt the service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's a significant amount of overhead for each microservice that's developed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to find a balance between allowing each team to decide how to work and
    standardizing to avoid reinventing the wheel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to document the service so that we can interact with another team.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How can we make such a migration?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to analyze the system, measure, plan accordingly, and execute the plan.
  prefs: []
  type: TYPE_NORMAL
- en: '**Describe how we can use a load balancer to migrate from an old server to
    a new one, without interrupting the system. **'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we have to configure the load balancer so that it points to the old web
    server, which will make the traffic cross through the web server.  Then, we have
    to change the DNS record so that it points to the load balancer. After the traffic
    has gone through the load balancer, we need to create a new entry for the new
    service so that the load balancer splits the traffic between both. After confirming
    that everything works as expected, we need to remove the entry from the old service.
    Now, all the traffic will be routed to the new service.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What are the characteristics of RESTful applications?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While a RESTful application is understood as a web interface that makes URIs
    into object representations and manipulates them through HTTP methods (and normally
    formats the requests with JSON), the textbook characteristics of a REST architecture
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Uniform interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client-server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stateless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cacheable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layered system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code on demand (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find out more about the REST architecture at [https://restfulapi.net/](https://restfulapi.net/).
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the advantages of using Flask-RESTPlus?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Some of the advantages of using Flask-RESTPlus are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Automatic Swagger generation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A framework that can define and parse inputs and marshal outputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows us to structure the code in namespaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What are some alternatives to Flask-RESTPlus?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other alternatives include Flask-RESTful (this is similar to Flask-RESTPlus,
    but it doesn't support Swagger) and the Django REST framework, which has a rich
    ecosystem that's full of third-party extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Name the Python package used through the tests to fix the time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`freezegun`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Describe the authentication flow.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An encoded token is generated by the authentication system (the User Backend).
    This token is encoded with a private key that only the User Backend has. This
    token is encoded in JWT and contains a user ID, as well as other parameters that,
    for example, tell us how long the token is valid for. This token is included in
    the `Authentication` header.
  prefs: []
  type: TYPE_NORMAL
- en: The token is obtained from the header and decoded using the corresponding public
    key, which is stored in the Thoughts Backend. This allows us to obtain the user
    ID independently with the certainty that it has been validated by the User Backend.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why did we choose SQLAlchemy as a database interface?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SQLAlchemy is well supported in Flask and allows us to define already existing
    databases. It is highly configurable and allows us to work at a low level, that
    is, near the underlying SQL, and at a higher level, which removes the need for
    any boilerplate code. In our use case, we inherited a database from the legacy
    system, thereby making the need to work seamlessly with an existing schema a necessity.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What does the FROM keyword do in a Dockerfile?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It starts our image from an existing one, adding more layers to it.
  prefs: []
  type: TYPE_NORMAL
- en: '**How would you start a container with its predefined command?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You would run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Why won''t creating a step to remove files from a Dockerfile create a smaller
    image?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Due to the layered structure of the filesystem that's used by Docker, each step
    in a Docker file creates a new layer. The filesystem is the result of all the
    operations working in tandem. The final image includes all the existing layers;
    adding a layer never reduces the size of the image. A new step for deleting will
    not be present in the final image, but it will always be available as part of
    the previous layer.
  prefs: []
  type: TYPE_NORMAL
- en: '**How does a multistage Dockerfile work?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A multistage Dockerfile contains more than one stage, each of which will start
    with a `FROM` command, which specifies the image that acts as the starting point.
    Data can be generated in one stage and then copied to another.
  prefs: []
  type: TYPE_NORMAL
- en: Multistage builds are useful if we wish to reduce the size of the final images;
    only the resulting data will be copied to the final stage.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the difference between the run and exec commands?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `run` command starts a new container from an image, while the `exec` command
    connects to an already existing running container. Note that if the container
    stops while you are executing it, the session will be closed.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping a container can occur in an `exec` session. The main process that is
    keeping the container running is the `run` command. If you kill the command or
    stop it in any other way, the container will stop and the session will be closed.
  prefs: []
  type: TYPE_NORMAL
- en: '**When should we use the -it flag?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you need to keep a Terminal open, for example, to run `bash` commands interactively.
    Remember the mnemonic *interactive Terminal*.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the alternatives to using uWSGI to serve web Python applications?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any web server that supports the WSGI web protocol can be used as an alternative.
    The most popular alternatives are Gunicorn, which aims to be easy to use and configure, `mod_wsgi`,
    an extension of the popular Apache web server that supports WSGI Python modules,
    and CherryPy, which includes its own web framework.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is docker-compose used for?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`docker-compose` allows for easy orchestration, that is, we can coordinate
    several interconnected Docker containers so that they work in unison. It also
    helps us configure Docker commands since we can use the `docker-compose.yaml`
    file to store the configuration parameters for all the affected containers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Can you describe what a Docker tag is?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A Docker tag is a way of labeling images while keeping their root names. It
    typically marks different versions of the same application or software. By default,
    the `latest` tag will be applied to an image build.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why do we need to push images to a remote registry?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We push images to a remote registry so that we can share images with other systems
    and other developers. Docker builds images locally unless they need to be pushed
    to another repository so that other Docker services can use them.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Does increasing the number of deployments reduce the quality of deployments?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No; it has been shown that increasing the number of deployments has a strong
    correlation with their quality increasing. A system that is capable of deploying
    quickly has to rely on strong automated tests, which increases the stability and
    overall quality of the system.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is a pipeline?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A pipeline is an ordered succession of steps or stages that are used to perform
    a build. If one of the steps fails, the build stops. The order of steps should
    aim to maximize the early detection of problems.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do we know if our main branch can be deployed?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we automatically run our pipeline to generate a build on each commit, we
    should detect problems on the main branch as soon as they are committed. The build
    should assure us that the top commit of the main branch can be deployed. A breakage
    in the main branch should be fixed as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the main configuration source for Travis CI?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `.travis.yml` file, which can be found in the root directory of the repository.
  prefs: []
  type: TYPE_NORMAL
- en: '**By default, when does Travis CI send notification emails?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Travis CI sends notification emails whenever a build breaks and when a previously
    broken branch passes successfully. Successful builds occur when the previous commit
    was successful but not reported.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can we avoid merging a broken branch into our main branch?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can avoid this by configuring in GitHub, which ensures that the branch passes
    the build before we merge it into a protected branch. To ensure that the feature
    branch has not deviated from the main one, we need to force it to merge with a
    build. It needs to be up to date with the main branch for this to happen.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why should we avoid storing secrets in a Git repository?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Due to the way Git works, any secret that's introduced can be retrieved by looking
    at the commit history, even if it's been removed. Since the commit history can
    be replicated in any cloned repository, it makes it impossible for us to verify
    whether it's correct—we can't rewrite the commit history into a cloned repository.
    Secrets should not be stored in Git repositories unless they are properly encrypted.
    Any secret that's stored by mistake should be removed.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is a container orchestrator?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A container orchestrator is a system where we can deploy multiple containers
    that work in unison, as well as manage provisioning and deployment in an ordered
    fashion.
  prefs: []
  type: TYPE_NORMAL
- en: '**In Kubernetes, what is a node?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A node is a physical server or virtual machine that is part of the cluster.
    Nodes can be added or removed from the cluster and Kubernetes will migrate or
    restart the running containers accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the difference between a pod and a container?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A pod can contain several containers that share the same IP. To deploy a container
    in Kubernetes, we need to associate it with a pod.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the difference between a job and a pod?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A pod is expected to run constantly. A job, or cron job, performs a single action,
    and then all the pod containers finish their execution.
  prefs: []
  type: TYPE_NORMAL
- en: '**When should we add an Ingress?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should add an Ingress when we need to be able to access a service externally
    from the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is a namespace?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A namespace is a virtual cluster. All of the definitions that are inside a cluster
    need to have unique names.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can we define a Kubernetes element in a file?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to specify it in YAML format and provide information about its API version,
    the kind of element it is, a metadata section with a name and namespace, and the
    element's definition in a `spec` section.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the difference between the kubectl get and describe commands?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kubectl get` obtains several elements, such as services or pods, and displays
    their basic information. `describe`, on the other hand, accesses a single element
    and presents much more information about it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What does the CrashLoopBackOff error indicate?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This error indicates that a container has finished executing the defined starting
    command. This error only occurs in relation to pods since they're never supposed
    to stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What are the three microservices that we are deploying?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following are the three microservices that we are deploying:'
  prefs: []
  type: TYPE_NORMAL
- en: The Users Backend, which controls authentication and how users are handled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Thoughts Backend, which stores thoughts and allows us to create and search
    for them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Frontend, which provides us with a user interface so that we can interact
    with the system. It calls the other two microservices through RESTful calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Which of the three microservices requires the other two microservices to
    be available?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Frontend calls the other two microservices, so they need to be available
    for the Frontend to work.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why do we need to use external IPs to connect to microservices while they''re
    running in docker-compose?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`docker-compose` creates an internal network for each microservice, so they
    need to communicate using an external IP so that they''re routed properly. While
    we''re exposing ports in the host computer, the external host IP can be used.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the main Kubernetes objects that are required for each application?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each microservice, we provide a deployment (which automatically generates
    a pod), a service, and an Ingress.
  prefs: []
  type: TYPE_NORMAL
- en: '**Are any of the objects not required?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An Ingress for the Users Backend and the Thoughts Backend isn't strictly required
    since they can be accessed through the node port, but it does make accessing them
    easier.
  prefs: []
  type: TYPE_NORMAL
- en: '**Can we detect issues if we scale to more than one pod or any other microservice?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Users Backend and Thoughts Backend creates a pod with two containers, which
    includes the database. If we create multiple pods, we will be creating multiple
    databases, and alternating between them can cause issues.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we create a new thought in one of the pods, we won't be able
    to search for it if the request was made in another pod.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the Frontend can be scaled with no issue.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why are we using the /etc/hosts file?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are using this file so that we can define a `host` that routes to our local
    Kubernetes cluster. This avoids us having to define an FQDN and configure a DNS
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Why shouldn''t we manage our own Kubernetes cluster?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since Kubernetes is an abstraction layer, it is more convenient to have a cloud
    provider take care of maintenance and management, as well as security best practices.
    It's also quite cheap to delegate clusters to an existing commercial cloud provider.
  prefs: []
  type: TYPE_NORMAL
- en: '**Can you name some commercial cloud providers that have a managed Kubernetes
    solution?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Amazon Web Services, Google Cloud Services, Microsoft Azure, Digital Ocean,
    and IBM Cloud are all commercial cloud providers that have a managed Kubernetes
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: '**What action do you need to perform to be able to push to an AWS Docker registry?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You need to log in to your Docker daemon. You can obtain the login command
    by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**What tool do we use to set up an EKS cluster?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`eksctl` allows us to create the whole cluster from the command line, as well
    as scale it up or down as required.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the main changes we made in this chapter so that we could use the
    YAML files from the previous chapters?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We had to change the image definition to be able to use the AWS registries.
    We included the liveness and readiness probes, as well as a deployment strategy.
  prefs: []
  type: TYPE_NORMAL
- en: These are only added to the `frontend` deployment. Adding the rest of the deployments
    is left to you as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: '**Are there any Kubernetes elements that are not required in this cluster?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Ingress element isn't strictly required since the Thoughts Backend and the
    Users Backend can't be accessed externally. The frontend service is capable of
    creating an externally facing ELB.
  prefs: []
  type: TYPE_NORMAL
- en: Don't feel like you're limited by our configuration. You can manually configure
    an ELB so that you can access the cluster in different ways, so you can use the
    Ingress configuration if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why do we need to control the DNS associated with an SSL certificate?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to prove that we own the DNS so that the SSL certificate can verify
    that only legitimate owners of the DNS address have access to a certificate for
    that DNS. This is the root element of HTTPS and states that you are communicating
    privately with the owner of a particular DNS.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the difference between the liveness and the readiness probes?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the readiness probe fails, the pod won't accept requests until it passes
    again. If the liveness probe fails, the container will be restarted.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why are rolling updates important in production environments?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They are important as they avoid interruptions in the service. They add workers
    one by one while removing old ones, ensuring that the number of available workers
    at any time remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the difference between autoscaling pods and nodes?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since nodes are reflected in physical instances, scaling them affects the resources
    that are in the system. Meanwhile, scaling pods uses the resources that are available
    to them, but doesn't modify them.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, increasing the number of nodes we have adds more hardware that
    needs to be run on the system. This has a cost associated with it in that we need
    to hire more hardware from our cloud provider. Increasing the number of pods we
    have doesn't have a cost in terms of hardware, which is why there should be some
    overhead to allow for increases.
  prefs: []
  type: TYPE_NORMAL
- en: Both strategies should be coordinated so that we can react quickly to load increases
    and, at the same time, reduce the amount of hardware that's being utilized so
    that we can reduce costs.
  prefs: []
  type: TYPE_NORMAL
- en: '**In this chapter, we deployed our own database containers. In production,
    this isn''t required. However, if you''re connected to an already existing database,
    how would you do this?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first step would be to change the environment variables in the `thoughts_backend/deployment.yaml` and `users_backend/deployment.yaml` files.
    The main one to connect to is `POSTGRES_HOST`, but the user and password will
    probably have to change as well.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of connecting to `POSTGRES_HOST` as an IP or DNS address directly, we
    could create an internal Kubernetes service called `postgres-db` that points toward
    an external address. This could help us abstract the address of the external database.
  prefs: []
  type: TYPE_NORMAL
- en: This would be deployed in one go to ensure that we can connect to the external
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we can remove the database containers that were described in the deployments,
    that is, `thoughts-backend-db` and `users-backend-db`. The images for these containers
    are only used for testing and development.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is the difference between using a script to push new code to servers
    and using a configuration management tool such as Puppet?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When using a script to push new code to servers, every server needs to have
    the code pushed individually. *Puppet* and other configuration management tools
    have a centralized server that receives new data and distributes it appropriately.
    They also monitor the fact that the servers are running as expected and can perform
    remediation tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management tools are used for big clusters since they reduce the
    amount of work that needs to be handled in custom scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the core idea behind DevOps?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The core idea behind DevOps is to empower teams so that they have control over
    performing their own deployments and their infrastructure. This requires a safety
    network in the form of automated procedures to ensure that these operations are
    easy, safe, and quick to perform.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the advantages of using GitOps?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The main advantages of using GitOps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Git is a common tool that most teams already know how to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It keeps a copy of the infrastructure definition, which means we can use it
    as a backup and recover from catastrophic failures or create a new cluster based
    on a previous definition with ease.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The infrastructure changes are versioned, which means we can make small discrete
    changes one by one and revert any of them if there's a problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Can only GitOps be used in Kubernetes clusters?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Though GitOps does have synergy with Kubernetes, since Kubernetes can be controlled
    by YAML files, there's nothing stopping us from using a Git repository to control
    a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '**Where does the Flux deployment live?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It lives in its own Kubernetes cluster so that it can pull data from Git.
  prefs: []
  type: TYPE_NORMAL
- en: '**What do you need to configure in GitHub so that Flux can access it?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You need to add an SSH key to the deployment keys of the GitHub repository.
    You can obtain an SSH key by calling `fluxctl identity`.
  prefs: []
  type: TYPE_NORMAL
- en: '**When you''re working in production environments, what features that are provided
    by GitHub ensure that we have control over deployments?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to have review and approval before we can merge into the main branch,
    which triggers a deployment. The inclusion of code owners to force approval from
    specific users can help us control delicate areas.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**When new business features are received, what analysis needs to be done in
    a system working under a microservice architecture?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to determine what microservice or microservices the new business feature
    affects. A feature that affects multiple microservices makes its implementation
    more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: '**If a feature requires two or more microservices to be changed, how do we
    decide which should be changed first?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This should be done in a back-to-forward way in order to keep backward compatibility.
    New features should be added while keeping backward compatibility in mind, so
    the possibilities are limited. Once the backend is ready, the frontend can be
    changed accordingly so that we can take advantage of the new feature.
  prefs: []
  type: TYPE_NORMAL
- en: '**How does Kubernetes help us set up multiple environments?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating new namespaces is very easy in Kubernetes. Since the definition of
    the system is encapsulated in YAML files, they can be copied and modified to create
    a duplicate environment. This can be used as a baseline and then evolved.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do code reviews work?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code in one branch is compared with the main branch. Another developer can
    look at the differences between them and make comments, asking for clarification
    or changes. These can then be discussed and then the code can be approved if the
    reviewer thinks it's good enough. The merge can be blocked until it has one or
    more approvals.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the main bottleneck for code reviews?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The main bottleneck is not having a reviewer to provide feedback and approve
    the code. That's why it's important to have enough people that can perform the
    role of a reviewer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Under GitOps principles, are the reviews for deployment different from code
    reviews?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No; under GitOps, the deployments are treated as code, so they can be reviewed
    just like any other code review.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is it important to have a clear path to deployment once a feature is
    ready to be merged into the main branch?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's important to have a clear path to deployment so that everyone is on the
    same page. It also provides a clear expectation of how fast deployments can happen.
    By doing this, we can specify when a review is required.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why are database migrations different from regular code deployments? **'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They are different because they can't be rolled back easily. While a code deployment
    can be rolled back so that the previous image is deployed again, database migrations
    make changes to the schema of the database or data, which may cause data loss
    if they're reverted. Normally, database migrations are forward-only, and any problems
    that occur need to be corrected with a new deployment.
  prefs: []
  type: TYPE_NORMAL
- en: This is the main reason why we have to take extra care with database migrations
    and ensure they are not backward incompatible.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is the observability of a system?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's the capacity of a system. It lets you know what its internal state is.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the different severity levels that are available in logs by default?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order of increasing severity, the different severity levels are `DEBUG`,
    `INFO`, `WARNING`, `ERROR`, and `CRITICAL`.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are metrics used for?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Metrics allow you to find out the aggregated statuses of the events that are
    occurring on the system and allow you to understand the general state of the system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why do you need to add a request ID to the logs?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You need to add a request ID to the logs so that you can group all of the logs
    that correspond to the same request.
  prefs: []
  type: TYPE_NORMAL
- en: '**What kinds of metrics are available in Prometheus?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Counters, which count a particular event; gauges, which keep track of a value
    that can go either up or down; and histograms (or summaries), which track events
    with a value associated with them, such as the times that events occur or when
    the status codes of requests are being returned.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the 75th percentile in a metric and how is it different from the
    average? **'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For histograms, the *75^(th)* percentile is where *25%* of the events are higher
    than the average, while *75%* are lower than it. The average is found by adding
    all of the values together and dividing that value by the number of values that
    were added together initially. Typically, the average will be close to the 50th
    percentile, although this depends on how the values are distributed.
  prefs: []
  type: TYPE_NORMAL
- en: The *90^(th)*-*95^(th)* percentile is good if we wish to determine latency since
    it provides upper times for requests, not counting outliers. The average can be
    skewed by outliers and thus not provide a realistic number for the vast majority
    of requests.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the four golden signals?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The four golden signals are four measurements that gather a description of a
    system's health. They are the latency of requests, the amount of traffic, the
    percentage of returned errors, and the saturation of resources.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What are the differences between releasing changes in a microservice architecture
    system and a monolith?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Releasing a change in a monolith will only involve one repository since the
    monolith is only one code base. Some changes that are made in a microservice architecture
    will need us to change two or more microservices so that we can allocate them.
    This requires more planning and care since we need to ensure that this is properly
    coordinated. In a properly architecture microservice system, such multirepository
    changes should be relatively rare since they incur overhead.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why should release changes be small in a microservice architecture?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The advantage of microservices is that we can release microservices in parallel,
    which is quicker than a monolith release. However, given that a release in a microservice
    could potentially affect other microservices, they should work in an iterative
    way, reducing the size of the changes and increasing their rate of deployment.
  prefs: []
  type: TYPE_NORMAL
- en: A small change is less risky and easier to roll back if that's required.
  prefs: []
  type: TYPE_NORMAL
- en: '**How does semantic versioning work?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In semantic versioning, versions have three numbers: a *Major* version number,
    a *Minor* version number, and a *Patch* version number. These are all separated
    by dots:'
  prefs: []
  type: TYPE_NORMAL
- en: An increase in a Patch version only fixes bugs and security problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An increase in a Minor version adds more features, but without backward-incompatible
    changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An increase in a Major version produces backward-incompatible changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What are the problems with semantic versioning for internal interfaces in
    a microservice architecture system?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since deployments in microservices are very common, and backward compatibility
    is very important, the meaning of a *major* release becomes diluted. Also, most
    of the consumers of the microservices are internal, so implicit communication
    between versions is less important.
  prefs: []
  type: TYPE_NORMAL
- en: When releases become common, semantic versioning loses meaning since the objective
    is to continuously refine and improve the product, instead of marking big releases.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the advantages of adding a version endpoint?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Any consumer that uses a microservice can request its version in the same way
    they can make any other request: by using a RESTful call.'
  prefs: []
  type: TYPE_NORMAL
- en: '**How can we fix the dependency problem in this chapter''s code?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code in this chapter has a dependency problem between TO BE FILLED.
  prefs: []
  type: TYPE_NORMAL
- en: '**What configuration variables should we store in a shared ConfigMap?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should store the configuration variables that are accessed by multiple microservices.
    Preemptively, we should store most of the configuration variables so that they
    can be reused.
  prefs: []
  type: TYPE_NORMAL
- en: '**Describe the advantages and disadvantages of putting all the configuration
    variables into a single shared ConfigMap.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A single shared ConfigMap makes the configuration variables very explicit. It
    encourages everyone to reuse them and tell others what the configuration is used
    for in other microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the dependency of a microservice will trigger a restart, so changing
    a ConfigMap that acts as a dependency for everything will cause all the microservices
    in the cluster to restart, which is time-consuming.
  prefs: []
  type: TYPE_NORMAL
- en: Also, a single ConfigMap file can end up being quite big, and splitting it into
    several smaller ones can help us organize the data more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: '**What''s the difference between a Kubernetes ConfigMap and a Kubernetes Secret?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kubernetes Secrets are better protected against unintentional access. The direct
    access tools won't display the Secret in plain text. Access to Secrets also needs
    to be configured in a more explicit way. On the other hand, ConfigMaps can be
    configured in bulk, so a pod will be able to access all of the values that have
    been stored in the ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can we change a Kubernetes Secret?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can change a Secret using `kubectl edit`, but it will need to be encoded
    in Base64 format.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to replace the `postgres-password` secret with the `someotherpassword` value,
    we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once restarted, our pods will be able to use the new Secret.
  prefs: []
  type: TYPE_NORMAL
- en: '**Imagine that, based on our configuration, we decided to change public_key.pub from
    a Secret to a ConfigMap. What changes do we have to make?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to change the ConfigMap so that it includes the file in `configuration.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note the indentation to delimitate the file. The `|` char marks a multiline
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `deployment.yaml` file, we need to change the source of the mount
    from a Secret to a ConfigMap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Remember to apply these changes to the ConfigMap first so that they are available
    when the deployment files are applied.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this method creates an environment variable called `public_key.pub`,
    along with the content of the file, since it is applied as part of the `shared-config`
    ConfigMap. An alternative is to create an independent ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: The Secret can be deleted after all the pods have been restarted.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Why is a leading architect convenient for a microservice architecture system?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Structuring a system in a microservice architecture allows us to create independent
    services that can be handled in parallel. These services still need to communicate
    with each other and cooperate.
  prefs: []
  type: TYPE_NORMAL
- en: Independent teams usually don't have a grasp of the big picture and tend to
    focus on their own projects. To help with the coordination and evolution of the
    system as a whole, independent teams need a leading architect who has a high-level
    overview of the system.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is Conway''s Law?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conway's Law is an adage that says that software structures replicate the communication
    structures of the organization that writes it.
  prefs: []
  type: TYPE_NORMAL
- en: This implies that, to change the way the software is structured, the organization needs
    to change, which is a much more difficult task.
  prefs: []
  type: TYPE_NORMAL
- en: To successfully design and evolve big systems, the organization needs to be
    taken into account and planned accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '**How is technical debt introduced?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are a lot of ways in which technical debt can be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, technical debt falls into one of the following four categories or
    a mix of them:'
  prefs: []
  type: TYPE_NORMAL
- en: By developing too quickly without taking the time to analyze other options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By making a compromise to shorten development time while knowing that the comprise
    will need to be fixed later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By not having a good enough understanding of the current system or tools, or
    having a lack of training or expertise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By making incorrect assumptions regarding an external problem, thereby designing
    for something that doesn't necessarily need to be fixed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Why is it important to create a culture so that we can work continuously
    to reduce technical debt?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's important to create a culture so that we can avoid *software rot*, which
    is the continuous decay of performance and reliability due to adding complexity
    to existing software. Unless addressing technical debt becomes a continuous process,
    the day-to-day pressure of making new releases means we won't be able to perform
    maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is it important to document problems in releases and share them with
    the rest of the team?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is important since every team can learn from the experience and solutions
    of others and improve their processes. This can also create an open culture where
    people aren't afraid of taking responsibility for their mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the main objective of a post-mortem meeting?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The main objective of a post-mortem meeting is to create follow-up tasks that
    fix the causes of an incident. To do so, we need to be as confident as possible
    that the root cause has been successfully detected (this is also the secondary
    objective).
  prefs: []
  type: TYPE_NORMAL
