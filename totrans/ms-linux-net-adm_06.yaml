- en: Chapter 6. Configuring Network Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've configured our nodes and allowed them to actually talk to one
    another. We can access our nodes to administer them remotely, transfer files between
    them, monitor their resources, and perform basic networking. In this chapter,
    we'll design the IP address scheme we'll use for our network, as well as set up
    the required services for putting the plan into action. This will include a discussion
    on setting up and configuring **Dynamic Host Control Protocol** (**DHCP**), **Domain
    Name Service**, as well as **Network Time Protocol** (**NTP**).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Planning your IP address layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and configuring a DHCP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and configuring a DNS server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an internal NTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning your IP address layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taking the time to come up with a great plan before implementing anything on
    your network is a great idea, but your IP address scheme is especially important.
    It's all too easy to accept defaults and get everyone up and running quickly.
    For some small companies, the default IP address layout that ships with your router
    (or whichever device handles DHCP by default) may suffice. But further down the
    road, it needs to change as companies grow. Being prepared for potential growth
    is critical. Implementing an IP address scheme is easy, but changing this scheme
    on a network that's already been rolled out is a great challenge. Always take
    the time to plan accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The first consideration for determining your IP address scheme is what types
    of machines you'll need to provide addresses to. Often, you'll have servers, workstations,
    and printers to deal with. But nowadays, we also have other devices on our network
    such as IP phones, company-issued phones, conference systems, tablets, and more.
    When you start to add all these devices together, a typical 24-bit network with
    254 usable addresses doesn't seem to be all that large, even for a small company.
    Worse, some devices (such as laptops) have multiple network interface cards. If
    you put all that together, you'll find that those 254 addresses can get used up
    really quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Having multiple subnets would certainly help. With subnetting, you can create
    individual networks for each type of service, each with their own set of IP addresses.
    You can, for example, have your servers on one subnet, printers on another, and
    end-user workstations on their own. Instead of having to split a single 24-bit
    subnet between these three types of devices, you can spread them out over several
    networks. We will cover subnetting in more detail in [Chapter 8](ch08.html "Chapter 8. Understanding
    Advanced Networking Concepts"), *Understanding Advanced Networking Concepts*,
    but for now segregating your network is almost always a good idea, for reasons
    even beyond IP addressing.
  prefs: []
  type: TYPE_NORMAL
- en: Another factor to take into consideration is limiting your **broadcast domain**.
    A single 24-bit network (which is often the default on network devices out of
    the box) is a single broadcast domain. In a nutshell, one device can talk to another
    device on your network without being routed first and share the same broadcast
    domain. If you only have a few devices, this doesn't really matter (unless one
    device handles a ridiculously large amount of traffic). But in most networks,
    breaking up your broadcast domain enhances performance. If you have a router separating
    your subnets, you are effectively breaking up your broadcast domain. Thus, it
    would be more difficult for a single node to saturate your network if it is on
    its own subnet. However, no solution is perfect and individual broadcast domains
    can become saturated.
  prefs: []
  type: TYPE_NORMAL
- en: 'One useful tool that you can use when planning your IP scheme is the `ipcalc`
    utility. The `ipcalc` utility can help you understand how many IP addresses you
    will be able to have available with each scheme. This utility is available via
    `apt-get` in Debian, and it doesn''t need any extra repositories. While there
    is an `ipcalc` command built into CentOS, it''s not the same thing and it''s not
    useful. If possible, I would stick to the Debian version. To use it, simply execute
    `ipcalc` along with a network you are thinking about using. For example, you could
    run the following as a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![Planning your IP address layout](img/B03919_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: ipcalc showing subnet information for a 10.10.9.60/22 internal network
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we can see that if we chose a `10.10.96.0/22` scheme,
    we would have `1022` allowable IP addresses, a subnet mask of `255.255.252.0`
    and this would be a class A private network. While you'll learn more about subnetting
    later in this book, the `ipcalc` utility will be handy for you to play around
    with and determine how specific IP layouts would look.
  prefs: []
  type: TYPE_NORMAL
- en: Another topic that's worth bringing up in IP addressing is IPv4 versus IPv6\.
    For quite a long time, IPv4 has been sufficient for everyone's needs. Unfortunately,
    the time has come where IPv4 addresses on the public Internet are starting to
    run out (and in many situations, already has). The benefit of IPv6 is that there
    are so many IP addresses available; it's completely inconceivable that we would
    ever run out again. There is also a security benefit to IPv6, since the address
    space is so large that targets are abstracted (in essence, security through obscurity).
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, you might be tempted to roll-out IPv6 addresses over IPv4
    within your network. However, my suggestion is unless you have a very good reason
    to do so, don't bother. The depletion of IPv4 addresses only affects the public
    Internet, not your internal network. While you can certainly roll-out IPv6 internally,
    there's no benefit to doing so. Given that IPv4 has over 4 billion addresses available,
    you would need quite a few devices in order to justify IPv6\. On the other hand,
    IPv6 is certainly useful (and will eventually be required) for telecoms. It's
    also useful for those of you who are studying Cisco exams, as understanding of
    this topic is required. But for the purposes of this book and setting up Linux
    networks, IPv6 doesn't justify the administration overhead.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, it's important to plan ahead. IPv4 is good enough for our needs
    and splitting our network into subnets is a good idea (even if you think your
    network will never surpass 254 addresses). Plan big; even in the worst-case scenario,
    you may never use all the IP addresses you configured. But even if you don't plan
    on using a large number of IP addresses, having them available in case you wish
    to grow your network is a good idea and much easier to implement later. In my
    experience, I've actually had the task of reconfiguring a company network that
    wasn't designed for growth. While it was definitely a learning experience, it
    wasn't an enjoyable one.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring a DHCP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we talked about creating a layout for your network.
    In this section, we'll put that plan in action. Here, we'll set up a DHCP server
    on either a Debian or CentOS machine, and configure it to serve IPv4 addresses
    to our network. So, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: First, decide on which distribution will run your DHCP server. It doesn't matter
    if you choose Debian, CentOS, or a derivative. The configuration is the same on
    each, with the main difference being the name of the package that you'll need
    to install and the daemon to start up. With Debian, you'll install the `isc-dhcp-server`
    package, and you'll install `dhcp` for CentOS. Debian will enable the DHCP daemon
    (`isc-dhcp-server`) for you, but it won't start up because we haven't configured
    it yet. CentOS will not attempt to start or enable its DHCP daemon (`dhcpd`).
  prefs: []
  type: TYPE_NORMAL
- en: For both Debian and CentOS, the configuration file we'll need to edit is located
    at `/etc/dhcp/dhcpd.conf`. In order to set up our DHCP server, we'll need to edit
    this file and then start or restart the daemon. Go ahead and open this file with
    your favorite text editor. If you installed your DHCP server on Debian, you'll
    notice you're provided with a default `/etc/dhcp/dhcpd.conf` file that contains
    a fair amount of example configuration. CentOS, on the other hand, pretty much
    gives you a blank file to work with. For our purposes, we'll create some configuration
    from scratch. You can either remove or back up the default configuration file
    in the case of Debian.
  prefs: []
  type: TYPE_NORMAL
- en: What follows is an example configuration `/etc/dhcp/dhcpd.conf` file for DHCP.
    In this example, we're using the same network as identified earlier while demonstrating
    the `ipcalc` utility (`10.10.96.0/22`). This network gives us several subnets
    to use, but you don't have to go ahead with this scheme; feel free to adjust accordingly
    to fit your environment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, let's go through this configuration line by line.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're identifying how long we would like a DHCP lease to last for. In
    practice, when a node requests an IP address, its client will be given a lease
    along with the IP address. This means that the IP address is only valid for a
    particular period of time. Here, we're setting a lease time of `86400`, which
    means our lease time is one day since this is referenced in seconds. We have this
    number listed twice, in the default and maximum lease times. The `default-lease-time`
    is given to any client if it doesn't specify a particular amount of time it is
    requesting the hold onto the IP address for. The `max-lease-time` means that if
    the client requests to hold onto the IP address for longer than this period, it
    won't be allowed to do so. We're basically setting the default and the maximum
    lease time to the same number. If we wanted to, we could have also included `min-lease-time`
    to enforce a minimum lease time in case a client asks for less.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With this section, we're setting the subnet mask that will be given to clients
    as well as the broadcast address. As you probably already know, the subnet mask
    identifies the network that each connecting node will be a part of. When clients
    check their IP info after being provided an address, the subnet mask we identify
    will be shown. The broadcast address is an address on which all nodes within this
    subnet would be able to receive packets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're appending the domain name of `local.lan` to the hostnames of each
    node that connect to our DHCP server. This step isn't required by any means, but
    can be useful if normalizing domain names within your network. We also include
    `authoritative` in our configuration to establish that our DHCP server is the
    primary one for this subnet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have a very important block of code at the end. Here, we identify
    the network address for our subnet, its subnet mask, the range of IP addresses
    we''re issuing, the default gateway, and our DNS server. In this example, we''re
    starting our first DHCP-issued address at `10.10.99.100` and ending our pool at
    `10.10.99.254`. If you recall the output of `ipcalc` earlier, you''d notice that
    the first address in this subnet begins at `10.10.96.1`. Instead of starting our
    pool there, we''re starting our pool much later. For the sake of reference, we
    used the `10.10.96.0/22` network, which gives us the following subnets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If we wanted to, we could set our DHCP range to begin at `10.10.96.1` and end
    at `10.10.99.254`. We would have 1,022 DHCP addresses in that case. However, the
    reason I didn't do that in my configuration is because the first three networks
    have been reserved for several purposes. I use the first (`10.10.96.0/22`) for
    servers, the next for DHCP reservations, and the third for network appliances.
    Since the first three subnets are outside the DHCP range, the DHCP server will
    never offer any of those addresses to clients, so I don't have to worry about
    a DHCP lease tackling a static address I may have set up. It's a very common practice
    to ensure that static IP addresses are outside the DHCP range.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be fair, this configuration is fairly complicated, as I''m showing you how
    to use multiple subnets with DHCP rather than focusing on just one network. To
    simplify a bit, if we were setting up a default 24-bit network, our configuration
    would look like the following (if we were using a `10.10.10.0/24` network):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With this configuration, I'm setting the DHCP range to start at `10.10.10.10`
    and end at `10.10.10.254`. This gives me nine IP addresses (`10.10.10.1`—`10.10.10.9`)
    that will never be assigned, so I have room to set up a few static IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: So, I mentioned *static IP addresses* a few times here. You probably already
    know what that means, but it's important to elaborate that static IP addresses
    are a great idea for servers. These are addresses that are reserved for certain
    servers or nodes, where you expect them to have the same IP address each time.
    This is probably a no-brainer if you've ever configured a network before. There's
    also the concept of a static lease that's important as well. A static lease is
    also known as a **reservation**. With a static lease, the IP address is still
    provided by the DHCP server, and the client still uses DHCP to request an address.
    The difference is that the client will receive the same address, each and every
    time it connects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up static leases is very easy. Reservations can be placed at the end
    of your `/etc/dhcp/dhcpd.conf` file. Here''s an example to show what the syntax
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a host named `bahamut` with a MAC address `28:B2:BD:05:1E:00`.
    The name is arbitrary; it has no actual meaning other than for us to remember
    which host the reservation is for. It doesn't have to match the hostname of the
    device that's requesting an IP. The two lines within the block of code simply
    mean that any time a network card connects to the DHCP server with a MAC address
    `28:B2:BD:05:1E:00`, it needs to be provided an IP address of `10.10.97.4`. We
    can add as many similar code blocks as we'd like for as many static leases we
    wish to assign.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering, when should you use a static IP and when should you
    use a static lease? In my opinion, use static leases whenever it makes sense and
    fits the design of your network. With static leases, you only need to check the
    `/etc/dhcp/dhcpd.conf` file whenever you'd like to see an overview of all your
    reservations. In addition, the host will always receive the same IP address, even
    if you reinstall the OS or boot it from a live install image. There's nothing
    you need to configure on the host itself for a static lease. Generally, static
    leases are easier to manage. Of course, your own preferences will supersede this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in order for our DHCP server to run properly, it must be started and
    configured to run at boot. Debian already took care of enabling the daemon, so
    you would just need to restart it for our configuration to take affect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For CentOS, we need to enable and start the service manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, configuring a DHCP server on Linux is fairly easy and straightforward.
    Of course, there are advanced usage scenarios and a plethora of additional options.
    But for most purposes, a configuration such as the one outlined here should suffice.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring a DNS server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Domain Name System** (**DNS**) makes navigating networked resources much
    easier. Unless you have a very small network, it''s unlikely that you''ll remember
    which IP addresses belong to which machines. DNS helps by mapping names to IP
    addresses, so you can refer to computers by their hostname and DNS will do the
    work of translating that back to the IP address.'
  prefs: []
  type: TYPE_NORMAL
- en: DNS is one of those things that virtually everyone with a network connected
    device uses all the time, regardless of whether or not the user realizes it. Computers,
    servers, smart phones, tablets, smart appliances, and more all utilize DNS. Whenever
    you look up a service on the Internet, such as a website or a remote resource,
    DNS translates the name of the resource to the IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Though the idea of DNS and what it does for us may be common knowledge, it's
    one of those things that are easy to take for granted. DNS is one of those mythical
    things that works in the background and makes our lives much easier. Most of us
    use it, but very few of us actually understand how it works. Whenever you connect
    to an **Internet Service Provider** (**ISP**), you're typically assigned a DNS
    server or two that you will use for your connection. The cleverer users out there
    will often bypass the ISP assigned DNS servers, to third-party servers such as
    those used by Google or OpenDNS in an attempt to squeeze additional performance.
  prefs: []
  type: TYPE_NORMAL
- en: DNS can also prove useful within your internal network as well. Most companies
    with more than a handful of workstations will set up DNS, and rightfully so. It
    makes navigating your network a cinch. For example, it's easier to refer to your
    local color printer as `hp-color-01` than it would be to remember an IP address,
    such as `10.19.89.40`. In this case, adding the printer would be easy. Just have
    your operating system browse to it by name. Any resource on your network can be
    named and creating a consistent and predictable naming scheme for all your networked
    resources is a great idea. So, let's do exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: As is typical, the naming of the required packages is a bit different on Debian-based
    distributions than CentOS. In Debian, the package you'll want to install is `bind9`.
    CentOS simply calls their `bind`. If you were wondering, **BIND** stands for **Berkeley
    Internet Name Domain** (named after where it was developed, namely the University
    of California at Berkeley). This is the most popular name server on the Internet,
    so you'll definitely want to familiarize yourself with it. While you're at it,
    I recommend installing `bind-utils` if you are running through this activity on
    a CentOS system. This gives us the `dig` command, which will be useful for our
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to install the required package on your server, and then
    all you''ll need to do is start it and ensure that it''s enabled to run at startup.
    Debian already takes care of starting the daemon and enabling it for us. You can
    confirm this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'CentOS doesn''t configure the `bind` daemon to autostart, and it does not start
    it up for you. If CentOS is your distribution of choice, you''ll want to execute
    the following command to enable `bind` and start it up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With this done, you actually have a working DNS server. Of course, we didn't
    configure anything, so our DNS server is not actually doing much for us. But now
    that we have it installed, we can add records to it and build our configuration.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's take a look at the default configuration file. Debian stores the
    default configuration file for bind at `/etc/bind/named.conf`. CentOS stores theirs
    at `/etc/named.conf` (it doesn't have its own directory). Go ahead and take a
    gander at this file to get a feel for how the configuration works. We're going
    to use our own configuration file, so I recommend you to back up the default files
    and we'll install our own.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a fresh `named.conf` file in our distribution''s default
    directory (`/etc/bind/named.conf` in Debian and `/etc/named.conf` in CentOS).
    Regardless of which distribution you''re using, we''ll make the file the same.
    If this file already has text in it, copy it to a backup or empty it, as the following
    two lines are the only text we need in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re going to include two additional files (which we will create, very
    soon). As you can see, our `named.conf` file is simply calling these files and
    contains no other configuration. This way, we can create our own standard place
    to find these files. `/etc/bind` is already the default location in Debian, but
    by calling out this directory in CentOS, we can force it to look for the configuration
    in the same place. But with CentOS, you''ll need to create the `/etc/bind` directory.
    The command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create our `/etc/bind/named.conf.options` file and customize it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're creating an options block with some code sandwiched in between curly
    braces, which then includes an additional set of curly braces where we identify
    our forwarding addresses. Since this DNS server is for locating resources within
    our internal network, the forwarders block tells our DNS server where to send
    requests, should it be unable to find what it's looking for locally. Your DNS
    server will likely still function perfectly fine without this, as in most cases
    it will still attempt another DNS server further down the chain. But setting the
    forwarders here allows us to force where we would like DNS lookups to go, in case
    we're looking for something externally. In this sample, I'm using Google's public
    DNS servers. However, you can choose your own. Some additional DNS servers (which
    are typically better) can be found at [www.opennicproject.org](http://www.opennicproject.org),
    which is also a good choice if you're concerned about privacy or tracking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next file is `/etc/bind/named.conf.local`, which contains the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this file, we start of by identifying our domain name. Here, I chose `local.lan`.
    As this server is not authoritative of anything on the Internet, this name works
    well. Within this block, we're calling out another file, `/etc/bind/net.local.lan`.
    In fact, as you can see, there are several files being called out here (five in
    total). The first is our main DNS zone, and it's the most important of these.
    Those that follow are where we configure reverse DNS lookups. Essentially, DNS
    allows us to not only map hostnames to IP addresses, but we can also do the reverse
    (look map IP addresses back to hostnames). You may not need all the files that
    I created in my example. With mine, I am creating a reverse lookup file for each
    of my four subnets. If you aren't creating multiple subnets, you'll only need
    to create one. The naming convention of these is `revp`, followed by the network
    portion of the IP address. So, for example, the reverse lookup file for my `10.10.99.0`
    network is `revp.10.10.99`. These files will also be stored in `/etc/bind` as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at our master record, the `/etc/bind/net.local.lan`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'First, I placed some generic comments, with lines beginning with a semicolon.
    If a line begins with a semicolon, it is ignored by `bind`. Comments can be a
    good method of leaving notes or facts regarding the configuration. However, comments
    aren''t used very often in `bind`. Next, we set our **Time To Live** (**TTL**)
    to one day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This value governs how long other DNS servers would be able to cache each record.
    After this period, any servers that have cached one of these records must discard
    them. For the purposes of setting up an internal DNS server, this value doesn''t
    affect us a great deal. However, if you''re setting up multiple DNS servers, this
    might be an important value to configure. One example of where the TTL value might
    prove useful is changing an address record to a different IP address. Suppose
    you''re switching your e-mail host to another provider. In that case, you would
    change the address record accordingly. However, before you enact this change,
    you may lower your TTL to something much less, such as one hour, and do this before
    you make this change. Then, servers are forced to discard this zone and refresh
    it, causing it to see your change in e-mail providers much quicker. When you are
    done, you would change this back. With the following line, we are identifying
    a **Start of Authority** (**SOA**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we are identifying that this DNS server has the authority for
    the `local.lan` domain. We also clarify that `hostmaster.local.lan` is responsible
    for it. Although it may not look like it, `hostmaster.local.lan` is actually an
    e-mail address in the format that bind prefers. However, this is obviously a fake
    address, which doesn''t matter for our internal DNS server. At the end of this
    line, we are opening a configuration block, in this case with an opening parenthesis.
    The following line represents our serial, and it''s a very important concept to
    understand in order for our DNS server to work properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Each time our `bind` daemon is restarted, it will reload this file. But when
    it does, the serial number is the first thing it will look at. If it is the same,
    it will likely not load in any changes. Thus, every time you change a zone file
    in `bind`, you must change this serial number as well. In this example, the current
    date is being used without hyphens or spaces. The last digit is just a revision
    number for that day, if the file is changed multiple times in one day. You can
    use whatever scheme you'd like. But using the date is a very popular approach.
    Regardless of the format you use, always ensure you increment the serial by 1
    with every change you make. You'll save yourself frustration wondering why newly
    created records aren't taking affect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: These values dictate how often slave DNS servers will be told to check for updates.
    The first value will configure slaves to refresh zone records from the master
    (this server) every eight hours. In regards to retry, we're letting slaves know
    that should there be a problem connecting, check back in this amount of time.
    Finally, we're setting our minimum age of zone records to one day, and the maximum
    to four weeks. Configuring slave DNS servers is beyond the scope of this book,
    but having this configuration in place doesn't hurt anything in case you do decide
    to configure slave DNS servers later on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're identifying this name server. In my case, I'm calling it `hermes`
    and its full domain name is `hermes.local.lan`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in this sample configuration, four address records are called out.
    This basically means that any time someone is looking for one of these hosts,
    the request is mapped to the listed domain name. These can be among multiple subnets
    or a single subnet. In my case, these hosts are on different subnets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The final line of this configuration contains a **Canonical Name** (**CNAME**)
    record. Basically, this allows us to refer to a server by another name. In this
    example, `galaxy` is also used for software known as `puppet`, so a CNAME record
    has been set up for it. This way, if someone were to try to access `galaxy.local.lan`
    or `puppet.local.lan`, their request would resolve to the same IP address (`10.10.96.4`).
    A CNAME records can be very useful if a single server provides more than one service
    to the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, I called out four reverse lookup records, `/etc/bind/revp.10.10.96`,
    `/etc/bind/revp.10.10.97`, `/etc/bind/revp.10.10.98`, and `revp.10.10.99`. Next,
    I''m going to demonstrate one of these files (in this case, for the `10.10.96.0`
    network):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: With this configuration, you'll notice we have a *start of authority* record
    as with our master zone, and we also have a serial number. The same idea applies
    here. Whenever you update any record (including reverse lookup records), you should
    update the serial number of the file. The start of authority entry works the same
    as earlier, no surprises here. Where the file differs is how the hosts are called
    out. Rather than calling out an entire IP address, we only need to identify the
    last octet since the entire file is dedicated to reverse IP address lookups from
    the `10.10.96.0` network. For each of your subnets, you'll need to create a similar
    file. Again, in our sample configuration there are four subnets, but you don't
    need that many. It was only provided in this way in order to provide an example
    of how to handle separate subnets, should you need to do so.
  prefs: []
  type: TYPE_NORMAL
- en: With our configuration in place, feel free to restart the bind service on your
    DNS server and test it out. We can restart `bind` with the `systemctl` command,
    as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Debian, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For CentOS, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'One way we can test our DNS server is via the `dig` command. With Debian, you
    should already have this package installed. CentOS requires the installation of
    the `bind-utils` package. `dig` (domain information groper) is a utility that
    allows us to request information from a DNS server. To give it a shot, try it
    out with an internal hostname:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If your DNS server comes up under `SERVER` in the output, then your DNS server
    is functioning properly. If for some reason it doesn't, verify what you've typed,
    your serial number, and whether or not you have restarted `bind` since your last
    configuration change.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to practice setting up additional nodes and records within your DNS
    server. Setting up `bind` can be frustrating at first, but stick with it and you'll
    be a pro in no time. Using examples from this section, you should have a working
    skeleton you can use to set up a DNS server within your environment. Make sure
    that you change the hostnames and IP addresses contained within the configuration
    files to those that match your network. In addition, make sure you set up `bind`
    to match your subnets, or remove mentions of other subnets if you don't have any.
    To be safe, instead of copying the configuration directly from this book, it's
    usually better to type everything manually just in case.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an internal NTP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most Linux distributions offer a **Network Time Protocol** (**NTP**) client
    that can be used to keep your local time up to date. The idea is that with an
    NTP client configured, your computer or server will periodically check in with
    an NTP server somewhere on the Internet and synchronize its clock to ensure it
    is as exact as possible. This is really important; very strange things can happen
    on Linux machines if the clock is off. These oddities can include things such
    as a node being unable to associate with a DHCP server to obtain an IP address,
    files becoming unsynchronized between file servers, and more. The moral of the
    story is this: you''ll want to have NTP set up and working in your environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Quite a few Linux distributions that are targeted toward end-user workstations
    (such as Ubuntu, Linux Mint, and so on) will often set up an NTP client for you.
    This means that out of the box, there's a good chance that your clock is probably
    synchronized already, assuming of course your installation has access to the Internet.
    By default, these clients will connect to a distribution-specific NTP server.
    This can be perfectly fine, but setting up your own NTP server instead has merit.
    One good reason for this is that by setting up your own NTP server, you're being
    a good network citizen. Think about it this way. If you have a company with a
    hundred Linux machines, each of those machines will be checking in with a public
    NTP server periodically if left with the default configuration. This causes unnecessary
    strain on that server. If you set up your own NTP server, only one of your servers
    will be checking in with the public server, which means you'd be absorbing fewer
    of its resources. In addition, some companies do not allow public access to **port
    123** (the port NTP uses) for security reasons. However, perhaps a single NTP
    server would be allowed to access port 123, which you can then configure your
    clients to connect to and use NTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into setting up an NTP server, it''s important to note that Debian
    and CentOS can often be the exception as to having an NTP client installed out
    of the box. Depending on the options and packages you selected during installation,
    the NTP client may or may not be functional yet. In my test environment, neither
    CentOS nor Debian had a working NTP client by default when I installed via a minimal
    installation and a net installation, respectively. However, setting up an NTP
    client is extremely easy. All you have to do is install NTP and enable it. This
    is actually one of those rare cases when both Debian and CentOS have the same
    name for the same package. The package is simply called `ntp`, so go ahead and
    install it if you don''t already have it installed. Once installed, Debian will
    start the `ntp` daemon and enable it for you. With CentOS, execute the following
    commands to get it going:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With both distributions, the file `/etc/ntp.conf` will be created once the package
    is installed, and this file will have a default configuration that will point
    your NTP client to your distribution's NTP server. Feel free to take a quick look
    at this file, if you're curious about what it looks like. To view which server
    your machine is synchronizing with, along with some stats regarding its synchronization,
    execute the `ntpq -p` command.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up an internal NTP server](img/B03919_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Viewing connected NTP servers
  prefs: []
  type: TYPE_NORMAL
- en: First, let's take a quick look at what these numbers mean. The first column
    `remote` includes a list of NTP servers we're connected to, no surprises there.
    Next is `refid`, which is where those servers are connected to. The `st` column
    refers to the **stratum** of that server, which is a number that refers to the
    layer on which that time server sits. Typically, the lower the number, the better
    it is; as it means that the server is reasonably close to the source that is providing
    it time. Each server down the chain has an increased stratum; lowest doesn't always
    mean that the server is better, but generally speaking, lower numbers are good.
    The `t` column refers to the type. This can be unicast, broadcast, multicast,
    or manycast. In this case, we have `u` for unicast.
  prefs: []
  type: TYPE_NORMAL
- en: The `when` column refers to how long ago the server was last polled. In the
    case of the sample screenshot, each server was polled 28, 24, 21 and 61 seconds
    ago, respectively. This can also be listed in hours or days as well. The `poll`
    column refers to the polling frequency, which here is set to poll every 64 seconds.
    The `reach` column is an octal number, which contains the results of the most
    recent eight NTP updates. If all eight were successful, this value will read 377,
    which is as high as it can get. This means that all eight attempts received a
    1 (success) which in octal, totals 377.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing up, the `delay` field references the delay (in milliseconds) to the
    NTP server. The `offset` field corresponds to the difference between the local
    clock and the clock of the server. Finally, `jitter` refers to the network latency
    between you and the server.
  prefs: []
  type: TYPE_NORMAL
- en: In order to set up an NTP server, you must first install the client as was mentioned
    earlier in this chapter. Install it, configure the daemon to automatically start,
    and then start it up. After performing those tasks, you're already most of the
    way there (the same client is used for the server as well). Essentially, if you
    point your other computers to a server which has NTP installed and configured,
    you essentially have everything you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are a few things that should be configured first. Mainly, the
    `/etc/ntp.conf` configuration file. This file is located in the same place on
    both Debian and CentOS. If you look at the file, you''ll see some lines that look
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see that by default, CentOS is identifying four NTP servers to
    synchronize with. These servers are generally fine for most use cases, but you
    may want to consider official NTP servers. To do so, check out the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.pool.ntp.org](http://www.pool.ntp.org)'
  prefs: []
  type: TYPE_NORMAL
- en: 'That website will allow you to view official NTP servers from the NTP Pool
    Project. To navigate, select your continent on the right and then your country.
    You should then see a list of NTP servers you can use. In my case, I get the following
    details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s up to you whether you use the NTP servers provided by your distribution
    or those provided by the NTP pool project. Personally, I prefer the latter. Once
    you have your servers configured, there''s one more change we should make. You
    should see a line in the configuration similar to the following in CentOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, similar to the following in Debian:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'On your NTP server, uncomment that line and change the network address to yours,
    as well as the subnet. Remove `notrust` if it is there. For reference, the line
    in my configuration appears as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'With this configuration, we''re restricting NTP access to local clients and
    also ensuring that they do not have access to change configuration on the NTP
    server (only read from it). Another change I like to make in NTP is to designate
    a log file. systemd takes care of logging with `journalctl`, but sometimes it''s
    useful to have a text file to peruse in case of problems. If you''d like that,
    then add the following line somewhere near the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have any problems, check that file. Next, if you''re using CentOS as
    your NTP server, you should enable NTP traffic through its firewall. To do that,
    run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have that out of the way, restart your NTP server. We can do so
    via one of the following commands (as root).
  prefs: []
  type: TYPE_NORMAL
- en: Use the `systemctl restart ntpd` command on CentOS, or `systemctl restart ntp`
    on Debian.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you have an NTP server. On your clients, change the server that
    they are configured to synchronize with to the IP of the machine you''ve designated
    as your NTP server. In my case, the command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: After restarting NTP, give your systems some time to synchronize. In some cases,
    it can take over a half an hour for them to start synchronizing. Give it a bit
    of time and then check your configuration to ensure that it is syncing with the
    `ntpq -p` command.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up an internal NTP server](img/B03919_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output from a machine synchronizing with a custom NTP server
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in this output of my test environment, I started up an NTP server
    at `10.10.99.123` that this Debian machine is synchronizing with and currently
    the server has a reachability of `7`, but this number is slowing going up. This
    is fine, as the server has only been running a few minutes.
  prefs: []
  type: TYPE_NORMAL
- en: If you have any issues, make sure that port 123 is open in any firewalls you
    may have in your network (with CentOS as the server, make sure you've run the
    firewall commands that were mentioned earlier). But before you get frustrated,
    give it time—it's not uncommon for an NTP server to take a bit to get going when
    first set up. Typically, everything should get going within 20 minutes, but I've
    seen it take longer.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we configured the layout of our network. We started off with
    a discussion on planning our network IP address layout, followed by putting that
    into action by creating our own DHCP server. This discussion included how to split
    this configuration into multiple subnets, without multiple subnets. We continued
    with setting up a DNS server so that we can resolve our network nodes by name.
    We wrapped up this chapter by setting up an NTP server, so we can ensure all of
    our nodes have the correct time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look into hosting web content with Apache.
  prefs: []
  type: TYPE_NORMAL
