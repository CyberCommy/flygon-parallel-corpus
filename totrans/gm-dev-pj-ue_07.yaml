- en: 8\. User Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will continue our work on the Dodgeball-based game that
    we have been working on in the last few chapters. We will continue this project
    by learning about game UIs (short for user interfaces) and some of their forms,
    namely menus and HUDs. By the end of this chapter, you will be able to use UMG,
    UE4's game UI system, to make a menu with interactable buttons, as well as a HUD
    that displays the player character's current health points through a progress
    bar.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about general-purpose utilities that allow
    you to properly structure and organize the code and assets in your project by
    using Blueprint Function Libraries, Actor Components, and Interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will dive into the topic of game UIs, which is something
    that's present in almost every video game. The game UI is one of the main ways
    to show information to the player, such as how many lives they have left, how
    many bullets are in their weapon, which weapon they are carrying, and so on, and
    to allow the player to interact with the game by choosing whether to continue
    the game, create a new game, choose which level they want to play in, and so on.
    This is shown to the player mostly in the form of images and text.
  prefs: []
  type: TYPE_NORMAL
- en: '**User Interfaces** or **UIs** are usually added on top of the rendering of
    the game, which means that they are in front of everything else you see in the
    game and behave as layers (you can add them on top of one another just like in
    Photoshop). However, there is an exception to this: *diegetic UI*. This type of
    UI isn''t layered onto the game''s screen, but rather exists inside of the game
    itself. A great example of this can be found in the game *Dead Space*, where you
    control a character in a third-person view and can see their health points by
    looking at the contraption attached to their back, inside the game world.'
  prefs: []
  type: TYPE_NORMAL
- en: Game UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are usually two different types of game UI: **menus** and **HUDs**.'
  prefs: []
  type: TYPE_NORMAL
- en: Menus are UI panels that allow the player to interact with them, either by pressing
    a button or a key on their input device.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done in the form of many different menus, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Main menus, where the player can choose whether to continue the game, create
    a new game, exit the game, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Level select menus, where the player can choose which level to play
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And many other options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HUDs are UI panels that are present during gameplay that give the player information
    that they should always know, such as how many lives they have left, which special
    abilities they can use, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We will be covering game UI and making both a menu and a HUD for our game in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We won't be covering diegetic UI here, as it is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: So how do we go about creating a game UI in UE4? The main way to do that is
    by using **Unreal Motion Graphics** (**UMG**), which is the tool that allows you
    to make a game UI (also called Widgets in UE4 terms) featuring menus and HUDs,
    and add them to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Let's jump into this topic in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: UMG Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In UE4, the main way to create a game UI is by using the UMG tool. This tool
    will allow you to make a game UI in the form of `Designer` tab, while also allowing
    you to add functionality to your game UI through UMG's `Graph` tab.
  prefs: []
  type: TYPE_NORMAL
- en: Widgets are the way UE4 allows you to represent a game UI. Widgets can be basic
    UI elements such as `Buttons`, `Text` elements, and `Images`, but they can also
    be combined to create more complex and complete Widgets, such as menus and HUDs,
    which is exactly what we will be doing in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create our first Widget in UE4 using the UMG tool in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.01: Creating a Widget Blueprint'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be creating our first Widget Blueprint, as well as
    learning the basic elements of UMG and how we can use them to create a game UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: In order to create our first Widget, open the editor, go to the `ThirdPersonCPP
    -> Blueprints` folder inside the `Content Browser`, and *right-click*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the very last section, `User Interface`, and select `Widget Blueprint`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Selecting this option will create a new `Widget Blueprint`, which is the name
    for a Widget asset in UE4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Name this Widget `TestWidget` and open it. You will see the interface for editing
    a Widget Blueprint, where you''ll be creating your own Widgets and UI. Here''s
    a breakdown of all the tabs present in this window:![Figure 8.1: The Widget Blueprint
    editor broken down into six windows'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_08_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.1: The Widget Blueprint editor broken down into six windows'
  prefs: []
  type: TYPE_NORMAL
- en: 'The details about the tabs in the preceding figure are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Palette` – This tab shows you all the individual UI elements that you can
    add to your Widget. This includes `Buttons`, `Text Boxes`, `Images`, `Sliders`,
    `Check Boxes`, and many more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hierarchy` – This tab shows you all the UI elements currently present in your
    Widget. As you can see, currently we only have a `Canvas Panel` element in our
    hierarchy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Designer` – This tab shows you how your Widget looks visually, according to
    the elements present in the hierarchy and how they''re laid out. Because the only
    element we currently have in our Widget doesn''t have a visual representation,
    this tab is currently empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Details` – This tab shows you the properties of the UI element you have currently
    selected. If you select the existing `Canvas Panel` element, all the options in
    the preceding screenshot should appear.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because this asset is a `Widget Blueprint`, these two buttons allow you to switch
    between the `Designer view`, which is the one presented in the screenshot, and
    the `Graph view`, which looks exactly like the window of a normal Blueprint class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Animation` – Both these tabs are related to Widget animations. Widget Blueprints
    allow you to animate the properties of UI elements, including their `position`,
    `scale`, `color`, and so on, over time. The tab on the left allows you to create
    and select animations to edit in the right tab, where you''ll be able to edit
    what properties they affect over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now look at some of the available UI elements in our `Widget`, starting
    with the existing `Canvas Panel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Canvas Panels` are usually added to the root of Widget Blueprints because
    they allow you to drag a UI element to any position you want in the `Designer`
    tab. This way, you can lay out these elements as you wish: at the center of the
    screen, at the top-left corner, at the bottom center of the screen, and so on.
    Let''s now drag another very important UI element into our Widget: a `Button`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Palette` tab, find the `Button` element and drag it into our `Designer`
    tab (hold the left mouse button while you drag):![Figure 8.2: A Button element
    being dragged from the Palette window'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: into the Designer window
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_08_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.2: A Button element being dragged from the Palette window into the
    Designer window'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you do this, you''ll be able to resize the button to the size you want
    by dragging the little white dots around it (keep in mind that you''ll only be
    able to do this to an element that is inside a Canvas Panel):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3: The result of resizing a UI element using the white dots around
    it'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_08_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.3: The result of resizing a UI element using the white dots around
    it'
  prefs: []
  type: TYPE_NORMAL
- en: Another way for you to drag elements inside each other in a `Widget` is to drag
    them inside the `Hierarchy` tab, instead of the `Designer` tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now drag a `Text` element inside our `Button`, but this time, use the `Hierarchy`
    tab:![Figure 8.4: Dragging a Text element from the Palette window into the Hierarchy
    window'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_08_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.4: Dragging a Text element from the Palette window into the Hierarchy
    window'
  prefs: []
  type: TYPE_NORMAL
- en: '`Text` elements can contain text specified by you with a certain size and font
    that you can modify in the `Details` panel. After you''ve dragged the `Text` element
    inside the `Button` using the `Hierarchy` tab, this is what the `Designer` tab
    should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5: The Button element in the Designer tab, after we add a Text element
    as its child'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_08_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.5: The Button element in the Designer tab, after we add a Text element
    as its child'
  prefs: []
  type: TYPE_NORMAL
- en: Let's change a few properties of this `Text` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select it either in the `Hierarchy` tab or the `Designer` tab and take a look
    at the `Details` panel:![Figure 8.6: The Details panel, showing the properties
    of the Text element we added'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_08_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.6: The Details panel, showing the properties of the Text element we
    added'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here you''ll find several properties that you can edit to your liking. For
    now, we just want to focus on two of them: the `Content` of the text and its `Color
    and Opacity`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Content` of the `Text` element from `Text Block` to `Button 1`:![Figure
    8.7: Changing the Text property of the Text element to Button 1'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_08_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.7: Changing the Text property of the Text element to Button 1'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's change its `Color and Opacity` from `White` to `Black`.
  prefs: []
  type: TYPE_NORMAL
- en: Click the `Color and Opacity` property and take a look at the window that pops
    up, the `Color Picker`. This window pops up whenever you edit a `Color` property
    in UE4\. It allows you to input colors in many different ways, including a color
    wheel, a `Saturation` and `Value` bar, `RGB` and `HSV` value sliders, and a couple
    more options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For now, change the color from white to black by dragging the `Value` bar (the
    one that goes from white to black from top to bottom) all the way to the bottom
    and then pressing `OK`:![Figure 8.8: Selecting the color black in the Color Picker
    window'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_08_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.8: Selecting the color black in the Color Picker window'
  prefs: []
  type: TYPE_NORMAL
- en: 'After these changes, this is what the button should look like:![Figure 8.9:
    The Button element after we change the Text element''s Text'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: property and its color
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_08_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.9: The Button element after we change the Text element''s Text property
    and its color'
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we conclude our first exercise for this chapter. You now know
    some of the essential basics of UMG, such as how to add `Button` and `Text` elements
    to your Widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Before we jump into our next exercise, let's first learn about Anchors.
  prefs: []
  type: TYPE_NORMAL
- en: Anchors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you might be aware, video games are played on many different screen sizes
    with many different resolutions. Because of that, it is important to make sure
    that the menus you create can adapt to all these different resolutions effectively.
    This is the main purpose of **Anchors**.
  prefs: []
  type: TYPE_NORMAL
- en: Anchors allow you to specify how you want a UI element's size to adapt as the
    screen resolution changes by specifying the proportion of the screen you want
    it to occupy. Using Anchors, you can have a UI element always at the top left
    of the screen, or always occupying half of the screen, no matter the size and
    resolution of that screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the size of the screen or resolution changes, your Widget will scale and
    move relative to its Anchor. Only elements that are direct children of a `Canvas
    Panel` can have an Anchor, which you can visualize through the `Anchor Medallion`,
    a white flower-like shape in the `Designer` tab, when you select said element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10: The Anchor Medallion at the top left of the outline shown'
  prefs: []
  type: TYPE_NORMAL
- en: in the Designer window
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_08_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.10: The Anchor Medallion at the top left of the outline shown in the
    Designer window'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the Anchor is collapsed into the top-left corner, which means that
    you won't have much control over how the button is scaled as the resolution changes,
    so let's change that in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.02: Editing UMG Anchors'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be changing the Anchors in our Widget in order to
    have our Button's size and shape adapt to a wide range of screen resolutions and
    sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the Button we created in the previous exercise, then head to the `Details`
    panel and press the very first property you see, the `Anchors` property. Here
    you'll be able to see the `Anchor` presets, which will align the UI element according
    to the pivots shown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll want to have our button centered on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the pivot that''s at the center of the screen:![Figure 8.11: The Button''s
    Anchors property, with the center Anchor outlined in a box'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_08_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.11: The Button''s Anchors property, with the center Anchor outlined
    in a box'
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll see that our `Anchor Medallion` has now changed places:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12: The Anchor Medallion after we change the Button''s Anchor to
    the center'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_08_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.12: The Anchor Medallion after we change the Button''s Anchor to the
    center'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the `Anchor Medallion` is at the center of the screen, we still won't
    have much control over how the Button will scale across different resolutions,
    but at least we know that it'll scale relative to the center of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In order to have our Button centered on the screen, we'll have to change the
    Button's position to be at the center of the screen as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeat the previous step of picking the center Anchor, but this time, before
    you select it, hold the *Ctrl* key in order to snap the Button''s position to
    this Anchor. After you click it, release the *Ctrl* key. This should be the result:![Figure
    8.13: The Button element being moved near its selected Anchor in the center'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_08_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.13: The Button element being moved near its selected Anchor in the
    center'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding screenshot, our Button has changed position,
    but it isn't properly centered on the screen yet. This is because of its `Alignment`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Alignment` property is of type `Vector2D` (a tuple with two `float` properties:
    `X` and `Y`) and dictates the center of the UI element relative to its total size.
    By default it''s set to `(0,0)`, meaning the center of the element is its top-left
    corner, which explains the result in the preceding screenshot. It can go all the
    way to `(1,1)`, the bottom-right corner. In this case, given that we want the
    alignment to center the button, we want it to be `(0.5, 0.5)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to update a UI element''s alignment when picking an `Anchor` point,
    you have to hold the *Shift* key and repeat the previous step. Alternately, to
    update both the position and the alignment of the button, picking the center `Anchor`
    point while holding both the *Ctrl* and *Shift* keys will do the job. This should
    then be the result:![Figure 8.14: The Button element being centered relative to
    its selected'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Anchor in the center
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_08_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.14: The Button element being centered relative to its selected Anchor
    in the center'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, when changing the resolution of the screen, we know that this
    button will always remain at the center of the screen. However, in order to maintain
    the Button's size relative to the resolution, we'll need to make a few more modifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag the bottom-right *petal* of the `Anchor Medallion` all the way to the
    bottom-right corner of the button:![Figure 8.15: Dragging the lower-right petal
    of the Anchor Medallion'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: to update the Button element's Anchor
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_08_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.15: Dragging the lower-right petal of the Anchor Medallion to update
    the Button element''s Anchor'
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag the top-left *petal* of the `Anchor Medallion` all the way to the top-left
    corner of the button:![Figure 8.16: Dragging the upper-left petal of the Anchor
    Medallion'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: to update the Button element's Anchor
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_08_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.16: Dragging the upper-left petal of the Anchor Medallion to update
    the Button element''s Anchor'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The percentages you see around the button when changing the `Anchor` are the
    space the element is occupying on the screen as a percentage. For instance, looking
    at the last screenshot, we can see that the button is occupying `11.9%` of the
    Widget's space on the *X* coordinate and `8.4%` of the Widget's space on the *Y*
    coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: You can set the size of a UI element to the size of its Anchor by holding the
    *Ctrl* key while moving the Anchor Medallion *petals*.
  prefs: []
  type: TYPE_NORMAL
- en: Now our button will finally adapt to varying screen sizes and resolutions due
    to these changes to its Anchor.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `Details` panel to manually edit all of the properties
    we just edited by using the `Anchor Medallion` and moving the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17: The properties we changed using the Anchor Medallion, shown'
  prefs: []
  type: TYPE_NORMAL
- en: in the Details window
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_08_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.17: The properties we changed using the Anchor Medallion, shown in
    the Details window'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need to know how we can visualize our Widget with different resolutions
    in the `Designer` tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag the double arrow at the bottom right of the outlined box inside the `Designer`
    tab:![Figure 8.18: The double arrow at the bottom right of the outlined'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: box inside the Designer tab
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_08_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.18: The double arrow at the bottom right of the outlined box inside
    the Designer tab'
  prefs: []
  type: TYPE_NORMAL
- en: 'By dragging the double arrow you can resize the `Canvas` to any screen resolution
    you want. In the following screenshot, you''ll see the most used resolutions for
    a variety of devices, and you can preview your Widget in each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19: The resolutions we can choose to preview in the Designer window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_08_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.19: The resolutions we can choose to preview in the Designer window'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find a full reference to UMG's Anchors at [https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors](https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors).
  prefs: []
  type: TYPE_NORMAL
- en: And that concludes our exercise. You've learned about Anchors and adapting your
    Widgets to varying screen sizes and resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned about some of the basics of UMG, let's see how we can
    create a Widget C++ class for this Widget Blueprint, which is what we're going
    to do in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.03: Creating the RestartWidget C++ Class'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will learn how to create a Widget C++ class, from which
    the Widget Blueprint that we created will inherit from. It will get added to the
    screen when the player dies in our `Dodgeball` game so that the player can have
    the option to restart the level. This Widget will have a button that will restart
    the level when the player clicks it.
  prefs: []
  type: TYPE_NORMAL
- en: The first step of this exercise will be adding the UMG-related modules to our
    project. Unreal Engine comprises several different modules, and in each project,
    you have to specify which ones you're going to use. Our project came with a few
    general modules when the source code files were generated, but we'll need to add
    a few more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Dodgeball.build.cs` file, which is a C# file and not a C++ file, located
    inside your project's `Source` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the file, and you''ll find the `AddRange` function from the `PublicDependencyModuleNames`
    property being called. This is the function that tells the engine which modules
    this project intends to use. As a parameter, an array of strings is sent, with
    the names of all the intended modules for the project. Given that we intend on
    using UMG, we''ll need to add the UMG-related modules: `UMG`, `Slate`, and `SlateCore`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we notified the engine that we''ll be using the UMG modules, let''s
    create our Widget C++ class:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Unreal editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the Content Browser and select `New C++ Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Show All Classes` checkbox to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for the `UserWidget` class and choose that as the new class's parent class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new C++ class `RestartWidget`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the files have been opened in Visual Studio, start making modifications
    to our Widget C++ class as mentioned in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we''ll add to this class is a `public` `class UButton*` property
    called `RestartButton`, which represents the Button the player will press in order
    to restart the level. You will want it to be bound to a Button in the Blueprint
    class that inherits from this class, by using the `UPROPERTY` macro with the `BindWidget`
    meta tag. This will force that Widget Blueprint to have a `Button` called `RestartButton`
    that we can access in C++ through this property and then freely edit its properties,
    such as the size and position, in the Blueprint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `BindWidget` meta tag will cause a compilation error if the Widget
    Blueprint that inherits from this C++ class doesn''t have an element with the
    same type and name. If you don''t want this to happen, you will have to mark `UPROPERTY`
    as an optional `BindWidget` like so:`UPROPERTY(meta = (BindWidget, OptionalWidget
    = true))`     This will make it so that binding this property is optional and doesn''t cause
    a compilation error when compiling the Widget Blueprint.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we're going to add the function that will be called when the player clicks
    the `RestartButton`, which will restart the level. We will be doing this using
    the `GameplayStatics` object's `OpenLevel` function and then sending the name
    of the current level.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Widget class''s header file, add a declaration for a `protected` function
    called `OnRestartClicked` that returns nothing and receives no parameters. This
    function must be marked as `UFUNCTION`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the class''s source file, add an `include` for the `GameplayStatics` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add an implementation for our `OnRestartClicked` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside its implementation, call the `GameplayStatics` object''s `OpenLevel`
    function. This function receives as parameters a world context object, which will
    be the `this` pointer, and the name of the level, which we''ll have to fetch using
    the `GameplayStatics` object''s `GetCurrentLevelName` function. This last function
    must also receive a world context object, which will also be the `this` pointer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The call to the `GameplayStatics` object's `GetCurrentLevelName` function must
    be preceded with `*` because it returns an `FString`, UE4's string type, and must
    be dereferenced in order to be passed to the `FName` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step will be binding this function in such a way that it is called
    when the player presses the `RestartButton`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we''ll have to override a function that belongs to the
    `UserWidget` class, called `NativeOnInitialized`. This function is called only
    once, similarly to the Actor''s `BeginPlay` function, which makes it appropriate
    to do our setup. Add a declaration for the `public` `NativeOnInitialized` function
    with both the `virtual` and `override` keyword in our Widget class''s header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the class''s source file, add the implementation of this function.
    Inside it, call its `Super` function and add an `if` statement that checks whether
    our `RestartButton` is different than `nullptr`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `if` statement is true, we''ll want to bind our `OnRestartClicked` function
    to the button''s `OnClicked` event. We can do this by accessing the button''s
    `OnClicked` property and calling its `AddDynamic` function, sending as parameters
    the object we want to call that function on, the `this` pointer, and a pointer
    to the function to be called, the `OnRestartClicked` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we''re accessing functions related to the `Button` class, we''ll also
    have to include it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A Button's `OnClicked` event will be called when the player presses and releases
    that button with the mouse. There are other events related to the button, including
    the `OnPressed` event (when the player presses the button), the `OnReleased` event
    (when the player releases the button), and the `OnHover` and `OnUnhover` events
    (when the player respectively starts and stops hovering the mouse over that button).
  prefs: []
  type: TYPE_NORMAL
- en: The `AddDynamic` function must receive as a parameter a pointer to a function
    marked with the `UFUNCTION` macro. If it doesn't, you will get an error when calling
    that function. This is why we marked the `OnRestartClicked` function with the
    `UFUNCTION` macro.
  prefs: []
  type: TYPE_NORMAL
- en: After you've done these steps, compile your changes and open the editor.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `TestWidget` Widget Blueprint that you created earlier. We'll want
    to associate this Widget Blueprint with the `RestartWidget` class we just created,
    so we need to reparent it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Widget Blueprint''s `File` tab, select the `Reparent Blueprint` option
    and choose the `RestartWidget` C++ class as its new parent class:![Figure 8.20:
    Reparenting the TestWidget''s class to RestartWidget'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_08_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.20: Reparenting the TestWidget''s class to RestartWidget'
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll notice that the Widget Blueprint now has a compilation error related
    to the `BindWidget` meta tag that we created in the C++ class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21: Compiler errors after setting the parent class to the RestartWidget
    class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_08_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.21: Compiler errors after setting the parent class to the RestartWidget
    class'
  prefs: []
  type: TYPE_NORMAL
- en: This is caused by the fact that the C++ class couldn't find any `Button` property
    called `RestartButton`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to fix this, we''ll need to rename our `Button` element inside the
    Widget Blueprint to `RestartButton`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22: Renaming the Button element to RestartButton'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_08_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.22: Renaming the Button element to RestartButton'
  prefs: []
  type: TYPE_NORMAL
- en: After you've done this, close the Widget Blueprint and change its name from
    `TestWidget` to `BP_RestartWidget`, the same way you just did in the previous step.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes the creation of our Widget class. You now know how to connect
    a Widget C++ class to a Widget Blueprint, a very important step toward handling
    Game UI in UE4.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we need to do is create our `Player Controller` C++ class, which
    will be responsible for instantiating our `RestartWidget` and adding it to the
    screen. We will be doing this in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.04: Creating the Logic for Adding the RestartWidget to the Screen'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will create the logic responsible for adding our newly
    created `RestartWidget` to the screen. It will appear on screen when the player
    dies so that they have the option to restart the level.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we''ll have to create a new `Player Controller` C++ class,
    which you can do by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Unreal editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* on the `Content Browser` and select `New C++ Class`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for the `Player Controller` class and choose that as the new class's
    parent class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new C++ class `DodgeballPlayerController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the class's files in Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When our player runs out of health points, the `DodgeballCharacter` class will
    access this `Player Controller` class and call a function that will add the `RestartWidget`
    to the screen. Follow these steps ahead in order to make this happen.
  prefs: []
  type: TYPE_NORMAL
- en: In order to know the class of the Widget to add to the screen (which will be
    a Widget Blueprint and not a Widget C++ class), we'll need to use the `TSubclassOf`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the class''s header file, add a `public` `TSubclassOf<class URestartWidget>`
    property called `BP_RestartWidget`. Be sure to make it a `UPROPERTY` with the
    `EditDefaultsOnly` tag so that we can edit it in the Blueprint class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In order to instantiate this Widget and add it to the screen, we'll need to
    save a reference to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `private` variable of type `class URestartWidget*` and call it `RestartWidget`.
    Be sure to make it a `UPROPERTY` function with no tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Although this property isn't supposed to be editable in a Blueprint class, we
    have to make this reference a `UPROPERTY`, otherwise the garbage collector will
    destroy the contents of this variable.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we need is a function responsible for adding our Widget to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a declaration for a `public` function that returns nothing and receives
    no parameters called `ShowRestartWidget`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, head to our class''s source file. First, add an include to the `RestartWidget`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the implementation of our `ShowRestartWidget` function, where we''ll
    start by checking whether our `BP_RestartWidget` variable is not a `nullptr`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If that variable is valid (different than `nullptr`), we want to pause the
    game using the `SetPause` function of `Player Controller`. This will make sure
    that the game stops until the player decides to do something (which in our case
    will be pressing the button that restarts the level):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we''ll do is change the input mode. In UE4, there are three
    input modes: `Game Only`, `Game and UI`, and `UI Only`. If your `Input` Mode includes
    `Game`, that means that the player character and player controller will receive
    inputs through the `Input Actions`. If your `Input` Mode includes `UI`, that means
    that the Widgets that are on the screen will receive inputs from the player. When
    we show this Widget on the screen, we won''t want the player character to receive
    any input.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, update to the `UI Only` `Input` Mode. You can do this by calling the
    `Player Controller` `SetInputMode` function and passing the `FInputModeUIOnly`
    type as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: After this, we want to show the mouse cursor, so that the player can see which
    button they are hovering the mouse on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will do this by setting the `Player Controller`''s `bShowMouseCursor` property
    to `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can actually instantiate our Widget using the `Player Controller`''s
    `CreateWidget` function, passing as a template parameter the C++ Widget class,
    which in our case is `RestartWidget`, and then as normal parameters the `Owning
    Player`, which is the `Player Controller` that owns this Widget and that we''ll
    send using the `this` pointer, and the Widget class, which will be our `BP_RestartWidget`
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After we instantiate the Widget, we''ll want to add it to the screen, using
    the Widget''s `AddToViewport` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'That concludes our `ShowRestartWidget` function. However, we also need to create
    the function that will remove the `RestartWidget` from the screen. In the class''s
    header file, add a declaration for a function just like the `ShowRestartWidget`
    function, but this time called `HideRestartWidget`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the class''s source file, add the implementation for the `HideRestartWidget` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we should do in this function is remove the Widget from the
    screen by calling its `RemoveFromParent` function, and destroy it using the `Destruct`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we want to unpause the game using the `SetPause` function we used in
    the previous function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, set the `Input` Mode to `Game Only` and hide the mouse cursor
    the same way we did in the previous function (this time we pass the `FInputModeGameOnly`
    type instead):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: And that concludes the logic for our `Player Controller` C++ class. The next
    thing we should do is call the function that will add our Widget to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `DodgeballCharacter` class''s source file and add the `include` keyword
    to our newly created `DodgeballPlayerController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `DodgeballCharacter` class''s implementation of the `OnDeath_Implementation`
    function, replace the call to the `QuitGame` function with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Get the character''s player controller using the `GetController` function.
    You''ll want to save the result in a variable of type `DodgeballPlayerController*`
    called `PlayerController`. Because the function will return a variable of type
    `Controller`, you''ll also need to cast it to our `PlayerController` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether the `PlayerController` variable is valid. If it is, call its
    `ShowRestartWidget` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: After these modifications, the last thing left for us to do is to call the function
    that will hide our Widget from the screen. Open the `RestartWidget` class's source
    file and implement the following modifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an `include` to the `DodgeballPlayerController`, which contains the function
    that we will be calling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `OnRestartClicked` function implementation, before the call to the
    `OpenLevel` function, we must fetch the Widget''s `OwningPlayer`, which is of
    type `PlayerController`, using the `GetOwningPlayer` function, and cast it to
    the `DodgeballPlayerController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, if the `PlayerController` variable is valid, we call its `HideRestartWidget`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: After you've followed all these steps, close the editor, compile your changes
    and open the editor.
  prefs: []
  type: TYPE_NORMAL
- en: You have now concluded this exercise. We have added all the necessary logic
    to add our `RestartWidget` to the screen, and the only thing left for us to do
    is creating the Blueprint class of our newly created `DodgeballPlayerController`,
    which we'll be doing in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.05: Setting up the DodgeballPlayerController Blueprint Class'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be creating the Blueprint class of our `DodgeballPlayerController`
    in order to specify which Widget we want to add to the screen, and tell UE4 to
    use this Blueprint class when the game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do that, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the `ThirdPersonCPP` -> `Blueprints` directory in the Content Browser,
    right-click on it, and create a new Blueprint class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for the `DodgeballPlayerController` class and select it as the parent
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename this Blueprint class to `BP_DodgeballPlayerController`. After that, open
    this Blueprint asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to its `Class Defaults` tab and set the class's `BP_RestartWidget` property
    to the `BP_RestartWidget` Widget Blueprint we created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the only thing left for us to do is to make sure that this `Player Controller`
    Blueprint class is being used in the game.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do this, we'll have to follow a few more steps.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the `ThirdPersonCPP` -> `Blueprints` directory in the `Content Browser`,
    *right-click* on it and create a new Blueprint class. Search for the `DodgeballGameMode`
    class and select it as the parent class, then rename this `Blueprint` class to
    `BP_DodgeballGameMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This class is responsible for telling the game which classes to use for each
    element of the game, such as which `Player Controller` class to use, among other
    things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the asset, go to its `Class Defaults` tab, and set the class''s `PlayerControllerClass`
    property to the `BP_DodgeballPlayerController` class we created:![Figure 8.23:
    Setting the PlayerControllerClass property to BP_DodgeballPlayerController'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_08_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.23: Setting the PlayerControllerClass property to BP_DodgeballPlayerController'
  prefs: []
  type: TYPE_NORMAL
- en: Close the asset and select the `Blueprints` drop-down option inside the editor
    toolbar that is at the top of the `Level Viewport` window. From there, select
    `Game Mode` (which should currently be set to `DodgeballGameMode`) `-> Select
    GameModeBase Class -> BP_DodgeballGameMode`. This will tell the editor to use
    this new `Game Mode` in all levels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, play the game and let your character get hit by a Dodgeball `3` times.
    After the third time, you should see the game get paused and show `BP_RestartWidget`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.24: Our BP_RestartWidget being added to the screen after the player'
  prefs: []
  type: TYPE_NORMAL
- en: runs out of health points
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_08_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.24: Our BP_RestartWidget being added to the screen after the player
    runs out of health points'
  prefs: []
  type: TYPE_NORMAL
- en: 'And when you click `Button 1` using your mouse, you should see the level reset
    to its initial state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.25: The level restarts after the player presses the button'
  prefs: []
  type: TYPE_NORMAL
- en: shown in the previous screenshot
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_08_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.25: The level restarts after the player presses the button shown in
    the previous screenshot'
  prefs: []
  type: TYPE_NORMAL
- en: And that concludes our exercise. You now know how to create Widgets and show
    them in your game. This is another crucial step in your journey toward becoming
    a skilled game developer.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to the next exercise, let's take a look at Progress Bars in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Progress Bars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the ways that video games can represent character stats such as health,
    stamina, and so on is through **Progress Bars**, which are what we'll use to communicate
    to the player how much health their character has. Progress Bars are essentially
    a shape, usually rectangular, that can be filled and emptied in order to show
    the player how a specific stat is progressing. If you want to show the player
    that their character's health is only half its maximum value, you could do this
    by showing the Progress Bar as half full. This is exactly what we'll be doing
    in this section. This Progress Bar will be the only element in our Dodgeball game's
    HUD.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create this `Health Bar`, we'll first need to create our HUD Widget.
    Open the editor, go to the `ThirdPersonCPP` -> `Blueprints` directory inside the
    Content Browser, and right-click and create a new `Widget Blueprint` class of
    the `User Interface` category. Name this new Widget Blueprint `BP_HUDWidget`.
    After that, open this new Widget Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Progress Bars in UE4 are just another UI element, like `Buttons` and `Text`
    elements, which means we can drag it from the `Palette` tab into our `Designer`
    tab. Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.26: Dragging a Progress Bar element into the Designer window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_08_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.26: Dragging a Progress Bar element into the Designer window'
  prefs: []
  type: TYPE_NORMAL
- en: 'At first, this Progress Bar might look similar to a button; however, it contains
    two specific properties that are important for a Progress Bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Percent` – allows you to specify this Progress Bar''s progress, from `0` to
    `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bar Fill Type` – allows you to specify how you want this Progress Bar to fill
    (from left to right, top to bottom, and so on):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.27: The Progress Bar''s Percent and Bar Fill Type properties'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_08_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.27: The Progress Bar''s Percent and Bar Fill Type properties'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you set the `Percent` property to `0.5`, you should see the Progress Bar
    be updated accordingly to fill half of its length:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.28: The Progress Bar filled halfway to the right'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_08_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.28: The Progress Bar filled halfway to the right'
  prefs: []
  type: TYPE_NORMAL
- en: Before you continue, set the `Percent` property to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now change the Progress Bar''s color from blue (its default color) to
    red. In order to do this, go to the `Details` tab and, inside the `Appearance`
    category, set the `Fill Color and Opacity` property to red (`RGB(1,0,0)`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.29: The Progress Bar''s Color being changed to red'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_08_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.29: The Progress Bar''s Color being changed to red'
  prefs: []
  type: TYPE_NORMAL
- en: After you've done this, your Progress Bar should now use red as its fill color.
  prefs: []
  type: TYPE_NORMAL
- en: 'To conclude our Progress Bar''s setup, let''s update its position, size, and
    Anchors. Follow these steps to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Slot `(Canvas Panel Slot)` category, expand the `Anchors` property and
    set its properties to these values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Minimum`: `0.052` on the `X` axis and `0.083` on the `Y` axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Maximum`: `0.208` on the `X` axis and `0.116` on the `Y` axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the `Offset Left`, `Offset Top`, `Offset Right`, and `Offset Bottom` properties
    to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your Progress Bar should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.30: The Progress Bar after all the modifications in this section
    have been completed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_08_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.30: The Progress Bar after all the modifications in this section have
    been completed'
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we can conclude the topic of Progress Bars. Our next step is
    going to be adding all the logic necessary to use this Progress Bar as a health
    bar, by updating its `Percent` property alongside the player character's health.
    We'll do exactly this in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.06: Creating the Health Bar C++ Logic'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be adding all the necessary C++ logic to update the
    Progress Bar inside our HUD as the player character's health changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the editor and create a new C++ class that inherits from `UserWidget`,
    similar to how we did in *Exercise 8.03*, *Creating the RestartWidget C++ Class*,
    but this time call it `HUDWidget`. This will be the C++ class that will be used
    for our HUD Widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `HUDWidget` class''s header file, add a new `public` property of type
    `class UProgressBar*` called `HealthBar`. This type is used to represent a Progress
    Bar, like the one we created in the previous section, in C++. Be sure to declare
    this property as a `UPROPERTY` function with the `BindWidget` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a declaration for a `public` function called `UpdateHealthPercent`, which
    returns nothing and receives a `float HealthPercent` property as a parameter.
    This function will be called in order to update the `Percent` property of our
    Progress Bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `HUDWidget` class''s source file, add the implementation for the `UpdateHealthPercent`
    function, which will call the `HealthBar` property''s `SetPercent` function, passing
    the `HealthPercent` property as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we''ll be using the `ProgressBar` C++ class, we''ll need to add an
    `include` to it at the top of the class''s source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step will be adding all the necessary logic to our `Player Controller`
    responsible for adding the `HUDWidget` to the screen. Implement the following
    steps in order to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `DodgeballPlayerController` class's header file, add a `public` property
    of type `TSubclassOf<class UHUDWidget>` called `BP_HUDWidget`. Make sure to mark
    it as a `UPROPERTY` function with the `EditDefaultsOnly` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This property will allow us to specify, in the `DodgeballPlayerController`
    Blueprint class, which Widget we want to use as our HUD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Add another property, this time `private`, of type `class UHUDWidget*` called
    `HUDWidget`. Mark it as a `UPROPERTY`, but without any tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `protected` declaration for the `BeginPlay` function, and mark it as
    both `virtual` and `override`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Add a declaration for a new `public` function, called `UpdateHealthPercent`,
    which returns nothing and receives a `float HealthPercent` as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This function will be called by our player character class in order to update
    the Health Bar in our HUD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now head over to the `DodgeballPlayerController` class''s source file. Start
    by adding an `include` to our `HUDWidget` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the implementation for the `BeginPlay` function, where we''ll start
    by calling the `Super` object''s `BeginPlay` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After that function call, check whether the `BP_HUDWidget` property is valid.
    If it is, call the `CreateWidget` function with the `UHUDWidget` template parameter
    and passing the `Owning Player`, `this`, and the Widget class, `BP_HUDWidget`,
    as parameters. Be sure to set the `HUDWidget` property to the return value of
    this function call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'After setting the `HUDWidget` property, call its `AddToViewport` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, add the implementation for the `UpdateHealthPercent` function, where
    we''ll check if the `HUDWidget` property is valid and, if it is, call its `UpdateHealthPercent`
    function and pass the `HealthPercent` property as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've added the logic responsible for adding the HUD to the screen
    and allowing it to be updated, we'll need to make some modifications to other
    classes. Follow these steps in order to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, our `Health` interface, which we created in the previous chapter,
    only has the `OnDeath` event, which is called whenever an object runs out of health
    points. In order to update our Health Bar every time the player takes damage,
    we'll need to allow our `HealthInterface` class to notify an object whenever that
    happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `HealthInterface` class''s header file and add a declaration similar
    to the one we did for the `OnDeath` event in *Exercise 7.04*, *Creating the HealthInterface
    Class*, but this time for the `OnTakeDamage` event. This event will be called
    whenever an object takes damage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have added this event to our `Interface` class, let''s add the
    logic that calls that event: open the `HealthComponent` class''s source file and,
    inside its implementation of the `LoseHealth` function, after subtracting the
    `Amount` property from the `Health` property, check whether the `Owner` implements
    the `Health` interface and, if it does, call its `OnTakeDamage` event. Do this
    the same way we already did later in that same function for our `OnDeath` event,
    but this time simply change the name of the event to `OnTakeDamage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Because our Health Bar will require the player character''s health points as
    a percentage, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `public` function to our `HealthComponent` that returns just that: in
    the `HealthComponent` class''s header file, add a declaration for a `FORCEINLINE`
    function that returns a `float`. This function should be called `GetHealthPercent`
    and be a `const` function. Its implementation will simply consist of returning
    the `Health` property divided by `100`, which we will assume is the maximum amount
    of health points an object can have in our game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now go to the `DodgeballCharacter` class''s header file and add a declaration
    for a `public` `virtual` function called `OnTakeDamage_Implementation`, which
    returns nothing and receives no parameters. Mark it as `virtual` and `override`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `DodgeballCharacter` class''s source file, add an implementation for
    the `OnTakeDamage_Implementation` function we just declared. Copy the content
    of the `OnDeath_Implementation` function to this new function''s implementation,
    but do this change: instead of calling the `ShowRestartWidget` function of `PlayerController`,
    call its `UpdateHealthPercent` function, and pass the return value of the `HealthComponent`
    property''s `GetHealthPercent` function as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This concludes this exercise''s code setup. After you''ve done these changes,
    compile your code, open the editor and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `BP_HUDWidget` Widget Blueprint and reparent it to the `HUDWidget`
    class, the same way you did in *Exercise 8.03*, *Creating the RestartWidget C++
    Class*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This should cause a compilation error, which you'll be able to fix by renaming
    our Progress Bar element to `HealthBar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Close this Widget Blueprint, open the `BP_DodgeballPlayerController` Blueprint
    class and set its `BP_HUDWidget` property to the `BP_HUDWidget` Widget Blueprint:![Figure
    8.31: Setting the BP_HUDWidget property to BP_HUDWidget'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_08_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.31: Setting the BP_HUDWidget property to BP_HUDWidget'
  prefs: []
  type: TYPE_NORMAL
- en: 'After you''ve done these changes, play the level. You should notice the `Health
    Bar` at the top left of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.32: The Progress Bar shown at the top left of the screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_08_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.32: The Progress Bar shown at the top left of the screen'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the player character gets hit by a Dodgeball, you should notice the `Health
    Bar` being emptied:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.33: The Progress Bar being emptied as the Player Character loses
    health points'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_08_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.33: The Progress Bar being emptied as the Player Character loses health
    points'
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we conclude this exercise, in which you've learned all the necessary
    steps in order to add a HUD to the screen and to update it during the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 8.01: Improving the RestartWidget'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we will be adding a `Text` element to our `RestartWidget`
    reading `Game Over` in order for the player to know that they just lost the game;
    adding an `Exit` button, which will allow the player to exit the game; and also
    updating the text of our existing button to `Restart` so that the players know
    what should happen when they click that button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `BP_RestartWidget` Widget Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a new `Text` element into the existing `Canvas Panel` element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `Text` element''s properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the `Anchors` property and set its `Minimum` to `0.291` on the `X` axis
    and `0.115` on the `Y` axis, and its `Maximum` to `0.708` on the `X` axis and
    `0.255` on the `Y` axis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the `Offset Left`, `Offset Top`, `Offset Right`, and `Offset Bottom` properties
    to `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the `Text` property to `GAME OVER`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Set the `Color and Opacity` property to red: `RGBA(1.0, 0.082, 0.082, 1.0)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expand the `Font` property and set its `Size` to `100`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the `Justification` property to `Align Text Center`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the other `Text` element inside the `RestartButton` property, and change
    its `Text` property to `Restart`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the `RestartButton` property and change the copy's name to `ExitButton`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `Text` property of the `Text` element inside the `ExitButton` property
    to `Exit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the `Anchor` property of the `ExitButton` property and set its `Minimum`
    to `0.44` on the *X* axis and `0.615` on the *Y* axis, and its `Maximum` to `0.558`
    on the *X* axis and `0.692` on the *Y* axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `ExitButton` properties of `Offset Left`, `Offset Top`, `Offset Right`,
    and `Offset Bottom` to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After you''ve done these changes, we''ll need to add the logic responsible
    for handling the `ExitButton` property click, which will exit the game:'
  prefs: []
  type: TYPE_NORMAL
- en: Save the changes made to the `BP_RestartWidget` Widget Blueprint and open the
    `RestartWidget` class's header file in Visual Studio. In this file, add a declaration
    for a `protected` function called `OnExitClicked` that returns nothing and receives
    no parameters. Be sure to mark it as a `UFUNCTION`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the existing `RestartButton` property, but call it `ExitButton` instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `RestartWidget` class's source file, add an implementation for the
    `OnExitClicked` function. Copy the contents of the `OnBeginOverlap` function from
    inside the `VictoryBox` class's source file into the `OnExitClicked` function,
    but remove the cast being done to the `DodgeballCharacter` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `NativeOnInitialized` function implementation, bind the `OnExitClicked`
    function we created to the `OnClicked` event of the `ExitButton` property, the
    same way we did for the `RestartButton` property in *Exercise 8.03*, *Creating
    the RestartWidget C++ Class*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And that concludes our code setup for this activity. Compile your changes, open
    the editor, then open the `BP_RestartWidget` and compile it just to make sure
    there are no compilation errors due to the `BindWidget` tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve done so, play the level again, let the player character be hit
    by three Dodgeballs, and notice the `Restart` Widget appear with our new modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.34: The updated BP_RestartWidget being shown after the player'
  prefs: []
  type: TYPE_NORMAL
- en: runs out of health points
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_08_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.34: The updated BP_RestartWidget being shown after the player runs
    out of health points'
  prefs: []
  type: TYPE_NORMAL
- en: If you press the `Restart` button, you should be able to replay the level, and
    if you press the `Exit` button, the game should end.
  prefs: []
  type: TYPE_NORMAL
- en: And that concludes our activity. You've consolidated the basics of using a `Widget`
    Blueprint and changing its element's properties and are now ready to start making
    your own menus.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this chapter concluded, you have now learned how to make a game UI in UE4,
    understanding things such as menus and HUDs. You've seen how to manipulate a Widget
    Blueprint's UI elements, including `Buttons`, `Text` elements, and `Progress Bars`;
    work with Anchors effectively, which is instrumental in allowing your game UI
    to adapt elegantly to multiple screens; listen to mouse events in C++, such as
    the `OnClick` event, and use that to create your own game logic; as well as how
    to add the Widgets you create to the screen, either at specific events or have
    them present at all times.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be taking a look at polishing our Dodgeball game
    by adding audiovisual elements such as sound and particle effects, as well as
    making a new level.
  prefs: []
  type: TYPE_NORMAL
