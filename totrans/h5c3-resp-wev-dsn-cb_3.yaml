- en: Chapter 3. Responsive Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: Responsive layout with the min-width and max-width properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling your layout with relative padding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a media query to your CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a responsive width layout with media queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing image sizes with media queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hiding an element with media queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a smoothly transitioning responsive layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has some challenging recipes. Responsive layouts often present
    some difficult challenges that can push you to create a great solution. With responsive
    design methods you can do much more, and do it more efficiently. Responsive layouts
    have introduced a whole new area of challenges to web development and a new dimension
    of excitement.
  prefs: []
  type: TYPE_NORMAL
- en: Responsive layout with the min-width and max-width properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many responsive layout techniques can be quite complex and overwhelming, but
    in this recipe you will see a fairly simple layout using the `min-width` and `max-width`
    properties applied to three floating elements. With this very simple responsive
    layout feature of CSS, you are ready to display your site on mobile devices and
    desktop screens of various sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Floating elements that collapse from multiple columns into one column on a small
    viewport is not a new trick. This has been around for years as a standard property
    of CSS1, however, there was never any reason to consider it useful until the mobile
    devices became common. So let's combine this old, stale property with some other
    fresh CSS properties to make a responsive layout.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a simple HTML page enclosed in an `article` element, containing a `h1`
    header and three elements. The first element will contain an image and the second
    and third will contain filler text. Assign to all of the inner elements a class
    of `float` and respectively `one`, `two`, and `three` as their IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create your style for the `.article` element and assign the properties:
    `width: 100%;`, `max-width: 1280px;`, and auto side margins. Then, center the
    `h1` title. Assign the `img` element the `width: 100%` and `height: auto;` properties
    to make it responsive to its parent element. For the floating element containing
    the `img` element, give it a `min-width` value of `500px`. You could also give
    each floating element a different background color to make them more discernible,
    but this is not vital to the layout. To all the floating elements in the `.float`
    class, add a `max-width: 350px` property, left float, and for clean looks, justify
    the text.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once everything is put together and you have the HTML document open in your
    browser, you will see how the layout smoothly goes from a three-column layout
    to a two-column layout, and then finally to a single-column layout, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/5442OT_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `max-width` property of the columns allows them to have a fluid but a maximum
    width. This gives you more flexibility in the layout of the columns than you would
    have with a static width. The image column utilizes the `min-width` property so
    it can respond to parent element width's changes by growing and shrinking. Finally,
    the whole layout can smoothly break down from three columns to one column by using
    the `float` property; once there is not enough room for the elements to float
    side by side, the last element drops to a new row.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling your layout with relative padding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's put together a simple layout for a blog with comments and comment replies.
    This is possible using only relative padding for the layout. You say, "That's
    crazy! How can you control a page layout with nothing but padding?" Let's find
    out.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, a blog is much more dynamic than a static HTML page, so this would
    be a good part of a comments template section for your favorite blogging software.
    That being said, this recipe is remarkably easy, and yet effective. So, go get
    yourself some Ipsum filler text and get ready to troll yourself.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is to create a very simple blog style page with comments embedded
    in the `div` element. In your HTML body, create the element that will hold everything,
    the `.content` div. Give it a `h1` title, a paragraph of Ipsum filler text, and
    follow it with a `.comments` element. Inside the `.comments` element you will
    build your embedded comments layout.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the `.comments` title, you will add your first comment. And next, inside
    that comment, immediately after the closing paragraph tag add a comment to that
    comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Continuing from there, you can insert more comments the same way to a comment
    on the parent comment, or add a comment outside of the parent `div` element to
    make the comment to the parents'' parent, all the way up to the original blog
    post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Eventually, you can have many comments and a good looking working layout built
    simply with only relative padding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CSS to make this work is surprisingly easy. Simply add the classes: `.content`,
    `.comments`, and `.comment`. In the `content` class add some side padding, and
    in the `comment` add heavier padding to the left.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/5442OT_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The relative padding attribute responds to page width changes by adjusting its
    own width.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a media query to your CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will explore the awesome power of the media query by rendering
    a simple web page with every permutation and device available in the universe.
    Okay, I'm exaggerating a little, I admit. But we will create a simple web page
    that will respond to several browser window sizes, devices, and other possible
    presentation methods.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Solely for the purpose of this recipe, go out and purchase one of each of the
    devices and variations described here. You'll need a new high definition TV, a
    smart phone, a not-so-smart phone, and at least one printer. No way? Okay, but
    I'm just trying to help you and the economy. That being said, of course it will
    be impossible to truly test every media query, but do what you can. There are
    a surprising number of possibilities. But in most real-life scenarios, you are
    unlikely to need or care to use most of these. We will at least try to cover the
    most commonly used media queries.
  prefs: []
  type: TYPE_NORMAL
- en: I will skip over those that I think are unnecessary to you. You can easily access
    information about these if you find yourself in a project with requirements to
    create presentations for one of these obscure devices. You never know! The WC3
    has all of the detailed information and descriptions of these if you need them
    at [http://www.w3.org/TR/css3-mediaqueries/](http://www.w3.org/TR/css3-mediaqueries/).
    I will exclude the examples and just for your reference include numerous devices
    with specific color limitations, including monochrome, print, TV, and handheld.
    The media queries you will need most likely are `screen` and `print`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a simple HTML page with a `h1` title, and an element wrapping around
    an image, and a paragraph of text. Get some Ipsum filler text if you don''t have
    any text lying around. It will look just like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next create a series of media queries. In the following list, I will give a
    brief explanation of what each does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is applied to the web page when it's printed. You can test this by selecting
    **File** | **Print** and then view the print preview. This is useful for web pages
    where users will be printing it as a document to read. You can take advantage
    of this and change or remove the formatting to make this version as simple as
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is generally applied on any device that shows the document in portrait
    mode. You can use it for mobile devices to change the look for different orientations.
    Be cautious because this also will be applied to desktop screens unless you specify
    it to smaller screens or devices only. The media query orientation's other possible
    value is landscape.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `height` and `width` media query allows you to specify style for specific
    screen dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This media query will apply a style to any page, regardless of browser's window
    size, that is viewed on a device of the specified dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This media query can be used to define styles for screens (not print) with a
    view window of the `16/9` ratio.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This aspect ratio would apply only to a device using a television to view.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `min-width` and `max-width` media queries are the most useful one. Here,
    you can define a responsive style for any window size including the small-screen
    mobile devices. I typically start by defining the smallest—or mobiles—viewports
    breakpoint, and define their styles, and then create breakpoint ranges for the
    most popular screen sizes, ending with a `min-width` media query to apply to the
    largest screen sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created the media queries that you think are useful for your
    current project, add styles to the media queries with different values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The final version of the page is displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/5442OT_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apply these styles and you will find that a different style is applied to different
    devices. You can combine a number of these in a clever way to create magic responsiveness
    in your site.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a responsive width layout with media queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will make a simple responsive width layout that adjusts itself
    to various screen widths. This layout would be a good starter template for a personal
    blog or news magazine, where you would want your readers to comment on your content
    and on each other's comments. It may even be a great theme starter to attract
    trolls to a flame war. This paragraph just sounds silly, sorry!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This template will work great in a dynamic CMS or blog software, but might not
    make much sense as a plain HTML page. But most themes work in the same as HTML
    as far as presentation goes. In most cases, you would simply replace the text
    and static navigation with template tags. This recipe will need some filler text
    to demonstrate. If you do not already have some text to work with, go to our old
    standby Ipsum generator to get some filler text.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, create a simple web page, and in the `style` element create your
    media queries. You can always link to an external stylesheet, but for the sake
    of simplicity, this and most of the recipes contain the CSS in the `<style>...</style>`
    section of your header. Include these standard breakpoints at screen sizes: `960`,
    `1024`, and `1280`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first media query affects all viewports narrower than `960px`. The second
    from `961px` to `1024px`, the third from `1025px` to `1280px`, and the last affects,
    all screen sizes larger than `1281px`. Within each media query, you will write
    a CSS for a different layout. There will be some layout CSS outside of the media
    query along with your style presentation, but most of them will be defined in
    the media queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create your HTML layout. The basic structure starts with
    these basic `div` elements—`nav`, `content`, and `comments`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Next add some filler content to your page. This will aid in the demonstration
    of the layout.
  prefs: []
  type: TYPE_NORMAL
- en: In the `nav` element, add an unordered list with sample menu links. This will
    serve as a responsive menu. At the pages' narrowest width, the menu will display
    vertically. In widths ranging from 961px to 1280px, the menu is displayed inline
    horizontally on top. For larger widths, we want the menu to return to a vertical
    display and return to the left-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: In the first two media queries, the `content` and `comments` elements will float
    left, but with different width ratios. In `960px`, these elements should have
    a width of `90%`. In the larger widths, set the `content` and `comments` elements
    at `60%` and `20%`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the menu slide back to the left on the large screens, we will use positioning
    to create a three column layout. In the `min-width:1281px` media query, add the
    `.nav` element and styles for absolute positioning and width:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That's almost all the steps necessary to build a responsive layout. To tidy
    things up, let's add some padding to the layouts. Add the `.nav`, `.content`,
    and `.comments` elements to the other media queries, and then add padding to those.
    Refer to the following CSS. The `min-width:1281px` media query will not have a
    padding for the `.nav` element, and the padding for the `.content` and `.comments`
    elements are reduced to allow for the vertical menu.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also style the inline menu however you want. For now let''s simply
    add some margins to the `li` elements. Add this element and styles outside of
    the media queries, `.nav ul li{margin: 2px 10px;}`.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, on to the content and comments, paste your filler text inside the `.content`
    element. I also added the header and paragraph tags inside. We will do something
    similar for the comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that we want to allow for embedded comments, or people to comment
    on comments. There will be a possible inherited hierarchy of comments, and we
    still need this to look good in all browser sizes, so we should add some padding.
    Adding a static padding to the `.comment` element will not look good in all browser
    sizes. Instead, add a relative padding to each media query''s `.comments` element,
    so that they take less space as the browser window gets smaller: `90%` for the
    `max-width:960px` media query and `20%` for all larger sizes. Add outside of the
    media queries, `padding-left: 8%` to the `.comment` element, and float the `.content`
    and `.comments` elements to the `left`. You can also `text-align:justify` them
    to make the text look like a block.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This CSS will make the padding on comments and embedded comments adjust to
    the changes in the browser window sizes. As a result, the comments section of
    your page will show the comment parent-and-child hierarchy, as well as a consistent
    and workable layout for each browser window size. You can see the code in action
    demonstrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/5442OT_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this responsive layout we used a few different techniques. First, the media
    query offers us limited but useful logic to deploy different layout techniques
    for different browser window sizes. Second, the fluid and floating elements with
    size ratios adjust with ease to the new layouts. And last but not least, fluid's
    percent-based padding gives a consistent ratio of padding to the screen size and
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: Changing image sizes with media queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to resize an image with a CSS media query.
    This can be useful in a number of situations, especially those where you want
    to download only one image and use it in different size versions in your responsive
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a good method for size variation that can be handled on the client side,
    but be careful not to abuse this method by causing the client to download a really
    large image file and do heavy resizing in their browser. There are better ways
    to do that, which were discussed in [Chapter 1](ch01.html "Chapter 1. Responsive
    Elements and Media"), *Responsive Elements and Media*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I recommend putting together a small HTML page with a `h1` title, the `wrap`
    element, and inside `wrap`, an image and a paragraph of text. You really don't
    need all of this extra stuff to make an image size change in an image query, however,
    it will help you demonstrate the use of changing an image size in the media query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create your media queries for the most frequent browser window size breakpoints:
    `960px`, `1024px`, `1280px`, `1366px`, `1440px`, and last but not least `1680px`.
    In each of these media queries, add your styles for the elements. In my example,
    I created media queries at `960px` and `1280px`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now as you resize your page you can see how the image resizes as the browser
    resizes through the various media queries. This is illustrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/5442OT_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The different media queries, when called by the browser, present different sizes
    for the element's `width` and `height` property. This allows you to optimize your
    image size for different devices. Use your judgment, and if the original image
    is too large, look into some server-side resizing as an alternate method.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding an element with media queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you some very useful tricks with media queries to make
    elements disappear off the screen, depending on the browser window's size. There
    are a few different methods of hiding an element on the screen, I will go through
    three of them in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This method can have a number of use cases. One very helpful case is using it
    to switch out menus on the fly when scaling a page down to a smaller device. You
    could also use this to change the way your content areas or aside contents are
    displayed. The possibilities are unlimited when you get creative with the methods.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Set up a simple page for demonstration. In my example, I wrote up a page with
    a `h1` header, an image, and then two elements with text inside them. Next, add
    some style to those elements. I added a different background color and width properties
    to each element, mostly, so that I could keep them apart when they disappeared.
  prefs: []
  type: TYPE_NORMAL
- en: And then add your media queries at a breakpoint. In the example, I'll add a
    breakpoint at `960px`. And inside the media queries, we're going to take a look
    at some different methods of getting the element to disappear.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your first media query, `max-width: 960px`, add the position: absolute and
    left: 5000px properties for the `img` element; This style will move the element
    far enough to the left of the screen that it has for all practical purposes, disappeared.
    Add to that media query a `display: none` style to the `.bar` element. This leaves
    the element where it is, but renders it invisible. Both of these elements are
    are effectively gone from the page, leaving only the title and `.foo` elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second media query, you will try a different way to remove an element
    from the screen. First, add the `.foo` element to the media query and give it
    a left margin of `5000px`. That removes it from the screen, however, the next
    element clears its vertical space and leaves an obvious white space where the
    element was. Then, float the element to the left and the white space will disappear.
    This is illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Congratulations! Open the project in your browser and see if it looks like
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/5442OT_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both the absolute position and float do not have a height property, so once
    applied to an element, they will not occupy any vertical space. This can be an
    especially useful trick to move elements around on your page. It can also cause
    some problems when you use floating elements for layout. This behavior can be
    fixed by inserting a break with a `clear:both` property after the element.
  prefs: []
  type: TYPE_NORMAL
- en: Making a smoothly transitioning responsive layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe I will guide you through the creation of a multi-zoned and responsive
    front page. This one will have a number of elements that are responsive in different
    ways; giving a rich user experience that delivers an impressive layout. I developed
    this for a startup I was working on and found that I liked it so much that I continued
    to develop it further to share with you in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will be a good template for a homepage to a content-heavy site.
    If you have been building content for a while, this will be perfect for the landing
    page, and can be modified for a single-item content page easily. If you are just
    getting started with your site, you can go get some generated text at [http://lipsum.com](http://lipsum.com)
    like I did for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This site breaks down into three HTML elements or a footer, and two elements
    that sometimes are vertical and sometimes are left and right floats—depending
    on the screen width. These elements themselves are also divided into smaller elements.
    So, get started and create a basic page with a top-wrap element, a middle-wrap
    element, and a footer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we start the CSS for these items. Add some basic CSS and the following
    media queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this basic layout, the `header` and `.content` rows both occupy `100%` of
    the page width, while the page is under `1280px`. When the page is larger, they
    occupy the respective `60%`/`40%` split and the float `left` and `right`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next let''s build the menus. This menu will employ a responsive trick of using
    a media query to hide and show two different menus. Essentially, we will build
    two different menus, and then use CSS to display the optimized one for each screen.
    The smallest version will use a multi-select drop-down menu, while the larger
    menu contains two inline lists. Here''s what the HTML looks like inside the top-wrap
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following CSS for the header elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This will display two different versions of the menu until we add to our media
    queries. Add media queries to switch between displaying the drop-down menu on
    small browser windows and the larger inline list menu on larger browser window
    sizes. Use the `display` property to show and hide the menus.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the menus, before the closing `</header>` tag create a space for a large
    high-quality photo to display on the site. And to prevent it from becoming a wasted
    space let''s put a search box right in the middle of it. We can actually make
    this search form stick closely to the center of the picture and responsively adjust
    to screen size changes. This is illustrated in the following simple code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: And of course the magic is in the CSS. Let's use some tricks to make the search
    form hover in the same spot. First give the outer `div` element a width of `100%`,
    then the `search` element will get an absolute position and few different properties
    under different media queries. This combination will keep the search form floating
    above the middle of the `img` area. Keep in mind that we are adding new CSS to
    the media queries. The following CSS code reflects only the additions, not what
    was already there. It gets rather long if I show the entire CSS expanding each
    time. At the end, I will include the entire CSS as it should be in its final state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `.img-search` image element will receive a dynamic width of `100%`, and
    auto height. And that's it for the large image search field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Give the next element, `.flip-tab`, a width of `100%`, and any height or other
    properties you want. You won''t have to worry about this again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The next element, `.teasers`, will get a `max-width: 1280px` property so it
    will auto-magically be at `100%` width of its parent element, `top-wrap`, limited
    to `1280px`. This element is simply a container for the three left-floating `.teaser`
    elements. These `.teaser` elements will have two different property sets under
    different media queries for a `600px` breakpoint.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'That concludes everything you will be doing in the `header` element. Up next
    is the `content` element, which wraps the content that will float in the right-hand
    side columns. What''s inside this element is nothing more than a two-column float
    split at a 60/40 ratio, or if the parent element is narrow, each is `100%` wide.
    The `content` element will have two different property sets under media queries
    with a breakpoint at `1280px`. These elements have some limited sample content.
    You can add much more once you deploy the layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This CSS is more complicated, but remember, you can access this entire work
    online. As you can see, the elements do zig and zag around a bit, but each breakpoint
    will have an optimized display.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the footer! (The end of the page!) The footer breaks down into a `100%`
    wide outer `<footer>`, and then a `footer-wrap` wrap with a `100%` width, `max-width`
    of `1280px`, dynamic side margins, and inline-block display. Inside are three
    elements that always have the property `display:inline-block`. When the display
    is small, these elements are each `100%` wide, otherwise they are `33%` wide,
    left-floating, with a minimum width of `144px`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As I promised previously, here is the full CSS code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This one was long and difficult; thanks for hanging in there! The effect is
    illustrated in the following screenshot, compare this with your output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/5442OT_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These CSS and media queries, when combined together, make a responsive footer
    that can stay centered through all the screen sizes, and collapse down for small
    mobile-sized browser windows.
  prefs: []
  type: TYPE_NORMAL
- en: Responsive layout is an exciting new area of web development methodology. The
    responsive methodology allows the designer and developer to create for multiple
    devices, especially mobile devices, without the expense of developing native apps.
    Very soon, if not already, you can expect many companies to want to take a responsive
    approach to their site redesigns.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You created a very simple method of responsive almost completely using CSS.
    I would challenge you to take this one step further by eliminating the dual menus
    in the `nav` element. Look in the *Adding JavaScript for mobile browsers only*
    recipe, in [Chapter 5](ch05.html "Chapter 5. Making Mobile-first Web Applications"),
    *Making Mobile-first Web Applications*, to add a jQuery method to replace the
    large menus with the `<select>` element in mobile browsers. This will prevent
    any potential search engine penalty from having duplicate content in the menus.
  prefs: []
  type: TYPE_NORMAL
- en: First, cut out the `smallMenu` div element and its children, and paste it somewhere
    in the header, or top of the body, inside a `<script> </script>` element as a
    variable, `smallMenu`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Next write the script that will be called to remove the `large-menu` div element
    and append to the `nav` element the `smallMenu` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now, when the page loads on a mobile device, the script will replace the navigation
    with a scaled-down mobile version, and you will not lose any sleep over your SEO!
  prefs: []
  type: TYPE_NORMAL
