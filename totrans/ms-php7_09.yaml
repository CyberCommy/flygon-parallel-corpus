- en: Reactive Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every so often, there is a shift in the software industry. A shift that enriches
    the ecosystem with ideas promising easier systems and application development.
    The driving force behind which is mostly the Internet nowadays, as it is a medium
    for all connected applications, not just those running in our browser. Majority
    of mobile users consume a large number of cloud services, without even realizing
    it. Ensuring consistent user experience in such a connected world is a challenge addressed
    in multiple ways. One such viewpoint is the reactivity, where programming language
    itself plays an important role.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, PHP follows the synchronous programming model and is not really
    fit for asynchronous programming. Although the standard library already has everything
    needed to write asynchronous I/O applications, the reality could not be far from
    different. Both MySQLi and MySQL (PDO), for example, remain blocking, making asynchronous
    programming with PHP useless. Luckily, the tides are shifting, and awareness about asynchronous
    is coming about with PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming is an emerging topic of the software industry that builds
    on top of observables as its primitive. We associate asynchronous behavior with
    it, as observables provide an ideal way to access asynchronous sequences of multiple
    items. On a higher level, it's just another programming paradigm, just as procedural,
    object-oriented, declarative, and functional programming are. While it requires
    a certain mind shift to adopt observables, operators, observers, and other building
    blocks, in return, it allows greater expressiveness and unidirectional data flow,
    leading to cleaner and simpler code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter,  we will take a closer look at the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Similarities with event-driven programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using RxPHP:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing RxPHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observable and observer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subject
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing custom operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-blocking I/O
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using React:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React event loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observable and event loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarities with event-driven programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Wikipedia defines reactive programming as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A programming paradigm oriented around data flows and the propagation of change."'
  prefs: []
  type: TYPE_NORMAL
- en: 'The very first thought of this may imply some similarities to a well-known
    event-driven programming. The data flows and the propagation of change sound a
    bit like something we may implement via the `\SplSubject`, `\SplObjectStorage`,
    and `\SplObserver` interfaces in PHP, as per the following trivial example. The
    `\SplObjectStorage` interface further encapsulates the `\Countable`, `\Iterator`,
    `\Traversable`, `\Serializable`, and `\ArrayAccess` interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We may say that data flows translate to a sequence of updates coming from the `$userRegister`
    instance's `notify()` method, the propagation of change translates to triggering
    the `update()` method of the mailer and logger instances, and the `\SplObjectStorage` method
    plays an important role This is just a trivial and superficial interpretation
    of the reactive programming paradigm in the context of the PHP code. Furthermore,
    there is no asynchronicity here at the moment. The PHP runtime and standard library
    effectively offer all that is needed to write asynchronous code. Throwing in a
    *reactivity* in the mix, is merely a matter of choosing the right library.
  prefs: []
  type: TYPE_NORMAL
- en: While the choice of PHP libraries for reactive programming isn't nearly as rich
    as those of the JavaScript ecosystem, there are a few noteworthy ones, such as **RxPHP** and **React**.
  prefs: []
  type: TYPE_NORMAL
- en: Using RxPHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Originally developed by Microsoft for the .NET platform, a set of libraries
    named **ReactiveX** (**reactive extensions**) is available at [http://reactivex.io](http://reactivex.io). ReactiveX
    allows us to write asynchronous and event-based programs using observable sequences.
    They do so by abstracting away low-level concerns such as non-blocking I/O, which
    we will talk about later. Over time, several programming languages made their own
    implementations of ReactiveX, following a nearly identical design pattern. The
    PHP implementation, named RxPHP, can be downloaded from [https://github.com/ReactiveX/RxPHP](https://github.com/ReactiveX/RxPHP):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2e6cd07e-5278-44a0-bf41-28da819dc572.png)'
  prefs: []
  type: TYPE_IMG
- en: Installing RxPHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The RxPHP library is available as a Composer `reactivex/rxphp` package. Assuming
    we already installed PHP and Composer, we can simply execute the following command
    in an empty directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us an output similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fd7135e9-4256-4fe9-9950-72f5b86a3c0e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The output suggests installing `react/event-loop`; we need to be sure to follow
    up on that by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us an output much like the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8627f3dc-2c79-4815-babe-131e0476128d.png)'
  prefs: []
  type: TYPE_IMG
- en: All that remains now is to create an `index.php` file, which includes `autoload.php` file
    generated by Composer, and we are ready to start playing with
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ccd5737a-95a9-4f41-be15-b8026849479e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The RxPHP library is comprised of several key components, the most basic ones
    being the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Observable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subject
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving forward, let's take a closer look at each of these components.
  prefs: []
  type: TYPE_NORMAL
- en: Observable and observer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our introduction example, we touched upon the observer pattern using `\SplSubject`
    and `\SplObserver`. Now, we are introducing an RxPHP observable and observer component.
    We might say that `\SplSubject` is analogous to `Rx\Observable`, whereas `\SplObserver`
    is analogous to `Rx\Observer\CallbackObserver`. The whole SPL and Rx, however,
    are only superficially analogous. `Rx\Observable` is more powerful than `\SplObserver`.
    We can think of `Rx\Observable` as a lazy source of event, a thing that produces
    value over time. Observables emit the following three types of events to their
    observers:'
  prefs: []
  type: TYPE_NORMAL
- en: The current item in the stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The error, if one occurred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The complete state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a nutshell, it is a reactive data source that knows how to signal internal
    data changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of which is as :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We see that the `subscribe()` method of the `Observable` instance accepts an
    instance of `CallbackObserver`. Each of the three parameters of an observer is
    a callback function. The first callback handles the stream item, the second returns
    potential error, and the third indicates a completed stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'RxPHP provides few a type of observables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AnonymousObservable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ArrayObservable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConnectableObservable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EmptyObservable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ErrorObservable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ForkJoinObservable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GroupedObservable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntervalObservable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IteratorObservable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MulticastObservable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NeverObservable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RangeObservable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RefCountObservable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReturnObservable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimerObservable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at a more elaborate example of observable and observer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating a simple generator function called `users()`. The
    great thing about generators is that they act as iterator, which makes it easy
    to create RxPHP observables from them using the `fromIterator()` method. Once
    we have the observable, we can chain few of its methods, such as `map()` and `filter()`,
    together. This way, we control the data stream hitting our subscribed observer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume the `users.csv` file with following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code should be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s assume that we want to attach multiple observers to our `$users`
    stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This won''t work. The code won''t throw any error, but the result might not
    be what we would expect it to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We cannot really attach multiple subscribers this way. The first attached observer
    consumes the stream, which is why the second observer sees it empty. This is where
    the `Rx\Subject\Subject` component may come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Subject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Rx\Subject\Subject` is an interesting component--it''s a class that acts both
    as observable and observer. The benefit of this is seen in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the anonymous classes, we were able to extend the `Rx\Subject\Subject` class
    on-the-fly. The underlying `onCompleted()`, `onError(Exception $error)`, and `onNext($value)`
    methods are where we *tap into* our observer-related logic. Once executed, the
    code results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'What is happening here is that the mailer first taps into the stream, and then
    streams back into the logger stream. This is possible because of the dual nature
    of `Rx\Subject\Subject`. It is important to note that the logger does not observe
    the original stream. We can test this easily by adding the filter to `$mailer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output will now omit the user named on the logger observer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The observable model of RxPHP allows us to treat streams with simple and composable
    operations. Each of these operations is done by an individual operator. The composition
    of operators is possible because operators themselves mostly return observable
    as a result of their operation. A quick peek into the `vendor\reactivex\rxphp\lib\Rx\Operator`
    directory reveals 48 different operator implementations, classified in several
    different categories
  prefs: []
  type: TYPE_NORMAL
- en: Creating o
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error-handling operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observable utility operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional and Boolean operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mathematical and aggregate operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connectable observable operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `map`, `filter`, and `reduce` methods are likely the most known and popular operators,
    so let''s start our example with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We started off by writing a simple generator function called `xrange()`. The
    beauty of the generator here is that the `xrange()` function will always take
    the same amount of memory, regardless of the range we choose. This gives us a
    great foundation to play with the ReactiveX operators. We then created a simple `$observer`,
    utilizing only its `$onNext` callable whilst ignoring the `$onError` and `$onCompleted` callables
    for the purpose of this section. We then created an observable stream from our `xrange()`
    function, passing it a range of 1 to 20. Finally, we got to the point where we
    hooked the `map()`, `filter()`, `reduce()`, and `subscribe()` method calls to
    our observable instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to execute this code now, the resulting output would be number `36`.
    To understand where this is coming from, let''s take a step back and comment out
    the `filter()` and `reduce()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output now is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `map()` function transforms the emitted items by applying a function to
    each item. In this case, that function is `$item * 2`. Now, let''s go ahead and
    restore the `filter()` function, but leave the `reduce()` function commented out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Knowing now that the `filter()` function will receive the `map()` function
    output stream (`2`, `4`, `6`, ... `20`), we observe the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `filter()` function transforms the emitted items by emitting back only those
    items that pass a predicate test. In this case, the predicate test is `$item %
    3 == 0`, which means, it returns items evenly divisible by `3`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if we restore the `reduce()` function, the result comes back as `36`.
    Unlike `map()` and `filter()`, which accept a single emitted item value, the `reduce()` function
    callback accepts two values.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick change to the body of the `reduce()` callback clarifies what''s going
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can see that `$x` comes in as a value of the first emitted item, whereas
    `$y` comes in as a value of the second emitted item. The function then applies
    sum computation on them, making the return result now a first emitted item in
    the second iteration, basically, giving `(6 + 12) => 18 => (18 + 18) => 36`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the sheer number of operators supported by RxPHP, we can imagine the
    real-life complexities we get to solve in an elegant way by simply composing a
    number of operators into a chain, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If existing operators are not enough, we can easily write our own by extending `Rx\Operator\OperatorInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing custom operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Though RxPHP provides over 40 operators for us to use, sometimes, there may
    be a need to use an operator that does not exist. Consider the following case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing this code with the *correct* `$users` variable gives us the following
    expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/adcac991-4be4-46cb-a8f4-d86272baeac5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, if we were to remove the comment in front of the *faulty* `$user`
    variable, the output comes out slightly unexpected, or at least not how we would
    like to handle it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/de247ab0-2353-4b00-bf0e-705febf72d38.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What we really want is to shift the unserialize logic into the RxPHP operator,
    and have it gracefully handle the unsuccessful `unserialize()` attempts. Luckily,
    writing a custom operator is an easy task. A quick look into the `vendor/reactivex/rxphp/src/Operator/OperatorInterface.php` file
    reveals the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Easy enough, the interface only requires a single `__invoke()` method implementation.
    We wrote about the `__invoke()` method extensively in [Chapter 4](d96bd098-e569-4ac7-ba7e-47ad24e3bbfb.xhtml),
    *Magic Behind Magic Methods*. This method gets called when we try to call an object
    as a function. `OperatorInterface`, in this case, lists three arguments to the `__invoke()`
    method, two of which are mandatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$observable`: This will be our input observable to which we subscribe'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$observer`: This is where we will emit our output value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With that in mind, the following is an implementation of our custom `UnserializeOperator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, we cannot chain our operator directly as we chain the RxPHP
    operators. We need to help ourselves with the `lift()` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With `UnserializeOperator` in place, the faulty serialized `$users` string
    now gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/540a7acd-603e-456b-bd8b-8d5eb4af2f0c.png)'
  prefs: []
  type: TYPE_IMG
- en: Our operator is now successfully handling errors, in that, it is delegating
    them onto the observer `onError` callback.
  prefs: []
  type: TYPE_NORMAL
- en: Making the best out of RxPHP is mostly about knowing the ins and outs of its
    operators. The `vendor/reactivex/rxphp/demo/` directory provides quite a few operator
    usage examples. It is worth spending some time going through each.
  prefs: []
  type: TYPE_NORMAL
- en: Non-blocking IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the RxPHP extensions opens up quite a few possibilities. Its observables,
    operators, and subscribers/observers implementations are certainly powerful. What
    they don't provide, however, is asynchronicity. This is where the React library
    comes into play, by providing an event-driven, non-blocking I/O abstraction layer.
    Before we touch upon React, let's first lay out a trivial example of blocking
    versus non-blocking I/O in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: We create a small *beacon* script that will merely generate some **standard
    output** (**stdout**) over time. Then, we will create a script that reads from
    the **standard input** (**stdin**) and see how it behaves when reading is done
    in the stream blocking and stream non-blocking mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating the `beacon.php` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The use of `$argv[1]` hints that the file is intended to be run from console.
    Using `$argv[1]`, we provide a number of seconds we wish the script to run. Within
    the loop, we have a signal... output, followed by a short `0.2` seconds of script
    sleep.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our beacon script in place, let''s go ahead and create `index.php` file
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Aside from two obvious start/end outputs, we utilize the `fgets()` function
    to read from the standard input.  `stream_set_blocking()` method is deliberately
    left commented out for the moment. Notice that the two scripts are completely
    unrelated to each other. At no point is `index.php` referencing the `beacon.php`
    file. This is because we will use the console and its pipe (`|`) to bridge the
    stdout of the `beacon.php` script to a stdin consumed by the `index.php` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/24b412d5-df8a-41c2-ae3f-f34d9cb535ad.png)'
  prefs: []
  type: TYPE_IMG
- en: There is nothing wrong with this output; this is what we expected. We first
    see the start string showing up, then several occurrences of signal..., and finally,
    the end string. However, there lies the catch, all of the signal... bits that
    are pulled by the `fgets()` function from stdout are an example of blocking IO.
    While we might not perceive it as such in this small example, we could easily
    imagine a beacon script sending output from a very large file, or a slow database
    connection. Our `index.php` script would simply hang its execution blocked during
    that time, or, better to say, it would wait for the `while (($line = fgets(STDIN)...`
    line to resolve.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we resolve the problem? First, we need to understand that this is not
    really a technical problem as such. There is nothing wrong with waiting to receive
    data. No matter how much we abstract things, there will always be that someone or
    something who needs to wait for data somewhere. The trick is positioning the somewhere bit
    at the right place, so it does not stand in the way of user experience. The JavaScript
    promises and callbacks are one example of where we may want to place that somewhere.
    Let''s take a look at the simple AJAX call made by the JavaScript jQuery library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the resulting output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dec130cd-c357-416b-a618-5395b5c1c72d.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice how `start-time` and `end-time` have been outputted before the `result-time`.
    The JavaScript did not block the execution at the `$.ajax({...` line, like PHP
    did on its `while (($line = fgets(STDIN)...` line in the preceding example. This
    is because JavaScript runtime is fundamentally different than PHP. The asynchronous
    nature of JavaScript relies on the chunks of code to split off and execute separately,
    then update what's needed via the callback mechanism, a functionality made possible
    by JavaScript event loop based concurrency model and message queue mechanism.
    The callback in this case was the anonymous function assigned to the success property
    of the `ajax()` method call. Once the AJAX call executed successfully, it called
    the assigned `success` function, which in turn resulted last on the output as
    the AJAX call takes time to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s go back to our little PHP example and modify the `index.php` file by
    removing the comment we placed in front of the `stream_set_blocking(STDIN, 0);`
    expression. Running the command again, with the pipe (`|`) this time, now results
    in the output much like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4c4e8bb4-7afb-408d-b467-b8ea55b2acc4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This time, the `while (($line = fgets(STDIN)...` line did not block the execution
    by waiting for `beacon.php` to finish. The trick lies in the `stream_set_blocking()`
    function, as it enables us to control the stream blocking mode, which by default
    is set to block I/O. Let''s go ahead and make a more PHP-like example, this time
    without using the console pipe. We will leave the `beacon.php` file as it is,
    but modify the `index.php` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We started off with a `proc_open()` function, which allows us to execute a
    command and open file pointers for standard input, output, and error. The `''php
    beacon.php 2''` argument does pretty much what our console command did, in regards
    to the part of command left of the pipe character. The way we catch an output
    of beacon script is using the `fgets()` function. However, we are not doing it
    directly, we are doing it through the while loop here, whereas the condition is
    the process `running` state. In other words, as long as the process is running,
    check whether there is any new output from the newly created process or not. If
    there is an output, show it; if not, show the --- beacon lost --- message. The
    following screenshot shows the resulting output with default (blocking) I/O:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4a9d00b2-7ccb-4731-b79f-7ed3a6eb0252.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we now remove the comment in front of `stream_set_blocking($pipes[1], 0);`,
    the resulting output changes into this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/502a795f-e386-41f8-b9d8-4862cd4f2a27.png)'
  prefs: []
  type: TYPE_IMG
- en: The output here shows the non-blocking relationship between the beacon and our
    running script. Unblocking the stream, we were able to utilize the `fgets()` function,
    which would normally block the script to periodically check on the standard input for
    as long as the process is running. In a nutshell, we are now able to read the
    output from a sub-process, while being able to initialize a few more of the sub-processes
    along the way. Although the example itself is a long-long way from the convenience
    of the jQuery promise/callback example, it is a first step towards the complexities
    behind blocking and non-blocking I/O, as it affects the way we write our code.
    This is where we will come to appreciate the role of the RxPHP observables and
    React event loops.
  prefs: []
  type: TYPE_NORMAL
- en: Using React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React is a library that makes it possible to event-driven programming in PHP,
    much like JavaScript does. Based on the reactor pattern, it essentially acts as
    an event loop, allowing various other third-party libraries using its components
    to write asynchronous code.
  prefs: []
  type: TYPE_NORMAL
- en: The page at [https://en.wikipedia.org/wiki/Reactor_pattern](https://en.wikipedia.org/wiki/Reactor_pattern)
    states, *The reactor design pattern is an event handling pattern for handling
    service requests delivered concurrently to a service handler by one or more inputs*.
  prefs: []
  type: TYPE_NORMAL
- en: The library is available at [https://github.com/reactphp/react](https://github.com/reactphp/react)
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f69decec-31c7-445e-920e-3c45c3e22e7f.png)'
  prefs: []
  type: TYPE_IMG
- en: Installing React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The React library is available as a Composer `react/react` package. Assuming
    we are still in our project directory where we installed RxPHP, we can simply
    execute the following command in order to add React to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us an output similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/58f88a2d-ef96-4ca2-b052-662c17135a41.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see quite a few interesting `react/*` packages being pulled in, `react/event-loop` being
    one of them. The messages suggesting we should install one of the more performant
    loop implementations are definitely worthy of interest, though out of the scope
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: React event loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Without any of the suggested event loop extensions, React event loop defaults
    to the `React\EventLoop\StreamSelectLoop` class, which is a `stream_select()`
    function-based event loop.
  prefs: []
  type: TYPE_NORMAL
- en: The page at [http://php.net/manual/en/function.stream-select.php](http://php.net/manual/en/function.stream-select.php)
    states, *The stream_select() function accepts arrays of streams and waits for
    them to change status*
  prefs: []
  type: TYPE_NORMAL
- en: As we already saw in our previous examples, making an event loop in React is
    simple
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the `Factory::create()` static function, which is implemented
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that unless we have `ext-libevent`, `ext-event`, or `ext-libev` installed,
    then the `StreamSelectLoop` implementation is used.
  prefs: []
  type: TYPE_NORMAL
- en: Each iteration of the loop is a tick. The event loop tracks timers and streams.
    Without either of these two, there are no ticks, and the loop simply
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0c81eb9e-fdaf-4494-98d2-08934a6ff4a9.png)'
  prefs: []
  type: TYPE_IMG
- en: As soon as we add some timers, the situation ch
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/48487a6d-646b-4b0a-ac55-4e0520019a7c.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice the order of the timer output, and the time next to each. Our loop still
    managed to end, as our timers expired. To keep the loop running constantly, we
    can add a *periodic timer*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bee357c9-0bb1-42c3-b5bd-146eb5cb191b.png)'
  prefs: []
  type: TYPE_IMG
- en: This loop will now continue to produce the same timer... output until we hit *Ctrl*
    + *C* on the console. We might be wondering, how does this differ from a PHP `while`
    loop? Generally, the `while` loop is of polling type, as it continuously checks
    things, leaving little to no room for the processor to switch tasks. The event
    loop uses more efficient interrupt-driven I/O instead of polling. However, the
    default `StreamSelectLoop` uses the `while` loop for its event-loop implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The addition of timers and streams is what makes it useful, as it abstracts
    the hard bits from us.
  prefs: []
  type: TYPE_NORMAL
- en: Observables and event loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and see how we can make our observables work with an event
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There is quite a lot going on here. We started off by creating a standard input
    and then flagging it as non-blocking. We then created the observer of the `Subject`
    type. This is because, as we will see later, we want our observer to behave like
    observer and observable. We then instantiated the loop, and passed onto `EventLoopScheduler`.
    In order for observables to work with the loop, we need to wrap them with a scheduler.
    We then used the instance of `IntervalObservable`, making its `map()` operator
    read the standard input, whereas the `filter()` operator was set to filter out
    any empty inputs (pressing Enter key on console with no text). We stored this
    observable into a `$disposable` variable. Finally, given that our `$observer`
    was an instance of `Subject`, we were able to attach the `filter()` operator to
    it as well as `subscribeCallback()`. We instructed the `filter()` operator here
    to only filter out the input with the quit string. Once `quit` was typed onto
    the console, followed by the *Enter* key,  `subscribeCallback()` was executed.
    Within `subscribeCallback()`, we have a `$disposable->dispose()` expression. Calling
    the disposable's dispose method automatically unsubscribed  `$observer` from  `$observable`.
    Given that there were no other timers or streams within the loop, this automatically
    terminated the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the console output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/39aa8f7d-4f9a-4c4c-920f-9f8a202dc1c9.png)'
  prefs: []
  type: TYPE_IMG
- en: When the code was run, we first saw the `start` string, then we typed in `John` and
    press , then we say $observer.onNext..., which repeated all the way until we typed `quit`.
  prefs: []
  type: TYPE_NORMAL
- en: The React event loop opens an interesting possibility for us, much like we are
    used to seeing in JavaScript and browser. While there is much more to be said
    about React, this should be enough to get us started with RxPHP and React combination.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we touched upon RxPHP and React, the two libraries that promise
    to bring reactive programming to PHP. While RxPHP brings the powerful  observables
    packaged in composable-looking syntax, React enriches our experience with event-loop
    implementation. To carefully, we should emphasize that this is still a relatively
    experimental area for PHP, and far from ready for mainstream production use. It
    does, however, demonstrate that PHP is not limited with its runtime capabilities
    and shows promise in the reactive area.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we will shift our focus on common design patterns found in modern
    PHP applications.
  prefs: []
  type: TYPE_NORMAL
