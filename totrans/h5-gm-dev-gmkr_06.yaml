- en: Chapter 6. Toppling Towers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the rest of the book we are going to focus on creating a single game from
    concept to a completed, released product. We will be utilizing everything we have
    learned so far and will be introduced to a variety of additional features, such
    as GameMaker: Studio''s physics and particle systems. We will build some more
    systems to allow character dialog and an inventory. Finally, we will look at the
    different ways to release the game, including onto Facebook.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we are going to build a physics-based tower toppling game that
    will demonstrate GameMaker: Studio''s implementation of the Box2D open source
    physics engine. It will feature towers made out of a variety of different materials,
    such as glass, wood, and steel. The goal of the game will be to clear a restricted
    zone by destroying these towers utilizing a variety of tools. We will create TNT
    that will blast outwards, a Wrecking Ball that will swing down, and a Magnet that
    will attract loose parts. Best of all, all the collision and movement will be
    done by the engine itself!'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the physics engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building a physics-based game, it requires a different way of thinking
    about how you go about creating things. So far, we have focused on applying movement
    to an instance by either teleporting it via the X/Y coordinates, or by changing
    the `speed`, `vspeed`, and `hspeed` variables. When we use the physics engine,
    these properties are ignored. Instead, the system itself deals with movement by
    applying a force onto the instance. That instance will react to the force based
    on its own properties and will act accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the direction of the world coordinates is not the same in physics
    world. Zero degrees in the GameMaker standard physics world indicates a direction
    of right, whereas in the Box2D physics world, zero degrees indicates up, as can
    be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the physics engine](img/4100OT_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To fully understand how the Box2D physics engine works, we need to take a look
    at the following four components that it is comprised of:'
  prefs: []
  type: TYPE_NORMAL
- en: The physics world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixtures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activating the world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Much like the real world, the physics world starts with the application of gravity.
    The amount of gravity will determine how fast the objects will fall and how much
    force is necessary to counteract it. Before we can use any of the physics functions
    in a game, we need to activate the world physics.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start a new project called `Chapter_06`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Room, and name it `Sandbox`. We will use this Room for testing
    purposes only.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **physics** tab and check **Room is Physics World**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Physics World Properties:**, set **Gravity:** to **X:** `0.0` and **Y:**
    `20.0`. This will set the direction and strength of the gravity in the world.
    If you wanted to have gravity as it is on Earth, we would set the value to **Y:**
    `9.8`. We are setting it to `20.0`, so objects appear to fall faster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, there is an option to set **Pixels To Meters:**. The entire physics
    system is based on real-world measurements, so we need to determine how many real-world
    meters are represented by a single pixel so that the calculations are accurate.
    We will leave this at the default value of 0.1 meters per pixel, or about 10 centimeters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The world is now ready to use the physics engine! The physics settings of the
    room should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Activating the world](img/4100OT_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Defining properties with fixtures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order for something to be affected by gravity and other such forces, an
    object requires a **Fixture**. A Fixture is what defines the shape and properties
    of a physics object. We will need to build two Objects: a Ground object that will
    never move, and a Steel Pillar which will react to gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by creating the Ground object. Create a new Sprite, `spr_Ground`,
    and load `Chapter 6/Sprites/Ground.png` with **Remove Background** unchecked.
    Leave **Origin** at **X**: `0`, **Y**: `0`, and click on **OK**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Ground`, and assign `spr_Ground` as the Sprite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to make this object responsive in the physics engine, we need to check
    **Uses Physics**. This will display **Physics Properties** as shown in the following
    screenshot:![Defining properties with fixtures](img/4100OT_06_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first element we need to set up is **Collision Shape**. There are three
    options to choose from: **Circle**, **Box**, and **Shape**. The most common shape
    is **Box**, which just has four points and is always in a rectangular form. The
    **Circle** shape is useful for perfectly round objects as it is determined by
    a radius, thus not useful for round shapes like an egg. **Shape** is the most
    useful option in that you can have up to eight points of collision. One drawback
    for this is that all shapes must be convex, or it will not work. See the following
    screenshot to better understand what is acceptable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining properties with fixtures](img/4100OT_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Ground is a rectangular object, so in **Collision Shape** under **Physics
    Properties**, select **Box**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default shape will be created with its starting point based on the origin
    of the Sprite, which in this case is in the upper-left corner. That means we will
    need to either adjust the **Origin**, or the **Physics Shape** to make it fit
    properly. For this object we will do the latter. Click on **Modify Collision Shape**
    to open the **Physics Shape** editor. Place the points so that they are correctly
    positioned on the sprite, as seen in the following screenshot, and then click
    on **OK**.![Defining properties with fixtures](img/4100OT_06_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that the shape is complete, we can set the other physics properties. There
    are six adjustable properties available to us here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Density**: This represents the mass of the Object per unit of volume. You
    can think of this as how heavy an object is compared to its overall size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Restitution**: This represents how bouncy an object is. Higher the number,
    more bounce the object will have on collision. This does not mean that the shape
    of the object will deform. It won''t as this is a rigid body physics simulation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collision Group**: These groups help simplify what objects can collide with
    each other. A positive number here will mean that all objects within that group
    number will always collide. A negative number means that the objects in that group
    number never collide with each other. If set to zero, a collision event will need
    to be placed into each object in order for it to collide. Using groups should
    be kept to a minimum, as it will dramatically increase processing time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linear Damping**: This represents the reduction of velocity of an object
    in motion. You can think of it as air friction as the object does not need to
    be in contact with any other object to slow down.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular Damping**: Much like **Linear Damping**, this is the reduction of
    rotational movement of an object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Friction**: Friction is the force that acts opposite to a moving object during
    collision. This works in a similar fashion to **Linear Damping** in that it slows
    down objects. The difference is that it requires a collision to occur.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different materials in the real world will have different values for each of
    these properties. There are many charts available that will show values for many
    types of materials, such as steel that has a density of 7,820 kilograms per cubic
    meter, and has a friction coefficient of 0.78 when touching other steel. Trying
    to think of all these values as they correspond to objects in a game can quickly
    become overwhelming. Luckily, games don't need to use real-world values, but instead
    we can use general concepts for the materials, such as steel has a high density
    while ice has a low density. Below is a chart with some basic concepts for how
    we need to treat the values for **Density**, **Restitution**, and **Friction**.
    For **Linear Damping** and **Angular Damping** it is a bit trickier, as they relate
    more to the shape of an object. For example, a round steel pin would have less
    **Angular Damping** than a square steel pin. All of these materials, whatever
    we set the values to, should always be tweaked until they feel correct for the
    game they are in. It is completely valid for a metal bar to have a density of
    three in one game and 300 in another, so long as it acts as the developer intends.
  prefs: []
  type: TYPE_NORMAL
- en: '| Material | Density | Restitution | Friction |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Steel | High | Low | Medium |'
  prefs: []
  type: TYPE_TB
- en: '| Glass | Low | Medium | Low |'
  prefs: []
  type: TYPE_TB
- en: '| Wood | Medium | Medium | Medium |'
  prefs: []
  type: TYPE_TB
- en: '| Rubber | Medium | High | Medium |'
  prefs: []
  type: TYPE_TB
- en: '| Stone | High | Low | High |'
  prefs: []
  type: TYPE_TB
- en: As this Ground is intended to never move or feel the effects of gravity, we
    need to set **Density** to `0`. When an object has no density it is considered
    to be a static object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don't want the Ground to be bouncy, so set **Restitution** to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will leave **Collision Group** at the default `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the object isn't moving, we might as well set **Linear Damping** and **Angular
    Damping** to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we do want objects to come quickly to a stop on the ground, so let's
    set **Friction** to `1`. We are done with `obj_Ground`, so click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will make the Steel Pillar. Create a new Sprite, `spr_Pillar_Steel`,
    and load `Chapter 6/Sprites/Pillar_Steel.png` with **Remove Background** checked.
    Center the origin and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Pillar_Steel`, and set `spr_Pillar_Steel` as its **Sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the box for **Uses Physics**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Collision Shape** under **Physics Properties**, select **Box**. As we placed
    the origin into the center of the Sprite, the shape should be correctly conformed
    to the Sprite so that we do not have to modify it. However, we should always open
    the **Physics Shape** editor to ensure that it is properly located to prevent
    any major issues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want this object to be fairly heavy, so set **Density** to `20`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Steel Pillar shouldn't be very slick either, so set **Friction** to `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set all the other properties to `0`, as we do not want to slow this object or
    have it bounce. We have now finished setting the properties of this object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The only thing we have left to do is to add an `obj_Ground` event. As can be
    seen in the next screenshot, we don't need any code, we just need a comment. Drag
    a **Comment** from the **Controls** tab under **Actions:** and write `Collide
    with Ground`. With this little trick the Pillar will now have active collision
    with the Ground.![Defining properties with fixtures](img/4100OT_06_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reopen the `Sandbox` room and place an instance of `obj_Pillar_Steel` somewhere
    near the top in the center horizontally. Also, place instances of `obj_Ground`
    along the bottom with one additional instance located right above the floor and
    just slightly under where the Steel Pillar will fall, as seen in the following
    screenshot. To move an instance freely in the **Room Properties** editor, hold
    down the *Alt* key while holding down the left mouse button.![Defining properties
    with fixtures](img/4100OT_06_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. The Steel Pillar should fall down and collide with the little
    stump on the ground. It should then fall over onto its side and come to a rest.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have just completed our first physics simulation! Let's now take a look at
    Joints.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting objects with Joints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are times when we will want two or more objects to be constrained to
    each other, such as a chain, or a ragdoll body. In the physics engine it is achieved
    through the use of **Joints**. There are five different types of Joints that we
    can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Distance Joints**: These will keep two instances connected at a set distance
    apart from each other. For example, a wheelbarrow would have a Distance Joint
    to keep the front wheel a set distance away from the handles, no matter how it
    is pushed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Revolute Joints**: These will rotate one instance around another. For example,
    a door hinge is a Revolute Joint that rotates a door around the door frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prismatic Joints**: These will allow one instance to move in a single direction
    relative to another. For example, a pinball plunger would have a Prismatic Joint,
    as it can only pull back or push forward into the machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pulley Joints**: These will allow one instance to influence another in relation
    to its movement. For example, a set of scales uses a Pulley Joint to weigh things.
    If it is heavier on one side it will go down, while the other side would go up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gear Joints**: These will affect the movement of one instance based on the
    rotation of another. For example, the spinning reel of a fishing rod is a Gear
    Joint; when it is rotated it will pull in the fish.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at how Joints work by creating a simple chain that is attached
    to an Anchor.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by building the anchor, which will be a stationary static object
    in the world. Create a new Sprite, `spr_Anchor`, and load `Chapter 6/Sprites/Anchor.png`
    with **Remove Background** checked. Center the origin and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Anchor`, and set `spr_Anchor` as the Sprite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the box for **Uses Physics** and change the **Collision Shape** to **Box**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Density** and **Restitution** to `0`. We can leave the other properties
    at the default values and it should look like the following screenshot:![Connecting
    objects with Joints](img/4100OT_06_31.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to create the Chain Links. Create a new Sprite, `spr_ChainLink`,
    and load `Chapter 6/Sprites/ChainLink.png` with **Remove Background** checked.
    Center the origin and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_ChainLink`, and set `spr_ChainLink` as the **Sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the box for **Uses Physics** and change the **Collision Shape** to **Box**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want the Chain to be quite strong and heavy, so set **Density** to `50`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Chain should not stretch and swings freely, therefore we need to set the
    **Restitution**, **Linear Damping**, **Angular Damping**, and **Friction** to
    `0`. The final settings should look like the following screenshot:![Connecting
    objects with Joints](img/4100OT_06_32.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The component parts are now complete; we will just need to build the entire
    Chain and attach it to the Anchor. Create a new Script, `scr_Anchor_Create`, write
    the following code, and add this to a **Create** event in `obj_Anchor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To build the Chain we run a loop starting to create nine links of the Chain.
    We start the loop at `1` so that the Chain is offset correctly. We use a basic
    one-dimensional array to store the ID of each Chain Link, as we will need this
    when we add the joints. The `x` offset we have in the creation will create each
    link an equal distance apart horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to apply a Revolute Joint to the first link of the Chain. After
    the previous code, add:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by creating a Revolute Joint from the anchor to the very first Chain
    Link. The rotation will occur around the Anchor''s X and Y axes. The next three
    parameters relate to the limitations of the rotation: the minimum and maximum
    angles of rotation, and whether these limits are active. In this case we don''t
    care, so we have turned off any angle limitation. The following three parameters
    are for whether the joint will rotate on its own or not, with values for the maximum
    speed, the set speed, and whether it is active. Again, we have turned it off so
    the Chain will just hang in the air. The last parameter is for whether the Anchor
    can collide with the Chain, and we do not want that to occur here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the first link attached, let''s join the rest of the Chain
    together. Still in the same script, at the end add:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here we are using a loop again, so that we can go through each link and attach
    the one that follows. Notice that the loop stops at `9`, as we have already connected
    one piece of Chain. In the case of the Chain, we don't want each Link to have
    full freedom of rotation. We have activated the rotational limit and set it to
    20 degrees in either direction.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a small Chain attached to an anchor. Let's add it to the world.
    Reopen the `Sandbox` and add a single instance of `obj_Anchor` near the top of
    the room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. The Anchor should remain at the top of the room with the Chain
    Links extending out to the right of it. The Chain will fall due to the gravity
    in the room, though each link will remain attached to the one above it, with the
    top link still attached to the Anchor. It should look something like the following
    screenshot:![Connecting objects with Joints](img/4100OT_06_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Applying forces to objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to move an object in the physics world, excluding movement due to gravity,
    it requires that a **Force** be applied to it. These forces can be applied from
    a point in the world or locally to the instance. How the object reacts to the
    force depends on the properties it has. Just like the real world, the heavier
    the object, the more force is required to move it.
  prefs: []
  type: TYPE_NORMAL
- en: In order to take a look at Forces we are going to create TNT, which will explode,
    shooting out eight fragments. These fragments will be very dense and will require
    a lot of force to make them move.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the fragments first. Create a new Sprite, `spr_TNT_Fragment`,
    and load `Chapter 6/Sprites/TNT_Fragment.png` with **Remove Background** unchecked.
    Center the origin and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_TNT_Fragment`, and assign `spr_TNT_Fragment` as the
    **Sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the box for **Uses Physics** and change **Collision Shape** to **Box**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Density** to `10`. We are making this value very high, so that when
    it collides with objects, such as the Steel Pillar, it will be able to move it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set all remaining properties to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we need several fragments to shoot out from the TNT, we need to be able
    to control the direction in which it is going to move. Therefore, we need to establish
    some variables. Create a new Script, `scr_TNT_Fragment_Create`, with the following
    variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The strength and direction of a force is determined by a vector, which is why
    we need X and Y variables. We have set it to zero, so that it is not moving by
    default. Don't forget to apply this to a **Create** event in `obj_TNT_Fragment`.
  prefs: []
  type: TYPE_NORMAL
- en: As these fragments are meant to represent an explosion, we will want to constantly
    apply force to them, so that they aren't overly affected by gravity. Create a
    new Script, `scr_TNT_Fragment_Step`, and apply some force. Add this script to
    a **Step** event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The function `physics_apply_force` is a world based force, with the first two
    parameters representing where in the world the force is coming from, and the second
    two parameters being the vector of force to be applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, these fragments will never stop moving, which is a problem. We are
    going to want to limit how far they can move outwards. Add the following code
    at the end of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: All we are doing here is checking to see if the Fragment has moved more than
    128 pixels from where it was created. If it has, we remove it from the world.
  prefs: []
  type: TYPE_NORMAL
- en: We want these fragments to collide with some of the other elements in the game.
    At the same time, we don't want them to go through anything, so we will destroy
    them. Create a new Script, `scr_TNT_Fragment_Collision` and remove the instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Add an `obj_Ground` event and add this script. This will remove the Fragment
    if it hits the Ground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want it to affect the Steel Pillar, but since we are planning on creating
    many more types of Pillars, let's build a parent object for the Pillars for collision
    detection. Create a new Object, `obj_Pillar_Parent`. This is all that it needs
    for now, so click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reopen `obj_Steel_Pillar` and set **Parent** to `obj_Pillar_Parent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While we are in `obj_Steel_Pillar`, we might as well have it react to other
    Pillars as well. Add an `obj_Pillar_Parent` and drag a **Comment** from **Controls**
    into the **Actions:** area, and enter `Collides with Pillars` as the comment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back into obj_TNT_Fragment and add an `obj_Pillar_Parent` and apply `scr_TNT_Fragment_Collision`.
    We will now have collision with all Pillars!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All we need to do now is to create the TNT and have it explode. Create a new
    Sprite, `spr_TNT`, and load `Chapter 6/Sprites/TNT.png` with **Remove Background**
    checked. Center the origin and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_TNT`, and apply `spr_TNT` as the Sprite. We will be
    manually placing the TNT in the game, and we don't need it to react to the world
    physics, so we do *not* need to turn on **Use Physics**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's create a new Script, `scr_TNT_Activate`, and for testing purposes, add
    it to a **Space** event under **Key Press**. We are going to create only a single
    Fragment and have it launch outwards to the right, so we can see how forces work
    in the world.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We first create a Fragment and capture its ID in a variable. We are then setting
    the horizontal force to be 100 units. This value seems like it should be enough
    force to push this object to the right.
  prefs: []
  type: TYPE_NORMAL
- en: Let's test it out. Reopen `Sandbox` and place a single instance slightly to
    the left of where the Steel Pillar will fall and three grid spaces above the Ground.
    Also, let's remove the extra instance of Ground and the Chain. The Room should
    look like the following screenshot:![Applying forces to objects](img/4100OT_06_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game and press the space key to spawn a Fragment. You should see the
    Fragment come out moving to the right, but it is falling downwards as well. When
    the Fragment collides with the Steel Pillar, the Fragment disappears and nothing
    happens to the Steel Pillar. All of this is a result of the Fragment not having
    enough force.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s increase the force. Reopen `scr_TNT_Activate` and change the second
    line to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Run the game and press space to see how this changes things. The Fragment now
    appears to move only to the right, and on contact with the Steel Pillar, it makes
    it rock a little bit. However, no matter how many times we hit the Steel Pillar,
    it will never fall over. This is due to the fact that the Steel Pillar has double
    the density of the Fragment, and it needs significantly more force to knock it
    down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once again, let''s adjust the number by adding a zero to the end. Change the
    force to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Run the game again and try to knock the Steel Pillar over. It should take three
    quick taps and it will fall over. As we can see, a small object like the Fragment
    is going to require a very large amount of force in order to move a large object
    such as the Steel Pillar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have one Fragment working, let's get the rest in. We need seven
    more fragments moving in 45 degree increments. We will also want to remove the
    TNT so it can only be triggered once.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, for each Fragment we apply an appropriate value for the forces
    in the X and Y directions. There is no need for us to pull out a calculator and
    some fancy equations to figure out exactly how much force is needed, especially
    on the angled pieces. Remember, this is a video game and we should only worry
    about the overall effect and experience the player has to see if the results are
    correct. When you run the game it should look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying forces to objects](img/4100OT_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this point we have a good foundational knowledge of how the Box2D physics
    engine works. We have built a room with physics activated and created several
    objects with fixtures and physics properties. We have used joints to connect a
    series of instances together and we have applied forces to an object to make it
    move. We are now ready to start building the tower toppling game!
  prefs: []
  type: TYPE_NORMAL
- en: Building a tower toppling game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to build a tower toppling game, the first elements we need to create
    are the support structures. We already have a Steel Pillar, which will be the
    strongest piece, but we will need several more. There will be three material types
    that will each have unique physics properties: Steel, Wood, and Glass. There will
    also need to be two different sizes, large and small, for variation. Finally,
    we want the large structures to be able to break apart into small chunks of Debris.'
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the Pillars and Debris
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start by building all the additional Steel Pillars and Debris.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Sprite, `spr_Pillar_Steel_Small`, and load `Chapter 6/Sprites/Pillar_Steel_Small.png`
    with **Remove Background** checked. Center the origin and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rather than making a new object, right click on `obj_Pillar_Steel` and **Duplicate**
    the object. This will keep the properties the same so we don't have to repeat
    most of that work. Rename this to `obj_Pillar_Steel_Small`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the Sprite to `spr_Pillar_Steel_Small`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As this is a duplicate of a larger object, we need to adjust the fixture. Click
    on **Modify Collision Shape** to open the **Physics Shape** editor, and move the
    points to properly fit the smaller sprite. We are done with this Pillar and the
    **Object Properties** should look like the following screenshot:![Constructing
    the Pillars and Debris](img/4100OT_06_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Sprite, `spr_Debris_Steel_01`, and load `Chapter 6/Sprites/Debris_Steel_01.png`
    with **Remove Background** checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When a Pillar becomes Debris, we will want to make sure each piece is placed
    and rotated correctly. In order to do this, we will need to place the origin as
    it would correspond to the Pillar''s origin. This debris comes from the upper-left
    corner, so set the origin to **X**: `16`, **Y**: `64` and click on **OK**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's duplicate the `obj_Pillar_Steel` again, name it `obj_Debris_Steel_01`
    and change the sprite to `spr_Debris_Steel_01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All Debris comes in odd shapes and we will want the collision to reflect that.
    In the **Physics Properties** editor, change **Collision Shape** to **Shape**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Modify Collision Shape** to open the **Physics Shape** editor and
    move the points to properly fit the Debris. You will notice that it likely has
    given you a triangle to start. To add additional points, just click away from
    the existing points. One other important note is that a Shape fixture must always
    be built in a clockwise manner in order for the physics to work properly. The
    collision shape should look like the following screenshot:![Constructing the Pillars
    and Debris](img/4100OT_06_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Sprite, `spr_Debris_Steel_``02`, and load `Chapter 6/Sprites/Debris_Steel_02.png`
    with **Remove Background** checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the origin to **X**: `0`, **Y**: `64` and click on **OK**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate `obj_Debris_Steel_01`, rename it `obj_Debris_Steel_02`, and set the
    **Sprite** to `spr_Debris_Steel_02`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once again, click on **Modify Collision Shape** and adjust the points appropriately
    as seen in the following screenshot:![Constructing the Pillars and Debris](img/4100OT_06_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have one more piece of Debris to make, create a new Sprite, `spr_Debris_Steel_03`,
    and load `Chapter 6/Sprites/Debris_Steel_03.png` with **Remove Background** checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the origin to **X**: `16`, **Y**: `0` and click on **OK**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate `obj_Debris_Steel_01`, rename it `obj_Debris_Steel_03`, and change
    the **Sprite** to `spr_Debris_Steel_03`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will need five total points on this object, so click on Modify **Collision
    Shape** and adjust the points appropriately as seen in the following screenshot.
    We are done with the Steel Debris:![Constructing the Pillars and Debris](img/4100OT_06_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will build the Wood Pillar and associated parts. We won't go through
    every step, as it is just going to be repeating the process we just went through
    with the Steel Pillar. We will, however, build the first Pillar of the other material
    types. Create a new Sprite, `spr_Pillar_Wood` and load `Chapter 6/Sprites/Pillar_Wood.png`
    with **Remove Background** checked. Center the origin and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Pillar_Wood`, and assign `spr_Pillar_Wood` as the
    **Sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Parent** to `obj_Pillar_Parent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check **Uses Physics**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the **Collision Shape** to **Box**. The collision shape should automatically
    fit the Sprite as it is a new object, so we don't need to modify the shape.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wood is much lighter than Steel, so we want to make it move with just a little
    force. Set the **Density** to `8`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wood also bounces a lot more as it can easily flex, therefore we should set
    **Restitution** to `0.2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will say that this Wood is less coarse than the Steel and set **Friction**
    to `0.5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the values for **Collision Group**, **Linear Damping**, and **AngularDamping**
    to `0`, as we will not want the Pillar affected by them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to add events for `obj_Ground` and `obj_Pillar_Parent` with comments
    attached for the collision detection to work. If you are wondering why we don't
    just put it in the `obj_Pillar_Parent`, it's because we will be adding scripts
    for Debris to these events later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are done with the Wood Pillar, which means we can now create the Small Wood
    Pillar and the Wood Debris. Go ahead and build all these parts with the files
    provided in `Chapter 6/Sprites/`. Make sure the object properties are all the
    same as can be seen in the following screenshot:![Constructing the Pillars and
    Debris](img/4100OT_06_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our last Pillar, and the weakest one, is the one made out of Glass. Create a
    new Sprite, `spr_Pillar_Glass`, and load `Chapter 6/Sprites/Pillar_Glass.png`
    with **Remove Background** checked. Center the origin and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Pillar_Glass`, with its **Sprite** set to `spr_Pillar_Glass`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Parent to `obj_Pillar_Parent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check **Uses Physics** and change the **Collision Shape** to **Box**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Glass is the lightest material and we want it to move with very little force.
    Set the **Density** to `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want the Glass to rattle a lot so we will set **Restitution** to `0.3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Glass should be very slick with a **Friction** value of `0.07`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As with the other Pillars, set the values for **Collision Group**, **Linear
    Damping**, and **Angular Damping** to `0`, as we will not want the Pillar affected
    by them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to add events for `obj_Ground` and `obj_Pillar_Parent` with
    comments attached for the collision detection to work. The final set up should
    look like the following screenshot:![Constructing the Pillars and Debris](img/4100OT_06_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we did with the other Pillars, create the remaining Glass pieces with the
    assets provided in `Chapter 6/Sprites/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that all the Pillars have been created, reopen Sandbox and place a few Pillars
    and some TNT. Run the Game and notice how the various materials react. The Glass
    will move easily while the Steel is fairly rigid. The Wood appears to react somewhere
    in between those two.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Breaking the Pillars into Debris
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already created all the necessary objects for spawning Debris from the
    Pillars; we just need to write the functionality for the switch between the two.
    To do this, we will build a simple system that can be used by all Pillars. In
    this game we will only break apart the larger Pillars. The small Pillar and the
    Debris will be destroyed if enough force is applied.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the weakest object, the Glass Pillar, by initializing some
    variables. Create a new Script, `scr_Pillar_Glass_Create`, and apply this to a
    **Create** event in `obj_Pillar_Glass`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first variable we have will be used for the amount of damage a Pillar can
    take. In this case, the Glass Pillar requires at least five points of damage to
    break apart. Next we are setting variables for each piece of Debris that we will
    need to spawn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Script, `scr_Pillar_BreakApart` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We start by determining the velocity of the collision, so that it only applies
    to moving objects, not static ones. We are using a function called abs, which
    will ensure that the velocity we are given is always a positive number. This will
    make the comparison much easier, as we don't need to consider the direction of
    movement. If the colliding object is moving faster than the damage amount of the
    Pillar, we then check a second conditional statement comparing the mass of the
    two instances involved in the collision. We only want the Pillar to break apart
    if it is hit by something stronger than itself. It would not make any sense to
    have a Glass Pillar destroy a Steel Pillar. If a Pillar is hit by a heavier object,
    we then spawn the Debris. For each piece of Debris, we need to place it in the
    appropriate position based on the physics speed and rotation of the Pillar it
    is spawning from. Once we have created the Debris, we destroy the Pillar.
  prefs: []
  type: TYPE_NORMAL
- en: Add this script to the `obj_Pillar_Parent` event in `obj_Pillar_Glass`. We can
    remove the comment as it is no longer needed for the collision to work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reopen `Sandbox` and place a single instance of TNT, with a Glass Pillar and
    Steel Pillar on either side. It should look like the following screenshot:![Breaking
    the Pillars into Debris](img/4100OT_06_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game and explode the TNT. We should see the Glass Pillars push out to
    the side, collide with the Steel Pillars, and then break apart into a pile of
    Debris, like the following screenshot:![Breaking the Pillars into Debris](img/4100OT_06_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's move onto the Wood Pillar. Create a new Script, `scr_Pillar_Wood_Create`,
    and initialize the necessary variables. Add them to a **Create** event in `obj_Pillar_Wood`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We have increased the required velocity of the damage to be applied in order
    for it to break apart. Glass is easy to shatter, while wood is not. We have also
    assigned the appropriate Debris to the Wood.
  prefs: []
  type: TYPE_NORMAL
- en: Remove the comment from the `obj_Pillar_Parent` and add `scr_Pillar_BreakApart`
    instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reopen `Sandbox` and replace the Glass Pillars with Wood Pillars.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game and explode the TNT. The Wood will move outwards, but will not
    shatter. This result is intended as we said we need more force to break it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another instance of TNT below the one existing in `Sandbox`. This will apply
    more force when it is detonated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. As can be seen in the next screenshot, this time the Wood Pillars
    move outwards and shatter on contact. The Steel Pillars will also be knocked over
    with this amount of force!![Breaking the Pillars into Debris](img/4100OT_06_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We only have the Steel Pillar remaining. We will set it up to function properly,
    though at this point we will not be able to test it, as there are no objects with
    more density than it. Create a new Script, `scr_Pillar_Steel_Create`, and add
    it to a **Create** event in `obj_Pillar_Steel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The same as before, we have increased the required velocity for damage and set
    the correct Debris to spawn.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to remove the comment from the `obj_Pillar_Parent` and replace
    it with `scr_Pillar_BreakApart`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now have the Pillars breaking apart into smaller pieces when they are hit
    with enough force. Next, we need to destroy the small Pillars and the Debris when
    enough force collides with them. Create a new Script, `scr_Pillar_Destroy`, with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Similar to `scr_Pillar_BreakApart`, we check the velocity of the colliding object
    and then compare mass to see if it should be destroyed. Here is where the difference
    between density and mass becomes apparent. All of the Debris have the same density
    as the Pillar that spawned it, which means that the solidity is the same. However,
    the bigger the object is, the more mass it will have. This means that smaller
    Debris chunks can be destroyed by larger Debris chunks.
  prefs: []
  type: TYPE_NORMAL
- en: Apply this script to all small Pillars and Debris in their respective `obj_Pillar_Parent`
    events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script uses the same variables as the type of Pillar it is, which means
    that we need to initialize them. We can reuse the existing script to save us some
    time. For each small Pillar and Debris, add a **Create** event and apply the appropriate
    Pillar Create script, as in all Glass should have `scr_Pillar_Glass_Create` assigned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Time to test this out. Reopen `Sandbox` and place two instances of Glass Pillars
    on top of the Wood Pillars, so that it looks like the following screenshot:![Breaking
    the Pillars into Debris](img/4100OT_06_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game and explode the TNT. The Glass Pillars should shatter easily and
    most of the Debris will disappear very quickly. The Wood Pillars will also splinter
    a bit and most of its Debris disappears. The Steel Pillars will rock slightly,
    but remain undamaged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding in the collision sounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything is functioning, though a bit boring, due to the lack of sound. The
    Debris being destroyed so quickly is also not very satisfying. Let's fix both
    of these issues.
  prefs: []
  type: TYPE_NORMAL
- en: First we need to bring in some sounds. Create a new Sound, `snd_Shatter_Glass`,
    and load `Chapter 6/Sounds/Shatter_Glass.wav`. The default values will work, just
    make sure that **Kind** is set to **Normal Sound**. This effect will be for when
    the Glass breaks apart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also want a sound for when the Glass Pillars do not break. Create another
    new Sound, `snd_Impact_Glass` and load `Chapter 6/Sounds/Impact_Glass.wav`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this process for the Wood and Steel sound effects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to initialize some variables, so reopen `scr_Pillar_Glass_Create` and
    add the following at the end of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We start by assigning variables to the `Impact` and `Shatter` sounds. We will
    only want to allow the impact sound to play a single time, so we have created
    the `isTapped` variable. The `isActive` variable and the alarm are going to be
    used, so that no sound is made when the game starts. When the physics system begins,
    all active instances in the world will have gravity applied, which will cause
    collisions. This in turn means that the impact sound will occur when nothing appears
    to be moving.
  prefs: []
  type: TYPE_NORMAL
- en: Reopen `scr_Pillar_Wood_Create` and `scr_Pillar_Steel_Create`, and add the same
    code with the appropriate sounds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we can start implementing the sounds. Open `scr_Pillar_BreakApart` and
    insert the following line of code before the instance is destroyed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When the Debris spawns, we will play the Shatter sound a single time. Notice
    that we have given this sound a priority of 10, which means that if too many sounds
    need to be played, this sound will be chosen over lower priority sounds.
  prefs: []
  type: TYPE_NORMAL
- en: Still in the script, we need to play the impact sound if a collision occurs,
    but does not break the Pillar. We will add an `else` statement immediately after
    the instance is destroyed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If only a minor collision has occurred, we check to see if we have run the sound
    before. If we haven't, then we play the impact sound, with a low priority, and
    stop this code from executing again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We only have one thing left to do in this script and that is to place all of
    the code into a conditional statement, so that it executes only if the instance
    is active. Add the check at the top of the script and place braces around all
    the existing code. When it is done, the whole script will look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to repeat this process for `scr_Pillar_Destroy`, so that the shatter
    sound is played on destruction, the impact sound on a light collision, and all
    of this when the instance is active. Here is the code in its entirety:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In order for the sounds to work, we need to make them active. Create a new Script,
    `scr_Pillar_Alarm0` and set `isActive` to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rather than adding an alarm for every pillar and debris, we can just add an
    **Alarm 0** event to `obj_Pillar_Parent`. This will not cause any conflicts because
    the alarm will only be run once per instance and only changes a variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game, explode the TNT and listen. We can hear the different sounds as
    the Pillars break apart and collide with each other. Also notice that there is
    more Debris now remaining. This is because there is now a one second delay before
    they can destroy themselves, which allows time for the Debris to escape any collision
    that happens upon creation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building the demolition equipment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have everything we need to build towers, but this game is all about demolition.
    The player would become bored if all they had was TNT to destroy the towers. We
    are going to utilize some more physics functions and create some new equipment:
    a Wrecking Ball and a Magnetic Crane.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Wrecking Ball
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with the Wrecking Ball as we have already built a large portion
    of it. We will utilize the Chain and Anchor and add a Ball to it.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Sprite, `spr_WreckingBall`, and load `Chapter 6/Sprites/WreckingBall.png`
    with **Remove Background** checked. Center the origin and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_WreckingBall`, and apply the `spr_WreckingBall` as
    its **Sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will want the Wrecking Ball to always be drawn in front of the chain that
    holds it. Set **Depth** to `-100`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the box for **Uses Physics**. We do not need to change Collision Shape,
    as the Wrecking Ball is a circle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want this Wrecking Ball to be very powerful, so set **Density** to `50`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As it is such a heavy object and hanging from a chain, it should not be able
    to spin very much. To slow the rotation, set the **AngularDamping** to `5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All other physics values for this object should be set to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are done building the Wrecking Ball, so now we need to add it to the Anchor
    and Chain. Reopen `scr_Anchor_Create` and add the following code at the end of
    the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here we are creating a Wrecking Ball at the end of the Chain, with a 24 pixel
    offset so it is positioned correctly. We then add a Revolute Joint between the
    last link in the Chain and the Wrecking Ball with a rotational limit of 30 degrees
    in either direction.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to add the collision. We are not going to place the collision
    on the Wrecking Ball, as the existing scripts are going to look for variables
    that the Wrecking Ball will not have. Instead, we will start by reopening `obj_Pillar_Parent`
    and adding an `obj_WreckingBall` event, and attaching `scr_Pillar_Destroy`. As
    all Pillars and Debris are parented to the object, they will all respond to this
    event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While this last step will work fine, it also means the large Pillars will be
    destroyed on contact as well. We want the large Pillars to always break apart
    first. We can still do this by reopening the three Pillars, `obj_Pillar_Glass`,
    `obj_Pillar_Wood`, and `obj_Pillar_Steel`, and add an `obj_WreckingBall` event
    with `scr_Pillar_BreakApart` attached. If a parent object and one of its children
    both have the same type of event, be it collision, step, or whatever, the child's
    event will be executed and the parent's event will be ignored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to execute both the parent event and the child event together
    by using the function `event_inherited()` in the child's event code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's test this out. Reopen `Sandbox` and place an instance of `obj_Anchor`
    in the room, just off to the right of the existing Pillars. We can also remove
    the TNT as we do not need it for this test. The setup should look like the following
    screenshot:![Creating a Wrecking Ball](img/4100OT_06_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. We should see the Wrecking Ball swing down attached to the Chain
    and Anchor. When the Wrecking Ball collides with the Steel Pillar, the Pillar
    breaks apart, as do many of the other Pillars. Everything works correctly, but
    there is a bit of an issue. The Wrecking Ball falls immediately, when it should
    wait to be triggered. Let's fix all that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order for us to stop the Wrecking Ball from moving immediately, we need
    to deactivate from the World Physics. This is simply done by setting the `phy_active`
    variable to false for each instance we want to stop. Reopen `scr_Anchor_Create`
    and apply this change for the Wrecking Ball and every Chain. The entire script
    can be seen in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The Wrecking Ball and Chain will no longer move at the start, but we still need
    to be able to trigger it at some point. Create a new Script, `scr_Anchor_Activate`,
    and for testing purposes, attach it to a **Space** event under **Key Press**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When this script is run, a simple `for` loop activates every Chain, and then
    the Wrecking Ball.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game. The Wrecking Ball should be extended out to the right and static.
    When we hit the space key, the Wrecking Ball and Chain should become active and
    swing down, colliding into the tower. The collision itself is much higher on the
    tower, as the Chain is now fairly rigid with only a little elasticity. It looks
    like we are done!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Making a Magnetic Crane
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our third piece of demolition equipment will be a Magnetic Crane. This Crane
    will drop down and pick up any small Pillar and Debris made from Steel. It will
    then raise itself back up with whatever it has collected.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by building the Magnet itself. Create a new Sprite, `spr_Magnet`,
    and load `Chapter 6/Sprites/Magnet.png` with **Remove Background** checked. Center
    the origin, and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Magnet`, and assign `spr_Magnet` as the **Sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the box for **Uses Physics** and set **Collision Shape** to **Box**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will want to make the collision area smaller, so that when it picks up objects,
    the effect appears more believable. Click on **Modify Collision Shape** and pull
    the sides in so that it looks like the following screenshot:![Making a Magnetic
    Crane](img/4100OT_06_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Magnet needs to be quite heavy so that the other objects can't push it around.
    Set **Density** to `50`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set all the other properties to `0`, as we don't want them affecting the magnet's
    movement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As our intention is for the magnet to only pick up the small objects made of
    Steel, we should change how the Steel Debris is parented. Currently, it is parented
    to `obj_Pillar_Parent` for collision purposes. We still need to be able to have
    that ability, but we want magnetic attraction to be unique to a few objects. To
    do this, we can parent the Debris to any object that has `obj_Pillar_Parent` as
    its parent. Let's set the Parent for all Steel Debris to `obj_Pillar_Steel_Small`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We also need to add a variable to everything made of steel so that we know
    if it has been collected or not. Reopen `scr_Pillar_Steel_Create` and add the
    following line of code at the end of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now we can make the script for the magnetic attraction. Create a new Script,
    `scr_Magnet_Step`, and attach it to a **Step** event in `obj_Magnet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We start by seeing whether the magnet is active and can begin collecting scrap
    metal. Next, we check if there are any small Steel Pillars, or anything parented
    to it, in the world. If there are instances in existence, we apply code directly
    to them through a `with` statement. If the instance has not been collected, we
    find the nearest Magnet, see how far away it is, and in what direction. When checking
    for the X and Y coordinates of an object in a physics game, we need to use the
    `phy_position_x` and `phy_position_y` values to accurately know where they are
    in the world space. Next, we see if the instance is within the magnetic range,
    and whether it is underneath the Magnet. If it is, we apply a strong impulse upwards,
    which will make it move towards the Magnet.
  prefs: []
  type: TYPE_NORMAL
- en: Once a small Steel Pillar or Debris comes in contact with the Magnet, we want
    to consider it collected and to always move with it. To do this, we will dynamically
    create a joint to any instance that collides with the Magnet. Create a new Script,
    `scr_Magnet_Collsion`, and attach it to an `obj_Pillar_Steel_Small` event in `obj_Magnet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here we are making a Prismatic Joint with the magnet and the instance that collides
    with it. The first two parameters are the two instances that are to be joined,
    followed by where in the world they are connected. The fifth and sixth parameters
    are the direction it can move in, and in this case it is vertical only. The next
    three are the limits of the movement. We don't want it to move, so we set the
    min/max values to zero. The limits do need to be enabled, otherwise they won't
    lift with the Magnet. The following three are for whether there is a motor to
    move this joint. The final parameter is for collision with the objects which we
    want to avoid. Once the joint has been created, we then set the collected variable
    to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to make a base for the Crane, which will function similar to the
    Anchor. Create a new Sprite, `spr_CraneBase`, and load `Chapter 6/Sprites/CraneBase.png`
    with **Remove Background** checked. Center the origin and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_CraneBase`, and apply `spr_CraneBase` as the **Sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the box for **Uses Physics** and set **Collision Shape** to **Box**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This object is meant to be static in the physics world, so we need to set the
    **Density** to `0`. All other properties can be left at their default values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will want the crane base to spawn the magnet and set the joint up. Create
    a new Script, `scr_CraneBase_Create`, and attach it to a **Create** event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We are creating the Magnet well below the crane base and have deactivated it
    from the physics world. We then apply a Prismatic Joint between the two instances.
    This time we are allowing for 128 pixels of movement in a vertical direction.
    We are also running a motor, so that the Magnet can move up and down on its own.
    The maximum force the motor can apply is `100000` and we have the motor dropping
    the Magnet at a motor speed of `20000`. As you can see, the values we are using
    are extremely high and the reason for this is to make sure that the heavy magnet
    can lift plenty of Steel Debris.
  prefs: []
  type: TYPE_NORMAL
- en: As with the Wrecking Ball, we need to activate the crane base. Create a new
    Script, `scr_CraneBase_Activate`, and for testing purposes, attach it to the **Space**
    event under **Key Press**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We want the magnet to drop down first, so we make it active in the physics world.
    We are using an alarm set for five seconds, which will raise the Magnet back up.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Script, `scr_CraneBase_Alarm0` and attach it to an **Alarm 0**
    event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We are setting the value for the motor speed to go up at a value of `-20000`.
    Again, we are using a very large number to ensure it goes back up with the additional
    weight of the Pillar Debris.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do for the Crane is to add a cable between the crane
    base and the magnet. For this we will simply draw a line between the two. Create
    a new Script, `scr_CraneBase_Draw`, and apply it to a **Draw** event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Whenever a **Draw** event is used, it overrides the drawing of the default Sprite
    for the object. Therefore, we use `draw_self` to correct that override. Next we
    set a color to use, here we are using a default dark gray color, and then we draw
    an 8 pixel wide line between the crane base and the top of the magnet.
  prefs: []
  type: TYPE_NORMAL
- en: All we need to do now is to add an instance of crane base to `Sandbox`. Place
    the instance off to the left-hand side of the existing Pillars. Also add a few
    instances of Debris and the small Steel Pillar as can be seen in the following
    screenshot:![Making a Magnetic Crane](img/4100OT_06_24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. The Magnet should be sitting in the air and we should notice the
    Debris shaking a bit as if there is some magnetic attraction occurring. When we
    hit space, the Magnet should drop down and collect a few pieces of Debris. After
    a few seconds, the Magnet will raise back up, taking the collected Debris with
    it. Also notice that none of the other Debris or Pillars are affected by the Magnet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Completing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have built a fun little toy, but it is not yet a game. We have no
    win or lose condition, no challenge, and no reward. We need to give the player
    something to do and challenge themselves with. We will start by implementing the
    win condition; remove all Pillars from a preset Zone. We will create some levels
    with a variety of Towers and Zones to clear. We will also create an Equipment
    Menu, so that the player can select what items they want to use and place them
    in the world.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the win condition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The win condition for this game is to clear all Pillars and Debris from a specific
    Zone. The player will only be able to activate the equipment once and will have
    a small amount of time to clear the Zone. If they clear it, they win and move
    on. If it isn't cleared, they lose and they try again.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by making a parent Zone that will have all the code, but is never
    actually placed into the world. Create a new Object, `obj_Zone_Parent`. There
    is no sprite to attach.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Script, `scr_Zone_Create`, and add it to a **Create** event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We start by stopping the animation of the assigned sprite. All the Zones will
    consist of sprites with two frames of animation. The first frame will indicate
    collision and the second frame is the all clear signal. We also have a variable
    that we will use to identify if a Pillar or Debris is in contact with the Zone.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Zone will need to constantly update whether it is clear of collision or
    not. Create a new Script, `scr_Zone_Step`, and attach it to a **Step** event with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here we are using a function, `collision_rectangle`, to determine whether the
    Pillar parent is currently in contact with the Zone. We cannot use a collision
    event to check for contact, as we need to watch for the lack of collision to happen.
    We are using the bounding box parameters of the Sprite to determine the size of
    the collision area. This will allow us to have multiple Zone sprites with a variety
    of sizes without any additional code. If there is collision, we switch to the
    first frame of the animation and indicate that collision is currently happening.
    Otherwise, we switch to the second frame of animation and indicate that the Zone
    is currently free of collision.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the parent Zone built, we can build the child Zones, which
    will be placed into the world. Create a new Sprite, `spr_Zone_01`, and load `Chapter
    6/Sprites/Zone_01.gif` with **Remove Background** checked. Leave the origin at
    **X**: `0` **Y**: `0`, so that collision will work correctly. Click on **OK**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Zone_01`, and apply `spr_Zone_01` as its **Sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want the Zone to always be drawn behind the towers, so set **Depth** to `100`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set Parent to `obj_Zone_Parent` and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have supplied a few more sprites in `Chapter 6` for variety. Repeat steps
    4 to 6 with the appropriate naming conventions for the additional zones.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `Sandbox` and place an instance of `obj_Zone_01`, so that it covers some
    of the Glass Pillars only, as seen in the following screenshot:![Setting the win
    condition](img/4100OT_06_25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game and activate the equipment. You should see the Zone remain red
    for as long as there are Pillars or Debris within it. Once it is clear, it will
    turn light blue, indicating that it is clear of collision.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to create an Overlord to check for the win condition. Create a
    new Object and name it `obj_Overlord`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Script, `scr_Overlord_Create`, and attach it to a **Create** event,
    so that we can initialize some variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We have two variables that we will be using. We will use `isTriggered` to check
    if the equipment has been activated or not. The `isVictory` variable will determine
    whether the win condition has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to take the activation away from the individual pieces of equipment
    and place it into the Overlord. Reopen `obj_TNT`, `obj_Anchor`, and `obj_CraneBase`,
    and remove the **Space** event under **Key Press**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Script, `scr_Overlord_Step`, and add it to a **Step** event in
    `obj_Overlord`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This code will only execute if the variable `isTriggered` is `true`. If it is,
    we check to see if there are any instances of the TNT in existence. If there are
    instances, we use a `with` statement to run the activation script for each instance.
    We do the same for the Anchor and Crane Base. We also add an alarm set for eight
    seconds, which is when we will check for the win condition. Finally, we set `isTriggered`
    back to `false` so that this runs for the second time.
  prefs: []
  type: TYPE_NORMAL
- en: Let's activate the equipment. Create a new Script, `scr_Overlord_KeyPress`,
    and add it to a **Space** event under **Key Press**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'At some point we may want to have more than one Zone in a level that needs
    to be cleared. This poses a bit of a problem, in that we need to ensure that all
    Zones are clear while not knowing in what order we are going to check each Zone.
    What we need to do is have any Zone that has collision. Stop the checking process
    and set the win condition to `false`. Create a new Script, `scr_WinCondition`,
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: By using a `with` statement to check `obj_Zone_Parent`, we are able to look
    for all instances of that object and all of its children. We are going to use
    `return` statements here to help us exit the script. When a return is executed,
    the script will immediately stop and any code after it will not be run. If any
    instance has collision we return `false`; otherwise, if no instances have collision,
    we return `true`.
  prefs: []
  type: TYPE_NORMAL
- en: We can now use `scr_WinCondition` in our alarm event. Create a new Script, `scr_Overlord_Alarm0`,
    and add it to an **Alarm 0** event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We start by capturing the returned `boolean` from `scr_WinCondition` in the
    `isVictory` variable. If it is `true`, we check to see if there is a room after
    the current room we are in. The order of rooms is determined by where they are
    placed in the Resource tree, with the next room being the one below it in the
    Resource tree. If there is a room, we go to it. If the win condition is `false`,
    we restart the room.
  prefs: []
  type: TYPE_NORMAL
- en: Reopen `Sandbox` and place a single instance of `obj_Overlord` anywhere in the
    room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can't test the win condition with only one room, so let's duplicate the `Sandbox`
    and name it `Sandbox_02`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rearrange the Pillars and equipment in the room so that you can tell that it
    is not the same room as Sandbox. Also move the Zone closer to the ground so that
    it guarantees the win condition will not happen, as shown in the following screenshot:![Setting
    the win condition](img/4100OT_06_26.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game and press space. In the first room we should see some destruction
    clear the Zone and after a few moments, the room will switch over to `Sandbox_02`.
    When the equipment is activated this time, there will be some destruction, but
    there will still be Pillars and Debris in the Zone. After a few moments, this
    room will restart. The win condition works!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the Equipment Menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we now have a win condition, there still isn't anything for the player
    to do. We are going to fix that by adding an **Equipment Menu**. This menu will
    be placed along the bottom of the gameplay screen and have selectable icons for
    the TNT, Wrecking Ball, and Magnetic Crane. When an icon is clicked it will create
    a placeable ghost version of the appropriate piece of equipment. To place the
    equipment, the player just needs to click somewhere in the world and the ghost
    will become the real item.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the Equipment Menu we are going to need several sprites. Create new
    sprites and load the appropriate files from `Chapter 6/Sprites/` for the following
    sprites with **Remove Background** unchecked. Leave the origin at **X**: 0 and
    **Y**: `0`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`spr_Menu_BG`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spr_Menu_TNT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spr_Menu_WreckingBall`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spr_Menu_MagneticCrane`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new Object and name it `obj_Menu`. We will not apply a Sprite to this
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We only need to initialize one variable to indicate when the menu is active.
    Create a new Script, `scr_Menu_Create`, and apply it to a **Create** event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this game we are going to require rooms of varying sizes, so that we can
    have tall or wide towers. This means that the menu will need to adapt to fit properly.
    This could be very frustrating except for the fact that we are going to set screen
    size to 640 x 480 at all times. If we use GameMaker's **Draw GUI** event, it ignores
    the world positioning and uses the coordinates based on the window size. Create
    a new script, `scr_Menu_DrawGUI`, and apply it to a **Draw GUI** event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As we know that every room is going to be displayed at a resolution of 640 x
    480, we start by drawing the background sprite at the bottom of the screen. We
    are going to use a variable, `menuItem_Zone`, to help with the mouse coordinates
    over the sprites. We will need to know exactly where the icon is placed when we
    code in the future, so we make variables for each menu item's coordinates and
    then draw the Sprite on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Reopen `Sandbox` and change the **Settings** of the room to **Width:** `800`,
    **Height:** `600`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the **Views** tab, check the boxes for **Enable the use of Views** and
    **Visible When Room Starts**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the **View In Room** to **W:** `800` **H:** `600`. Do not change the
    values for **Port on Screen**. By doing this, we will be able to see the entire
    room and it will be displayed at the standard 640 x 480 resolution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now place a single instance of `obj_Menu` anywhere in the room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. You should see the menu with the three icons at the bottom of
    the screen as shown in the following screenshot:![Creating the Equipment Menu](img/4100OT_06_27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the menu functional we need to first create all the ghost objects. We
    do not need to bring in any new sprites, as we will use the existing sprites for
    each piece of equipment. Let's start by creating a new Object, `obj_Ghost_TNT`,
    and applying `spr_TNT` as the **Sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new Script, `scr_Ghost_TNT_Create`, and apply it to a **Create** event
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In order to differentiate the Ghost TNT from the real TNT, we start by setting
    the transparency to 50 percent. We are going to use some common scripts for all
    ghosts, so we will need a variable to indicate what this Ghost represents.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to be able to move this object with the mouse around the room
    for placement. To do this we are going to write a Script that can be used by all
    ghosts. Create a new Script, `scr_Ghost_Step` and apply it to a **Step** event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Create another new Script, `scr_Ghost_Released`, and add it to a **Left Released**
    event under **Mouse**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We don't want to be able to place the item down on top of the menu, or on top
    of other instances we are trying to destroy. To make this happen we first need
    to grab the height of the display area and the position of the mouse within the
    display. It is important to note that we cannot use the standard `mouseY` variable
    as it relates to the position within the world because we need to know its position
    on screen. We check to see if there is a lack of collision at the current location
    in the room with any Pillar, and that the mouse on screen is 64 pixels above the
    bottom, which ensures that it is above the menu. If this is all true, we create
    an instance of whatever item is to be placed, tell the Menu that it is no longer
    active and remove the Ghost from the world. We are now done with the Ghost TNT.
  prefs: []
  type: TYPE_NORMAL
- en: Up next is the Ghost Wrecking Ball. Create a new Object, `obj_Ghost_WreckingBall`
    and assign `spr_Anchor` as its **Sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have some common scripts, so let's apply them quickly. Add a **Step** event,
    apply `scr_Ghost_Step`, and add a **Left Released** event under **Mouse** with
    `scr_Ghost_Released` attached.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Script, `scr_Ghost_WreckingBall_Create`, and add it to a **Create**
    event. All we need here is to initialize what item it will create when placed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can''t build this exactly the same as the TNT, as the Wrecking Ball is comprised
    of several parts. For this Ghost we will need a **Draw** event and a new Script,
    `scr_Ghost_WreckingBall_Draw` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We start by setting the instance to half transparent so that it looks like a
    Ghost. We then draw the Anchor, run a `for` loop to draw the Chain, and then the
    Wrecking Ball is drawn at the end of the Chain. Finally, we need to reset the
    transparency back to full at the end of this code. It is critical that we do this,
    as Draw events affect everything that is drawn on screen. If we did not reset
    it, every object in the world would have half transparency.
  prefs: []
  type: TYPE_NORMAL
- en: Now for the Ghost Magnetic Crane. Create a new Object, `obj_Ghost_MagneticCrane`,
    and apply `spr_CraneBase` as the **Sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The same as for the other Ghosts, add a **Step** event and a **Left Released**
    event under **Mouse** and apply the appropriate scripts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Script, `scr_Ghost_MagneticCrane_Create`, and initialize the necessary
    variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now draw the pieces. Create another Script, `scr_Ghost_MagneticCrane_Draw`,
    and add it as a **Draw** event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In a similar manner as the Ghost Wrecking Ball, we start by setting the transparency
    to 50 percent. We then draw the crane base, draw a thick gray line and the magnet
    at the same position they would be when placed. We then set the transparency back
    to full.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ghosts are now all complete; we just need to spawn them. Reopen `scr_Menu_DrawGUI`
    and add the following code at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We start by checking if the menu is active or not. If a menu item is selected
    and hasn't been placed, the menu will be considered active. If we are able to
    select a menu item, we grab the mouse location on screen. We check the mouse location
    on screen, first with the Y coordinate and the Zone offsets to see if the mouse
    is on top of the Menu, then with the X coordinate and the Zone of each item. If
    the mouse is over the top of one of the icons, we redraw the sprite on the second
    frame of animation to indicate the hover state. We then check to see if the left
    mouse button has been pressed, and if it has, we spawn the appropriate Ghost item
    and the menu is now active. Now we can spawn TNT, Wrecking Balls, and Magnetic
    Cranes.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game. We already have the menu on screen, but now when you hover over
    the icons, they should be highlighted. When you click on an icon, it creates the
    appropriate Ghost item, which will move with the mouse. When you click in the
    playable area, an instance of the item will be created and can be used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Constructing the towers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now have a working game and all that is left is to create some levels to
    play. We will build a few levels with a variety of different towers and room sizes
    to make sure all our code is working properly.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Room and in the **settings** tab, name it `Level_01.Make` sure
    this is moved to the top of the Rooms section of the Resource tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **physics** tab, check the box for **Room is Physics World** and set
    the **Gravity** to **X:** `0` **Y:** `20`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **objects** tab, select `obj_Ground` and place instances 64 pixels from
    the bottom and across the width of the room. The menu will take up the bottom
    64 pixels, so we don't need to put any Ground down there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add single instances of `obj_Overlord` and `obj_Menu` in the area below the
    Ground instances. While technically they can go anywhere in the room, this will
    just keep things a bit more organized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As this is the first level, let's make it easy for the player and only use Glass
    Pillars. Up to this point in the book, we have only been placing objects as they
    were created. When placing the Pillars, we can easily rotate them and place them
    in the world. To rotate an instance in the **Room Properties** editor, first place
    the instance in the room normally, and while it is still selected, change the
    **Rotation** value in the **objects** tab. There are options for scaling an instance,
    but we cannot use these in a physics simulation, as it does not affect the Fixture
    size.
  prefs: []
  type: TYPE_NORMAL
- en: Using only `obj_Pillar_Glass` and `obj_Pillar_Glass_Small`, construct a simple
    two story tower as seen in the following screenshot:![Constructing the towers](img/4100OT_06_28.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, place a single instance of `obj_Zone_01` behind the tower and roughly
    in the center vertically. This room is now complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's build the final room meant for much later in the game, but this time much
    larger and with multiple zones. Create a new Room and in the **settings** name
    it `Level_12`, and change the **Width** to `1280` and **Height** to `960`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Resource tree, move this room so that it is immediately after `Level_01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This room is now twice as big as `Level_01`, but we want to display it on screen
    at the same size. In the **views** tab, check the boxes for **Enable the use of
    Views** and **Visible When Room Starts**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the **View In Room** to **W:** `1280` **H:** `960`. Do not change the
    values for **Port on Screen**. Again, by doing this we will be able to see the
    entire room at the standard 640 x 480 resolution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **physics** tab, check the box for **Room is Physics World** and set
    the **Gravity** to **X:** `0` **Y:** `20`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will start by laying the ground down with `obj_Ground`. As the room is twice
    as large, our numbers need to double as well. The menu will display with a height
    of 64 pixels of screen resolution in this room, which means the Ground should
    be 128 pixels from the bottom.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place single instances of `obj_Overlord` and `obj_Menu` in the area below the
    Ground instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As this level is meant to be a later level in the game, we can use all small
    and regular size pillars of all types. Build a couple of towers with varying heights
    and building materials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an instance of `obj_Zone_01` behind each of the towers. An example of what
    the level could look like can be seen in the following screenshot:![Constructing
    the towers](img/4100OT_06_29.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. The first level should only need a few, well placed pieces of
    TNT to successfully destroy it. The next level should be much more difficult to
    complete, and requires all three types of equipment. The challenge now is to see
    how few pieces of equipment are needed to destroy everything. Have fun smashing
    things up as shown in the following screenshot:![Constructing the towers](img/4100OT_06_30.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot of material in this chapter. We started with the basics of
    using the Box2D physics system. We learned how to assign Fixtures to objects and
    what the different properties were that we could change. We created a Chain and
    Wrecking Ball that utilized Revolute Joints so each piece would rotate with the
    one preceding it. We built TNT and a Magnetic Crane that used Forces to move objects
    around the world. We also made Debris spawn from the large Pillars when they collided
    with heavier, stronger objects. Additionally, we learned about the Draw GUI event
    and the difference between a Sprite's location as represented in a room versus
    the location on screen. This allowed us to create a Menu that will display properly
    on screen no matter the size of the room.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to continue to work on this game in the next chapter. We will create
    a store and inventory system so that the player has a limited amount of equipment
    and can purchase additional items. We will also dive into displaying dialog, so
    that we can add some basic story elements to the game to motivate the player to
    destroy more stuff!
  prefs: []
  type: TYPE_NORMAL
