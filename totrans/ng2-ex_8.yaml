- en: Chapter 8.  Some Practical Scenarios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With seven chapters under our belt, it should feel nice. What you have learned
    thus far is a direct consequence of the apps we have built in the last few chapters.
    I believe you now have an adequate understanding of the framework, how it works,
    and what it supports. Armed with this knowledge, as soon as we start to build
    some decent size apps, there are some common problems/patterns that will invariably
    surface, such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: How to authenticate the user and control his/her access (authorize)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make sure that the app is performing enough?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: My app requires localized content. What do I do?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What tools can I use to expedite app development?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I have an Angular 1 app. How do I migrate it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And some more!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will try to address such common scenarios and provide some
    working solutions and/or prescriptive guidance to handle such use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Angular seed projects**: You will learn how some seed projects in Angular
    can help us when starting a new engagement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authenticating Angular applications**: This is a common requirement. We look
    at how to support cookie- and token-based Authentication in Angular.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular performance**: A customary performance section is a must as we try
    to detail what makes Angular 2 performant and things you can do to make your apps
    faster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Migrating Angular 1 apps to Angular 2**: Angular 1 and Angular 2 are altogether
    different beasts. In this chapter, you will learn how to gradually migrate an
    Angular 1 app to Angular 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start from the beginning!
  prefs: []
  type: TYPE_NORMAL
- en: Building a new app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine a scenario here: we are building a new application and given the super
    awesomeness of the Angular framework, we have unanimously decided to use Angular.
    Great! What next? Next is the mundane process of setting up the project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although a mundane activity, it''s still a critical part of any engagement.
    Setting up a new project typically involves:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a standard folder structure. This is at times influenced by the server
    framework (such as *RoR*, *ASP.Net*, *Node.js*, and others).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding standard assets to specific folders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Setting up the build, which in case we are developing an Angular 2-based web
    application includes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling/transpiling content if using TypeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the Module loader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency management in terms of framework and third-party components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up unit/E2E testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring builds for different environments such as dev, test, and production.
    Again, this is influenced by the server technology involved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code bundling and minification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a lot of stuff to do.
  prefs: []
  type: TYPE_NORMAL
- en: What if we can short-circuit the overall setup process? This indeed is possible;
    we just need a **seed project** or a **starter site**.
  prefs: []
  type: TYPE_NORMAL
- en: Seed projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we write this book, Angular 2 has just surfaced. There are a number of *seed
    projects* that can get us started in no time. Some seed projects integrate the
    framework with a specific backend and some only dictate/provide Angular-specific
    content. Some come preconfigured with vendor-specific libraries/frameworks (such
    as *LESS*, *SASS*, *Bootstrap*, and *FontAwesome*) whereas others just provide
    a plain vanilla setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the notable seed projects worth exploring are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Angular 2 Webpack Starter** ([http://bit.ly/ng2webpack](http://bit.ly/ng2webpack)):
    This seed repo serves as an Angular 2 starter for anyone looking to get up and
    running with Angular 2 and TypeScript fast. It uses Webpack (module bundler) to
    build our files and assist with boilerplate. It is a complete build system with
    a substantial number of integrations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular 2 Seed** ([http://bit.ly/ng2seed](http://bit.ly/ng2seed)): Another
    seed project similar to Angular 2 Webpack starter. This seed project uses gulp
    for build automation, and the module bundler system is not as advanced as Webpack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**angular-cli** ([http://bit.ly/ng2-cli](http://bit.ly/ng2-cli)): This is a
    command-line tool created by the Angular team that not only sets up a seed project
    for us but also has scaffolding capabilities. We can generate boilerplate components,
    directives, pipes, and services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These projects provide a head start when building with Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the app is tied to a specific backend stack, we have two choices, which
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use one of these seed projects and integrate it with the backend manually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find a seed project/implementation that does it for us. Angular 2 is relatively
    new, but there is a good chance that such seed projects will come up over time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This discussion cannot be complete without mentioning tools that go a step further.
    They not only come with a seed implementation but also have scaffolding capabilities
    that make our lives easier.
  prefs: []
  type: TYPE_NORMAL
- en: Seed and scaffolding tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two of the noteworthy to mention in this space are **Yeoman** and **angular-cli**.
  prefs: []
  type: TYPE_NORMAL
- en: Yeoman
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Yeoman ([http://yeoman.io/](http://yeoman.io/)) is a suite of tools targeted
    toward web application development. It defines a workflow for building modern
    web applications. It consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**yo**: This is a scaffolding tool used to generate code on-the-fly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grunt/Gulp**: The de facto choices when it comes to building systems on Node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bower/npm**: Bower is a package manager for the Web and works similarly to
    npm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scaffolding component of Yeoman is quite interesting. *yo*, as it is named,
    uses the concept of a generator to achieve scaffolding.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Scaffolding is the process of generating a code skeleton that can be built upon.
    Using scaffolding, we can save some initial effort and provide some guidance around
    how the overall structure of any coding artefact should look.
  prefs: []
  type: TYPE_NORMAL
- en: Generators in Yeoman are used to set up the initial seed project, and later
    for individual script generation too. Since Yeoman is not targeted specifically
    towards Angular, there are generators for various client and server stacks. There
    are a number of generators available for Angular 2 with varied configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Check out [http://bit.ly/yogenerators](http://bit.ly/yogenerators) for an exhaustive
    list of generators supported on Yeoman! You need to filter down to Angular 2 generators
    and select something that works for you. Feel free to experiment with these generators
    and see what best fits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: angular-cli
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A scaffolding tool officially endorsed by the Angular team, **angular-cli**
    works in the same way as Yeoman but specifically targets Angular 2\. Let's try
    it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install angular-cli, from the command line, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And then run this set of commands to generate the initial artefacts and build
    the setup for a new project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Open the browser at `http://localhost:4200/`, and we have a running app!
  prefs: []
  type: TYPE_NORMAL
- en: Let's check its scaffolding capabilities too.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a component, we just need to invoke this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It generates a boilerplate implementation for our component *Home*. The tool
    creates a `home` folder inside the `src/app` folder, and adds a number of files
    related to the component. Not only does this save us some mouse clicks and typing
    effort, but also the generated code adheres to the best practices outlined by
    the Angular community. A nice start! Go check out the generated code to understand
    this structure.
  prefs: []
  type: TYPE_NORMAL
- en: We just saw component generation using angular-cli, but this tool can also generate
    *directives*, *pipes*, *services*, and *routes*. Look at the tool documentation
    on the GitHub site [http://bit.ly/ng2-cli](http://bit.ly/ng2-cli).
  prefs: []
  type: TYPE_NORMAL
- en: Time to look at the most touted area in Angular, **performance**. Let's understand
    what makes Angular run fast and what switches/knobs are available with Angular
    to improve the overall app performance.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular 2 has been designed with performance in mind. Every part of the framework,
    starting from the framework footprint, initial load time, memory utilization,
    change detection plus data binding, and DOM rendering, has been tweaked or is
    being tweaked for better performance.
  prefs: []
  type: TYPE_NORMAL
- en: The next few sections are dedicated to understanding how performant Angular
    is and the tricks it uses to achieve some impressive performance gains.
  prefs: []
  type: TYPE_NORMAL
- en: Byte size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Byte size* of the framework is a good starting point for performance optimization.
    While the world is moving towards a high-speed Internet, a sizable population
    among us is on a slow connection and are using their mobile to connect to the
    Web. We may not think too much about few KB here or there, but it does matter!'
  prefs: []
  type: TYPE_NORMAL
- en: While the byte size of Angular 2 out-of-the-box is bigger than Angular 1, there
    are techniques that can drastically reduce the size of an Angular 2 bundle.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, the standard techniques of *minification* and *gzipping* can
    reduce this gap substantially. And with Angular 2, we can do some nifty tricks
    with *module bundler/loaders* to reduce the Angular 2 bundle size even more.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tree shaking** may be a quirky name for a process, but it literally does
    what it says! As we build apps using TypeScript (or ES2015), containing *modules*
    and *exports*, a module bundler such as *Rollup* ([http://rollupjs.org](http://rollupjs.org))
    can perform static code analysis on such code, determine what parts of the code
    are never used, and remove them before bundling the release bits. Such module
    bundlers, when added to the app''s build process, can analyze the framework bit,
    any third-party library, and the app code to remove any dead code before creating
    bundles. *Tree shaking can result in enormous size reduction as you don''t bundle
    framework bits that you don''t use.*'
  prefs: []
  type: TYPE_NORMAL
- en: One of the biggest framework pieces that can be removed from the framework bundle
    is the *compiler*. Yes, you read right, it's the compiler!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For curious readers, the compiler is the single biggest framework piece contributing
    a whopping *500 KB+* to the Angular bundle (In Angular 2 *v2.0.0*).
  prefs: []
  type: TYPE_NORMAL
- en: Using tree shaking together with **Ahead-of-Time** (**AoT**) compilation, we
    can just get rid of the Angular compiler (in the browser) altogether.
  prefs: []
  type: TYPE_NORMAL
- en: With AoT compilation, the view templates (HTML) are compiled beforehand on the
    server side. This compilation again is done as part of the app's build process
    where a server version of Angular 2 compiler (a node package) compiles every view
    in the application.
  prefs: []
  type: TYPE_NORMAL
- en: With all the templates compiled, there is no need to send the Angular compiler
    bits to the client side at all. Tree shaking can now just get rid of the compiler
    and create a far slimmer framework package.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Read more about AoT in the framework documentation available at [http://bit.ly/ng2-aot](http://bit.ly/ng2-aot).
  prefs: []
  type: TYPE_NORMAL
- en: Initial load time and memory utilization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The initial load time for any web app with a full-fledged framework is typically
    slow. This effect is more pronounced on mobile devices, where the JavaScript engine
    may not be as powerful as a desktop client. For a better user experience, it becomes
    imperative that the framework initial load time is optimized, especially for mobile
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: Out of the box, **Angular 2 is five times faster than Angular 1** when it comes
    to initial load time and re-rendering the view. These numbers will get better
    as the Angular team evolves the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Further, AoT compilation too can improve the initial load time of the application
    as a time-consuming activity (view compilation) is not required.
  prefs: []
  type: TYPE_NORMAL
- en: The same holds good for memory utilization. Angular 2 fares better here too,
    and things will get even better with future releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are planning to switch to Angular 2, this is something that you should
    look forward to: a performant framework built for the future.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next three performance improvements that we are going to talk about have
    been made possible because of a single architectural decision: *the creation of
    a separate renderer layer*.'
  prefs: []
  type: TYPE_NORMAL
- en: The Angular rendering engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The biggest disadvantage of Angular 1 was that the framework was tied to the
    browser DOM. The directives, the binding, and the interpolations all worked against
    the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Angular 2, the biggest architectural change that came in was a separate
    rendering layer. Now an Angular 2 app has two layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application layer**: This is the layer our code resides in. It uses an abstraction
    build over the renderer layer to interact with it. The Renderer class we saw in
    [Chapter 6](part0066.xhtml#aid-1UU542 "Chapter 6.  Angular 2 Directives in Depth"),
    *Angular 2 Directives in Depth*, is the interface that we use to interact with
    the rendering layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rendering layer**: This layer is responsible for translating requests from
    the application layer into rendered components, and reacting to user input and
    view updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default renderer implementation for the renderer is `DomRenderer`, which
    runs inside the browser. But there are other rendering abstractions too and we
    will discuss them in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Prerendering** on the server side is yet another technique for improving
    the initial load time of an Angular 2 app. This technique is really helpful on
    mobile devices, as it improves the perceived load time considerably.'
  prefs: []
  type: TYPE_NORMAL
- en: Server-side rendering takes care of the initial page load before client-side
    rendering kicks in (and handles view rendering henceforth).
  prefs: []
  type: TYPE_NORMAL
- en: In such a scenario, when the user requests for a view/page, a piece of software
    on the server generates a fully materialized HTML page with data pre-bound to
    the view and sends it to the client along with a small script. The app view hence
    is immediately rendered, ready for interaction. While the framework loads in the
    background, the small script that was sent along the first time captures all user
    inputs and makes them available to the framework, allowing it to replay the interactions
    once it is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Angular Universal, as it is touted, allows rendering and sharing of the view
    both on the server- and client-side.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side rendering is only made possible because of separation of the rendering
    layer as described previously. The initial view is generated by a renderer implementation
    on the server, named `ServerDomRenderer`. There is a Node.js plugin ([http://bit.ly/ng2-universal-node](http://bit.ly/ng2-universal-node))
    that can be used in a number of node web frameworks such as *Express*, *Hapi*,
    *Sail*, and others. Efforts are also ongoing to have a rendered implementation
    for other popular server platforms such as .NET and PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Look at the Angular design docs for Angular Universal ([http://bit.ly/ng2-universal-design](http://bit.ly/ng2-universal-design))
    and the embedded YouTube videos at the top of the design doc to learn more about
    server-side rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Performance is not the only benefit with server-side rendering. As it turns
    out, search indexers too like pre-rendered HTML content. Server-side rendering
    is really useful in areas such as **search engine optimization (SEO)** and deep
    linking, which allows easy content sharing.
  prefs: []
  type: TYPE_NORMAL
- en: Offloading work to a web worker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Offloading work to a **web worker** is a neat idea, again made possible due
    to the separation of the rendering layer from the application layer.
  prefs: []
  type: TYPE_NORMAL
- en: '*Web workers* provide a mechanism for running scripts in background threads.
    These threads can execute work that does not involve the browser DOM. Be it a
    CPU-intensive task or a remote XHR invocation, all can be delegated to web workers.'
  prefs: []
  type: TYPE_NORMAL
- en: In today's world, CPUs with multiple cores are the norm, but JavaScript execution
    is still single-threaded. There is a need for a standard/mechanism to utilize
    these idle cores for our apps. Web worker fits the bill perfectly, and since most
    modern browsers support them, we all should be writing code that utilizes web
    workers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sadly that''s not happening. Web workers are still not mainstream and there
    are good reasons for that. Web workers impose a good number of restrictions on
    what is allowed and what is not. These limitations include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No direct access to DOM**: Web workers cannot directly manipulate the DOM.
    In fact, web workers do not have access to multiple globals such as *window* and
    *document*, and others are not available on the web worker thread. This severely
    limits the number of use cases where a web worker can be utilized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Browser support**: Web workers are only available for modern/evergreen browsers
    (IE 10+).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inter process communication**: Web workers do not share memory with your
    main browser process and hence need to communicate with the main thread (UI thread)
    only through *message passing* (serialized data). Adding to that, the message
    passing mechanism is asynchronous in nature, adding another layer of complexity
    to the communication model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearly, web workers are hard to use.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 tries to alleviate these limitations by integrating the web worker
    usage into the framework itself. It does that by running the complete application
    in the web worker thread, except the rendering part.
  prefs: []
  type: TYPE_NORMAL
- en: The framework takes care of the communication between the application code running
    inside the web worker, and the renderer running inside the main UI thread. From
    a developer's perspective, there are no visible differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is again made possible due to the separation of the renderer layer in
    Angular 2\. The following diagram shows the layers that run on the app main thread
    and what runs inside the web worker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Offloading work to a web worker](../Images/image00408.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go through at this talk ([http://bit.ly/yt-ng2-web-worker](http://bit.ly/yt-ng2-web-worker))
    from Jason Teplitz to learn about what web workers have to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Performant mobile experience
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular's rendering abstraction again opens up a host of integration avenues,
    especially on the mobile platform. Rather than running an app on a mobile browser,
    Angular renderers can be created that can tap the device's native UI capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two notable projects in this domain are renderers for platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ReactNative** ([http://bit.ly/rnative](http://bit.ly/rnative)): A renderer
    for ReactNative ([http://bit.ly/ng2-rnative](http://bit.ly/ng2-rnative)). It allows
    writing of Angular 2 apps using ReactNative''s rendering capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NativeScript** ([https://www.nativescript.org/](https://www.nativescript.org/)):
    Angular and NativeScript teams have collaborated to create a renderer for NativeScript
    ([http://bit.ly/ng2-native-script](http://bit.ly/ng2-native-script)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App platforms such as *ReactNative* and *NativeScript* already do a superb job
    of providing JavaScript-based APIs for the native mobile platforms (iOS and Android),
    allowing us to utilize a single code base, with a familiar language. Angular renderers
    take things a step further. With Angular integration, a good amount of code can
    be shared across browsers and mobile devices. Things may only differ in terms
    of view templates and view-related services such as dialogs, popups, and others.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the documentation for the respective renderers to understand how they
    work and the features they support.
  prefs: []
  type: TYPE_NORMAL
- en: Next up on the line, we have framework improvements in terms of *change detection*.
  prefs: []
  type: TYPE_NORMAL
- en: Change detection improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the major performance improvements in Angular 2 over Angular 1 is in
    how *change detection* works in Angular 2\. Angular 2 change detection out of
    the box is insanely fast, and it can be tweaked further for even better results.
  prefs: []
  type: TYPE_NORMAL
- en: The next few sections talk about Angular change detection in depth. It's an
    important topic to understand when building anything at scale. It also helps us
    debug scenarios where it may seem that change detection is not working as advertised.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start the discussion by understanding what change detection is and why
    it is important.
  prefs: []
  type: TYPE_NORMAL
- en: Change detection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Angular's *data binding engine* does a great job of binding the view with the
    model data (component data). These are live bindings where Angular keeps the view
    in sync with model changes. Any time the model changes, the binding engine re-renders
    parts of the view that are dependent on the model. To manage this view-model synchronization,
    Angular needs to know when the model changed and what changed exactly. This is
    what **change detection** is all about. During app execution, Angular frequently
    does what we call **change detection runs** to determine what changed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are from Angular 1, *change detection run* is roughly equivalent to **digest
    cycles**, except that in Angular 2 there are no cycles.
  prefs: []
  type: TYPE_NORMAL
- en: While this problem of keeping the model and view in sync may sound simple, it's
    a tough nut to crack. Unlike the component tree, the interconnection between multiple
    models can be complex. Changes in one component model can trigger changes in multiple
    component models. Furthermore, these interconnections may have cycles. A single
    model property could be bound to multiple views. All these complex scenarios need
    to be managed using a robust change detection infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, we explore how the Angular change detection infrastructure
    works, when change detection triggers, and how can we influence change detection
    behavior in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Change detection setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It all starts with Angular setting up change detectors for every component
    rendered on the view. Since every Angular app is a hierarchy of components, these
    change detectors are also set up in the same hierarchy. The following diagram
    highlights the **change detector hierarchy** of the *Workout Builder* app at a
    point in time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Change detection setup](../Images/image00409.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A *change detector* attached to a component has the responsibility of detecting
    changes in the component. It does that by parsing the binding on the component's
    template HTML and sets up the necessary change detection watches.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the detector only sets up watches on model properties used in the
    template, not on all component properties.
  prefs: []
  type: TYPE_NORMAL
- en: Another important point worth highlighting here is that *change detection is
    set up one way, from model to view*. Angular does not have the concept of two-way
    data binding and hence the preceding figure is a directed tree without cycles.
    This also makes change detection more predictable. Interleaving model and view
    updates is disallowed.
  prefs: []
  type: TYPE_NORMAL
- en: When does change detection kick in?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Does Angular constantly check for changes in the model data? Considering the
    fact that the component properties we bind the view to do not inherit from any
    special class, Angular has no way of knowing which property changed. The only
    way out for Angular is to constantly query each data-bound property to know its
    current value and compare it against its old value for changes. Highly inefficient
    to say the least!
  prefs: []
  type: TYPE_NORMAL
- en: Angular does better than that, as change detection runs get executed only at
    specific times during app execution. Think carefully about any web application;
    what causes a view to update?
  prefs: []
  type: TYPE_NORMAL
- en: 'View can get updated due to:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User input/ browser events**: We click on a button, enter some text, and
    scroll the content. Each of these actions can update the view (and the underlying
    model).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote XHR requests**: This is another common reason for view updates. Getting
    data from a remote server to show on the grid and getting user data to render
    a view are examples of this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**setTimeout and setInterval timers**: As it turns out, we can use `setTimeout`
    and `setInterval` to execute some code asynchronously and at specific intervals.
    Such code can also update the model. For example, a `setInterval` timer may check
    for stock quotes at regular intervals and update the stock price on the UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For obvious reasons, Angular change detection too kicks in only when any of
    these conditions occur.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting part here is not when Angular's change detection kicks in but
    how Angular is able to intercept all *browser events*, *XHR requests*, and `setTimeout`
    and `setInterval` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This feat in Angular is performed by a library called **zone.js**. As the documentation
    describes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A Zone is an execution context that persists across async tasks.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'One of the basic abilities of this library is that it can hook into a piece
    of code and trigger callbacks when code execution starts and when it ends. The
    code being monitored could be a sequence of calls that are both synchronous and
    asynchronous in nature. Consider this example, which highlights the usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We wrap a piece of code inside a call to the `zone.run` call. This code calls
    the `doWork` function synchronously twice, interleaved with a `setTimeout` call
    that invokes the same function after a lapse of 200 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'By wrapping this sequence inside `zone.run`, we can know when the call execution
    is complete. In zone terminology, these are **turns**. The code before `zone.run`
    sets up a subscriber that gets called when execution is complete, using the `zone.onMicrotaskEmpty`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we execute the preceding code, the logs look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `onMicrotaskEmpty` subscription is executed twice, once after the sequential
    execution completes (defined inside `run` callback) and one after the asynchronous
    `setTimeout` execution is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 change detection uses the same technique to execute our code within
    zones. This code could be an *event handler*, which internally makes more synchronous
    and asynchronous calls before completing. Or it could be a `setTimeout`/`setInterval`
    operation that may again require a UI update.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular change detection framework subscribes to the `onMicrotaskEmpty`
    observable for the executing zone, and kicks in change detection whenever a turn
    is complete. The following diagram highlights what happens when code similar to
    the one just described is run on a button click:'
  prefs: []
  type: TYPE_NORMAL
- en: '![When does change detection kick in?](../Images/image00410.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During the execution of the code block, if the zone library determines that
    the call is asynchronous in nature, it spawns a new micro task that has its own
    life cycle. It is the completion of these micro tasks that also triggers `onMicrotaskEmpty`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to know how the change detection trigger looks inside Angular,
    here is an excerpt from the Angular source code (simplified further):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `ApplicationRef` class tracks all the change detectors attached throughout
    the app and triggers a change detection cycle when the application-level zone
    object fires the `onMicrotaskEmpty` event. We will shortly touch upon what happens
    during this change detection.
  prefs: []
  type: TYPE_NORMAL
- en: '*Zonejs* gets the ability to track execution context across any asynchronous
    call because it overrides the default browser API. The override, also termed **monkey
    patching**, overrides the *event subscription*, *XHR requests*, and `setTimeout`/`setInterval`
    API. In the example highlighted previously, the `setTimeout` we invoke is a monkey-patched
    version of the original browser API.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how change detectors are set up and when this activity kicks
    in, we can look at how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How does change detection work?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the change detectors are set up and the browser API is monkey-patched to
    trigger change detection, the real change detection kicks in. This is quite a
    simple process.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as any of the asynchronous event callbacks is triggered (execution of
    an event handler is also an async activity), Angular first executes the application
    code we have attached to the callback. This code execution may result in some
    model updates. Post the execution of the callback, Angular needs to respond to
    the changes by triggering a *change detection run*.
  prefs: []
  type: TYPE_NORMAL
- en: In a change detection run, starting from the top of the component tree, every
    change detector evaluates its respective component's template bindings to see
    if the value of the binding expression has changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some things that we need to highlight regarding this execution:'
  prefs: []
  type: TYPE_NORMAL
- en: Angular does a strict equality check (using `===`) to detect changes. Since
    it's not a deep comparison, for a binding that refers to an object Angular will
    only update the view when the object reference changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The change detection flow is unidirectional (starting from root), from parent
    to child in a top-down fashion. The detectors on the parent component run before
    the child detectors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, the change detection algorithm navigates the complete tree, irrespective
    of where the change was triggered in the tree. This implies all binding is evaluated
    on every change detection run.
  prefs: []
  type: TYPE_NORMAL
- en: '![How does change detection work?](../Images/image00411.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Binding evaluation on every run may seem inefficient but it is not. Angular
    employs some advance optimizations to make this check superfast. Still if we want
    to tweak this behavior, we do have some switches that can reduce the number of
    checks performed. We will touch upon this topic soon.
  prefs: []
  type: TYPE_NORMAL
- en: Change detectors only track properties that are part of template bindings, not
    the complete object/component properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To detect changes in the bound value, the change detectors need to track the
    previous value of the expression evaluated during the last change detection run.
    Clearly some amount of book keeping is required for every template binding we
    use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The obvious next question would be: What happens when a change is detected
    (by a change detector)?'
  prefs: []
  type: TYPE_NORMAL
- en: Since all the hard work of setting up change detection and identifying changes
    has already been done, this step just involves updating the component state and
    synchronizing the component DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few more observations worth highlighting here:'
  prefs: []
  type: TYPE_NORMAL
- en: First and foremost, Angular separates the model update step from the DOM update.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider this code snippet, which is invoked when someone clicks on a button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Assuming that both `firstName` and `lastName` are bound to the component view,
    a change to `firstName` does not update the DOM binding immediately. Instead,
    Angular waits for the `doWork` function to complete before triggering a change
    detection run and DOM update.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, a change detection run does not (and should not) update the model
    state. This avoids any cycles and cascading updates. A change detection run is
    only responsible for evaluating the bindings and updating the view. This also
    means that we should not update the model state during change detection. If we
    update the model during change detection, Angular throws an error. Let''s see
    an example of this behavior:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open `start.html` and update the last div to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And add a `changeDetectionDone` function to the component implementation (`start.component.ts`),
    which looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the app, load the start page, and then look at the browser console. Angular
    has logged a number of errors that look like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We are changing the state of the component when calling the `changeDetectionDone`
    function (inside an interpolation), and Angular throws an error because it does
    not expect the component state to update.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This change detection behavior is enabled only when **production mode** in Angular
    has not been enabled. Angular's *production mode* can be enabled by calling the
    `enableProdMode()` function before bootstrapping the application (in `bootstrap.ts`).
  prefs: []
  type: TYPE_NORMAL
- en: When enabled, Angular behaves a bit differently. It turns off assertions and
    other checks within the framework. Production mode also affects the change detection
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In non-production mode, Angular traverses the component tree twice to detect
    changes. If on the second pass any binding expression has changed, it throws an
    error.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, when in production mode, change detection tree traversal is done
    only once. The change detection error that we saw in the console will not show
    up if we enable production mode. This can lead to an inconsistency between the
    model and view state. Something we should be aware of!
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom-line is that we cannot alter the state of a component when change
    detection is in progress. A direct corollary: if we are using a function inside
    the binding expression, function executions should be stateless, without any side
    effects.'
  prefs: []
  type: TYPE_NORMAL
- en: And lastly, this change detection traversal from root to leaf node executes
    only once during the change detection run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A pleasant surprise for folks with an Angular 1 background! *The digest cycle
    count is Angular 2 is 1*. Angular 2 developers will never face "the digest iterations
    exceeded exception!" A far more performant change detection system!
  prefs: []
  type: TYPE_NORMAL
- en: Change detection performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's talk about change detection performance. If you think checking the complete
    component tree every time for change is inefficient, you would be surprised to
    know how fast it is. Due to some optimization done in terms of how expressions
    are evaluated and compared, Angular can perform thousands of checks in a couple
    of milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, for every expression involved in the view binding, Angular generates
    a change detection function that specifically targets a particular binding. While
    it may seem counterintuitive at first, Angular does not have a common function
    for determining whether an expression has changed. Instead, it's like writing
    our own change detection function for every property that we bind to. This allows
    the JavaScript VM to optimize the code, resulting in improved performance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Want to learn more about it? Check out this video by Victor Savkin: [https://youtu.be/jvKGQSFQf10](https://youtu.be/jvKGQSFQf10).'
  prefs: []
  type: TYPE_NORMAL
- en: In spite of all this optimization, there may still be cases where traversing
    the complete component tree may not be performant enough. This is especially true
    when we have to render a large dataset on the view, keeping the bindings intact.
    The good news is that the Angular change detection mechanism can be tweaked.
  prefs: []
  type: TYPE_NORMAL
- en: The reason Angular needs to do the complete tree walk is that model changes
    at one place may trigger model changes at other places. In other words, a model
    change may have a cascading effect, where interconnected model objects are also
    updated. Since Angular has no way to know what exactly changed, it checks the
    complete component tree and associated model.
  prefs: []
  type: TYPE_NORMAL
- en: If we can help Angular determine what parts of the application state are updated,
    Angular can be pretty smart about what part of the component tree it traverses
    to detect changes. We do this by storing the app data in some special data structures
    that help Angular decide what components need to be checked for changes.
  prefs: []
  type: TYPE_NORMAL
- en: There are three ways in which we can make Angular change detection smarter.
  prefs: []
  type: TYPE_NORMAL
- en: Using immutable data structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Immutable objects/collections** are objects that cannot be changed once created.
    Any property change results in a new object being created. This is what **immutable.js**,
    a popular library for immutable data structures, has to say:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Immutable data cannot be changed once created, leading to much simpler application
    development, no defensive copying, and enabling advanced memoization and change
    detection techniques with simple logic.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let's try to understand how immutable data structures help in the Angular context
    with an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine we are building a set of components to collect employee information
    for a **Human Resource** (**HR**) software. The employee component view looks
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It has sections for taking personal, professional, and address information.
    The `summary` components provide a read-only view for employee data being entered.
    Each of the components has a property called `model`, highlighting what part of
    employee data these components manipulate. Each of these components'' summary,
    professional, personal, and address internally may have other child components.
    This is how the component tree looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using immutable data structures](../Images/image00412.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What happens when we update an employee's personal information? With standard
    objects (mutable), Angular cannot make any assumption about the shape of data
    and what all has changed; hence, it does the complete tree walk.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does immutability help here? When using an immutable data structure, any
    change to an object''s properties results in a new object being created. For example,
    if we create an immutable object using a popular library, *immutablejs*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Changes to either the `name` or `age` property of `personalInfo` create a new
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This immutability comes in handy if each of the employee model properties (`personal`,
    `professional`, `home` and `work`) is immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take for instance the `PersonalInfo` component definition that binds to personal
    info data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Since the only thing `PersonalInfo` depends upon is the `model` property, and
    the `model` property binds to an immutable object, Angular only needs to do a
    check for changes if the `model` reference changes. Otherwise, the complete `PersonalInfo`
    component subtree can be skipped.
  prefs: []
  type: TYPE_NORMAL
- en: By setting the `PersonalInfo` component property `changeDetection` to `ChangeDetectionStrategy.OnPush`,
    we instruct Angular to trigger change detection only when the component's inputs
    change.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we change the change detection strategy to `OnPush` for each of the Employee
    component children and update the employee''s personal info, only the `PersonalInfo`
    component subtree is checked for changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using immutable data structures](../Images/image00413.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For a large component tree, such an optimization will improve the app/view performance
    manifold.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When set to `OnPush`, Angular triggers change detection only when the component's
    input property changes or there is an event raise inside the component or its
    children.
  prefs: []
  type: TYPE_NORMAL
- en: Developing applications using immutable data structures departs from the standard
    development paradigm where the applicate state is totally mutable. What we have
    highlighted in this section is how Angular takes advantage of immutable data structures
    to optimize the change detection process.
  prefs: []
  type: TYPE_NORMAL
- en: '*Observables* are another kind of data structure that can help us optimize
    Angular change detection.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Observables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Observables** are data structures that trigger events when their internal
    state changes. The Angular *eventing infrastructure* extensively uses *observables*
    to communicate the components'' internal state to the outside world.'
  prefs: []
  type: TYPE_NORMAL
- en: While we have used observable *output * *properties* (the `EventEmitter` class)
    to raise events, *input * *properties* too can take observables. Such observable
    inputs can help Angular optimize change detection.
  prefs: []
  type: TYPE_NORMAL
- en: When using observables, the change detection switch still remains `ChangeDetectionStrategy.OnPush`.
    But this time, only if a component input triggers an event (as they are observables)
    will Angular perform the dirty check. When the input triggers an event, the complete
    component tree path, starting from the affected component to the root, is marked
    for verification.
  prefs: []
  type: TYPE_NORMAL
- en: When performing the view update, Angular will only sync the affected path and
    ignore the rest of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Manual change detection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can actually disable change detection on a component completely and trigger
    manual change detection when required. To disable change detection, we just need
    to inject the component-specific change detector (the `ChangeDetectorRef` class
    instance) into the component and call the `detach` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now the onus is on us to inform Angular when the component should be checked
    for changes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can reattach the component to the change detection tree by using the `reattach`
    function on `ChangeDetectorRef.`
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ChangeDetectorRef` class has two functions that can be utilized for manual
    change detection:'
  prefs: []
  type: TYPE_NORMAL
- en: '`markForCheck`: This marks the path from the detector to the root for dirty
    checking. Remember, the actual dirty check is only performed once all of the app
    code has executed, and not as soon as we call `markForCheck`. This snippet shows
    the use of this function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`detectChanges`: This function actually performs change detection on the component
    on which it is called (and its children). Using `detectChanges` is like isolating
    the tree from the rest of the application and performing local change detection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We seldom need to disable the standard change detector setup, unless there are
    situations where standard change detection becomes an expensive affair.
  prefs: []
  type: TYPE_NORMAL
- en: Take, for example, a public chatroom app, which is receiving messages from thousands
    of people connected to it. If we constantly keep pulling the messages and refreshing
    the DOM, the app may become unresponsive. In such a scenario, we can disable change
    detection on parts of the chat app component tree and manually trigger change
    detection to update the UI at specific intervals.
  prefs: []
  type: TYPE_NORMAL
- en: While we have seen three ways to tweak change detection behavior, the good thing
    is that these are not exclusive. Parts of the component tree can use immutable
    data structures, parts can use observables, parts can employ manual change detection,
    and the rest can still use the default change detection. And Angular will happily
    oblige!
  prefs: []
  type: TYPE_NORMAL
- en: Enough on change detection for now. We may never need it unless we are building
    some large views with a chatty UI. Such scenarios require us to squeeze every
    bit of performance out of the change detection system, and the system is ready
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will have a look at another common requirement that most apps invariably
    have: authenticating their users.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling authentication and authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most, if not all, apps have a requirement to authenticate/authorize their users.
    We may argue that authentication and authorization are more of a server concern
    than a client one, and that is correct. Still, the client side needs to adapt
    and integrate with the authentication and authorization requirement imposed by
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: In a typical app execution workflow, the app first loads the partial views,
    then makes calls to pull data from the server, and finally binds data to its view.
    Clearly, the views and the remote data API are two assets that need to be secured.
  prefs: []
  type: TYPE_NORMAL
- en: 'To guard these resources, you need to understand how a typical application
    is secured on the server. There are primarily two broad approaches to securing
    any web applications: *cookie-based authentication* and *token-based authentication*.
    Each of them requires different handling on the client part. The next two sections
    describe how we can integrate with either of these approaches.'
  prefs: []
  type: TYPE_NORMAL
- en: Cookie-based authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This authentication mechanism is the easiest to implement if the server stack
    supports it. It''s non-intrusive and may require bare minimum changes to the Angular
    application. **Cookie-based authentication** involves setting the browser cookie
    to track the user authentication session. The following sequence diagram explains
    a typical cookie-based authentication workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cookie-based authentication](../Images/image00414.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is how a typical authentication workflow works:'
  prefs: []
  type: TYPE_NORMAL
- en: When trying to access a secured resource from the browser, if the user is not
    authenticated, the server sends an HTTP 401 Unauthorized status code. As we will
    see later, a user request is an unauthorized request if there is no cookie attached
    to the request or the cookie is expired/invalid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This unauthorized response is intercepted by the server or, at times, by the
    client framework (Angular in our case) and it typically results in a 302 redirect
    (if intercepted by the server). The redirect location is the URL to the login
    page (the login page allows anonymous access).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user then enters the username and password on the login page and does a
    POST to the login endpoint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server validates the credentials, sets a browser cookie, and redirects the
    user to the original requested resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Henceforth, the authentication cookie is a part of every request (added by the
    browser automatically), and the server uses this cookie to confirm his identity
    and whether the user is authenticated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This scenario assumes that the HTML and API exist under a single domain.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, with this approach, the Angular infrastructure is not involved;
    or the involvement is minimal. Even the login page can be a standard HTML page
    that just sends data to the login endpoint for authentication. If the user lands
    on the Angular app, it implicitly means that the user has been authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The cookie-based authentication flow may vary depending on the server framework,
    but the general pattern of setting a cookie and attaching a cookie with every
    subsequent request remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: In a cookie-based application authentication, if the application wants to get
    the user context, a server endpoint (such as `/user/details` ) is exposed that
    returns the logged-in-user-specific data. The client application can then implement
    a service such as `UserService` that loads and caches the user profile data.
  prefs: []
  type: TYPE_NORMAL
- en: The scenario described here assumes that the API server (the server that returns
    data) and the site where the application is hosted are in a single domain. That
    may not be the case always. Even for *Personal Trainer*, the data resides on the
    *MongoLab* servers and the application resides on a different server (even if
    it is local). And we already know that this is a cross-domain access and it comes
    with its own set of challenges.
  prefs: []
  type: TYPE_NORMAL
- en: In such a setup, even if the API server is able to authenticate the request
    and send a cookie back to the client, the client application still does not send
    the authentication cookie on a subsequent request.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, we need to set a Boolean variable, `withCredentials`, to `true`
    on the XHR request. This can be enabled at the global level by overriding `BaseRequestOptions`
    (the `withCredentials` property). The framework uses the `BaseRequestOptions`
    class for the default HTTP request option. See the next section, *Token-based
    authentication*, to learn how to override `BaseRequestOptions`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can also be enabled on a per-request level by passing in the `withCredentials:true`
    flag in each HTTP request method as the last parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The last parameter to every HTTP function, including `get`, `post`, and `put`,
    is a `RequestOptionsArgs` object. This allows us to override some properties of
    the request being made.
  prefs: []
  type: TYPE_NORMAL
- en: Once this flag is enabled, the client browser will start attaching the authentication
    cookie for the cross-domain requests.
  prefs: []
  type: TYPE_NORMAL
- en: The server too needs to have **cross-origin resource sharing** (**CORS**) enabled
    and needs to respond in a specific manner for the request to succeed. It should
    set the **access-control-allow-credentials** header to true and the **access-control-allow-origin**
    header to the host site making the request.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Check out the MDN documentation ([http://bit.ly/http-cors](http://bit.ly/http-cors))
    to learn about this scenario in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cookie-based authentication is definitely less work on the client side, but
    there are times when you have to revert to token-based access. This could be because:'
  prefs: []
  type: TYPE_NORMAL
- en: Cookies and cross-domain requests do not play nicely across browsers. Specifically,
    IE8 and IE9 do not support it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server may not support generating cookies, or the server only exposes token-based
    authentication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Token-based solutions are easy to integrate with native mobile application and
    desktop clients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tokens are not susceptible to cross-site request forgery (CSRF) attacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To know more about CSRF, look at the CRSF Prevention cheat sheet here at [http://bit.ly/csrf-cs](http://bit.ly/csrf-cs).
  prefs: []
  type: TYPE_NORMAL
- en: The next section talks about supporting token-based authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Token-based authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Token-based access** is all about sending a token (typically in HTTP headers)
    with each request instead of a cookie. A simplified token-based workflow looks
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Token-based authentication](../Images/image00415.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Many public APIs (such as *Facebook* and *Twitter*) use token-based authentication.
    The format of the token, where it goes, and how it is generated depends on the
    protocol used and the server implementation. Popular services that use token-based
    authentication implement the **OAuth 2.0** protocol for token generation and exchange.
  prefs: []
  type: TYPE_NORMAL
- en: In a typical token-based authentication setup, the views are available publically
    but the API is secured. If the application tries to pull data through API calls
    without attaching the appropriate token to the outgoing request, the server returns
    an *HTTP 401 Unauthorized* status code.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with a token-based authentication system requires a decent amount
    of setup on the client side too. Let's take the simplified example of a *Human
    Resource (HR)* system that supports token-based authentication so that you understand
    how the authentication workflow works with the Angular application as a client.
  prefs: []
  type: TYPE_NORMAL
- en: The HR system has a page showing a list of employees and a login page. It also
    has API endpoints to get a list of employees and generate access tokens. The API
    endpoint that returns the employee list is secured by token-based access.
  prefs: []
  type: TYPE_NORMAL
- en: The workflow starts with the user loading the employee list page. The view is
    loaded but the API call fails, with the server returning *HTTP 401 Unauthorized*.
  prefs: []
  type: TYPE_NORMAL
- en: On receiving a 401 HTTP error code, the app should respond by either routing
    the user to a login view (remember this is an SPA) or opening a login popup.
  prefs: []
  type: TYPE_NORMAL
- en: 'A naive implementation for this could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The biggest problem with the preceding implementation is that we need to add
    the catch block to every component that requires remote data access as the call
    may fail. Not very smart!
  prefs: []
  type: TYPE_NORMAL
- en: Instead we have to centralize this check. Given that an Angular app is basically
    a component tree, such a check can be added to a top-level component. The `canActivate`
    component guard hook will be the right place to add this check.
  prefs: []
  type: TYPE_NORMAL
- en: 'So given this route configuration on the app root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To block unauthorized access to `/home`, we can implement the `canActivate`
    guard class as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And then extend the route definition for home to include this guard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To understand how the `canActivate` function can be implemented, we need to
    know what happens on the client during token authentication.
  prefs: []
  type: TYPE_NORMAL
- en: With token-based authentication, the login page looks similar to a cookie-based
    login page, but instead of cookies being set on the server as part of the login
    process, a token is returned. This token needs to be attached to all subsequent
    API requests that are secure. This token hence needs to be persisted in the *browser's
    local storage*, and all this is done the first time the token is received.
  prefs: []
  type: TYPE_NORMAL
- en: 'An *authentication service* can perform such chores. A sample implementation
    of the service looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The service does an HTTP `post` to the login endpoint, and on receiving the
    authentication token, it stores the token in the browser's local storage.
  prefs: []
  type: TYPE_NORMAL
- en: Post authentication, the next task is to attach the token on subsequent requests
    that access the secured API resource. For most API implementations, this token
    needs to be added to the request header.
  prefs: []
  type: TYPE_NORMAL
- en: 'All `http` service functions: `get`, `post`, and others-take an extra parameter
    of type `RequestOptionsArgs`, used to pass some extra parameter to the request.
    We can use the `headers` property to set the *auth token* for HTTP requests that
    require authorization. The name of the token may vary based on the backend implementation,
    but this is how a typical request with a token looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Although this approach works, it's quite verbose and cumbersome. Each call to
    the secured API now needs this extra parameter to be set. We need some better
    alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular has a `BaseRequestOptions` class that contains the default options
    for an HTTP request. We can replace `BaseRequestOptions` with our own options
    using Angular DI. This can be done by inheriting from the `BaseRequestOptions`
    class and overriding the DI provider for `BaseRequestOptions` during bootstrap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Sadly, this doesn't work! Since the authorization token is not available till
    authentication is done, setting up `RequestOptions` during bootstrap will result
    in an empty `Authorization` header being set on all future HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Overriding `RequestOptions` during bootstrapping is only useful if we have the
    necessary content available during that phase.
  prefs: []
  type: TYPE_NORMAL
- en: What other options are we left with? Angular 2, unlike Angular 1, does not have
    **global interceptors** that can be used to inject the headers before the request
    is made. Therefore, the only viable alternative is to create a custom HTTP client
    service to communicate with the secure API. This service can attach the token
    transparently when available.
  prefs: []
  type: TYPE_NORMAL
- en: We have created a sample service implementation for this purpose and the implementation
    is available at [http://bit.ly/ng2-auth-svc](http://bit.ly/ng2-auth-svc). We will
    be highlighting some relevant parts of this `AuthHttp` service.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `AuthHttp` exposes the same interface as the HTTP service, with its function
    internally delegating the request to the original `http` service. The next snippets
    detail two such HTTP functions, `get` and `post`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the HTTP function wrappers internally calls the `_request` private
    method. This function does most of the heavy lifting, which involves setting the
    HTTP authorization header, making a request, and receiving the response. The function
    implementation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: After merging the request options and setting the authorization header, the
    function creates a custom observable that makes a request using the `http` service
    `request` function. On receiving a response, the observer emits the response and
    is marked complete (no more events).
  prefs: []
  type: TYPE_NORMAL
- en: '*401* error handling is a bit different in the preceding function. The function
    calls `this.authFailed.next(err)` and raises an event on an `EventEmitter` defined
    on the `AuthHttp` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Then it triggers the standard error triggering mechanism with `observer.error(err)`;
  prefs: []
  type: TYPE_NORMAL
- en: The usefulness of this event will be clear pretty soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `_buildAuthHeader` implementation is simple as it pulls the authorization
    token from the browser''s local storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This service can now be injected and used to invoke any secure API, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This call will add the authorization token if available to the API request.
  prefs: []
  type: TYPE_NORMAL
- en: What have we done thus far? The views have been secured using the `@CanActivate`
    decorator and the API endpoints are secured too, but there is still one scenario
    that needs to be handled. What happens when the token expires?
  prefs: []
  type: TYPE_NORMAL
- en: When the API token expires, any access to API endpoints again results in 401
    errors. In such a scenario, the app should either redirect to the login page or
    show a login popup to continue.
  prefs: []
  type: TYPE_NORMAL
- en: To know when a request failed, we again use the `AuthHttp` service. The `authFailed`
    event on `AuthHttp` can be subscribed to. The best place to subscribe and react
    to this event would be in the *root component implementation*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the root component of the app, we just need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: And with that, we have now handled most of the scenarios related to token-based
    authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, token-based authentication, even though flexible, requires a decent
    amount of setup and coordination among various components/services.
  prefs: []
  type: TYPE_NORMAL
- en: This walkthrough just outlines one mechanism to send a token to the server,
    but the process may vary based on the server stack too. Always refer to the backend/server
    documentation before implementing a token-based authentication in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While working on this book, there were not many libraries out there that implemented
    these standard chores required for token-based authentication. In future, before
    you start, do check whether there is a popular/mature community offering for the
    same.
  prefs: []
  type: TYPE_NORMAL
- en: We have taken care of authentication, but what about authorization? Once the
    user context is established, we still need to make sure that the user is only
    able to access parts that he/she is allowed to. *Authorization* is still missing.
  prefs: []
  type: TYPE_NORMAL
- en: Handling authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like authentication, authorization support too needs to be implemented on both
    the server and client side, more so on the server than the client. Remember, anyone
    can hack into the JavaScript code and circumvent the complete authentication/authorization
    setup. So, always tighten your server infrastructure irrespective of whether the
    client has the necessary checks in place or not.
  prefs: []
  type: TYPE_NORMAL
- en: This still does not mean that we do not do any authorization check, on the client.
    For standard users, this is the first line of defence against unwarranted access.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working on an authorization requirement for any application, there are
    three essential elements that are part of the setup:'
  prefs: []
  type: TYPE_NORMAL
- en: The resources that need to be secured/authorized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of roles and users that are part of these roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mapping between the resources and the roles that defines who can access what
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From an Angular app perspective, the resources are the pages and, sometimes,
    sections of pages that need to be restricted to specific roles. If the user is
    in a specific role, depending upon the role-resource mapping, they get access
    to some pages; else they are denied access.
  prefs: []
  type: TYPE_NORMAL
- en: While authorization in an Angular application can be implemented in a number
    of ways, we will outline a generic implementation that can be further customized
    to suite your needs in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Adding authorization support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To enable authorization, the first thing that we need to do is expose the logged-in
    user data, including his/her roles throughout the application.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing user authentication context
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'User context can be shared using an Angular service, which can then be injected
    into components that require the authorization context. Look at this service interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SessionContext` service tracks the user login session and provides details
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The logged-in user (`currentUser`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the user is authenticated (`isAuthenticated`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `isUserInRole` function, which returns `true` or `false` based on whether
    the user is part of any of the roles passed into the `roles` parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With such a service in place, we can add authorization for routes, thereby restricting
    access to some routes to specific roles only.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting routes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Like authentication, the `canActivate` guard check can also be used for authorization.
    Implement a class with the `CanActivate` interface and inject the `SessionContext`
    service into the constructor; then check whether the user belongs to a specific
    role in the `canActivate` function using the `SessionContext` service. Check out
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Only users with roles of *Contributor* and *Admin* now have access to Home.
  prefs: []
  type: TYPE_NORMAL
- en: We register the preceding guard class with our routes in the same manner as
    we did earlier in the *Token-based Authentication* section.
  prefs: []
  type: TYPE_NORMAL
- en: And this is how we authorized access to our routes.
  prefs: []
  type: TYPE_NORMAL
- en: But what happens when a page has view elements that are rendered based on the
    user's role?
  prefs: []
  type: TYPE_NORMAL
- en: Conditionally rendering content based on roles
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Conditionally rendering content is easy to implement. We just need to show/hide
    HTML elements based on the user role. We can build a *structural directive* such
    as `ng-if` that can verify that the user belongs to a role before rendering the
    content. The directive usage looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code checks whether the user is in an admin role before rendering
    a **Site Setting** hyperlink.
  prefs: []
  type: TYPE_NORMAL
- en: 'The directive implementation mimics how `ng-if` works, except that our show/hide
    logic depends upon the `SessionContext` service. Here is a sample implementation
    for the `a2beRolesAllowed` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is a trivial implementation that uses `SessionContext` and the roles passed
    as input (`a2beRolesAllowed`) to show hide a fragment.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of authentication and authorization implementation.
    The reference implementation walkthrough should help us build authentication and
    authorization into our apps. With this basic understanding in place, any setup
    can be tweaked to handle other custom authentication/authorization scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s now time to address the elephant in the room: migrating from Angular
    1 to Angular 2\. If you are starting afresh on Angular 2, you can very well skip
    the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Migrating Angular 1 apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have been working extensively on Angular 1, Angular 2 poses some pertinent
    questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Should I migrate my Angular 1 apps to Angular 2?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the framework ready for prime time?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When should the migration happen?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the migration one-shot or can it be done in an incremental fashion?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the effort involved?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can I do something today that helps with the migration in the future?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I am starting with a new Angular 1 app today. What should I do to make the migration
    seamless in the future when Angular 2 is released?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every such query needs be addressed to make sure the transition is as smooth
    as possible. No one like surprises later in the game! In the coming sections,
    we will try to answer a number of such questions. As part of the learning, we
    will also walk you through migrating the Angular 1 version of the Trainer app
    (developed for the first version of this book) to Angular 2\. This will help everyone
    make some informed decisions on when and how to migrate to Angular 2.
  prefs: []
  type: TYPE_NORMAL
- en: '"Should I migrate or not?" is something that we will address first.'
  prefs: []
  type: TYPE_NORMAL
- en: Should I migrate?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just because Angular 2 is here does not mean Angular 1 is gone. Angular 1 is
    still being actively developed in parallel with Angular 2\. Google is committed
    to supporting Angular 1 for a good amount of time, and there have been a steady
    number of releases in Angular 1, with Angular 1.5 released in Feb 2016\. Given
    that Angular 1 will not be going away any time soon, we can think from our app's
    perspective now.
  prefs: []
  type: TYPE_NORMAL
- en: First things first, what has Angular 2 to offer over its predecessor?
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of Angular 2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Angular 2 is designed for the future and overcomes a number of shortcomings
    of its predecessor. In this section, we emphasize on what makes Angular 2 a better
    framework than Angular 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Things you should be aware of while making a decision to move to Angular 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Better behavioral encapsulation**: Admittedly, while Angular 1 scopes seem
    to be god sent when we started learning Angular 1, we have now realized how difficult
    it is to manage the hierarchical nature of scopes. Component-based development
    in Angular 2 provides a better encapsulation in terms of the state of the application.
    A component manages its own state, takes input, and raises events: a clear demarcation
    of responsibilities that are easy to reason with!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Less of framework in app code**: You don''t need special objects such as
    scope. DI works with annotation (in TypeScript). You don''t set up watches. All
    in all, when reading a component code, you will not find framework-level constructs
    in it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smaller framework API to explore**: Angular 1 had a host of directives that
    one had to be aware of. With Angular 2 template syntax, directives related to
    browser events are gone. This reduces the number of directives that one needs
    to be aware of.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Angular 2 is faster compared to its predecessor. A complete
    section of this book was dedicated to understanding what makes Angular 2 a high-performance
    framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mobile-friendly**: Angular 2 tries to optimize the user''s mobile experience
    by utilizing technologies such as server-side rendering and web workers. Angular
    2 applications on mobile are more performant that those of its predecessor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-platform**: Angular 2 targets to run on most devices and across platforms.
    You can use Angular 2 to build applications for web and mobile. As we learned
    earlier, the separation of the rendering layer has open up a great number of possibilities
    in terms of where Angular 2 can be utilized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In true sense, Angular 2 supersedes its predecessor, and in a perfect world,
    everyone should be working on a better framework/technology. But if you are the
    cautious type and want to try Angular 2 only once things become stable, we suggest
    you build your Angular 1 apps today in ways that allow easy migration to Angular
    2.
  prefs: []
  type: TYPE_NORMAL
- en: The next section talks about the principles and practices to follow for Angular
    1 today, allowing easy migration in future.
  prefs: []
  type: TYPE_NORMAL
- en: Developing Angular 1 apps today for easy migration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular 2 is a paradigm shift and the way we develop components in Angular 2
    is quite different from Angular 1\. For easy migration, Angular 1 too should embrace
    component-based development. This can be achieved if we follow some guidelines/principles
    while building Angular 1 apps. The next few sections detail these guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The advices listed here are highly recommended even if you do not plan to migrate
    to Angular 2\. These recommendation bits will make Angular 1 code more modular,
    organized, and testable.
  prefs: []
  type: TYPE_NORMAL
- en: One component per file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This can be anything: an Angular 1 *controller*, *directive*, *filter*, or
    *service*. One component per file allows better organization of code and easy
    migration, allowing us to clearly identify how much progress has been made.'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding inline anonymous functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use named functions instead to declare controllers, directives, filters, and
    services. A declaration such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Should be converted to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The advantages of using named functions are ease of debugging and ease of migration
    to TypeScript. Using named functions also requires that the dependencies be registered
    using the `$inject` function property.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`$inject`-based dependency declaration safeguards against minification and
    adds to the readability of the functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid exposing global name functions with this approach, it is advisable
    to wrap the function in an **Immediately Invoked Function Expression** (**IIFE**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding $scope!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yes, you read it right; avoid the $scope object or using scopes directly!
  prefs: []
  type: TYPE_NORMAL
- en: The biggest problem with Angular 1 scopes is their hierarchical nature. Accessing
    the parent scope from the child scope gives us tremendous flexibility but it comes
    at a cost. This can unknowingly create unwarranted dependencies that make the
    app really hard to debug and, of course, migrate. In contrast, in Angular 2 a
    view is bound to its component implementation and cannot access data outside its
    boundary implicitly. Therefore, if you plan to migrate to Angular 2, *avoid scopes
    at all costs*.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of techniques that can be used to remove the `$scope` object
    dependency. The next few subsections elaborate on some techniques that can help
    us avoid Angular 1 scopes.
  prefs: []
  type: TYPE_NORMAL
- en: Using controller as (controller aliasing) syntax everywhere
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Angular 1.3+ has the *controller as* syntax for *controller*, *directive*, and
    *routes*. *controller as* allows Angular 1 databinding expressions to bind to
    controller instance properties instead of the current scope object properties.
    With the controller as a paradigm in place, we never need to interact with the
    scope directly, and hence future migration becomes easy.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While controller aliasing gets rid of scope access, scopes are still there in
    Angular 1\. The complete Angular 1 databinding infrastructure depends upon scopes.
    Controller aliasing just puts an indirection between our code and scope access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following syntax for *controller as* in views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And the corresponding controller implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`WorkoutListController` as `workoutList` creates an alias `workoutList` for
    `WorkoutListController` on the current scope, hence allowing us to bind to the
    `workouts` property defined on the controller.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Route definition too allows controller aliasing using the `controllerAs` property
    in a *route definition object*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Finally, directives too can use `controllerAs`, and together with the `bindToController`
    property on the *directive definition object*, we can get rid of any direct scope
    access.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Look at the angular documentation on controller, routes, and directive to get
    a basic understanding of the controller as syntax. Also look at the following
    posts for some more detailed samples on this topic: [http://bit.ly/ng1-controller-as](http://bit.ly/ng1-controller-as)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[http://bit.ly/ng1-bind-to](http://bit.ly/ng1-bind-to)'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding ng-controller
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If scopes can be avoided, so can controllers!
  prefs: []
  type: TYPE_NORMAL
- en: This may again seem counterintuitive, but the approach has real benefits. What
    we ideally want to do is emulate component behavior in Angular 1\. Since the closest
    thing to components in Angular 1 is *element directives* (with `restrict='E'`),
    we should utilize *element directives* everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: An Angular 1 element directive with its own template and isolated scope can
    very well behave like an Angular 2 component and only be dependent on its internal
    state for its view binding. We just don't need `ng-controller`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the usage of `ng-controller` for audio tracking from the Angular 1
    version of the *Personal Trainer* app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using `WorkoutAudioController`, an element directive can encapsulate
    the workout audio''s view and behavior. Such a directive can then replace the
    complete `ng-controller` declaration and its view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'When replacing `ng-controller` with an element directive, the scope variables
    that the controller depends upon should be passed to the directive using the `bindToController`
    property on the *directive definition object*. Something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This topic has been extensively covered in these two blog posts by Tero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/ng2-no-controllers](http://bit.ly/ng2-no-controllers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://bit.ly/ng2-refactor-to-component](http://bit.ly/ng2-refactor-to-component)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are must-read posts with a wealth of information!
  prefs: []
  type: TYPE_NORMAL
- en: Building using the Angular 1.5+ component API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Angular 1.5+ has a **component API** that allows us to create directives that
    can be easily migrated to Angular 2\. The component API is preconfigured with
    sensible defaults, hence incorporating the best practices when it comes to building
    truly isolated + reusable directives.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the component API ([http://bit.ly/ng1-dev-guide-components](http://bit.ly/ng1-dev-guide-components))
    and this informative post by Tod Motto ([http://bit.ly/1MahwNs](http://bit.ly/1MahwNs))
    to learn about the component API.
  prefs: []
  type: TYPE_NORMAL
- en: To reiterate what has been emphasized earlier, these steps are not just targeted
    towards easy Angular 2 migration but also towards making Angular 1 code better.
    Component-based UI development is a better paradigm than what we are used to with
    Angular 1.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We highly recommend that you go through the Angular 1 style guide ([http://bit.ly/ng2-styleguide](http://bit.ly/ng2-styleguide)).
    This guide contains a wealth of tips/patterns that allow us to build better Angular
    1 apps, and is in sync with the guidelines provided previously for easy Angular
    2 migration.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you have decided to migrate, it's time to decide what to migrate.
  prefs: []
  type: TYPE_NORMAL
- en: What to migrate?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For an app in maintenance mode, where most of the development activity revolves
    around bug fixes and some enhancements, it would be prudent to stick to Angular
    1\. Remember the old saying "*If it ain't broke, don't fix it*."
  prefs: []
  type: TYPE_NORMAL
- en: If the app is being actively developed and has a clear long-term roadmap, migrating
    to Angular 2 is worth considering. As we dig deeper into the intricacies of migration,
    we will realize the time and effort involved in the process. While the Angular
    team has worked really hard to make this migration smooth, by no stretch of imagination
    is this a trivial job. It is going to take a good amount of time and effort to
    perform the actual migration.
  prefs: []
  type: TYPE_NORMAL
- en: The silver lining here is that we do not need to migrate everything at once.
    We can work slowly towards migrating parts of the Angular 1 code base to Angular
    2\. Both the frameworks can coexist, and can depend on each other too. This also
    allows us to develop new parts of applications in Angular 2\. How cool is that!
  prefs: []
  type: TYPE_NORMAL
- en: But again, this flexibility comes at a cost-the cost of bytes. As both frameworks
    are downloaded, the page bytes do increase, something that we should be aware
    of.
  prefs: []
  type: TYPE_NORMAL
- en: Also, while the coexistence of both the frameworks allows us to migrate without
    much disruption, we cannot make it a perpetual activity. Eventually, Angular 1
    has to go, and the sooner it does the better.
  prefs: []
  type: TYPE_NORMAL
- en: During migration, the best thing that can be done is to carve out new SPA's
    within the existing application. For example, we can build the Admin area of an
    app entirely using Angular 2, with a separate host page, but still share the common
    infrastructure of style sheets, images, and even Angular 1 services if we refactor
    the code a bit. As we will learn later, migrating services to Angular 2 is the
    easiest.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking an application into multiple smaller ones introduces full-page refreshes,
    but this is a cleaner approach when it comes to migration.
  prefs: []
  type: TYPE_NORMAL
- en: Taking all of this into consideration, if you have decided to migrate and identified
    areas of migration, you need to do the prep work for migration.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for Angular 2 migration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Welcome to the big brave world of Angular 2 migration! A successful migration
    strategy involves making sure that we do the groundwork beforehand, hence avoiding
    any late surprises.
  prefs: []
  type: TYPE_NORMAL
- en: As a prep work, the first step is to analyze the application from a third-party
    library dependency perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying third-party dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any third-party library that an Angular 1 app uses needs a migration strategy
    too. These could be either jQuery-based libraries or Angular 1 libraries.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery libraries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: jQuery libraries in Angular 1 were consumed by creating a directive wrapper
    over them. We will have to migrate such directives to Angular 2.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 1 libraries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Migrating Angular 1 libraries is bit of a tricky affair. Angular 1 has a massive
    ecosystem, whereas Angular 2 is a new kid on the block. It will take some time
    for the Angular 2 community offerings to be as rich as Angular 1\. Hence, for
    every Angular 1 library we use, we need to find a substitute in Angular 2 or create
    one, or get rid of the library altogether.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take for example the every-so-popular UI framework **ui-bootstrap** ([http://bit.ly/ng1-ui-bootstrap](http://bit.ly/ng1-ui-bootstrap)).
    There are multiple efforts going on to rewrite this library for Angular 2, but
    none are complete. If we have a dependency on *ui-bootstap*:'
  prefs: []
  type: TYPE_NORMAL
- en: We can either use the ports, assuming that the components we want to use have
    been migrated. The notable ports here are **ng-bootstrap** ([https://goo.gl/3dHkaU](https://goo.gl/3dHkaU))
    and **ng2-bootstrap** ([https://goo.gl/u4hOJn](https://goo.gl/u4hOJn)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or wait for the port to be complete.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or take a more radical approach of building our own bootstrap library in Angular
    2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these choices has trade-offs in terms of time and complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Another choice that needs to be made is the development language. Should we
    use TypeSript, ES2015, or plain old JavaScript (ES5)?
  prefs: []
  type: TYPE_NORMAL
- en: Choice of language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We would definitely recommend TypeScript. It's a super awesome language, and
    it integrates very well with Angular 2, vastly reducing the verbosity of Angular
    2 declarations. Also, given that it can coexist with JavaScript, it makes our
    life easier. Even without Angular 2, TypeScript is one language that we should
    embrace for the web platform.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming sections, we will migrate the Angular 1 **Personal Trainer** app
    to Angular 2\. The app is currently available on *GitHub* at [http://bit.ly/a1begit](http://bit.ly/a1begit).
    This app was part of the first version of this book, *AngularJS by Example*, and
    was built using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are again going to follow the checkpoint-based approach for this migration.
    The checkpoints that we highlight during the migration have been implemented as
    GitHub branches. Only this time, there is not companion code base to download.
  prefs: []
  type: TYPE_NORMAL
- en: Since we will be interacting with a *git* repository for v1 code and using N*ode.js*
    tools for the build, please set up *git* and *nodejs* on your dev box before proceeding
    further.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating Angular 1's Personal Trainer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we even begin the migration process we need to set up the v1 *Personal
    Trainer* locally.
  prefs: []
  type: TYPE_NORMAL
- en: The code for the migrated app can be downloaded from the GitHub site at [https://github.com/chandermani/angularjsbyexample](https://github.com/chandermani/angularjsbyexample).
    Since we migrate in chunks, we have created multiple checkpoints that map to **GitHub
    branches** dedicated to migration. Branches such as `ng2-checkpoint8.1`, `ng2-checkpoint8.2`,
    and so on highlight this progression. During the narration, we will highlight
    the branch for reference. These branches will contain the work done on the app
    up to that point in time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *7 Minute Workout* code is available inside the repository folder named
    `trainer`.
  prefs: []
  type: TYPE_NORMAL
- en: So let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Angular 1's Personal Trainer locally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps and you will be up and running in no time:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the command line, clone the v1 github repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to the new git repo and check out the `ng2-base` branch to get started:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Since the app loads its workout data from **MongoDB** hosted in **mLab **([https://mlab.com/](https://mlab.com/)),
    you need an mLab account to host workout-related data. Set up an mLab account
    by signing up with them. Once you have an mLab account, you need to retrieve your
    API key from mLab's management portal. Follow the instructions provided in the
    API documentation ([http://bit.ly/mlab-docs](http://bit.ly/mlab-docs)) to get
    your API key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have the API key, update this line in `app/js/config.js` with your
    API key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: And add some seed workout data into your mLab instance. The instructions to
    add the seed data into mLab are available in the source code file, `app/js/seed.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, install the necessary *npm packages* required for v1 *Personal Trainer*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Install **http-server**; it will act as a development server for our v1 app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the setup is complete by starting the `http-server` from the `app`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: And open the browser location `http://localhost:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: The v1 *Personal Trainer* start page should show up. Play around with the app
    to verify that the app is working fine. Now the migration can begin.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step before we begin migrating v1 *Personal Trainer* is to identify
    the external libraries that we are using in the Angular 1 version of Personal
    Trainer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The external libraries that we are using in v1 are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`angular-media-player`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`angular-local-storage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`angular-translate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`angular-ui-bootstrap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`owl. carousel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Libraries such as *angular-media-player* and *angular-local-storage* are easy
    to migrate/replace. We have already done this in the earlier chapters of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: '*angular-translate* can be replaced with *ng2-translate*, and as we will see
    in the coming sections, it is not a very challenging task.'
  prefs: []
  type: TYPE_NORMAL
- en: We use *angular-ui-bootstrap* for **modal dialogs** in *Personal Trainer*. *ng2-bootstrap*
    ([http://bit.ly/ng2-bootstrap](http://bit.ly/ng2-bootstrap)) is a worthy successor
    and plans to have a 1-1 parity with the older bootstrap version, but while writing
    this book, the modal dialog implementation was a work in progress; hence we had
    look for alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two other libraries available specifically targeting modal dialogs:
    **angular2-modal** ([http://bit.ly/ng2-modal](http://bit.ly/ng2-modal)) and **ng2-bs3-modal**
    ([http://bit.ly/ng2-bs3-modal](http://bit.ly/ng2-bs3-modal)). We can pick one
    of these and get rid of the *angular-ui-bootstrap* library.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Owl. Carousel* is a jQuery library, and we can write an Angular 2 component
    to wrap this plugin.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have sorted out the external dependencies, let's decide the language
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: While the existing code base is JavaScript, we love TypeScript. Its type safety,
    its terse syntax, and how well it plays with Angular 2 makes it our language of
    choice. Hence, it's going to be TypeScript all the way.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that tilts the decision in favor of TypeScript is that we do not
    need to migrate the existing code base to TypeScript. Anything we migrate/build
    new, we build it in TypeScript. Legacy code still remains in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start. As a first migration task, we need to set up a module loader for
    our v1 Personal Trainer.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the module loader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we are going to create a number of new Angular 2 components spread across
    numerous small files, adding direct script reference is going to be tedious and
    error-prone. We need a module loader. A module loader can help us with:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating isolated/reusable modules based on some common module formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the script loading order based on dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing bundling/packaging of a module and on-demand loading for dev/production
    deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the **SystemJS** module loader for this migration too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install SystemJS from the command line using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the commands need to be executed from the `trainer/app` folder.
  prefs: []
  type: TYPE_NORMAL
- en: We open `index.html` and remove all the script references of our app scripts.
    All script references with the source as `src='js/*.*'` should be removed, except
    `angular-media-player.js` and `angular-local-storage.js`, as they are external
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: We are not removing script references for third-party libraries but only
    app files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add SystemJS configurations after all third-party script references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the `ng-app` attribute on the body tag, keeping the `ng-controller`
    declaration intact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `ng-app` way of bootstrapping has to go as we switch to the `angular.bootstrap`
    function. Manual bootstrapping helps when we bring Angular 2 into the mix.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding `SystemJS.import` call loads the application by loading the first
    app module defined in `js/app.js`. We are going to define this module shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `app.module.js` in the same folder as `app.js` and
    copy the complete contents of `app.js` into `app.module.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to get rid of the `use strict` statement. The TypeScript compiler does
    not like it.
  prefs: []
  type: TYPE_NORMAL
- en: All the app module definitions are not in `app.module.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, clear `app.js` and add the following imports and bootstrap code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We have added *ES6 import statements* to `app.js`. These are the same scripts
    that were earlier referenced in `index.html`. SystemJS now loads these script
    files when loading `app.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Moving all of theAngular 1 module declaration into a new file `app.module.js`
    and importing it first in `app.js` makes sure that the Angular 1 modules are defined
    before any of the `import` statements are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not confuse between *ES6 modules* and *Angular 2 modules* defined/accessed
    using `angular.module('name')`. These two are altogether different concepts.
  prefs: []
  type: TYPE_NORMAL
- en: The last few lines bootstrap the Angular 1 application using the `angular.bootstrap`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Module loading is enabled now; let's enable TypeScript too.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling TypeScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable TypeScript, install the TypeScript compiler using *npm*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also install the TypeScript *type definition manager*, which allows
    us to use type definition for the libraries we use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Type definitions** or **typings** are files that define the public interface
    for a TypeScript/JavaScript library. These type definitions help IDEs provide
    intellisense around the library functions. Typings are available for most of the
    popular JavaScript libraries and for frameworks/libraries written in TypeScript.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open `package.json` and add these lines inside the script configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The two `scripts` properties that we just added are used to provide shortcuts
    for commonly executed scripts. See the following example, where we use the `typings`
    command to install `typings` (`npm run typings`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the *type definitions* for Angular 1 and jQuery. From the command line,
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are having trouble installing the *typings*, make sure that the installed
    `typings` package is the latest one, and then try again. We can check the latest
    version of the package using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Update `package.json` with the latest version and call `npm install` from the
    command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to set up some configurations for the TypeScript compiler. Create
    a file called `tsconfig.json` (in the `trainer/app` folder) and copy the configuration
    from the `ng2-checkpoint8.1` repo branch (also available remotely at [http://bit.ly/ng2be-8-1-tsconfig](http://bit.ly/ng2be-8-1-tsconfig)):
    Run the compiler using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This should start the TypeScript compiler and there should be no errors reported.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep this command running in a separate console window at all times during development.
    The compiler will continuously watch for changes to the TypeScript file and rebuild
    the code if changes are detected.
  prefs: []
  type: TYPE_NORMAL
- en: Change the extension for the `app.js` and `app.module.js` files to `app.ts`
    and `app.module.ts`. The TypeScript compiler detects these changes and compiles
    the TypeScript files. Post compilation, the compiler produces two files for each
    TypeScript file. One is the compiled JavaScript file (such as `app.js`) and the
    other is a map file (`app.js.map`) for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have not set up an elaborate build for this exercise as our primary focus
    is around migration.
  prefs: []
  type: TYPE_NORMAL
- en: For your own apps, the initial setup steps may vary depending upon how the build
    is already set up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we test our new changes, `config.js` needs to be fixed because we have
    enabled *strict DI check* in Angular 1 through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Replace the `config.js` content with updated content available in `ng2-checkpoint8.1`
    or at [http://bit.ly/ng2be-8-1-configjs](http://bit.ly/ng2be-8-1-configjs) (*and
    remember to set the API key again*). The update fixes the `config` function and
    makes it minification-friendly. Time to test the app!
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the TypeScript compiler is running in one console; run `http-server
    -c-1` on a new console window.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to `http://localhost:8080;` the app start page should load.
  prefs: []
  type: TYPE_NORMAL
- en: Commiting your local changes
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If things work fine, you can even commit your local changes to your git repo.
    This will help you track what has changed over the time as we migrate the app
    piece by piece.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation till this point is available in the `ng2-checkpoint8.1` GitHub
    branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are facing problems, compare the `ng2-base` and `ng2-checkpoint8.1`
    branches to understand the changes made. Since the code is hosted in GitHub, we
    can use the *GitHub compare* interface to compare commits in a single branch.
    See the documentation on how to do it here: [http://bit.ly/github-compare](http://bit.ly/github-compare).'
  prefs: []
  type: TYPE_NORMAL
- en: The [http://bit.ly/ng2be-compare-base-8-1](http://bit.ly/ng2be-compare-base-8-1) link shows
    a comparison between `ng2-base` and `ng2-checkpoint8.1`.
  prefs: []
  type: TYPE_NORMAL
- en: You can ignore the diff view for `app.js` and `app.module.js`, generated as
    part of the TypeScript compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Time to introduce Angular 2!
  prefs: []
  type: TYPE_NORMAL
- en: Adding Angular 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start by installing Angular 2 and dependent *npm modules* for our app. We
    will update the `package.json` file with the necessary packages first.
  prefs: []
  type: TYPE_NORMAL
- en: Copy all of the updated package file from [http://bit.ly/ng2be-8-2-package-json](http://bit.ly/ng2be-8-2-package-json)
    into your local installation.
  prefs: []
  type: TYPE_NORMAL
- en: '`package.json` now references some new packages related to Angular 2\. Install
    the referenced packages by calling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are having trouble with installing packages with `npm install`, delete
    the `node_modules` folder and run `npm install` again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then add a few library references that Angular 2 is dependent upon (and not
    loaded using SystemJS) in `index.html` before the `system.src.js` script reference
    (three in total):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: As it stands now, the SystemJS configuration is present in the `index.html`
    file itself. Since Angular 2 requires some decent amount of configuration, we
    are going to create a separate *SystemJS configuration file* instead, and reference
    that in `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this script reference after the `system.src.js` reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now clear the script section containing the call to the `System.config` function
    and replace it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Copy the `systemjs.config.js` from [http://bit.ly/ng2be-migrate-systemjs-config](http://bit.ly/ng2be-migrate-systemjs-config)
    and place it in the same folder as `package.json`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This configuration file derives from the *Quick Start Guide* for Angular available
    at [http://bit.ly/ng2-qsguide](http://bit.ly/ng2-qsguide). You can learn more
    about this configuration from the online guide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also update `tsconfig.json` and add a new property called `moduleResolution`
    to `compilerOptions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This instructs TypeScript to look for type definitions in the `node_modules`
    folder. Remember, Angular 2 typings are bundled as part of the Angular 2 library
    itself, and hence separate type definition import is not required.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the Angular 2-specific references have been added, we need to modify
    the existing bootstrap process to also load Angular 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular team has come up with an Angular 2 service, **UpdateAdapter**,
    that allows Angular 2 to bootstrap within an Angular 1 setup. The `UpgradeAdapter`
    service enables a number of common migration use cases. Using `UpgradeAdapter`,
    we can:'
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap an app with both the Angular 1 and Angular 2 frameworks loaded. This
    is the first thing we are going to do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporate an Angular 2 component in an Angular 1 view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporate an Angular 1 component in an Angular 2 view, albeit with some limitations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register an Angular 1 service with Angular 2 and vice versa.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sole purpose of the `UpgradeAdpater` service is to allow the gradual migration
    of artefacts from Angular 1 to Angular 2\. As we make progress with our migration
    efforts, the role of `UpgradeAdpater` becomes clear.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn how to bootstrap the hybrid Angular 1 and Angular 2 app using `UpgradeAdpater`.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the hybrid app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we are starting with Angular 2, we need to define a root app module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `app-ng1.module.js`, and copy the complete content of `app.module.ts`
    to the new file. Also remember to update the `import` statement in `app.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Let's now add the Angular 2 root module definition (`AppModule`) to `app.module.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the content of `app.module.ts` with the Angular 2 module definition.
    Copy the new definition from `ng2-checkpoint8.2` (GitHub location: [http://bit.ly/ng2be-8-2-app-module-ts](http://bit.ly/ng2be-8-2-app-module-ts)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a file called `upgrade-adapter.ts` in the same folder as `app.ts`
    and add a *global export* for the `UpdateAdapter` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This instance of `UpgradeAdpater` (named `upgradeAdapter`) is now available
    globally, and can be used to bootstrap the hybrid app.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Exporting an instance of `UpgradeAdapter` allows us to reuse the same instance
    across the app. This is a mandatory requirement for interoperability between the
    frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the file we just created into `app.ts`. Add this import statement after
    other imports in `app.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'And replace the bootstrap code with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Refresh your app and make sure it works as before. Do watch out for errors in
    TypeScript compiler console window.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! We now have a hybrid app up and running. Both frameworks are
    now working in tandem.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Look at the `ng2-checkpoint8.2` branch if you are facing issues upgrading to
    Angular 2. Again, you can also compare these git branches `ng2-checkpoint8.1`
    and `ng2- checkpoint8.2` to understand what has changed ([http://bit.ly/ng2be-compare-8-1-8-2](http://bit.ly/ng2be-compare-8-1-8-2)).
  prefs: []
  type: TYPE_NORMAL
- en: The migration process can start now. We can start by migrating a part of an
    Angular 1 view/directive to Angular 2.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting Angular 2 components into Angular 1 views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common migration pattern involves migrating lower-level Angular 1 directives/views
    to Angular 2 components. If we visualize the Angular 1 HTML view structure as
    a tree of directives, we start at the leaf. We migrate parts of a directive/view
    to an Angular 2 component and embed the component inside the Angular 1 view template.
    This Angular 2 component is injected into the Angular 1 view as an *element directive*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The closest thing to Angular 2 components that Angular 1 has is element directives.
    During migration, we are either migrating element directives or controller (`ng-controller`)-view
    pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a bottom-up approach to migrating view/directives to Angular 2 components.
    The following diagram highlights how the Angular 1 view hierarchy gradually transforms
    into an Angular 2 component tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Injecting Angular 2 components into Angular 1 views](../Images/image00416.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's migrate something small and get a feel of how things work. `ExerciseNavController`
    and its corresponding view fit the bill.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating our first view to Angular 2 component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ExerciseNavController` is part of *workout builder* and is located inside
    `trainer/app/js/WorkoutBuilder/exercise.js`. The corresponding view is served
    from `trainer/app/partials/workoutbuilder/left-nav-exercises.html`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary purpose of this this controller-view pair is to show the list of
    available exercises when building a workout (available user path `http://localhost:8080/#/builder/workouts/new`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Migrating our first view to Angular 2 component](../Images/image00417.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on any of these exercise names adds the exercise to the workout being
    constructed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with creating a component for the above view.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before starting on the new component, add a new workout builder module (`WorkoutBuilderModule`)
    to the application. Copy the module definition from `ng2-checkpoint8.3` in the
    `WorkoutBuilder` folder (GitHub location: [http://bit.ly/ng2be-8-3-workout-builder-module-ts](http://bit.ly/ng2be-8-3-workout-builder-module-ts)).
    Also import the newly created module in `app.module.ts`.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of inlining the complete code here, we suggest copying the `exercise-nav-component.ts`
    file from GitHub branch `ng2-checkpoint8.3` ([http://bit.ly/ng2be-8-3-exercisenavts](http://bit.ly/ng2be-8-3-exercisenavts))
    and adding it to the `WorkoutBuilder` folder locally. Since there is a decent
    amount of boilerplate, we will highlight only the relevant parts.
  prefs: []
  type: TYPE_NORMAL
- en: Contrasting template syntax
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Angular team has published an excellent reference ([http://bit.ly/ng2-a1-a2-quickref](http://bit.ly/ng2-a1-a2-quickref))
    that details the common view syntaxes in Angular 1 and their equivalents in Angular
    2\. Highly recommended when migrating an Angular 1 app!
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, if you look at the `exercise-nav-component.ts` file, the component
    template is similar to `left-nav-exercises.html` used in Angular 1, except there
    is no `ng-controller` and the template bindings are Angular 2-based:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If we focus on the component implementation (`ExercisesNavComponent`), the
    first striking thing is the component''s dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '`WorkoutService` and `WorkoutBuilderService` are Angular 1 services injected
    into Angular 2 components.'
  prefs: []
  type: TYPE_NORMAL
- en: Nice! If that is your initial reaction, we can't blame you. It is pretty cool!
    But the story is still incomplete. There is no magic happening here. Angular 2
    cannot access Angular 1 services unless it is told where to look. It's `UpgradeAdapter`
    that does most of the heavy lifting here.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting Angular 1 dependencies into Angular 2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`UpgradeAdapter` has an API method that allows us to register an *Angular 1
    service* with Angular 2\. Open `app.ts` and add these lines after the `upgrade-adapter`
    import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `updateNg1Provider,` as its name suggests, registers an Angular 1 dependency
    with the *Angular 2 root injector*. Once registered, the dependency is available
    throughout the Angular 2 application.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Sharing functionality with services**'
  prefs: []
  type: TYPE_NORMAL
- en: '`UpgradeAdapter` will also make sure that the same instance of the service
    is shared across the two frameworks. This makes services a prime candidate for
    sharing behavior across the frameworks. And, as we will see soon, it works the
    other way round too.'
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies at times have other dependencies, and hence it's better if we bring
    in all the service dependencies from Angular 1 at one go. Copy the list of Angular
    1 dependency registrations (done using `upgradeNg1Provider`) from [http://bit.ly/ng2be-8-3-appts](http://bit.ly/ng2be-8-3-appts)
    into your local `app.ts`. Remember to delete the two extraneous declarations that
    we have already imported above.
  prefs: []
  type: TYPE_NORMAL
- en: Back to component integration! As the `ExercisesNavComponent` is rendered inside
    an Angular 1 view, it needs to be registered as an *Angular 1 directive*.
  prefs: []
  type: TYPE_NORMAL
- en: Registering Angular 2 components as directives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ExercisesNavComponent` is an Angular 2 component, but it can be converted
    into an Angular 1 directive. Open `app.ts` and add the highlighted lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This time the `UpgradeAdapter` function used is `downgradeNg2Component`. This
    function returns a *factory function* containing the *directive definition object*.
    We register the component as an Angular 1 directive, `exerciseNav`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every Angular 2 component is registered as an *element directive* when used
    in Angular 1.
  prefs: []
  type: TYPE_NORMAL
- en: The component implementation is complete. We now need to clean up the old code
    and inject the new directive in the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `app.ts` and add the import statement to import the newly created component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the definition of `ExercisesNavController` from `exercise.js`, and replace
    the content of `left-nav-exercises.html` (located in the `partials` folder) with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: And we are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 1 still loads `left-nav-exercises.html` as part of the route transition,
    but the view inside is an Angular 2 component.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and try out the new implementation. Create a new workout and try to
    add exercises from the left nav. The functionality should work as before.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Look at `ng2-checkpoint8.3` in case you are facing issues upgrading to Angular
    2.
  prefs: []
  type: TYPE_NORMAL
- en: You can compare the git branches `ng2-checkpoint8.2` and `ng2-checkpoint8.3`
    to understand what has changed ([http://bit.ly/ng2be-compare-8-2-8-3](http://bit.ly/ng2be-compare-8-2-8-3)).
  prefs: []
  type: TYPE_NORMAL
- en: While we have only migrated a trivial component, this exercise highlights how
    easy it is to convert/downgrade an Angular 2 component to the Angular 1 directive
    and use it in Angular 1 view. The overall encapsulation of an Angular 2 component
    makes this chore easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'This downgraded component can even take an input from the parent scope using
    the all-so-familiar Angular 2 property binding syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Add to that, the event raised by the component can be subscribed by the Angular
    1 container scope too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We now have an Angular 2 component running inside Angular 1 using services initially
    designed for Angular 1\. A promising start to our migration journey!
  prefs: []
  type: TYPE_NORMAL
- en: Before we move any further, it's time to highlight how this collaboration works
    and the rules of engagement.
  prefs: []
  type: TYPE_NORMAL
- en: Rules of engagement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The migration story from Angular 1 to Angular 2 is only possible because these
    frameworks can coexist, and possibly share data. There are some touch points where
    the boundaries can be crossed. To have a better sense of how a hybrid application
    works and what is achievable in such a setup, we need to understand the areas
    of collaboration between the two frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three areas that need discussion:'
  prefs: []
  type: TYPE_NORMAL
- en: Template interleaving in DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since Angular 2 components and Angular 1 directives can coexist in a DOM, the
    question we need to answer is: Who owns what parts of the DOM?'
  prefs: []
  type: TYPE_NORMAL
- en: Angular 1 directives and Angular 2 components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When it comes to ownership of a DOM element, the golden rule is:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Every DOM element is owned/managed by exactly one of the Angular frameworks.*'
  prefs: []
  type: TYPE_NORMAL
- en: Take our previous migration example. The view that is part of `ExercisesNavComponent`
    is managed by Angular 2, whereas the container view (`left-nav-exercises.html`)
    is managed by Angular 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Things get a bit tricky at the boundaries of these directives and components.
    Consider the declaration inside `left-nav-exercises.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Who owns this? The short answer is Angular 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this is an Angular 2 component, the host element is owned by Angular
    1\. This means all Angular 1 template syntax works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'As these components and directives coexist in the same view, they often need
    to communicate. There are two ways to manage this communication:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using templating capabilities of Angular 1 and Angular 2:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Angular 2 component embedded inside an Angular 1 view can take inputs from
    the parent scope using event and property binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a similar fashion, if a directive is injected into an Angular 2 component
    view, it too can get inputs from the parent component and call the parent component
    function (through its isolated scope)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using shared services. We saw an example of this previously as we injected the
    `WorkoutService` and `WorkoutBuilderService` Angular 1 services into `ExercisesNavComponent`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Injecting Angular 1 directives into Angular 2 is a bit tricky. To be able to
    inject an Angular 1 directive into an Angular 2 template, the directive needs
    to abide by some rules. We will talk about these rules in the coming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing functionality using services is far more flexible compared to sharing
    through view templates. Injecting services across framework boundaries requires
    us to register the service across both frameworks and let Angular take care of
    the rest. Let's learn how dependency injection works across boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Resource sharing and dependency injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How dependencies are registered in a hybrid app is driven by how DI works in
    these two frameworks. For Angular 1, there is only one global injector, whereas
    Angular 2 has a concept of hierarchical injectors. In a hybrid environment, the
    least common denominator is the global injector that both the frameworks support.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing an Angular 1 service
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Dependencies defined in Angular 1 can be used in Angular 2 once they are registered
    with Angular 2''s *app injector* (root injector). The `UpgradeAdapter` function
    `upgradeNg1Provider` handles this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Since dependency injection in Angular 1 is *string-token-based*, the first parameter
    is the name of the service (the string token). The second parameter allows us
    to register a custom Angular 2 token for the v1 service.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what we did in the exercise `nav` component migrated earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'When it comes to injecting the dependency in Angular 2, we require the `Inject`
    decorator (*with string token*) for injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WorkoutService` is a generic provider registers with Angular 1\. Had this
    been a TypeScript class, the registration could have been done using an extra
    class token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'And injected using the all-so-familiar type injection with no decorators required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Sharing an Angular 2 service
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Services from Angular 2 too can be injected into Angular 1\. Since Angular
    1 only has a global injector, the dependency is registered at the global level.
    The `UpgradeAdapter` function that does this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The `downgradeNg2Provider` creates a factory function than can be consumed
    by the Angular 1 module''s `factory` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '`MyService` can now be injected across the Angular 1 app, like any other service.'
  prefs: []
  type: TYPE_NORMAL
- en: '`UpgradeAdapter` makes sure that only a single instance of the dependency is
    created and shared across the frameworks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following diagram; it summarizes what we have discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing an Angular 2 service](../Images/image00418.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: One last topic of this discussion is *change detection*.
  prefs: []
  type: TYPE_NORMAL
- en: Change detection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a hybrid application, change detection is managed by Angular 2\. If you are
    used to calling `$scope.$apply()` in your code, you don't need to in a hybrid
    application.
  prefs: []
  type: TYPE_NORMAL
- en: We have already discussed how Angular 2 change detection works. The Angular
    2 framework takes care of triggering Angular 1 change detection by internally
    calling `$scope.$apply()` on standard triggering points.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the rules of engagement, it is easier to comprehend how
    things work, what's feasible, and what's not.
  prefs: []
  type: TYPE_NORMAL
- en: Let's set some bigger/meatier targets and migrate the start and finish pages
    of the v1 app.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating the start and finish pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The finish page is easy to migrate, and I suggest you do it yourself. Create
    a folder called `finish` inside the `js` folder, and create three files, `finish-component.ts`,
    `finish-component.tpl.html`, and `finish.module.ts`, for the component's code
    and view template and the module definition. Implement the component.
  prefs: []
  type: TYPE_NORMAL
- en: Import the finish module into `AppModule` (`app.module.ts`). And then fix the
    route for finish to load the finish component.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, remember to delete the finish html template from the `partials/workout`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are stuck in migrating the finish page, compare the `ng2-checkpoint8.3`
    and `ng2-checkpoint8.4` git branches to understand what has changed in the `8.4`
    branch ([http://bit.ly/ng2be-compare-8-3-8-4](http://bit.ly/ng2be-compare-8-3-8-4)).
  prefs: []
  type: TYPE_NORMAL
- en: The finish page was easy, the start page is not! While the start page seems
    to be an easy target, there are some challenges that require some head-scratching.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest issue with the start page is that it uses a third-party library,
    *angular-translate*, to localize the content of the page. Since we are migrating
    the complete page/view to Angular 2, we need a mechanism to handle these Angular
    1 library dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '*angular-translate* comes with a *filter* (*pipe* in the Angular 2 world) and
    a directive, both named `translate`. Their job is to translate string tokens into
    localized string literals.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the *start* page becomes an Angular 2 component, we need to convert
    the filter into an Angular 2 pipe and, in some way, make the `translate` directive
    work in Angular 2\. The migration choices we have in this case are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new filter and upgrade the v1 `translate` directive using `UpgradeAdapter`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find a suitable replacement for angular-translate in Angular 2 world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the first choice seems to be the easiest, it has some serious limitations.
    Angular 2 `UpgradeApapter` comes with an `upgradeNg1Component` function, which
    can upgrade any Angular 1 directive. Not really! There are some stringent requirements
    around which a directive can be upgraded to Angular 2.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Upgrade of an Angular 1 component does not mean the component has been migrated.
    Angular 2 instead allows us to use an Angular 1 element directive as-is inside
    Angular 2 component views.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 1 directive upgrade
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At times, the parts of an application may be migrated in a top-down fashion;
    a higher order view is converted into a component. In such a case, instead of
    migrating all the custom directives that are part of the Angular 1 view, we just
    upgrade them to Angular 2 components using the `UpgradeAdpater` function `upgradeNg1Component`.
    The following diagram illustrates this migration path:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Angular 1 directive upgrade](../Images/image00419.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Angular 2 framework puts some restrictions around what can be upgraded to
    an Angular 2 component. Here is an excerpt from the Angular 2 migration guide.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be Angular 2 compatible, an Angular 1 component directive should configure
    these attributes: `restrict: ''E''`. Components are usually used as elements.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '`scope: {}` - an isolated scope. In Angular 2, components are always isolated
    from their surroundings, and we should do this in Angular 1 too.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '`bindToController: {}`. Component inputs and outputs should be bound to the
    controller instead of using the $scope.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '`controller` and `controllerAs`. Components have their own controllers. template
    or templateUrl. Components have their own templates.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Component directives may also use the following attributes:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '`transclude: true`, if the component needs to transclude content from elsewhere.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '`require`, if the component needs to communicate with some parent component''s
    controller.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Component directives **may not** use the following attributes:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '`compile`. This will not be supported in Angular 2.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '`replace`: true. Angular 2 never replaces a component element with the component
    template. This attribute is also deprecated in Angular 1.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '`priority` and `terminal`. While Angular 1 components may use these, they are
    not used in Angular 2 and it is better not to write code that relies on them.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The only Angular 1 directives that can be upgraded to Angular 2 are element
    directives, given that all other conditions are met.
  prefs: []
  type: TYPE_NORMAL
- en: With this sizeable laundry list, upgrading an Angular 1 directive to Angular
    2 is difficult, when compared to an Angular 2 component downgrade. More often
    than not, we have to do an actual code migration of an Angular 1 directive if
    the parent view has been migrated to Angular 2.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the *angular-translate* source code, we realize it uses the `$compile`
    service; therefore, the upgrade option is ruled out. We need to find an alternative
    library.
  prefs: []
  type: TYPE_NORMAL
- en: We do have an internationalization library for Angular 2, `ng2-translate` ([http://bit.ly/ng2-translate](http://bit.ly/ng2-translate)).
  prefs: []
  type: TYPE_NORMAL
- en: Replacing angular-translate with ng2-translate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*ng2-translate* is an internationalization library that targets Angular 2\.
    This library can replace v1 *angular-translate*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the npm package for `ng2-translate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Update `systemjs.config.js` to include the `ng2-translate` library. Add entries
    to the `map` and `packages` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '`ng2-translate` needs to be configured at the module level, so update `app.module.ts`
    with the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The preceding provider declaration sets up a loader that loads the translation
    files (`.json`) from the `i18n` folder. The `HttpModule` import is required for
    the translate library to load translations from server.
  prefs: []
  type: TYPE_NORMAL
- en: 'These statements require imports to keep the TypeScript compiler happy. Add
    these import statements to `app.module.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The `ng2-translate` library is now ready to be used.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that we are going to do is set the default translation language
    as soon as the application bootstraps.
  prefs: []
  type: TYPE_NORMAL
- en: Using a bootstrap-ready callback for initialization
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With Angular 2, luckily the bootstrap function on `UpdateAdapter` has a `ready`
    callback function just for this purpose. It is invoked after both the frameworks
    bootstrap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the bootstrap function in `app.ts` with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'And add an import for `TranslateService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The code tries to determine the current browser language and sets the current
    language for translations accordingly. Make note of how we get hold of `TranslateService`.
    The `UpgradeAdapterRef` object holds the reference to the Angular 2 *root injector*,
    which in turn loads `ng2-translate`'s `TranslateService`.
  prefs: []
  type: TYPE_NORMAL
- en: Next copy the three files related to start page implementation, from the `ng2-checkpoint8.4`
    branch ([http://bit.ly/ng2be-8-4-start](http://bit.ly/ng2be-8-4-start)) into a
    new folder `app/js/start`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The start component now needs to be registered as an Angular 1 directive before
    use. Add this statement to `app.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The start template file now uses the `translate` pipe (*the name of the pipe
    is the same as the Angular 1 filter * `translate`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The page also has some pipes, which are used to search and sort the workout
    list shown on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: We now need to add implementation for the pipes `orderBy` and `search`. Copy
    the complete code from `ng2-checkpoint8.4` ([http://bit.ly/ng2be-8-4-pipests](http://bit.ly/ng2be-8-4-pipests))
    and add it to a new file, `js/shared/pipes.ts` locally. We will not dwell into
    any of the pipe implementation here as we have done that already in earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Yet again we create a new Angular 2 module to share these pipes across the application.
    Copy the module definition from `ng2-checkpoint8.4` ([http://bit.ly/ng2be-shared-module-ts](http://bit.ly/ng2be-shared-module-ts))
    into the local `js/shared` folder, and import it into `app.module.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have previously migrated the `secondsToTime` (available in `js/7MinWorkout/filters.js`)
    filter to Angular 2, and the implementation is available in the `pipes.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: Start and finish component implementation is complete. Let's integrate them
    into the app.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the start and finish pages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Start/finish views are loaded as part of route change; hence we need to fix
    the route definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `app.ts` and add imports for start and finish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The route definitions are in `config.js`. Update the start and finish route
    definitions to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The route template html is a part of the Angular 1 view. Since we have registered
    both `StartComponent` and `FinishComponent` as Angular 1 directives, the route
    loads the correct components.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have already migrated the finish page, you do not need to redo the import
    and route setup for finish as described.
  prefs: []
  type: TYPE_NORMAL
- en: A few more fixes are pending before we can test the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `app-ng1.module.ts` with modules for `start` and `finish`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Finally copy the translation files `de.json` and `en.json` from the `ng2-checkpoint8.4`
    folder `i18n` ([http://bit.ly/ng2-8-4-i18n](http://bit.ly/ng2-8-4-i18n)). Now
    we are ready to be test what we have developed.
  prefs: []
  type: TYPE_NORMAL
- en: If not started, start the TypeScript compiler and *HTTP-server*, and then launch
    the browser. The start and finish pages should load just fine. But the translations
    do not work! Clicking on the language translation links on the top nav has no
    affect. Content always renders in English.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are stuck, compare the git branches `ng2-checkpoint8.3` and `ng2-checkpoint8.4`
    to understand what changed ([http://bit.ly/ng2be-compare-8-3-8-4](http://bit.ly/ng2be-compare-8-3-8-4)).
  prefs: []
  type: TYPE_NORMAL
- en: Translations still do not work because the top nav code (`root.js`) that enables
    translation is still using the older library. We need to get rid of angular-translate
    (the v1 library) altogether. Having two libraries doing the same work is not something
    we want, but removing it is also not that simple.
  prefs: []
  type: TYPE_NORMAL
- en: Getting rid of angular-translate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get rid of angular-translate (v1) library we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the angular-translate's directive/filter references from all Angular
    1 views.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get rid of any code that uses this library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting rid of the v1 directive/filter altogether is a difficult task. We can
    neither add the v2 ng2-translate pipe in the Angular 1 view nor can we migrate
    every view using the v1 directive/filter to Angular 2 at one shot.
  prefs: []
  type: TYPE_NORMAL
- en: Why not write a new Angular 1 filter that uses the ng2-translate's translation
    service (`TranslateService`) for translations and then use the new filter everywhere?
    Problems solved!
  prefs: []
  type: TYPE_NORMAL
- en: Let's call this filter `ng2Translate`. We replace all references to the `translate`
    filter in v1 view with `ng2Translate`. All v1 `translate` directive references
    should also be replaced with `ng2Translate` filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the filter implementation looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `filters.ts` in the `shared` folder and add the preceding
    implementation. The filter uses `TranslateService` (registered in Angular 1 as
    `ng2TranslateService`) to map string tokens to localized content. To test this
    implementation, there are a few more steps needed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace all references to `translate` (directive and filter) across the Angular
    1 view with `ng2Translate`. There are references in these files: `description-panel.html`,
    `video-panel.html`, `workout.html` (in the folder `partials/workout`), and `index.html`.
    Replacing the filter in the interpolation is a simple exercise, and for the `translate`
    directive, replace it with interpolation. For example in `partials/workout/description-panel.html`,
    the line of code is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'It then becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Remember to quote the string token (`'RUNNER.STEPS'`) inside the interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the filter into `app.ts`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ng2Translate` filter depends upon the `TranslateService`; hence needs
    to be registered with the Angular 1 injector using (in `app.ts` again):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Angular 2's `TranslateService` is registered as `ng2TranslateService` in Angular
    1.
  prefs: []
  type: TYPE_NORMAL
- en: Finally copy the updated `root.js` from [http://bit.ly/ng2-migrate-root-no-trasnlate](http://bit.ly/ng2-migrate-root-no-trasnlate).
    We have replace all references to `$translate` service with `ng2TranslateService`,
    and refactored the code to use the new service. `root.js` contains the implementation
    for v1 `RootController`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are good to go now. Try out the new implementation, the app should load translation
    with using ng2-translate library.
  prefs: []
  type: TYPE_NORMAL
- en: We can now delete all references to angular-translate. There are references
    in `index.html`, `app.module.ts` and `config.js`.
  prefs: []
  type: TYPE_NORMAL
- en: The migration of the start and finish pages is complete and it's time to look
    at some other targets.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Compare the branches `ng2-checkpoint8.4` and `ng2-checkpoint8.5` to understand
    the new changes in `ng2-checkpoint8.5` ([http://bit.ly/ng2be-compare-8-4-8-5](http://bit.ly/ng2be-compare-8-4-8-5)).
  prefs: []
  type: TYPE_NORMAL
- en: The next few migrations that we detail in the coming sections will not be as
    descriptive as earlier migrations. We strongly recommend you look at the relevant
    commits on the `angular2-migrate-ts` branch to understand how things move forward.
    We will only highlight relevant details for the coming migrations.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing the ui-bootstrap library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One thing that we have learned while migrating the start and finish pages to
    Angular 2 is how cumbersome it is to migrate third-party dependencies. Migrating
    an Angular 1 view that uses external libraries without migrating those libraries
    themselves is a challenge. We have also learned that it is much easier to embed
    an Angular 2 component inside an Angular 1 view than the other way round.
  prefs: []
  type: TYPE_NORMAL
- en: Given these observations, it becomes imperative that we migrate/replace third-party
    libraries first while migrating to Angular 2.
  prefs: []
  type: TYPE_NORMAL
- en: One such library that we want to get rid of is the **ui-bootstrap** ([http://bit.ly/ng1-ui-bootstrap](http://bit.ly/ng1-ui-bootstrap))
    library. While we only use the modal dialog service from ui-bootstrap, moving
    away from it is going to be a challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Calling this modal dialog a service `($uibModal`) would be a misnomer. While
    it is injected like a service in Angular 1, it actually manipulates the DOM and
    therefore cannot be upgraded using the `upgradeNg1Provider` function.
  prefs: []
  type: TYPE_NORMAL
- en: We again need an alternate implementation for modal dialogs in Angular 2\. The
    library we choose for this exercise is angular2-modal ([http://bit.ly/ng2-modal](http://bit.ly/ng2-modal)).
  prefs: []
  type: TYPE_NORMAL
- en: Personal Trainer uses angular2-modal in two places, in the top nav to show the
    workout history and during workout execution to show the exercise-related video.
  prefs: []
  type: TYPE_NORMAL
- en: As part of migrating to angular2-modal, we also migrate **top nav** (declared
    inside `index.html`) and the **video panel** (`partials/workout/video-panel.html`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Look at the `ng2-checkpoint8.6` GitHub branch to understand what artefacts were
    changed during this migration. We will only *highlight* things that made the migration
    challenging.
  prefs: []
  type: TYPE_NORMAL
- en: You can also compare this branch with the previous one (`ng2-checkpoint8.5`)
    on GitHub, at [http://bit.ly/ng2be-compare-8-5-8-6](http://bit.ly/ng2be-compare-8-5-8-6),
    to know what the changes are.
  prefs: []
  type: TYPE_NORMAL
- en: '*This section will detail the code in the context of the* `ng2-checkpoint8.6` *GitHub
    branch.*'
  prefs: []
  type: TYPE_NORMAL
- en: The biggest challenge with migrating to our new modal dialog library, *angular2-modal*,
    was that it required access to the root component to properly render the dialog
    in the middle of the screen. While this is not a problem in a standard Angular
    2 app, for a hybrid app, the library failed to locate the root component as there
    was none.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Look at the *Using angular2-modal dialog library* section in [Chapter 3](part0039.xhtml#1565U2-edca168d36254bda8a21f611a95615c3
    "Chapter 3.  More Angular 2 – SPA, Routing, and Data Flows in Depth"), *More Angular
    2 –€“ SPA, Routing, and Data Flows in Depth*, to understand how to install and
    configure the library. You can also compare the branches `ng2-checkpoint8.5` and
    `ng2-checkpoint8.6` to determine changes specific to angular2-modal.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get around these limitations, we first had to restructure the Angular 1
    app, such that we have an Angular 2 root component. Such a component then encompasses
    the complete Angular 1 view. The new rendered html structure now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Replacing the ui-bootstrap library](../Images/image00420.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Open `index.html`, the `ng2-root` (`Ng2RootComponent`) tag is an Angular 2 component
    that wraps the complete Angular 1 view. The existing Angular 1 view html itself
    is now wrapped inside a directive (`ng1Root`) using the `component` API. Look
    at files `ng1-root-component.ts`, `ng1-root-component.tpl.html` and `ng2-root-component.ts`
    to understand how these components are structured now and to provide angular2-modal
    `ng2-root` container reference in the `Ng2RootComponent` 's constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The restructuring of root elements also employs another migration pattern.
    The Angular 2 component (`Ng2RootComponent`) transcludes the Angular 1 element
    directive (`ng1Root`). Check the view template of `Ng2RootComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'And it''s use in `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: In such a setup, while the `ng1RootComponent` is embedded inside the Angular
    2 `Ng2RootComponent`, it derives its context from the parent Angular 1 view and
    hence can access the parent scope.
  prefs: []
  type: TYPE_NORMAL
- en: There were numerous other small changes made to the app as part of this migration,
    and comparing this branch against `ng2-checkpoint8.5` with help you understand
    what has changed.
  prefs: []
  type: TYPE_NORMAL
- en: We will stop here and direct you to the other GitHub branches pertaining to
    migration. All branches starting with `ng2-checkpoint*` are the migration branches.
    Try to migrate the pending views and compare them with the GitHub branch changes.
    Remember, a working version of the app has already been developed in Angular 2,
    and hence there is a good reference point. Look at the `README.md` file for each
    branch to know what part of the application was migrated to Angular 2.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, let's summarize our learnings from the migration that we did.
  prefs: []
  type: TYPE_NORMAL
- en: Learnings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We hope this migration exercise has provided enough insight into the process.
    You can now gauge the complexity, the time, and the effort required to migrate
    elements from Angular 1 to Angular 2\. Let''s highlight our learning as part of
    this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Migration is time-consuming**: Migration by no stretch of imagination is
    a trivial exercise. Each page/view presents its own challenges that we need to
    overcome. Some elements are easy to migrate and some are not. The best thing you
    can do today if you are developing in Angular 1 would be to follow the advices
    from the *Developing Angular 1 apps today for easy migration* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Migrate third-party libraries first**: Migrating third-party libraries can
    be quite challenging. The reasons are manifold:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such libraries are used across pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They may not be upgradable to Angular 2 (using `UpgradeAdapter`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrating each view that uses such a library may not be feasible when the library
    is extensively used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's better to identify all third-party dependencies in your app and find a
    suitable alternative for them in the Angular 2 world. If possible, develop some
    proof of concept (POC) with the new library to understand how different the new
    library is from the existing implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Libraries with overlap may exist**: While migrating, there could be scenarios
    where both Angular 1 and Angular 2 versions of a library coexist. Minimize this
    time period and migrate to the newer version as soon as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It is easier to integrate Angular 2 components into Angular 1 than the other
    way round**: While migrating, migrate the complete view to Angular 2\. Due to
    the restriction imposed by Angular 2, it becomes very difficult to have a parent
    Angular 2 component with embedded Angular 1 element directives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With such limitations, a bottom-up approach to migrating works better than a
    top-down approach.
  prefs: []
  type: TYPE_NORMAL
- en: '**Anything non-UI-related is easy to migrate**: For *Personal Trainer*, we
    migrate the services last as they can be easily migrated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feature parity better Angular 1 and Angular 2**: Angular 2 may not have every
    feature that Angular 1 supports. In such a case, we need workarounds to achieve
    the desired behaviour.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That completes our migration story. With this, it's time to conclude the chapter
    and summarize our learnings from it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we gained some useful insight into a number of practical issues
    surrounding Angular development. These tips/guidelines can be extremely handy
    when building real-life applications using the framework.
  prefs: []
  type: TYPE_NORMAL
- en: We started the chapter by exploring the concept of *seed projects* and how these
    projects can get us up and running in no time. We looked at some popular seed
    projects that can serve as a base for any new Angular app development. We also
    touched upon *Yeoman* and *angular-cli*, a suite of tools that helps us kick-start
    new projects.
  prefs: []
  type: TYPE_NORMAL
- en: In spite of being a server-side concern, authentication and authorization do
    affect the client implementation. The section on authentication/authorization
    covered how to handle authentication in a cookie and token-based setup.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the ever-so-important topic of performance, where you learned ways
    to optimize an Angular app's performance.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we migrated the v1 *Personal Trainer* to Angular 2\. The gradual migration
    process taught us the intricacies of migration, the challenges faced, and the
    workaround done.
  prefs: []
  type: TYPE_NORMAL
- en: The book is coming to a close, but for everyone reading it, the journey has
    just begun. It's time to put theories into practice, hone our newly acquired skills,
    build something useful with Angular, and share it with the world. The more you
    invest in Angular, the more rewarding the framework is. Let's get started!
  prefs: []
  type: TYPE_NORMAL
