- en: Smart Agriculture and Voice AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](part0083.html#2F4UM0-ce91715363d04669bca1c1545beb57ee), *Smart
    Agriculture*, we have seen one of the mainstream areas in which IoT can create
    an impact; the agriculture sector. In this chapter, we are going to take that
    to a new level. Using a voice AI engine such as Amazon Alexa, we are going to
    talk to the smart weather station that we have built.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a farmer can ask Alexa *`Alexa, ask smarty app the moisture level
    in my farm*, and Alexa would go *the moisture level in your farm is 20%. Consider
    watering now*. Then, the farmer would go, *Alexa, ask smarty app to turn on my
    motor* and Alexa would turn it on. Fascinating, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Generally, voice AI based IoT is more common in the concepts of smart home and
    smart office. I wanted to implement it with smart agriculture.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to work on the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand Amazon Alexa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build an IoT.js controlled water motor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand AWS lambda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop a skillset for Amazon Alexa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the weather station as well as the water motor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Voice AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There was a time when turning something on/off using a smart phone was exciting.
    Times have changed and things have evolved quite a bit since in the space of voice
    AI. A lot of people use their voice to do a lot of things, right from making notes,
    building their grocery lists, to searching the internet. We no longer use hands
    for mundane activities.
  prefs: []
  type: TYPE_NORMAL
- en: '"Look Ma, No hands!"'
  prefs: []
  type: TYPE_NORMAL
- en: What's next? Think of it and it happens? I would love to be alive to see that,
    as I could do things at the speed of thought.
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to the world of Voice AI, you can start looking up Amazon Alexa,
    Google Now/Google Assistant, Apple Siri, or Windows Cortana to see what I am talking
    about. Since we are going to work with Amazon Alexa in this chapter, we will explore
    only that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Amazon recently launched a couple of devices named Amazon Echo and Amazon Echo
    Dot (recently made available in India too), which are smart speakers, enabled
    by Alexa, Amazon''s voice AI software. If you want to experience Alexa for yourself,
    without buying buying echo products, download the reverb app for Android: [https://play.google.com/store/apps/details?id=agency.rain.android.alexa&hl=en](https://play.google.com/store/apps/details?id=agency.rain.android.alexa&hl=en)
    or iOS: [https://itunes.apple.com/us/app/reverb-for-amazon-alexa/id1144695621?mt=8](https://itunes.apple.com/us/app/reverb-for-amazon-alexa/id1144695621?mt=8)
    and launch the app.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see an interface with a microphone icon. Press and hold the microphone
    and you should see the text Listening... on the top, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now say, *Alexa, tell me a joke* and get entertained by Alexa!
  prefs: []
  type: TYPE_NORMAL
- en: Test drive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test what we are going to build, press the microphone icon in the reverb
    app and say, *Alexa, ask smarty app for the weather report* and you should hear
    the latest data that is persisted in the database for the smart weather station.
    And then you can say, *Alexa, ask smarty app to turn on the motor,* or *Alexa,
    ask smarty app to turn off the motor;* if my device is online, it will turn it
    off.
  prefs: []
  type: TYPE_NORMAL
- en: Along with smart weather station, we are going to build a smart socket, which
    can be connected to a motor in a farm. And using Alexa, we are going to turn on/off
    the motor.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you have an Amazon echo or echo dot, you can test the skill we are going
    to build. Or, you can do the same using the reverb app. You can also use [https://reverb.ai/](https://reverb.ai/)
    or [https://echosim.io/](https://echosim.io/) for the same.
  prefs: []
  type: TYPE_NORMAL
- en: Till your Alexa skill is published, it will be only accessible on devices that
    are linked with your Amazon account only. If you have enabled beta testing, then
    you can allow multiple people to access this skill on their Amazon account linked
    Alexa powered devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are facing issues to explore the demo, check out this video recording:
    `/videos/chapter5/alexa_smarty_app_demo.mov`'
  prefs: []
  type: TYPE_NORMAL
- en: So, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Building a smart socket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to build a smart socket. The setup is going to
    be quite similar to what we had in [Chapter 4](part0083.html#2F4UM0-ce91715363d04669bca1c1545beb57ee),
    *Smart Agriculture*. Create a new folder named `chapter5` and copy the contents
    of the `chapter4` folder into it. The `chapter4` folder has the code for the smart
    weather station, and now, we are going to add the required code for smart socket.
  prefs: []
  type: TYPE_NORMAL
- en: The smart socket is a simple electrical socket that can be controlled over the
    internet. That is, turn on the socket and turn off the socket. We are going to
    use a **mechanical relay** to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to start off by setting up the relay with the other sensors on
    the Raspberry Pi. I am going to use one Raspberry Pi to demonstrate the smart
    weather station as well as the smart socket. You can use two Raspberry Pis as
    well for this.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to add the appropriate MQTT client code to the API engine; next,
    update the web, desktop, and mobile app to have a toggle switch to turn on/off
    the relay.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create a new topic named `socket` on, which we would send either
    `1` or `0` to turn on/off the relay, thus turning the load on the other end of
    the relay on/off.
  prefs: []
  type: TYPE_NORMAL
- en: Do remember that we are exploring the various solutions that can be built with
    IoT and we are not building the final product itself.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up relay with Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of now, Raspberry Pi has the smart weather station sensors attached to it.
    Now, we are going to add a relay to the setup.
  prefs: []
  type: TYPE_NORMAL
- en: A relay is an electrical switch that is driven by an electronic signal. That
    is, triggering the relay with logic high `1` will turn on the relay and logic
    low `0` will turn off the relay.
  prefs: []
  type: TYPE_NORMAL
- en: Some relays work the other way around, depending on the component. To know more
    about types of relay and how they work, refer to, [https://www.phidgets.com/docs/Mechanical_Relay_Primer](https://www.phidgets.com/docs/Mechanical_Relay_Primer).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can purchase a simple 5V driven relay from Amazon: ([https://www.amazon.com/DAOKI%C2%AE-Arduino-Indicator-Channel-Official/dp/B00XT0OSUQ/ref=sr_1_3](https://www.amazon.com/DAOKI%C2%AE-Arduino-Indicator-Channel-Official/dp/B00XT0OSUQ/ref=sr_1_3)).'
  prefs: []
  type: TYPE_NORMAL
- en: Relays deal with AC current, and in our examples, we are not going to connect
    any AC power supply to the relay. We are going to power it using a 5V DC supply
    from Raspberry Pi and using the LED indicator on the relay identify if the relay
    has been turned on or off. In case you want to connect it to an actual power supply,
    please take adequate precaution before doing so. The results might be shocking
    if proper care is not taken.
  prefs: []
  type: TYPE_NORMAL
- en: Along with the weather station, we are going to connect the relay as well to
    the Raspberry Pi 3\. Connect the relay, as shown in the following figure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connection of Raspberry Pi with the smart weather station:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Connection of Raspberry Pi with a `relay` (module):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00067.jpeg)If you purchased a standalone relay, you need to set
    up the circuit, as shown previously. And, if you have purchased the relay module,
    you need to connect pin 18/GPIO24 to the trigger pin, after powering the relay.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To reiterate the previous connection, please see the tables shown, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Raspberry Pi and MCP3208:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Raspberry Pi number - Pin name** | **MCP 3208 pin number - Pin name** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 - 3.3V | 16 - VDD |'
  prefs: []
  type: TYPE_TB
- en: '| 1 - 3.3V | 15 - AREF |'
  prefs: []
  type: TYPE_TB
- en: '| 6 - GND | 14 - AGND |'
  prefs: []
  type: TYPE_TB
- en: '| 23 - GPIO11, SPI0_SCLK | 13 - CLK |'
  prefs: []
  type: TYPE_TB
- en: '| 21 - GPIO09, SPI0_MISO | 12 - DOUT |'
  prefs: []
  type: TYPE_TB
- en: '| 19 - GPIO10, SPI0_MOSI | 11 - DIN |'
  prefs: []
  type: TYPE_TB
- en: '| 24 - GPIO08, CEO | 10 - CS |'
  prefs: []
  type: TYPE_TB
- en: '| 6 - GND | 9 - DGND |'
  prefs: []
  type: TYPE_TB
- en: 'Moisture sensor and MCP3208:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **MCP 3208 pin number - Pin name** | **Sensor pin** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 - A0 | Rain sensor - A0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 - A1 | Moisture sensor - A0 |'
  prefs: []
  type: TYPE_TB
- en: 'Raspberry Pi and DHT11:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Raspberry Pi number - Pin name** | **Sensor pin** |'
  prefs: []
  type: TYPE_TB
- en: '| 3 - GPIO2 | DHT11 - data |'
  prefs: []
  type: TYPE_TB
- en: 'Raspberry Pi and relay:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Raspberry Pi number - Pin name** | **Sensor pin** |'
  prefs: []
  type: TYPE_TB
- en: '| 12 - GPIO18 | Relay - trigger pin |'
  prefs: []
  type: TYPE_TB
- en: All grounds and all 3.3V pins are connected to a common point. All the relay
    needs is a 5V power supply from the Raspberry Pi, which is pin 2.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have connected the sensors as shown previously, we will write the required
    code needed to interface with the sensors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Head towards the `pi-client` folder inside `Raspberry Pi 3`, open `pi-client/index.js`,
    and update it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To the `Weather Station` code, we have added the `rpio` module and using the
    `rpio.open()`, we have made pin 12 as an output pin. We are also listening to
    the topic named socket. And, when we get a response from the broker on this topic,
    we set pin 12 to high or low based on the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will install the `rpio` module inside the Raspberry Pi `pi-client`
    folder, and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Save all, the files. Now, we will start the Mosca broker from our desktop/machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once you have started Mosca server, do check the IP address of the server on
    which Mosca is running. Update the same IP in your Raspberry Pi `config.js` file
    or else Raspberry Pi cannot post data to the broker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Mosca has started successfully and we have validated the IP on the Raspberry
    Pi, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will start the server and keep sending the weather information to the broker.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to write the required logic needed for the
    API engine to process the relay.
  prefs: []
  type: TYPE_NORMAL
- en: Managing relay in an API engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the relay is connected to the Raspberry Pi, we will write the logic
    that will send the on/off command to the socket topic. Open `api-engine/server/mqtt/index.js`
    and update it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added a method named `sendSocketData` and exported it. We are going
    to call this method in the `api-engine/server/api/data/data.controller.jscreate`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Save all, the files and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following on your screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Do note, the last value in the data string printed in the console; `s`, we are
    sending the status of the relay as well to display in the UI, if the relay is
    on/off.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we are done with the code needed to develop the API engine. In the
    next section, we are going to work on the web app.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the web app template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to update the web app template to have a toggle
    button, quite similar to what we had in [Chapter 2](part0032.html#UGI00-ce91715363d04669bca1c1545beb57ee),
    *IoTFW.js - I*, and [Chapter 3](part0072.html#24L8G0-ce91715363d04669bca1c1545beb57ee),
    *IoTFW.js - II*. Using the toggle button, we are going to turn on/off the relay
    manually. In the later sections, we are going to automate them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open, `web-app/src/app/device/device.component.html` and update it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'All we have done is added a new row that shows a toggle button, and using this,
    we turn on/off the socket. Next, the required logic to manage the toggle button,
    open `web-app/src/app/device/device.component.ts` and update it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'All we have done here is manage the toggle button state. Save all the files
    and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to `http://localhost:4200` and then navigate to the device page. Now,
    using the toggle button on the page, we can turn the relay on/off, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If everything is set up correctly, you should see the relay LED turn on/off
    on the relay, as shown in the following photograph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Wires! Duh!
  prefs: []
  type: TYPE_NORMAL
- en: With this, we are done with the web app. In the next section, we are going to
    build the same web app and deploy it inside our desktop app.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the desktop app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the web app is done, we are going to build the same and deploy it inside
    our desktop app.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, head back to the terminal/prompt of the `web-app` folder and
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a new folder inside the `web-app` folder named `dist`. The
    contents of the `dist` folder should be on the lines of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'All, the code we have written is finally bundled into the preceding files.
    We will grab all of the files (not the `dist` folder) present inside the `dist`
    folder and then paste it inside the `desktop-app/app` folder. The final structure
    of the `desktop-app` after the previous changes will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To test drive, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, when we navigate to the VIEW DEVICE page, we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using the toggle button, we should be able to turn the relay on/off.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we are done with the development of the desktop app. In the next
    section, we will update the mobile app.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the mobile app template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section, we have updated the desktop app. In this section, we are
    going to update the mobile app template with the toggle switch component. So,
    using this toggle switch, we can turn the smart socket on/off.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to update the view-device template. Update `mobile-app/src/pages/view-device/view-device.html`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to add the required logic to manage the toggle button. Update
    `mobile-app/src/pages/view-device/view-device.ts`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have added the required logic to manage the toggle button. Save all,
    the files and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can deploy the same to your device as well, by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the app is launched, and when we navigate to VIEW DEVICE page, we should
    see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We should be able to control the socket using the toggle button on the mobile
    app.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we are done with the set up of smart motor.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to build a new skill for Amazon Alexa.
  prefs: []
  type: TYPE_NORMAL
- en: Developing Alexa skill
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section, we have seen how to build a smart socket and integrate
    it with our existing smart weather station. In this section, we are going to build
    a new skill for interfacing our smart devices with Amazon Alexa.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create a new skill named smarty app and then add two voice
    models to it:'
  prefs: []
  type: TYPE_NORMAL
- en: To get the latest weather status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To turn on/off the socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are new to Alexa and its skill development, I would recommend watching
    the following series before you continue: Developing Alexa skills: [https://www.youtube.com/playlist?list=PL2KJmkHeYQTO6ci5KF08mvHYdAZu2jgkJ](https://www.youtube.com/playlist?list=PL2KJmkHeYQTO6ci5KF08mvHYdAZu2jgkJ)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To give a quick overview of our skill creation, we are going to follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the Amazon developer portal and create and set up a new skill
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Train the voice model
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the required business logic in AWS lambda service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy and test the setup
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Creating skill
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we are going to do is log in to [https://developer.amazon.com](https://developer.amazon.com).
    Once we are logged in, click on Alexa on the top section of the page. You should
    land on a page that should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on Get Started > below Alexa Skills Kit and you should be redirected to
    a page where you can view your existing skill sets or create a new one. Click
    on the golden button on the top right-hand corner named Add a new skill.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should be redirected to a page, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'I have given the preceding information. You can configure it as you please.
    Click Save and then click on Interaction Model on the left menu, and you should
    be redirected to the Interactive Model settings, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We are going to use the skill builder, which is still in beta at the time of
    writing. Skill builder is an easy interface to train our voice model.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Launch Skill Builder button.
  prefs: []
  type: TYPE_NORMAL
- en: Training the voice model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we are inside the skill builder, we are going to start training the models.
    In our application, we are going to have two intents:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WeatherStatusIntent`: To get the values of all four sensors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ControlMotorIntent`: To turn the motor on/off'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from this, you can also add other intents based on your requirements.
    You can add a moisture sensor only intent to get the values of moisture sensor
    only or rain sensor intent for only rain sensor values.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will go ahead and set up these intents and create slots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are inside the skill builder, you should see something similar to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, using Add + next to the intents on the left-hand side, create a new custom
    intent and name it `WeatherStatusIntent`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we are going to train the voice model. Once the intent has been created,
    click on the intent name on the left menu. Now, we should see a section named
    Sample Utterances. We are going to feed the sample utterances of how the user
    is going to invoke our service.
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep things simple, I have added only three samples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alexa, ask smarty app:'
  prefs: []
  type: TYPE_NORMAL
- en: The weather report
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The weather status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The field conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see this in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we are going to create another intent named `ControlMotorIntent` using
    the same process. Click on ControlMotorIntent on the left-hand side menu and we
    should see the sample utterances section.
  prefs: []
  type: TYPE_NORMAL
- en: For this intent, we are going to do something different; we are going to create
    something called **slots**. We are going to take the sample utterance that the
    user would utter and extract a piece of it as a variable.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the user says, *Alexa, ask smarty app to turn on the motor,*
    or *Alexa, ask smarty app to turn off the motor*, everything is the same except
    for turn on or turn off, so we want to convert these to variables and handle each
    instruction differently.
  prefs: []
  type: TYPE_NORMAL
- en: If the slot is turned on, we turn on the motor and if the slot is turned off,
    we are going to turn off the motor.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, once you have entered the sample utterance such as to turn on the motor,
    select the text `turn on`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once you have selected the text, enter a custom intent slot name motorAction
    and click on the *plus* icon.
  prefs: []
  type: TYPE_NORMAL
- en: We will have only one utterance for this intent. Next, we need to configure
    the motorAction intent slot.
  prefs: []
  type: TYPE_NORMAL
- en: On the right-hand side of the page, you should see the newly created intent
    slot. Check the checkbox under the REQ column. This means that this value is required
    for the intent to be called. Next, click on Choose a slot type below the slot
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have to define a custom intent slot type. Add `motorActionIntentSlot`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we have to set up the values. Click on `motorActionIntentSlot` from the
    left-hand side menu and add two values; turn on and turn off, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once this is done, we need to set up the prompt that will be spoken when the
    user doesn''t utter the two slot values we have defined. Click on {motorAction}
    under ControlMotorIntent and below Dialog Model, and enter a prompt such as `Do
    you want me to turn on or turn off the motor?`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With this, we are done with defining our voice model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to ask the Alexa skill engine to build our voice model and add
    it to its skill engine. Using the Save Model button at the top of the page, save
    the model and then Build Model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00083.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The build generally takes five minutes or less to complete.
  prefs: []
  type: TYPE_NORMAL
- en: ngrok the API engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we go ahead and start working on the lambda service, we need to first
    expose our API engine to be available with a public URL, as in [http://iotfwjs.com/api](http://iotjs.com/api),
    so when the user asks the Alexa skill service a question or issues a command,
    the Alexa skill service can contact us via the lambda service.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have been using a local IP-based configuration to interact with the
    API engine, broker, web app, or Raspberry Pi. But, that doesn't work when we want,
    Alexa skill service to find us.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, we are going to use a service named `ngrok` ([https://ngrok.com/](https://ngrok.com/))
    to temporarily host our local code with a public URL that Amazon Alexa service
    can use to find us via lambda service.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up `ngrok`, please follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the `ngrok` installer from here: [https://ngrok.com/download](https://ngrok.com/download)
    for your OS, which is running the API engine'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip and copy the contents of the `ngrok` downloaded ZIP file at the root of
    the `api-engine` folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start Mosca from the root of the `broker` folder, by running the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the API engine from the root of `api-engine` folder, by running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Start tunneling with `ngrok` now. From the root of the `api-engine` folder,
    where we have copied the `ngrok` executable, run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `./ngrok http 9000` will start a new tunnel between the local host
    and a public instance of `ngrok` server, and we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00084.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The forwarding URL changes every time you kill and restart `ngrok`. In the
    preceding case, the public URL of ngrok: `http://add7231d.ngrok.io` is mapped
    to my local server: `http://localhost:9000`. Isn''t this easy?'
  prefs: []
  type: TYPE_NORMAL
- en: 'To quickly test the public URL, open `web-app/src/app/app.global.ts` and update
    it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can launch your web app from anywhere and it will talk to the API engine
    using the public URL.
  prefs: []
  type: TYPE_NORMAL
- en: Do read the terms of service ([https://ngrok.com/tos](https://ngrok.com/tos))
    and privacy policy ([https://ngrok.com/privacy](https://ngrok.com/privacy)) of
    `ngrok` before proceeding further.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the lambda function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the voice model is trained and we have a public URL to access the API
    engine, we are going to write the required service to respond to the user's interactions.
  prefs: []
  type: TYPE_NORMAL
- en: When a user goes, *Alexa, ask smarty app the weather report*, Alexa will make
    a request to the AWS lambda function and the lambda function will call the API
    engine for appropriate activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quoting from AWS: [https://aws.amazon.com/lambda/details/](https://aws.amazon.com/lambda/details/)'
  prefs: []
  type: TYPE_NORMAL
- en: The AWS Lambda is a serverless compute service that runs your code in response
    to events and automatically manages the underlying compute resources for you.
    You can use AWS Lambda to extend other AWS services with custom logic, or create
    your own back-end services that operate at AWS scale, performance, and security.
  prefs: []
  type: TYPE_NORMAL
- en: 'To know more about AWS lambda, refer to: [https://aws.amazon.com/lambda/details/](https://aws.amazon.com/lambda/details/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, head to AWS console: [https://console.aws.amazon.com/](https://console.aws.amazon.com/)
    and select the region as North Virginia. As of today, AWS lambda services hosted
    in North America and Europe are only allowed to be linked with the Alexa Skill.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, from the Service menu on top, select Lambda under the Compute section.
    This will take us to the Functions screen of the lambda service. Click on Create
    a Lambda function and we will be asked to select a blueprint. Select Blank Function.
    Next, you will be asked to select a trigger; select Alexa Skill Set, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Next. Now, we need to configure the function. Update it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00086.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For Lambda function code, enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: There is a lot going on in the code. `exports.handler()` is the default function
    that we need to set up for lambda to work. Inside that, we have defined the type
    of incoming request. And, if the incoming is an `IntentRequest`, we call `onIntent()`.
    Inside `onIntent()`, we fetch the `intentName` and invoke the appropriate logic.
  prefs: []
  type: TYPE_NORMAL
- en: If the `intentName` is `WeatherStatusIntent`, we invoke `handleWSIRequest()`,
    or else if the intentName is `ControlMotorIntent`, we call `handleCMIRequest()`.
  prefs: []
  type: TYPE_NORMAL
- en: Inside `handleWSIRequest()` we invoke the `getData()`, which will make a HTTP
    `GET` request to our `ngrok` URL. Once the data arrives, we construct a response
    and return it to the skill service.
  prefs: []
  type: TYPE_NORMAL
- en: And, `handleCMIRequest()` does the same, except it first gets the `motorAction`
    slot value and then calls `setData()`, which will call or either turn the motor
    on/off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the code has been copied, you should find additional configuration at
    the bottom. We are going to leave the handler as-is. For the role, click on Create
    a custom role, and set it up, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And click on Allow. This will create a new role that will get populated in
    Existing role*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00088.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once this is done, click on Next. Verify the summary and click on Create function
    at the bottom of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything goes well, you should see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00089.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Do notice the ARN in the top right corner. This is the **Amazon Resource Name**
    (**ARN**) for our lambda function. We need to provide this as an input to the
    Alexa Skills Kit.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have all the pieces, we will configure the ARN in the Alexa skill
    we have created. Head back to Alexa skill and click on Configuration, and update
    the configuration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00090.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click Next. If everything is set up correctly, we can test the setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Towards the bottom of the Test page, we should see a section named `Service
    Emulator`. You can test it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00091.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the request received by lambda from Alexa:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00092.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With this, we are done with integrating Alexa with our IoT.js framework.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored how to integrate a voice AI service such as
    Alexa with the IoTFW.js framework we have developed. We continued with the same
    example from [Chapter 4](part0083.html#2F4UM0-ce91715363d04669bca1c1545beb57ee),
    *Smart Agriculture*, and started off this chapter by setting up the relay that
    can turn the motor on/off. Next, we have understood how Alexa works. We have created
    a new custom skill and then set up the required voice model. After that, we have
    written the required business logic in AWS lambda, which will get the latest weather
    status as well as control the motor.
  prefs: []
  type: TYPE_NORMAL
- en: We have finally tested everything using the reverb app and also validated everything.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 6](part0111.html#39REE0-ce91715363d04669bca1c1545beb57ee), *Smart
    Wearable*, we are going to look at IoT and healthcare.
  prefs: []
  type: TYPE_NORMAL
