- en: Building Optimized Frontends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have come quite far in this book while trying to understand how to build
    applications for enterprises in Python. The chapters we''ve covered so far consisted
    of how to build a scalable and responsive backend for our enterprise application
    that can cater for a large number of concurrent users, so that our enterprise
    application is a success with its users. However, there is one topic we have been
    missing and which usually gets very little attention when building enterprise
    level applications: the application frontend.'
  prefs: []
  type: TYPE_NORMAL
- en: When a user interacts with our application, they are hardly concerned with what
    is going on in the backend. The experience of the user is directly connected with
    how the frontend of the application responds to their inputs. This makes the application
    frontend not only one of the most important aspects of the application, but also
    makes it one of the major deciding factors for the success of the application
    among its users.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we will take a look at how we can build application
    frontends that not only provide an easy to use experience, but also a fast response
    to their inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'While going through this chapter, we will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The need for optimizing the application frontends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing the resources your frontend depends upon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging the client-side caching to streamline the page loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing web storage for persisting user data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code listings in this book can be found under bugzot applicationdirectory
    built in `chapter06` at [https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python).
  prefs: []
  type: TYPE_NORMAL
- en: 'The code samples can be cloned by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The execution of the code does not require any particular set of special tools
    or frameworks and is a pretty straightforward process. The `README.md` file points
    to how to run the code samples for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The need for optimizing frontends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The UI of the application is one of its most important user facing components.
    It decides how the user is going to perceive the application. A smooth and fluid
    frontend goes a long way in defining the user experience with the application.
  prefs: []
  type: TYPE_NORMAL
- en: This requirement for a smooth user experience brings in the need for optimizing
    the application frontend, in that it provides an easy to use interface, fast response
    times, and fluidity in the operations. If we go ahead and look toward the web
    2.0 companies such as Google, Facebook, LinkedIn, and so on, they spend a huge
    amount of resources just on optimizing their frontends to shave off a few milliseconds
    of the rendering time. That is how important an optimized frontend is.
  prefs: []
  type: TYPE_NORMAL
- en: Components of an optimized frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are discussing optimizing the frontends. But what does an optimized frontend
    consist of? How can we decide whether a frontend is optimized or not? Let's take
    a look.
  prefs: []
  type: TYPE_NORMAL
- en: 'An optimized frontend has several components, where it is not compulsory that
    every component needs to be reflected from the frontend. These components are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quick rendering times**: One of the first focuses of frontend optimization
    is to reduce the rendering time of the page. Although there is no predefined set
    of rendering times that can be considered good or bad, you can think that a good
    rendering time will be the one where the user does not have to wait too long for
    the page to load on a decent internet connection. Also, a ...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What causes frontend issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Frontend issues are a category of issues that are easily perceived by the users
    because they affect the way the user interacts with an application. For the sake
    of clarity here, when we say frontend of an enterprise web application, we are
    not only talking about its UI, we are also talking about the code and the templates
    that are there to render the required UI. Now, let''s move on to understand what
    possible causes of frontend-specific issues are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Excessive amount of objects**: In most of the dynamically populated templates
    that are responsible for rendering the frontend, the first problem comes with
    the rendering of an excessive amount of objects. When a lot of objects are passed
    to a template that needs to be rendered, the page response times tend to increase,
    causing an imminent slowdown in the process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Excessive includes**: One of the major things that is focused on in software
    engineering is how to increase the modularity of the code base. The increase in
    modularity benefits in the increased reusability of the components. However, everything
    done in excess can be a signal of a major problem that might occur. When the frontend
    templates are modularized to an extent that goes beyond what is required, the
    rendering performance of the templates decreases. The reason for this is that
    for every include that is there, a new file needs to be loaded from the disk,
    which is an exceptionally slow operation. One of the counter points here could
    be that once the template is loaded with all it includes resolved, the rendering
    engine can cache the template and serve the later requests from the cache. However,
    most of the caching engines have a limit on how much level of included depth they
    can cache, beyond which the performance hit will be imminent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unnecessary set of resources**: Some of the frontends could have an unnecessarily
    large amount of resources being loaded that are not used anywhere on a particular
    page. This includes JavaScript files that contain functions that are executed
    only on a small set of pages. Every extra file that is being loaded not only adds
    to increased consumption of the bandwidth but also affects the loading performance
    of the frontend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forcing the code to be loaded serially**: Most modern browsers are now optimized
    to load a lot of resources in parallel to efficiently utilize the network bandwidth
    and to reduce the page loading times. However, at times, some of the tricks that
    we use to reduce the amount of code may force the page to get loaded sequentially
    instead of being loaded in parallel. One of the most common examples that may
    cause the page resources to be loaded in sequence is the use of CSS imports. Although
    CSS imports provide the flexibility of loading third-party CSS files directly
    inside another style sheet, it also reduces the ability of the browser to load
    the contents of the CSS file in parallel, hence increasing the time it takes to
    render a page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This set of causes forms a non-exhaustive list of issues that can cause a slowdown
    in the page rendering time and hence provide an unpleasant experience to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at how we can optimize our frontends to be responsive
    in nature and provide the best possible user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we learned about the various issues that may hamper the performance
    of the frontend. Now, it's time to take a look at how we can reduce the performance
    impact on the frontends and make them fast and responsive in an enterprise grade
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first and foremost optimization that we are going to take a look at is
    the optimization of resources that a particular page loads when it is requested.
    For this, consider the following code snippet from the user data display page
    in the admin panel, which is responsible for displaying a table of users in the
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good. As we can see, the code snippet just loops over a user''s
    object and renders the table based on how many records are stored in the user''s
    table. This is essentially good for most of the purposes where the user records
    are only in a small number (for example, 100 or so). But this code will start
    to become problematic as the number of users in the application grows. Imagine
    trying to load 1 million records from the application database and making them
    display on the UI. There are certain issues with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Slow database queries**: Trying to load up 1 million records from the database
    at the same time is going to be very slow and can take quite a significant time,
    hence blocking the view from rendering for a long time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decoding the objects in the frontend:** In the frontend, to render the page,
    the templating engine has to decode the data from all the objects so that it is
    able to display the data on the page. This kind of operation is not only CPU intensive,
    but also slow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Large page size:** Imagine transferring over a page consisting of millions
    of records over the network from the server to client. This process is time-consuming
    and also makes the page unfavorable to load over slow connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, what can we do here? The answer to this is pretty simple: let''s optimize
    the amount of resources that are going to be loaded. To achieve this, we are going
    to utilize a concept known as pagination.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement pagination, we need to make a few changes to the view that is
    responsible for rendering the frontend template, as well as the frontend template.
    The following code describes how the view will look if it had to support pagination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We are now done with the modifications to the view—it now supports pagination.
    Implementing this pagination was quite an easy task with the facilities already
    provided by SQLAlchemy to paginate the results from the database table using the
    `paginate()` method. This `paginate()` method asks for three parameters, namely
    the page number, which should start from one, the number of records on each page,
    and `error_out`, which is responsible for setting the error reporting for the
    method. A `False` here disables the errors from being displayed on `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the view developed to support the pagination, the next thing is to define
    the template so that it can take advantage of the pagination. The following code
    shows the modified template code that takes advantage of the pagination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: And with this, we have our view code ready. This view code is quite simple as
    we have just extended the previous template by adding a `href`, which loads the
    data for the next page.
  prefs: []
  type: TYPE_NORMAL
- en: With our resources being sent to the page now optimized, the next thing we need
    to focus on is how we can make our frontend load more and more resources faster.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching CSS in parallel by avoiding CSS imports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSS is one of the major parts of any frontend that helps in providing the styling
    information to the browser for how it should style the page it has received from
    the server. Usually, a frontend may have a number of CSS files associated with
    it. One of the possible optimizations that we can achieve here is by making these
    CSS files get fetched in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's imagine we have the following set of CSS files, namely `main.css`,
    `reset.css`, `responsive.css`, and `grid.css`, which our frontend needs to load.
    The way we allow the browser to load all these files in parallel is by linking
    them into the frontend using the HTML link tag instead of CSS imports, which causes
    the CSS files to be loaded ...
  prefs: []
  type: TYPE_NORMAL
- en: Bundling JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the current time and hopefully the future as well, we will constantly see
    increasing bandwidths for the networks, be it broadband networks or mobile networks
    that allow for faster downloading of resources in parallel. But for every resource
    that needs to be fetched from a remote server, there is still some network latency
    involved due to the fact that every separate resource demands a separate request
    to be made to the server. This latency can bite when there are a lot of resources
    that need to be loaded and when the user is on a high latency network.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, most modern web applications heavily utilize JavaScript for a wide
    set of purposes, which may include input validation, dynamically generating content,
    and so on. All of this functionality is split into multiple files, which may include
    some libraries, customized code, and so on. Although having all of these split
    into different files can help in parallel loading, sometimes the JavaScript files
    contain code for generating dynamic content on the web page, which may block the
    rendering of the web page until all the necessary files required for successfully
    rendering the page are not loaded.
  prefs: []
  type: TYPE_NORMAL
- en: One of the possible ways through which we can reduce the amount of time a browser
    takes to load up these script resources is to bundle them all together into a
    single file. This allows all the scripts to be combined into a single large file
    that the browser can fetch in a single request. Although this may cause the user
    a bit of a slow experience when they first visit a website, once the resource
    has been fetched and cached, the subsequent loads of the web page will be significantly
    faster for the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, a lot of third-party libraries are available that allow us to bundle
    this JavaScript. Let''s take an example of a simple tool called Browserify, which
    allows us to bundle our JavaScript files. For example, if we had multiple JavaScript
    files, such as `jquery.js`, `image-loader.js`, `slideshow.js`, and `input-validator.js`,
    and we want to bundle these files together with Browserify, all we have to do
    is run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will create a bundle of these JavaScript files into a common file
    known as `bundle.js`, which can now be included in our web application through
    the use of a simple script tag like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With the JavaScript bundled to load up in one request, we may start seeing some
    improvements in terms of how quickly a page is fetched and displayed to the user
    in the browser with the subsequent page loads. Now, let's take a look at one other
    interesting topic that may be of a good use to really make a difference in how
    quickly our web application loads up for repeated visits to the website.
  prefs: []
  type: TYPE_NORMAL
- en: The technique we discussed for bundling of JavaScript can also be a good optimization
    for the inclusion of CSS files.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing client-side caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Caching has long been used to speed up the loading of resources that are frequently
    used. For example, most of the modern operating systems utilize caching for providing
    faster access to the most frequently used applications. The web browsers also
    utilize caching to provide quicker access to resources when the user visits the
    same website again. This is done so as to avoid fetching the same files from the
    remote server again and again if they haven't changed and hence reducing the amount
    of data transfer that may be required, while also improving the rendering time
    for the page.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in the world of enterprise applications, something like client-side caching
    can prove to be really useful. This happens because ...
  prefs: []
  type: TYPE_NORMAL
- en: Setting application-wide cache control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since our application is based upon Flask, we can leverage several simple mechanisms
    for setting up the cache control for our application. For example, adding the
    following code to the end of our `bugzot/application.py` file enables site-wide
    cache control, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we utilize the Flask's inbuilt `after_request` decorator hook
    to set up the HTTP response header once the request has arrived to the Flask application.
    The decorated function needs a single parameter that takes in an object of the
    response class and returns a modified response object.
  prefs: []
  type: TYPE_NORMAL
- en: For our use case, inside the code for the method for the `after_request` hook,
    we set the `cache_control.max_age` header, which specifies the upper boundary
    for the time for which the content will be served from the cache before it is
    fetched from the server again, and the `cache_control.public` header, which defines
    if the cached response can be shared with multiple requests or not.
  prefs: []
  type: TYPE_NORMAL
- en: Now, there could be times when we want to set up the cache control differently
    for a particular kind of request. For example, we may not want `cache_control.public`
    to be set for the user profile page so as to avoid displaying the same profile
    data to the different users. Our application allows us to achieve these kinds
    of scenarios pretty quickly. Let's take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Setting request level cache control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Flask, we can modify the response headers before we send the response back
    to the client. This can be done fairly easily. The following example shows a simple
    view implementing response-specific header control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Utilizing web storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any web application developer who has worked on any application that involves
    even a little user management will for sure have heard about web cookies, which
    in essence provide a mechanism for storing some of the information on the client
    side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Utilizing cookies provides an easy way through which we can maintain small
    amounts of user data on the client side and can read it multiple times until the
    cookies expire. But as easy as it is to deal with cookies, there are certain limitations
    that restrict the cookies being used for anything useful, other than maintaining
    a small amount of application state on the client side. Some of these limitations
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Cookies are transferred with every request, hence adding to the data that is
    transferred with every request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cookies allow for storing a little amount of data that is restricted to a maximum
    of 4 KB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, the question that comes is, what can we do if we want to store more data
    or we want to avoid fetching the same set of stored data again and again with
    every request?
  prefs: []
  type: TYPE_NORMAL
- en: 'For dealing with such scenarios, the latest version of HTML, HTML 5, provides
    various functionalities that allow for dealing with client-side web storage. This
    web storage provides a number of benefits over the cookies-based mechanism, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Since the web storage is available directly on the client side, the information
    doesn't need to be sent by the server again and again to the client with every
    request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web storage API provides a maximum of 10 MB of storage, which is multiple
    times grater than what can be stored with the cookies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web storage provides the flexibility of storing the data either in local storage,
    for example, the data will be accessible even after the user closes and opens
    a browser again, or on a per session basis, where the data stored in the web storage
    will be cleared off as soon as the session is invalidated, either when the user
    session is destroyed by your application handler responsible for handling the
    user log out, or the browser is closed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This makes web storage an attractive place to put in the data and avoid loading
    it again and again.
  prefs: []
  type: TYPE_NORMAL
- en: For our enterprise applications, this can provide a lot of flexibility by storing
    the results of the intermediate steps in the user browser only, and then submitting
    them back to the server only when all the required input fields have been filled
    up.
  prefs: []
  type: TYPE_NORMAL
- en: One other use case that may be more specific to Bugzot is that, we can store
    the bug report that a user is filing into the web storage and send it to the server
    when the bug report is completed. In this case, the user gets the flexibility
    to come back to working on their bug reports as and when they wish, without worrying
    about starting from scratch again.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about the benefits that web storage provides, let's take a
    look at how we can leverage the use of web storage.
  prefs: []
  type: TYPE_NORMAL
- en: Working with local web storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The use of local web storage is easy with HTML 5, since it provides a number
    of APIs to interact with the web storage. So, without wasting much time, let''s
    take a look at a simple example of how we can use local web storage. For this,
    we will create a simple JavaScript file known as `localstore.js` with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This was ...
  prefs: []
  type: TYPE_NORMAL
- en: Working with session storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As simple as it is to use the local storage, session storage also doesn''t
    add any kind of complexity. For example, let''s take a look at how easy it is
    to port our example of `localStorage` to `sessionStorage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: From this example, it is evident that moving away from local storage to session
    storage is very easy, with both the storage options providing a similar storage
    API, the only difference being how long the data in the storage is kept.
  prefs: []
  type: TYPE_NORMAL
- en: With the knowledge of how we can optimize frontends to provide completely scalable
    and responsive enterprise web applications, now it's time for us to visit some
    aspects of the enterprise application development that ensure what we are building
    is secure and works as per expectations, and doesn't delivers random surprises.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the course of this chapter, we learned about why it is important
    to have an optimized frontend for our enterprise applications, and how a frontend
    may affect the use of our application inside the enterprise. We then moved on
    to understand what kind of issues usually plague the performance of web frontends,
    and what possible solutions we can take to improve the application frontend. This
    involves reducing the amount of resources that are loaded by the frontend, allowing
    the CSS to load in parallel, bundling JavaScript, and so on. We then moved on
    to understand how caching can prove to be useful considering the use case of an
    enterprise web application. Once we understood the concept of caching, we then
    moved into the territory ...
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can the use of CDN provide a boost to frontend performance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we do something to make the browser utilize existing connections to the
    server for loading resources?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we remove a particular key from web storage or clear the contents of
    web storage?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
