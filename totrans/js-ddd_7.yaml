- en: Chapter 7. It's Not All Domain-driven Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *If I have seen further, it is by standing on the shoulders of giants.*
    |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
- en: '|   | --*Newton* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
- en: As with most things in developing, and not just when developing software, most
    concepts have been discovered before and most things have been done before, but
    there are those slight variations, or a recombination of ideas, that make old
    concepts more useful or enable new and innovative uses. The practice of developing
    software has been growing and evolving since the beginning. Some time ago, the
    concept of structured programming, the use of functions, subroutines, while and
    for loops, was considered a new concept. Later, object-orientation and functional
    programming took those ideas and added new ones on top to further ease maintainability
    and allow programmers to better express their intentions in the programs they
    write.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: As with those ideas, domain-driven design evolved from a lot of the ideas of
    object-oriented programming, and a lot of them have been mentioned throughout
    the book already. There are more concepts influencing the ideas, and some of them
    are closely related to object-orientation, such as the ideas of aspect-orientation,
    and using plain objects to model a core service-layer in a system. But there are
    also ideas originating from other areas, such as building domain-specific languages.
    Domain-specific languages have been around for a very long time and they are commonly
    seen in the LISP family of languages.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The LISP family knows different forms of DSLs, and most LISP programs can be
    seen as a very lightweight DSL in themselves. Visit [http://en.wikipedia.org/wiki/Lisp_%28programming_language%29](http://en.wikipedia.org/wiki/Lisp_%28programming_language%29)
    for more details.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming also added to the ideas of domain-driven design, most
    notably the idea that immutability is a thing to aim for, easing debugging, and
    thinking about the domain in general.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following chapter, you will see in detail what those additional concepts
    are that influence domain-driven design, as well as programming in general. This
    chapter will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the prerequisites for domain-driven design
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know the influences such as object- and aspect-oriented programming,
    programming with plain objects, as well as command-query separation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain-specific languages
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other programming practices such as functional programming and event-based systems
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching the domain to the problem
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working on an application mostly means thinking about ways to express a given
    problem in a way that a machine can understand and work on it. Domain-driven design
    takes this full circle back and makes sure that the people working on the domain
    understand the machine representation of the problem, and are therefore able to
    reason about it and contribute to it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the book, we have been talking about building a language for humans
    and machines at the same time. Doing this means taking the constructs that JavaScript
    gives us and making them expressive to developers and domain experts alike.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to express a problem, and some of them are easier to reason
    about than others. In a very simple case, for example, one could write the sum
    of the numbers of an array like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This simple program works by doing a lot of work inside the `for` loop check,
    assigning a current element of the array, an initial starting value for the sum,
    and consequently uses those to implement the sum. To make the loop a little more
    confusing, it uses the property of getting an index outside the array bounds,
    resulting in an undefined, which is false to break out of the loop in the check.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Even though this works, it is very hard to reason about what is happening. This
    is due to naming as well as complex constructs being used to express the idea
    of summing up numbers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Growing into a domain
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Thinking about the domain in the previous example, we can see that JavaScript
    already gives us terms to express this domain more clearly, assuming some familiarity
    with mathematical terms, for example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑前面例子中的领域，我们可以看到JavaScript已经为我们提供了更清晰地表达这个领域的术语，假设对数学术语有一定的了解，例如：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By using the tools available to us, we can slowly grow into the domain concepts
    in general, extending what is already there, and building what needs to be added.
    We now use the built-in reduce function to do the same as the `for` loop did before.
    The `reduce` function takes a function as an argument, which gets passed the result
    so far and the current element, and we also give it a starting point of 0 to get
    the process started. For people familiar with the language, this is much more
    readable and almost instantly understandable as it uses the common concepts of
    how to express operations on arrays.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用我们可用的工具，我们可以逐渐成长为领域概念的一般性，扩展已有的内容，并构建需要添加的内容。我们现在使用内置的reduce函数来执行与以前的“for”循环相同的操作。`reduce`函数将一个函数作为参数，该函数传递到目前为止的结果和当前元素，并且我们还给它一个起始点0来启动该过程。对于熟悉该语言的人来说，这更易读，几乎可以立即理解，因为它使用了如何在数组上表达操作的常见概念。
- en: 'Using the same basic technique, we can leverage the built-in functions to accomplish
    tasks in our domain as well. When we want to calculate the time a transport takes,
    we might want to only consider the working days, so we need to filter weekends,
    and using the built-in function, this can be expressed cleanly:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的基本技术，我们也可以利用内置函数来完成我们领域中的任务。当我们想要计算运输所需的时间时，我们可能只想考虑工作日，因此我们需要过滤周末，使用内置函数，这可以清晰地表达：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We use the filter method to filter out weekends in the days from now, assuming
    it is Monday, and we can then select the arrival day as the position in the array.
    As we move along in our development we can make this even clearer, but using the
    built-in methods to operate already gives the code natural readability.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用filter方法来过滤掉现在的日期中的周末，假设今天是星期一，然后我们可以选择到达日作为数组中的位置。随着我们在开发中的进展，我们可以使这更加清晰，但是使用内置方法来操作已经使代码具有自然的可读性。
- en: Different domains have different merits of expressiveness, and the more understood
    a certain problem is, in general, the better it leads to building a domain design
    around the idea, in case when the general problem's complexity actually leads
    to a domain-driven design.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的领域具有不同的表现优点，通常情况下，对某个问题的理解越深刻，就越有利于围绕这个想法构建领域设计，以便在一般问题的复杂性实际上导致领域驱动设计的情况下。
- en: A good domain for domain-driven design
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 领域驱动设计的良好领域
- en: So far we have been working with the dungeon management system, which manages
    cells and prisoners coming in and out of the dungeon, making the dungeon money
    if they are present. This domain is quite complex as we have seen already, as
    we have just managed the transport of prisoners out of the dungeon so far, allowing
    the dungeon to have enough prisoners at the right time. This is, of course, not
    a real-world example, well obviously, as we have been talking about orcs. The
    example is grounded in a very real-world application, originally based on the
    idea of managing bookings for hotels, with over- and underbooking.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用地牢管理系统，该系统管理着进出地牢的单元格和囚犯，如果囚犯在场，地牢就会赚钱。这个领域非常复杂，正如我们已经看到的那样，因为我们到目前为止只是管理了囚犯从地牢中的运输，使地牢在适当的时间有足够的囚犯。当然，这不是一个真实的例子，显然，因为我们一直在谈论兽人。这个例子是基于一个非常真实的应用程序，最初是基于管理酒店预订的想法，包括超额预订和不足预订。
- en: On inspecting the domain, we can see certain properties that make it a valuable
    domain for domain-driven design. The inherent problem is quite complex and involves
    many different parts to collaborate and model, to build a complete, working system.
    Each part is also commonly subject to change as the system is further optimized
    towards an optimal system, providing maximum profit for the using company.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查领域时，我们可以看到使其成为领域驱动设计有价值的特性。固有问题非常复杂，涉及许多不同的部分进行协作和建模，以构建一个完整的、可工作的系统。随着系统进一步优化为最佳系统，为使用公司提供最大利润，每个部分也经常会发生变化。
- en: What further increases the value of the domain design, in this case, is that
    the users interacting with the system vary widely. Different users need to be
    exposed to different interfaces being wired together. This kind of sharing functionality
    is hard to get right, and having a central core model to model the shared parts
    is a good way to keep the different sub-applications from drifting apart, which
    is a common problem in projects having a common set of domain-specific logic split
    over multiple applications.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，进一步增加领域设计的价值的是，与系统交互的用户差异很大。不同的用户需要暴露给不同的接口，这些接口被连接在一起。这种共享功能很难做到，拥有一个中心核心模型来模拟共享部分是保持不同子应用程序不会分离的好方法，这在将一组特定于领域的逻辑分割到多个应用程序的项目中是一个常见的问题。
- en: The power of object-orientation
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象的力量
- en: Large parts of the concepts we have been leveraging as part of our building
    of the application so far are by no means specific inventions for the concepts
    of domain-driven design. Many familiar with other work around these principles
    of software engineering will have noticed many ideas from other areas. A large
    chunk of ideas are those cultivated by many people over the years as part of object-orientation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在构建应用程序的过程中利用的概念绝不是领域驱动设计概念的特定发明。许多熟悉软件工程原则的人会注意到许多来自其他领域的想法。许多想法是多年来许多人培养出来的对象导向的一部分。
- en: The object-oriented principles so far
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 到目前为止的面向对象原则
- en: 'Object-orientation is about the encapsulation of state with functionality.
    The idea is fundamental and we have been using it throughout the book to build
    up our system and compose different parts as objects. JavaScript objects are special
    when it comes to object-orientation, as JavaScript is one of the few languages
    based on prototypical inheritance versus classical inheritance like most other
    object-oriented languages. This means more than a special way to deal with inheritance;
    it also means that JavaScript has a very easy way to deal with objects. Because
    there is no real difference between an instance and a class, the syntax to deal
    with objects is very simple:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is the most simple way to create objects and is also the most often used
    one in JavaScript.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: We have used objects to both represent value objects as well as entities, especially
    value objects. A key point to object-oriented programming is the isolation objects
    provide; when building the system we build it up by letting objects interact via
    sending messages to each other. This works particularly well when we are able
    to separate the command from the query messages as we have done. Splitting the
    commands from the queries enables easier testing and better reasoning about the
    code as it splits the things that modify the state (the commands) from idempotent
    operations (the queries that can be executed without causing any side effects).
    Another even more important advantage is that separating queries from commands
    allows us to express the significance of the commands from the domain more clearly.
    When we issue a command to a domain object, it has a significant meaning in the
    domain and should therefore stand on its own as well as being in the ubiquitous
    language established in the project. When issuing a command, we always want to
    express the "why", and bundling this with a query does not allow a name to express
    both.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common example is the command to update a property on the object, like `updateAddress`,
    which does not tell us the "why" when naming it. `changeDeliveryTarget` makes
    it clearer why this attribute was updated. Mixing these kind of changes in a query
    method is unnatural.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Prototypical inheritance gives us another great way to model our data, as compared
    to classical inheritance the chains in prototypical inheritance are likely quite
    shallow. The important feature of prototypes is that they allow us to inherit
    dynamically from any object. The following code shows the usage of `Object.create`
    to inherit and extend objects:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using the `Object.create` method allows us to easily build from other objects.
    It was not always present in JavaScript, and before we needed to do a lot more
    to get the same effect, but with the `Object.create` method, building objects
    is very natural and it embraces the concept of prototypical inheritance.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Objects lend themselves very well to model data that flows through the system
    as they are very lightweight and extendable. There are a couple of caveats we
    need to be aware of, as discussed in the previous sections. Especially, the simple
    extension that allows the use of shallow inheritance hierarchies while still using
    polymorphism to resolve control flow. Using polymorphism to control the control
    flow is the common approach in object-orientation to allow objects to encapsulate
    knowledge. When we send a command to an object, we want it to act according to
    its internal knowledge and state, and we don''t care about its specific implementation
    unless we want to send it a specific command. This allows us to have smart objects
    that respond to commands directed at them differently, for example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We again use a basic JavaScript object as the base to build new functionality
    on top. This time, we extend our simple counter with new functionality by implementing
    a jumping counter with a new function, without modifying the underlying counter
    object. This shows the power of easy extensibility—we can just use functionality
    encapsulated in objects that already exist and build upon it without much ceremony.
    This possibility is the source of much of the power of JavaScript, a nice power
    to have but also easily abused.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: This leads to a very simple model of domain models that depend on each other,
    which can be used directly but also extended along the way.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The object-oriented modeling of business domains
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea of object-orientation to encapsulate the business domain is of great
    benefit in general as it leads to a less coupled system that is easier to understand
    and modify. When we think of objects as things we pass messages to and receive
    answers from, we naturally couple ourselves less to the internal structure of
    the code, as the API becomes a question and answer, as well as a command game.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'In a very simple example going back to our dungeon and its orcs, we might want
    to implement a method for fighting an intruder. So we start by implementing an
    orc with a weapon, using a very lightweight object to start with, for example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There is one feature here that is not commonly used but is very powerful: we
    can define getters and setters in JavaScript for objects via the special `get`
    or `set` syntax, allowing us to first of all limit the scope of modifications
    to our properties, but also to allow us to construct more complex properties out
    of other ones. In this case, we abstract the knowledge that a missing weapon means
    the orc is not armed.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'We consider the fight to be its own domain object, so we model it as well:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The fight encapsulates the logic that only an armed orc can actually attack
    his opponent during a battle. This is, of course, very simple logic but it might
    grow to be more complex. We will use an object model to abstract away the fact
    of how a fight is handled in the system.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is always important to keep in mind that creating objects, especially in
    JavaScript, is very cheap. Encapsulating too much knowledge into one object is
    not a good idea and more often than not, it is better to split an object early
    into responsibilities. A good indicator for this is an object that has lots of
    private methods, or methods whose names are closely related.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now model our fight with the objects:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This encapsulates the logic for the fight in its own object and uses the orcs
    to encapsulate logic related to the orcs.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The scenarios of pure object-orientation falling short
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basics of object orientation work very well for large parts of modeling
    the domain. Especially in JavaScript with its very lightweight object creation
    and modeling, it lends itself quite nicely to model a domain like we have seen.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Where object orientation falls short is on the level of transaction management,
    we have certain interaction spanning multiple objects that needs to be managed
    from a higher level. On the other hand, we don't want the details of the transaction
    to leak to all the involved objects. This is where domain-driven design comes
    in with a separation of value objects, entities, and aggregates. In this case,
    aggregates allow workflow management by being the life-cycled manager of other
    collaborators. As we model the domain as composed of sub-domains, even though
    an entity may be shared between different collaborating sub-domains, each sub-domain
    has its own view of the entity. In each sub-domain, an aggregate can control the
    transactions necessary to accomplish the task and make sure the data is in a consistent
    state.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: There are, of course, multiple other additions as we have seen throughout the
    book but the addition of a higher-level management for the lower-level details
    of the objects is an important feature, extending object-oriented application
    structures toward domain-driven form object orientation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Influences to keep close
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object-orientation is not the only influence on application development we have
    seen throughout the book. Many different techniques can be useful to model domain
    concepts and influence how applications are developed. JavaScript itself is a
    very flexible language and can be used, and sometimes to abused, to do very interesting
    things.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the situation, different ideas can be good to keep at hand when
    modeling certain aspects or solving certain problems as they occur when building
    the model.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Aspect-oriented programming
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At its core, most ideas of software development revolve around how it is possible
    to encapsulate logic and state it so it is easily accessible and has a common
    interface that is understandable as well as extensible. Extensibility is a very
    important aspect especially in business software since the requirements need to
    be adjusted to the real world and the software needs to be able to encompass new
    requirements quickly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Aspect-oriented programming sets the idea of aspects of the software development
    in the centre of the program design, and concerns itself especially with how we
    can implement cross-cutting concerns without duplication and in a maintainable
    fashion. Aspects in the case of aspect-oriented programming are all kind of concerns
    that might be shared across different objects.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The canonical example of aspect-oriented programming is the addition of an audit
    log to the system. The audit log is something that would need to be implemented
    across all the different domain objects, while at the same time not being a core
    concern to the object. Aspect-oriented programming extracts the aspect, in this
    case the audit logging, and applies it to each object that should be treated this
    way. By that means, it makes the aspect a core part of the system, decoupled from
    the business object.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript, due to its very dynamic nature, can do this very simply and dynamically;
    one solution is to use traits.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The traits used are based on [https://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins/](https://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins/).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now build on the previous example and add `audit` logging to our `Fight`
    object. We can add the calls to the log to the `fight` class directly:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To make sure we can either audit the fight or not, we will add a flag and then
    check and log the appropriate calls. This adds quite a lot of plumbing to the
    object as we also now need to depend on a way to inspect, and therefore add a
    dependency, to the `util` library.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I consider flag arguments a red flag in most cases as they indicate that multiple
    concerns are mixed in one place, which need to be switched on. Often, it can be
    an indicator of a cross-cutting concern better solved by using aspect-orientation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'A better way to add logging to the orc fight is by adding a loggable trait
    to the fight. The trait would be the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code wraps each function in a function that first logs its arguments and
    forwards them to the function afterwards. This is possible without touching the
    object at all in an abstract way since JavaScript allows us to enumerate all the
    properties of the object we want to extend via the introspection capabilities.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: When applied to an object, the `asLoggable` trait wraps every method of the
    object in a logged method, writing out which function was called on what, and
    with what kind of arguments, and to output more meaningful information, it uses
    the `inspect` library.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s apply this to the previously constructed code, which means replacing
    the `Fight` object with the `LoggableFight` object:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The calls will now be logged and the output will be as follows, but shortened
    for printability:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在调用将被记录，输出将如下，但为了可打印性而缩短：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This addition does not change the overall behavior, but is a pure extension
    to the system.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个添加并不改变整体行为，而是对系统的纯扩展。
- en: Extending an object in this way is a very powerful technique but can be quite
    dangerous at the same time. Even though the code is quite simple to create, it
    is not as easy to understand where certain properties of the code come from, and
    a lot depends on the right naming. If we, for example, had just replaced the `Fight`
    object all together, getting rid of the `LoggableFight` object name, there would
    be no indication of why there is suddenly logging applied to the method, and a
    developer tracking down a bug in the code would have a tough time in a big project.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式扩展对象是一种非常强大的技术，但同时也可能非常危险。尽管代码创建起来相当简单，但要理解代码的某些属性来自何处并不容易，很大程度上取决于正确的命名。例如，如果我们完全替换了`Fight`对象，摆脱了`LoggableFight`对象名称，那么就不会有任何迹象表明为什么方法突然应用了日志记录，而在一个大型项目中，跟踪代码中的错误将会让开发人员感到困难。
- en: Command-query separation
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令查询分离
- en: 'While aspect-orientation is about separating concerns at the level of objects,
    command query separation is about separating concerns at the level of methods.
    We have seen before that handling the state is difficult and a value object is
    therefore more simple than an entity. The same is true for methods: sending a
    query to an object means that the object will answer the same query in the same
    way as long as it holds the same state, and the query does not modify the state.
    This makes it very easy to write tests for queries because a simple setup of the
    object, and asserting the output of the method, does the trick.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然面向方面是关于在对象级别上分离关注点，命令查询分离是关于在方法级别上分离关注点。我们之前已经看到处理状态是困难的，因此值对象比实体更简单。对于方法也是如此：向对象发送查询意味着只要对象保持相同的状态，查询就会以相同的方式回答，而且查询不会修改状态。这使得为查询编写测试非常容易，因为简单设置对象，并断言方法的输出就可以了。
- en: Commands can be more complicated, as they modify the state of the object that
    they are sent to. A command in general does not have a return value but should
    only result in a state change for the object. This again makes it easier for us
    to test the result of commands, as we can set up an object, send a command, and
    assert that the appropriate change has been applied, without having to assert
    at the same time that the correct return value has been returned along the way.
    What we need to keep in mind when writing commands is to manage their failure
    states, and depending on the application there are multiple ways to deal with
    this. The simplest way might be raising an exception, or when using `async` commands,
    returning an error to the callback. This allows managing the aggregate, to react
    and either roll back, or handle the problem appropriately. Either way, we don't
    want to return more complex results as this quickly leads down the path of depending
    on data being returned from the command.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 命令可能更复杂，因为它们修改了被发送到的对象的状态。一般来说，命令没有返回值，但应该只导致对象的状态发生变化。这使得我们更容易测试命令的结果，因为我们可以设置一个对象，发送一个命令，并断言适当的变化已经被应用，而不必同时断言正确的返回值已经在途中返回。在编写命令时，我们需要牢记的是管理它们的失败状态，根据应用程序的不同，有多种处理方式。最简单的方式可能是引发异常，或者在使用`async`命令时，将错误返回给回调函数。这允许管理聚合，以便对问题做出反应，要么回滚，要么适当地处理问题。无论哪种方式，我们都不希望返回更复杂的结果，因为这很快就会导致依赖从命令返回的数据。
- en: Command-query separation is one of the core principles to keep in mind when
    writing maintainable code that can be tested and extended.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 命令查询分离是编写可维护的、可测试和可扩展的代码时要牢记的核心原则之一。
- en: Plain old objects
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 普通旧对象
- en: 'Along with the separation comes the tendency to make things as simple as possible,
    and the way to go for most applications, especially in JavaScript, is to use the
    simple, plain objects that JavaScript provides. We have multiple ways to construct
    objects in JavaScript, and throughout the book we have been using both the classical
    and more more class-like pattern:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 随着分离的出现，人们倾向于尽可能简化事物，尤其是在JavaScript中，大多数应用程序的最佳选择是使用JavaScript提供的简单、普通对象。我们在JavaScript中构建对象的方式有多种，本书中我们一直在使用经典的和更类似类的模式：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this chapter, we also used the more JavaScript-like pattern using `Object.create`
    and exemplar objects.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还使用了更类似JavaScript的模式，使用`Object.create`和示例对象。
- en: The important thing to note in all of this is that the code stays away from
    using complex containers to manage the objects, the lifecycle, and more. Using
    plain objects, whatever pattern is used to construct them, means they can be tested
    in isolation and are simple to follow through the application, as well as extensively
    using the patterns of the core language as needed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些中需要注意的重要事情是，代码远离使用复杂的容器来管理对象、生命周期等。使用普通对象，无论使用什么模式来构建它们，意味着它们可以在隔离的情况下进行测试，并且在应用程序中简单地跟踪，同时根据需要广泛地使用核心语言的模式。
- en: Domain-specific languages
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域特定语言
- en: Using specific keywords to describe parts of the domain is one of the main goals
    we set out to achieve in building a system using domain-driven design. Especially
    the LISP community, which has been an influence on JavaScript ([http://readwrite.com/2011/07/22/javascript-was-no-accident](http://readwrite.com/2011/07/22/javascript-was-no-accident)),
    there is a strong tendency to meld the language to the problem. This naturally
    leads to further trying to make the language fit the domain, with the ultimate
    goal of having a language that is perfect for solving the specific problem the
    domain has.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特定关键词来描述领域的部分是我们在使用领域驱动设计构建系统时设定的主要目标之一。特别是LISP社区对JavaScript产生了影响，有一种强烈的倾向将语言与问题融合在一起。这自然地导致进一步尝试使语言适应领域，最终目标是拥有一种完美解决特定问题的语言。
- en: This kind of development is referred to as using **Domain-specific Languages**,
    or **DSL** for short. In day-to-day work, there are lots of very DSLs we come
    across, be it CSS to describe the style of a HTML document, or SQL for interfacing
    with the database. The lines when a language is a DSL and when it is a general-purpose
    language are often a bit blurred. SQL, for example, is often considered a "real"
    programming language, so to speak, even though it has the very specific purpose
    of modifying and querying a relational database.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这种开发被称为使用**特定领域语言**，简称**DSL**。在日常工作中，我们经常遇到许多DSL，无论是用于描述HTML文档样式的CSS，还是用于与数据库交互的SQL。语言是DSL，还是通用语言的界限通常有些模糊。例如，SQL通常被认为是一种“真正”的编程语言，即使它具有修改和查询关系数据库的非常具体的目的。
- en: A DSL is often defined and implemented on a host language and a library to provide
    the functionality first, and is then further refined by adding a special syntax
    on top. A more recent example of this can be seen in the Ruby world where the
    server administration toolkit Chef started out as a library of functions to control
    the configuration of servers, but as this developed the system became more DSL-like
    and by now, the language to describe configuration is still hosted on Ruby but
    has its own words to describe the specifics of server administration. The power
    of this model is, of course, that the underlying language is still Ruby, a general-purpose
    language, and therefore when the DSL reaches its limits, there is always the possibility
    to extend it using the host language.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: DSL通常是在主机语言和库上定义和实现的，首先提供功能，然后通过添加特殊语法来进一步完善。最近的一个例子可以在Ruby世界中看到，服务器管理工具Chef最初是一组函数库，用于控制服务器配置，但随着系统的发展，它变得更像DSL，到现在为止，描述配置的语言仍然托管在Ruby上，但有自己的词汇来描述服务器管理的具体内容。当然，这种模式的优势在于底层语言仍然是Ruby，一种通用语言，因此当DSL达到极限时，总是可以使用主机语言进行扩展。
- en: Creating DSLs
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建DSL
- en: This kind of model is what we would want to follow in a system in my opinion.
    When building a new application, it is not practical to start designing a DSL
    to solve the—at this point probably still unknown—core problem of the domain.
    But we want to start building a library of words we can use to describe our problem,
    gluing this kind of library together more and more, while filling in the gaps.
    This is how most (good) DSLs evolve. They start as a library and grow until they
    reach a point where it becomes practical to extract the language itself as a core
    domain part.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，这种模式是我们想要在系统中遵循的。在构建新应用程序时，从实际角度来看，开始设计DSL来解决领域的核心问题——在这一点上可能仍然未知——是不切实际的。但我们希望开始构建一个词汇库，用来描述我们的问题，将这种词汇库越来越紧密地粘合在一起，同时填补空白。这就是大多数（好的）DSL的演变方式。它们起初是一个库，然后不断发展，直到达到一个实际上可以将语言本身提取为核心领域部分的程度。
- en: 'JavaScript itself is full of DSLs, as the language design lends itself very
    nicely to the construction of libraries that expose their functionality as a DSL.
    The line, again, is not always clear but as we look at code such as the following,
    we can see a certain DSL-like nature. The following snippet is an example from
    [https://jquery.com/](https://jquery.com/):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript本身充满了DSL，因为语言设计非常适合构建将其功能公开为DSL的库。再次强调，界限并不总是清晰，但当我们看到以下代码时，我们可以看到某种DSL的特性。以下片段是来自[https://jquery.com/](https://jquery.com/)的一个例子：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code uses the **jQuery** selection engines to define click handlers on elements,
    and trigger actions in them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用**jQuery**选择引擎来定义元素上的点击处理程序，并在其中触发操作。
- en: jQuery has become one of those almost ubiquitous libraries and is almost considered
    essential by some web developers. jQuery first introduced the way to select certain
    page elements by their selector, be it "`#`" for an element ID or "`.`" for elements
    by class. This way of reusing the selector definition from CSS to also select
    elements from the page, and therefore being able with one function—the `$`, to
    create a language to manipulate all kinds of page elements, is the real power
    of jQuery.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery已经成为几乎无处不在的库，并且被一些Web开发人员认为是必不可少的。jQuery首先介绍了通过其选择器选择特定页面元素的方法，无论是通过“#”选择元素ID，还是通过“.”选择类别元素。这种重用CSS中的选择器定义来选择页面元素的方式，因此能够使用一个函数——$，来创建一种语言来操作各种页面元素，这就是jQuery的真正力量。
- en: DSLs in domain-driven design
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 领域驱动设计中的DSL
- en: As we are looking at other DSLs, we should realize that our own approach for
    development hasn't been too far from the power of a true DSL. There is some way
    to go of course, but even the simple examples from the beginning of the chapter
    show where we are going in accordance to naming things right, to be able to grow
    a language we can speak with the domain experts. This is another power of DSLs
    as the goal is to make the language as understandable as possible to people not
    considered the core developers of the system.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Where jQuery made it possible for web designers to start manipulating their
    web pages with JavaScript, our language in the project should make it possible
    for the business owners to check whether the rules that are supposed to be reflected
    by the system are truly reflected as they are supposed to be. The following code
    shows how we can use our build functions, to clearly show in the code how a prisoner
    transfer is executed:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Even though a business expert would likely not understand the preceding code
    directly, it allows us to follow through with an explanation. We can explain the
    inputs to the expert saying, "A prisoner transfer involves the prisoner being
    sent, the dungeon the prisoner is sent to and the dungeon the prisoner is coming
    from. We also need notify the dungeon". Walking through the code, we can explain
    the steps along the way:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: A prisoner is supposed to be transferred from one dungeon to another.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need a keeper and a carriage to perform the transfer.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the transfer succeeds, a message is sent to the dungeon.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These simple-to-follow rules, stated as closely as possible to plain English,
    is what we are aiming for. Even though we might not involve the business experts
    in daily code walkthroughs, it is useful to be able to cross-check the rules as
    close to the code when the need arises, and just to reduce our own mental overhead.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Drawing knowledge
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object orientation and its specific forms are, of course, not the only influence
    we have, and not the only one we should have. Many different ways of developing
    software have been found to be useful and have value in the world of software
    development. Depending on the kind of system we want to build, it is not always
    the best even to model as objects.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: There are very common ways that lend themselves nicely to specific problems,
    be it a more functional approach when faced with the problems of concurrency,
    or a more logical approach when trying to build a rule engine. All these kind
    of ways to approach a problem influence the way we think about a system, and the
    more different approaches there are in our toolbox, the better we can pick one
    that fits.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Naturally, certain approaches feel better for an individual; I, for example,
    don't fair well when faced with a purely functional, statically-typed approach
    that, for example, Haskell takes to developing software. I have a hard time expressing
    my thoughts about the problem in such a language. Don't get discouraged by this
    kind of struggle though, because even your day-to-day work might not seem to fit
    the approach, you might come across a problem where it fits perfectly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, I think that besides knowing about the approaches that object
    orientation takes to solve problems, close relation to domain-driven design, can't
    be the end all, and an introduction to other ways of thinking can be very helpful
    to draw knowledge from.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|   | *Functional programming is a style of programming which models computations
    as the evaluation of expressions.* |   |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '|   | --*[https://wiki.haskell.org/Functional_programming](https://wiki.haskell.org/Functional_programming)*
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: Functional programming has gained a lot of influence over the last years, and
    it has not only gained traction in niche communities, but companies have been
    founded on the idea that functional programming is a way to develop software.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Even though it has been around for a long time, a recent surge of interest in
    the ideas of functional programming has been sparked, but problems arise in the
    development of large scale systems needing to serve large numbers of users concurrently,
    and be as bug free as possible. The premise of functional programming is that
    large parts of the development can be done in a purely functional way, avoiding
    mutation of the state as well as passing around functions to be executed on other
    functions, or value objects to be transformed toward the end result.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: As our systems become more parallel and have to deal with more concurrent requests,
    the more functional our code is and the more it interacts with immutable data
    structures, the easier to manage this increasingly complex scenario gets. We can
    avoid the need for more complex locking, as well as race conditions that are hard
    to debug.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming and JavaScript
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript has had many influences, be it the prototypical inheritance mechanism
    oriented towards the way inheritance is done in the language itself, or the way
    functions are first class citizens as they are in **Scheme**, a LISP dialect.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'This influence from Scheme makes JavaScript somewhat functional even though
    it is, maybe, not the primary focus of the way many people use the language:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the beginning of this chapter, we already used the `reduce` function on the
    array, and we can now follow this up with a `filter` and `map` to create more
    complex chains of operations. These all work very similarly and abstract away
    the knowledge of how iteration should be handled, but they let you express the
    action to be done. In the case of a map, transforming each element to its square,
    and in the case of a filter, sorting out elements that do not match a certain
    criteria.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript has basic ways to operate on elements in a functional style. Using
    the likes of map, reduce, and filter, we can quickly modify collections, for example,
    and this kind of programming is often used to modify sets of HTML elements in
    a similar style.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Of course, a program like this could also be written as a `for` loop, but in
    this case the intention gets lost in the setup of the loop as well as the management
    of the loop variables. Functional methods specialized in modifying collections
    are a very effective way to boil the problem down to the core steps and describe
    them as functions to apply, without having to worry about how each element is
    mapped over, selected from the original collection and, probably most importantly,
    where to store the result.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: For increased readability, we can name the functions being applied, as required,
    to reduce the mental overhead for the reader having to understand the function
    body. Combined with the higher abstraction level, these collection methods, like
    the previously introduced methods such as `filter` and `reduce`, mean we can quickly
    create very expressive APIs.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Value objects
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The idea that we don't want to worry about where we store results but simply
    operate on the input and let the language figure out what to do about the intermediate
    results, and how to manage the pass through of the elements, is a core strength
    of functional programming. Even though this is not the case for JavaScript, it
    is easy to see how the preceding code could be optimized by the compiler to pass
    through items in batches, or even operate on the items in separate workers instead
    of letting the main process do all the work.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: These kinds of optimizations are easy to do when we don't have to directly deal
    with the problems of concurrency. The main problem of concurrency is the shared
    state between different parts of the program. So the main thing to learn from
    functional approaches is possibly the idea that what we called "value objects"
    before, objects that are only identified by their properties and not their identity,
    are a good thing. We can easily pass them around and modify collections of them
    with functions, and share them with whoever we want, because they can't change.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Value objects make dependencies shallow, as they terminate chains we have to
    think about. Once we reach a value object, we can be sure that we just need to
    construct one in case we want to test something. There is no need for mocking,
    stubbing, or anything complicated.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Not only are value objects at the core of functional approaches, maybe as much
    as the idea that functions are a first class thing, but they are also there to
    represent the data to pass through the system. As we have seen before, this data
    can flow through, instead of having to stop and be evaluated as a whole. This
    thinking naturally leads to another tool in our tool chest, using events to model
    the state of a system.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Events
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The real-world functions through a system of reactions to actions and events.
    If somebody wants me to open the door of my apartment, they will ring the doorbell,
    and if I''m at home, I will react to this and go to open the door. This is a well-defined
    flow of events: first somebody decides they want to trigger me to open the door,
    so they need to discover the service to send the event, in this case the doorbell,
    they then trigger the event by pressing the doorbell. When I hear the ring, I
    first need to check whether the event is actually for me, and in the case of the
    doorbell this depends on whether I''m alone at home or not. After deciding that
    the event is actually for me, I can decide how to react, selecting the appropriate
    handler, so to speak, so I will get up and go to open the door.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'At each point of the execution, I can decide how to handle the next step. If
    I am in the shower, for example, I might decide to ignore the event and just continue
    showering. After I''m done, I might check the door later, queuing up the action
    to handle the event. Also in the case of the doorbell, the event is multicast
    to multiple consumers; if, for example, my wife is at home, she can also go to
    open the door. From an event-sender side, we also have multiple options: if I''m
    outside somebody''s house, I can decide to ring the doorbell, but if I don''t
    get a reaction, I can check whether there are other ways to trigger the signal;
    I can, for example, just knock. The following diagram shows the flow of events
    described:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![Events](graphics/B03704_07_01.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: This little example shows the very power of modeling a system via small components
    communicating via events. Each component can decide how to respond to an event
    considering its current load or even other events being triggered at the same
    time. Priorities can be implemented by reordering the events either on the sender
    side or on the consumer side to ensure the best responsiveness for the system
    in regards to the agreed-upon service level agreements.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript offers this kind of eventing at its core, and NodeJS''s `EventEmitter`
    is a nice abstraction over the core idea, leading to very clear code, for example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `EventEmitter` function allows us to add to the functionality commonly known
    from interacting with the document object model in JavaScript to any object we
    need. In the preceding code, we use the `inherits` helper to make our `House`
    be an `EventEmitter`. With this in place, we can act on events and dispatch them
    as seen. We can define events we want other objects to be able to react to, like
    we would react to clicks or hover events.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Event stores versus entity relational mapping
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on what our system is supposed to achieve, it can be important to
    save events. In the case of our doorbell example where I am in the shower, we
    might have the problem that I can not hear the event as well as my decision to
    not respond to it. Depending on the reason the person triggering the event had,
    this can either be acceptable or not.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: If it were the postman trying to drop off a package and they don't want to wait,
    they can have a short timeout to await a response and if they don't get one, they
    can queue the package delivery again on their side, get back in the van, and try
    again tomorrow. In other circumstances when we want the system delivering the
    event to handle this scenario for us, this is also common, for example, when I
    miss a call, I will get an SMS with the call details, or a voicemail saving the
    event details for me and when I'm ready to handle it I can do so.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: In many software systems, we want the event delivery system to abstract away
    as many things as possible. Going all the way to the extreme, it is even possible
    to construct the system purely by storing the events and never actually modifying
    any data, but just generating new events to again be stored. All the system needs
    to know at this point is at which point in time a consumer is in regards to the
    event stream, and it can then replay whatever is needed, obviating the need to
    store modifiable data by mapping entities to a database. The only entity in this
    scenario is the pointer into the event log for each consumer. This is not something
    that is easy to implement as it raises problems due to the only eventually consistent
    nature of such a system. After all, it takes time to send events between systems,
    but it might be worth it for a reasonably complex system to tackle.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A very good example of such a system is **Kafka**, and it is a whole ecosystem
    for modeling, consuming, event creation, and storage, but there are other examples
    for this as well. Martin Kleppman has written about, and presented on this, at
    various occasions, for example, at Spanconf 2014: [https://www.youtube.com/watch?v=b_H4FFE3wP0](https://www.youtube.com/watch?v=b_H4FFE3wP0).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Creating a system like this is probably not the simplest or the first choice
    when developing a business application as the requirements for the infrastructure
    to support it are quite high. The more the application has to deal with high availability
    and the more the system starts to be distributed for whatever reason, the more
    reasonable such a system becomes. JavaScript as a language is very well suited
    to event handling, as it is at the core of the domain the language was build for—reacting
    to user events in the browser.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this chapter, there have been a lot of things introduced that are
    not the primary focus but still added a great deal of understanding to the evolvement
    of domain-driven design. Being inspired by workarounds can really improve the
    general software development practices so there is further reading I would recommend.
    To further understand object orientation, and especially to find design patterns
    to use, I recommend the book called *Gang of four*, and *Design Patterns : Elements
    of Reusable Object-Oriented Software*, *Erich Gamma*, *Richard Helm*, *Ralph Johnson*,
    *John Vlissides*, *Pearson Publishing.* Even though the book is old, it still
    represents classic work on object orientation, and establishes a lot of terminology.
    Also *Smalltalk Best Practice Patterns*, *Kent Becks*, *Prentice Hall*, really
    embraces Object-Oriented design, and even though both books are naturally not
    focused on JavaScript, they can still be very helpful in advancing your design
    skills.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: At the other end of the chapter, we went into some detail on how to get started
    on modeling a flow of events, which is currently a very hot topic. Martin Kleppmann
    has been doing a lot of work around this area, so following his work closely will
    bring you some good insights into how to model growing applications ([https://martin.kleppmann.com/](https://martin.kleppmann.com/)).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: There is obviously a lot more to follow up on, but getting started with the
    mentioned work will naturally lead to a lot more, probably more than is digestible
    in a short amount of time, so I recommend you go and follow this up and follow
    it down the rabbit hole.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the various ways domain-driven design is influenced
    and can be augmented by related software development patterns. Some patterns are
    closer than others, such as DSLs, and some are more orthogonal such as modeling
    the system as a series of events.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The important thing is to make sure we don't get stuck in trying to only apply
    the techniques we see in a specific pattern, but look at what is around to make
    sure we use the right tool for the job. At its core, domain-driven design is about
    modeling business software, and while most business software follows similar patterns
    and rules, some internal details might be very well-suited for a functional core
    integrated in the software as a whole, or even the development of a DSL that allows
    not-so-technical business experts to express their rules clearly.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to sum up all the details we came across and
    are going to think about how to work on an ever-changing product like most business
    software is.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
