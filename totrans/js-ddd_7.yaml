- en: Chapter 7. It's Not All Domain-driven Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *If I have seen further, it is by standing on the shoulders of giants.*
    |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Newton* |'
  prefs: []
  type: TYPE_TB
- en: As with most things in developing, and not just when developing software, most
    concepts have been discovered before and most things have been done before, but
    there are those slight variations, or a recombination of ideas, that make old
    concepts more useful or enable new and innovative uses. The practice of developing
    software has been growing and evolving since the beginning. Some time ago, the
    concept of structured programming, the use of functions, subroutines, while and
    for loops, was considered a new concept. Later, object-orientation and functional
    programming took those ideas and added new ones on top to further ease maintainability
    and allow programmers to better express their intentions in the programs they
    write.
  prefs: []
  type: TYPE_NORMAL
- en: As with those ideas, domain-driven design evolved from a lot of the ideas of
    object-oriented programming, and a lot of them have been mentioned throughout
    the book already. There are more concepts influencing the ideas, and some of them
    are closely related to object-orientation, such as the ideas of aspect-orientation,
    and using plain objects to model a core service-layer in a system. But there are
    also ideas originating from other areas, such as building domain-specific languages.
    Domain-specific languages have been around for a very long time and they are commonly
    seen in the LISP family of languages.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The LISP family knows different forms of DSLs, and most LISP programs can be
    seen as a very lightweight DSL in themselves. Visit [http://en.wikipedia.org/wiki/Lisp_%28programming_language%29](http://en.wikipedia.org/wiki/Lisp_%28programming_language%29)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming also added to the ideas of domain-driven design, most
    notably the idea that immutability is a thing to aim for, easing debugging, and
    thinking about the domain in general.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following chapter, you will see in detail what those additional concepts
    are that influence domain-driven design, as well as programming in general. This
    chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the prerequisites for domain-driven design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know the influences such as object- and aspect-oriented programming,
    programming with plain objects, as well as command-query separation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain-specific languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other programming practices such as functional programming and event-based systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching the domain to the problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working on an application mostly means thinking about ways to express a given
    problem in a way that a machine can understand and work on it. Domain-driven design
    takes this full circle back and makes sure that the people working on the domain
    understand the machine representation of the problem, and are therefore able to
    reason about it and contribute to it.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the book, we have been talking about building a language for humans
    and machines at the same time. Doing this means taking the constructs that JavaScript
    gives us and making them expressive to developers and domain experts alike.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to express a problem, and some of them are easier to reason
    about than others. In a very simple case, for example, one could write the sum
    of the numbers of an array like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This simple program works by doing a lot of work inside the `for` loop check,
    assigning a current element of the array, an initial starting value for the sum,
    and consequently uses those to implement the sum. To make the loop a little more
    confusing, it uses the property of getting an index outside the array bounds,
    resulting in an undefined, which is false to break out of the loop in the check.
  prefs: []
  type: TYPE_NORMAL
- en: Even though this works, it is very hard to reason about what is happening. This
    is due to naming as well as complex constructs being used to express the idea
    of summing up numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Growing into a domain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Thinking about the domain in the previous example, we can see that JavaScript
    already gives us terms to express this domain more clearly, assuming some familiarity
    with mathematical terms, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By using the tools available to us, we can slowly grow into the domain concepts
    in general, extending what is already there, and building what needs to be added.
    We now use the built-in reduce function to do the same as the `for` loop did before.
    The `reduce` function takes a function as an argument, which gets passed the result
    so far and the current element, and we also give it a starting point of 0 to get
    the process started. For people familiar with the language, this is much more
    readable and almost instantly understandable as it uses the common concepts of
    how to express operations on arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the same basic technique, we can leverage the built-in functions to accomplish
    tasks in our domain as well. When we want to calculate the time a transport takes,
    we might want to only consider the working days, so we need to filter weekends,
    and using the built-in function, this can be expressed cleanly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We use the filter method to filter out weekends in the days from now, assuming
    it is Monday, and we can then select the arrival day as the position in the array.
    As we move along in our development we can make this even clearer, but using the
    built-in methods to operate already gives the code natural readability.
  prefs: []
  type: TYPE_NORMAL
- en: Different domains have different merits of expressiveness, and the more understood
    a certain problem is, in general, the better it leads to building a domain design
    around the idea, in case when the general problem's complexity actually leads
    to a domain-driven design.
  prefs: []
  type: TYPE_NORMAL
- en: A good domain for domain-driven design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far we have been working with the dungeon management system, which manages
    cells and prisoners coming in and out of the dungeon, making the dungeon money
    if they are present. This domain is quite complex as we have seen already, as
    we have just managed the transport of prisoners out of the dungeon so far, allowing
    the dungeon to have enough prisoners at the right time. This is, of course, not
    a real-world example, well obviously, as we have been talking about orcs. The
    example is grounded in a very real-world application, originally based on the
    idea of managing bookings for hotels, with over- and underbooking.
  prefs: []
  type: TYPE_NORMAL
- en: On inspecting the domain, we can see certain properties that make it a valuable
    domain for domain-driven design. The inherent problem is quite complex and involves
    many different parts to collaborate and model, to build a complete, working system.
    Each part is also commonly subject to change as the system is further optimized
    towards an optimal system, providing maximum profit for the using company.
  prefs: []
  type: TYPE_NORMAL
- en: What further increases the value of the domain design, in this case, is that
    the users interacting with the system vary widely. Different users need to be
    exposed to different interfaces being wired together. This kind of sharing functionality
    is hard to get right, and having a central core model to model the shared parts
    is a good way to keep the different sub-applications from drifting apart, which
    is a common problem in projects having a common set of domain-specific logic split
    over multiple applications.
  prefs: []
  type: TYPE_NORMAL
- en: The power of object-orientation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Large parts of the concepts we have been leveraging as part of our building
    of the application so far are by no means specific inventions for the concepts
    of domain-driven design. Many familiar with other work around these principles
    of software engineering will have noticed many ideas from other areas. A large
    chunk of ideas are those cultivated by many people over the years as part of object-orientation.
  prefs: []
  type: TYPE_NORMAL
- en: The object-oriented principles so far
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Object-orientation is about the encapsulation of state with functionality.
    The idea is fundamental and we have been using it throughout the book to build
    up our system and compose different parts as objects. JavaScript objects are special
    when it comes to object-orientation, as JavaScript is one of the few languages
    based on prototypical inheritance versus classical inheritance like most other
    object-oriented languages. This means more than a special way to deal with inheritance;
    it also means that JavaScript has a very easy way to deal with objects. Because
    there is no real difference between an instance and a class, the syntax to deal
    with objects is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is the most simple way to create objects and is also the most often used
    one in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: We have used objects to both represent value objects as well as entities, especially
    value objects. A key point to object-oriented programming is the isolation objects
    provide; when building the system we build it up by letting objects interact via
    sending messages to each other. This works particularly well when we are able
    to separate the command from the query messages as we have done. Splitting the
    commands from the queries enables easier testing and better reasoning about the
    code as it splits the things that modify the state (the commands) from idempotent
    operations (the queries that can be executed without causing any side effects).
    Another even more important advantage is that separating queries from commands
    allows us to express the significance of the commands from the domain more clearly.
    When we issue a command to a domain object, it has a significant meaning in the
    domain and should therefore stand on its own as well as being in the ubiquitous
    language established in the project. When issuing a command, we always want to
    express the "why", and bundling this with a query does not allow a name to express
    both.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common example is the command to update a property on the object, like `updateAddress`,
    which does not tell us the "why" when naming it. `changeDeliveryTarget` makes
    it clearer why this attribute was updated. Mixing these kind of changes in a query
    method is unnatural.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prototypical inheritance gives us another great way to model our data, as compared
    to classical inheritance the chains in prototypical inheritance are likely quite
    shallow. The important feature of prototypes is that they allow us to inherit
    dynamically from any object. The following code shows the usage of `Object.create`
    to inherit and extend objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Using the `Object.create` method allows us to easily build from other objects.
    It was not always present in JavaScript, and before we needed to do a lot more
    to get the same effect, but with the `Object.create` method, building objects
    is very natural and it embraces the concept of prototypical inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Objects lend themselves very well to model data that flows through the system
    as they are very lightweight and extendable. There are a couple of caveats we
    need to be aware of, as discussed in the previous sections. Especially, the simple
    extension that allows the use of shallow inheritance hierarchies while still using
    polymorphism to resolve control flow. Using polymorphism to control the control
    flow is the common approach in object-orientation to allow objects to encapsulate
    knowledge. When we send a command to an object, we want it to act according to
    its internal knowledge and state, and we don''t care about its specific implementation
    unless we want to send it a specific command. This allows us to have smart objects
    that respond to commands directed at them differently, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We again use a basic JavaScript object as the base to build new functionality
    on top. This time, we extend our simple counter with new functionality by implementing
    a jumping counter with a new function, without modifying the underlying counter
    object. This shows the power of easy extensibility—we can just use functionality
    encapsulated in objects that already exist and build upon it without much ceremony.
    This possibility is the source of much of the power of JavaScript, a nice power
    to have but also easily abused.
  prefs: []
  type: TYPE_NORMAL
- en: This leads to a very simple model of domain models that depend on each other,
    which can be used directly but also extended along the way.
  prefs: []
  type: TYPE_NORMAL
- en: The object-oriented modeling of business domains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea of object-orientation to encapsulate the business domain is of great
    benefit in general as it leads to a less coupled system that is easier to understand
    and modify. When we think of objects as things we pass messages to and receive
    answers from, we naturally couple ourselves less to the internal structure of
    the code, as the API becomes a question and answer, as well as a command game.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a very simple example going back to our dungeon and its orcs, we might want
    to implement a method for fighting an intruder. So we start by implementing an
    orc with a weapon, using a very lightweight object to start with, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one feature here that is not commonly used but is very powerful: we
    can define getters and setters in JavaScript for objects via the special `get`
    or `set` syntax, allowing us to first of all limit the scope of modifications
    to our properties, but also to allow us to construct more complex properties out
    of other ones. In this case, we abstract the knowledge that a missing weapon means
    the orc is not armed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We consider the fight to be its own domain object, so we model it as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The fight encapsulates the logic that only an armed orc can actually attack
    his opponent during a battle. This is, of course, very simple logic but it might
    grow to be more complex. We will use an object model to abstract away the fact
    of how a fight is handled in the system.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is always important to keep in mind that creating objects, especially in
    JavaScript, is very cheap. Encapsulating too much knowledge into one object is
    not a good idea and more often than not, it is better to split an object early
    into responsibilities. A good indicator for this is an object that has lots of
    private methods, or methods whose names are closely related.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now model our fight with the objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This encapsulates the logic for the fight in its own object and uses the orcs
    to encapsulate logic related to the orcs.
  prefs: []
  type: TYPE_NORMAL
- en: The scenarios of pure object-orientation falling short
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basics of object orientation work very well for large parts of modeling
    the domain. Especially in JavaScript with its very lightweight object creation
    and modeling, it lends itself quite nicely to model a domain like we have seen.
  prefs: []
  type: TYPE_NORMAL
- en: Where object orientation falls short is on the level of transaction management,
    we have certain interaction spanning multiple objects that needs to be managed
    from a higher level. On the other hand, we don't want the details of the transaction
    to leak to all the involved objects. This is where domain-driven design comes
    in with a separation of value objects, entities, and aggregates. In this case,
    aggregates allow workflow management by being the life-cycled manager of other
    collaborators. As we model the domain as composed of sub-domains, even though
    an entity may be shared between different collaborating sub-domains, each sub-domain
    has its own view of the entity. In each sub-domain, an aggregate can control the
    transactions necessary to accomplish the task and make sure the data is in a consistent
    state.
  prefs: []
  type: TYPE_NORMAL
- en: There are, of course, multiple other additions as we have seen throughout the
    book but the addition of a higher-level management for the lower-level details
    of the objects is an important feature, extending object-oriented application
    structures toward domain-driven form object orientation.
  prefs: []
  type: TYPE_NORMAL
- en: Influences to keep close
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object-orientation is not the only influence on application development we have
    seen throughout the book. Many different techniques can be useful to model domain
    concepts and influence how applications are developed. JavaScript itself is a
    very flexible language and can be used, and sometimes to abused, to do very interesting
    things.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the situation, different ideas can be good to keep at hand when
    modeling certain aspects or solving certain problems as they occur when building
    the model.
  prefs: []
  type: TYPE_NORMAL
- en: Aspect-oriented programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At its core, most ideas of software development revolve around how it is possible
    to encapsulate logic and state it so it is easily accessible and has a common
    interface that is understandable as well as extensible. Extensibility is a very
    important aspect especially in business software since the requirements need to
    be adjusted to the real world and the software needs to be able to encompass new
    requirements quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Aspect-oriented programming sets the idea of aspects of the software development
    in the centre of the program design, and concerns itself especially with how we
    can implement cross-cutting concerns without duplication and in a maintainable
    fashion. Aspects in the case of aspect-oriented programming are all kind of concerns
    that might be shared across different objects.
  prefs: []
  type: TYPE_NORMAL
- en: The canonical example of aspect-oriented programming is the addition of an audit
    log to the system. The audit log is something that would need to be implemented
    across all the different domain objects, while at the same time not being a core
    concern to the object. Aspect-oriented programming extracts the aspect, in this
    case the audit logging, and applies it to each object that should be treated this
    way. By that means, it makes the aspect a core part of the system, decoupled from
    the business object.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript, due to its very dynamic nature, can do this very simply and dynamically;
    one solution is to use traits.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The traits used are based on [https://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins/](https://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins/).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now build on the previous example and add `audit` logging to our `Fight`
    object. We can add the calls to the log to the `fight` class directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To make sure we can either audit the fight or not, we will add a flag and then
    check and log the appropriate calls. This adds quite a lot of plumbing to the
    object as we also now need to depend on a way to inspect, and therefore add a
    dependency, to the `util` library.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I consider flag arguments a red flag in most cases as they indicate that multiple
    concerns are mixed in one place, which need to be switched on. Often, it can be
    an indicator of a cross-cutting concern better solved by using aspect-orientation.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better way to add logging to the orc fight is by adding a loggable trait
    to the fight. The trait would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The code wraps each function in a function that first logs its arguments and
    forwards them to the function afterwards. This is possible without touching the
    object at all in an abstract way since JavaScript allows us to enumerate all the
    properties of the object we want to extend via the introspection capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: When applied to an object, the `asLoggable` trait wraps every method of the
    object in a logged method, writing out which function was called on what, and
    with what kind of arguments, and to output more meaningful information, it uses
    the `inspect` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s apply this to the previously constructed code, which means replacing
    the `Fight` object with the `LoggableFight` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The calls will now be logged and the output will be as follows, but shortened
    for printability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This addition does not change the overall behavior, but is a pure extension
    to the system.
  prefs: []
  type: TYPE_NORMAL
- en: Extending an object in this way is a very powerful technique but can be quite
    dangerous at the same time. Even though the code is quite simple to create, it
    is not as easy to understand where certain properties of the code come from, and
    a lot depends on the right naming. If we, for example, had just replaced the `Fight`
    object all together, getting rid of the `LoggableFight` object name, there would
    be no indication of why there is suddenly logging applied to the method, and a
    developer tracking down a bug in the code would have a tough time in a big project.
  prefs: []
  type: TYPE_NORMAL
- en: Command-query separation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While aspect-orientation is about separating concerns at the level of objects,
    command query separation is about separating concerns at the level of methods.
    We have seen before that handling the state is difficult and a value object is
    therefore more simple than an entity. The same is true for methods: sending a
    query to an object means that the object will answer the same query in the same
    way as long as it holds the same state, and the query does not modify the state.
    This makes it very easy to write tests for queries because a simple setup of the
    object, and asserting the output of the method, does the trick.'
  prefs: []
  type: TYPE_NORMAL
- en: Commands can be more complicated, as they modify the state of the object that
    they are sent to. A command in general does not have a return value but should
    only result in a state change for the object. This again makes it easier for us
    to test the result of commands, as we can set up an object, send a command, and
    assert that the appropriate change has been applied, without having to assert
    at the same time that the correct return value has been returned along the way.
    What we need to keep in mind when writing commands is to manage their failure
    states, and depending on the application there are multiple ways to deal with
    this. The simplest way might be raising an exception, or when using `async` commands,
    returning an error to the callback. This allows managing the aggregate, to react
    and either roll back, or handle the problem appropriately. Either way, we don't
    want to return more complex results as this quickly leads down the path of depending
    on data being returned from the command.
  prefs: []
  type: TYPE_NORMAL
- en: Command-query separation is one of the core principles to keep in mind when
    writing maintainable code that can be tested and extended.
  prefs: []
  type: TYPE_NORMAL
- en: Plain old objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Along with the separation comes the tendency to make things as simple as possible,
    and the way to go for most applications, especially in JavaScript, is to use the
    simple, plain objects that JavaScript provides. We have multiple ways to construct
    objects in JavaScript, and throughout the book we have been using both the classical
    and more more class-like pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this chapter, we also used the more JavaScript-like pattern using `Object.create`
    and exemplar objects.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to note in all of this is that the code stays away from
    using complex containers to manage the objects, the lifecycle, and more. Using
    plain objects, whatever pattern is used to construct them, means they can be tested
    in isolation and are simple to follow through the application, as well as extensively
    using the patterns of the core language as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Domain-specific languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using specific keywords to describe parts of the domain is one of the main goals
    we set out to achieve in building a system using domain-driven design. Especially
    the LISP community, which has been an influence on JavaScript ([http://readwrite.com/2011/07/22/javascript-was-no-accident](http://readwrite.com/2011/07/22/javascript-was-no-accident)),
    there is a strong tendency to meld the language to the problem. This naturally
    leads to further trying to make the language fit the domain, with the ultimate
    goal of having a language that is perfect for solving the specific problem the
    domain has.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of development is referred to as using **Domain-specific Languages**,
    or **DSL** for short. In day-to-day work, there are lots of very DSLs we come
    across, be it CSS to describe the style of a HTML document, or SQL for interfacing
    with the database. The lines when a language is a DSL and when it is a general-purpose
    language are often a bit blurred. SQL, for example, is often considered a "real"
    programming language, so to speak, even though it has the very specific purpose
    of modifying and querying a relational database.
  prefs: []
  type: TYPE_NORMAL
- en: A DSL is often defined and implemented on a host language and a library to provide
    the functionality first, and is then further refined by adding a special syntax
    on top. A more recent example of this can be seen in the Ruby world where the
    server administration toolkit Chef started out as a library of functions to control
    the configuration of servers, but as this developed the system became more DSL-like
    and by now, the language to describe configuration is still hosted on Ruby but
    has its own words to describe the specifics of server administration. The power
    of this model is, of course, that the underlying language is still Ruby, a general-purpose
    language, and therefore when the DSL reaches its limits, there is always the possibility
    to extend it using the host language.
  prefs: []
  type: TYPE_NORMAL
- en: Creating DSLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This kind of model is what we would want to follow in a system in my opinion.
    When building a new application, it is not practical to start designing a DSL
    to solve the—at this point probably still unknown—core problem of the domain.
    But we want to start building a library of words we can use to describe our problem,
    gluing this kind of library together more and more, while filling in the gaps.
    This is how most (good) DSLs evolve. They start as a library and grow until they
    reach a point where it becomes practical to extract the language itself as a core
    domain part.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript itself is full of DSLs, as the language design lends itself very
    nicely to the construction of libraries that expose their functionality as a DSL.
    The line, again, is not always clear but as we look at code such as the following,
    we can see a certain DSL-like nature. The following snippet is an example from
    [https://jquery.com/](https://jquery.com/):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The code uses the **jQuery** selection engines to define click handlers on elements,
    and trigger actions in them.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery has become one of those almost ubiquitous libraries and is almost considered
    essential by some web developers. jQuery first introduced the way to select certain
    page elements by their selector, be it "`#`" for an element ID or "`.`" for elements
    by class. This way of reusing the selector definition from CSS to also select
    elements from the page, and therefore being able with one function—the `$`, to
    create a language to manipulate all kinds of page elements, is the real power
    of jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: DSLs in domain-driven design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we are looking at other DSLs, we should realize that our own approach for
    development hasn't been too far from the power of a true DSL. There is some way
    to go of course, but even the simple examples from the beginning of the chapter
    show where we are going in accordance to naming things right, to be able to grow
    a language we can speak with the domain experts. This is another power of DSLs
    as the goal is to make the language as understandable as possible to people not
    considered the core developers of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where jQuery made it possible for web designers to start manipulating their
    web pages with JavaScript, our language in the project should make it possible
    for the business owners to check whether the rules that are supposed to be reflected
    by the system are truly reflected as they are supposed to be. The following code
    shows how we can use our build functions, to clearly show in the code how a prisoner
    transfer is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though a business expert would likely not understand the preceding code
    directly, it allows us to follow through with an explanation. We can explain the
    inputs to the expert saying, "A prisoner transfer involves the prisoner being
    sent, the dungeon the prisoner is sent to and the dungeon the prisoner is coming
    from. We also need notify the dungeon". Walking through the code, we can explain
    the steps along the way:'
  prefs: []
  type: TYPE_NORMAL
- en: A prisoner is supposed to be transferred from one dungeon to another.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need a keeper and a carriage to perform the transfer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the transfer succeeds, a message is sent to the dungeon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These simple-to-follow rules, stated as closely as possible to plain English,
    is what we are aiming for. Even though we might not involve the business experts
    in daily code walkthroughs, it is useful to be able to cross-check the rules as
    close to the code when the need arises, and just to reduce our own mental overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object orientation and its specific forms are, of course, not the only influence
    we have, and not the only one we should have. Many different ways of developing
    software have been found to be useful and have value in the world of software
    development. Depending on the kind of system we want to build, it is not always
    the best even to model as objects.
  prefs: []
  type: TYPE_NORMAL
- en: There are very common ways that lend themselves nicely to specific problems,
    be it a more functional approach when faced with the problems of concurrency,
    or a more logical approach when trying to build a rule engine. All these kind
    of ways to approach a problem influence the way we think about a system, and the
    more different approaches there are in our toolbox, the better we can pick one
    that fits.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Naturally, certain approaches feel better for an individual; I, for example,
    don't fair well when faced with a purely functional, statically-typed approach
    that, for example, Haskell takes to developing software. I have a hard time expressing
    my thoughts about the problem in such a language. Don't get discouraged by this
    kind of struggle though, because even your day-to-day work might not seem to fit
    the approach, you might come across a problem where it fits perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, I think that besides knowing about the approaches that object
    orientation takes to solve problems, close relation to domain-driven design, can't
    be the end all, and an introduction to other ways of thinking can be very helpful
    to draw knowledge from.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|   | *Functional programming is a style of programming which models computations
    as the evaluation of expressions.* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*[https://wiki.haskell.org/Functional_programming](https://wiki.haskell.org/Functional_programming)*
    |'
  prefs: []
  type: TYPE_TB
- en: Functional programming has gained a lot of influence over the last years, and
    it has not only gained traction in niche communities, but companies have been
    founded on the idea that functional programming is a way to develop software.
  prefs: []
  type: TYPE_NORMAL
- en: Even though it has been around for a long time, a recent surge of interest in
    the ideas of functional programming has been sparked, but problems arise in the
    development of large scale systems needing to serve large numbers of users concurrently,
    and be as bug free as possible. The premise of functional programming is that
    large parts of the development can be done in a purely functional way, avoiding
    mutation of the state as well as passing around functions to be executed on other
    functions, or value objects to be transformed toward the end result.
  prefs: []
  type: TYPE_NORMAL
- en: As our systems become more parallel and have to deal with more concurrent requests,
    the more functional our code is and the more it interacts with immutable data
    structures, the easier to manage this increasingly complex scenario gets. We can
    avoid the need for more complex locking, as well as race conditions that are hard
    to debug.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming and JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript has had many influences, be it the prototypical inheritance mechanism
    oriented towards the way inheritance is done in the language itself, or the way
    functions are first class citizens as they are in **Scheme**, a LISP dialect.
  prefs: []
  type: TYPE_NORMAL
- en: 'This influence from Scheme makes JavaScript somewhat functional even though
    it is, maybe, not the primary focus of the way many people use the language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the beginning of this chapter, we already used the `reduce` function on the
    array, and we can now follow this up with a `filter` and `map` to create more
    complex chains of operations. These all work very similarly and abstract away
    the knowledge of how iteration should be handled, but they let you express the
    action to be done. In the case of a map, transforming each element to its square,
    and in the case of a filter, sorting out elements that do not match a certain
    criteria.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript has basic ways to operate on elements in a functional style. Using
    the likes of map, reduce, and filter, we can quickly modify collections, for example,
    and this kind of programming is often used to modify sets of HTML elements in
    a similar style.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, a program like this could also be written as a `for` loop, but in
    this case the intention gets lost in the setup of the loop as well as the management
    of the loop variables. Functional methods specialized in modifying collections
    are a very effective way to boil the problem down to the core steps and describe
    them as functions to apply, without having to worry about how each element is
    mapped over, selected from the original collection and, probably most importantly,
    where to store the result.
  prefs: []
  type: TYPE_NORMAL
- en: For increased readability, we can name the functions being applied, as required,
    to reduce the mental overhead for the reader having to understand the function
    body. Combined with the higher abstraction level, these collection methods, like
    the previously introduced methods such as `filter` and `reduce`, mean we can quickly
    create very expressive APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Value objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The idea that we don't want to worry about where we store results but simply
    operate on the input and let the language figure out what to do about the intermediate
    results, and how to manage the pass through of the elements, is a core strength
    of functional programming. Even though this is not the case for JavaScript, it
    is easy to see how the preceding code could be optimized by the compiler to pass
    through items in batches, or even operate on the items in separate workers instead
    of letting the main process do all the work.
  prefs: []
  type: TYPE_NORMAL
- en: These kinds of optimizations are easy to do when we don't have to directly deal
    with the problems of concurrency. The main problem of concurrency is the shared
    state between different parts of the program. So the main thing to learn from
    functional approaches is possibly the idea that what we called "value objects"
    before, objects that are only identified by their properties and not their identity,
    are a good thing. We can easily pass them around and modify collections of them
    with functions, and share them with whoever we want, because they can't change.
  prefs: []
  type: TYPE_NORMAL
- en: Value objects make dependencies shallow, as they terminate chains we have to
    think about. Once we reach a value object, we can be sure that we just need to
    construct one in case we want to test something. There is no need for mocking,
    stubbing, or anything complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Not only are value objects at the core of functional approaches, maybe as much
    as the idea that functions are a first class thing, but they are also there to
    represent the data to pass through the system. As we have seen before, this data
    can flow through, instead of having to stop and be evaluated as a whole. This
    thinking naturally leads to another tool in our tool chest, using events to model
    the state of a system.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The real-world functions through a system of reactions to actions and events.
    If somebody wants me to open the door of my apartment, they will ring the doorbell,
    and if I''m at home, I will react to this and go to open the door. This is a well-defined
    flow of events: first somebody decides they want to trigger me to open the door,
    so they need to discover the service to send the event, in this case the doorbell,
    they then trigger the event by pressing the doorbell. When I hear the ring, I
    first need to check whether the event is actually for me, and in the case of the
    doorbell this depends on whether I''m alone at home or not. After deciding that
    the event is actually for me, I can decide how to react, selecting the appropriate
    handler, so to speak, so I will get up and go to open the door.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At each point of the execution, I can decide how to handle the next step. If
    I am in the shower, for example, I might decide to ignore the event and just continue
    showering. After I''m done, I might check the door later, queuing up the action
    to handle the event. Also in the case of the doorbell, the event is multicast
    to multiple consumers; if, for example, my wife is at home, she can also go to
    open the door. From an event-sender side, we also have multiple options: if I''m
    outside somebody''s house, I can decide to ring the doorbell, but if I don''t
    get a reaction, I can check whether there are other ways to trigger the signal;
    I can, for example, just knock. The following diagram shows the flow of events
    described:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Events](graphics/B03704_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This little example shows the very power of modeling a system via small components
    communicating via events. Each component can decide how to respond to an event
    considering its current load or even other events being triggered at the same
    time. Priorities can be implemented by reordering the events either on the sender
    side or on the consumer side to ensure the best responsiveness for the system
    in regards to the agreed-upon service level agreements.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript offers this kind of eventing at its core, and NodeJS''s `EventEmitter`
    is a nice abstraction over the core idea, leading to very clear code, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `EventEmitter` function allows us to add to the functionality commonly known
    from interacting with the document object model in JavaScript to any object we
    need. In the preceding code, we use the `inherits` helper to make our `House`
    be an `EventEmitter`. With this in place, we can act on events and dispatch them
    as seen. We can define events we want other objects to be able to react to, like
    we would react to clicks or hover events.
  prefs: []
  type: TYPE_NORMAL
- en: Event stores versus entity relational mapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on what our system is supposed to achieve, it can be important to
    save events. In the case of our doorbell example where I am in the shower, we
    might have the problem that I can not hear the event as well as my decision to
    not respond to it. Depending on the reason the person triggering the event had,
    this can either be acceptable or not.
  prefs: []
  type: TYPE_NORMAL
- en: If it were the postman trying to drop off a package and they don't want to wait,
    they can have a short timeout to await a response and if they don't get one, they
    can queue the package delivery again on their side, get back in the van, and try
    again tomorrow. In other circumstances when we want the system delivering the
    event to handle this scenario for us, this is also common, for example, when I
    miss a call, I will get an SMS with the call details, or a voicemail saving the
    event details for me and when I'm ready to handle it I can do so.
  prefs: []
  type: TYPE_NORMAL
- en: In many software systems, we want the event delivery system to abstract away
    as many things as possible. Going all the way to the extreme, it is even possible
    to construct the system purely by storing the events and never actually modifying
    any data, but just generating new events to again be stored. All the system needs
    to know at this point is at which point in time a consumer is in regards to the
    event stream, and it can then replay whatever is needed, obviating the need to
    store modifiable data by mapping entities to a database. The only entity in this
    scenario is the pointer into the event log for each consumer. This is not something
    that is easy to implement as it raises problems due to the only eventually consistent
    nature of such a system. After all, it takes time to send events between systems,
    but it might be worth it for a reasonably complex system to tackle.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A very good example of such a system is **Kafka**, and it is a whole ecosystem
    for modeling, consuming, event creation, and storage, but there are other examples
    for this as well. Martin Kleppman has written about, and presented on this, at
    various occasions, for example, at Spanconf 2014: [https://www.youtube.com/watch?v=b_H4FFE3wP0](https://www.youtube.com/watch?v=b_H4FFE3wP0).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a system like this is probably not the simplest or the first choice
    when developing a business application as the requirements for the infrastructure
    to support it are quite high. The more the application has to deal with high availability
    and the more the system starts to be distributed for whatever reason, the more
    reasonable such a system becomes. JavaScript as a language is very well suited
    to event handling, as it is at the core of the domain the language was build for—reacting
    to user events in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this chapter, there have been a lot of things introduced that are
    not the primary focus but still added a great deal of understanding to the evolvement
    of domain-driven design. Being inspired by workarounds can really improve the
    general software development practices so there is further reading I would recommend.
    To further understand object orientation, and especially to find design patterns
    to use, I recommend the book called *Gang of four*, and *Design Patterns : Elements
    of Reusable Object-Oriented Software*, *Erich Gamma*, *Richard Helm*, *Ralph Johnson*,
    *John Vlissides*, *Pearson Publishing.* Even though the book is old, it still
    represents classic work on object orientation, and establishes a lot of terminology.
    Also *Smalltalk Best Practice Patterns*, *Kent Becks*, *Prentice Hall*, really
    embraces Object-Oriented design, and even though both books are naturally not
    focused on JavaScript, they can still be very helpful in advancing your design
    skills.'
  prefs: []
  type: TYPE_NORMAL
- en: At the other end of the chapter, we went into some detail on how to get started
    on modeling a flow of events, which is currently a very hot topic. Martin Kleppmann
    has been doing a lot of work around this area, so following his work closely will
    bring you some good insights into how to model growing applications ([https://martin.kleppmann.com/](https://martin.kleppmann.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: There is obviously a lot more to follow up on, but getting started with the
    mentioned work will naturally lead to a lot more, probably more than is digestible
    in a short amount of time, so I recommend you go and follow this up and follow
    it down the rabbit hole.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the various ways domain-driven design is influenced
    and can be augmented by related software development patterns. Some patterns are
    closer than others, such as DSLs, and some are more orthogonal such as modeling
    the system as a series of events.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing is to make sure we don't get stuck in trying to only apply
    the techniques we see in a specific pattern, but look at what is around to make
    sure we use the right tool for the job. At its core, domain-driven design is about
    modeling business software, and while most business software follows similar patterns
    and rules, some internal details might be very well-suited for a functional core
    integrated in the software as a whole, or even the development of a DSL that allows
    not-so-technical business experts to express their rules clearly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to sum up all the details we came across and
    are going to think about how to work on an ever-changing product like most business
    software is.
  prefs: []
  type: TYPE_NORMAL
