- en: Testing and Improving Our Vehicle Control Solution in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will use our vehicle control solution with MQTT messages
    and Python code. We will learn how to process commands received in MQTT messages
    with Python code. We will write Python code to compose and send MQTT messages
    with commands. We will work with the blocking and threaded network loops and we
    will understand their difference. Finally, we will take advantage of the last
    will and testament feature. We will take an in-depth look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Processing commands with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending messages with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the network loop with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with last will and testament with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with retained last will messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding blocking and non-blocking code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the threaded client interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing commands with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 4](87908cb8-83ed-4b74-bfc5-dd0c4ddd93aa.xhtml), *Writing Code to
    Control a Vehicle with Python and MQTT Messages*, we coded a solution that was
    capable of processing commands for a vehicle received as MQTT messages with Python
    code. Now, we want to make a vehicle process many commands to check how all the
    pieces work together. We want to execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the Mosquitto server, or any other MQTT server you might want to use
    for this example, is running.
  prefs: []
  type: TYPE_NORMAL
- en: Launch MQTT.fx and follow all the steps explained in [Chapter 4](https://cdp.packtpub.com/hands_on_mqtt_programming_with_python/wp-admin/post.php?post=129&action=edit#post_107), *Writing
    Code to Control a Vehicle with Python and MQTT Messages*, to configure a connection
    with TLS and TLS authentication, if you didn't establish a previous secure connection
    to the MQTT server with MQTT.fx. Then, click on the Connect button.
  prefs: []
  type: TYPE_NORMAL
- en: Click Subscribe and enter `vehicles/vehiclepi01/executedcommands` in the drop-down
    menu on the left-hand side of the Subscribe button. Then, click the Subscribe
    button. MQTT.fx will display a new panel on the left-hand side with the topic
    filter to which we have subscribed with QoS level 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, execute the following line to start the vehicle controller example in
    any computer or device that you want to use as the MQTT client that uses Linux
    or macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, you must execute the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Keep the code running on your local computer or on the IoT board you have chosen
    to use as the vehicle controller for this example.
  prefs: []
  type: TYPE_NORMAL
- en: In MQTT.fx, click Publish and enter `vehicles/vehiclepi01/commands` in the drop-down
    menu on the left-hand side of the Publish button. Click QoS 2 because we want
    to use QoS level 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following text in the textbox below the Publish button: `{"CMD":
    "LOCK_DOORS"}`'
  prefs: []
  type: TYPE_NORMAL
- en: Then, click the Publish button. MQTT.fx will publish the entered text to the
    specified topic with QoS level 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the window in which you can see the output generated by the Python code
    that receives the messages and controls the vehicle. If you are running the code
    on an IoT board, you might be using an SSH terminal or a screen connected to the
    IoT board. If you are running the code on your local computer, go to Terminal
    or Command Prompt, based on the operating system you are using. You will see the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The code has received the message with the command, the `Vehicle` instance executed
    the `lock_doors` method, and the output displays the results of executing this
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to MQTT.fx, click Subscribe and you will see a new message has arrived
    in the `vehicles/vehiclepi01/executedcommands` topic with the following payload:
    `{"SUCCESSFULLY_PROCESSED_COMMAND": "LOCK_DOORS"}`. The following screenshot shows
    the received message in MQTT.fx:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ca44b769-efda-4736-b925-9e45b6ca3c91.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, repeat the following procedure for each of the commands included in the
    previously shown list. We want our vehicle control application to process each
    of those commands received in MQTT messages with QoS level 2\. Remove the existing
    text and enter the text for the JSON string in the textbox under the Publish button
    and then click the Publish button. MQTT.fx will publish the entered text to the
    specified topic with QoS level 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to the window in which you can see the output generated by the Python code
    that receives the messages and controls the vehicle. You will see the following
    output that indicates that all the commands have been received and processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Go back to MQTT.fx, click Subscribe, and you will see a total of 12 messages
    that have arrived in the `vehicles/vehiclepi01/executedcommands` topic. You can
    easily check the contents of the payload for each of the received messages by
    clicking on the panel that represents each of them on the right-hand side of the
    window. The following screenshot shows the last received message in MQTT.fx:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/92978bdf-384b-4340-b6d1-c49b8db655f5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will use the Mosquitto command-line utilities to subscribe to the `vehicles/vehiclepi01/executedcommands`
    topic and publish many MQTT messages with the JSON strings with the commands to
    the `vehicles/vehiclepi01/commands` topic. This time, we will publish the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Open another Terminal in macOS or Linux, or another Command Prompt in Windows,
    go to the directory in which Mosquitto is installed, and run the following command.
    Replace `192.168.1.1` with the IP or hostname for the MQTT server. Remember to
    replace `ca.crt`, `board001.crt`, and `board001.key` with the full path to these
    files, created in the `board_certificates` directory. Leave the window opened
    and the utility will display all the messages received in the `vehicles/vehiclepi01/executedcommands`
    topic. The code file for the sample is included in the `mqtt_python_gaston_hillar_05_01`
    folder, in the `script_01.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Open another Terminal in macOS or Linux, or another Command Prompt in Windows,
    go to the directory in which Mosquitto is installed, and run the following commands
    to publish messages with commands to the `vehicles/vehiclepi01/commands` topic
    with QoS level 2\. Make the same replacements previously explained for the `mosquitto_sub`
    command. The code file for the sample is included in the `mqtt_python_gaston_hillar_05_01`
    folder, in the `script_02.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After you run the previous commands, the `VehicleCommandProcessor` class will
    receive these commands and process them. After a few seconds, you will see the
    following output in the window that is executing the `mosquitto_sub` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that the MQTT.fx utility will also receive the messages because it stayed
    subscribed to the `vehicles/vehiclepi01/executedcommands` topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the window in which you can see the output generated by the Python code
    that receives the messages and controls the vehicle. You will see the following
    output, which indicates that all the commands have been received and processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Sending messages with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been publishing MQTT messages to control the vehicle with GUI
    and command-line tools. Now, we will write code in Python to publish the commands
    to control each vehicle and check the results of the execution of these commands.
    Of course, GUI utilities, such as MQTT.fx and the Mosquitto command-line utilities,
    are extremely useful. However, after we know that things are working as we expect,
    we can write the necessary code to perform tests in the same programming language
    we are using to run the code on the IoT board.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are going to code a Python client that will publish messages to the
    `vehicles/vehiclepi01/commands` topic and will subscribe to the `vehicles/vehiclepi01/executedcommands`
    topic. We will code both a publisher and a subscriber. This way, we will be able
    to design applications that can talk to IoT devices with MQTT messages, with Python
    as the programming language for the client applications. Specifically, the applications
    will be able to communicate through an MQTT server with Python code in all the
    publisher and subscriber devices.
  prefs: []
  type: TYPE_NORMAL
- en: We can run the Python client on any other computer or IoT board that is capable
    of executing Python 3.x.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](87908cb8-83ed-4b74-bfc5-dd0c4ddd93aa.xhtml), *Writing Code to
    Control a Vehicle with Python and MQTT Messages*, we created a Python file named
    `config.py` in the main virtual environment folder. In this file, we defined many
    configuration values that were used to establish a connection with the Mosquitto
    MQTT server. This way, all the configuration values were included in a specific
    Python script. If you need to make changes to this file to configure the application
    that will compose and send commands in MQTT messages to control the vehicle, make
    sure you review the explanations included in [Chapter 4](87908cb8-83ed-4b74-bfc5-dd0c4ddd93aa.xhtml), *Writing
    Code to Control a Vehicle with Python and MQTT Messages.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create a new Python file named `vehicle_mqtt_remote_control.py`
    in the main virtual environment folder. We will create many functions that we
    will assign as the callbacks to the events in the MQTT client. In addition, we
    will declare variables, a helper class, and a helper function to make it easy
    to publish a message with a command and the required values for the command. The
    following lines show the code that defines the variables, the helper class, and
    the functions. The code file for the sample is included in the `mqtt_python_gaston_hillar_05_01`
    folder, in the `vehicle_mqtt_remote_control.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first line imports the variables we have declared in our well-known `config.py`
    file. The code declares the `vehicle_name` variable that saves a string with `"vehiclepi01"`
    and that we can easily replace with the name of the vehicle that we want to control.
    Our main goal is to build and publish command messages to the topic specified
    in the `commands_topic` variable. We will subscribe to the topic specified in
    the `processed_commands_topic` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `LoopControl` class declares a class attribute named `is_last_command_processed`
    initialized to `False`. We will use this class attribute as a flag to control
    the network loop.
  prefs: []
  type: TYPE_NORMAL
- en: The `on_connect` function is the callback that will be executed once a successful
    connection has been established with the MQTT server. The code checks the value
    of the `rc` argument that provides the `CONNACK` code returned by the MQTT server.
    If this value matches `mqtt.CONNACK_ACCEPTED`, it means that the MQTT server accepted
    the connection request, and therefore, the code calls the `client.subscribe` method
    for the MQTT client received in the `client` argument to subscribe to the topic
    name saved in the `processed_commands_topic` with a QoS level of 0.
  prefs: []
  type: TYPE_NORMAL
- en: The `on_message` function will be executed each time a new message arrives to
    the topic to which we have subscribed. The function just prints the raw string
    with the payload of the received message. If the payload includes the string saved
    in the `CMD_TURN_OFF_ENGINE` constant, we assume the last command was successfully
    executed and the code sets the `LoopControl.is_last_command_processed` to `True`.
    This way, we will control the network loop based on the feedback provided by the
    vehicle with MQTT messages that indicate the processed commands.
  prefs: []
  type: TYPE_NORMAL
- en: The `on_subscribe` function will be called when the subscription has been successfully
    completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next table summarizes the functions that will be called based on the received
    responses from the MQTT server:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Response from the MQTT server** | **Function that will be called** |'
  prefs: []
  type: TYPE_TB
- en: '| `CONNACK` | `on_connnect` |'
  prefs: []
  type: TYPE_TB
- en: '| `SUBACK` | `on_subscribe` |'
  prefs: []
  type: TYPE_TB
- en: '| `PUBLISH` | `on_message` |'
  prefs: []
  type: TYPE_TB
- en: The `build_command_message` function receives the command name, the key, and
    the value that provide the necessary information to build the string with the
    JSON key-value pairs that compose a command in the `command_name`, `key`, and
    `value` arguments. Note that the last two arguments are optional and their default
    value is an empty string. The function creates a dictionary and saves the results
    of serializing the dictionary to a JSON-formatted string in the `command_message`
    local variable. The `COMMAND_KEY` constant is the first key for the dictionary
    and the `command_name` received as an argument, the value that composes the first
    key-value pair. Finally, the function returns the `command_message` string.
  prefs: []
  type: TYPE_NORMAL
- en: The `publish_command` function receives the MQTT client, the command name, the
    key, and the value that provide the necessary information to execute the command
    in the `client`, `command_name`, `key`, and `value` arguments. As in the `build_command_message`
    function, the key and value arguments are optional and their default value is
    an empty string. The function calls the previously explained `build_command_message`
    function with the `command_name`, `key`, and `value` arguments it received and
    saves the result in the `command_message` local variable. Then, the code calls
    the `client.publish` method to publish the `command_message` JSON-formatted string
    to the topic name saved in the `commands_topic` variable with a QoS level of 2.
  prefs: []
  type: TYPE_NORMAL
- en: The next line calls the `client.loop` method to ensure communication with the
    MQTT server is carried out and sleeps for one second. This way, the message will
    be published and the application will wait one second.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the network loop with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will use the previously coded `functions` in a `__main__` method that
    will publish many commands included in the MQTT messages that the code that controls
    the vehicle will process. You have to add the next lines to the existing `vehicle_mqtt_remote_control.py`
    Python file. The following lines show the code for the `__main__` method, that
    is, the main block of code. The code file for the sample is included in the `mqtt_python_gaston_hillar_05_01`
    folder, in the `vehicle_mqtt_remote_control.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first lines of code are similar to the first Python example we coded. After
    calling the `client.connect` method, the code calls the `publish_command` command
    many times to build and publish the messages with the commands.
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop calls the `client.loop` method to ensure communication with
    the MQTT server is carried out and sleeps for 500 milliseconds, that is, 0.5 seconds.
    After the last command is processed, the `LoopControl.is_last_command_processed`
    class variable is set to `True` and the while loop ends its execution. When this
    happens, the code calls the `client.disconnect` method and finally the `client.loop`
    method to make sure that the disconnect request is processed.
  prefs: []
  type: TYPE_NORMAL
- en: If we don't call the `client.loop` method after calling `client.disconnect`,
    the program can finish its execution without sending the request to disconnect
    to the MQTT server. In the next sections, we will work with the last will and
    testament feature and we will note that the ways in which a client is disconnected
    have an important impact on the usage of this feature.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we don't want the loop to run forever because we have a specific
    goal of composing and sending a set of commands. Once we are sure that the last
    command has been processed, we close the connection with the MQTT server.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the code that controls `vehiclepi01` is running, that is, the
    `vehicle_mqtt_client.py` Python script that we coded in [Chapter 4](87908cb8-83ed-4b74-bfc5-dd0c4ddd93aa.xhtml), *Writing
    Code to Control a Vehicle with Python and MQTT Messages*, is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, execute the following line to start the vehicle remote control example
    on any computer or device that you want to use as the MQTT client and uses Linux
    or macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, you must execute the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Keep the code running on your local computer or on the IoT board you have chosen
    to use as the vehicle remote control for this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the device and window in which you executed the previous Python script,
    named `vehicle_mqtt_remote_control.py`. You will see the following output. The
    Python code will show all the messages received in the `vehicles/vehiclepi01/executedcommands`
    topic. The program will end its execution after the vehicle indicates that it
    has successfully processed the `TURN_OFF_ENGINE` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to the device and window in which you executed the Python script that controlled
    the vehicle and processed the received commands, that is, `vehicle_mqtt_client.py`.
    You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows two Terminal windows running on a computer with
    macOS. The Terminal on the left-hand side is displaying the messages shown by
    the Python client that publishes commands and works as the remote control for
    the vehicle, that is, the `vehicle_mqtt_remote_control.py` script. The Terminal
    on the right-hand side is displaying the results of running the code for the Python
    client that controls the vehicle and processes the received commands, that is,
    the `vehicle_mqtt_client.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7335cf47-4c8d-487d-bca1-88ece1b7c706.png)'
  prefs: []
  type: TYPE_IMG
- en: Working with last will and testament with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will check what happens if the MQTT client that represents our vehicle
    remote control application disconnects unexpectedly from the MQTT server with
    the code we have written so far. Pay attention to all the steps because we will
    manually interrupt the execution of the vehicle remote control program to understand
    a specific problem that we will solve by taking advantage of the last will and
    testament feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following line to start the vehicle remote control example on any
    computer or device that you want to use as the MQTT client and uses Linux or macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, you must execute the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to the device and window on which you executed the previous Python script,
    named `vehicle_mqtt_remote_control.py`. After you see the following output, press
    *Ctrl* + *C* to interrupt the execution of the script before all the commands
    are processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After you press *Ctrl* + *C*, you will see an output with a traceback similar
    to the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We interrupted the connection between the MQTT client that works as a remote
    control for the vehicle and the MQTT server. We didn't wait for all the commands
    to be published and we disconnected the MQTT client unexpectedly from the MQTT
    server. The vehicle doesn't know that the remote control application has been
    interrupted.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we used a keyboard shortcut to interrupt the execution of the
    Python program. However, a network failure might be another cause for an unexpected
    disconnection of the MQTT client from the MQTT server.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we don't want a network failure to leave our vehicle without control,
    and therefore, we want to make sure that the vehicle parks in a safe place if
    the remote control application loses connection with the MQTT server. In this
    case, we want to make sure the vehicle receives a message with the command that
    indicates to the vehicle that it must park in a safe place that is configured
    for the vehicle.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](d20ae00b-2bb7-4d81-b3eb-5c47215bce1f.xhtml)*, Installing an MQTT
    3.1.1 Mosquitto Server*, we analyzed the fields and flags that compose the payload
    of the `CONNECT` control packet that an MQTT client sends to an MQTT server to
    establish a connection. Now, we will use the appropriate method provided in `paho-mqtt`
    to configure the values for the `Will`, `WillQoS`, `WillRetain`, `WillTopic`,
    and `WillMessage` flags and fields that will allow our MQTT client to take advantage
    of the last will and testament feature of MQTT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the existing `vehicle_mqtt_remote_control.py` Python file and replace
    the lines that define the `__main__` method with the following code to configure
    the last will message that we want the MQTT server to send to the vehicle if an
    unexpected disconnection occurs. The added lines are highlighted. The code file
    for the sample is included in the `mqtt_python_gaston_hillar_05_02` folder, in
    the `vehicle_mqtt_remote_control.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We added two lines of code before the code calls the `client.connect` method,
    that is, before we send a connection request to the MQTT server. The first line
    calls the `build_command_message` function with `CMD_PARK_IN_SAFE_PLACE` as an
    argument to build the JSON string with the command that makes the vehicle park
    in a safe place, and stores it in the `last_will_payload` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code calls the `client.will_set` method that allows us to configure
    the desired values for the `Will`,  `WillQoS`, `WillRetain`, `WillTopic`, and
    `WillMessage` flags and fields that will be used in the CONNECT control packet.
    The code calls this method with `commands_topic`, `last_will_payload`, and `2` 
    as the values for the topic, `payload`, and `qos` arguments. As we don't specify
    a value for the `retain` argument, the method will use its default value, `False`,
    which specifies that the last will message is not going to be a retained message.
    This way, when the next line of code calls the `client.connect` method to request
    the MQTT client to establish a connection to the MQTT server, the `CONNECT` control
    packet will include the appropriate values for the fields and flags to configure
    a last will message with QoS level 2, `commands_topic` as the topic in which the
    message will be published, and `last_will_payload` as the payload for the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, execute the following line to start the vehicle remote control example
    on any computer or device that you want to use as the MQTT client and uses Linux
    or macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, you must execute the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to the device and window in which you executed the previous Python script,
    named `vehicle_mqtt_remote_control.py`. After you see the following output, press
    *Ctrl* + *C* to interrupt the execution of the script before all the commands
    are processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After you press *Ctrl* + *C*, you will see an output with a traceback similar
    to the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We interrupted the connection between the MQTT client that works as a remote
    control for the vehicle and the MQTT server. We didn't wait for all the commands
    to be published and we disconnected the MQTT client unexpectedly from the MQTT
    server. Thus, the MQTT server publishes the configured last will message that
    the MQTT client, which works as a remote control for the vehicle, has configured
    when it established a connection with the MQTT server. This way, the vehicle receives
    a command to park in a safe place when the connection between the remote control
    application and the MQTT server is lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the device and window in which you executed the Python script that controlled
    the vehicle and processed the received commands, that is, `vehicle_mqtt_client.py`.
    You will see an output similar to the following lines. Note that the last received
    message instructs the vehicle to park in a safe place. This last received message
    is the last will message we configured with the added lines of code in the Python
    script named `vehicle_mqtt_remote_control.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows two Terminal windows running on a computer with
    macOS. The Terminal on the left-hand side is displaying the messages shown by
    the Python client that publishes commands and works as the remote control for
    the vehicle, that is, the `vehicle_mqtt_remote_control.py` script. The Terminal
    on the right-hand side is displaying the results of running the code for the Python
    client that controls the vehicle and processes the received commands, that is,
    the `vehicle_mqtt_client.py` script. The interruption of the connection generated
    the MQTT server to publish the configured last will message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/05a40b9f-167a-48f5-829b-fcbca43e357a.png)You can take advantage
    of the last will and testament feature to indicate to interested clients that
    a specific board, device, or sensor is offline.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, execute the following line to start the vehicle remote control example
    on any computer or device that you want to use as the MQTT client and uses Linux
    or macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, you must execute the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Go to the device and window in which you executed the previous Python script,
    named `vehicle_mqtt_remote_control.py`.
  prefs: []
  type: TYPE_NORMAL
- en: This time, keep the code running on your local computer or on the IoT board
    you have chosen to use as the vehicle remote control for this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the device and window in which you executed the Python script that controlled
    the vehicle and processed the received commands, that is, `vehicle_mqtt_client.py`.
    You will see the following last lines in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the code called the `client.disconnect` method and then the `client.loop`
    method. The MQTT client disconnected from the MQTT server in a normal way, and
    therefore, the last will message with the command to park the vehicle in a safe
    place wasn't published.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to understand that the configured last will message isn't
    published when the MQTT client disconnects from the MQTT by calling the `client.disconnect`
    method and making sure that the network events are processed. If we want to publish
    a message before a normal disconnection performed with the `client.disconnect`
    method, we must write the necessary code to do so before calling this method.
    In addition, we have to make sure that the network events are processed.
  prefs: []
  type: TYPE_NORMAL
- en: Working with retained last will messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will check what happens when the MQTT client that controls the vehicle
    disconnects unexpectedly from the MQTT server and our vehicle remote control application
    disconnects unexpectedly, too. Pay attention to all the steps because we will
    manually interrupt the execution of both programs to understand a specific problem
    that we will solve by taking advantage of the last will and testament feature
    combined with the retained flag value.
  prefs: []
  type: TYPE_NORMAL
- en: You will have to be quick to run the next steps. Hence, make sure you read all
    the steps and then execute them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following line to start the vehicle remote control example on any
    computer or device that you want to use as the MQTT client and uses Linux or macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, you must execute the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to the device and window in which you executed the Python script that controlled
    the vehicle and processed the received commands, that is, `vehicle_mqtt_client.py`.
    After you see the following output, press *Ctrl* + *C* to interrupt the execution
    of the script before all the commands are received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After you press *Ctrl* + *C*, you will see an output with a traceback similar
    to the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We interrupted the connection between the MQTT client that controls the vehicle
    and processes the received commands and the MQTT server. We didn't wait for all
    the commands to be received and we disconnected the MQTT client unexpectedly from
    the MQTT server. The vehicle remote control application doesn't know that the
    remote control application has been interrupted and it waits until the last command
    it sent is processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the device and window in which you executed the previous Python script,
    named `vehicle_mqtt_remote_control.py`. Press *Ctrl* + *C*  to interrupt the execution
    of the script. After you press *Ctrl* + *C*, you will see an output with a traceback
    similar to the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Go back to the device and window in which you executed the Python script that
    controlled the vehicle and processed the received commands, that is, `vehicle_mqtt_client.py`.
    Execute the following line to start this script again on any computer or device
    that you want to use as the MQTT client and uses Linux or macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, you must execute the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait a few seconds and you will only see the following output that indicates
    the connection to the MQTT server has been accepted. No commands have been received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows two Terminal windows running on a computer with
    macOS. The Terminal on the left-hand side is displaying the messages shown by
    the Python client that publishes commands and works as the remote control for
    the vehicle, that is, the `vehicle_mqtt_remote_control.py` script. The Terminal
    on the right-hand side is displaying the results of running the code for the Python
    client that controls the vehicle and processes the received commands, that is,
    the `vehicle_mqtt_client.py` script after the previously explained interruptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f4771d68-6c0b-4a1d-a201-b17583b5f3a5.png)'
  prefs: []
  type: TYPE_IMG
- en: When we started the `vehicle_mqtt_client.py` script, the code generated a new
    MQTT client and established a connection with the MQTT server and subscribed to `vehicles/vehiclepi01/commands`.
    The last will message published to this topic when we interrupted the execution
    of the `vehicle_mqtt_remote_control.py` script had been published with the `Retained`
    flag set to `False`, therefore, the message wasn't retained by the MQTT server
    and any new subscription to a topic filter that matches the topic to which the
    retained last will message has been sent doesn't receive it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the existing `vehicle_mqtt_remote_control.py` Python file and replace
    the lines that call the `client.will_set` method within the `__main__` method
    with the following code. The code file for the sample is included in the `mqtt_python_gaston_hillar_05_03`
    folder, in the `vehicle_mqtt_remote_control.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We specified the `True` value for the `retain` argument that, in the previous
    version of the code, used the default `False` value. This way, the last will message
    is going to be a retained message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following line to start the vehicle remote control example on any
    computer or device that you want to use as the MQTT client and uses Linux or macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, you must execute the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to the device and window in which you executed the Python script that controlled
    the vehicle and processed the received commands, that is, `vehicle_mqtt_client.py`.
    After you see the following output, press *Ctrl* + *C* to interrupt the execution
    of the script before all the commands are received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'After you press *Ctrl* + *C*, you will see an output with a traceback similar
    to the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We interrupted the connection between the MQTT client that controls the vehicle
    and processes the received commands and the MQTT server. We didn't wait for all
    the commands to be received and we disconnected the MQTT client unexpectedly from
    the MQTT server. The vehicle remote control application doesn't know that the
    remote control application has been interrupted and it waits until the last command
    it sent is processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the device and window in which you executed the previous Python script,
    named `vehicle_mqtt_remote_control.py`. Press *Ctrl* + *C* to interrupt the execution
    of the script. After you press *Ctrl* + *C*, you will see an output with a traceback
    similar to the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Go back to the device and window in which you executed the Python script that
    controlled the vehicle and processed the received commands, that is, `vehicle_mqtt_client.py`.
    Execute the following line to start this script again on any computer or device
    that you want to use as the MQTT client and uses Linux or macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, you must execute the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait a few seconds and you will only see the output which indicates the connection
    to the MQTT server has been accepted, and a message, which indicates the retained
    last will message that instructs the vehicle to park in a safe place has been
    received and processed. Hence, the vehicle will be parked in a safe place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows two Terminal windows running on a computer with
    macOS. The Terminal on the left-hand side is displaying the messages shown by
    the Python client that publishes commands and works as the remote control for
    the vehicle, that is, the `vehicle_mqtt_remote_control.py` script. The Terminal
    on the right-hand side is displaying the results of running the code for the Python
    client that controls the vehicle and processes the received commands, that is,
    the `vehicle_mqtt_client.py` script after the previously explained interruptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ae4b5d8c-cdd0-41f9-8101-75804c384227.png)'
  prefs: []
  type: TYPE_IMG
- en: With the new code, when we started the `vehicle_mqtt_client.py` script, the
    code generated a new MQTT client, established a connection with the MQTT server,
    and subscribed to the `vehicles/vehiclepi01/commands`. The last will message published
    to this topic when we interrupted the execution of the `vehicle_mqtt_remote_control.py`
    script had been published with the `Retained` flag set to `True`, and therefore,
    the message was retained by the MQTT server and any new subscription to a topic
    filter that matches the topic to which the retained last will message has been
    sent receives it. The retained last will message allows us to make sure that the
    message arrives as the first message when a new connection to the MQTT server
    subscribes to a matching topic.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we always want to make sure that the vehicle receives the last
    will message if the MQTT client created in the `vehicle_mqtt_client.py` script
    loses the connection with the MQTT server and then establishes a new connection.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding blocking and non-blocking code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been working with blocking calls that processed MQTT-related
    network traffic and dispatched callbacks. Whenever we called the `client.loop`
    method in the previous examples, the method used the default values for the two
    optional arguments: `1` for `timeout` and `1` for `max_packets`. The method blocks
    for up to one second, that is, the value of the `timeout` argument, to handle
    incoming or outgoing data. The method runs with a synchronous execution, and therefore,
    the next line of code won''t be executed until this method returns. We called
    the `client.loop` method in the main thread, and therefore, no other code can
    be executed in this thread while the `client.loop` method is blocking.'
  prefs: []
  type: TYPE_NORMAL
- en: In our first example with Python code that created an MQTT client, we called
    the `client.loop_forever` method. This method blocks until the client calls the
    `disconnect` method. The method runs with a synchronous execution, and therefore,
    the next line of code won't be executed until the client calls the `disconnect`
    method. We also called the `client.loop_forever` in the main thread, and therefore,
    no other code can be executed in this thread while the `client.loop_forever` method
    is blocking.
  prefs: []
  type: TYPE_NORMAL
- en: One important difference between the loop method and the `loop_forever` method
    is that it is necessary to handle reconnections manually when we work with the
    loop method. The `loop_forever` method automatically handles reconnections to
    the MQTT server.
  prefs: []
  type: TYPE_NORMAL
- en: The `paho-mqtt` library provides us with a threaded client interface for the
    network loop that launches another thread that automatically calls the `loop`
    method. This way, it is possible to free up the main thread to run other code.
    The threaded interface is non-blocking and we don't have to worry about repeatedly
    calling the `loop` method. In addition, the threaded interface automatically handles
    reconnections to the MQTT server.
  prefs: []
  type: TYPE_NORMAL
- en: Using the threaded client interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will write a new version of the vehicle remote control application
    to use the threaded interface, also known as the threaded loop. Open the existing
    `vehicle_mqtt_remote_control.py` Python file and replace the lines that define
    the `publish_command` function with the following lines. The code file for the
    sample is included in the `mqtt_python_gaston_hillar_05_04` folder, in the `vehicle_mqtt_remote_control.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We removed the following line before the call to `time.sleep(1)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The threaded loop will automatically call `client.loop` in another thread, and
    therefore, we don't need to include a call to `client.loop` within the `publish_command`
    method anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the existing `vehicle_mqtt_remote_control.py` Python file and replace
    the lines that define the `__main__` method with the following code to use the
    threaded loop. The added lines are highlighted. The code file for the sample is
    included in the `mqtt_python_gaston_hillar_05_04` folder, in the `vehicle_mqtt_remote_control.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: After calling the `client.connect` method, the code calls the `client.loop_start`
    method. This method starts a new thread that processes the MQTT network traffic
    and frees up the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the calls to the edited `publish_command` function do not call `client.loop`
    anymore because the threaded client interface that we started with `client.loop_start`
    will automatically call the loop to process outgoing messages.
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop that checks whether the last command has been processed or
    not every 500 milliseconds doesn't call `client.loop` anymore. Now, there is another
    thread that is calling `client.loop` for us.
  prefs: []
  type: TYPE_NORMAL
- en: When the last command is processed, the code calls the `client.disconnect` method
    and finally calls the `client.loop_stop` method to stop the thread that is running
    the threaded client interface. This method will return when the thread is finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following line to start the new version of the vehicle remote control
    example on any computer or device that you want to use as the MQTT client and
    uses Linux or macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, you must execute the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: You will note that the timing between the send commands and the processed commands
    is clearer because the time at which the network events are processed is more
    accurate in the new version.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see whether you can answer the following questions correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following methods of the `paho.mqtt.client.Client` instance blocks
    execution and ensures communication with the MQTT server is carried out?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`loop`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`loop_start`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`blocking_loop`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following methods of the `paho.mqtt.client.Client` instance starts
    a new thread and ensures communication with the MQTT server is carried out?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`loop`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`loop_start`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`non_blocking_loop`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following methods of the `paho.mqtt.client.Client` instance configures
    a last will message to be sent to the MQTT server if the client disconnects unexpectedly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`last_will_publish`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`last_will_message`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`will_set`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following methods of the `paho.mqtt.client.Client` instance stops
    the thread that is running the threaded client interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`loop_end`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`non_blocking_loop_stop`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`loop_stop`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following methods is non-blocking?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`loop_start`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`non_blocking_loop`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`loop_forever`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The right answers are included in the [Appendix](d9cf708f-f027-4bfa-a2d2-9fd3653165d9.xhtml), *Solutions*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we processed commands received as JSON strings within MQTT
    messages with Python code. Then, we coded a Python client that composed and published
    messages with commands to work as a remote control application for the vehicle
    controller.
  prefs: []
  type: TYPE_NORMAL
- en: We worked with the blocking network loop and then we converted the application
    to use the threaded client interface to avoid blocking the main thread. We took
    advantage of the last will and testament feature to make sure a controlled vehicle
    parks in a safe place whenever a connection is lost. Then, we worked with retained
    last will messages.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how to use Python to work with multiple MQTT applications
    that take advantage of advanced features, we will use a cloud-based real-time
    MQTT provider to monitor a surfing completion in which we will need to receive
    and process data from multiple sensors, which is what we are going to discuss
    in [Chapter 6](dc244927-5db3-4108-a486-fa7f17f5f3ba.xhtml), *Monitoring a surfing
    competition with cloud-based real-time MQTT providers and Python*.
  prefs: []
  type: TYPE_NORMAL
