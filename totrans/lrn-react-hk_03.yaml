- en: Using the State Hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you've learned about the principles of React and had an introduction
    to Hooks, we are going to learn about the State Hook in depth. We will start by
    learning how the State Hook works internally by reimplementing it ourselves. Next,
    we learn about some of the limitations of Hooks, and why they exist. Then, we
    will learn about possible alternative Hook APIs and their associated problems.
    Finally, we learn how to solve the common problems that result from the limitations
    of Hooks. By the end of this chapter, we will know how to use the State Hook in
    order to implement stateful function components in React.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Reimplementing the `useState` Hook as a simple function, which accesses the
    global state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing our reimplementation to real React Hooks and learning about the differences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about possible alternative Hook APIs and their trade-offs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving common problems resulting from the limitations of Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving problems with conditional Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A fairly recent version of Node.js should already be installed (v11.12.0 or
    higher). The `npm` package manager for Node.js also needs to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter can be found in the GitHub repository: [https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter02](https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2Mm9yoC](http://bit.ly/2Mm9yoC)'
  prefs: []
  type: TYPE_NORMAL
- en: Please note that it is highly recommended that you write the code on your own.
    Do not simply run the code examples that have been previously provided. It is
    important that you write the code yourself so that you learn and understand it
    properly. However, if you run into any issues, you can always refer to the code
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's get started with the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Reimplementing the useState function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to get a better understanding of how Hooks work internally, we are
    going to reimplement the `useState` Hook from scratch. However, we are not going
    to implement it as an actual React Hook, but as a simple JavaScript function—just
    to get an idea of what Hooks are actually doing.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that this reimplementation is not exactly how React Hooks work internally.
    The actual implementation is similar, and thus, it has similar constraints. However,
    the real implementation is much more complicated than what we will be implementing
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to start reimplementing the State Hook:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we copy the code from `chapter1_2`, where we are going to replace the
    current `useState` Hook with our own implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `src/App.js` and remove the import of the Hook by removing the following
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with these lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We are going to need `ReactDOM` in order to force rerendering of the component
    in our reimplementation of the `useState` Hook. If we used actual React Hooks,
    this would be dealt with internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we define our own `useState` function. As we already know, the `useState`
    function takes the `initialState` as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define a value, where we will store our state. At first, this value
    will be set to `initialState`, which is passed as an argument to the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the `setState` function, where we will set the value to something
    different, and force the rerendering of our `MyName` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we return the `value` and the `setState` function as an array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason why we use an array, and not an object, is that we usually want
    to rename the `value` and `setState` variables. Using an array makes it easy to
    rename the variables through destructuring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, Hooks are simple JavaScript functions that deal with side effects,
    such as setting a stateful value.
  prefs: []
  type: TYPE_NORMAL
- en: Our Hook function uses a closure to store the current value. The closure is
    an environment where variables exist and are stored. In our case, the function
    provides the closure, and the `value` variable is stored within that closure.
    The `setState` function is also defined within the same closure, which is why
    we can access the `value` variable within that function. Outside of the `useState`
    function, we cannot directly access the `value` variable unless we return it from
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: Problems with our simple Hook implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we run our Hook implementation now, we are going to notice that when our
    component rerenders, the state gets reset, so we cannot enter any text in the
    field. This is due to the reinitialization of the `value` variable every time
    our component gets rendered, which happens because we call `useState` each time
    we render the component.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we are going to solve this problem by using a global
    variable and then turn the simple value into an array, allowing us to define multiple
    Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Using a global variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have learned, the value is stored within the closure that is defined by
    the `useState` function. Every time the component rerenders, the closure is reinitialized,
    which means that our value will be reset. To solve this, we need to store the
    value in a global variable, outside of the function. That way, the `value` variable
    will be in the closure outside of the function, which means that when the function
    gets called again, the closure will not be reinitialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a global variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add the following line (in bold) above the `useState` function definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we replace the first line in our function with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, our `useState` function uses the global `value` variable, instead of defining
    the `value` variable within its closure, so it will not be reinitialized when
    the function gets called again.
  prefs: []
  type: TYPE_NORMAL
- en: Defining multiple Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our Hook function works! However, if we wanted to add another Hook, we would
    run into another problem: all the Hooks write to the same global `value` variable!'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a closer look at this problem by adding a second Hook to our component.
  prefs: []
  type: TYPE_NORMAL
- en: Adding multiple Hooks to our component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say we want to create a second field for the last name of the user,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating a new Hook at the beginning of our function, after the
    current Hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define another `handleChange` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we place the `lastName` variable after the first name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add another `input` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When we try this out, we are going to notice that our reimplemented Hook function
    uses the same value for both states, so we are always changing both fields at
    once.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing multiple Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to implement multiple Hooks, instead of having a single global variable,
    we should have an array of Hook values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to refactor the `value` variable to a `values` array so that
    we can define multiple Hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, edit the first line of the `useState` function where we now initialize
    the value at the `currentHook` index of the `values` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to update the setter function, so that only the corresponding
    state value is updated. Here, we need to store the `currentHook` value in a separate
    `hookIndex` variable, because the `currentHook` value will change later. This
    ensures that a copy of the `currentHook` variable is created within the closure
    of the `useState` function. Otherwise, the `useState` function would access the
    `currentHook` variable from the outer closure, which gets modified with each call
    to `useState`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the final line of the `useState` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Using `values[currentHook++]`, we pass the current value of `currentHook` as
    an index to the `values` array, and then increase `currentHook` by one. This means
    that `currentHook` will be increased after returning from the function.
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to first increment a value and then use it, we could use the `arr[++indexToBeIncremented]`
    syntax, which first increments, and then passes the result to the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'We still need to reset the `currentHook` counter when we start rendering our
    component. Add the following line (in bold) right after the component definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, our simple reimplementation of the `useState` Hook works! The following
    screenshot highlights this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/de58db6c-14f4-478c-8f14-074080e7ee47.png)'
  prefs: []
  type: TYPE_IMG
- en: Our custom Hook reimplementation works
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, using a global array to store our Hook values solved the problems
    that we had when defining multiple Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Example code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example code for the simple Hook reimplementation can be found in the `Chapter02/chapter2_1`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Just run `npm install` in order to install all the dependencies and `npm start`
    to start the application, and then visit `http://localhost:3000` in your browser
    (if it did not open automatically).
  prefs: []
  type: TYPE_NORMAL
- en: Can we define conditional Hooks?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if we wanted to add a checkbox that toggles the use of the first name field?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s find out by implementing such a checkbox:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add a new Hook in order to store the state of our checkbox:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define a handler function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we render a checkbox:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We do not want to show the first name if it is disabled. Edit the following
    existing line in order to add a check for the `enableFirstName` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Could we put the Hook definition into an `if` condition, or a ternary expression,
    like we are in the following code snippet?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The latest version of `react-scripts` actually throws an error when defining
    conditional Hooks, so we need to downgrade the library for this example, by running
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we either use the Hook, or if the first name is disabled, we return the
    initial state and an empty setter function so that editing the input field will
    not work.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now try out this code, we are going to notice that editing the last name
    still works, but editing the first name does not work, which is what we wanted.
    As we can see in the following screenshot, only editing the last name works now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3d7b5e61-a873-4b2d-b8b3-2d7ef07896e6.png)'
  prefs: []
  type: TYPE_IMG
- en: State of the app before checking the checkbox
  prefs: []
  type: TYPE_NORMAL
- en: 'When we click the checkbox, something strange happens:'
  prefs: []
  type: TYPE_NORMAL
- en: The checkbox is checked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first name input field is enabled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of the last name field is now the value of the first name field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see the result of clicking the checkbox in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1796851e-7490-424a-8e4f-8892e2f9babd.png)'
  prefs: []
  type: TYPE_IMG
- en: State of the app after checking the checkbox
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the last name state is now in the first name field. The values
    have been swapped because the order of Hooks matters. As we know from our implementation,
    we use the `currentHook` index in order to know where the state of each Hook is
    stored. However, when we insert an additional Hook in-between two existing Hooks,
    the order gets messed up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before checking the checkbox, the `values` array was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[false, '''']`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hook order: `enableFirstName`, `lastName`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we entered some text in the `lastName` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[false, ''Hook'']`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hook order: `enableFirstName`, `lastName`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we toggled the checkbox, which activated our new Hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[true, ''Hook'', '''']`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hook order: `enableFirstName`, `name`, `lastName`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see, inserting a new Hook in-between two existing Hooks makes the `name` Hook
    steal the state from the next Hook (`lastName`) because it now has the same index
    that the `lastName` Hook previously had. Now, the `lastName` Hook does not have
    a value, which causes it to set the initial value (an empty string). As a result,
    toggling the checkbox puts the value of the `lastName` field into the `name` field.
  prefs: []
  type: TYPE_NORMAL
- en: Example code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example code for the problem of the conditional Hook of our simple Hook
    reimplementation can be found in the `Chapter02/chapter2_2` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Just run `npm install` in order to install all dependencies and `npm start` to
    start the application, and then visit `http://localhost:3000` in your browser
    (if it did not open automatically).
  prefs: []
  type: TYPE_NORMAL
- en: Comparing our reimplementation with real Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our simple Hook implementation already gives us an idea about how Hooks work
    internally. However, in reality, Hooks do not use global variables. Instead, they
    store state within the React component. They also deal with the Hook counter internally,
    so we do not need to manually reset the count in our function component. Furthermore,
    real Hooks automatically trigger rerenders of our component when the state changes.
    To be able to do this, however, Hooks need to be called from a React function
    component. React Hooks cannot be called outside of React, or inside React class
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'By reimplementing the `useState` Hook, we have learned a couple things:'
  prefs: []
  type: TYPE_NORMAL
- en: Hooks are simply functions that access React features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hooks deal with side effects that persist across rerenders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of Hook definitions matters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last point is especially important because it means that we cannot conditionally
    define Hooks. We should always have all the Hook definitions at the beginning
    of our function component, and never nest them within `if` or other constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we have also learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: React Hooks need to be called inside React function components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Hooks cannot be defined conditionally, or in loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are now going to look at alternative Hook APIs that allow conditional Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative Hook APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it would be nice to define Hooks conditionally or in loops, but why
    did the React team decide to implement Hooks like this? What are the alternatives?
    Let's go through a few of them.
  prefs: []
  type: TYPE_NORMAL
- en: Named Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We could give each Hook a name and then store the Hooks in an object instead
    of an array. However, this would not make for a nice API, and we would also always
    have to think of coming up with unique names for Hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore, what would happen when the conditional is set to `false`, or an
    item is removed from the loop? Would we clear the Hook state? If we do not clear
    the Hook state, we might be causing memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Even if we solved all these problems, there would still be the problem of name
    collisions. If we, for example, create a custom Hook that makes use of the `useState` Hook,
    and call it `nameHook`, then we cannot call any other Hook `nameHook` in our component
    anymore, or we will cause a name collision. This is even the case for Hook names
    from libraries, so we need to make sure we avoid name collisions with Hooks that
    have been defined by libraries as well!
  prefs: []
  type: TYPE_NORMAL
- en: Hook factories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Alternatively, we could also create a Hook factory function, which uses `Symbol`
    internally, in order to give each Hook a unique key name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we could use the factory function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this means that we will need to instantiate each Hook twice: once
    outside of our component and once inside the function component. This creates
    more room for errors. For example, if we create two Hooks and copy and paste the
    boilerplate code, then we might make a mistake in the name of our Hook resulting
    from the factory function, or we might make a mistake when using the Hook inside
    the component.'
  prefs: []
  type: TYPE_NORMAL
- en: This approach also makes it much harder to create custom Hooks, which forces
    us to write wrapper functions. Furthermore, it is harder to debug these wrapped
    functions than it is to debug a simple function.
  prefs: []
  type: TYPE_NORMAL
- en: Other alternatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There were many proposed alternative APIs for React Hooks, but each of them
    suffered from similar problems: either making the API harder to use, harder to
    debug, or introducing the possibility of name collisions.'
  prefs: []
  type: TYPE_NORMAL
- en: In the end, the React team decided that the simplest API was to keep track of
    Hooks by counting the order in which they are called. This approach comes with
    its own downsides, such as not being able to call Hooks conditionally or in loops.
    However, this approach makes it very easy for us to create custom Hooks, and it
    is simple to use and debug. We also do not need to worry about naming Hooks, name
    collisions, or writing wrapper functions. The final approach for Hooks lets us
    use Hooks just like any other function!
  prefs: []
  type: TYPE_NORMAL
- en: Solving common problems with Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we found out, implementing Hooks with the official API also has its own trade-offs
    and limitations. We are now going to learn how to overcome these common problems,
    which stem from the limitations of React Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will take a look at solutions that can be used to overcome these two problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Solving conditional Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving Hooks in loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving conditional Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, how do we implement conditional Hooks? Instead of making the Hook conditional,
    we can always define the Hook and use it whenever we need it. If this is not an
    option, we need to split up our components, which is usually better anyway!
  prefs: []
  type: TYPE_NORMAL
- en: Always defining the Hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For simple cases, such as the first and last name example that we had previously,
    we can just always keep the Hook defined, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Always defining the Hook is usually a good solution for simple cases.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting up components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to solve conditional Hooks is to split up one component into multiple
    components and then conditionally render the components. For example, let's say
    we want to fetch user information from a database after the user logs in.
  prefs: []
  type: TYPE_NORMAL
- en: 'We cannot do the following, as using an `if` conditional could change the order
    of the Hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we have to create a separate component for when the user is logged
    in, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Using two separate components for the non-logged in and logged in state makes
    sense anyway, because we want to stick to the principle of having one functionality
    per component. So, usually, not being able to have conditional Hooks is not much
    of a limitation if we stick to best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Solving Hooks in loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As for Hooks in loops, we can either use a single State Hook containing an array,
    or we can split up our components. For example, let's say we want to display all
    the users that are online.
  prefs: []
  type: TYPE_NORMAL
- en: Using an array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We could simply use an array that contains all `users`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: However, this might not always make sense. For example, we might not want to
    update the `user` state through the `OnlineUsers` component because we would have
    to select the correct `user` state from the array, and then modify the array.
    This might work, but it is quite tedious.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting up components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A better solution would be to use the Hook in the `UserInfo` component instead.
    That way, we can keep the state for each user up to date, without having to deal
    with array logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, using one component for each functionality keeps our code simple
    and concise, and also avoids the limitations of React Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Solving problems with conditional Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have learned about the different alternatives to conditional Hooks,
    we are going to solve the problem that we had in our small example project earlier. The
    simplest solution to this problem would be to always define the Hook, instead
    of conditionally defining it. In a simple project like this one, always defining
    the Hook makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `src/App.js` and remove the following conditional Hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with a normal Hook, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, our example works fine! In more complex cases, it might not be feasible
    to always define the Hook. In that case, we would need to create a new component,
    define the Hook there, and then conditionally render the component.
  prefs: []
  type: TYPE_NORMAL
- en: Example code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example code for the simple solution to the conditional Hooks problem can
    be found in the `Chapter02/chapter2_3` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Just run `npm install` in order to install all dependencies and `npm start` to
    start the application, and then visit `http://localhost:3000` in your browser
    (if it did not open automatically).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started out by reimplementing the `useState` function, by
    making use of global state and closures. We then learned that in order to implement
    multiple Hooks, we need to use a state array instead. By using a state array,
    however, we were forced to keep the order of Hooks consistent across function
    calls. This limitation made conditional Hooks and Hooks in loops impossible. We
    then learned about possible alternatives to the Hook API, their trade-offs, and
    why the final API was chosen. Finally, we learned how to solve the common problems
    that stem from the limitations of Hooks. We now have a solid understanding of
    the inner workings and limitations of Hooks. Furthermore, we learned about the
    State Hook in depth.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to create a blog application using the State
    Hook, and learn how to combine multiple Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To recap what we have learned in this chapter, try to answer the following
    questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What problems did we run into while developing our own reimplementation of the
    `useState` Hook? How did we solve these problems?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are conditional Hooks not possible in the React implementation of Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are Hooks, and what do they deal with?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do we need to watch out for when using Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the common problems of alternative API ideas for Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we implement conditional Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we implement Hooks in loops?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are interested in finding out more about the concepts that we have learned
    in this chapter, take a look at the following reading material:'
  prefs: []
  type: TYPE_NORMAL
- en: More information on flaws of alternative Hook APIs: [https://overreacted.io/why-do-hooks-rely-on-call-order/](https://overreacted.io/why-do-hooks-rely-on-call-order/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official comment on alternative Hook APIs: [https://github.com/reactjs/rfcs/pull/68#issuecomment-439314884](https://github.com/reactjs/rfcs/pull/68#issuecomment-439314884)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official documentation on why conditional Hooks do not work: [https://reactjs.org/docs/hooks-rules.html#explanation](https://reactjs.org/docs/hooks-rules.html#explanation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
