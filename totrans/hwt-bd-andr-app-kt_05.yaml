- en: '5\. Essential Libraries: Retrofit, Moshi, and Glide'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover the steps needed to present app users with dynamic
    content fetched from remote servers. You will be introduced to the different libraries
    required to retrieve and handle this dynamic data.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to fetch data from a network endpoint
    using Retrofit, parse JSON payloads into Kotlin data objects using Moshi, and
    load images into `ImageViews` using Glide.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to implement navigation in our app.
    In this chapter, we will learn how to present dynamic content to the user as they
    navigate around our app.
  prefs: []
  type: TYPE_NORMAL
- en: Data presented to users can come from different sources. It can be hardcoded
    into the app, but that comes with limitations. To change hardcoded data, we have
    to publish an update to our app. Some data cannot be hardcoded by its nature,
    such as currency exchange rates, the real-time availability of assets, and the
    current weather, to name a few. Other data may become outdated, such as the terms
    of use of an app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In such cases, you would usually fetch the relevant data from a server. One
    of the most common architectures for serving such data is the **representational
    state transfer** (**REST**) architecture. The REST architecture is defined by
    a set of six constraints: the client-server architecture, statelessness, cacheability,
    a layered system, code on demand (optional), and a uniform interface. To read
    more about REST, visit [https://medium.com/extend/what-is-rest-a-simple-explanation-for-beginners-part-1-introduction-b4a072f8740f](https://medium.com/extend/what-is-rest-a-simple-explanation-for-beginners-part-1-introduction-b4a072f8740f).'
  prefs: []
  type: TYPE_NORMAL
- en: When applied to a web service **application programming interface** (**API**),
    we get a **HyperText Transfer Protocol** (**HTTP**)-based RESTful API. The HTTP
    protocol is the foundation of data communication for the World Wide Web, also
    known as the internet. It is the protocol used by servers all around the world
    to serve websites to users in the form of HTML documents, images, style sheets,
    and so forth. An interesting article on this topic for further information can
    be found at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview).
  prefs: []
  type: TYPE_NORMAL
- en: RESTful APIs rely on the standard HTTP methods—`GET`, `POST`, `PUT`, `DELETE`,
    and `PATCH`—to fetch and transform data. These methods allow us to fetch, store,
    delete, and update data entities on remote servers.
  prefs: []
  type: TYPE_NORMAL
- en: To execute these HTTP methods, we can rely on the built-in Java `HttpURLConnection`
    class or use a library such as `OkHttp`, which offers additional features such
    as gzipping, redirects, retries, and both synchronous and asynchronous calls.
    Interestingly, from Android 4.4, `HttpURLConnection` is just a wrapper around
    `OkHttp`. If we choose `OkHttp`, we might as well go for **Retrofit**, as we will
    in this chapter, to benefit from its type safety, which is better suited for handling
    REST calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most commonly, data is represented by **JavaScript Object Notation** (**JSON**).
    JSON is a text-based data transfer format. As the name implies, it was derived
    from JavaScript. However, it has since become one of the most popular standards
    for data transfer, and its most modern programming languages have libraries that
    encode or decode data to or from JSON. A simple JSON payload may look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common data structure used by RESTful services is **Extensible Markup
    Language** (**XML**), which encodes documents in a format that is human- and machine-readable.
    XML is considerably more verbose than JSON. The same data structure as the previous
    in XML would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this chapter, we will focus on JSON.
  prefs: []
  type: TYPE_NORMAL
- en: When obtaining a JSON payload, we are essentially receiving a string. To convert
    that string into a data object, we have a few options—the most popular ones being
    libraries such as `org.json` package. For its lightweight nature, we will focus
    on Moshi.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will look into loading images from the web. Doing so will allow
    us not only to provide up-to-date images but also to load the right images for
    the user's device. It will also let us only load the images when we need them,
    thus keeping our APK size smaller.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching Data from a Network Endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the purpose of this section, we will use TheCatAPI ([https://thecatapi.com/](https://thecatapi.com/)).
    This RESTful API offers us vast data about, well… cats.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, we will create a new project. We then have to grant our app
    internet access permission. This is done by adding the following code to your
    `AndroidManifest.xml` file, right before the `Application` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to set up our app to include Retrofit. `OkHttp` HTTP client.
    Retrofit helps us generate **Uniform Resource Locators** (**URLs**), which are
    the addresses of the server endpoints we want to access. It also makes the decoding
    of JSON payloads easier by providing integration with several parsing libraries.
    Sending data to the server is also easier with Retrofit, as it helps with encoding
    the requests. You can read more about Retrofit here: [https://square.github.io/retrofit/](https://square.github.io/retrofit/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add Retrofit to our project, we need to add the following code to the `dependencies`
    block of the `build.gradle` file of our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the latest version here: [https://github.com/square/retrofit](https://github.com/square/retrofit).'
  prefs: []
  type: TYPE_NORMAL
- en: With Retrofit included in our project, we can proceed to set it up.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, to access an HTTP(S) endpoint, we start by defining the contract with
    that endpoint. A contract to access the `https://api.thecatapi.com/v1/images/search`
    endpoint looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There are a few things to note here. First, you will notice that the contract
    is implemented as an interface. This is how you define contracts for Retrofit.
    Next, you will notice that the name of the interface implies that this interface
    can, eventually, cover all calls made to the TheCatAPI service. It is a bit unfortunate
    that Square chose `Service` as the conventional suffix for these contracts, as
    the term service has a different meaning in the Android world, as you will see
    in *Chapter 8*, *Services, Broadcast Receivers, and Notifications*. Nevertheless,
    this is the convention.
  prefs: []
  type: TYPE_NORMAL
- en: To define our endpoint, we start by stating the method with which the call will
    be made using the appropriate annotation—in our case, `@GET`. The parameter passed
    to the annotation is the path of the endpoint to access. You'll notice that `https://api.thecatapi.com/v1/`
    is stripped from that path. That is because this is the common address for all
    of the endpoints of TheCatAPI, and so will be passed to our Retrofit instance
    at construction time instead. Next, we choose a meaningful name for our function—in
    this case, we'll be calling the image search endpoint, and so `searchImages` seems
    appropriate. The parameters of the `searchImages` function define the values we
    can pass to the API when we make the calls.
  prefs: []
  type: TYPE_NORMAL
- en: There are different ways in which we can transfer data to the API. `@Query`
    allows us to define values added to the query of our request URL (that's the optional
    part of the URL that comes after the question mark). It takes a key value pair
    (in our case, we have `limit` and `size`) and a data type. If the data type is
    not a string, the value of that type will be transformed into a string. Any value
    passed will be URL-encoded for us.
  prefs: []
  type: TYPE_NORMAL
- en: Another such way is using `@Path`. This annotation can be used to replace a
    token in our path wrapped in curly brackets with a provided value. The `@Header`,
    `@Headers`, and `@HeaderMap` annotations will allow us to add or remove HTTP headers
    from the request. `@Body` can be used to pass content in the body of `POST`/`PUT`
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we have a return type. To keep things simple at this stage, we will
    accept the response as a string. We wrapped our string in a `Call` interface.
    `Call` is Retrofit's mechanism for executing network requests synchronously (via
    `execute()`) or asynchronously (via `enqueue(Callback)`). When using RxJava (the
    Java implementation of ReactiveX, or Reactive Extensions; you can read more about
    ReactiveX at `https://reactivex.io/`), we can wrap our result in an `Observable`
    class (a class that emits data) or a `Single` class (a class that emits data once)
    as appropriate instead (see *Chapter 13*, *RxJava and Coroutines*, for more information
    on RxJava).
  prefs: []
  type: TYPE_NORMAL
- en: 'With our contract defined, we can get Retrofit to implement our service interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to run our app with this code, our app will crash with `IllegalArgumentException`.
    This is because Retrofit needs us to tell the app how to process the server response
    to a string. This processing is done with what Retrofit calls `ConverterFactory`
    instance to our `retrofit` instance, we need to add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For our project to recognize `ScalarsConverterFactory`, we need to update our
    app''s `build.gradle` file by adding another dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can obtain a `Call` instance by calling `val call = theCatApiService.searchImages(1,
    "full")`. With the instance obtained in this fashion, we can execute an async
    request by calling `call.enqueue(Callback)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Callback` implementation will have two methods: `onFailure(Call, Throwable)`
    and `onResponse(Call, Response)`. Note that we are not guaranteed to have a successful
    response if `onResponse` was called. `onResponse` is called whenever we successfully
    receive any response from the server and no unexpected exception occurred. So,
    to confirm that the response is a success response, we should check the `response.isSuccessful`
    property. The `onFailure` function will be called in the case of a network error
    or an unexpected exception somewhere along the way.'
  prefs: []
  type: TYPE_NORMAL
- en: So, where should we implement the Retrofit code? In clean architecture, data
    is provided by repositories. Repositories, in turn, have data sources. One such
    data source can be a network data source. This is where we would be implementing
    our network calls. Our ViewModels (in the case of **Model-View-ViewModel** (**MVVM**),
    the ViewModel is an abstraction of the view that exposes properties and commands)
    will then request data from repositories via use cases.
  prefs: []
  type: TYPE_NORMAL
- en: For our implementation, we will simplify the process by instantiating Retrofit
    and the service in the Activity. This is not good practice. Do not do this in
    a production app. It does not scale well and is very difficult to test. Instead,
    adopt an architecture that decouples your views from your business logic and your
    data. See *Chapter 14*, *Architecture Patterns*, for some ideas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.01: Reading Data from an API'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following chapters, we will be developing an app for an imaginary secret
    agency with a worldwide network of agents saving the world from countless dangers.
    The secret agency in question is quite unique: it operates secret cat agents.
    In this exercise, we will create an app that presents us with one random secret
    cat agent from TheCatAPI. Before you can present data from an API to your user,
    you first have to fetch that data. Let''s start:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new `Empty Activity` project (`File` | `New` | `New Project`
    | `Empty Activity`). Click `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your application `Cat Agent Profile`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure your package name is `com.example.catagentprofile`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the save location to where you want to save your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave everything else at its default values and click `Finish`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure you are on the `Android` view in your `Project` pane:![Figure 5.1:
    Android view in the Project pane'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_05_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.1: Android view in the Project pane'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your `AndroidManifest.xml` file. Add internet permission to your app like
    so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To add Retrofit and the scalars converter to your app, open the app module,
    `build.gradle` (`Gradle Scripts` | `build.gradle (Module: app)`), and add the
    following lines anywhere inside the `dependencies` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Your `dependencies` block should now look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Between the time of writing and when you carry out this exercise, some dependencies
    may have changed. You should still only add the lines in bold from the preceding
    code block. These will add Retrofit and support for reading server responses as
    single strings.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that Retrofit now requires, as a minimum, Android API 21
    or Java 8.
  prefs: []
  type: TYPE_NORMAL
- en: Click the `Sync Project with Gradle Files` button in Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your `activity_main.xml` file in `Text` mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To be able to use your label to present the latest server response, you need
    to assign an ID to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the `Project` pane on the left, right-click on your app package (`com.example.catagentprofile`),
    then select `New` | `Package`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your package `api`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, right-click on the newly created package (`com.example.catagentprofile.api`),
    then select `New` | `Kotlin File/Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your new file `TheCatApiService`. For `Kind`, choose `Interface`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following into the `interface` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This defines the image search endpoint. Make sure to import all the required
    Retrofit dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Open your `MainActivity` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the `MainActivity` class block, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `serverResponseView` as a field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the `getCatImageResponse()` function after the `onCreate(Bundle?)`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This function will fire off the search request and handle the possible outcomes—a
    successful response, an error response, and any other thrown exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoke a call to `getCatImageResponse()` in `onCreate()`. This will trigger
    the call as soon as the activity is created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Add the missing imports.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run your app by clicking the `Run ''app''` button or pressing *Ctrl* + *R*.
    On the emulator, it should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2: The app presenting the server response JSON'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_05_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.2: The app presenting the server response JSON'
  prefs: []
  type: TYPE_NORMAL
- en: Because every time you run your app a new call is made and a random response
    is returned, your result will likely differ. However, whatever your result, if
    successful, it should be a JSON payload. Next, we will learn how to parse that
    JSON payload and extract the data we want from it.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing a JSON Response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have successfully retrieved a JSON response from an API, it is time
    to learn how to use the data we have obtained. To do so, we need to parse the
    JSON payload. This is because the payload is a plain string representing the data
    object, and we are interested in specific properties of that object. If you look
    closely at *Figure 5.2*, you may notice that the JSON contains breed information,
    an image URL, and some other bits of information. However, for our code to use
    that information, first we have to extract it.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the introduction, multiple libraries exist that will parse a
    JSON payload for us. The most popular ones are Google's GSON ([https://github.com/google/gson](https://github.com/google/gson))
    and, more recently, Square's Moshi ([https://github.com/square/moshi](https://github.com/square/moshi)).
    Moshi is very lightweight, which is why we have chosen to use it in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: What do JSON libraries do? Basically, they help us convert data classes into
    JSON strings (serialization) and vice versa (deserialization). This helps us communicate
    with servers that understand JSON strings while allowing us to use meaningful
    data structures in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Moshi with Retrofit, we need to add the Moshi Retrofit converter to
    our project. This is done by adding the following line to the `dependencies` block
    of our app''s `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Since we will no longer be accepting the responses as strings, we can go ahead
    and remove the scalars Retrofit converter.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to create a data class to map the server JSON response to. One
    convention is to suffix the names of API response data classes with `Data`—so
    we'll call our data class `ImageResultData`. Another common suffix is `Entity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we design our server response data classes, we need to take two factors
    into account: the structure of the JSON response and our data requirements. The
    first will affect our data types and field names, while the second will allow
    us to omit fields we do not currently need. JSON libraries know that they should
    ignore data in fields we have not defined in our data classes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One more thing JSON libraries do for us is automatically map JSON data to fields
    if they happen to have the exact same name. While this is a nice feature, it is
    also problematic. If we rely solely on it, our data classes (and the code accessing
    them) will be tightly coupled to the API naming. Because not all APIs are designed
    well, you might end up with meaningless field names, such as `fn` or `last`, or
    inconsistent naming. Luckily, there is a solution to this problem. Moshi provides
    us with an `@field:Json` annotation. It can be used to map a JSON field name to
    a meaningful field name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Some consider it better practice to include the annotation even when the API
    name is the same as the field name for the sake of consistency. We prefer the
    conciseness of direct conversion when the field name is clear enough. This approach
    can be challenged when obfuscating our code. If we do, we have to either exclude
    our data classes or make sure to annotate all fields.
  prefs: []
  type: TYPE_NORMAL
- en: While we are not always lucky enough to have properly documented APIs, when
    we do, it is best to consult the documentation when designing our model. Our model
    would be a data class into which the JSON data from all calls we make will be
    decoded. The documentation for the image search endpoint of TheCatAPI can be found
    at [https://docs.thecatapi.com/api-reference/images/images-search](https://docs.thecatapi.com/api-reference/images/images-search).
    You will often find documentation to be partial or inaccurate. If this happens
    to be the case, the best thing you can do is contact the owners of the API and
    request that they update the documentation. You may have to resort to experimenting
    with an endpoint, unfortunately. This is risky because undocumented fields or
    structures are not guaranteed to remain the same, so when possible, try and get
    the documentation updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the response schema obtained from the preceding link, we can define
    our model as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that the response structure is actually that of a list of results. This
    means we need our responses mapped to `List<ImageResultData>`, not simply `ImageResultData`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to update `TheCatApiService`. Instead of `Call<String>`, we can
    now have `Call<List<ImageResultData>>`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to update the construction of our Retrofit instance. Instead of
    `ScalarsConverterFactory`, we will now have `MoshiConverterFactory`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we need to update our callback, since it should no longer be handing
    string calls, but `List<ImageResultData>` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 5.02: Extracting the Image URL from the API Response'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, we have a server response as a string. Now, we want to extract the image
    URL from that string and present only that URL on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the app''s `build.gradle` file and replace the scalars converter implementation
    with a Moshi converter one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Click the `Sync Project with Gradle Files` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under your app package (`com.example.catagentprofile`), create a `model` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the `com.example.catagentprofile.model` package, create a new Kotlin
    file named `CatBreedData`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Populate the newly created file with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Next, create `ImageResultData` under the same package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set its contents to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `TheCatApiService` file and update the `searchImages` return type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, open `MainActivity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the Retrofit initialization block to use the Moshi converter to deserialize JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `getCatImageResponse()` function to handle `List<ImageResultData>`
    requests and responses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, you need to check not only for a successful response but also that there
    is at least one `ImageResultData` instance. You can then read the `imageUrl` property
    of that instance and present it to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run your app. It should now look something like the following:![Figure 5.3:
    App presenting the parsed image URL'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_05_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.3: App presenting the parsed image URL'
  prefs: []
  type: TYPE_NORMAL
- en: Again, due to the random nature of the API responses, your URL will likely be different.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have now successfully extracted a specific property from an API response.
    Next, we will learn how to load the image from the URL provided to us by the API.
  prefs: []
  type: TYPE_NORMAL
- en: Loading Images from a Remote URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just learned how to extract particular data from an API response. Quite often,
    that data will include URLs to images we want to present to the user. There is
    quite a bit of work involved in achieving that. First, you have to fetch the image
    as a binary stream from the URL. Then, you need to transform that binary stream
    into an image (it could be a GIF, JPEG, or one of a few other image formats).
    Then, you need to convert it into a bitmap instance, potentially resizing it to
    use less memory.
  prefs: []
  type: TYPE_NORMAL
- en: You may also want to apply other transformations to it at that point. Then,
    you need to set it to an `ImageView`. Sounds like a lot of work, doesn't it? Well,
    luckily for us, there are a few libraries that do all of that (and more) for us.
    The most commonly used libraries are Square's **Picasso** ([https://square.github.io/picasso/](https://square.github.io/picasso/))
    and **Glide** by Bump Technologies ([https://github.com/bumptech/glide](https://github.com/bumptech/glide)).
    Facebook's **Fresco** ([https://frescolib.org/](https://frescolib.org/)) is somewhat
    less popular. We will proceed with Glide because it is consistently the faster
    of the two for loading images, whether it is from the internet or from the cache.
    It's worth noting that Picasso is more lightweight, so it is a trade-off, and
    both libraries are quite useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'To include Glide in your project, add it to the `dependencies` block of your
    app''s `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, because we might change our minds at a later point, this is a great
    opportunity to abstract away the concrete library to have a simpler interface
    of our own. So, let''s start by defining our `ImageLoader` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is a naïve implementation. In a production implementation, you might want
    to add arguments (or multiple functions) to support options such as different
    cropping strategies or having loading states.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our implementation of the interface will rely on Glide, and so will look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We prefix our class name with `Glide` to differentiate it from other potential
    implementations. Constructing `GlideImageLoader` with `context` allows us to implement
    the clean `loadImage(String, ImageView)` interface without having to worry about
    the context, which is required by Glide for image loading. In fact, Glide is smart
    about the Android context. That means we could have separate implementations for
    `Activity` and `Fragment` scopes, and Glide would know when an image-loading request
    went beyond the scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we haven''t yet added an `ImageView` to our layout, let''s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This will add an `ImageView` with an ID of `main_profile_image` below our `TextView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now create an instance of `GlideImageLoader` in `MainActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Again, in a production app, you would be injecting the dependency, rather than
    creating it inline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we tell our Glide loader to load the image and, once loaded, center-crop
    it inside the provided `ImageView`. This means the image will be scaled up or
    down to fully fill the `ImageView`, with any excess content cut off (cropped).
    Since we already obtained an image URL before, all we need to do is make the call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to make sure the result contains a string that is not empty or made
    of spaces (`isBlank()` in the preceding code block). Then, we can safely load
    the URL into our `ImageView`. And we''re done. If we run our app now, we should
    see something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: Server response image URL with the actual image'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_05_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.4: Server response image URL with the actual image'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the API returns random results, so the actual image is likely
    to be different. If we're lucky, we might even get an animated GIF, which we would
    then see animating.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.03: Loading the Image from the Obtained URL'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous exercise, we extracted the image URL from the API response.
    Now, we will use that URL to fetch an image from the web and display it in our
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the app''s `build.gradle` file and add the Glide dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Synchronize your project with the Gradle files.
  prefs: []
  type: TYPE_NORMAL
- en: On the left `Project` panel, right-click on your project package name (`com.example.catagentprofile`)
    and select `New` | `Kotlin File/Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in `ImageLoader` in the `Name` field. For `Kind`, choose `Interface`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the newly created `ImageLoader.kt` file and update it like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This will be your interface for any image loader in the app.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the project package name again, and again select `New` | `Kotlin
    File/Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new file `GlideImageLoader`, and select `Class` for `Kind`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the newly created file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Open `activity_main.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Open the `MainActivity.kt` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a field for your newly added `ImageView` at the top of your class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Define `ImageLoader` just above the `onCreate(Bundle?)` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Update your `getCatImageResponse()` function like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, once you have a non-blank URL, it will be loaded into `profileImageView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the app:![Figure 5.5: Exercise outcome – showing a random image and its
    source URL'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_05_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.5: Exercise outcome – showing a random image and its source URL'
  prefs: []
  type: TYPE_NORMAL
- en: The following are bonus steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your layout like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This will add an `Agent breed` label and tidy up the view layout. Now, your
    layout looks a bit more like a proper cat agent profile app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `MainActivity.kt`, locate the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace that line with the following to look up the new name field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Update `getCatImageResponse()` like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This is done to load the first breed returned from the API into `agentNameView`,
    with a fallback to `Unknown`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, not many pictures in TheCatAPI have breed data. However,
    if you run your app enough times, you will end up seeing something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.6: Showing the cat agent image and breed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_05_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.6: Showing the cat agent image and breed'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned how to fetch data from a remote API. We then learned
    how to process that data and extract the information we need from it. Lastly,
    we learned how to present an image on the screen when given an image URL.
  prefs: []
  type: TYPE_NORMAL
- en: In the following activity, we will apply our knowledge to develop an app that
    tells the user the current weather in New York, presenting the user with a relevant
    weather icon, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 5.01: Displaying the Current Weather'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say we want to build an app that shows the current weather in New York.
    Furthermore, we also want to display an icon that represents the current weather.
  prefs: []
  type: TYPE_NORMAL
- en: This activity aims to create an app that polls an API endpoint for the current
    weather in JSON format, transforms that data into a local model, and uses that
    model to present the current weather. It also extracts the URL to an icon representing
    the current weather and fetches that icon to be displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the free OpenWeatherMap.org API for the purpose of this activity.
    Documentation can be found at [https://www.metaweather.com/api/](https://www.metaweather.com/api/).
    To sign up for an API token, please go to [https://home.openweathermap.org/users/sign_up](https://home.openweathermap.org/users/sign_up).
    You can find your keys and generate new ones as needed at [https://home.openweathermap.org/api_keys](https://home.openweathermap.org/api_keys).
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Grant internet permissions to the app in order to be able to make API and image requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add Retrofit, the Moshi converter, and Glide to the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the app layout to support the presentation of the weather in a textual
    form (short and long description) as well as a weather icon image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the model. Create classes that will contain the server response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the Retrofit service for the OpenWeatherMap API,[https://api.openweathermap.org/data/2.5/weather](https://api.openweathermap.org/data/2.5/weather).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Retrofit instance with a Moshi converter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the API service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handle the successful server response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handle the different failure scenarios.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7: The final weather app'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_05_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.7: The final weather app'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: http://packt.live/3sKj1cp'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to fetch data from an API using Retrofit. We
    then learned how to handle JSON responses using Moshi, as well as plain text responses.
    We also saw how different error scenarios can be handled.
  prefs: []
  type: TYPE_NORMAL
- en: We later learned how to load images from URLs using Glide and how to present
    them to the user via `ImageView`.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few popular libraries for fetching data from APIs as well
    as for loading images. We only covered some of the most popular ones. You might
    want to try out some of the other libraries to find out which ones fit your purpose
    best.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be introduced to `RecyclerView`, which is a powerful
    UI component that we can use to present our users with lists of items.
  prefs: []
  type: TYPE_NORMAL
