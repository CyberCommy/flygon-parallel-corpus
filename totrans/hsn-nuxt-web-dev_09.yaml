- en: Adding Vue Forms
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will create forms with `v-model` and `v-bind`. You will
    learn to validate forms on the client side before sending the form data to the
    server. You will create forms with basic elements, binding dynamic values and
    using modifiers to modify the input element's behavior. You will also learn to
    use the `vee-validate` plugin for validating forms and applying it to Nuxt apps. It
    is important to learn and understand how to use `v-model` and `v-bind` with Vue
    forms in this chapter because we will use forms in the coming chapters, such as
    in [Chapter 10](808b1fa6-d397-4c97-b45a-95de8238497a.xhtml), *Adding a Vuex Store*,
    and [Chapter 12](8e574c51-68dc-45e2-8a1d-4c04d9c38df5.xhtml), *Creating User Logins
    and API Authentication*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover in this chapter are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding `v-model`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating forms with basic data bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making dynamic value bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating forms with `vee-validate`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying Vue forms in Nuxt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding v-model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`v-model` is a Vue directive (a custom built-in Vue HTML attribute) that allows
    us to create a two-way binding on the form''s `input`, `textarea`, and `select`
    elements. You can bind a form input with the Vue data so that the data can be
    updated when the users interact with the input field. `v-model` will always skip
    the initial value you set on the form elements but treats the Vue data as the
    source of truth. So you should declare the initial value on the Vue side, inside
    the `data` option or function.'
  prefs: []
  type: TYPE_NORMAL
- en: '`v-model` will pick the appropriate way to update the element based on the
    input type, which means that if you use it on the form input with `type="text"`,
    it will use `value` as the property and `input` as the event to perform the two-way
    binding for you. Let''s look at what falls under this directive in the coming
    sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Using v-model in text and textarea elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remember the two-way binding that we implemented with `v-model` to create custom
    input components in [Chapter 5](099c1dc8-8dfa-46f8-bfbd-bfa036eefbb7.xhtml), *Adding
    Vue Components*? In the *Creating custom input components* section of that chapter,
    we learned that the `v-model` syntax for inputs – `<input v-model="username">` –
    is shorthand for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This text `input` element, behind the scene, binds the `value` attribute that
    gets the value from a handler, `username`, which gets its value from the `input`
    event. And so, a custom text input component, too, must always use the `value`
    prop and the `input` event in the `model` property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just because of the nature of a `v-model` input being made of `v-bind:value`
    and `v-on:input`. This is also the same when using the `v-model` directive in
    a `textarea` element, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This `v-model` `textarea` element is shorthand for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This `textarea` input element, behind the scene, binds the `value` attribute
    that gets the value from the handler, `message`, which gets its value from the
    `input` event. And so, a custom `textarea` component, too, must always comply
    with the nature of the `v-model` `textarea` element by using the `value` prop
    and the `input` event in the `model` property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In short, the `v-model` text `input` element and the `v-model` `textarea` input
    element always bind the `value` attribute with a handler for getting the new value
    on the input event, and so must the custom input components by adopting the same
    attribute and event. What about `v-model` in checkboxes and radio buttons elements
    then? Let's dive into them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using v-model in checkbox and radio elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On the other hand, `v-model` `checkbox` and `radio` button input elements always
    bind the `checked` attribute with a Boolean value that is updated on the `change`
    event, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `v-model` `checkbox` input element in the preceding code snippet is indeed
    shorthand for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And so, a custom checkbox input element, too, must always comply with the nature
    of the `v-model` checkbox input element (shown in the preceding code block) by
    adopting the `checked` prop and the `change` event in the `model` property as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The same applies to the `v-model` radio button input elements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `v-model` element is another shorthand for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And so, a custom radio button input element, too, must always comply with the
    nature of the `v-model` element as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In short, as the `v-model` `checkbox` and `radio` button input elements always
    bind the `value` attribute and are updated on the `change` event, so must the
    custom input components by adopting the same attribute and event. Now, let's take
    a look at how `v-model` works in `select` elements in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using v-model in select elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Not surprisingly, v-model `select` input elements always bind the `value` attribute
    with a handler for getting its selected value on the `change` event, as in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `v-model` `checkbox` input element is just another shorthand
    for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And so, a custom `checkbox` input element, too, must always comply with the
    nature of the `v-model` element by using the `value` prop and the `change` event
    in the `model` property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `v-model` is syntactic sugar on top of `v-bind`, which binds
    a value to the markup, and `v-on`, which updates data on the user input events,
    which can be either `change` or `input` events. In short, `v-model` combines `v-bind`
    and `v-on` under the hood – but it is important to understand what lies underneath
    the syntax as a Vue/Nuxt apps developer.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the examples we've covered in this section in `/chapter-7/vue/html/`
    in our GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have discovered how the `v-model` directive works in the form's
    input elements, let's use these `v-model` elements on a form and validate them
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Validating forms with basic data bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A form is a document for collecting information. The HTML `<form>` element is
    a form where the data or information can be collected from the web user. This
    element requires `<input>` elements in it to specify what data we want to collect.
    But before accepting the data, we usually would want to validate and filter it
    so that we get genuine and correct data from the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vue allows us to validate the data easily from the `v-model` input elements,
    so let''s get started with a single-file components (SFC) Vue app and webpack,
    which you learned about in [Chapter 5](099c1dc8-8dfa-46f8-bfbd-bfa036eefbb7.xhtml), *Adding
    Vue Components*, in the *Compiling single-file components with webpack *section.
    First, we will create a very simple form with a `submit` button and the markups
    for displaying the error message in the `<template>` block as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will add the rest of the input elements inside `<form>` later. Now, let''s
    set up the basic structure and understand what we will need. We use `v-on:submit.prevent`
    to prevent the browser from sending the form data by default because we will handle
    the submission with the `checkForm` method in the Vue instance in the `<script>`
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: On the JavaScript side, we define an array to hold the errors that we might
    get in the validation process. The `checkForm` logic validates the required fields
    that we will add later in this section. If the required field fails to pass the
    validation then we push the error message to `errors`. When the form is filled
    in correctly and/or no error is found, it will be passed to the `processForm`
    logic, where we can do something further with the form data before sending it
    to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Validating text elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get started by adding an `<input>` element for single-line text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the `<script>` block, we define a `name` property in the `data` function
    that holds the initial `null` value and will be updated on the `input` event from
    the `<input>` element. We validate the `name` data in the `if` condition block
    when you hit the `submit` button; if it has no data provided, then we `push` the
    error message to `errors`.
  prefs: []
  type: TYPE_NORMAL
- en: Validating textarea elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next element we are adding is `<textarea>` for multi-line text, which works
    the same way as `<input>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the `<script>` block, we define a `message` property in the `data` function
    that holds the initial `null` value and will be updated on the `input` event from
    the `<textarea>` element. We validate the `message` data in the `if` condition
    block when you hit the `submit` button; if it has no data provided, then we `push`
    the error message to `errors`.
  prefs: []
  type: TYPE_NORMAL
- en: Validating checkbox elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next element is a single checkbox `<input>` element that will hold the
    default Boolean value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We also will add the following multiple checkbox `<input>` elements that are
    bound to the same array, that is, `books: []`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the `<script>` block, we define a `subscribe` property in the `data` function
    that holds the initial Boolean `false` value and will be updated on the `change`
    event from the checkbox `<input>` element. We validate the `subscribe` data in
    the `if` condition block when you hit the `submit` button; if it has no data provided
    or it is `false`, then we `push` the error message to `errors`.
  prefs: []
  type: TYPE_NORMAL
- en: We do the same for the multiple checkbox `<input>` elements by defining a `books`
    property that holds the initial empty array and will be updated on the `change`
    event from the checkbox `<input>` element. We validate the `books` data in the
    `if` condition block; if its length is `0` then we `push` the error message to
    `errors`.
  prefs: []
  type: TYPE_NORMAL
- en: Validating radio elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next element is multiple radio button `<input>` elements that are bound
    to the same property name, that is, `gender`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the `<script>` block, we define a `gender` property in the `data` function
    that holds the initial `null` value and will be updated on the `change` event
    from the selected `<input>` radio button element. We validate the `gender` data
    in the `if` condition block when you hit the `submit` button. If it has no data
    provided, then we `push` the error message to `errors`.
  prefs: []
  type: TYPE_NORMAL
- en: Validating select elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next element is a single `<select>` element with multiple `<option>` elements
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And the last one is multiple `<select>` elements with multiple `<option>` elements
    that are bound to the same `Array`, that is, `favourites: []`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the `<script>` block, we define a `favourites` property in the `data` function
    that holds the initial `null` value and will be updated on the `change` event
    from the `<select>` element. We validate the `favourites` data in the `if` condition
    block when you hit the `submit` button. If it has no data provided, then we `push`
    the error message to `errors`. We do the same for the multiple `<select>` elements
    by defining a `favourites` property that holds the initial empty array and will
    be updated on the `change` event from the `<select>` element. We validate the
    `favourites` data in the `if` condition block; if its length is `0` then we push
    the error message to `errors`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we will finish up this form with the `processForm` logic, which is called
    only when no error is found in the `checkForm` logic. We use a Node.js package,
    `qs`, to stringify the `this.form` object so we can send the data to the server in
    the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s install `qs` with npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We send the data using `axios` and get the response (usually in JSON format)
    back from the server, then you can do something with the response data, such as
    displaying a "success" or "failed" message on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about `qs`, visit [https://www.npmjs.com/package/qs](https://www.npmjs.com/package/qs),
    and for `axios`, please visit [https://github.com/axios/axios](https://github.com/axios/axios).
  prefs: []
  type: TYPE_NORMAL
- en: You can find the preceding example app in `/chapter-7/vue/webpack/` in our GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: However, we are not quite finished yet, because we may want to bind dynamic
    values to the form inputs sometimes, instead of getting the default ones from
    `v-model`. For example, we only get the Boolean value for the `subscribe` property
    with a single checkbox `<input>` element in our example app, but we want to use
    a string value with `yes` or `no` instead. We will explore how we can change the
    default values in the coming section.
  prefs: []
  type: TYPE_NORMAL
- en: Making dynamic value bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our example app in the previous section, we either get strings or Boolean
    values for the `radio`, `checkbox`, and `select` options by using `v-model` alone.
    We can change this default value by using `true-value`, `false-value`, and `v-bind`.
    Let's dive in.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing Boolean – checkbox elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can bind our custom value to the **single** `checkbox` elements by using
    `true-value` and `false-value`. For example, we can bind the `yes` value to replace
    the default `true` Boolean value with `true-value` and `no` to replace the default `false`
    Boolean value with `false-value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, you get a response of `yes` or `no` when you send the value of the `subscribe` input
    to the server. In the `<script>` block, we now declare `no` as the initial value
    on the `subscribe` property and validate it in the `if` condition block to make
    sure it is always `yes` when you hit the `submit` button, otherwise we push the
    error message to `errors`.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing strings with dynamic properties – radio elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As for the radio button `<input>` elements, we can bind their values to the
    dynamic property in the Vue instance by using `v-bind`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now you get `m` when this radio button is picked and the validation is the same
    as before.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing strings with objects – select options elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We also can use `v-bind` **non-string** values such as `Object` to the form
    inputs. See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now when this option is selected, you get `object` for `typeof this.favourite`
    and `On the Origin of Species` for `this.favourite.title`. There is no change
    in the validation logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also can render `<option>` elements dynamically with dynamic values and
    `v-for`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now we don't have to hardcode the `<option>` elements anymore. We can pull the
    `books` data from elsewhere, such as an API.
  prefs: []
  type: TYPE_NORMAL
- en: Besides binding dynamic values to form inputs, we also can modify the default
    behavior of `v-model` on the input elements. For example, instead of syncing the
    input with the data, we can use the `change` event on them. Let's discover how
    you can do this in the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Using modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue provides these three modifiers, `.lazy`, `.number`, and `.trim`, that we
    can use with `v-model` to change the default events or to add extra functionality
    to the form input. Let's dive in.
  prefs: []
  type: TYPE_NORMAL
- en: Adding .lazy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use `.lazy` with `v-model` to change the `input` event to a `change`
    event on the `<input>` and `<textarea>` elements. See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now the input with the data is synced after `change`, instead of the `input`
    event, which is the default.
  prefs: []
  type: TYPE_NORMAL
- en: Adding .number
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use `.number` with `v-model` to change the default typecast of `string`
    to `number` on `<input>` elements with `type="number"`. See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now you get `number` for `typeof this.form.age` instead of `string` without
    having `.number`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding .trim
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use `.trim` with `v-model` to trim off the whitespace from the user
    input. See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now the text from the user is trimmed automatically. Any extra whitespace at
    the beginning and end of the text will be trimmed off.
  prefs: []
  type: TYPE_NORMAL
- en: While writing custom validation logic is possible, there is already a great
    plugin that helps validate inputs easily and displays the corresponding errors.
    This plugin is called VeeValidate and is a template-based validation framework
    for Vue. Let's discover how we can leverage this plugin in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Validating forms with VeeValidate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With VeeValidate, we will use VeeValidate''s components to validate our HTML
    forms and Vue''s scoped slots to expose the error messages. For example, this
    is a `v-model` input element that we are already familiar with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to validate it with VeeValidate, you just have to wrap the input
    with a `<ValidationProvider>` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, we use the `<ValidationProvider>` component to validate `<input>`
    elements. We can attach validation rules to this component using the `rules` attribute
    and display errors with the `v-slot` directive. Let''s discover how you can make
    use of this plugin to speed up the validation process in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install VeeValidate with npm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `.js` file in the `/src/` directory and add rules by using the `extend`
    function from VeeValidate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: VeeValidate provides many built-in validation rules in separate bundles, such
    as `required`, `email`, `min`, `regex`, and so on, so we can import the specific
    rules that we only need for our apps. So in the preceding code, we import the
    `required` rule and install it through the `extend` function, and then add our
    custom message in the `message` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `/src/vee-validate.js` into the main entry file where the Vue instance
    is initiated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the `ValidationProvider` component locally into a page and start validating
    the input fields on that page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We also can register `ValidationProvider` globally in `/src/main.js` or `/src/plugins/vee-validate.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: But this is probably not a good idea if you don't need this component on every
    page in your app. So if you just need it on a page, then import it locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `ValidationObserver` component locally and add the `passes` object
    to the `v-slot` directive. So let''s refactor theJavaScript code from *step 4*
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We use the `<ValidationObserver>` component to wrap the `<form>` element to
    tell whether it is valid or not before submitting. We also use the `passes` property
    in the object of the scoped slot on the `<ValidationObserver>` component, which
    is used to prevent the form from submitting if it is invalid. Then we pass our
    `processForm` method to the `passes` function in the `v-on:submit` event on the
    form element. Our `processForm` method will not be called if the form is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. We are done. You can see that we no longer need the `checkForm` method
    on the `v-on:submit` event in the `methods` property because VeeValidate has done
    the heavy lifting on validating the elements for us and now our JavaScript code
    is shortened. We only need to wrap around our input fields with `<ValidationProvider>`
    and `<ValidationObserver>` components.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to find out more about the Vue slots and VeeValidate, please visit
    the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://logaretm.github.io/vee-validate/](https://logaretm.github.io/vee-validate/) for
    VeeValidate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://vuejs.org/v2/guide/components-slots.html](https://vuejs.org/v2/guide/components-slots.html) for
    Vue slots'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the example of our preceding Vue app in `/chapter-7/vue/cli/` in
    our GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will find out how we can apply VeeValidate in Nuxt apps in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Applying custom validation to a Nuxt application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's apply the custom validation to the Contact page in the sample website
    that we already have. You have probably noticed that the existing contact form
    has already installed the validation from Foundation (Zurb). Using Foundation's
    form validation is another great way to spice up our HTML form validation.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in knowing more about Foundation, you can find out more
    from their official guide at [https://foundation.zurb.com/sites/docs/abide.html](https://foundation.zurb.com/sites/docs/abide.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'But if we want to do the custom validation with VeeValidate, which we have
    just learned for use in the Vue app, then let''s install and set up what we need
    for Nuxt in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install VeeValidate via npm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a plugin file in the `/plugins/` directory and add the rules we need,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Everything in this file is the same as the file we did in the Vue app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the plugin path in the `plugins` option in the Nuxt config file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an exception for the `/vee-validate/dist/rules.js` file in the `build`
    option in the Nuxt config file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In Nuxt, the `/node_modules/` folder is excluded from transpilation by default,
    and you will get an error reading `Unexpected token export` when using `vee-validate`,
    so we must add `/vee-validate/dist/rules.js` for transpilation before running
    the Nuxt app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `ValidationObserver` and `ValidationProvider` components just as
    we did for the Vue app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove Foundation''s `data-abide` attribute from the `<form>` element, but
    wrap it with the `<ValidationObserver>` component and bind the `submit` event
    with the `passes` and `processForm` methods to the `<form>` element as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This step is also the same as what we did with the Vue app, but we added `ref="observer"`
    in this example as we will need it in *step 8*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start refactoring all the `<input>` elements inside the `<form>` element with
    the `<ValidationProvider>` component, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This step is also the same as what we did with the Vue app, but in this example,
    we added two scoped slot data properties, `invalid` and `validated`, in the `v-slot`
    directive for binding classes conditionally to the `<label>` and `<input>` elements.
    So if we get `true` for both `invalid` and `validated`, then we will bind the `is-invalid-label`
    and `is-invalid-input` classes to the elements, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the Validation Provider's scoped slot data properties,
    please visit [https://vee-validate.logaretm.com/v2/guide/components/validation-provider.html#scoped-slot-data](https://vee-validate.logaretm.com/v2/guide/components/validation-provider.html#scoped-slot-data).
  prefs: []
  type: TYPE_NORMAL
- en: 'Refactor the `data` function in the `<script>` block by adding the following
    data properties to sync up with the `v-model` input elements. We also will add
    two methods in the `methods` option, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This step is also the same as what we did with the Vue app, but in this example,
    we added the `clear` method and the `reset` method in `processForm` for the `methods`
    options. The `<ValidationObserver>` component does not reset the state of the
    form after submitting so we have to do it manually, by passing the observer as
    a reference in *step 6*, and then we can access it from the Vue instance with
    `this.$refs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these three scoped slot data properties, `dirty`, `invalid`, and `validated`,
    to the `<ValidationObserver>` component for toggling the alert and success messages,
    then let''s refactor this component as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In this last step, we added a `submitted` data property with a `false` Boolean
    by default, which will be set to `true` when the form is submitted in the `processForm`
    method. On the other hand, the alert message block will be visible when `invalid`
    and `validated` from the scoped slot are both `true`, and the success message
    block will be visible when both the `submitted` property is `true` and the `dirty`
    scoped slot data property is `false`. We get a `true` Boolean from the `dirty`
    property if one of the input fields is "dirty" – in other words, when a letter
    is present in the input field.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the refactored code in our Nuxt app is quite similar to what
    we did in the Vue standard app. But in the Nuxt app, we added more complex logic
    to the form such as toggling the alert and success messages, binding classes conditionally
    to the `<label>` and `<input>` elements, and resetting the `<ValidationObserver>`
    component whenever the form is submitted. The refactoring process is the same
    for the rest of the input elements, which you can find in the book's GitHub repository
    at `/chapter-7/nuxt-universal/sample-website/`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered Vue form validation with `v-model` on the various
    form inputs. You have learned basic and dynamic value binding, and how to use
    modifiers to change the default input event and typecast. You also have learned
    to use the `vee-validate` plugin to make the validation easier. Finally, we managed
    to apply these to the Nuxt app.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to explore how to add a server-side framework
    in Nuxt apps. You will learn to create a simple API with Koa and integrate it
    with Nuxt, and request the API data using `asyncData` with the HTTP client, Axios.
    Also, you will be introduced to a minimalistic build system based on webpack,
    called Backpack, which will simplify the custom webpack configuration that we
    have been using for the single-file component Vue apps. You will learn how to
    use this build system in Nuxt apps, too. So, stay tuned!
  prefs: []
  type: TYPE_NORMAL
