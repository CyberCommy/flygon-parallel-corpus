- en: Adding Vue Forms
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 添加Vue表单
- en: In this chapter, you will create forms with `v-model` and `v-bind`. You will
    learn to validate forms on the client side before sending the form data to the
    server. You will create forms with basic elements, binding dynamic values and
    using modifiers to modify the input element's behavior. You will also learn to
    use the `vee-validate` plugin for validating forms and applying it to Nuxt apps. It
    is important to learn and understand how to use `v-model` and `v-bind` with Vue
    forms in this chapter because we will use forms in the coming chapters, such as
    in [Chapter 10](808b1fa6-d397-4c97-b45a-95de8238497a.xhtml), *Adding a Vuex Store*,
    and [Chapter 12](8e574c51-68dc-45e2-8a1d-4c04d9c38df5.xhtml), *Creating User Logins
    and API Authentication*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将使用`v-model`和`v-bind`创建表单。您将学习在将表单数据发送到服务器之前在客户端验证表单。您将创建具有基本元素的表单，绑定动态值，并使用修饰符修改输入元素的行为。您还将学习如何使用`vee-validate`插件验证表单并将其应用于Nuxt应用程序。在本章中学习如何在Vue表单中使用`v-model`和`v-bind`非常重要，因为我们将在接下来的章节中使用表单，例如在“添加Vuex存储”第10章和“创建用户登录和API身份验证”第12章中。
- en: 'The topics we will cover in this chapter are the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将涵盖以下主题：
- en: Understanding `v-model`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`v-model`
- en: Validating forms with basic data bindings
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基本数据绑定验证表单
- en: Making dynamic value bindings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动态值绑定
- en: Validating forms with `vee-validate`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`vee-validate`验证表单
- en: Applying Vue forms in Nuxt
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Nuxt中应用Vue表单
- en: Understanding v-model
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解`v-model`
- en: '`v-model` is a Vue directive (a custom built-in Vue HTML attribute) that allows
    us to create a two-way binding on the form''s `input`, `textarea`, and `select`
    elements. You can bind a form input with the Vue data so that the data can be
    updated when the users interact with the input field. `v-model` will always skip
    the initial value you set on the form elements but treats the Vue data as the
    source of truth. So you should declare the initial value on the Vue side, inside
    the `data` option or function.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-model`是Vue指令（自定义内置Vue HTML属性），允许我们在表单的`input`、`textarea`和`select`元素上创建双向绑定。您可以将表单输入与Vue数据绑定，以便在用户与输入字段交互时更新数据。`v-model`始终会跳过您在表单元素上设置的初始值，而将Vue数据视为真相的来源。因此，您应该在Vue端，在`data`选项或函数内声明初始值。'
- en: '`v-model` will pick the appropriate way to update the element based on the
    input type, which means that if you use it on the form input with `type="text"`,
    it will use `value` as the property and `input` as the event to perform the two-way
    binding for you. Let''s look at what falls under this directive in the coming
    sections.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-model`将根据输入类型选择适当的方式来更新元素，这意味着如果您在`type="text"`的表单输入上使用它，它将使用`value`作为属性，并使用`input`作为事件来执行双向绑定。让我们看看在接下来的部分中包括哪些内容。'
- en: Using v-model in text and textarea elements
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在文本和文本区域元素中使用v-model
- en: 'Remember the two-way binding that we implemented with `v-model` to create custom
    input components in [Chapter 5](099c1dc8-8dfa-46f8-bfbd-bfa036eefbb7.xhtml), *Adding
    Vue Components*? In the *Creating custom input components* section of that chapter,
    we learned that the `v-model` syntax for inputs – `<input v-model="username">` –
    is shorthand for the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在《添加Vue组件》的第5章中使用`v-model`实现双向绑定来创建自定义输入组件吗？在该章节的“创建自定义输入组件”部分，我们学到了输入框的`v-model`语法
    - `<input v-model="username">` - 实际上是以下内容的简写：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This text `input` element, behind the scene, binds the `value` attribute that
    gets the value from a handler, `username`, which gets its value from the `input`
    event. And so, a custom text input component, too, must always use the `value`
    prop and the `input` event in the `model` property as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文本`input`元素在幕后绑定了`value`属性，该属性从处理程序`username`中获取值，而`username`又从`input`事件中获取值。因此，自定义的文本输入组件也必须始终在`model`属性中使用`value`属性和`input`事件，如下所示：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is just because of the nature of a `v-model` input being made of `v-bind:value`
    and `v-on:input`. This is also the same when using the `v-model` directive in
    a `textarea` element, as in the following example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅是因为`v-model`输入的性质是由`v-bind:value`和`v-on:input`组成。当在`textarea`元素中使用`v-model`指令时，情况也是一样的，如下例所示：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This `v-model` `textarea` element is shorthand for the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`v-model` `textarea`元素是以下内容的简写：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This `textarea` input element, behind the scene, binds the `value` attribute
    that gets the value from the handler, `message`, which gets its value from the
    `input` event. And so, a custom `textarea` component, too, must always comply
    with the nature of the `v-model` `textarea` element by using the `value` prop
    and the `input` event in the `model` property as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`textarea`输入元素在幕后绑定了`value`属性，该属性从处理程序`message`中获取值，而`message`又从`input`事件中获取值。因此，自定义的`textarea`组件也必须始终遵守`v-model`
    `textarea`元素的性质，通过使用`value`属性和`input`事件在`model`属性中，如下所示：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In short, the `v-model` text `input` element and the `v-model` `textarea` input
    element always bind the `value` attribute with a handler for getting the new value
    on the input event, and so must the custom input components by adopting the same
    attribute and event. What about `v-model` in checkboxes and radio buttons elements
    then? Let's dive into them in the next section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`v-model`文本`input`元素和`v-model` `textarea`输入元素始终将`value`属性与处理程序绑定，以在输入事件上获取新值，因此自定义输入组件也必须采用相同的属性和事件。那么复选框和单选按钮元素中的`v-model`又是怎样的呢？让我们在下一节中深入了解它们。
- en: Using v-model in checkbox and radio elements
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在复选框和单选按钮元素中使用v-model
- en: 'On the other hand, `v-model` `checkbox` and `radio` button input elements always
    bind the `checked` attribute with a Boolean value that is updated on the `change`
    event, as in the following example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`v-model`复选框和单选按钮输入元素始终将`checked`属性与在`change`事件上更新的布尔值绑定，如下例所示：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `v-model` `checkbox` input element in the preceding code snippet is indeed
    shorthand for the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，`v-model` `checkbox`输入元素确实是以下内容的简写：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And so, a custom checkbox input element, too, must always comply with the nature
    of the `v-model` checkbox input element (shown in the preceding code block) by
    adopting the `checked` prop and the `change` event in the `model` property as
    follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，自定义的复选框输入元素也必须始终遵守`v-model`复选框输入元素的性质（如前面的代码块中所示），通过在`model`属性中采用`checked`属性和`change`事件，如下所示：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The same applies to the `v-model` radio button input elements, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于`v-model`单选按钮输入元素，如下所示：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding `v-model` element is another shorthand for the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`v-model`元素是以下内容的另一种简写：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And so, a custom radio button input element, too, must always comply with the
    nature of the `v-model` element as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，自定义的单选按钮输入元素也必须始终遵守`v-model`元素的性质，如下所示：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In short, as the `v-model` `checkbox` and `radio` button input elements always
    bind the `value` attribute and are updated on the `change` event, so must the
    custom input components by adopting the same attribute and event. Now, let's take
    a look at how `v-model` works in `select` elements in the next section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`v-model`、`checkbox` 和 `radio` 按钮输入元素总是绑定 `value` 属性，并在 `change` 事件上更新，因此自定义输入组件也必须采用相同的属性和事件。现在，让我们看看
    `v-model` 在下一节中如何在 `select` 元素中工作。
- en: Using v-model in select elements
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在选择元素中使用 v-model
- en: 'Not surprisingly, v-model `select` input elements always bind the `value` attribute
    with a handler for getting its selected value on the `change` event, as in the
    following example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，`v-model` `select` 输入元素总是将 `value` 属性与在 `change` 事件上获取其选定值的处理程序绑定，如下例所示：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding `v-model` `checkbox` input element is just another shorthand
    for the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `v-model` `checkbox` 输入元素只是以下内容的另一种简写：
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And so, a custom `checkbox` input element, too, must always comply with the
    nature of the `v-model` element by using the `value` prop and the `change` event
    in the `model` property as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，自定义的 `checkbox` 输入元素也必须始终遵守 `v-model` 元素的特性，使用 `value` 属性和 `model` 属性中的 `change`
    事件，如下所示：
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, `v-model` is syntactic sugar on top of `v-bind`, which binds
    a value to the markup, and `v-on`, which updates data on the user input events,
    which can be either `change` or `input` events. In short, `v-model` combines `v-bind`
    and `v-on` under the hood – but it is important to understand what lies underneath
    the syntax as a Vue/Nuxt apps developer.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`v-model` 在 `v-bind` 的基础上是一种语法糖，它将一个值绑定到标记上，并在用户输入事件上更新数据，这些事件可以是 `change`
    或 `input` 事件。简而言之，`v-model` 在幕后结合了 `v-bind` 和 `v-on`，但重要的是要理解语法下面的内容，作为Vue/Nuxt应用程序开发者。
- en: You can find the examples we've covered in this section in `/chapter-7/vue/html/`
    in our GitHub repository.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在我们的GitHub存储库的`/chapter-7/vue/html/`目录中找到本节中涵盖的示例。
- en: Now that you have discovered how the `v-model` directive works in the form's
    input elements, let's use these `v-model` elements on a form and validate them
    in the next section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 `v-model` 指令在表单输入元素中的工作方式，让我们在下一节中在表单上使用这些 `v-model` 元素并对其进行验证。
- en: Validating forms with basic data bindings
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基本数据绑定验证表单
- en: A form is a document for collecting information. The HTML `<form>` element is
    a form where the data or information can be collected from the web user. This
    element requires `<input>` elements in it to specify what data we want to collect.
    But before accepting the data, we usually would want to validate and filter it
    so that we get genuine and correct data from the user.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表单是收集信息的文件。HTML `<form>` 元素是一个可以从网页用户那里收集数据或信息的表单。这个元素需要在其中使用 `<input>` 元素来指定我们想要收集的数据。但在接受数据之前，我们通常会希望对其进行验证和过滤，以便从用户那里获得真实和正确的数据。
- en: 'Vue allows us to validate the data easily from the `v-model` input elements,
    so let''s get started with a single-file components (SFC) Vue app and webpack,
    which you learned about in [Chapter 5](099c1dc8-8dfa-46f8-bfbd-bfa036eefbb7.xhtml), *Adding
    Vue Components*, in the *Compiling single-file components with webpack *section.
    First, we will create a very simple form with a `submit` button and the markups
    for displaying the error message in the `<template>` block as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Vue允许我们轻松地从 `v-model` 输入元素中验证数据，因此让我们从单文件组件（SFC）Vue应用程序和webpack开始，你可以在[第5章](099c1dc8-8dfa-46f8-bfbd-bfa036eefbb7.xhtml)中了解到，*添加Vue组件*，在*使用webpack编译单文件组件*部分。首先，我们将创建一个非常简单的表单，其中包括一个
    `submit` 按钮和在 `<template>` 块中显示错误消息的标记，如下所示：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will add the rest of the input elements inside `<form>` later. Now, let''s
    set up the basic structure and understand what we will need. We use `v-on:submit.prevent`
    to prevent the browser from sending the form data by default because we will handle
    the submission with the `checkForm` method in the Vue instance in the `<script>`
    block:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: On the JavaScript side, we define an array to hold the errors that we might
    get in the validation process. The `checkForm` logic validates the required fields
    that we will add later in this section. If the required field fails to pass the
    validation then we push the error message to `errors`. When the form is filled
    in correctly and/or no error is found, it will be passed to the `processForm`
    logic, where we can do something further with the form data before sending it
    to the server.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Validating text elements
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get started by adding an `<input>` element for single-line text:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the `<script>` block, we define a `name` property in the `data` function
    that holds the initial `null` value and will be updated on the `input` event from
    the `<input>` element. We validate the `name` data in the `if` condition block
    when you hit the `submit` button; if it has no data provided, then we `push` the
    error message to `errors`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Validating textarea elements
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next element we are adding is `<textarea>` for multi-line text, which works
    the same way as `<input>`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the `<script>` block, we define a `message` property in the `data` function
    that holds the initial `null` value and will be updated on the `input` event from
    the `<textarea>` element. We validate the `message` data in the `if` condition
    block when you hit the `submit` button; if it has no data provided, then we `push`
    the error message to `errors`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Validating checkbox elements
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next element is a single checkbox `<input>` element that will hold the
    default Boolean value:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We also will add the following multiple checkbox `<input>` elements that are
    bound to the same array, that is, `books: []`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the `<script>` block, we define a `subscribe` property in the `data` function
    that holds the initial Boolean `false` value and will be updated on the `change`
    event from the checkbox `<input>` element. We validate the `subscribe` data in
    the `if` condition block when you hit the `submit` button; if it has no data provided
    or it is `false`, then we `push` the error message to `errors`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: We do the same for the multiple checkbox `<input>` elements by defining a `books`
    property that holds the initial empty array and will be updated on the `change`
    event from the checkbox `<input>` element. We validate the `books` data in the
    `if` condition block; if its length is `0` then we `push` the error message to
    `errors`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Validating radio elements
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next element is multiple radio button `<input>` elements that are bound
    to the same property name, that is, `gender`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the `<script>` block, we define a `gender` property in the `data` function
    that holds the initial `null` value and will be updated on the `change` event
    from the selected `<input>` radio button element. We validate the `gender` data
    in the `if` condition block when you hit the `submit` button. If it has no data
    provided, then we `push` the error message to `errors`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Validating select elements
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next element is a single `<select>` element with multiple `<option>` elements
    as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And the last one is multiple `<select>` elements with multiple `<option>` elements
    that are bound to the same `Array`, that is, `favourites: []`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the `<script>` block, we define a `favourites` property in the `data` function
    that holds the initial `null` value and will be updated on the `change` event
    from the `<select>` element. We validate the `favourites` data in the `if` condition
    block when you hit the `submit` button. If it has no data provided, then we `push`
    the error message to `errors`. We do the same for the multiple `<select>` elements
    by defining a `favourites` property that holds the initial empty array and will
    be updated on the `change` event from the `<select>` element. We validate the
    `favourites` data in the `if` condition block; if its length is `0` then we push
    the error message to `errors`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we will finish up this form with the `processForm` logic, which is called
    only when no error is found in the `checkForm` logic. We use a Node.js package,
    `qs`, to stringify the `this.form` object so we can send the data to the server in
    the following format:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s install `qs` with npm:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then we can use it as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We send the data using `axios` and get the response (usually in JSON format)
    back from the server, then you can do something with the response data, such as
    displaying a "success" or "failed" message on the server side.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: For more information about `qs`, visit [https://www.npmjs.com/package/qs](https://www.npmjs.com/package/qs),
    and for `axios`, please visit [https://github.com/axios/axios](https://github.com/axios/axios).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: You can find the preceding example app in `/chapter-7/vue/webpack/` in our GitHub
    repository.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: However, we are not quite finished yet, because we may want to bind dynamic
    values to the form inputs sometimes, instead of getting the default ones from
    `v-model`. For example, we only get the Boolean value for the `subscribe` property
    with a single checkbox `<input>` element in our example app, but we want to use
    a string value with `yes` or `no` instead. We will explore how we can change the
    default values in the coming section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Making dynamic value bindings
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our example app in the previous section, we either get strings or Boolean
    values for the `radio`, `checkbox`, and `select` options by using `v-model` alone.
    We can change this default value by using `true-value`, `false-value`, and `v-bind`.
    Let's dive in.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Replacing Boolean – checkbox elements
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can bind our custom value to the **single** `checkbox` elements by using
    `true-value` and `false-value`. For example, we can bind the `yes` value to replace
    the default `true` Boolean value with `true-value` and `no` to replace the default `false`
    Boolean value with `false-value`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, you get a response of `yes` or `no` when you send the value of the `subscribe` input
    to the server. In the `<script>` block, we now declare `no` as the initial value
    on the `subscribe` property and validate it in the `if` condition block to make
    sure it is always `yes` when you hit the `submit` button, otherwise we push the
    error message to `errors`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Replacing strings with dynamic properties – radio elements
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As for the radio button `<input>` elements, we can bind their values to the
    dynamic property in the Vue instance by using `v-bind`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now you get `m` when this radio button is picked and the validation is the same
    as before.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Replacing strings with objects – select options elements
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We also can use `v-bind` **non-string** values such as `Object` to the form
    inputs. See the following example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now when this option is selected, you get `object` for `typeof this.favourite`
    and `On the Origin of Species` for `this.favourite.title`. There is no change
    in the validation logic.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'We also can render `<option>` elements dynamically with dynamic values and
    `v-for`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now we don't have to hardcode the `<option>` elements anymore. We can pull the
    `books` data from elsewhere, such as an API.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Besides binding dynamic values to form inputs, we also can modify the default
    behavior of `v-model` on the input elements. For example, instead of syncing the
    input with the data, we can use the `change` event on them. Let's discover how
    you can do this in the next topic.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Using modifiers
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue provides these three modifiers, `.lazy`, `.number`, and `.trim`, that we
    can use with `v-model` to change the default events or to add extra functionality
    to the form input. Let's dive in.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Adding .lazy
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use `.lazy` with `v-model` to change the `input` event to a `change`
    event on the `<input>` and `<textarea>` elements. See the following example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now the input with the data is synced after `change`, instead of the `input`
    event, which is the default.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Adding .number
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use `.number` with `v-model` to change the default typecast of `string`
    to `number` on `<input>` elements with `type="number"`. See the following example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now you get `number` for `typeof this.form.age` instead of `string` without
    having `.number`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Adding .trim
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use `.trim` with `v-model` to trim off the whitespace from the user
    input. See the following example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now the text from the user is trimmed automatically. Any extra whitespace at
    the beginning and end of the text will be trimmed off.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: While writing custom validation logic is possible, there is already a great
    plugin that helps validate inputs easily and displays the corresponding errors.
    This plugin is called VeeValidate and is a template-based validation framework
    for Vue. Let's discover how we can leverage this plugin in the next section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Validating forms with VeeValidate
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With VeeValidate, we will use VeeValidate''s components to validate our HTML
    forms and Vue''s scoped slots to expose the error messages. For example, this
    is a `v-model` input element that we are already familiar with:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you want to validate it with VeeValidate, you just have to wrap the input
    with a `<ValidationProvider>` component:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In general, we use the `<ValidationProvider>` component to validate `<input>`
    elements. We can attach validation rules to this component using the `rules` attribute
    and display errors with the `v-slot` directive. Let''s discover how you can make
    use of this plugin to speed up the validation process in the following steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Install VeeValidate with npm:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a `.js` file in the `/src/` directory and add rules by using the `extend`
    function from VeeValidate:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: VeeValidate provides many built-in validation rules in separate bundles, such
    as `required`, `email`, `min`, `regex`, and so on, so we can import the specific
    rules that we only need for our apps. So in the preceding code, we import the
    `required` rule and install it through the `extend` function, and then add our
    custom message in the `message` property.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `/src/vee-validate.js` into the main entry file where the Vue instance
    is initiated:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Import the `ValidationProvider` component locally into a page and start validating
    the input fields on that page:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We also can register `ValidationProvider` globally in `/src/main.js` or `/src/plugins/vee-validate.js`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: But this is probably not a good idea if you don't need this component on every
    page in your app. So if you just need it on a page, then import it locally.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `ValidationObserver` component locally and add the `passes` object
    to the `v-slot` directive. So let''s refactor theJavaScript code from *step 4*
    as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We use the `<ValidationObserver>` component to wrap the `<form>` element to
    tell whether it is valid or not before submitting. We also use the `passes` property
    in the object of the scoped slot on the `<ValidationObserver>` component, which
    is used to prevent the form from submitting if it is invalid. Then we pass our
    `processForm` method to the `passes` function in the `v-on:submit` event on the
    form element. Our `processForm` method will not be called if the form is invalid.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: That's it. We are done. You can see that we no longer need the `checkForm` method
    on the `v-on:submit` event in the `methods` property because VeeValidate has done
    the heavy lifting on validating the elements for us and now our JavaScript code
    is shortened. We only need to wrap around our input fields with `<ValidationProvider>`
    and `<ValidationObserver>` components.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to find out more about the Vue slots and VeeValidate, please visit
    the following links:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[https://logaretm.github.io/vee-validate/](https://logaretm.github.io/vee-validate/) for
    VeeValidate'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://vuejs.org/v2/guide/components-slots.html](https://vuejs.org/v2/guide/components-slots.html) for
    Vue slots'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the example of our preceding Vue app in `/chapter-7/vue/cli/` in
    our GitHub repository.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will find out how we can apply VeeValidate in Nuxt apps in the following
    section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Applying custom validation to a Nuxt application
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's apply the custom validation to the Contact page in the sample website
    that we already have. You have probably noticed that the existing contact form
    has already installed the validation from Foundation (Zurb). Using Foundation's
    form validation is another great way to spice up our HTML form validation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in knowing more about Foundation, you can find out more
    from their official guide at [https://foundation.zurb.com/sites/docs/abide.html](https://foundation.zurb.com/sites/docs/abide.html).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'But if we want to do the custom validation with VeeValidate, which we have
    just learned for use in the Vue app, then let''s install and set up what we need
    for Nuxt in the following steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Install VeeValidate via npm:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a plugin file in the `/plugins/` directory and add the rules we need,
    as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Everything in this file is the same as the file we did in the Vue app.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the plugin path in the `plugins` option in the Nuxt config file:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add an exception for the `/vee-validate/dist/rules.js` file in the `build`
    option in the Nuxt config file:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In Nuxt, the `/node_modules/` folder is excluded from transpilation by default,
    and you will get an error reading `Unexpected token export` when using `vee-validate`,
    so we must add `/vee-validate/dist/rules.js` for transpilation before running
    the Nuxt app.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `ValidationObserver` and `ValidationProvider` components just as
    we did for the Vue app:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Remove Foundation''s `data-abide` attribute from the `<form>` element, but
    wrap it with the `<ValidationObserver>` component and bind the `submit` event
    with the `passes` and `processForm` methods to the `<form>` element as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This step is also the same as what we did with the Vue app, but we added `ref="observer"`
    in this example as we will need it in *step 8*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Start refactoring all the `<input>` elements inside the `<form>` element with
    the `<ValidationProvider>` component, as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This step is also the same as what we did with the Vue app, but in this example,
    we added two scoped slot data properties, `invalid` and `validated`, in the `v-slot`
    directive for binding classes conditionally to the `<label>` and `<input>` elements.
    So if we get `true` for both `invalid` and `validated`, then we will bind the `is-invalid-label`
    and `is-invalid-input` classes to the elements, respectively.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the Validation Provider's scoped slot data properties,
    please visit [https://vee-validate.logaretm.com/v2/guide/components/validation-provider.html#scoped-slot-data](https://vee-validate.logaretm.com/v2/guide/components/validation-provider.html#scoped-slot-data).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Refactor the `data` function in the `<script>` block by adding the following
    data properties to sync up with the `v-model` input elements. We also will add
    two methods in the `methods` option, as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This step is also the same as what we did with the Vue app, but in this example,
    we added the `clear` method and the `reset` method in `processForm` for the `methods`
    options. The `<ValidationObserver>` component does not reset the state of the
    form after submitting so we have to do it manually, by passing the observer as
    a reference in *step 6*, and then we can access it from the Vue instance with
    `this.$refs`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these three scoped slot data properties, `dirty`, `invalid`, and `validated`,
    to the `<ValidationObserver>` component for toggling the alert and success messages,
    then let''s refactor this component as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this last step, we added a `submitted` data property with a `false` Boolean
    by default, which will be set to `true` when the form is submitted in the `processForm`
    method. On the other hand, the alert message block will be visible when `invalid`
    and `validated` from the scoped slot are both `true`, and the success message
    block will be visible when both the `submitted` property is `true` and the `dirty`
    scoped slot data property is `false`. We get a `true` Boolean from the `dirty`
    property if one of the input fields is "dirty" – in other words, when a letter
    is present in the input field.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the refactored code in our Nuxt app is quite similar to what
    we did in the Vue standard app. But in the Nuxt app, we added more complex logic
    to the form such as toggling the alert and success messages, binding classes conditionally
    to the `<label>` and `<input>` elements, and resetting the `<ValidationObserver>`
    component whenever the form is submitted. The refactoring process is the same
    for the rest of the input elements, which you can find in the book's GitHub repository
    at `/chapter-7/nuxt-universal/sample-website/`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered Vue form validation with `v-model` on the various
    form inputs. You have learned basic and dynamic value binding, and how to use
    modifiers to change the default input event and typecast. You also have learned
    to use the `vee-validate` plugin to make the validation easier. Finally, we managed
    to apply these to the Nuxt app.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to explore how to add a server-side framework
    in Nuxt apps. You will learn to create a simple API with Koa and integrate it
    with Nuxt, and request the API data using `asyncData` with the HTTP client, Axios.
    Also, you will be introduced to a minimalistic build system based on webpack,
    called Backpack, which will simplify the custom webpack configuration that we
    have been using for the single-file component Vue apps. You will learn how to
    use this build system in Nuxt apps, too. So, stay tuned!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
