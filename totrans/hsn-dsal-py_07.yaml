- en: Hashing and Symbol Tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have previously looked at **arrays** and **lists**, where items are stored
    in sequence and accessed by index number. Index numbers work well for computers.
    They are integers so they are fast and easy to manipulate. However, they don't
    always work so well for us. For example, if we have an address book entry, let's
    say at index number 56, that number doesn't tell us much. There is nothing to
    link a particular contact with number 56\. It is difficult to retrieve an entry
    from the list using the index value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to look at a data structure that is better suited
    to this kind of problem: a dictionary. A dictionary uses a keyword instead of
    an index number, and it stores data in `(key, value)` pairs. So, if that contact
    was called *James*, we would probably use the keyword *James* to locate the contact.
    That is, instead of accessing the contact by calling *contacts [56]*, we would
    use *contacts* `james`.'
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries are a widely used data structure, often built using hash tables.
    As the name suggests, hash tables rely on a concept called **hashing**. A hash
    table data structure stores the data in `key/value` pairs, where keys are obtained
    by applying a hash function to it. It stores the data in a very efficient way
    so that retrieval can be very fast. We will discuss all the related issues in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Hashing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different functions with elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no additional technical requirement, except for the fact that Python
    needs to be installed on the system. Here is the GitHub link for the source code
    discussed in this chapter: [https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Hashing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hashing is a concept in which, when we give data of an arbitrary size to a function, we
    get a small simplified value. This function is called a **hash function**. Hashing
    uses a hash function that maps the given data to another range of data, so that
    a new range of data can be used as an index in the hash table. More specifically,
    we will use hashing to convert strings into integers. In our discussions in this
    chapter, we are using strings to convert into integers, however, it can be any
    other data type which can be converted into integers. Let's look at an example
    to better understand the concept. We want to hash the expression `hello world`,
    that is, we want to get a numeric value that we could say *represents* the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can obtain the unique ordinal value of any character by using the `ord()`
    function. For example, the `ord(''f'')` function gives 102\. Further, to get the
    hash of the whole string, we could just sum the ordinal numbers of each character
    in the string. See the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The obtained numeric value, `1116`, for the whole `hello world` string is called
    the **hash of the string**. Consider the following diagram to see the ordinal
    value of each character in the string that results in the hash value `1116`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/12710178-03f0-4efd-8f50-b84231ea4f63.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding approach is used to obtain the hash value for a given string
    and seems to work fine. However, note that we could change the order of the characters
    in the string and we would have got the same hash; see the following code snippet
    where we get the same hash value for the `world hello` string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, there would be the same hash value for the `gello xorld` string, as
    the sum of the ordinal values of the characters for this string would be the same
    since `g` has an ordinal value that is one less than that of `h`, and `x` has
    an ordinal value that is one greater than that of `w`. See the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the following diagram, where we can observe that the hash value for
    this string is again, `1116`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/623ed462-1cfe-4b45-b619-692367501b52.png)'
  prefs: []
  type: TYPE_IMG
- en: Perfect hashing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **perfect hashing function** is the one by which we get a unique hash value
    for a given string (it can be any data type, here it is a string as we are limiting
    the discussion to strings for now). In practice, most of the hashing functions
    are imperfect and face collisions. This means that a hash function gives the same
    hash value to more than one string; that is undesirable because a perfect hash
    function should return a unique hash value to a string. Normally, hashing functions
    need to be very fast, so trying to create a function that gives us a unique hash
    value for each string is normally not possible. Hence, we accept this fact and
    we know that we may get some collisions, that is, two or more strings may have
    the same hash value. Therefore, we try to find a strategy to resolve the collisions
    rather than trying to find a perfect hash function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid the collisions of the previous example, we could, for example, add
    a multiplier, so that the ordinal value of each character is multiplied by a value
    that continuously increases as we progress in the string. Next, the hash value
    of the string is obtained by adding the multiplied ordinal value of each character.
    To better understand the concept, refer to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a488b9e9-4cb8-4039-8c67-4954d1527d26.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, the ordinal value of each character is progressively
    multiplied by a number. Note that the last row is the result of multiplying the
    values; row two has the ordinal values of each character; row three shows the
    multiplier value; and, in row four, we get values by multiplying the values of
    row two and three so that `104 x 1` equals `104`. Finally, we add all of these
    multiplied values to get the hash value of the `hello world` string, that is, `6736`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this concept is shown in the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test this function on the strings that we used earlier, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this program, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that, this time, we get different hash values for these three strings.
    Still, this is not a perfect hash. Let''s try the strings, `ad` and `ga`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We still get the same hash value for two different strings. Therefore, we need
    to devise a strategy for resolving such collisions. We shall look at that shortly,
    but first, we will study an implementation of a hash table.
  prefs: []
  type: TYPE_NORMAL
- en: Hash tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A** hash table** is a data structure where elements are accessed by a keyword
    rather than an index number, unlike in **lists** and **arrays**. In this data
    structure, the data items are stored in key/value pairs similar to dictionaries.
    A hash table uses a hashing function in order to find an index position where
    an element should be stored and retrieved. This gives us fast lookups since we
    are using an index number that corresponds to the hash value of the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each position in the hash table data structure is often called a **slot** or
    **bucket** andcan store an element. So, each data item in the form of `(key, value)` pairs
    would be stored in the hash table at a position that is decided by the hash value
    of the data. For example, the hashing function maps the input string names to
    a hash value; the `hello world` string is mapped to a hash value of 92, which
    finds a slot position in the hash table. Consider the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b737f679-af81-47f6-ada2-c7beb23d6de8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To implement the hash table, we start by creating a class to hold hash table
    items. These need to have a key and a value since our hash table is a `{key-value}`
    store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us a very simple way to store items. Next, we start working on the
    hash table class itself. As usual, we start off with a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The hash table uses a standard Python list to store its elements. Let''s set
    the size of the hash table to 256 elements to start with. Later, we will look
    at strategies for how to grow the hash table as we begin filling it up. We will
    now initialize a list containing 256 elements in the code. These are the positions
    where the elements are to be stored—the slots or buckets. So, we have 256 slots
    to store elements in the hash table. Finally, we add a counter for the number
    of actual hash table elements we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c5ea5ffe-6a97-4132-837e-830e98b472c1.png)'
  prefs: []
  type: TYPE_IMG
- en: It is important to note the difference between the size and count of a table. The
    size of a table refers to the total number of slots in the table (used or unused).
    The count of the table refers to the number of slots that are filled, meaning
    the number of actual `(key-value)` pairs that have been added to the table.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have to decide on adding our hashing function to the table. We can use
    the same hash function that returns the sum of ordinal values for each character
    in the strings with a slight change. Since our hash table has 256 slots, that
    means we need a hashing function that returns a value in the range of 1 to 256
    (the size of the table). A good way of doing it is to return the remainder of
    dividing the hash value by the size of the table since the remainder would surely
    be an integer value between 0 and 255.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the hashing function is only meant to be used internally by the class, we
    put an underscore (`_`) at the beginning of the name to indicate this. This is
    a normal Python convention for indicating that something is meant for internal
    use. Here is the implementation of the `hash` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For the time being, we are going to assume that keys are strings. We shall discuss
    how one can use non-string keys later. For now, the `_hash()` function is going
    to generate the hash value for a string.
  prefs: []
  type: TYPE_NORMAL
- en: Storing elements in a hash table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To store the elements in the hash table, we add them to the table with the `put()`
    function and retrieve them with the `get()` function. First, we will look at the
    implementation of the `put()` function. We start by embedding the key and the
    value into the `HashItem` class and then compute the hash value of the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation of the `put` function to store the elements in the
    hash table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once we know the hash value of the key, it will be used to find the position
    where the element should be stored in the hash table. Hence, we need to find an
    empty slot. We start at the slot that corresponds to the hash value of the key.
    If that slot is empty, we insert our item there.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the slot is not empty and the key of the item is not the same as
    our current key, then we have a collision. It means that we have a hash value
    for the item that is the same as some previously stored item in the table. This
    is where we need to figure out a way to handle a conflict.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following diagram, the **hello world** key string is already
    stored in the table, and there is a collision when a new string, `world hello`, gets
    the same hash value of `92`. Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6fc3a488-d225-45a8-aaec-63afa11aa0df.png)'
  prefs: []
  type: TYPE_IMG
- en: One way of resolving this kind of collision is to find another free slot from
    the position of the collision; this collision resolution process is called **open
    addressing**. We can do this by linearly looking for the next available slot by
    adding `1` to the previous hash value where we get the collision. We can resolve
    this conflict by adding `1` to the sum of the ordinal values of each character
    in the key string, which is further divided by the size of the hash table to obtain
    the hash value. This systematic way of visiting each slot is a linear way of resolving
    collisions and is called **linear probing**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider an example as shown in the following diagram to better understand
    how we resolve this collision. The hash value for the `eggs` key string is `51`.
    Now, there is a collision because we have already used this location to store
    data. Therefore, we add `1` in the hash value that is computed by the sum of the
    ordinal values of each character of the string to resolve the collision. Hence,
    we obtain a new hash value for this key string to store the data—location `52`.
    See the following diagram and code snippet for this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/343bdb1c-ac38-4fc1-a624-10dfbab473ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is to check whether the slot is empty, then get the new
    hash value using the method described. If the slot is empty, to store the new
    element (that means the slot contained `None` previously), then we increase the
    count by one. Finally, we insert the item into the list at the required position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving elements from the hash table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To retrieve the elements from the hash table, the value stored corresponding
    to the key would be returned. Here, we will discuss the implementation of the
    retrieval method—the `get()` method. This method would return the value stored
    in the table corresponding to the given key.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we compute the hash of the given key corresponding to the value
    that is to be retrieved.  Once we have the hash value of the key, we look up the
    hash table at the position of the hash value. If the key item is matched with
    the stored key value at that location, the corresponding `value` is retrieved.
    If that does not match, then we add `1` to the sum of the ordinal values of all
    the characters in the string, similar to what we did at the time of storing the
    data, and we look at the newly obtained hash value. We keep looking until we get
    our key element or we check all the slots in the hash table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an example to understand the concept in the following diagram in four
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We compute the hash value for the given key string, `"egg"`, which turns out
    to be `51`. Then, we compare this key with the stored key value at location `51`,
    but it does not match.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the key does not match, we compute a new hash value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We look up the key at the location of the newly created hash value, which is
    `52`; we compare the key string with the stored key value and, here, it matches,
    as shown in the following diagram.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The stored value is returned corresponding to this key value in the hash table.
    See the following diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/a5db02a4-57a6-4528-ab70-45ebc3299844.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To implement this retrieval method that is, the `get()` method, we start by
    calculating the hash of the key. Next, we look up at the computed hash value in
    the table. If there is a match, we return the corresponding stored value. Otherwise,
    we keep looking at the new hash value location computed as described. Here is
    the implementation of the `get()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we return `None` if the key was not found in the table. Another good
    alternative may be to raise an exception in case the key does not exist in the
    table.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the hash table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test our hash table, we create `HashTable` and store a few elements in it,
    then try to retrieve them. We will also try to `get()` a key that does not exist.
    We also use the two strings, `ad` and `ga`, which had the collision and returned
    the same hash value by our hashing function. To properly evaluate the work of
    the hash table, we throw this collision as well, just to see that the collision
    is properly resolved. See the example code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code returns the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, looking up the `worst` key returns `None`, since the key does
    not exist. The `ad` and `ga` keys also return their corresponding values, showing
    that the collision between them is properly handled.
  prefs: []
  type: TYPE_NORMAL
- en: Using [] with the hash table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the `put()` and `get()` methods doesn't look very convenient to use. However,
    we would have preferred to be able to treat our hash table as a list, as it would
    be easier to use. For example, we would like to be able to use `ht["good"]` instead
    of `ht.get("good")` for the retrieval of elements from the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be easily done with the special methods, `__setitem__()` and `__getitem__()`.
    See the following code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our test code would be like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we also print the number of elements already stored in the hash
    table using the `count` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Non-string keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most cases in real-time applications, generally, we need to use strings for
    the keys. However, if necessary, you could use any other Python types. If you
    create your own class that you want to use as a key, you will need to override
    the special `__hash__()` function for that class, so that you get reliable hash
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you would still have to calculate the modulo (`%`) of the hash value
    and the size of the hash table to get the slot. That calculation should happen
    in the hash table and not in the key class since the table knows its own size
    (the key class should not know anything about the table that it belongs to).
  prefs: []
  type: TYPE_NORMAL
- en: Growing a hash table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our example, we fixed the hash table size to 256\. It is obvious that, when
    we add the elements to the hash table, we would begin to fill up the empty slots,
    and at some point, all of the slots would be filled up and the hash table will
    be full. To avoid such a situation, we can grow the size of the table when it
    is starting to get full.
  prefs: []
  type: TYPE_NORMAL
- en: 'To grow the size of the hash table, we compare the size and the count in the
    table. `size` is the total number of the slots and `count` denotes the number
    of slots that contains elements. So, if `count` is equal to `size`, that means
    we have filled up the table. The load factor of the hash table is generally used
    to expand the size of the table; that gives us an indication of how many available
    slots of the table have been used. The load factor of the hash table is computed
    by dividing the number of **used** slots by the **total** number of slots in the
    table. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ee3e4e63-871f-4f89-9bfe-83df85d4fe6a.png)'
  prefs: []
  type: TYPE_IMG
- en: As the load factor value approaches 1, it means that the table is going to be
    filled, and we need to grow the size of the table. It is better to grow the size
    of the table before it gets almost full, as the retrieval of elements from the
    table becomes slow when the table fills up. A value of 0.75 for the load factor
    may be a good value to grow the size of the table.
  prefs: []
  type: TYPE_NORMAL
- en: The next question is how much we should increase the size of the table. One
    strategy would be to simply double the size of the table.
  prefs: []
  type: TYPE_NORMAL
- en: Open addressing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The collision resolution mechanism we used in our example was linear probing,
    which is an example of an open addressing strategy. Linear probing is simple since
    we use a fixed number of slots. There are other open addressing strategies as
    well, however, they all share the idea that there is an array of slots. When we
    want to insert a key, we check whether the slot already has an item or not. If
    it does, we look for the next available slot.
  prefs: []
  type: TYPE_NORMAL
- en: If we have a hash table that contains 256 slots, then 256 is the maximum number
    of elements in that hash. Moreover, as the load factor increases, it will take
    longer to find the insertion point for the new element.
  prefs: []
  type: TYPE_NORMAL
- en: Because of these limitations, we may prefer to use a different strategy to resolve
    collisions, such as chaining.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Chaining is another method to handle the problem of collision in hash tables.
    It solves this problem by allowing each slot in the hash table to store a reference
    to many items at the position of a collision. So, at the index of a collision,
    we are allowed to store many items in the hash table. Observe the following diagram—there
    is a collision for the strings, **hello world** and **world hello**. In the case
    of chaining, both items are allowed to store at the location of the **92** hash
    value using a **list**. Here is the example diagram to show collision resolution
    using chaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/46886635-c11e-45e1-bc94-291c680dc461.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In chaining, the slots in the hash table are initialized with empty lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3518632e-5693-470a-87b0-0e6428fe8e49.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When an element is inserted, it will be appended to the list that corresponds
    to that element''s hash value. That is, if you have two elements that both have
    a hash value of `1075`, both of these elements would be added to the list that
    exists in the `1075%256=51` slot of the hash table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d4084896-ca8c-4213-8e75-455df499452e.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows a list of entries with hash value `51`.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining then avoids conflict by allowing multiple elements to have the same
    hash value. Hence, there is no limit on the number of elements that can be stored
    in a hash table, whereas, in the case of linear probing, we had to fix the size
    of the table, which we need to later grow when the table is filled up, depending
    upon the load factor. Moreover, the hash table can hold more values than the number
    of available slots, since each slot holds a list that can grow.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a problem in chaining—it becomes inefficient when a list
    grows at a particular hash value location. As a particular slot has many items,
    searching them can get very slow since we have to do a linear search through the
    list until we find the element that has the key we want. This can slow down retrieval,
    which is not good, since hash tables are meant to be efficient. The following
    diagram demonstrates a linear search through list items until we find a match:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c8def2e4-1a3e-4b25-ba26-fbad0abbafbb.png)'
  prefs: []
  type: TYPE_IMG
- en: So, there is a problem of slow retrieval of items when a particular position
    in a hash table has many entries. This problem can be resolved using another data
    structure in place of using a list that can perform fast searching and retrieval.
    There is a nice choice of using **binary search trees** (**BSTs**), which provide
    fast retrieval, as we discussed in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could simply put an (initially empty) BST in each slot as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f33540e3-5074-4d55-9b5b-2ce497987b10.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, the `51` slot holds a BST, which we use to store and
    retrieve the data items. But we would still have a potential problem—depending
    on the order in which the items were added to the BST, we could end up with a
    search tree that is as inefficient as a list. That is, each node in the tree has
    exactly one child. To avoid this, we would need to ensure that our BST is self-balancing.
  prefs: []
  type: TYPE_NORMAL
- en: Symbol tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Symbol tables are used by compilers and interpreters to keep track of the symbols
    that have been declared and to keep information about them. Symbol tables are
    often built using hash tables since it is important to efficiently retrieve a
    symbol from the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example. Suppose we have the following Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have two symbols, `name` and `age`. They belong to a namespace, which
    could be `__main__`, but it could also be the name of a module if you placed it
    there. Each symbol has a `value`; for example, the `name` symbol has the value, `Joe`, and
    the `age` symbol has the value, `27`. A symbol table allows the compiler or the
    interpreter to look up these values. So, the `name` and `age` symbols become keys
    in the hash table. All of the other information associated with them become the
    `value` of the symbol table entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s not only variables that are symbols, but functions and classes are also
    treated as symbols, and they will also be added to the symbol table so that, when
    any one of them needs to be accessed, they are accessible from the symbol table.
    For example, the `greet()` function and two variables are stored in the symbol
    table in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/58c18771-70c0-454c-91fc-514e05854547.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Python, each module that is loaded has its own symbol table. The symbol
    table is given the name of that module. This way, modules act as namespaces. We
    can have multiple symbols of the same name as long as they exist in different
    symbol tables, and we can access them through the appropriate symbol table. See
    the following example, showing multiple symbol tables in a program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/161c04e4-7336-4910-8a73-47ec4d89feba.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at hash tables. We looked at how to write a hashing
    function to turn string data into integer data. Then, we looked at how we can
    use hashed keys to quickly and efficiently look up the value that corresponds
    to a key.
  prefs: []
  type: TYPE_NORMAL
- en: Further, we looked at the difficulties in the implementation of hash tables
    due to collisions in hash values. This led us to look at collision resolution
    strategies, so we discussed two important collision resolution methods, which
    are linear probing and chaining.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section of this chapter, we studied symbol tables, which are often built
    using hash tables. Symbol tables allow a compiler or an interpreter to look up
    a symbol (such as a variable, function, or class) that has been defined and retrieve
    all information about it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about graphs and other algorithms.
  prefs: []
  type: TYPE_NORMAL
