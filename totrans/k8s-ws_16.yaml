- en: 16\. Kubernetes Admission Controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about Kubernetes admission controllers and use
    them to modify or validate incoming API requests. This chapter describes the utility
    of Kubernetes admission controllers and how they offer to extend the capabilities
    of your Kubernetes cluster. You will learn about several built-in admission controllers
    and the difference between mutating and validating controllers. By the end of
    this chapter, you will be able to create your own custom admission controllers
    and apply this knowledge to build a controller for your required scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 4*, *How to Communicate with Kubernetes (API Server)*, we learned
    how Kubernetes exposes its **Application Programming Interface** (**API**) to
    interact with the Kubernetes platform. You also studied how to use kubectl to
    create and manage various Kubernetes objects. The kubectl tool is simply a client
    to the Kubernetes API server. Kubernetes master nodes host the API server through
    which anyone can communicate with the cluster. The API server provides a way to
    communicate with Kubernetes for not only external actors but also all internal
    components, such as the kubelet running on a worker node.
  prefs: []
  type: TYPE_NORMAL
- en: The API server is the central access point to our cluster. If we want to make
    sure that our organization's default set of best practices and policies are enforced,
    there is no better place to check for and apply them than at the API server. Kubernetes
    provides this exact capability via **admission controllers**.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a moment to understand why admission controllers are useful. Consider,
    for example, that we have a policy of a standard set of labels in all the objects
    to assist in the reporting of groups of objects per business unit. This might
    be important for getting specific data, such as how many Pods are being executed
    by the integration team. If we are managing and monitoring objects based on their
    labels, then any objects without the required labels can hamper our management
    and monitoring practices. Therefore, we would want to implement a policy that
    will prevent an object from being created if these labels are not defined in the
    object specification. This requirement can be easily implemented using admission controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Policy Agent is a good example of how webhooks can be used to build an
    extensible platform to apply standards on the Kubernetes objects. You can find
    more details about it at this link: [https://www.openpolicyagent.org/docs/latest/kubernetes-admission-control](https://www.openpolicyagent.org/docs/latest/kubernetes-admission-control).'
  prefs: []
  type: TYPE_NORMAL
- en: Admission controllers are a set of components that intercept all calls to the
    Kubernetes API server and provide a way to make sure that any requests are meeting
    the desired criteria. It is important to note that the controllers are invoked
    after the API call is authenticated and authorized and before the objects are
    actioned and stored in etcd. This provides a perfect opportunity to implement
    control and governance, apply standards, and accept or reject the API requests
    to keep the cluster in the desired shape. Let's take a look at how admission controllers
    work in the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: How Admission Controllers Work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes provides a set of more than 25 admission controllers. A set of admission
    controllers is enabled by default and the cluster administrator can pass flags
    to the API server to control enabling/disabling the additional controllers (configuring
    the API server in a production-grade cluster is outside the scope of this book).
    These can be broadly divided into two types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mutating admission controllers** allow you to modify the request before it
    gets applied to the Kubernetes platform. `LimitRanger` is one such example, which
    applies the `defaultRequests` to the Pod if it is undefined by the Pod itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validating admission controllers** validate the request and cannot change
    the request object. If this controller rejects the request, it will not be actioned
    by the Kubernetes platform. An example of this would be the `NamespaceExists`
    controller, which rejects the request if the namespace referenced in the request
    is not available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Essentially, admission controllers are executed in two phases. In the first
    phase, mutating admission controllers are executed, and, in the second phase,
    validating admission controllers are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the situation, it might be a good idea to avoid using mutating
    controllers because they change the state of the request, and the caller may not
    be aware of the changes. Instead, you can use a validating controller to reject
    an invalid request and let the caller fix the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'A high-level overview of admission controllers is illustrated in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1: Stages of an API request for creating an object'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_16_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.1: Stages of an API request for creating an object'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the Kubernetes API server receives an API call (which can be made via
    kubectl or the kubelet running on other nodes), it passes the call through the
    following phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Perform authentication and authorization of the call to make sure that the caller
    is authenticated and RBAC policies are applied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the payload through all of the existing mutating controllers. Mutating controllers
    are those that can change the object sent by the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether the object abides by the defined schema and whether all of the
    fields are valid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the payload through all of the existing validating controllers. These controllers
    validate the final objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the objects in the etcd datastore.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can see from *Figure 16.1* that some admission controllers have something
    called **webhooks** attached to them. This might not be true for all admission
    controllers. We will learn more about webhooks in the later sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note that some of the controllers provide functionality both as mutating and
    validating controllers. In fact, a few Kubernetes functions are implemented as
    admission controllers. For example, when a Kubernetes namespace enters the terminating
    state, the `NamespaceLifecycle` admission controller prevents new objects from
    being created in the terminating namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'We will only cover a few admission controllers in this chapter for brevity.
    Please refer to this link for a complete list of the controllers that are available:
    [https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s confirm that our Minikube setup is configured to run admission controllers.
    Run the following command to start Minikube with all of the required plugins enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a response like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.2: Starting up Minikube with all of the required plugins'
  prefs: []
  type: TYPE_NORMAL
- en: to run admission controllers
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_16_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.2: Starting up Minikube with all of the required plugins to run admission
    controllers'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have had an overview of the built-in admission controllers, let's
    take a look at how we can make an admission controller using our own custom logic.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Controllers with Custom Logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, Kubernetes provides a list of controllers with predefined
    functionality. These controllers are baked into the Kubernetes server binary.
    However, what happens if you need to have your own policy or standard to check
    against, and none of the admission controllers fit your requirements?
  prefs: []
  type: TYPE_NORMAL
- en: To address such a requirement, Kubernetes provides something called **admission
    webhooks**. There are two types of admission webhooks, which we will study in
    the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The Mutating Admission Webhook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **mutating admission webhook** is a type of mutating admission controller
    that doesn't have any logic of its own. Instead, it allows you to define a URL
    that will be called by the Kubernetes API server. This URL is the address to our
    webhook. Functionally, a webhook is an HTTPS server that accepts requests, processes
    them, and then responds back.
  prefs: []
  type: TYPE_NORMAL
- en: If multiple URLs are defined, they are processed in a chain, that is, the output
    of the first webhook becomes the input for the second webhook.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes API server sends a payload (the AdmissionReview object) to the
    webhook URL with the request being processed. You can modify the request as per
    your requirement (for example, by adding a custom annotation) and send back a
    modified request. The Kubernetes API server will use the modified object in the
    next stages of creating the resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'The execution flow will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kubernetes API receives a request for creating an object. For example,
    let''s say you want to create a Pod that is defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Kubernetes calls a webhook, defined as `MutatingAdmissionWebHook`, and passes
    the object definition to it. In this case, it's the Pod specification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The webhook (which is the custom code written by you) receives the object and
    modifies it as per the custom rules. Let''s say, for example, it adds the custom
    annotation, `podModified="true"`. After modification, the object will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The webhook returns the modified object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kubernetes will treat the modified object as if it was the original request
    and move on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The flow mentioned earlier can be visualized as follows. Note that the flow
    is simplified so that you can understand the major stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.3: Process flow for the mutating admission webhook'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_16_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.3: Process flow for the mutating admission webhook'
  prefs: []
  type: TYPE_NORMAL
- en: The Validating Admission Webhook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second type of webhook is the validating admission webhook. This hook, similar
    to a mutating admission webhook, doesn't have any logic of its own. Following
    the same pattern, it allows us to define a URL, which ultimately provides the
    logic that decides to accept or reject this call.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference is that a validating webhook cannot modify the request and
    can only allow or reject a request. If this webhook rejects the request, Kubernetes
    will send an error back to the caller; otherwise, it will proceed to execute the
    request further.
  prefs: []
  type: TYPE_NORMAL
- en: How a Webhook Works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Webhooks are deployed as Pods in the Kubernetes cluster, and the Kubernetes
    API server calls them over SSL using the **AdmissionReview** object. This object
    defines the **AdmissionRequest** and **AdmissionResponse** objects. The webhook
    reads the request payload from the AdmissionRequest object and provides the success
    flag and optional changes in the AdmissionResponse object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a top-level definition of the AdmissionReview object. Note
    that AdmissionRequest and AdmissionResponse are both part of the AdmissionReview
    object. The following is an excerpt from the definition of the AdmissionReview
    object in the Kubernetes source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'This snippet is an extract from the Kubernetes source code. You can view more
    details of the AdmissionReview objects at this link: [https://github.com/kubernetes/api/blob/release-1.16/admission/v1beta1/types.go](https://github.com/kubernetes/api/blob/release-1.16/admission/v1beta1/types.go).'
  prefs: []
  type: TYPE_NORMAL
- en: The same AdmissionReview object is used for both mutating and validating admission
    webhooks. A mutating webhook calculates the changes required to meet the custom
    requirements that you have coded in the webhook. These changes (defined as a patch)
    are passed in the `patch` field, along with a `patchType` field in the AdmissionResponse
    object. The API server then applies that patch to the original object and the
    resultant object is persisted in the API server. To validate the webhook, these
    two fields are kept empty.
  prefs: []
  type: TYPE_NORMAL
- en: A validating admission webhook would simply set a flag to accept or reject a
    request, while a mutating admission webhook would set a flag whether or not the
    request was successfully modified as per the request.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's take a closer look at how we can manually patch an object, which
    will help you to build a webhook that can patch an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can manually patch an object using the `kubectl patch` command. As an example,
    let''s say that you want to add a field to the `.metadata.annotation` section
    in an object. To do that, the command would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note the double space before and after the field that we want to add (shown
    in the preceding command as `{"new":"annotation"}`). Let's implement this in an
    exercise where we will also learn how this command can be used with a JSON payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.01: Modifying a ConfigMap Object through a Patch'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will patch a ConfigMap using kubectl. We will add an annotation
    to the ConfigMap object. This annotation can later be used to group objects, similar
    to the use case that we mentioned in the *Introduction* section. Therefore, if
    multiple teams are using a cluster, we would want to track which teams are using
    which resources. Let''s begin the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a namespace with the name `webhooks`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a ConfigMap using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the contents of the ConfigMap using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.4: Getting the contents of the ConfigMap in YAML format'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_16_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.4: Getting the contents of the ConfigMap in YAML format'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s patch the ConfigMap with an annotation. The annotation we want
    to add is `teamname` with the value of `kubeteam`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In *Chapter 6*, *Labels and Annotations*, we learned that annotations are stored
    as key-value pairs. Therefore, a key can have only a value, and if a value already
    exists for the key (in this case, `teamname`), then the value will be overwritten
    by the new value. Therefore, ensure your webhook logic excludes the objects that
    already have the desired configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s apply another patch using detailed patch instructions using JSON
    format to provide the required field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there are three components of the patch: `op` (for operations such
    as `add`), `path` (for the location of the fields to patch), and `value` (which
    is the new value). You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is another way to apply the patch. You can see the preceding command, which
    is instructing Kubernetes to add a new annotation with the key as `custompatched`
    and the value as `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see whether the patch has been applied. Use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.5: Checking the modified annotations on our ConfigMap'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_16_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.5: Checking the modified annotations on our ConfigMap'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the `annotations` field under `metadata`, both annotations
    have been applied to our ConfigMap. The platform team now knows who owns this
    ConfigMap object.
  prefs: []
  type: TYPE_NORMAL
- en: Guidelines for Building a Mutating Admission WebHook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now know all the parts of a working mutating admission webhook. Remember
    that the webhook is just a simple HTTPS server, and you can write it in your language
    of choice. Webhooks are deployed in the cluster as Pods. The Kubernetes API server
    will call these Pods over SSL on port 443 to mutate or validate the objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pseudocode for building a webhook Pod will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: A simple HTTPS server (the webhook) is set up in a Pod to accept POST calls.
    Note that the call must be over SSL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kubernetes will send the AdmissionReview object to the webhook through an HTTPS
    POST call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The webhook code will process the AdmissionRequest object to get the details
    of the object in the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The webhook code will optionally patch the object and set the response flag
    to indicate success or failure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The webhook code will populate the AdmissionResponse section in the AdmissionReview
    object with the updated request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The webhook will respond to the POST call (received in *step 2*) with the AdmissionReview
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Kubernetes API server will assess the response and, based on the flag, accept
    or reject the client request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the code for the webhook, we will specify the path and required modifications
    using JSON. Keep in mind from the previous exercise that, while patching, our
    patch object definition will contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`op` specifies operations such as `add` and `replace`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path` specifies the location of the field we are trying to modify. Refer to
    the output of the command in *Figure 16.5* and note that different fields are
    located in different places. For example, the name is inside the metadata field,
    so the path for this will be `/metadata/name`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` specifies the value of the field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A simple mutating webhook written in Go should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: mutatingcontroller.go
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The complete code for this example can be found at [https://packt.live/2GFRCot](https://packt.live/2GFRCot).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding code, the three main parts are the **AdmissionRequest**
    object, the **patch**, and the **AdmissionResponse** object with the patched information.
  prefs: []
  type: TYPE_NORMAL
- en: So far, in this chapter, we have learned what the admission webhook is and how
    it interacts with the Kubernetes API server. We have also demonstrated that one
    way to change the requested objects is by using a patch. Now, let's apply what
    we have learned until now and deploy a webhook in our Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that all communications between the API server and the webhook are
    over SSL. SSL is a protocol that is used for secure communication over a network.
    To do this, we need to create public and private keys, as you will see in the
    following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have not yet built the code that goes into the webhook. First,
    let's demonstrate how to deploy the Pods (using Deployment) for a webhook using
    a pre-built container, and then we will go on to build the code that goes into
    the Pod to get the webhook up and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.02: Deploying a Webhook'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll deploy a simple pre-built webhook server to Kubernetes.
    Remember that a webhook is just an HTTPS server, and that is exactly what we are
    going to create. When Kubernetes has to call the webhook endpoint over SSL, we
    will need to create a certificate for our call. Once we create our certificates
    for SSL communication, we will use the Kubernetes Deployment object to deploy
    our webhook:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a **Certificate Authority** (**CA**) for a self-signed certificate.
    This CA will be later used to create trust between the Kubernetes and our webhook
    server for the HTTPS call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give you the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.6: Generating a self-signed certificate'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_16_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.6: Generating a self-signed certificate'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about self-signed certificates at this link: [https://aboutssl.org/what-is-self-sign-certificate/](https://aboutssl.org/what-is-self-sign-certificate/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the private key for the SSL call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.7: Creating the private key for the SSL call'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_16_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.7: Creating the private key for the SSL call'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now sign the server certificate with the CA:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the name of the service in this command is the service that is going
    to expose our webhook within the cluster so that the API server can access it.
    We will revisit this name in *step 7*. You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have created a certificate that our server can use. Next, we will just
    create a Kubernetes Secret to load the private key and certificate to our webhook server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Our webhook will run as a Pod, which we will create using a Deployment. To
    do that, first, create a file named `mutating-server.yaml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are linking to the premade image for the server that we have provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Deployment using the YAML file that we created in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Once the server is created, we need to create a Kubernetes Service. Note that
    the Service is accessible through `webhook-server.webhooks.svc`. This string,
    which we used in *step 3* while creating the certificate, is based on the fields
    defined in the following specification, in the format of `<SERVICENAME>.<NAMESPACENAME>.svc`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file, named `mutating-serversvc.yaml`, to define a Service with the
    following specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the definition from the previous step, create the Service using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we have deployed a pre-built webhook and configured certificates
    such that our webhook is ready to accept calls from the Kubernetes API server.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Webhook to Work with Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this stage, we have created and deployed the webhook using a Deployment.
    Now, we need to register the webhook with Kubernetes so that Kubernetes knows
    about it. The way to do this is by creating a `MutatingWebHookConfiguration` object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find more details about MutatingConfigurationWebhook at [https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/](https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows an example of what the configuration object for
    `MutatingWebhookConfiguration` would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are a few notable definitions from the preceding object:'
  prefs: []
  type: TYPE_NORMAL
- en: The `clientConfig.service` section defines the location of the mutating webhook
    (which we deployed in *Exercise 16.02*, *Deploying a Webhook*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `caBundle` section contains the certificate through which SSL trust will
    be established. This is the certificate, encoded in Base64 format. We will explain
    how to encode it in the next section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `rules` section defines what operations need to be intercepted. Here, we
    are instructing Kubernetes to intercept any calls to create a new Pod.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to Encode a Certificate in Base64 Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As pointed out earlier, when the Kubernetes API server calls the webhook, the
    call is encrypted over SSL, and we need to provide the SSL trust certificate in
    the webhook definition. This can be seen in the `caBundle` field in the definition
    of `MutatingWebhookConfiguration` shown in the previous section. The data in this
    field is Base64-encoded, as you learned in *Chapter 10*, *ConfigMaps and Secrets*.
    The following commands can be used to encode a certificate in Base64 format.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, convert the generated file into Base64 format using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we need to convert the generated CA bundle into the Base64 format and
    put it in the YAML file (as mentioned earlier), we need to remove the newline
    (`\n`) characters. The following commands could be used to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Both of these commands do not show any response in the terminal upon successful
    execution. At this stage, you will have the CA bundle inside the `onelinecert.pem`
    file, which you can copy to create your YAML definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 16.01: Creating a Mutating Webhook That Adds an Annotation to a Pod'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we are using the knowledge we have acquired in this and earlier
    chapters to create a mutating webhook that adds a custom annotation to a Pod.
    There can be many use cases for such a webhook. For example, you might want to
    record whether the container image is coming from the previously approved repository
    or not, for future reporting. Extending this further, you can also schedule Pods
    from different repositories on different nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The high-level steps for completing this activity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new namespace named `webhooks`. If it exists already, delete the existing
    namespace and then create it again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate the self-signed CA certificate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a private/public key pair for SSL and sign it with the CA certificate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a secret that holds the private/public key pair generated in the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the webhook code to add a custom annotation in the Pod.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Package the webhook server code as a Docker container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the Docker container to a public repository of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have any difficulty building your own webhook, you can use the code
    available at this link as a reference: [https://packt.live/2R1vJlk](https://packt.live/2R1vJlk).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to avoid building and packaging a webhook, we have provided a pre-built
    container so that you can use it directly in your Deployment. You can use this
    image from Docker Hub: `packtworkshops/the-kubernetes-workshop:webhook`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using this image allows you to skip *steps 5* to *7*.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Deployment that deploys the webhook server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expose the webhooks Deployment as a Kubernetes Service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Base64-encoded version of the CA certificate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `MutatingWebHookConfiguration` object so that Kubernetes can intercept
    the API call and call our webhook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this stage, our webhook has been created. Now, to test whether our webhook
    is working, create a simple Pod with no annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the Pod is created, make sure that the annotation is added to the Pod
    by describing it. Here is a truncated version of the expected output. Note that
    the annotation here is supposed to be added by our webhook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.8: Expected output of Activity 16.01'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_16_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.8: Expected output of Activity 16.01'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 799.
  prefs: []
  type: TYPE_NORMAL
- en: Validating a Webhook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned that the mutating webhook essentially allows the modification
    of Kubernetes objects. The other kind of webhook is called a validating webhook.
    As the name suggests, this webhook does not allow any change in the Kubernetes
    objects; instead, it works as a gatekeeper to our cluster. It allows us to write
    code that can validate any Kubernetes object being requested and allow or reject
    the request based on the conditions that we specify.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand how this can be helpful using an example. Let's assume that
    our Kubernetes cluster is used by many teams, and we want to know which Pods are
    associated with which teams. One solution is to ask all the teams to add a label
    on their Pod (for example, a label with the key as `teamName` and the name of
    the team as the value). As you can guess, it is not a standard Kubernetes feature
    to enforce a set of labels. In this case, we would need to create our own logic
    to disallow Pods that do not have these labels.
  prefs: []
  type: TYPE_NORMAL
- en: One way to achieve this is to write a validating webhook that looks for this
    label in any requests for Pods and reject the creation of the requested Pods if
    this label does not exist. You are going to do exactly this in *Activity 16.02*,
    *Creating a Validating Webhook that Checks for a Label in a Pod* later in the
    chapter. For now, let's take a look at what the code for a validating webhook
    will look like.
  prefs: []
  type: TYPE_NORMAL
- en: Coding a Simple Validating WebHook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at an excerpt from the code for a simple validating webhook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The three main parts that you can observe in this snippet are the AdmissionRequest
    object, the logic to check whether the label exists, and creating the AdmissionResponse
    object with the Allowed flag.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand all the different components required for a validating
    webhook, let's build one in the following activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 16.02: Creating a Validating Webhook That Checks for a Label in a
    Pod'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we will use the knowledge that we have acquired in this and
    earlier chapters to write a validating webhook that verifies whether a label is
    present in the requested Pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'The required steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new namespace named `webhooks`. If it exists already, delete the existing
    namespace and then create it again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate the self-signed CA certificate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a private/public key pair for SSL and sign it with the CA certificate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a secret that holds the private/public key pair generated in the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Even if you have the certificates and secrets from the previous activity, we
    recommend that you discard them and start afresh to avoid any conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: Write the webhook code to check whether a label with the key `teamName` is present.
    If it is not present, reject the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Package the webhook code as a Docker container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the Docker container to a public repository of your choice (quay.io allows
    you to create a free public repository).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have any difficulty in building your own webhook, you can use the code
    available at this link as a reference: [https://packt.live/2FbL7Jv](https://packt.live/2FbL7Jv).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to avoid building and packaging a webhook, we have provided a pre-built
    container so that you can use it directly in your Deployment. You can use this
    image from Docker Hub: `packtworkshops/the-kubernetes-workshop:webhook`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using this image allows you to skip *steps 5* to *7*.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Deployment that deploys the webhook server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expose the webhooks Deployment as a Kubernetes service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Base64-encoded version of the CA certificate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `ValidtingWebhookConfiguration` so that Kubernetes can intercept the
    API call and call our webhook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a simple Pod with no labels and verify that it is being rejected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a simple Pod with the desired labels and verify that it is being created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the Pod is created, make sure that the label is part of the Pod specifications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can test your validating webhook by trying to create a Pod without the
    `teamName` label. It should get rejected with the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.9: Expected output of the Activity 16.02'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_16_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.9: Expected output of the Activity 16.02'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at the following address: [https://packt.live/304PEoD](https://packt.live/304PEoD).'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the Effect of a Webhook on Selected Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you define any webhook (mutating or validating), you can control which
    namespaces will be affected by the webhook by defining the `namespaceSelector`
    parameter. Note that this is only applicable to objects that are namespace-scoped.
    For cluster-scoped objects, such as persistent volumes, this parameter will make
    no difference, and the webhook will be applied.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Not all admission controllers (mutating or validating) can be restricted to
    a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Just like many Kubernetes objects, namespaces can also have labels. We will
    use this property of namespaces to apply a webhook on specific namespaces, as
    you will see in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.03: Creating a Validating Webhook with the Namespace Selector Defined'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will define a validating webhook that enforces a custom
    rule to be applied to Pods created in a `webhooks` namespace. The rule is that
    the Pod must define a label called `teamName`. Since the rule is applicable to
    Pods created in the `webhooks-demo` namespace, all other namespaces can create
    Pods without the label defined.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Before running this exercise, make sure that you have completed *Activity 16.02*,
    *Creating a Validating Webhook that Checks for a Label in a Pod* as we are reusing
    the objects created there. You can refer to the solution in the *Appendix* if
    you are facing any issues with the activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify that the validating webhook we created in *Activity 16.02*, *Creating
    a Validating Webhook that Checks for a Label in a Pod*, still exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, delete the preexisting validating webhook defined in *Activity 16.02*,
    *Creating a Validating Webhook that Checks for a Label in a Pod*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `ValidatingWebHookConfiguration` is a cluster scoped object, and specifying
    the `-n` flag is optional for this command.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.10: Deleting the existing validating webhook'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_16_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.10: Deleting the existing validating webhook'
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete the `webhooks` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `webhooks` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now we should have a clean slate to continue with this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new CA bundle and a private/public key pair to be used in this webhook.
    Generate a self-signed certificate using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.11: Generating a self-signed certificate'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_16_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.11: Generating a self-signed certificate'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Even if you have created the CA and keys in the previous activity, you will
    need to recreate them for this exercise to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a private/public key pair and sign it with the CA certificate using
    the following two commands, one after the other:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get an output that is similar to the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.12: Signing a private/public key pair with our certificate'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_16_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.12: Signing a private/public key pair with our certificate'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a secret that holds the private/public key pair:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to deploy the webhook in the `webhooks` namespace. Create a file
    named `validating-server.yaml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can use the same webhook image created in *Activity 16.02*, *Creating a
    Validating Webhook That Checks for a Label in a Pod*. In this reference YAML,
    we are using the image that we have provided in our repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deploy the webhook server by using the definition from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You might need to wait a bit and check whether the webhook Pods have been created.
    Keep checking the status of the Pods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.13: Checking whether our webhook is online'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_16_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.13: Checking whether our webhook is online'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `-w` flag continuously watches the Pods. You can end the watch
    when all of the Pods are ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have to expose the deployed webhook server via the Kubernetes service.
    Create a file named `validating-serversvc.yaml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note that the webhook service has to be running on port `443`, as this is the
    standard for TLS communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the definition from the previous step to create the service using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a Base64-encoded version of the CA certificate. Use the following commands,
    one after the other:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The first command is to convert the certificate into a PEM format. And the
    second one is to convert the PEM certificate into Base64\. These commands show
    no response. You can inspect the file using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The file contents should be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.14: Contents of the Base64-encoded CA certificate'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_16_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.14: Contents of the Base64-encoded CA certificate'
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the TLS certificates you generate will not look exactly like
    what is shown here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following two commands to clean up the blank lines from our CA certificate
    and add the contents to a new file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The first command shows no response, and the second one prints out the contents
    of `onlinecert.pem`. You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.15: Base64-encoded CA certificate with the line breaks removed'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_16_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.15: Base64-encoded CA certificate with the line breaks removed'
  prefs: []
  type: TYPE_NORMAL
- en: Now we have the Base64-encoded certificate with no blank lines. For the next
    step, we will copy the value that you get in this output, being careful not to
    copy the `$` (which would be `%`, in the case of Zsh) at the end of the value.
    Paste this value in place of `CA_BASE64_PEM` (a placeholder for `caBundle`) in
    `validation-config-namespace-scoped.yaml`, which will be created in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file, named `validation-config-namespace-scoped.yaml`, using the following
    `ValidatingWebHookConfiguration` specification to configure the Kubernetes API
    server to call our webhook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `CA_BASE64_PEM` placeholder will be replaced with the contents of `onelinecert.pem`
    from the previous step. Be careful not to copy any line breaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the webhook, as defined in the previous step. Make sure that you replace
    the `caBundle` field with the certificates created in the earlier steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.16: Creating the ValidatingWebhookConfiguration'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_16_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.16: Creating the ValidatingWebhookConfiguration'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new namespace, called `webhooks-demo`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the `applyValidation=true` label to the `webhooks` namespace, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This label will match the selector defined in *step 14* and make sure our validation
    criteria (enforced by the webhook) applies to this namespace. Note that we don't
    label the `webhooks-demo` namespace, so the validation will *not* apply to this namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now define a Pod without the `teamName` label. Create a file named `target-validating-pod.yaml`
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the definition from the previous step, create the Pod in the `webhooks`
    namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The creation of the Pod should get rejected as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.17: Pod rejected due to the absence of the required label'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_16_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.17: Pod rejected due to the absence of the required label'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that our webhook just checks the `teamName` label in the Pod. The
    Pod creation is rejected as per our namespace selector in the definition from
    *step 14*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, try creating the same Pod in the `webhooks-demo` namespace to see whether
    things go differently:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get this response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We were able to successfully create the Pod in the `webhooks-demo` namespace,
    but we were not able to do so in the `webhooks` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s describe the Pod to get more details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a response similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.18: Checking the specification of our Pod'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_16_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.18: Checking the specification of our Pod'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this Pod does not have any labels, and yet we were able to create
    it. This is because our validating webhook is not watching the `webhooks-demo` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you have learned how a webhook can be configured to make changes
    at the namespace level. This could be useful to test functionality and provide
    different functionality to different teams that might own different namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned that admission controllers provide a way to enforce
    the mutation and validation of objects during create, update, and delete operations.
    It is an easy way to extend the Kubernetes platform to adhere to the standards
    of your organization. They can be used to apply the best practices and policies
    onto the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we learned what mutating and validating webhooks are, how to configure
    them, and how to deploy them on the Kubernetes platform. Webhooks provide a simple
    way to extend Kubernetes and help you to adapt to the requirements of a particular enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous series of chapters, starting from *Chapter 11*, *Build Your
    Own HA Cluster*, to *Chapter 15*, *Monitoring and Autoscaling in Kubernetes*,
    you learned how to set up your highly-available cluster on AWS and run stateless,
    as well as stateful, applications. In the next few chapters, you will learn many
    advanced skills that will help you go beyond just running applications, and enable
    you to leverage many of the powerful administration features offered by Kubernetes
    and maintain the health of your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, in the next chapter, you will learn about the Kubernetes scheduler.
    This is a component that decides the nodes on which a Pod will be scheduled. You
    will also learn how to configure the scheduler to adhere to your needs and how
    you can control Pod placement on a node.
  prefs: []
  type: TYPE_NORMAL
