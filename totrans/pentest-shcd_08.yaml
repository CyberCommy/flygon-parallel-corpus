- en: Exploit Development – Part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will continue our topic about exploit development. First,
    we will continue and complete our previous example by injecting a shellcode. Then,
    we will talk about a new technique, which is used to avoid the NX protection mechanism
    (NX will be explained in the last chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the topics that we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Injecting shellcode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return-oriented programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structured exception handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting shellcode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's continue our example from the previous chapter. After we have control
    of the instruction pointer, what we need is to inject a shellcode and redirect
    the instruction pointer to point at it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that to happen, we will need to find a home for the shellcode. It''s easy,
    actually; it just involves jumping to the stack. What we need now is to find that
    instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start vulnserver, then start the Immunity Debugger as an administrator, and
    from the File menu, attach with vulnserver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00311.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Hit the run program icon and then right-click and select Search for; then,
    select All Commands in all modules to search for any instruction within the application
    itself or any related library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00312.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then what we need to do is jump to the stack to execute our shellcode; so,
    let''s search for the `JMP ESP` instruction and hit Find:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00313.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's copy the address of `JMP ESP` from `kernel32.dll 7DD93132`, then re-run
    vulnserver inside the Immunity Debugger again, and hit the run program icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use any library, not just `kernel32.dll`. However, if you use the system's
    libraries, such as `kernel32.dll`, then the address will change each time Windows
    boots up due to the ASLR mechanism (which will be explained in the last chapter);
    but if you use a library related to the application and not related to the system,
    then the address will not change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, from the attacking machine, edit our exploit to be like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the exploit. The instruction pointer is not pointing at `43434343`,
    which are our `C` characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00314.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we are ready to insert our shellcode. Let''s create one using the Metasploit
    Framework:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This command generates a reverse TCP shell to connect back to my attacking
    machine on port `4321`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00315.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, our final exploit should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s start vulnserver again. Then, set up a listener on our attacking
    machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to try our exploit, and let''s keep our eyes on the listener:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, from our listener shell, we execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00316.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s confirm this using `ipconfig`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00317.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now we have control over our victim machine!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is **return-oriented programming** (**ROP**)?
  prefs: []
  type: TYPE_NORMAL
- en: Let's explain what ROP is in the simplest way. ROP is a technique used to exploit
    buffer overflow vulnerability even if NX is enabled. The ROP technique can pass
    NX protection techniques using ROP gadgets.
  prefs: []
  type: TYPE_NORMAL
- en: ROP gadgets are sequences of addresses for machine instructions, which are stored
    already in the memory. So, if we could change the flow of execution to one of
    these instructions, then we could take control over the application, and we can
    do so without uploading a shellcode. Also, ROP gadgets end with the `ret` instruction.
    If you don't get it yet, it's okay; we will perform an example to fully understand
    what ROP is.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what we need is to install ropper, which is a tool to find ROP gadgets
    within a binary. You can download it via its official repository on GitHub ([https://github.com/sashs/Ropper](https://github.com/sashs/Ropper)), 
    [](https://github.com/sashs/Ropper) or you can follow the instructions given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the next vulnerable code, which will print out, `Starting
    /bin/ls`. Execute the `overflow` function, which will take input from the user
    and then print it out along with the size of the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile it, but without disabling NX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, start `gdb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s confirm that NX is enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00318.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now perform fuzzing and controlling RIP using PEDA instead of the Metasploit
    Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a pattern of `500` characters and save a file named `pattern`.
    Now, let''s read this pattern as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00319.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The program crashed. The next step is to examine the last element in the stack
    to calculate the offset of EIP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We got the last element in the stack as `0x41413741` (if you are using the
    same OS, this address should be the same). Now, let''s see whether the offset
    of this pattern and the next offset will be the exact offset of RIP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00320.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So the exact offset of RIP will start from `105`. Let''s confirm that too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This code should overflow RIP registers with six `B` characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, from inside GDB, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00321.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot indicates that we are going in the right direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since NX is enabled, we can''t upload and run a shellcode, so let''s use ROP
    with the return-to-libc technique, which enables us to use calls from libc itself,
    which could enable us to call the function. Here, we will use the `system` function
    to execute shell commands. Let''s take a look at the system `man` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00322.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What we need is the address of the `system` function and also the location of
    the string of a shell command—luckily, we have that inside our `/bin/ls` code.
  prefs: []
  type: TYPE_NORMAL
- en: The only thing we did was copy the location of the string into the stack. Now,
    we need to find a way to copy the location to the RDI register to enable the system
    function to execute the `ls` command. So, we need the ROP gadget, which can extract
    the address of the string and copy it to the RDI register because the first argument
    should be in the RDI register.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let''s start with the ROP gadget. Let''s search for any ROP gadget related
    to the RDI register. Then, navigate to the location where you installed ropper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00323.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This ROP gadget is perfect: `pop rdi; ret;`, with the address `0x0000000000400653`.
    Now, we need to find out where exactly the `system` function is in the memory,
    from inside GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00324.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have also got the location of the `system` function with the address,
    `0x7ffff7a57590`.
  prefs: []
  type: TYPE_NORMAL
- en: This address may be different on your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get the location of the `/bin/ls` string, using GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00325.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have got the location to the string with the address, `0x400697`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logical order of the stack should be:'
  prefs: []
  type: TYPE_NORMAL
- en: The address of the `system` function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The string pointer, which will be popped to the RDI register
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ROP gadget to extract pop, which is the last element in the stack to the
    RDI register
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we need to push them into the stack in reverse order, using our exploit
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the script to update `input.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, from GDB, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The logical order of the stack should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00326.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It worked! And as you can see, the `ls` command executed successfully. We found
    a way to get around NX protection and exploit this code.
  prefs: []
  type: TYPE_NORMAL
- en: Structured exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Structured exception handling** (**SEH**) is simply an event that occurs
    during the execution of a code. We can see SEH in high-programming languages,
    such as C++ and Python. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is an example of dividing by zero, which will raise an exception. The program
    should change the flow of execution to something else, which is doing whatever
    inside it.
  prefs: []
  type: TYPE_NORMAL
- en: 'SEH consists of two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Exception registration record (SEH)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next exception registration record (nSEH)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They are pushed into the stack in reverse order. So now how to exploit SEH?
    It''s as simple as a regular stack overflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00327.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'This is what our exploit should look like. What we need exactly is to push
    an instruction, **pop pop ret**, into **SEH** to make a jump to **nSEH**. Then,
    push a jump instruction into **nSEH** to make a jump to the shellcode; so, our
    final shellcode should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00328.gif)'
  prefs: []
  type: TYPE_IMG
- en: We will cover a practical scenario in [Chapter 11](part0109.html#37UDA0-5bf3e26315164e77bbeecc4f75207114),
    *Real-World Scenarios – Part 3*, about exploiting SEH.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we have briefly discussed exploit development, starting from fuzzing and
    how to gain control over the instruction pointer. Then, we saw how to find a home
    for a shellcode and change the flow of execution to that shellcode. Finally, we
    talked about a technique called ROP for bypassing the NX protection technique,
    and took a quick look at SEH exploiting techniques.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go through *real-world scenarios* and build an
    exploit for real applications.
  prefs: []
  type: TYPE_NORMAL
