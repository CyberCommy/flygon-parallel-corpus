- en: Parallel Execution of Python Script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python has become the *de facto* standard for network automation. Many network
    engineers already use it on a daily basis to automate networking tasks, from configuration,
    to operation, to troubleshooting network problems. In this chapter, we will visit
    one of the advanced topics in Python: scratching the surface of Python''s multiprocessing
    nature and learning how to use it to accelerate script execution time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How Python code is executed in an OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python multiprocessing library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How a computer executes your Python script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is how your computer''s operating system executes Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you type `python <your_awesome_automation_script>.py` in the shell, Python
    (which runs as a process) instructs your computer processor to schedule a thread (which
    is the smallest unit of processing):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00121.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The allocated thread will start to execute your script, line by line. A thread
    can do anything, including interacting with I/O devices, connecting to routers,
    printing output, performing mathematical equations, and more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the script hits the **End of File** (**EOF**), the thread will be terminated
    and returned to the free pool, to be used by other processes. Then, the script
    is terminated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Linux, you can use `#strace –p <pid>` to trace a specific thread execution.
  prefs: []
  type: TYPE_NORMAL
- en: The more threads that you assign to your script (and that are permitted by your
    processor or OS), the faster your script will run. Actually, threads are sometimes
    called **workers** or **slaves**.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have a feeling that you have this little idea in your head: Why wouldn''t
    we assign a lot of threads, from all cores, to Python script, in order to get
    the job done quickly?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with assigning a lot of threads to one process without special
    handling is the **race condition**. The operating systems will allocate memory
    to your process (in this case, it''s the Python process), to be used at runtime
    and accessed by all threads—*all of them at the same time*. Now, imagine that
    one of those threads reads some data before it''s actually written by another
    thread! You don''t know the order in which the threads will attempt to access
    the shared data; this is the race condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00122.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: One available solution is to make the thread acquire a lock. In fact, Python,
    by default, is optimized to run as a single-threaded process, and has something
    called **Global Interpreter Lock** (**GIL**). GIL does not allow multiple threads
    to execute Python code at the same time, in order to prevent conflicts between
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: But, rather than having multiple threads, why don't we have multiple processes?
  prefs: []
  type: TYPE_NORMAL
- en: 'The beauty of multiple processes, as compared to multiple threads, is that
    you don''t have to be afraid of data corruption due to shared data. Each spawned
    process will have its own allocated memory, which won''t be accessed by other
    Python processes. This allows us to execute parallel tasks at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00123.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Also, from Python's point of view, each process has its own GIL. So, there's
    no resource conflict or race condition here.
  prefs: []
  type: TYPE_NORMAL
- en: Python multiprocessing library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `multiprocessing` module is Python's standard library that is shipped with
    Python binaries, and it is available from Python 2.6\. There's also the `threading`
    module, which allows you to spawn multiple threads, but they all share the same
    memory space. Multiprocessing comes with more advantages than threading. One of
    them is isolated memory space for each process, and it can take advantage of multiple
    CPUs and cores.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with multiprocessing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, you need to import the module for your Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Then, wrap your code with a Python function; this will allow the process to
    target this function and mark it as a parallel execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose that we have code that connects to the router and executes commands
    on it using the `netmiko` library, and we want to connect to all of the devices
    in parallel. This is a sample serial code that will connect to each device and
    execute the passed command, and then continue with the second device, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The Python file `devices.py` is created on the same directory as our script,
    and it contains the login details and credentials for each device in a `dictionary`
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we want to use the multiprocessing module instead, we need to redesign
    the script and move the code to be under a function; then, we will assign a number
    of processes equal to the number of devices (one process will connect to one device
    and execute the command) and set the target of the process to execute this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: We imported a multiprocess module as `mp`. One of the most important classes
    available inside the module is `Process`, which takes our `netmiko connect` function
    as a target argument. Also, it accepts passing an argument to the target function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we iterated over our nodes and created a process for each device and appended
    that process to the processes list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `start()` method, which is available in the module, is used to spawn and
    then it starts the process execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the script execution time is calculated by subtracting the script start
    time from the script end time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behind the scenes, the main thread that executes the main script will start
    to fork a number of processes equal to the number of devices. Each of them targets
    one function that executes `show run` on all devices at the same time and stores
    the output in a variable, without affecting each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a sample view of the processes inside Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00124.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, when you execute the full code, one final thing needs to be done. You
    need to join the forked process to the main thread/truck, in order to smoothly
    finish the program''s execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../images/00125.gif)The `join()` method used in the preceding example has
    nothing to do with the original `join()`, available as a string method; it''s
    only used to join the process to the main thread.'
  prefs: []
  type: TYPE_NORMAL
- en: Intercommunication between processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you will have a process that needs to pass or exchange information
    with other processes during runtime. The multiprocessing module has a `Queue`
    class that implements a special list, within which a process can insert and consume
    data. There are two methods available inside of this class: `get()` and `put()`.
    The `put()` method is used to add data to the `Queue`, whereas getting data from
    the queue is done via the `get()` method. In the next example, we will use `Queue` to
    pass data from a subprocess to a parent process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: We imported another class, called `Queue()`, from the `multiprocess` module,
    and instantiated it into the `mp_queue` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, during the process creation, we appended this queue as an argument side-by-side
    with the device, so every process will have access to the same queue and be able
    to write data to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `connect_to_dev()` function connects to each device and executes the `show
    run` command on the Terminal, then writes the output to the shared queue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we formatted the output as dictionary items, `{ip:<command_output>}`,
    before adding it to the shared queue using `mp_queue.put()`.
  prefs: []
  type: TYPE_NORMAL
- en: After the processes finished execution and joined the main (parent) process,
    we used `mp_queue.get()` to retrieve the queue items in a results list, then used `pprint`
    to prettyprint the output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the Python multiprocessing library and how
    to instantiate and execute Python code in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to prepare a lab environment and explore
    automation options to speed up server deployment.
  prefs: []
  type: TYPE_NORMAL
