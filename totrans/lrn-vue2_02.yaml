- en: Chapter 2. Fundamentals – Installing and Using
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we gained some familiarity with Vue.js. We were able
    to use it in two different applications that we created from scratch. We learned
    how to integrate Vue.js into an already existing project. We were able to see
    Vue's reactive data binding in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you are probably asking yourself: how does it work? What does it do to
    achieve this behavior of fast UI changes when the data model is changed? Probably,
    you decided to use Vue.js in your project and are now wondering whether it follows
    some architectural pattern or paradigm so that you should adopt it in your project.
    In this chapter, we will explore the key concepts of the Vue.js framework to understand
    all its behind the scenes features. Also in this chapter, we will analyze all
    the possible ways of installing Vue.js. We will also create a skeleton for our
    applications, which we will develop and enhance through the next chapters. We
    will also learn ways of debugging and testing our applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we are going to learn:'
  prefs: []
  type: TYPE_NORMAL
- en: What the MVVM architecture paradigm is and how it applies to Vue.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What declarative Views are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Vue.js explores defined properties, getters, and setters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How reactivity and data binding works in Vue.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What dirty checking, DOM, and virtual DOM are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main differences between Vue.js 1.0 and Vue.js 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What reusable components are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How plugins, directives, custom plugins, and custom directives work in Vue.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to install, start, run, and debug a Vue application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MVVM architectural pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do you remember how we were creating the `Vue` instance in the first chapter?
    We were instantiating it calling `new Vue({...})`. You also remember that in the
    options, we were passing the element on the page where this `Vue` instance should
    be bound and the `data` object that contained the properties we wanted to bind
    to our View. The `data` object is our Model and the DOM element where the `Vue`
    instance is bound is our View:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MVVM architectural pattern](../Images/image00239.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Classic View-Model representation where the Vue instance binds one to another
  prefs: []
  type: TYPE_NORMAL
- en: 'In the meantime, our `Vue` instance is something that helps to bind our Model
    to the View and vice versa. Our application thus follows **Model-View-ViewModel**
    (**MVVM**) pattern, where the `Vue` instance is a ViewModel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MVVM architectural pattern](../Images/image00240.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The simplified diagram of the Model-View-ViewModel pattern
  prefs: []
  type: TYPE_NORMAL
- en: Our **Model** contains data and some business logic, and our **View** is responsible
    for its representation. **ViewModel** handles data binding, ensuring that the
    data changed in the **Model** is immediately affecting the **View** layer and
    vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Our Views thus become completely data driven. **ViewModel** becomes responsible
    for the control of the data flow, making data binding fully declarative for us.
  prefs: []
  type: TYPE_NORMAL
- en: DefineProperty, getters, and setters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what happens with the data once passed to the `Vue` instance? What are these
    transformations that `Vue` applies to it so that it becomes so automatically bound
    to the View layer?
  prefs: []
  type: TYPE_NORMAL
- en: Let's analyze what would we do if we had, let's say, a string, and every time
    it changes we would like to apply some transformations to some DOM element. How
    would we apply the string-changing listener function? To what would we attach
    it? There is no such thing as `var stringVar='hello';stringVar.onChange(doSomething)` .
  prefs: []
  type: TYPE_NORMAL
- en: So we would probably wrap the string's value setting and getting in some sort
    of function that would do something, for example, updating the DOM each time the
    string was updated. How would you implement it? While you're thinking about it,
    I'll prepare a quick demo of something interesting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the developer tools on your shopping list application. Let''s code a little
    bit. Create an `obj` variable and another `text` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s store the DOM element `h2` in a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If we assign `text` to the `obj.text` property, how can we achieve that in every
    change of this property the `innerHTML` of `h2` would change as well?
  prefs: []
  type: TYPE_NORMAL
- en: Let's use the `Object.defineProperty` method ( [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: 'This method allows the creation of getter and setter functions, thus specifying
    what must happen when the property is accessed or changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now try to change the `obj.text` property from the console. Look at the title:'
  prefs: []
  type: TYPE_NORMAL
- en: '![DefineProperty, getters, and setters](../Images/image00241.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The set method of object.defineProperty is called every time the property changes
  prefs: []
  type: TYPE_NORMAL
- en: 'This exact mechanism was used by Vue.js. Once the data are passed to the `Vue`
    instance, all its properties go through the `Object.defineProperty` method, which
    assigns reactive getters and setters to them. For each directive existing on a
    page, a watcher is added, which is being notified within the `set` method. Open
    the `vue.js` code in the console and search for the line that says `set: function
    reactiveSetter(newVal)`. Add a breakpoint and try to change the title of the shopping
    list in the input. Now step over until you reach the last call in this function
    that says `dep.notify()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![DefineProperty, getters, and setters](../Images/image00242.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Breakpoint inside the setter function that calls the watchers notify method
  prefs: []
  type: TYPE_NORMAL
- en: Step into the function. You will see that this function is iterating through
    the watchers of the property and updates them. If you step over this call, you
    will see that the DOM is not being updated. This is because the updates performed
    on the same event loop are being put into the queue that is being flushed periodically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the `runBatcherQueue` function and put a breakpoint inside it. Try to
    change the title again. As you can see, this function iterates through all the
    watchers that are waiting inside the queue and calls the `run` method on each
    of them. If you step into this method, you will see that it compares the new value
    with the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It then it calls a callback''s execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you step into this callback function, you will see that in the end, it will
    finally update the DOM value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Isn't it simple?
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this debugging Vue version 1.0 is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'So the mechanism behind the Vue.js reactive data binding is very simple. **Watchers**
    are being assigned to all the directives and data properties. Then, during the
    `set` method of `Object.defineProperty`, the **Watchers** are notified and, in
    turn, they update the corresponding **DOM** or **data**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![DefineProperty, getters, and setters](../Images/image00243.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The data flow from the data object to the DOM
  prefs: []
  type: TYPE_NORMAL
- en: '**DOM** elements that have directives have attached listeners that listen to
    their updates and call the corresponding **data** property setter that, in turn,
    wakes up its **Watchers**.'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing with other frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you try a new tool, you want to know how it compares with other tools
    or frameworks. You can find a deep analysis in this regard on the official page
    of Vue.js: [http://vuejs.org/guide/comparison.html](http://vuejs.org/guide/comparison.html)
    . I will just point to some topics that I find important regarding the mostly
    used frameworks.'
  prefs: []
  type: TYPE_NORMAL
- en: React
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React and Vue are really similar. They both use virtual DOM, have reusable components,
    and are about reactive data. It is worth mentioning, however, that Vue only uses
    virtual DOM starting from its second major version. Prior to Vue 2.0, it used
    real DOM. The Vue 2.0 release not only became more performant than Vue 1.0 but
    it also became more performant than React ( [http://vuejs.org/guide/comparison.html#Performance-Profiles](http://vuejs.org/guide/comparison.html#Performance-Profiles)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: The most significant difference is probably the way you create your components
    in both frameworks. You might already know that in React, everything is JavaScript.
    Developing everything, even templates, in JavaScript, can actually be good, so
    programmers are always in the same scope and rendering becomes more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, for some designers who want to do rapid prototyping or for developers
    with not-so-strong programming skills, or for people who simply don''t want to
    learn JSX, it might become really painful to work like this. In Vue components,
    you can actually also use JSX, but you can still follow a common web development
    structure: writing CSS inside the `<style>` tags, writing HTML code inside the
    `<template>` tags, and writing the component''s logic in JavaScript inside the
    `<script>` tags. Compare, for example, the template inside the render function
    in React and the template that you can write inside the Vue component. In this
    example, I will show how to render the list of items of the shopping list that
    we have seen before. So in React, you will end up with the JSX code similar to
    this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Using Vue, you will just write the following HTML code inside the `template`
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: I, personally, like to have these things separated, thus I find it nice that
    Vue offers this possibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another nice thing about Vue is that it allows to scope style within the components
    using the `scoped` attribute attached to the `style` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Within this style, in case you use preprocessors, you still have access to all
    globally defined variables and can create or redefine styles that will be only
    accessible by this component.
  prefs: []
  type: TYPE_NORMAL
- en: It's also worth to mention the learning curve for both frameworks. To be able
    to start developing applications using React, you would probably have to learn
    JSX and ES2105 syntax, since most examples in official React documentation use
    it. With Vue, you can start out of the blue. Just include it in the page, like
    you would do with jQuery, and you can already use Vue models and data binding
    using pretty simple and easy to understand syntax, and any JavaScript version
    you like to use. After that, you can scale up in your learning and in your applications
    style.
  prefs: []
  type: TYPE_NORMAL
- en: In case you want to perform a deeper analysis of both frameworks, have a look
    at the documentation, try to elaborate similar examples, and check what suits
    your needs more.
  prefs: []
  type: TYPE_NORMAL
- en: Angular
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a huge difference between Angular 1 and Angular 2\. We all know that
    the second version of Angular is completely different from its predecessor. It
    offers more performance, the API is different, and the underlying implementation
    has been rewritten.
  prefs: []
  type: TYPE_NORMAL
- en: These two versions are so different that in Vue official documentation, you
    will find the comparison between both the Angular versions as it was between two
    different frameworks. However, the learning curve and the way in which each of
    the frameworks forces you to structure the application are transversal for both
    the Angular versions. It turns out that Vue is much less opinionated than Angular
    1 as well as Angular 2\. Just compare Angular's quick start guide and Vue's hello
    world applications at [https://angular.io/docs/js/latest/quickstart.html](https://angular.io/docs/js/latest/quickstart.html)
    and [http://vuejs.org/guide/index.html#Hello-World](http://vuejs.org/guide/index.html#Hello-World)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *"Even without TypeScript, Angular''s Quickstart guide starts out with
    an app that uses ES2015 JavaScript, NPM with 18 dependencies, 4 files, and over
    3,000 words to explain it all - just to say Hello World."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*http://vuejs.org/guide/comparison.html#Learning-Curve* |'
  prefs: []
  type: TYPE_TB
- en: If you still use Angular 1, it's worth to mention that the big difference between
    this framework and Vue is that in this version of Angular, each time the scope
    changed, re-evaluated all the watchers, thus performing dirty checking, hence
    reducing the performance when the amount of watchers became considerably high.
    Hence, in Vue, when something in the scope changes, only this property's watcher
    is being re-evaluated. All others are sitting idle and waiting for their respective
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: Vue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No, it is not a typo. It is also worth comparing Vue with Vue. Vue has also
    recently launched its second version, which is faster and cleaner than its predecessor.
    If you still use Vue 1.0, it is worth to upgrade. If you don't know anything about
    Vue versions, it is worth to check how it evolved and what does the new version
    allow. Check the Vue blog post that announced Vue 2.0 in April 2016 at [https://vuejs.org/2016/04/27/announcing-2.0/](https://vuejs.org/2016/04/27/announcing-2.0/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before putting our hands into the code and starting to enhance our applications
    with components, plugins, mixins, templates, and other things, let's overview
    the main Vue features. Let's analyze what are reusable components and how the
    application state can be managed, and also talk about plugins, filters, and mixins.
    In this section, we will have just a slight overview of these features. We will
    learn them deeply in the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Reusable components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you know not only what data binding in Vue.js is and how to use it,
    but also how it works, it is time to introduce another powerful Vue.js feature.
    Components created with Vue.js can be used and reused in the application as bricks
    you build your house of. Each component has its own scope of styles and bindings,
    being completely isolated from the other components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component creation syntax is very similar to the `Vue` instance creation
    that we already know, and you should only use `Vue.extend` instead of just `Vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![Reusable components](../Images/image00244.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Custom components in Vue.js
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s, for example, try to divide our shopping list code into components.
    As you remember, our shopping list consists essentially of three parts: the part
    that contains the shopping list item, another part that contains the input for
    adding new items, and the third part that allows changing the title of the shopping
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reusable components](../Images/image00245.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Three essential parts of the shopping list application
  prefs: []
  type: TYPE_NORMAL
- en: Let's change the code of the application so that it uses three components, one
    for each part.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code was looking like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will create three components: `ItemsComponent`, `ChangeTitleComponent`,
    and `AddItemComponent`. All of them will have the `data` property with the `data`
    object. The `addItem` method will jump from the main `Vue` instance to `ChangeTitleComponent`.
    All the necessary HTML will go from our `index.html` file to each of the components.
    So in the end, our main script will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'How do we use these components inside the View? We should just replace the
    corresponding markup with the tag of the registered component. Our markup looked
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reusable components](../Images/image00246.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The shopping list application markup with defined components
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the first highlighted area we will replace with the `<add-item-component></add-item-component>`
    tag, the second one with the `<items-component></items-component>` tag, and the
    third one with the `<change-title-component></change-title-component>` tag. Thus,
    our previously huge markup now looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We will go deeply into components in the next chapter and will learn an even
    nicer way of structuring them. Stay tuned!
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have already learned in the previous chapter what directives are and how
    they are used to enhance the application's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: You've already used some directives that allow data binding in different ways
    to the View layer (`v-model`, `v-if`, `v-show`, and so on). Besides these default
    directives, Vue.js allows you to create custom directives. Custom directives provide
    a mechanism to enable custom behavior of DOM to data mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'When registering a custom directive, you can provide three functions: `bind`,
    `update`, and `unbind`. Inside the `bind` function, you can attach an event listener
    to the element and do whatever needs to be done there. Inside the `update` function
    that receives old and new values as parameters, you can define a custom behavior
    of what should happen when data changes. The `unbind` method provides all the cleaning
    operations needed (for example, detach event listeners).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Vue 2.0, directives have significantly reduced the scope of responsibility—now
    they are only used to apply low-level direct DOM manipulations. Vue's changing
    guide suggests to prefer using components over custom directives ( [https://github.com/vuejs/vue/issues/2873](https://github.com/vuejs/vue/issues/2873)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the full version of the custom directive would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The simplified version, in case you just need to do something on the value
    update, can only have the `update` method that can be passed directly as the second
    parameter of the directive function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The theory is nice, but without a small example, it turns out boring. So let's
    have a look at a very simple example, which will show the square of the number
    each time its value is updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our custom directive will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Use this directive in your template file using the `v-` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Instantiate the `Vue` instance with `item` in its data and try to change the
    value of `item`. You will see that the value inside the `div` element will immediately
    display the square number of the changed value. The complete code for this custom
    directive can be found in the JSFiddle at [https://jsfiddle.net/chudaol/we07oxbd/](https://jsfiddle.net/chudaol/we07oxbd/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Plugins in Vue.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Vue''s core functionality, as we have already analyzed, provides declarative
    data binding and components composing. This core behavior is enhanced with plugins
    that provide a rich set of functionality. There are several types of plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: Plugins that add some global property or method (`vue-element`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugins that add some global assets (`vue-touch`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugins that add `Vue` instance methods attaching them to Vue's prototype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugins that provide some external functionality or API (`vue-router`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugins must provide an `install` method that has access to the global `Vue`
    object that can enhance and modify it. In order to use this plugin, Vue provides
    the `use` method that receives plugins instances (`Vue.use(SomePlugin)`).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also write a Vue plugin of your own to enable custom behavior for your
    `Vue` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the previous custom directives example and create a minimalistic
    plugin that implements mathematical square and square root directives. Create
    a file named `VueMathPlugin.js` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a file called `script.js`. Let''s add the main script to this file.
    In this script, we will import both `Vue` and `VueMathPlugin`, and will call Vue''s
    `use` method in order to tell it to use the plugin and call the plugin''s `install`
    method. Then we''ll just initiate a `Vue` instance as we always do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create an `index.html` file that includes the `main.js` file (we will build
    it with Browserify and Babelify). In this file, let''s add an input using the
    `v-model` directive that will be used to change the value of the item. Create
    two spans using `v-square` and `v-sqrt` directives as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `package.json` file to include the needed dependencies for building
    the project and add a script for building the `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now install the dependencies and build the project from the following command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `index.html` in the browser. Try to change the number in the input box.
    Both square and square root values change immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Plugins in Vue.js](../Images/image00247.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The changes in the data are applied immediately to the directives created as
    a part of custom plugin
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enhance `MathPlugin` with trigonometrical functions (sine, cosine, and tangent).
  prefs: []
  type: TYPE_NORMAL
- en: A possible solution to this exercise can be found in the *Annexes*.
  prefs: []
  type: TYPE_NORMAL
- en: Application state and Vuex
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an application reaches a considerable size, it might become necessary for
    us to manage the global application state somehow. Inspired from Flux ( [https://facebook.github.io/flux/](https://facebook.github.io/flux/)
    ), there is a Vuex module that allows us to manage and share the global application
    state among Vue components.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not think about the application state as something complex and difficult
    to understand. In fact, it is no more than just data. Each component has its own
    data, and "application state" is data that can be easily shared between all the
    components!
  prefs: []
  type: TYPE_NORMAL
- en: '![Application state and Vuex](../Images/image00248.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How Vuex store manages applications state updates
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the other plugins, in order to be able to use and to instantiate the Vuex
    store, you need to instruct Vue to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, when initializing the main component, assign the store instance to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now the main application and all its components are aware about the store, have
    access to the data inside it, and are able to trigger actions on it at any time
    of the application's life cycle. We will dig deeply into the application state
    in the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: vue-cli
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yes, Vue has its own command-line interface. It allows us to initialize a Vue
    application with whatever configuration we want. You can initialize it with Webpack
    boilerplate, with Browserify boilerplate, or just with a simple boilerplate that
    just creates an HTML file and prepares everything for you to start working with
    Vue.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install it with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The different ways of initializing an application are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the difference, let''s run `vue init` with the simple template and with
    the Webpack template, and look at the differences in the generated structure.
    Following is how the output differs from both commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![vue-cli](../Images/image00249.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The output from the commands vue init webpack and vue init simple
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is how the application structure differs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![vue-cli](../Images/image00250.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The difference in structure in application scaffolded with vue init simple and
    vue init webpack
  prefs: []
  type: TYPE_NORMAL
- en: The `index.html` file in the simple configuration already contains Vue.js from
    the CDN, so if you just need to do something really simple such as quick prototyping,
    use this one.
  prefs: []
  type: TYPE_NORMAL
- en: But if you are about to start a complex **Single Page Application** (**SPA**)
    project that will require testing and hot reloading during development, use the
    Webpack or Browserify configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Vue plugins for IDEs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are plugins for Vue syntax highlighting for some major IDEs. I will leave
    you with the links to the fanciest of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **IDE** | **Link to the Vue plugin** |'
  prefs: []
  type: TYPE_TB
- en: '| Sublime | [https://github.com/vuejs/vue-syntax-highlight](https://github.com/vuejs/vue-syntax-highlight)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Webstorm | [https://github.com/postalservice14/vuejs-plugin](https://github.com/postalservice14/vuejs-plugin)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Atom | [https://github.com/hedefalk/atom-vue](https://github.com/hedefalk/atom-vue)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Visual Studio Code | [https://github.com/LiuJi-Jim/vscode-vue](https://github.com/LiuJi-Jim/vscode-vue)
    |'
  prefs: []
  type: TYPE_TB
- en: '| vim | [https://github.com/posva/vim-vue](https://github.com/posva/vim-vue)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Brackets | [https://github.com/pandao/brackets-vue](https://github.com/pandao/brackets-vue)
    |'
  prefs: []
  type: TYPE_TB
- en: Installing, using, and debugging a Vue.js application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will analyze all the possible ways of installing Vue.js.
    We will also create a skeleton for our applications that we will develop and enhance
    through the next chapters. We will also learn the ways of debugging and testing
    our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Vue.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of ways to install Vue.js. Starting from classic, including
    the downloaded script into HTML within the `<script>` tags, using tools like bower,
    npm, or Vue's command-line interface (`vue-cli`), to bootstrap the whole application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at all these methods and choose our favorite. In all these
    examples, we will just show a header on a page saying **`Learning Vue.js`**.
  prefs: []
  type: TYPE_NORMAL
- en: Standalone
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Download the `vue.js` file. There are two versions, minified and developer version.
    The development version is at [https://vuejs.org/js/vue.js](https://vuejs.org/js/vue.js)
    . The minified version is at [https://vuejs.org/js/vue.min.js](https://vuejs.org/js/vue.min.js)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are developing, make sure you use the development non-minified version
    of Vue. You will love the nice tips and warnings on the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then just include `vue.js` in the `<script>` tags, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Vue is registered in the global variable. You are ready to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example will then look as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: CDN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Vue.js is available in the following CDNs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**jsdelivr**: [https://cdn.jsdelivr.net/vue/2.0.3/vue.js](https://cdn.jsdelivr.net/vue/2.0.3/vue.js)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**cdnjs**: [https://cdnjs.cloudflare.com/ajax/libs/vue/2.0.3/vue.js](https://cdnjs.cloudflare.com/ajax/libs/vue/2.0.3/vue.js)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**unpkg**:  [https://unpkg.com/vue@2.0.3/dist/vue.js](https://unpkg.com/vue@2.0.3/dist/vue.js)
    (recommended)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just put the URL in source in the `script` tag and you are ready to use Vue!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Beware the CDN version might not be synchronized with the latest available version
    of Vue.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the example will look exactly the same as in the standalone version, but
    instead of using downloaded file in the `<script>` tags, we are using a CDN URL.
  prefs: []
  type: TYPE_NORMAL
- en: Bower
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are already managing your application with Bower and don''t want to
    use other tools, there''s also a Bower distribution of Vue. Just call `bower install`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Our example will look exactly like the two previous examples, but it will include
    the file from the `bower` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: CSP-compliant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Content Security Policy** (**CSP**) is a security standard that provides
    a set of rules that must be obeyed by the application in order to prevent security
    attacks. If you are developing applications for browsers, you are likely familiar
    with this policy!'
  prefs: []
  type: TYPE_NORMAL
- en: For the environments that require CSP-compliant scripts, there's a special version
    of Vue.js at [https://github.com/vuejs/vue/tree/csp/dist](https://github.com/vuejs/vue/tree/csp/dist)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Let's do our example as a Chrome application to see the CSP-compliant Vue.js
    in action!
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a folder for our application example. The most important
    thing in a Chrome application is the `manifest.json` file, which describes your
    application. Let''s create it. It should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create our `main.js` file, which will be the entry point
    for the Chrome application. The script should listen for the application launching
    and open a new window with given sizes. Let''s create a window of 500 x 300 size
    and open it with `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the Chrome-specific application magic is over and now we shall
    just create our `index.html` file that will do the same thing as in the previous
    examples. It will include the `vue.js` file and our script, where we will initialize
    our Vue application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Download the CSP-compliant version of Vue.js and add it to the `assets` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create the `app.js` file and add the code that we already wrote
    added several times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Add it to the `assets` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget to create two icons of 16 and 128 pixels and call them `icon_16.png`
    and `icon_128.png`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code and structure in the end should look more or less like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![CSP-compliant](../Images/image00251.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Structure and code for the sample Chrome application using vue.js
  prefs: []
  type: TYPE_NORMAL
- en: 'And now the most important thing. Let''s check if it works! It is very, very
    simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to `chrome://extensions/url`  in your Chrome browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **`Developer mode`** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **`Load unpacked extension...`** and check the folder that we've just
    created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your app will appear in the list! Now just open a new tab, click on apps, and
    check that your app is there. Click on it!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![CSP-compliant](../Images/image00252.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Sample Chrome application using vue.js in the list of Chrome apps
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have just created a Chrome application!
  prefs: []
  type: TYPE_NORMAL
- en: npm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `npm` installation method is recommended for large-scale applications.
    Just run `npm install vue` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then require it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, for ES2015 lovers, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Our HTML will look exactly like in the previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create a `script.js` file that will look almost exactly the same
    as in a standalone or CDN version, with the only difference being that it will
    require `vue.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s install Vue and Browserify in order to be able to compile our `script.js`
    file into the `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `package.json` file, add a script for build as well that will execute
    Browserify on `script.js` transpiling it into `main.js`. So our `package.json`
    file will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: And open `index.html` in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have a friend that at this point would say something like: really? So many
    steps, installations, commands, explanations... Just to output some header? I''m
    out!'
  prefs: []
  type: TYPE_NORMAL
- en: If you are also thinking this, wait. Yes, this is true, now we've done something
    really simple in a rather complex way, but if you stay with me a bit longer, you
    will see how complex things become easy to implement if we use the proper tools.
    Also, do not forget to check your Pomodoro timer, maybe it's time to take a rest!
  prefs: []
  type: TYPE_NORMAL
- en: vue-cli
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we have already mentioned in the previous chapter, Vue provides its own
    command-line interface that allows bootstrapping single-page applications using
    whatever workflows you want. It immediately provides hot reloading and structure
    for a test-driven environment. After installing `vue-cli`, just run `vue init
    <desired boilerplate> <project-name>` and then just install and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now open your browser on `localhost:8080`. You just used `vue-cli` to scaffold
    your application. Let's adapt it to our example. Open a source folder. In the
    `src` folder, you will find an `App.vue` file. Do you remember we talked about
    Vue components that are like bricks from which you build your application? Do
    you remember that we were creating and registering them inside our main script
    file, and I mentioned that we will learn to build components in a more elegant
    way? Congratulations, you are looking at the component built in a fancy way!
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the line that says `import Hello from ''./components/Hello''`. This is
    exactly how the components are being reused inside other components. Have a look
    at the template at the top of the component file. At some point, it contains the
    `<hello></hello>` tag. This is exactly where in our HTML file the `hello` component
    will appear. Have a look at this component; it is in the `src/components` folder.
    As you can see, it contains a template with `{{ msg }}` and a script that exports
    data with defined `msg`. This is exactly the same as we were doing in our previous
    examples without using components. Let''s slightly modify the code to make it
    the same as in the previous examples. In the `Hello.vue` file, change `msg` in
    the `data` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `App.vue` component, remove everything from the template except the
    `hello` tag so that the template looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you rerun the application, you will see our example with beautiful styles
    that we didn''t touch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![vue-cli](../Images/image00253.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Vue application bootstrapped using vue-cli
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Besides Webpack boilerplate template, you can use the following configurations
    with your `vue-cli`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`webpack-simple`: A simple Webpack + vue-loader setup for quick prototyping'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`browserify`: A full-featured Browserify + Vueify setup with hot-reload, linting,
    and unit testing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`browserify-simple`: A simple Browserify + Vueify setup for quick prototyping'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`simple`: The simplest possible Vue setup in a single HTML file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dev build
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: My dear reader, I can see your shining eyes and I can read your mind. Now that
    you know how to install and use Vue.js and how it works, you definitely want to
    put your hands deeply into the core code and contribute!
  prefs: []
  type: TYPE_NORMAL
- en: I understand you. For this, you need to use the development version of Vue.js,
    which you have to download from GitHub and compile yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Let's build our example with this development version of Vue. Create a new folder,
    for example, `dev-build`, and copy all the files from the npm example to this
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do not forget to copy the `node_modules` folder. You should `cd` into it and
    download files from GitHub to it, and then run `npm install` and `npm run build`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now build our example application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Open `index.html` in the browser; you will see the usual **`Learning Vue.js`**
    header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now try to change something in `vue.js` source! Go to the `node_modules/vue/src/compiler/parser`
    folder and open the `text-parser.js` file. Find the line that says the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, this regular expression defines default delimiters used in the HTML
    templates. The things inside these delimiters are recognized as a Vue data or
    as a JavaScript code. Let''s change them! Let''s replace `{` and `}` with double
    percentage signs! Go on and edit the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now rebuild both Vue source and our application and refresh the browser. What
    do you see?
  prefs: []
  type: TYPE_NORMAL
- en: '![Dev build](../Images/image00254.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After changing the Vue source and replacing delimiters, {{}} delimiters do not
    work anymore!
  prefs: []
  type: TYPE_NORMAL
- en: The message inside `{{}}` is no longer recognized as data that we passed to
    Vue. In fact, it is being rendered as part of HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now go to the `index.html` file and replace our curly brackets delimiters with
    double percentage, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Rebuild our application and refresh the browser! What about now? You see how
    easy it is to change the framework's code and to try out your changes. I'm sure
    you have plenty of ideas about how to improve or add some functionality to Vue.js.
    So change it, rebuild, test, deploy! Happy pull requests!
  prefs: []
  type: TYPE_NORMAL
- en: Debugging your Vue application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can debug your Vue application the same way you debug any other web application.
    Use your developer tools (firebug), breakpoints, debugger statements, and so on.
    If you want to dive deep inside the Chrome debugging tools, check Chrome's documentation
    at [https://developer.chrome.com/devtools](https://developer.chrome.com/devtools)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Vue also provides *Vue.js devtools*, so it gets easier to debug Vue applications.
    You can download and install it from the Chrome web store at [https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, it doesn't work with locally opened files, so use some simple
    HTTP server in order to serve our examples as a web page (for example, [https://www.npmjs.com/package/http-server](https://www.npmjs.com/package/http-server)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing it, open, for example, our shopping list application. Open
    developer tools. You will see the **`Vue`** tab has automatically appeared:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging your Vue application](../Images/image00255.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Vue devtools
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we only have one component—**`<Root>`**. As you can imagine, once
    we start working with components and having lots of them, they will all appear
    in the left part of the Vue devtools palette. Click on the **`<Root>`** component
    and inspect it. You''ll see all the data attached to this component. If you try
    to change something, for example, add a shopping list item, check or uncheck a
    checkbox, change the title, and so on, all these changes will be immediately propagated
    to the data in the Vue devtools. You will immediately see the changes on the right-hand
    side of it. Let''s try, for example, to add a shopping list item. Once you start
    typing, you see on the right how `newItem` changes accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging your Vue application](../Images/image00256.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The changes in the Models are immediately propagated to the Vue devtools data
  prefs: []
  type: TYPE_NORMAL
- en: When we start adding more components and introduce complexity to our Vue applications,
    the debugging will certainly become more fun!
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolding our applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do you remember the two applications that we started to work on in the first
    chapter, the shopping list application and the Pomodoro one? In this section,
    we will scaffold these applications using the `vue-cli` tool in order for them
    to be ready to contain reusable components, be tested, and be deployed. Once we
    bootstrap these applications, we will work on them until the end of this book.
    So let's do it carefully and with lots of love!
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolding the shopping list application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will scaffold the shopping list application using `vue-cli` Webpack configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In case you have ignored all previous practical exercises related to `vue-cli`,
    do not forget to install it before proceeding to the next steps: **npm install
    -g vue-cli**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you already have `vue-cli` installed, go to the directory where you want
    to bootstrap the application and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Answer yes to all the questions (just click enter) and voilà! You have the
    application bootstrapped:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scaffolding the shopping list application](../Images/image00257.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Bootstraping the shopping list application with vue-cli
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to the shopping list directory and run `npm install` and `npm run dev`.
    Open your browser at `localhost:8080`. You will see the **`Hello World`** page
    of the newly created Vue application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scaffolding the shopping list application](../Images/image00258.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Hello World view of the newly bootstrapped application
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s clean the bootstrapped code so that the application gets ready to be
    populated with our application-specific code. Go to the `App.vue` file and remove
    everything, leaving just the tags that define the application structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<template>` with the main `<div>` inside'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<script>` tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<style>` tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, in the end, your `App.vue` file looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Have a look at the page opened in the browser. Funny, you haven't done anything, but
    the page now doesn't contain the default **`Hello World`**. The page is empty!
    It has changed automatically!
  prefs: []
  type: TYPE_NORMAL
- en: 'Try adding something inside the `<template>` tags. Look at the page; it automatically
    reloads once you introduce changes. This works because of the `vue-hot-reload`
    plugin that detects changes in your Vue components and automatically rebuilds
    the project and reloads the browser page. Try to write some JavaScript code inside
    the `<script>` tags that doesn''t correspond to lint standards, for example, using
    `notDefinedVariable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The page in the browser is not refreshed. Look at your shell console. It shows
    the *lint* errors and "refuses" to build your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scaffolding the shopping list application](../Images/image00259.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Each time the application is changed the lint rules are checked
  prefs: []
  type: TYPE_NORMAL
- en: This happens, thanks to the ESLint plugin, which checks the code against the
    lint rules each time the application changes.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we can be sure that our code will follow the best quality standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of quality, we should also prepare our application to be able to run
    unit tests. Luckily for us, `vue-cli` with Webpack has already done it for us.
    Run `npm run unit` to run unit tests and `npm run e2e` to run end-to-end nightwatch
    tests. End-to-end tests will not run in parallel with your running application
    since both are using the same port. So, if you want to run tests during development,
    you should change the port in the `config/index.js` configuration file or simply
    stop the application between running tests. After running tests, you will see
    the end-to-end tests fail. This is because they are checking for the application''s
    specific elements that we have removed. Open the file `test.js` from the `test/e2e/specs/`
    directory and clean all the assertions that we don''t need anymore. Now it should
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Rerun the tests. Now they should be passing. From now on, as we will add code
    to our application, we will add unit and end-to-end tests.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstraping your Pomodoro application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the Pomodoro application, do the same as for the shopping list application.
    Run `vue init webpack pomodoro` and repeat all the necessary steps to ensure that
    the structure is ready to be populated with the Pomodoro application code!
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implement our Pomodoro application as a Chrome app! You just need to use it
    with a CSP-compliant version of Vue.js and add a `manifest.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have analyzed the behind-the-scenes of Vue.js. You learned
    how data reactivity is achieved. You saw how Vue.js leverages `Object.defineProperty`
    getters and setters to propagate changes in the data. You saw an overview of the
    key Vue.js concepts, such as reusable components, plugins system, and state management
    with Vuex. We have bootstrapped the applications that we will develop during the
    next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will have a deeper look into the Vue's components system.
    We will use components in our applications.
  prefs: []
  type: TYPE_NORMAL
