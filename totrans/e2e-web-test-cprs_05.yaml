- en: '*Chapter 4*: Writing Your First Test'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you start this chapter, you need to have an understanding of how Cypress
    tests are run, different Cypress commands, how to set up Cypress, running Cypress
    on the command line, and how to use the test runner to open Cypress tests. This
    information was covered in the first three chapters, and will help you better
    understand the fundamentals that we will be building on in this chapter when writing
    our first test.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover the basics of creating test files and writing
    a basic test, before we move on and write more complicated tests and assert various
    elements using Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating test files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your first test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing practical tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cypress' auto-reload feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cypress assertions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By completing this chapter, you will be ready to learn how to debug running
    tests using the test runner.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The GitHub repository for this chapter can be found at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress](https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress)'
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter can be found in the `chapter-04` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Creating test files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All tests within Cypress must be within a test file for them to run. For a test
    to be considered useful, it must validate all the conditions that we have defined
    in the test and return a response stating whether the conditions have been met.
    Cypress tests are no exception to the process of writing tests, and all the tests
    that are written in a test file must have a set of conditions to be validated.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will go through the process of writing a test file, starting
    from where a test file should be located in Cypress, different extensions that
    Cypress supports, and the file structures that test files written in Cypress should
    follow.
  prefs: []
  type: TYPE_NORMAL
- en: Testfiles location
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cypress creates test files by default when it is initialized in the `cypress/integration/examples`
    directory. However, these can be deleted as they are intended to show the proper
    format of utilizing different Cypress test types and assertions. Cypress allows
    you to be flexible when it comes to locating different modules and folder structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is recommended that when you''re working on your first project, you use
    the location mentioned in the previous paragraph to write your Cypress tests.
    To reconfigure the Cypress folder structures, you can change the Cypress default
    configuration and pass the new configuration into the `cypress.json` file. A good
    example of changing the default Cypress configuration would be to change our test
    directory from being located in `cypress/integration/examples to cypress/tests/todo-app`
    to elsewhere. To change the default directory, all we would need to do is change
    our `cypress.json` configuration, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code block shows the `integrationFolder` setting, which changes
    how the Cypress `tests` dictionary is configured.
  prefs: []
  type: TYPE_NORMAL
- en: Testfiles extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cypress accepts different file extensions, which allows us to write tests that
    go beyond the normal JavaScript default format. The following file extensions
    are acceptable in Cypress tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.jsx`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.coffee`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.cjsx`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to these, Cypress also supports ES2015 out of the box and CommonJS
    modules, which makes it possible for us to use keywords such as **import** and
    **require** without any additional configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Testfile structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testfile structures in Cypress are similar to most of the other structures
    used to write tests or even normal JavaScript code. The structure of Cypress tests
    takes module imports and declarations into consideration, as well as the test
    body, which contains the tests. This can be seen in the following sample test
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, every test file needs to have the declarations at the top-most
    part of the test file. By doing this, the tests can be nested in the `describe`
    blocks, which specify the scope and the type of tests that will be run.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our test file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the GitHub link located in the *Technical requirements* section, open
    the `chapter-04` folder. Follow these steps to create your first test file:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `integration` folder directory located inside the Cypress directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty test file called `sample.spec.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the purposes of this demonstration, we have created a `package.json` file
    in the `chapter-04` root directory for you. All you need to do is run the commands
    without worrying about how they work for now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the Cypress test runner with the `npm run cypress:run` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the test runner preview and confirm that the test file we added is visible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, it's time for a quick recap.
  prefs: []
  type: TYPE_NORMAL
- en: Recap â€“ creating test files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learned how to create test files, how Cypress accepts different
    test file formats, and how to change the default directory of Cypress tests. We
    also learned the structure of a test and how Cypress borrows the format of tests
    from languages such as JavaScript. In the next section, you will focus on writing
    your first test.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cypress tests are no different than any other tests. As in all other tests,
    Cypress tests should pass when the expected result is consistent with what the
    application under test expects; it should fail when the expected result is not
    consistent with what the application should do. In this section, we will explore
    different types of tests, the structure of a test, and how Cypress understands
    the changes in a test file and reruns the tests. This section will also cover
    how to write practical tests.
  prefs: []
  type: TYPE_NORMAL
- en: Example test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will look at the basic structure of a Cypress test. This
    remains standard in most of the tests that we will write during the course of
    this chapter. The following test checks that what we expect and what is returned
    are equal to `true`. It should pass when we run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the test has `describe()` and `it()` hooks. The hooks
    included in the Cypress tests come bundled by default from the **Chai** assertion
    library, which Cypress uses as its default assertion library. The hooks are used
    to help you to understand the different stages of the tests. The `describe` hook
    helps encapsulate different tests into one block, while the `it` hook helps us
    identify specific tests within a test block.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The Chai assertion library is included in the Cypress framework as a package.
    It is the default assertion library that Cypress uses to verify the success or
    failure of tests.
  prefs: []
  type: TYPE_NORMAL
- en: Considering the test we saw in this section, we will now explore the different
    types of test classification in Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: Test classification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tests can be classified into the results they yield after they''ve been run.
    Cypress tests can also be classified according to their states. The tests can
    be in any of the following states:'
  prefs: []
  type: TYPE_NORMAL
- en: Passing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skipped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll take a detailed look at these three categories in the next few sections.
  prefs: []
  type: TYPE_NORMAL
- en: Passing tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A passing test is a test that correctly validates the input by matching it
    with the expected output. In Cypress, passing tests are clearly marked as passed,
    and this is visible on the command log and the Cypress test runner. Using the
    `sample.spec.js` file that we created earlier, we can create our first passing
    test, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the test while using the `chapter-04` directory as a reference, we can
    run the following command on the command-line interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this test, we are verifying that the input given, `true`, is similar to
    the test output that we expect, which is also `true`. This test might not be very
    useful, but its purpose is to show a passing test. The following screenshot shows
    a passing test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 â€“ Passing test'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.1_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 â€“ Passing test
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows the result of passing the test in the command
    log. We can further verify that the test passes all the other conditions by looking
    at the green checkmark in the top-left corner.
  prefs: []
  type: TYPE_NORMAL
- en: Failing tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like a passing test, a failing test also validates the test input against
    the test expectations and compares it to the result. A test failure occurs in
    the event that the expected result and the test input do not evaluate to the same
    thing. Cypress does a good job of displaying failing tests and describing what
    failed in the test. Using the same `sample.spec.js` file we created earlier, create
    a failing test, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the test , we will use the `chapter-0`4 directory as a reference, and
    then run the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this failing test, we are comparing a test input of `true` to a test expectation
    of `false`, which leads to a failing test set to `true`, which is not equal to
    `false`. The test automatically fails as it does not pass the validation that
    determines that our test passed. The following screenshot shows the result of
    our failing test in the command log:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 â€“ Failing test'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.2_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 â€“ Failing test
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the command log, we can see that we have two tests: one that passes
    and one that fails. On the failing test, the Cypress command log shows the assertions
    that failed to meet our expectations. The test runner, on the other hand, goes
    ahead and shows us one failing test as a summary of our test run. When the test
    fails, Cypress allows us to read the exact exception that occurred. In this case,
    we can clearly see that the test failed at the assertion level due to an incorrect
    assertion.'
  prefs: []
  type: TYPE_NORMAL
- en: Skipped tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Skipped tests in Cypress are not executed. Skipped tests are used to omit tests
    that are either failing or that do not need to run when other tests are being
    executed. Skipped tests are suffixed with the`.skip` keyword after their test
    hook. We can skip tests that are in a whole block by skipping the test block with
    `describe.skip` , or just skip a single test by using `it.skip`. The following
    code block shows two tests in which the main `describe` block is skipped and another
    test that is skipped inside the `describe` block. The following code illustrates
    different ways of skipping Cypress tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we can skip either the whole code block or specific tests
    when we add`.skip` to either the `it` or `describe` hook. The following screenshot
    shows a skipped test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 â€“ Skipped test'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.3_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 â€“ Skipped test
  prefs: []
  type: TYPE_NORMAL
- en: Skipped tests are just shown as skipped in the command log and in the test runner;
    no activity takes place for a test block or a single test that has been skipped.
    The preceding screenshot shows the state of the skipped tests defined in our `sample.spec.js`
    file, which can be found in our `chapter-04` GitHub repository directory. Now
    that we know how to write different types of tests, we can dive into writing practical
    tests. But first, let's test our knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise on tests classification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the knowledge you''ve gained by reading this section of this chapter,
    write tests that meet the following criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: A passing test that asserts that a variable is of the `string` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A failing test that asserts a valid variable is equal to `undefined`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A skipped test that checks whether a Boolean variable is `true`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's recap what we've covered in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Recap â€“ writing your first test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learned how to identify different types of tests and looked
    at how the Cypress framework treats them. We learned what passing tests, failing
    tests, and skipped tests are. We also learned how the Cypress test runner displays
    the states of tests that have either passed, failed, or been skipped. Finally,
    we went through an exercise to test our knowledge of classifying tests. Now, let's
    move on to writing a practical test.
  prefs: []
  type: TYPE_NORMAL
- en: Writing practical tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we went through the basics of understanding different
    classifications for tests in Cypress and what the results of the classifications
    are. In this section, we will focus on writing tests that go beyond asserting
    that a Boolean value is equal to another Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For any test to have value, it needs to have three fundamental phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the desired state of the application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Executing the action to be tested
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Asserting the state of the application after executed actions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our practical tests, we will use our **Todo** application to write tests
    that correspond to the three fundamental phases required to write a meaningful
    test. To do this, we will complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Visit the Todo application page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for an element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Interact with the element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make an assertion on the application state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These steps will guide the practical tests that we are about to write and will
    help us in having a the holistic view of Cypress tests.
  prefs: []
  type: TYPE_NORMAL
- en: Visiting the Todo application page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This step involves visiting the Todo application page, which is where we will
    run our test. Cypress provides a built-in `cy.visit()` command for navigating
    to web pages. The following code block shows the steps we need to follow to visit
    our Todo page. This code block can be found in the `chapter-04` folder of this
    book''s GitHub repository, in the `practical-tests.spec.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When this test runs, upon observing the command log, we will see the `visit`
    command, as well as the application that we just visited in the Cypress application
    preview on the right, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 â€“ Visiting the Todo application'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.4_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 â€“ Visiting the Todo application
  prefs: []
  type: TYPE_NORMAL
- en: Even though our application does not have any assertions, our test still passes
    as no error leading to the failure of our test has caused Cypress to throw an
    exception. Cypress commands are built to fail by default if they encounter an
    error, and this adds to the confidence we have when writing our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for an element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make sure that Cypress performs some action in our application, we need
    to perform an action that will cause the application state to change. Here, we
    will search for a Todo application input element that is used to *add a Todo*
    item to our application. The following code block will search for the element
    that''s responsible for adding a new Todo item and verify that it is present in
    the URL we just navigated to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When the Cypress `cy.get()` command does not find the input element, an error
    will be thrown; otherwise, Cypress will pass the test. To get the input element,
    we do not need to verify that the element exists as Cypress already handles this
    using the **default assertions** that are chained in most Cypress commands.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Default assertions in Cypress are built-in mechanisms that will cause a command
    to fail without the need for explicit assertions to be declared by the user. With
    these commands, Cypress takes care of the behavior of an exception if it's encountered
    while executing the said command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows Cypress searching for the Todo input element
    that is responsible for adding Todo items to our Todo list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 â€“ Searching for the Todo input element'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.5_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 â€“ Searching for the Todo input element
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can verify that Cypress visited the Todo application URL, then checked
    that the input element that adds Todo items exists.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the Todo input element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have confirmed we have an input element in our Todo application,
    it is time to interact with the application and change its state. To change the
    state of the Todo application, we will add a Todo item using the input element
    that we verified exists. Cypress chains commands together. To interact with our
    element, we will use the Cypress`.type()` command to send a string to the element
    and add the Todo item to the application state. The following code block will
    add a new Todo using the Todo input element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code block builds on the previous code and uses the Cypress `type()`
    function to add a new Todo. Here, we also invoked the `{enter}` argument of the
    Cypress `type` method to simulate the *Enter* key functionality since the Todo
    application does not have a submit button to click for us to add a new Todo item.
    The following screenshot shows the added Todo item. With this item, we can verify
    that our test was successfully able to add a new Todo item. This item is visible
    on the Todo list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 â€“ Interacting with the Todo input element'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.6_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 â€“ Interacting with the Todo input element
  prefs: []
  type: TYPE_NORMAL
- en: Our test runner shows that a new Todo has been created. Again our test passes,
    even without an assertion, since the commands that have been run have passed the
    default Cypress assertions. Now, we need to assert that the application state
    has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Asserting the application state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we''ve added our Todo, we need to assert that our new Todo item has
    been added and that the application state has changed due to the addition of the
    Todo item. To do this, we need to add an assertion once we''ve added our Todo
    item. In the following code block, we will assert our changes to the application
    state. Here, we have added an assertion to check that the`.Todo-list` class, which
    holds the list items, is equal to `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To further validate our state changes, we can add more Todo items to verify
    that the number of items increases as we add Todo items.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Cypress, we can use assertion functions such as `.should()` and `expect()`,
    which are bundled within the tools that make up Cypress. By default, Cypress extends
    all the functions that are in the Chai library, which is the default Cypress assertion
    library. The following screenshot shows two added Todo items and a confirmation
    note on the Cypress preview stating that the two added Todo items exist in the
    Todo list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 â€“ Asserting the application state'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.7_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 â€“ Asserting the application state
  prefs: []
  type: TYPE_NORMAL
- en: 'In this test, we can verify that all the added Todos are visible on the Cypress
    app''s preview page and that our assertion passes. We can now add more assertions,
    specifically to check that the name of the first Todo is `New Todo` and that the
    other added Todo is called `Another Todo`. To do this, we will add more assertions
    to our test and check specific details of our Todo items. In the following code
    block, we will verify that Cypress can check the names of the added Todo items;
    that is, *New Todo* and *Another Todo*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In these assertions, we have used the Cypress `cy.get()` method to find the
    elements using their CSS classes and then identified the first and last added
    Todo items by their text.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise on practical testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the GitHub repository link mentioned in the *Technical requirements* section,
    write a test that navigates to the Todo application and add three new Todo items
    to it. Write tests that check that the Todo items that have been added exist by
    verifying their values and their quantity.
  prefs: []
  type: TYPE_NORMAL
- en: Recap â€“ writing practical tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we wrote our first practical test. Here, we visited a page,
    checked that the page had an input element, interacted with the element, and asserted
    that the application state changes. Having understood the flow of tests in Cypress,
    we can now move on and look at the features that make test writing interesting
    in Cypress, such as auto-reload.
  prefs: []
  type: TYPE_NORMAL
- en: Cypress' auto-reload feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Cypress watches for file changes and reloads the tests immediately
    when a file change is detected. This only happens if Cypress is running. The Cypress
    auto-reload feature comes in handy because you do not need to rerun the tests
    once you've made changes to their test files.
  prefs: []
  type: TYPE_NORMAL
- en: With the auto-reload feature, it is possible to have instant feedback and understand
    whether their changes were successful or whether their tests are failing. Due
    to this, this feature allows you to save time that would have otherwise been used
    for debugging tests or checking whether the changes that were made fixed the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'While Cypress'' auto-reload feature is enabled by default, you may opt to turn
    it off and manually rerun the tests after making a change. Cypress allows you
    to stop watching for file changes. This can either be done by configuring the
    `cypress.json` file or by using Cypress'' command-line configuration options.
    When using the `cypress.json` configuration file, the setting you must use to
    disable watching for file changes is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This setting will persist and permanently disable file changes as long as Cypress
    is running, unless the configuration is altered or changed to `true`. The other
    option when it comes to disabling Cypress watching for the file changes is to
    use the command-line configuration option shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With this command, Cypress will temporarily stop watching for file changes,
    and will only change this behavior when we stop the execution of Cypress on our
    terminal window. Cypress will then continue to watch for file changes and auto-reload
    whenever changes are made to a test file.
  prefs: []
  type: TYPE_NORMAL
- en: Recap â€“ Cypress' auto-reload feature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learned how Cypress utilizes the auto-reload feature to
    watch for file changes and immediately reload and rerun when any changes take
    place in our test files. We also learned how to easily turn off the auto-reload
    feature in Cypress either by permanently disabling it using the `cypress.json`
    file or by passing the command in the command-line configuration when running
    our tests. Next, we will be looking at Cypress assertions.
  prefs: []
  type: TYPE_NORMAL
- en: Cypress assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned in the previous section, when writing our first test, assertions
    exist to describe the desired state of the application. Assertions in Cypress
    behave like guards to the tests in that they validate that the desired state and
    the present state are the same. Cypress assertions are unique as they are retried
    when Cypress commands are running until a timeout is reached or until an element
    is found.
  prefs: []
  type: TYPE_NORMAL
- en: Cypress assertions originate from the **chai**, **chai-jquery** and **sinon-chai**
    modules, which come bundled with the Cypress installation. Cypress also allows
    you to write custom assertions using the Chai plugins. However, in this section,
    we will focus on the default assertions that come bundled with Cypress, and not
    on the custom assertions that can be extended as plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write Cypress assertions in two ways: either by explicitly defining
    subjects or by implicitly defining subjects. Cypress recommends implicitly defining
    subjects in assertions as they are immediate to the element that the Cypress commands
    are working on. The following are how assertions are classified in the Cypress
    framework:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implicit subjects: `.should()` or `.and()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Explicit subjects: `expect()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at each of them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit subjects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `should` or `and` commands are Cypress commands, which means they can directly
    act on the immediately yielded subjects from Cypress. The commands can also be
    chained with other Cypress commands, which makes them easy to work with while
    at the same time guaranteeing an immediate response when invoking them. The following
    code block demonstrates how to test implicit subjects. Here, we will use the output
    of the `cy.get` command to make assertions in our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using the `should()`command to assert that the input element for
    the Todo items has a placeholder value. The `should` command is chained from the
    `cy.get()` command. This not only makes it easy to work with, but also reduces
    the amount of code that is required to assert that the placeholder is what it
    is. In the following code block, we are combining different assertions of an implicit
    subject that will be returned by the `cy.get` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have used the `.and()` Cypress command to further verify that the
    element that was just yielded has both a placeholder and a CSS class called `new-todo`.
    With these implicit assertions, we can verify that by using implicit subjects,
    we can chain off multiple commands from the same yielded response from Cypress,
    and also assert different items. The following code block shows code assertions
    that have been made by using explicit subjects where we have to declare each subject
    that we are asserting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when using implicit subjects, we can make cleaner assertions
    and reduce the amount of code we write. In this code block, every assertion has
    to be on the same line and acted upon individually.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit subjects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use `expect()` when we want to assert specific subjects that we define when
    running a test. Explicit subjects are common in **unit tests** and are great when
    there is a need to perform some logic before we perform the assertion or even
    have several assertions for the same subject. The following code block shows explicit
    subject assertion using the `expect` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This code block shows an explicit comparison of the instantiated `string` to
    our expectations. The declared `string` is an explicit subject, which means it
    can be asserted more than once and also manipulated before it performs the assertions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For complex assertions, we can use the `.should()` method to assert explicit
    subjects. This allows a callback function to be passed with the subject that has
    been yielded as the first argument. We can add assertions inside the `should`
    function like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have visited the URL, then used the yielded element from `cy.get('new-todo')`
    to assert that a CSS class with the name `new-todo` exists. This test allows us
    to query for an element and also write different assertions for the subject as
    the need arises.
  prefs: []
  type: TYPE_NORMAL
- en: Exerciseâ€“implicit and explicit subjects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the knowledge you've obtained from this section and by using the GitHub
    repository link mentioned in the *Technical requirements* section as a reference
    point, complete the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the Todo application URL ([http://todomvc.com/examples/react/#/](http://todomvc.com/examples/react/#/))
    and add a Todo:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a test using implicit subject assertions to assert that the Todo has been
    added, and that the name you entered is the same name that is displayed on the
    Todo items list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the Todo app URL, mark a Todo as completed. Then, using the explicit subject's
    assertion, write a test to verify that the completed Todo has been marked as completed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recap â€“ Cypress assertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learned how to assert both explicit and implicit subjects
    and looked at how different and similar they are. We also learned that different
    assertion types can be used for different subjects. We then had the chance to
    carry out an exercise to practice our skills of asserting implicit and explicit
    subjects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to classify tests in Cypress by understanding
    what passing, failing, and skipped tests mean and how Cypress views and represents
    tests in the test runner and command log. We also learned about the structure
    of the test file and the acceptable file extensions for Cypress tests. We then
    wrote our first practical tests, which tested that a Todo application can add,
    delete, and mark a Todo as completed. The highlight of this chapter was learning
    how Cypress watches for file changes and how we can carry out our assertions in
    Cypress either by explicitly asserting our test subjects or implicitly asserting
    them. By completing this chapter, you know how to write a basic test in Cypress
    by working with elements and understanding the assertions that are available.
    In the next chapter, we will learn how to debug running tests in Cypress and the
    tools that we can use for that purpose.
  prefs: []
  type: TYPE_NORMAL
