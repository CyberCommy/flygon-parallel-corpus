- en: Chapter 6. Selecting a Build System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding chapters covered the four elements of embedded Linux and showed
    you, step-by-step, how to build a toolchain, a bootloader, a kernel, and a root
    filesystem, and then combine them into a basic embedded Linux system. And there
    are a lot of steps! Now it is time to look at ways to simplify the process by
    automating it as much as possible. I will look at how embedded build systems can
    help, and look at two in particular: Buildroot and the Yocto Project. Both are
    complex and flexible tools which would require an entire book to adequately describe
    how they work. In this chapter, I only want to show you the general ideas behind
    build systems. I will show you how to build a simple device image to get an overall
    feel of the system and then how to make some useful changes, using the Nova board
    example from the previous chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: No more rolling your own embedded Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of creating a system manually, as described in [Chapter 5](ch05.html
    "Chapter 5. Building a Root Filesystem"), *Building a Root Filesystem,* is called
    the **roll your own** (**RYO**) process. It has the advantage that you are in
    complete control of the software and you can tailor it to do anything you like.
    If you want it to do something truly odd but innovative, or if you want to reduce
    the memory footprint to the smallest possible, RYO is the way to go. But, in the
    vast majority of situations, building manually is a waste of time and produces
    inferior, unmaintainable systems.
  prefs: []
  type: TYPE_NORMAL
- en: They are usually built incrementally over a period of months, often undocumented
    and seldom recreated from scratch because nobody had a clue where each part came
    from.
  prefs: []
  type: TYPE_NORMAL
- en: Build systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The idea of a build system is to automate all the steps I have described up
    to this point. A build system should be able to build, from upstream source code,
    some or all of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The toolchain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bootloader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The root filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building from an upstream source is important for a number of reasons. It means
    that you have peace of mind that you can rebuild at any time, without external
    dependencies. It also means that you have the source code for debugging and that
    you can meet your license requirements to distribute that to users where necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore to do its job, a build system has to be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Download a source from upstream, either directly from the source code control
    system or as an archive, and cache it locally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply patches to enable cross compilation, fix architecture-dependent bugs,
    apply local configuration policies, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build the various components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a staging area and assemble a root filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create image files in various formats ready to be loaded onto the target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other things that are useful are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Add your own packages containing, for example, applications or kernel changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Select various root filesystem profiles: large or small, with and without graphics
    or other features'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a standalone SDK that you can distribute to other developers so that
    they don't have to install the complete build system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Track which open source licenses are used by the various packages you have selected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow you to create updates for in-field updating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a user-friendly user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all cases, they encapsulate the components of a system into packages, some
    for the host and some for the target. Each package is defined by a set of rules
    to get the source, build it, and install the results in the correct location.
    There are dependencies between the packages and a build mechanism to resolve the
    dependencies and build the set of packages required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open source build systems have matured considerably over the last few years.
    There are many around, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Buildroot**: An easy-to-use system using GNU `make` and `Kconfig` ([http://buildroot.org](http://buildroot.org))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EmbToolkit**: A simple system for generating root filesystems; the only one
    at the time of writing that supports LLVM/Clang out of the box ([https://www.embtoolkit.org](https://www.embtoolkit.org))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenEmbedded**: A powerful system which is also a core component of the Yocto
    Project and others ([http://openembedded.org](http://openembedded.org))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenWrt**: A build tool oriented towards building firmware for wireless routers
    ([https://openwrt.org](https://openwrt.org))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PTXdist**: An open source build system sponsored by Pengutronix ([http://www.pengutronix.de/software/ptxdist/index_en.html](http://www.pengutronix.de/software/ptxdist/index_en.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tizen**: A comprehensive system, with emphasis on mobile, media, and in-vehicle
    devices ([https://www.tizen.org](https://www.tizen.org))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Yocto Project**: This extends the OpenEmbedded core with configuration,
    layers, tools, and documentation: probably the most popular system ([http://www.yoctoproject.org](http://www.yoctoproject.org))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I will concentrate on two of these: Buildroot and The Yocto Project. They approach
    the problem in different ways and with different objectives.'
  prefs: []
  type: TYPE_NORMAL
- en: Buildroot has the primary aim of building root filesystem images, hence the
    name, although it can build bootloader and kernel images as well. It is easy to
    install and configure, and generates target images quickly.
  prefs: []
  type: TYPE_NORMAL
- en: The Yocto Project, on the other hand, is more general in the way it defines
    the target system and so it can build fairly complex embedded devices. Every component
    is generated as a package in RPM, `.dpkg` or `.ipk` format (see the following
    section) and then the packages are combined together to make the filesystem image.
    Furthermore, you can install a package manager in the filesystem image, which
    allows you to update packages at runtime. In other words, when you build with
    the Yocto Project, you are, in effect, creating your own custom Linux distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Package formats and package managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mainstream Linux distributions are, in most cases, constructed from collections
    of binary (precompiled) packages in either RPM or deb format. **RPM** stands for
    **Red Hat Package Manager** and is used in Red Hat, Suse, Fedora, and other distributions
    based on them. Debian-derived distributions, including Ubuntu and Mint, use the
    Debian package manager format, `deb`. In addition, there is a light-weight format
    specific to embedded devices known as the **Itsy PacKage** format, or **ipk**,
    which is based on `deb`.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to include a package manager on the device is one of the big differentiators
    between build systems. Once you have a package manager on the target device, you
    have an easy path to deploy new packages to it and to update existing ones. I
    will talk about the implications of this in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Buildroot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Buildroot project website is at [http://buildroot.org](http://buildroot.org).
  prefs: []
  type: TYPE_NORMAL
- en: Current versions of Buildroot are capable of building a toolchain, a bootloader
    (U-Boot, Barebox, GRUB2, or Gummiboot), a kernel, and a root filesystem. It uses
    GNU `make` as the principal build tool.
  prefs: []
  type: TYPE_NORMAL
- en: There is good online documentation at [http://buildroot.org/docs.html](http://buildroot.org/docs.html),
    including *The Buildroot User Manual*.
  prefs: []
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Buildroot was one of the first build systems. It began as part of the uClinux
    and uClibc projects as a way of generating a small root filesystem for testing.
    It became a separate project in late 2001 and continued to evolve through to 2006,
    after which it went into a rather dormant phase. However, since 2009, when Peter
    Korsgaard took over stewardship, it has been developing rapidly, adding support
    for `glibc`-based toolchains and the ability to build a bootloader and a kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Buildroot is also the foundation of another popular build system, OpenWrt ([http://wiki.openwrt.org](http://wiki.openwrt.org))
    which forked from Buildroot around 2004\. The primary focus of OpenWrt is to produce
    software for wireless routers and so the package mix is oriented towards networking
    infrastructure. It also has a runtime package manager using the `.ipk` format
    so that a device can be updated or upgraded without a complete re-flash of the
    image.
  prefs: []
  type: TYPE_NORMAL
- en: Stable releases and support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Buildroot developers produce stable releases four times a year, in February,
    May, August, and November. They are marked by `git` tags of the form `<year>.02`,
    `<year>.05`, `<year>.08`, and `<year>.11`. Typically, when you start your project,
    you will be using the latest stable release. However, the stable releases are
    seldom updated after release. To get security fixes and other bug fixes you will
    have to either continually update to the next stable release as they become available
    or backport the fixes into your version.
  prefs: []
  type: TYPE_NORMAL
- en: Installing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As usual, you can install Buildroot either by cloning the repository or downloading
    an archive. Here is an example of obtaining version 2015.08.1, which was the latest
    stable version at the time of writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The equivalent TAR archive is available from [http://buildroot.org/downloads](http://buildroot.org/downloads).
  prefs: []
  type: TYPE_NORMAL
- en: Next, you should read the section titled *System Requirement* from *The Buildroot
    User Manual*, available at [http://buildroot.org/downloads/manual/manual.html](http://buildroot.org/downloads/manual/manual.html)
    and make sure that you have installed all the packages listed there.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Buildroot uses the `Kconfig` and `Kbuild` mechanisms as the kernel, which I
    described in the section *Understanding kernel configuration* in [Chapter 4](ch04.html
    "Chapter 4. Porting and Configuring the Kernel"), *Porting and Configuring the
    Kernel*. You can configure it from scratch directly using `make menuconfig` (or
    `xconfig` or `gconfig`), or you can choose one of the 90 or so configurations
    for various development boards and the QEMU emulator which you can find stored
    in the directory `configs/`. Typing `make help` lists all the targets including
    the default configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by building a default configuration that you can run on the ARM
    QEMU emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that you do not tell `make` how many parallel jobs to run with a `-j`
    option: Buildroot will make optimum use of your CPUs all by itself. If you want
    to limit the number of jobs, you can run `make menuconfig` and look under **Build**
    options.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The build will take half an hour to an hour, depending on the capabilities
    of your host system and the speed of your link to the Internet. When it is complete,
    you will find that two new directories have been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dl/`: This contains archives of the upstream projects that Buildroot has built'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output/`: This contains all the intermediate and final compiled resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will see the following in `output/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`build/`: This is the build directory for each component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`host/`: This contains various tools required by Buildroot that run on the
    host, including the executables of the toolchain (in `output/host/usr/bin`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`images/`: This is the most important of all and contains the results of the
    build. Depending on what you selected when configuring, you will find a bootloader,
    a kernel, and one or more root filesystem images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`staging/`: This is a symbolic link to the `sysroot` of the toolchain. The
    name of the link is a little confusing because it does not point to a staging
    area as I defined it in [Chapter 5](ch05.html "Chapter 5. Building a Root Filesystem"),
    *Building a Root Filesystem*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`target/`: This is the staging area for the root directory. Note that you cannot
    use this as a root filesystem, as it stands, because the file ownership and permissions
    are not set correctly. Buildroot uses a device table, as described in the previous
    chapter, to set ownership and permissions when the filesystem image is created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some of the sample configurations have a corresponding entry in the directory
    `boards/`, which contains custom configuration files and information about installing
    the results on the target. In the case of the system you have just built, the
    relevant file is `board/qemu/arm-vexpress/readme.txt`, which tells you how to
    start QEMU with this target.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that you have already installed `qemu-system-arm` as described in
    [Chapter 1](ch01.html "Chapter 1. Starting Out"), *Starting Out*, you can run
    it using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the kernel boot messages appear in the same terminal window
    where you started QEMU, followed by a login prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Log in as `root`, no password.
  prefs: []
  type: TYPE_NORMAL
- en: You will see that QEMU launches a black window in addition to the one with the
    kernel boot messages. It is there to display the graphics frame buffer of the
    target. In this case, the target never writes to the `framebuffer`, which is why
    it appears black. To close QEMU, either type `poweroff` at the root prompt or
    just close the `framebuffer` window. This works with QEMU 2.0 (default on Ubuntu
    14.04), but fails with earlier versions including QEMU 1.0.50 (default on Ubuntu
    12.04) because of problems with the SCSI emulation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom BSP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let''s use Buildroot to create a BSP for our Nova board, using the same
    versions of U-Boot and Linux from earlier chapters. The recommended places to
    store your changes are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`board/<organization>/<device>`: contains any patches, binary blobs, extra
    build steps, configuration files for Linux, U-Boot, and other components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`configs/<device>_defconfig`: contains the default configuration for the board'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`packages/<organization>/<package_name>`: is the place to put any additional
    packages for this board'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use the BeagleBone configuration file as a base, since Nova is a close
    cousin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `.config` file is set for BeagleBone. Next, create a directory for
    the board configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: U-Boot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Chapter 3](ch03.html "Chapter 3. All About Bootloaders"), *All About Bootloaders*,
    we created a custom bootloader for Nova, based on the 2015.07 of U-Boot version
    and created a patch file for it. We can configure Buildroot to select the same
    version, and apply our patch. Begin by by copying the patch file into `board/melp/nova`,
    and then use `make menuconfig` to set the U-Boot version to 2015.07, the patch
    directory to `board/melp/nova` and the board name to nova, as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![U-Boot](img/B03982_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Chapter 4](ch04.html "Chapter 4. Porting and Configuring the Kernel"),
    *Porting and Configuring the Kernel*, we based the kernel on Linux 4.1.10 and
    supplied a new device tree, named `nova.dts`. Copy the device tree to `board/melp/nova`
    and change the Buildroot kernel configuration to use this version and the nova
    device tree as show in in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linux](img/B03982_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Build
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you can build the system for the Nova board just by typing `make`, which
    produces these files in the directory `output/images`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to save a copy of the configuration so that you and others
    can use it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, you have a Buildroot configuration for the Nova board.
  prefs: []
  type: TYPE_NORMAL
- en: Adding your own code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose that there are some programs that you have developed that you want
    to include in the build. You have two options: firstly to build them separately,
    using their own build systems, and then roll the binary into the final build as
    an overlay. Secondly you could create a Buildroot package that can be selected
    from the menu and built like any other.'
  prefs: []
  type: TYPE_NORMAL
- en: Overlay
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An overlay is simply a directory structure that is copied over the top of the
    Buildroot root filesystem at a late stage in the build process. It can contain
    executables, libraries and anything else you may want to include. Note that any
    compiled code must be compatible with the libraries deployed at runtime, which
    means that it must be compiled with the same toolchain that Buildroot uses. Using
    the Buildroot toolchain is quite easy: just add it to the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The prefix for the tools is `<ARCH>-linux-`.
  prefs: []
  type: TYPE_NORMAL
- en: The overlay directory is set by `BR2_ROOTFS_OVERLAY`, which contains a list
    of directories separated by spaces, which you should overlay on the Buildroot
    root filesystem. It can be configured in `menuconfig` with the option **System
    configuration** | **Root filesystem overlay directories**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you add a `helloworld` program to the `bin` directory, and
    a script to start it at boot time, you would create an overlay directory with
    the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overlay](img/B03982_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Then you would add `board/melp/nova/overlay` to the overlay options.
  prefs: []
  type: TYPE_NORMAL
- en: The layout of the root filesystem is controlled by the `system/skeleton` directory,
    and the permissions are set in `device_table_dev.txt` and `device_table.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Buildroot packages are stored in the `package` directory, over 1,000 of them,
    each in its own subdirectory. A package consists of at least two files: `Config.in,`
    containing the snippet of `Kconfig` code required to make the package visible
    in the **configuration** menu, and a `makefile` named `<package_name>.mk`. Note
    that the package does not contain the code, just the instructions to get the code
    by downloading a tarball, doing a git pull, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: The `makefile` is written in a format expected by Buildroot and contains directives
    that allow Buildroot to download, configure, compile, and install the program.
    Writing a new package `makefile` is a complex operation which is covered in detail
    in the *Buildroot User Manual*. Here is an example which shows you how to create
    a package for a simple program stored locally, such as our `helloworld` program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by creating the subdirectory `package/helloworld` with a configuration
    file, `Config.in`, that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first line must be of the format `BR2_PACKAGE_<uppercase package name>`.
    That is followed by a Boolean and the package name as it will appear in the **configuration**
    menu and which will allow a user to select this package. The *Help* section is
    optional (but hopefully useful).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, link the new package into the **Target Packages** menu by editing `package/Config.in`
    and sourcing the configuration file as mentioned in the preceding section. You
    could append this to an existing sub-menu but, in this case, it seems neater to
    create a new sub-menu which only contains our package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a makefile, `package/helloworld/helloworld.mk`, to supply the
    data needed by Buildroot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The location of the code is hard-coded to a local path name. In a more realistic
    case, you would get the code from a source code system or from a central server
    of some kind: there are details of how to do this in the *Buildroot User Guide*
    and plenty of examples in other packages.'
  prefs: []
  type: TYPE_NORMAL
- en: License compliance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Buildroot is based on open source software, as are the packages it compiles.
    At some point during the project, you should check the licenses, which you can
    do by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The information is gathered into `output/legal-info`. There are summaries of
    the licenses used to compile the host tools in `host-manifest.csv` and, on the
    target, in `manifest.csv`. There is more information in the `README` file and
    in the *Buildroot User Manual*.
  prefs: []
  type: TYPE_NORMAL
- en: The Yocto Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Yocto Project is a more complex beast than Buildroot. Not only can it build
    toolchains, bootloaders, kernels, and root filesystems, as Buildroot can, but
    it can generate an entire Linux distribution for you, with binary packages that
    can be installed at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The Yocto Project is primarily a group of recipes, similar to Buildroot packages
    but written using a combination of Python and shell script, and a task scheduler
    called BitBake that produces whatever you have configured, from the recipes.
  prefs: []
  type: TYPE_NORMAL
- en: There is plenty of online documentation at [https://www.yoctoproject.org/](https://www.yoctoproject.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The structure of the Yocto Project makes more sense if you look at the background
    first. Its roots are in OpenEmbedded, [http://openembedded.org/](http://openembedded.org/)
    which, in turn, grew out of a number of projects to port Linux to various hand-held
    computers, including the Sharp Zaurus and Compaq iPaq. OpenEmbedded came to life
    in 2003 as the build system for those hand-held computers but quickly expanded
    to encompass other embedded boards. It was developed and continues to be developed
    by an enthusiastic community of programmers.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenEmbedded project set out to create a set of binary packages using the
    compact `.ipk` format, which could then be combined in various ways to create
    a target system and be installed on the target at runtime. It did this by creating
    recipes for each piece of software and using BitBake as the task scheduler. It
    was, and is, very flexible. By supplying the right metadata, you can create an
    entire Linux distribution to your own specification. One that is fairly well known
    is *The Ångström Distribution*, [http://www.angstrom-distribution.org](http://www.angstrom-distribution.org),
    but there are many others.
  prefs: []
  type: TYPE_NORMAL
- en: At some time in 2005 Richard Purdie, then a developer at OpenedHand, created
    a fork of OpenEmbedded which had a more conservative choice of packages and created
    releases that were stable over a period of time. He named it Poky, after the Japanese
    snack (if you are worried about these things, Poky is pronounced to rhyme with
    hockey). Although Poky was a fork, OpenEmbedded and Poky continued to run alongside
    each other, sharing updates and keeping the architectures more or less in step.
    Intel brought out OpenedHand in 2008 and they transferred Poky Linux to the Linux
    Foundation in 2010 when they formed the Yocto Project.
  prefs: []
  type: TYPE_NORMAL
- en: Since 2010, the common components of OpenEmbedded and Poky have been combined
    into a separate project known as OpenEmbedded core, or just oe-core.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the Yocto Project collects together several components, the most
    important of which are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Poky**: The reference distribution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**oe-core**: The core metadata, which is shared with OpenEmbedded'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BitBake**: The task scheduler, which is shared with OpenEmbedded and other
    projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation**: User manuals and developer''s guides for each component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hob**: A graphical user interface to OpenEmbedded and BitBake'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Toaster**: A web-based interface to OpenEmbedded and BitBake'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ADT Eclipse**: A plug-in for Eclipse that makes it easier to build projects
    using the Yocto Project SDK'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strictly speaking, the Yocto Project is an umbrella for these sub-projects.
    It uses OpenEmbedded as its build system, and Poky as its default configuration
    and reference environment. However, people often use the term "the Yocto Project"
    to refer to the build system alone. I feel that it is too late for me to turn
    this tide, so for brevity I will do the same. I apologise in advance to the developers
    of OpenEmbedded.
  prefs: []
  type: TYPE_NORMAL
- en: The Yocto Project provides a stable base which can be used as it is or which
    can be extended using meta layers, which I will discuss later in this chapter.
    Many SoC vendors provide board support packages for their devices in this way.
    Meta layers can also be used to create extended, or just different, build systems.
    Some are open source, such as the Angstrom Project, others are commercial, such
    as MontaVista Carrier Grade Edition, Mentor Embedded Linux, and Wind River Linux.
    The Yocto Project has a branding and compatibility testing scheme to ensure that
    there is interoperability between components. You will see statements like *Yocto
    Project Compatible 1.7* on various web pages.
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, you should think of the Yocto Project as the foundation of a whole
    sector of embedded Linux, as well as being a complete build system in its own
    right. You may be wondering about the name, *yocto*. A yocto is the SI prefix
    for 10-24, in the same way that micro is 10-6\. Why name the project yocto? It
    was partly to indicate that it could build very small Linux systems (although,
    to be fair, so can other build systems), but also, perhaps, to steal a march on
    the Ångström distribution which is based on OpenEmbedded. An Ångström is 10-10\.
    That's huge, compared to a yocto!
  prefs: []
  type: TYPE_NORMAL
- en: Stable releases and support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Usually, there is a release of the Yocto Project every six months, in April
    and October. They are principally known by the code name, but it is useful to
    know the version numbers of the Yocto Project and Poky as well. Here is a table
    of the four most recent releases at the time of writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Code name | Release date | Yocto version | Poky version |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Fido` | April 2015 | 1.8 | 13 |'
  prefs: []
  type: TYPE_TB
- en: '| `Dizzy` | October 2014 | 1.7 | 12 |'
  prefs: []
  type: TYPE_TB
- en: '| `Daisy` | April 2014 | 1.6 | 11 |'
  prefs: []
  type: TYPE_TB
- en: '| `Dora` | October 2013 | 1.5 | 10 |'
  prefs: []
  type: TYPE_TB
- en: The stable releases are supported with security and critical bug fixes for the
    current release cycle and the next cycle, that is approximately twelve months
    after release. No toolchain or kernel version changes are allowed for these updates.
    As with Buildroot, if you want continued support, you can update to the next stable
    release or you can backport changes to your version. You also also have the option
    of commercial support for periods of several years with the Yocto Project from
    operating system vendors such as Mentor Graphics, Wind River, and many others.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Yocto Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get a copy of the Yocto Project, you can either clone the repository, choosing
    the code name as the branch which is `fido` in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can also download the archive from [http://downloads.yoctoproject.org/releases/yocto/yocto-1.8/poky-fido-13.0.0.tar.bz2](http://downloads.yoctoproject.org/releases/yocto/yocto-1.8/poky-fido-13.0.0.tar.bz2).
  prefs: []
  type: TYPE_NORMAL
- en: In the first case, you will find everything in the `poky` directory, in the
    second case, `poky-fido-13.0.0/`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you should read the section titled *System Requirements* from the
    *Yocto Project Reference Manual* ([http://www.yoctoproject.org/docs/current/ref-manual/ref-manual.html#detailed-supported-distros](http://www.yoctoproject.org/docs/current/ref-manual/ref-manual.html#detailed-supported-distros))
    and, in particular, you should make sure that the packages listed there are installed
    on your host computer.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with Buildroot, let''s begin with a build for the ARM QEMU emulator. Begin
    by sourcing a script to set up the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: That creates a working directory for you named `build` and makes it the current
    directory. All of the configuration, intermediate, and deployable files will be
    put in this directory. You must source this script each time you want to work
    on this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can choose a different working directory by adding it as a parameter to
    `oe-init-build-env`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'That will put you into the `build-qemuarm` directory. You can then have several
    projects on the go at the same time: you choose which one you want to work with
    through the parameter to `oe-init-build-env`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, the `build` directory contains only one subdirectory named `conf`,
    which contains the configuration files for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`local.conf`: Contains a specification of the device you are going to build
    and the build environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bblayers.conf`: Contains a list of the directories that contain the layers
    you are going to use. There will be more on layers later on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templateconf.cfg`: Contains the name of a directory which contains various
    `conf` files. By default, it points to `meta-yocto/conf`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For now, we just need to set the `MACHINE` variable in `local.conf` to `qemuarm`
    by removing the comment character at the start of this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Building
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To actually perform the build, you need to run `bitbake`, telling it which
    root filesystem image you want to create. Some common images are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**core-image-minimal**: A small console-based system which is useful for tests
    and as the basis for custom images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**core-image-minimal-initramfs**: This is similar to core-image-minimal, but
    built as a ramdisk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**core-image-x11**: A basic image with support for graphics through an X11
    server and the xterminal terminal app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**core-image-sato**: A full graphical system based on Sato, which is a mobile
    graphical environment built on X11, and GNOME. The image includes several apps
    including a terminal, an editor, and a file manager.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By giving BitBake the final target, it will work backwards and build all the
    dependencies first, beginning with the toolchain. For now, we just want to create
    a minimal image to see whether or not it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The build is likely to take some time, maybe more than an hour. When it is
    complete, you will find several new directories in the build directory including
    `build/downloads`, which contains all the source downloaded for the build, and
    `build/tmp` which contains most of the build artifacts. You should see the following
    in `tmp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`work`: Contains the build directory and the staging area for all components,
    including the root filesystem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deploy`: Contains the final binaries to be deployed on the target:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deploy/images/[machine name]`: Contains the bootloader, the kernel, and the
    root filesystem images ready to be run on the target'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deploy/rpm`: Contains the RPM packages that went to make up the images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deploy/licenses`: Contains the license files extracted from each package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you build a QEMU target, an internal version of QEMU is generated, which
    removes the need to install the QEMU package for your distribution and thus avoids
    version dependencies. There is a wrapper script named `runqemu` for this internal
    QEMU.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the QEMU emulation, make sure that you have sourced `oe-init-build-env`
    and then just type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, QEMU has been configured with a graphic console so that the boot
    messages and login prompt appear in the black framebuffer screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running](img/B03982_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can log on as `root`, without a password. You can close down QEMU by closing
    the framebuffer window. You can launch QEMU without the graphic window by adding
    `nographic` to the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you close QEMU using the key sequence *Ctrl* + *A* + *X*.
  prefs: []
  type: TYPE_NORMAL
- en: The `runqemu` script has many other options, type `runqemu help` for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The metadata for the Yocto Project is structured into layers, by convention,
    each with a name beginning with `meta`. The core layers of the Yocto Project are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**meta**: This is the OpenEmbedded core'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**meta-yocto**: Metadata specific to the Yocto Project, including the Poky
    distribution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**meta-yocto-bsp**: Contains the board support packages for the reference machines
    that the Yocto Project supports'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of layers in which BitBake searches for recipes is stored in `<your
    build directory>/conf/bblayers.conf` and, by default, includes all three layers
    mentioned in the preceding list.
  prefs: []
  type: TYPE_NORMAL
- en: 'By structuring the recipes and other configuration data in this way, it is
    very easy to extend the Yocto Project by adding new layers. Additional layers
    are available from SoC manufacturers, the Yocto Project itself, and a wide range
    of people wishing to add value to the Yocto Project and OpenEmbedded. There is
    a useful list of layers at [http://layers.openembedded.org](http://layers.openembedded.org).
    Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**meta-angstrom**: The Ångström distribution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**meta-qt5**: Qt5 libraries and utilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**meta-fsl-arm**: BSPs for Freescale ARM-based SoCs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**meta-fsl-ppc**: BSPs for Freescale PowerPC-based SoCs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**meta-intel**: BSPs for Intel CPUs and SoCs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**meta-ti**: BSPs for TI ARM-based SoCs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a layer is as simple as copying the meta directory into a suitable location,
    usually alongside the default meta layers, and adding it to `bblayers.conf`. Just
    make sure it is compatible with the version of the Yocto Project you are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the way layers work, let''s create a layer for our Nova board
    which we can use for the remainder of the chapter as we add features. Each meta
    layer has to have at least one configuration file, `conf/layer.conf`, and should
    also have a `README` file and a license. There is a handy helper script that does
    the basics for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The script asks for a priority, and if you want to create sample recipes. In
    the example here, I just accepted the defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'That will create a layer named `meta-nova` with a `conf/layer.conf`, an outline
    `README` and a MIT license in `COPYING.MIT`. The `layer.conf` file looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It adds itself to `BBPATH` and the recipes it contains to `BBFILES`. From looking
    at the code, you can see that the recipes are found in the directories with names
    beginning `recipes-` and have file names ending in `.bb` (for normal BitBake recipes),
    or `.bbappend` (for recipes that extend existing normal recipes by adding and
    overriding instructions). This layer has the name `nova` which is added to the
    list of layers in `BBFILE_COLLECTIONS` and it has a priority of `6`. The layer
    priority is used if the same recipe appears in several layers: the one in the
    layer with the highest priority wins.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you are about to build a new configuration, it is best to begin by creating
    a new build directory named `build-nova`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you need to add this layer to your build configuration, `conf/bblayers.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can confirm that it is set up correctly by using another helper script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There you can see the new layer. It has priority `6` which means that we could
    override recipes in the other layers, which have a lower priority.
  prefs: []
  type: TYPE_NORMAL
- en: At this point it would be a good idea to run a build, using this empty layer.
    The final target will be the Nova board but, for now, build for a BeagelBone Black
    by removing the comment before `MACHINE ?= "beaglebone"` in `conf/local.conf`.
    Then, build a small image using `bitbake core-image-minimal` as before.
  prefs: []
  type: TYPE_NORMAL
- en: As well as recipes, layers may contain BitBake classes, configuration files
    for machines, distributions, and more. I will look at recipes next and show you
    how to create a customized image and how to create a package.
  prefs: []
  type: TYPE_NORMAL
- en: BitBake and recipes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'BitBake processes metadata of several different types, which include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**recipes**: Files ending in `.bb`. These contain information about building
    a unit of software, including how to get a copy of the source code, the dependencies
    on other components, and how to build and install it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**append**: Files ending in `.bbappend`. These allow some details of a recipe
    to be overridden or extended. `A.bbappend` file simply appends its instructions
    to the end of a recipe (`.bb`) file of the same root name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**include**: Files ending in `.inc`. These contain information that is common
    to several recipes, allowing information to be shared among them. The files may
    be included using the `include` or `require` keywords. The difference is that
    `require` produces an error if the file does not exist, whereas `include` does
    not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**classes**: Files ending in `.bbclass`. These contain common build information,
    for example how to build a kernel or how to build an `autotools` project. The
    classes are inherited and extended in recipes and other classes using the `inherit`
    key word. The class `classes/base.bbclass` is implicitly inherited in every recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**configuration**: Files ending in `.conf`. They define various configuration
    variables that govern the project''s build process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A recipe is a collection of tasks written in a combination of Python and shell
    code. The tasks have names like `do_fetch`, `do_unpack`, `do_patch`, `do_configure`,
    `do_compile`, `do_install`, and so on. You use BitBake to execute these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default task is `do_build`, so that you are running the build task for
    that recipe. You can list the tasks available in a recipe by running `bitbake
    core-image-minimal` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-c` option allows you to specify the task, missing off the `do_` part.
    A common use is `-c fetch` to get the code needed by a recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `fetchall` to get the code for the target and all the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The recipe files are are usually named `<package-name>_version.bb`. They may
    have dependencies on other recipes, which would allow BitBake to work out all
    the subtasks that need to be executed to complete the top level job. Unfortunately,
    I don't have the space in this book to describe the dependency mechanism, but
    you will find a full description in the Yocto Project documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, to create a recipe for our `helloworld` program in `meta-nova`,
    you would create a directory structure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The recipe is `helloworld_1.0.bb` and the source is local to the recipe directory
    in the subdirectory files. The recipe contains these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The location of the source code is set by `SRC_URI`: in this case it will search
    directories, files, `helloworld`, and `helloworld-1.0` in the recipe directory.
    The only tasks that need to be defined are `do_compile` and `do_install`, which
    compile the one source file simply and install it into the target root filesystem:
    `${D}` expands to the staging area of the target device and `${bindir}` to the
    default binary directory, `/usr/bin`.'
  prefs: []
  type: TYPE_NORMAL
- en: Every recipe has a license, defined by `LICENSE`, which is set to `GPLv2` here.
    The file containing the text of the license and a checksum is defined by `LIC_FILES_CHKSUM`.
    BitBake will terminate the build if the checksum does not match, indicating that
    the license has changed in some way. The license file may be part of the package
    or it may point to one of the standard license texts in `meta/files/common-licenses`,
    as is the case here.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, commercial licenses are disallowed, but it is easy to enable them.
    You need to specify the license in the recipe, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in your `conf/local.conf`, you would explicitly allow this license, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To make sure that it compiles correctly, you can ask BitBake to build it, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If all goes well, you should see that it has created a working directory for
    it in `tmp/work/cortexa8hf-vfp-neon-poky-linux-gnueabi/helloworld/`.
  prefs: []
  type: TYPE_NORMAL
- en: You should also see there is an RPM package for it in `tmp/deploy/rpm/cortexa8hf_vfp_neon/helloworld-1.0-r0.cortexa8hf_vfp_neon.rpm`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is not part of the target image yet, though. The list of packages to be
    installed is held in a variable named `IMAGE_INSTALL`. You can append to the end
    of that list by adding this line to your `conf/local.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there has to be a space between the first double quote and the first
    package name. Now, the package will be added to any image that you bitbake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If you look in `tmp/deploy/images/beaglebone/core-image-minimal-beaglebone.tar.bz2`
    you will see that `/usr/bin/helloworld` has indeed been installed.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing images via local.conf
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may often want to add a package to an image during development or tweak
    it in other ways. As shown previously, you can simply append to the list of packages
    to be installed by adding a statement like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be no surprise that you can also do the opposite: you can remove
    a package using this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can make more sweeping changes via `EXTRA_IMAGE_FEATURES`. There are too
    many to list here, I recommend you look at the *Image Features* section of the
    *Yocto Project Reference Manual* and the code in `meta/classes/core-image.bbclass`.
    Here is a short list which should give you an idea of the features you can enable:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dbg-pkgs`: installs debug symbol packages for all the packages installed in
    the image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`debug-tweaks`: allows root logins without passwords and other changes that
    make development easier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package-management`: installs package management tools and preserves the package
    manager database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`read-only-rootfs`: makes the root filesystem read-only. We will cover this
    in more detail in [Chapter 7](ch07.html "Chapter 7. Creating a Storage Strategy"),
    *Creating a Storage Strategy*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x11`: installs the X server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x11-base`: installs the X server with a minimal environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x11-sato`: installs the OpenedHand Sato environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an image recipe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problem with making changes to `local.conf` is that they are, well, local.
    If you want to create an image that is to be shared with other developers, or
    to be loaded onto a production system, then you should put the changes into an
    image recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'An image recipe contains instructions about how to create the image files for
    a target, including the bootloader, the kernel, and the root filesystem images.
    You can get a list of the images that are available by using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The recipe for `core-image-minimal` is in `meta/recipes-core/images/core-image-minimal.bb`.
  prefs: []
  type: TYPE_NORMAL
- en: A simple approach is to take an existing image recipe and modify it using statements
    similar to those you used in `local.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine that you want an image that is the same as `core-image-minimal`
    but includes your `helloworld` program and the `strace` utility. You can do that
    with a two-line recipe file which includes (using the `require` keyword) the base
    image and adds the packages you want. It is conventional to put the image in a
    directory named `images`, so add the recipe `nova-image.bb` with this content
    in `meta-nova/recipes-local/images`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove the `IMAGE_INSTALL_append` line from your `local.conf` and
    build it using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to go further and take total control of the contents of the root
    filesystem, you can start from scratch with an empty `IMAGE_INSTALL` variable
    and populate it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`IMAGE_LINGUAS` contains a list of `glibc` locales to be installed in the target
    image. They can take up a lot of space so, in this case, we set the list to be
    empty, which is fine so long as we do not need locale-dependent library functions.
    `IMAGE_ROOTFS_SIZE` is the size of the resulting disk image, in KiB. Most of the
    work is done by the `core-image` class which we inherit at the end.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an SDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is very useful to be able to create a standalone toolchain that other developers
    can install, avoiding the need for everyone in the team to have a full installation
    of the Yocto Project. Ideally, you want the toolchain to include development libraries
    and header files for all the libraries installed on the target. You can do that
    for any image using the `populate_sdk` task, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a self-installing shell script in `tmp/deploy/sdk` named:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, by default, the toolchain does not include static libraries. You
    can enable them individually by adding lines like this to your `local.conf` or
    the image recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also enable them globally as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If you only want a basic toolchain with just C and C++ cross compilers, the
    C library and header files, you can instead run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To install the SDK, just run the shell script. The default install directory
    is `/opt/poky`, but the install script allows you to change that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To make use of the toolchain, first source the environment set up script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Toolchains generated in this way are not configured with a valid `sysroot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Consequently, if you try to cross compile as I have shown in previous chapters,
    it will fail like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because the compiler has been configured to be generic to a wide range
    of ARM processors, and the fine tuning is done when you launch it using the right
    set of `gcc` flags. So long as you use `$CC` to compile, everything should work
    fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: License audit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Yocto Project insists that each package has a license. A copy of the license
    is in `tmp/deploy/licenses/[packagenam.e]` for each package, as it is built. In
    addition, a summary of the packages and licenses used in an image are in the `<image
    name>-<machine name>-<date stamp>` directory. This is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The first file lists the licenses used by each package, the second lists the
    package names only.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can have look at the following documentation for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The Buildroot User Manual*, [http://buildroot.org/downloads/manual/manual.html](http://buildroot.org/downloads/manual/manual.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Yocto Project* documentation: there are nine reference guides plus a tenth
    which is a composite of the others (the so-called *Mega-manual*") at [https://www.yoctoproject.org/documentation](https://www.yoctoproject.org/documentation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Instant Buildroot*, by *Daniel Manchón Vizuete*, Packt Publishing, 2013'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Embedded Linux Development with Yocto Project*, by *Otavio Salvador* and *Daianne
    Angolini*, Packt Publishing, 2014'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using a build system takes the hard work out of creating an embedded Linux
    system, and it is almost always better than hand crafting a roll your own system.
    There is a range of open source build systems available these days: Buildroot
    and the Yocto Project represent two different approaches. Buildroot is simple
    and quick, making it a good choice for fairly simple single-purpose devices: traditional
    embedded Linux as I like to think of them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Yocto Project is more complex and flexible. It is package based, meaning
    that you have the option to install a package manager and perform updates of individual
    packages in the field. The meta layer structure makes it easy to extend the metadata
    and indeed there is good support throughout the community and industry for the
    Yocto Project. The downside is that there is a very steep learning curve: you
    should expect it to take several months to become proficient with it, and even
    then it will sometimes do things that you didn''t expect, or at least that is
    my experience.'
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget that any devices you create using these tools will need to be maintained
    in the field for a period of time, often many years. The Yocto Project will provide
    point releases for about one year after a release, Buildroot usually does not
    provide any point releases. In either case you will find yourself having to maintain
    your release yourself or else paying for commercial support. The third possibility,
    ignoring the problem, should not be considered an option!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter I will look at file storage and filesystems, and at the
    way that the choices you make there will affect the stability and maintainability
    of your embedded Linux.
  prefs: []
  type: TYPE_NORMAL
