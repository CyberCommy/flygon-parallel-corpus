- en: Low-Level Programming with C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Initially, C++ was perceived as the successor of the C language; however, since
    then it has evolved into something big, sometimes scary, and even untamable. With
    recent language updates, it now represents a complex beast that requires time
    and patience to tame. We will start this chapter with the basic constructs that
    almost every language supports, such as data types, conditional and loop statements,
    pointers, structs, and functions. We will look at those constructs from the perspective
    of a low-level systems programmer, curious how even a simple instruction can be
    executed by the computer. A deep understanding of these basic constructs is mandatory
    in building a solid base for more advanced and abstract topics such as object-oriented
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn more about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The details of program execution and its entry point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special properties of the `main()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intricacies behind the function call and recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory segments and addressing fundamentals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data types and how variables reside in memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointers and arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The low-level details of conditionals and loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The g++ compiler with the option `--std=c++2a` is used to compile the examples
    throughout the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source files used in this chapter at [https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP).
  prefs: []
  type: TYPE_NORMAL
- en: Program execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](2297d785-7242-4149-8b31-f9af1fcdd833.xhtml), *Building C++ Applications*,
    we learned that the compiler generates an executable file after compiling the
    source code. The executable file contains machine code that can be copied to the
    memory of the computer to be run by the **Central Processing Unit** (**CPU**).
    The copying is done by an internal tool of the OS called a loader. So the **operating
    system** (**OS**) copies the contents of the program to the memory and starts
    executing the program by passing its first instruction to the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: main()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Program execution starts with the `main()` function, the *designated start
    of the program* as stated in the standard. A simple program outputting the `Hello,
    World!` message will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You may have encountered or used in your programs the arguments of the `main()`
    function. It has two arguments, `argc` and `argv,` allowing strings to be passed
    from the environment, usually referred to as the **command-line arguments**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The names `argc` and `argv` are conventional and can be replaced with anything
    you want. The `argc` argument holds the number of command-line arguments passed
    to the `main()` function; the `argv` argument holds the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, we can compile and run the preceding example with the following
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When you look at the number of arguments, you'll notice that it is `5`. The
    first argument is always the name of the program; that's why we skipped it in
    the example by starting the loop from number `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Rarely, you can see a widely supported but not standardized third argument,
    most commonly named `envp`. The type of `envp` is an array of `char` pointers
    and it holds the environment variables of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program can contain lots of functions, but the execution of the program
    always starts with the `main()` function, at least from the programmer''s perspective.
    Let''s try to compile the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'g++ raises an error on the `foo();` call `C++ requires a type specifier for
    all declarations`. The call was parsed as a declaration rather than an instruction
    to execute. The way we tried to call a function before `main()` might seem silly
    for seasoned developers, so let''s try another way. What if we declare something
    that calls a function during its initialization? In the following example, we
    define a `BeforeMain` struct with a constructor printing a message, and then we
    declare an object of type `BeforeMain` in the global scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The example successfully compiles and the program outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we add a member function to `BeforeMain` and try to call it? See the
    following code to understand this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to `test()` won''t be successful. So we cannot call a function before
    `main()`, but we can declare variables- objects that would be initialized by default.
    So there is definitely something that does an *initialization* before `main()`
    is actually called. It turns out that the `main()` function is not the true starting
    point of a program. The actual starting function of the program prepares the environment,
    that is, collects the arguments passed to the program, and then calls the `main()`
    function. This is required because C++ supports global and static objects that
    need to be initialized before the program begins, which means before the `main()`
    function is called. In the Linux world, this function is referred to as `__libc_start_main`.
    The compiler augments the generated code with the call of `__libc_start_main`,
    which in turn may or may not call other initialization functions before the `main()`
    function gets called. Going abstract, just imagine that the preceding code will
    be altered to something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We will examine the entry point in more detail in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Special properties of main()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We concluded that `main()` is not actually the entry point of the program,
    though the standard states that it is the designated start. The compiler pays
    special attention to `main()`. It behaves like a regular C++ function, but besides
    being the first function to be called, it has other special properties. First
    of all, it is the only function that could omit the `return` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The returned value indicates the success of the execution. By returning `0`,
    we aim to tell the control that `main()` ended successfully, so if the control
    reaches the end without encountering a corresponding `return` statement, it will
    consider the call successful and the effect is the same as `return 0;`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting property of the `main()` function is that its return type
    cannot be deduced automatically. It is not allowed to use the `auto` placeholder
    type specifier, which indicates that the return type will be deduced from function''s
    `return` statement. Here''s how it works for regular functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'By placing the `auto` specifier, we tell the compiler to automatically deduce
    the `return` type. With C++11, we also placed the type name after the arrow (`->`)
    although the second syntax is shorter. Consider the `get_ratio()` function, which
    returns the standard ratio as an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To successfully compile C++ code containing new features specified in C++11,
    C++14, C++17, or C++20, you should use proper compiler flags. When compiling with
    g++, use the `--std` flag and specify the standard version. The recommended value
    is **`--std=c++2a`**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example compiles successfully, but look at what happens when we try the
    same trick with the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will produce the following errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cannot initialize return object of type ''auto'' with an rvalue of type ''int''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''main'' must return ''int''`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Something strange is going on with the `main()` function. This is because the
    `main()` function allows omitting the `return` statement, but for the compiler,
    the `return` statement must exist to support automatic `return` type deduction.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s important to remember that if there are multiple `return` statements,
    they must all deduce to the same type. Let''s suppose we need an updated version
    of the function, which returns an integer value (as shown in the previous example),
    and if specified, returns a more precise `float` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code won't compile successfully because there are two `return`
    statements with different deduced types.
  prefs: []
  type: TYPE_NORMAL
- en: constexpr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `constexpr` specifier declares that the value of the function is possible
    to evaluate at compile time. The same definition applies to variables as well.
    The name itself consists of `const` and `expression`. This is a useful feature
    because it allows optimizing your code to the fullest. Let''s take a look at the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how the compiler modifies the `main()` function in the preceding
    example. Supposing the compiler won''t optimize the `double_it()` function on
    its own (for example, making it an *inline* function), the `main()` function will
    take the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`constexpr` is not a guarantee that the function value will be computed at
    compile time; however, the compiler is able to do so if the input of the `constexpr`
    function is known at compile time. That''s why the preceding example transformed
    directly to a computed value of `126` for the  `tripled` variable and had no effect on
    the `another_tripled`  variable as the input is not known to the compiler (and
    nor us).'
  prefs: []
  type: TYPE_NORMAL
- en: '**C++20** introduces the `consteval` specifier, allowing you to insist on the
    compile-time evaluation of the function result. In other words, a `consteval`
    function produces a constant expression at compile time. The specifier makes the
    function an *immediate* one, which will produce an error if the function call
    cannot lead to a constant expression. The `main()` function cannot be declared
    as `constexpr`.'
  prefs: []
  type: TYPE_NORMAL
- en: C++20 also introduces the `constinit` specifier. We use `constinit` to declare
    a variable with static or thread storage duration. We will discuss thread storage
    duration in [Chapter 8](fc8fb840-e179-4725-9e44-403b63be460d.xhtml), *Concurrency
    and Multithreading*. The most notable difference with `constinit` is that we can
    use it with objects that have no `constexpr` destructor. This is because `constexpr`
    requires the object to have static initialization and constant destruction. Furthermore,
    `constexpr` makes the object const-qualified while `constinit` does not. However,
    `constinit` requires the object to have static initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another special property of `main()` is that it cannot be called recursively.
    From the perspective of the OS, the `main()` function is the entry point of the
    program, so calling it again would mean starting everything over; therefore, it
    is prohibited. However, calling a function recursive just because it calls itself
    is partially correct. For example, the `print_number()` function calls itself
    and never stops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the `print_number(1)` function will output numbers `1`, `2`, `3`, and
    so on. This is more like a function that calls itself infinitely rather than a
    correct recursive function. We should add a couple more properties to make the `print_number()`
    function a useful recursive one. First of all, the recursive function must have
    a base case, a scenario when further function calls stop, which means the recursion
    stops propagating. We can make such a scenario for the `print_number()` function
    if, for example, we want to print numbers up to 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one more property for a function to be recursive: solving smaller
    problems that will eventually lead to the base case. In the preceding example,
    we already had it by solving a smaller problem for the function, that is, by printing
    one number. After printing one number, we move to the next small problem: printing
    the next number. Finally, we get to the base case and we are done. There isn''t
    any magic in a function calling itself; think of it as a function calling a different
    function with the same implementation. What''s really interesting is how a recursive
    function affects the program execution overall. Let''s take a look at a simple
    example of calling a function from an other function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When a function is called, memory space is allocated for its arguments and
    local variables. The program starts with the `main()` function, which in this
    example simply calls the `calculate()` function by passing literal values `11`
    and `22`. The control *jumps* to the `calculate()` function and the `main()` function
    is kind of *on hold*; it waits until the `calculate()` function returns to continue
    its execution. The `calculate()` function has two arguments, `a` and `b`; although
    we named parameters of the `sum()`, `max()`, and `calculate()` differently, we
    could use the same names in all the functions. Memory space is allocated for these
    two arguments. Let''s suppose that an int takes 4 bytes of memory, therefore a
    minimum of 8 bytes are required for the `calculate()` function to be executed
    successfully. After allocating 8 bytes, the values `11` and `22` should be copied
    to the corresponding locations (see the following diagram for details):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/094082a9-5d6c-4a64-8dcf-6480fc9f38e9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `calculate()` function calls the functions `sum()` and `max()` and passes
    its argument values to them. Correspondingly, it waits for both functions to be
    executed sequentially in order to form the value to return to the `main()`. The
    `sum()` and `max()` functions are not called simultaneously. First, `sum()` is
    called, which leads to a copy of the values of variables `a` and `b` to the locations
    allocated for the arguments of `sum()`, named `n` and `m`, which again take eight
    bytes in total. Take a look at the following diagram to understand this better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04c7e009-48fb-448d-b6aa-1909c9f31f6d.png)'
  prefs: []
  type: TYPE_IMG
- en: Their sum is calculated and returned. After the function is done and it returns
    a value, the memory space is  freed. This means that variables `n` and `m` are
    not accessible anymore and their locations can be reused.
  prefs: []
  type: TYPE_NORMAL
- en: We don't consider temporary variables at this point. We will revisit this example
    later to show the hidden details of function execution, including temporary variables
    and how to avoid them as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'After `sum()` has returned a value, the `max()` function is called. It follows
    the same logic: memory is allocated to the arguments `x` and `y`, and to the `res` variable.
    We intentionally store the result of the ternary operator `(?:)` in the `res`
    variable to make the `max()` function allocate more space for this example. So,
    12 bytes are allocated to the `max()` function in total. At this point, the x `main()` function is
    still on hold and waits for `calculate()`, which in turn, is on hold and waits
    for the `max()`  function to complete (see the following diagram for details):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a6cd36b-9a99-4e1f-9f25-38221c7045e6.png)'
  prefs: []
  type: TYPE_IMG
- en: When `max()` is done, the memory allocated to it is freed and its return value
    is used by  `calculate()` to form a value to return. Similarly, when  `calculate()`
    returns, the memory is freed and the `main()` function's local variable result
    will contain the value returned by `calculate()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `main()` function then finishes its work and the program exits, that is,
    the OS frees the memory allocated for the program and can reuse it later for other
    programs. The described process of allocating and freeing memory (deallocating
    it) for functions is done using a concept called a stack.
  prefs: []
  type: TYPE_NORMAL
- en: A stack is a data structure *adapter*, which has its rules to insert and access
    the data inside of it. In the context of function calls, the stack usually means
    a memory segment provided to the program that automatically manages itself following
    the rules of the stack data structure adapter. We will discuss this in more detail
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to recursion, when the function calls itself, memory should be allocated
    to the newly called function''s arguments and local variables (if any). The function
    calls itself again, which means the stack will continue to grow (to provide space
    for the new functions). It doesn''t matter that we call the same function; from
    the stack perspective, each new call is a call to a completely different function,
    so it allocates space for it with a serious look on its face while whistling its
    favorite song. Take the look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf484616-ddb5-4701-b9f2-f35a455c23b0.png)'
  prefs: []
  type: TYPE_IMG
- en: The first call of the recursive function is on hold and waits for the second
    call of the same function, which in turn is on hold and waits for the third call
    to finish and return a value, which is in turn on hold, and so on. If there is
    a bug in the function or the recursion base is difficult to reach, the stack will
    sooner or later overgrow, which will lead to a program crash with the reason known
    as **stack overflow**.
  prefs: []
  type: TYPE_NORMAL
- en: Though recursion provides more elegant solutions to a problem, try to avoid
    recursion in your programs and use the iterative approach (loops). In mission-critical
    system development guidelines such as the navigation system of a Mars rover, using
    recursion is completely prohibited.
  prefs: []
  type: TYPE_NORMAL
- en: In [chapter 1](2297d785-7242-4149-8b31-f9af1fcdd833.xhtml), *Building C++ Applications*,
    we mentioned coroutines. Although we will discuss them in detail later in the
    book, you should note that the main function cannot be a coroutine.
  prefs: []
  type: TYPE_NORMAL
- en: Working with data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we refer to computer memory, we consider the **Random Access Memory** (**RAM**)
    by default, and also the RAM is a general term for either SRAM or DRAM; we will
    mean DRAM by default unless otherwise stated. To clear things out, let''s take
    a look at the following diagram, which illustrates the memory hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/547620d9-ff05-460c-b5ea-b029ffc5fb94.png)'
  prefs: []
  type: TYPE_IMG
- en: When we compile a program, the compiler stores the final executable file in
    the hard drive. To run the executable file, its instructions are loaded into the
    RAM and are then executed by the CPU one by one. This leads us to the conclusion
    that any instruction required to be executed should be in the RAM. This is partially
    true. The environment that is responsible for running and monitoring programs
    plays the main role.
  prefs: []
  type: TYPE_NORMAL
- en: Programs we write are executed in the hosted environment, which is in the OS.
    The OS loads the contents of the program (its instructions and data, that is,
    the process) not directly into the RAM, but the**virtual memory**, a mechanism
    that makes it possible both to handle processes conveniently and to share resources
    between processes. Whenever we refer to the memory that a process is loaded to,
    we mean the virtual memory, which in turn *maps* its contents to the RAM.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, we use the terms RAM, DRAM, virtual memory, and memory interchangeably,
    considering virtual memory as an abstraction around the physical memory (the DRAM).
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin with an introduction to the memory structure and then investigate
    data types within the memory.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The memory consists of lots of boxes, each of which is able to store a specified
    amount of data. We will refer to these boxes as *memory cells*, considering that
    each cell can store 1 byte representing 8 bits. Each memory cell is unique even
    if they store the same value. The uniqueness is achieved by addressing the cells
    so that each cell has its unique address in the memory. The first cell has the
    address **0**, the second cell **1**, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates an excerpt of the memory, each cell with
    its unique address and ability to store 1 byte of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17fe7523-4981-49a8-902e-a920b256354e.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram can be used to abstractly represent both physical and
    virtual memories. The point of having an additional layer of abstraction is the
    ease of managing processes and providing more functionality than with physical
    memory. For example, OSes can execute programs greater than physical memory. Take
    a computer game as an example of a program taking almost 2 GB of space and a computer
    with a physical memory of 512 MB. Virtual memory allows the OS to load the program
    portion by portion by unloading old parts from the physical memory and mapping
    new parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Virtual memory also better supports having more than one program in memory,
    thus supporting parallel (or pseudo-parallel) execution of multiple programs.
    This also provides efficient use of shared code and data, such as dynamic libraries.
    Whenever two different programs require the same library to work with, the single
    instance of the library could exist in memory and be used by both programs without
    them knowing about each other. Take a look at the following diagram, which depicts
    three programs loaded into memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f09b9ec9-be4f-4cf1-a8ab-8ad6a6af1ae5.png)'
  prefs: []
  type: TYPE_IMG
- en: There are three running programs in the preceding diagram; each of the programs
    takes up some space in virtual memory. **My Program** is fully contained in the
    physical memory while the **Calculator** and **Text Editor** are partially mapped
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Addressing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, each memory cell has its unique **address**, which is
    the guarantee of the uniqueness of each cell. An address is usually represented
    in a *hexadecimal* form because it's shorter and it's faster to convert to **binary**
    rather than decimal numbers. A program that is loaded into virtual memory operates
    and sees *logical* addresses. These addresses, also called virtual addresses,
    are *fake* and provided by the OS, which *translates* them to physical addresses
    when needed. To optimize the translation, the CPU provides **Translation Lookaside
    Buffer**, a part of its **Memory Management Unit** (**MMU**). Translation Lookaside
    Buffer caches recent translations of virtual addresses to physical addresses.
    So the efficient address translation is a software/hardware task. We will dive
    into the address structure and translation details in [Chapter 5](2b708ddc-255e-490e-bd4c-e783ccae5f9e.xhtml),
    *Memory Management and Smart Pointers*.
  prefs: []
  type: TYPE_NORMAL
- en: The length of the address defines the size of total the memory that can be operated
    by the system. When you encounter statements such as a 32 bits system or a 64
    bits system, it actually means the length of the address, that is, the address
    is 32 bits or 64 bits long. The longer the address, the bigger the memory. To
    make things clear, let's compare an 8 bits long address with a 32 bits long one.
    As agreed earlier, each memory cell is able to store 1 byte of data and has a
    unique address. If the address length is 8 bits, the address of the first memory
    cell is all zeros— **0000 0000**. The address of the next cell is greater by one,
    that is, it's **0000 0001**, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The biggest value that can be represented by 8 bits is **1111 1111**. So, how
    many memory cells can be represented with an address length of 8 bits? This question
    is worth answering in more detail. How many different values can be represented
    by 1 bit? Two! Why so? Because 1 bit can represent either **1** or **0**. How
    many different values can be represented by 2 bits? Well, **00** is one value,
    **01** is another value, **10**, and finally, **11**. So, four different values
    in total can be represented by 2 bits. Let''s make a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c23f0a1a-555a-4752-95ea-7a5494a651aa.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see a pattern here. Each position (each bit) in a number can have two
    values, so we can calculate the number of different values represented by *N*
    bits by finding *2^N*; therefore, the number of different values represented by
    8 bits is *2⁸ = 256*. This means that an 8 bits system can address up to 256 memory
    cells. On the other hand, a 32-bit system is able to address *2^(32) = 4 294 967
    296* memory cells, each storing 1 byte of data, that is, storing *4294967296 * 1
    byte = 4 GB *of data.
  prefs: []
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What''s the point of having data types at all? Why can''t we program in C++
    using some `var` keyword to declare variables and forget about variables such
    as `short`, `long`, `int`, `char`, `wchar`, and so on? Well, C++ does support
    a similar construct, the `auto` keyword that we have already used previously in
    this chapter, a so-called *placeholder type specifier*. It''s named a placeholder
    because it is, indeed, a placeholder. We cannot (and we must not ever be able
    to) declare a variable and then change its type during runtime. The following
    code might be valid JavaScript code, but it is definitely not valid C++ code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Imagine the C++ compiler could compile this code. How many bytes of memory should
    be allocated for the  `a` variable? When declaring `var a = 12;`, the compiler
    could deduce its type to `int` and specify 4 bytes of memory space, but when the
    variable changes its value to `Hello, World!`, the compiler has to reallocate
    the space, or invent a new hidden variable named `a1` of type `std::string` .
    Then the compiler tries to find every access to the variable in the code that
    accesses it as a string and not as an integer or a double and replace the variable
    with the hidden `a1`. The compiler might just quit and start to ask itself the
    meaning of life.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can declare something similar to the preceding code in C++ as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The difference between the previous two examples is that the second example
    declares three different variables of three different types. The previous non-C++
    code declared just one variable and then assigned values of different types to
    it. You can't change the type of a variable in C++, but the compiler allows you
    to use the `auto` placeholder and deduces the type of the variable by the value
    assigned to it.
  prefs: []
  type: TYPE_NORMAL
- en: It is crucial to understand that the type is deduced at compile time, while
    languages such as JavaScript allow you to deduce the type at runtime. The latter
    is possible because such programs are run in environments such as virtual machines,
    while the only environment that runs the C++ program is the OS. The C++ compiler
    must generate a valid executable file that could be copied into the memory and
    run without a support system. This forces the compiler to know beforehand the
    actual size of the variable. Knowing the size is important to generate the final
    machine code because accessing a variable requires its address and size, allocating
    memory space to a variable requires the number of bytes that it should take.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C++ type system classifies types into two major categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fundamental types** (`int`, `double`, `char`, `void`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compound types** (pointers, arrays, classes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The language even supports special type traits, `std::is_fundamental` and `std::is_compound`,
    to find out the category of a type, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We used `std::is_fundamental_v` and `std::is_compound_v` helper variable templates,
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The program outputs: `0 1 1 0`.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `std::boolalpha` I/O manipulator before printing the type categories
    to print `true` or `false` instead of `1` or `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the fundamental types are arithmetic types such as `int` or `double`;
    even the `char` type is arithmetic. It actually holds a number rather than a character,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: A `char` variable holds 1 byte of data, which means it can represent 256 different
    values (because 1 byte is 8 bits, and 8 bits can be used in *2⁸* ways to represent
    a number). What if we use one of the bits as a *sign* bit, for example, allowing
    the type to support negative values as well? That leaves us with 7 bits for representing
    the actual value, and following the same logic, it allows us to represent 27 different
    values, that is, 128 (including 0) different values of positive numbers and the
    same amount of negative values. Excluding 0 gives us the range -127 to +127 for
    the signed `char`. This signed versus unsigned representation applies to almost
    all integral types.
  prefs: []
  type: TYPE_NORMAL
- en: So whenever you encounter that, for example, the size of an int is 4 bytes,
    which is 32 bits, you should already know that it is possible to represent the
    numbers 0 to 2^(32) in an unsigned representation, and the values -2^(31) to +2^(31)
    in a signed representation.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ is a unique language in the way that it provides access to low-level details
    such as addresses of variables. We can take the address of any variable declared
    in the program using the `&` operator as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will output something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice the hexadecimal representation of the address. Although this value is
    just an integer, it is used to store in a special variable called a pointer. A
    pointer is just a variable that is able to store address values and supports the
    `*` operator (dereferencing), allowing us to find the actual value stored at the
    address.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to store the address of the variable answer in the preceding example,
    we can declare a pointer and assign the address to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable answer is declared as an `int`, which usually takes 4 bytes of
    memory space. We already agreed that each byte has its own unique address. Can
    we conclude that the answer variable has four unique addresses? Well, yes and
    no. It does acquire four distinct but contiguous memory bytes, but when the address
    operator is used against the variable, it returns the address of its first byte.
    Let''s take a look at a portion of code that declares a couple of variables and
    then illustrate how they are placed in the memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The size of a data type is implementation-defined, though the C++ standard
    states the minimum supported range of values for each type. Let''s suppose the
    implementation provides 4 bytes for an `int`, 8 bytes for a double, and 1 byte
    for `char`. The memory layout for the preceding code should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7b01d3f-b5b7-43ec-be24-1612dd507b39.png)'
  prefs: []
  type: TYPE_IMG
- en: Pay attention to  `ivar` in the memory layout; it resides in four contiguous
    bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever we take the address of a variable, whether it resides in a single
    byte or more than one byte, we get the address of the first byte of the variable.
    If the size doesn''t affect the logic behind the address operator, then why do
    we have to declare the type of the pointer? In order to store the address of `ivar`
    in the preceding example, we should declare the pointer as an `int*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/957b67f2-4da3-4fa0-8a68-cd0cdd02ec7d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Turns out, the type of the pointer is crucial in accessing the variable using
    that very pointer. C++ provides the dereferencing operator (the `*` symbol before
    the pointer name):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'It basically works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Reads the contents of the pointer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finds the address of the memory cell that is equal to the address in the pointer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Returns the value that is stored in that memory cell
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The question is, what if the pointer points to the data that resides in more
    than one memory cell? That's where the type of the pointer comes in. When dereferencing
    the pointer, its type is used to determine how many bytes it should read and return
    starting from the memory cell that it points to.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know that a pointer stores the address of the first byte of the
    variable, we can actually read any byte of the variable by moving the pointer
    forward. We should remember that the address is just a number, so adding or subtracting
    another number from it will produce another address. What if we point to an integer
    variable with a `char` pointer?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When we try to dereference the `p` pointer, it will return only the first byte
    of `ivar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we want to move to the next byte of `ivar`, we add `1` to the `char`
    pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following diagram; it clearly shows how we access bytes
    of the `ivar` integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b595b562-70fe-45cf-990d-c1b6b939ff9d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to read the first or the last two bytes, you can use a short pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You should be careful with pointer arithmetics, as adding or subtracting a number
    will actually move the pointer by the defined size of the data type. Adding 1
    to an `int` pointer will add `sizeof(int) * 1` to the actual address.
  prefs: []
  type: TYPE_NORMAL
- en: What about the size of a pointer? As mentioned previously, a pointer is just
    a variable that is special in the way that it can store a memory address and provide
    a dereferencing operator that returns the data located at that address. So if
    the pointer is just a variable, it should reside in memory as well. We might consider
    that the size of a `char` pointer is less than the size of an `int` pointer just
    because the size of a `char` is less than the size of an `int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the catch: the data that is stored in the pointer has nothing to do
    with the type of data the pointer points to. Both `char` and `int` pointers store
    the address of the variable, so to define the size of the pointer, we should consider
    the size of the address. The size of the address is defined by the system we work
    in. For example, in a 32-bit system, the address size is 32 bits long, and in
    a 64-bit system, the address size is 64 bits long. This leads us to a logical
    conclusion: the size of the pointer is the same regardless of the type of data
    it points to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It will output `4 = 4 = 4` in a 32-bit system, and `8 = 8 = 8` in a 64-bit system.
  prefs: []
  type: TYPE_NORMAL
- en: Memory segments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The memory consists of segments and the program segments are distributed through
    these memory segments during the loading. These are artificially divided ranges
    of memory addresses that make it easier to manage the program by the OS. A binary
    file is also divided into segments, such as code and data. We previously mentioned
    code and data as sections. Sections are the division of a binary file needed for
    the linker, which uses the sections that are meant for the proper work of the
    linker and combines the sections that are meant for the loader into segments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, when we discuss a binary file from the runtime perspective, we mean
    segments. The data segment contains all the data required and used by the program,
    and the code segment contains the actual instructions that process the very same
    data. However, when we mention data, we don''t mean every single piece of data
    used in the program. Let''s take a look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The code segment of the preceding program consists of the instructions of the
    `main()` and `max()` functions, where `main()` prints the message using the `operator<<`
    of the `cout` object and then calls the `max()` function. What data actually resides
    in the data segment? Does it contain `a` and `b` arguments of the `max()` function? As
    it turns out, the only data that is contained in the data segment is the string
    `The maximum of 11 and 22 is:`, along with other static, global, or constant data.
    We didn't declare any global or static variables, so the only data is the mentioned
    message.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting thing comes with values the `11` and `22`. These are literal
    values, which means they have no address; therefore they are not located anywhere
    in the memory. If they are not located anywhere, the only logical explanation
    of how they are located within the program is that they reside in the code segment.
    They are a part of the `max()` call instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about the `a` and `b` arguments of the `max()` function? And here comes
    the segment in the virtual memory that is responsible for storing variables that
    have automatic storage duration— the stack. As already mentioned previously, the
    stack automatically handles the allocation/deallocation of memory space for local
    variables and function arguments. The arguments `a` and `b` will be located in
    the stack when the `max()` function is called. In general, if an object is said
    to have automatic storage duration, the memory space will be allocated at the
    beginning of the enclosing block. So when the function is called, its arguments
    are pushed into the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: When the function is done, the automatically allocated space will be freed at
    the end of the enclosing code block.
  prefs: []
  type: TYPE_NORMAL
- en: The enclosing code block represents not only the function body but also the
    block of the conditional statements and loops.
  prefs: []
  type: TYPE_NORMAL
- en: It's said that the arguments (or local variables) are popped out of the stack. **Push**
    and **pop** are terms used within the context of the stack. You insert data into
    the stack by *pushing* it, and you retrieve (and remove) data out of the stack
    by *popping* it. You might have encountered the **LIFO** term, which stands for
    **last in, first out**. That perfectly describes the push and pop operations of
    the stack.
  prefs: []
  type: TYPE_NORMAL
- en: When the program is run, the OS provides the fixed size of the stack. The stack
    is able to grow in size and if it grows to the extent that no more space is left,
    it crashes because of the stack overflow.
  prefs: []
  type: TYPE_NORMAL
- en: The heap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We described the stack as a manager of variables with *automatic storage duration*.
    The word *automatic* suggests that programmers shouldn''t care about the actual
    memory allocation and deallocation. Automatic storage duration could be achieved
    only if the size of data or a collection of the data is known beforehand. This
    way, the compiler is aware of the number and type of function arguments and local
    variables. At this point, it seems more than fine, but programs tend to work with
    dynamic data— data of an unknown size. We will study dynamic memory management
    in detail in [Chapter 5](2b708ddc-255e-490e-bd4c-e783ccae5f9e.xhtml), *Memory
    Management and Smart Pointers; *for now, let''s look at a simplified diagram of
    memory segments and find out what the heap is used for:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18f5425d-2362-474c-8e4c-3fd91432d3ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The program uses the heap segment in order to request more memory space than
    has been required before. This is done at runtime, which means the memory is being
    allocated dynamically during the program execution. The program requests the OS
    for new memory space whenever required. The OS doesn''t actually know whether
    the memory is required for an integer, or for a user-defined `Point`, or even
    for an array of user-defined `Point`. The program requests the memory by passing
    the actual size of bytes that it requires. For example, to request a space for
    an object of type `Point`, the `malloc()` function can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `malloc()` function came from the C language and to use it we need to include
    the `<cstdlib>` header file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `malloc()` function allocates a contiguous memory space of `sizeof(Point)`
    bytes— let''s say 8 bytes. It then returns the address of the first byte of that
    memory as it is the only way to provide access to space. And the thing is, `malloc()`
    doesn''t actually know whether we requested memory space for a `Point` object
    or an `int`, and it simply returns  `void*`. `void*` stores the address of the
    first byte of allocated memory, but it definitely cannot be used to fetch the
    actual data by dereferencing the pointer simply because `void` does not define
    the size of the data. Take a look at the following diagram; it shows that `malloc`
    allocates memory on the heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/762fa3db-fc1e-4137-b71c-ee80cffd43f5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To actually use the memory space, we need to cast the `void` pointer to the
    desired type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, simply declare and initialize the pointer with a cast result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'C++ solves this headache by introducing the `new` operator, which automatically
    fetches the size of the memory space to be allocated and converts the result to
    the desired type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Dynamic memory management is a manual process; there is no similar construct
    to the stack that automatically deallocates the memory space if it is not required
    anymore. To manage the memory resource correctly, we should use the `delete` operator
    when we want to deallocate the space. We will find out the details in [Chapter
    5](2b708ddc-255e-490e-bd4c-e783ccae5f9e.xhtml) *Memory Management and Smart Pointers*.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens when we access the members of the `Point` object pointed to by
    `p`? Dereferencing `p` returns the full `Point` object, so to change the value
    of member `x`, we should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, better still, access it with the arrow operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We will dive into the user-defined types and structs in particular in [Chapter
    3](c0982ed5-7e38-4bd3-9c4d-37b0d2f01691.xhtml), *Details of Object-Oriented Programming.*
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An array is the basic data structure that provides a collection of data contiguously
    stored in memory. Many adapters, such as the stack, are implemented using arrays.
    Their uniqueness is that array elements are all of the same type, which plays
    a key role in accessing array elements. For example, the following declaration
    creates an array of 10 integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The name of the array decays to a pointer to its first element. Considering
    the fact that array elements have the same type, we can access any element of
    the array by advancing the pointer to its first element. For example, the following
    code prints the third element of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The same goes with the first element; the following three lines of code are
    doing the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To make sure that `arr[2]` and `*(arr + 2)` do the exact same thing, we can
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving the `2` behind the `+` won''t affect the result, so the following code
    is valid as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: And it prints the third element of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'An array element is accessed in constant time, which means accessing the first
    and the last elements of the array takes the same amount of time. It''s because
    every time we access an array element, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Advance the pointer by adding the corresponding numeric value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the contents of memory cells placed at the result pointer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The type of the array indicates how many memory cells should be read (or written).
    The following diagram illustrates the access:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbb9a70d-2cfc-471f-ae05-4d6e28d2ffca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This idea is crucial when creating dynamic arrays, which are arrays that are
    located in the heap rather than the stack. As we already know, allocating memory
    from the heap gives the address of its first byte, so the only chance to access
    elements other than the first one, is by using pointer arithmetic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We will discuss more about the structure of arrays and other data structures
    in [Chapter 6](92a352fd-cfe4-4d57-8005-ef618534ff74.xhtml), *Digging into Data
    Structures and Algorithms in STL.*
  prefs: []
  type: TYPE_NORMAL
- en: Control flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic concepts of almost any programming language are conditional statements
    and loops. We are going to explore them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s hard to imagine a program that doesn''t contain a conditional statement.
    It''s almost a habit to check the input arguments of functions securing their
    safe execution. For example, the `divide()`  function takes two arguments, divides
    one by the other, and returns the result. It''s pretty clear that we need to make
    sure that the divisor is not zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Conditionals are at the core of programming languages; after all, a program
    is a collection of actions and decisions. For example, the following code uses
    conditional statements to find the maximum value out of two input arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example is oversimplified on purpose to express the usage of
    the `if`-`else` statement as is. However, what interests us the most is the implementation
    of such a conditional statement. What does the compiler generate when it encounters
    an `if` statement? The CPU executes instructions sequentially one by one, and
    instructions are simple commands doing exactly one thing. We can use complex expressions
    in a single line in a high-level programming language such as C++, while the assembly
    instructions are simple commands that can do only one simple operation in one
    cycle: `move`, `add`, `subtract`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: The CPU fetches the instruction from the code memory segment, decodes it to
    find out what it should exactly do (move data, add numbers, subtract them), and
    executes the command.
  prefs: []
  type: TYPE_NORMAL
- en: To run at its fastest, the CPU stores the operands and the result of the execution
    in storage units called **registers**. You can think of registers as temporary
    variables of the CPU. Registers are physical memory units that are located within
    the CPU so the access is much faster compared to the RAM. To access the registers
    from an assembly language program, we use their specified names, such as `rax`,
    `rbx`, `rdx`, and so on. The CPU commands operate on registers rather than the
    RAM cells; that's why the CPU has to copy the contents of the variable from the
    memory to registers, execute operations and store the results in a register, and
    then copy the value of the register back to the memory cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following C++ expression takes just a single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'It would look similar to the following assembly representation (comments are
    added after semicolons):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'A conditional statement suggests that a portion of the code should be skipped.
    For example, calling `max(11, 22)` means the `if` block will be omitted. To express
    this in the assembly language, the idea of jumps is used. We compare two values
    and, based on the result, we jump to a specified portion of the code. We label
    the portion to make it possible to find the set of instructions. For example,
    to skip adding `42` to the register `rbx`, we can *jump* to the portion labeled
    `UNANSWERED` using the unconditional jump instruction `jpm` as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `jmp` instruction performs an unconditional jump; that means it starts
    the execution of the first instruction at a specified label without any condition
    check. The good news is that the CPU provides conditional jumps as well. The body
    of the `max()` function will translate into the following assembly code (simplified),
    where the `jg` and `jle` commands are interpreted as *jump if greater than* and
    *jump if less than or equal*, respectively (based on the results of the comparison
    using the `cmp` instruction):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the labels `GREATER` and `LESSOREQUAL` represent the
    `if` and `else` clauses of the `max()` function implemented earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The switch statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Conditionals such as the `switch` statement use the same logic as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s suppose `rax` represents the age, `rbx` represents `can_drink`, and
    `rdx` represents  `can_code`. The preceding example will translate into the following
    assembly instructions (simplified to express the basic idea):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Each `break` statement translates into jumping to the `BEYOND_SWITCH` label,
    so if we forget the `break` keyword, for example, in the case where `age` is `18`, the
    execution will reach through  `CASE_21` as well. That's why you should not forget
    the `break` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Let's find a way to avoid using conditionals in the source, both to make the
    code shorter and possibly faster. We will use function pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing conditionals with function pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we looked at memory segments, and one of the most important segments
    is the code segment (also called a text segment). This segment contains the program
    image, which is the instructions of the program that should be executed. Instructions
    are usually grouped into functions, which provide a unique name allowing us to
    call them from other functions. Functions reside in the code segment of the executable
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function has its address. We can declare a pointer that takes the address
    of the function and then use it later to call that function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The function pointer can be called the same way as the original function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Let's suppose we are writing a program that takes two numbers and a character
    from the input and executes an arithmetic operation on the numbers. The operation
    is specified by the character, whether it's `+`, `-`, `*`, or `/`. We implement
    four functions, `add()`, `subtract()`, `multiply()`, and `divide()`, and call
    one of them based on the value of the character input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of checking the value of the character in a bunch of `if` statements
    or a `switch` statement, we will map the type of the operation to the specified
    function using a hash table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `std::unordered_map` maps `char` to a function pointer defined
    as `(*)(int, int)`. That is, it can point to any function that takes two integers
    and returns an integer.
  prefs: []
  type: TYPE_NORMAL
- en: The hash table is represented by `std::unordered_map`, defined in the `<unordered_map>`
    header. We will discuss it in detail in  [Chapter 6](92a352fd-cfe4-4d57-8005-ef618534ff74.xhtml), *Digging
    into Data Structures and Algorithms in STL*
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we don''t need to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we simply call the function mapped by the character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Though the use of a hash table is much prettier and looks more professional,
    you should take care of unexpected cases, such as invalid user input.
  prefs: []
  type: TYPE_NORMAL
- en: Functions as types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second argument for `unordered_map` is `int (*)(int, int)`, which literally
    means a pointer to a function taking two integers and returning an integer. C++
    supports the class template `std::function` as a general-purpose function wrapper
    allowing us to store callable objects including ordinary functions, lambda expressions,
    functions objects, and so on. The stored object is referred to as the target of
    `std::function` and if it doesn't have a target, it will throw the `std::bad_function_call`
    exception if invoked. This helps us both to make the `operations` hash table accept
    any callable object as its second parameter and to handle exceptional cases such
    as invalid character input, mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Notice the argument for `std::function`; it has the form `int(int, int)` rather
    than `int(*)(int, int)`. Using `std::function` helps us to handle exceptional
    situations. For example, calling `operations['x'](num1, num2);` will lead to,
    creation of the empty `std::function` mapped to the character `x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'And calling it will throw an exception, so we can ensure the safety of the
    code by properly handling the call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use *lambda expressions—* unnamed functions constructed in
    place and able to capture variables in scope. For example, instead of declaring
    the preceding functions and then inserting them into the hash table, we can create
    a lambda expression right before inserting it into the hash table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Lambda expressions will be covered throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Loops may be perceived as repeatable `if` statements, which again should be
    translated into CPU comparison and jump instructions. For example, we can calculate
    the sum of numbers from 0 to 10 using the `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This will translate to the following assembly code (simplified):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'C++17 introduced init statements that can be used in conditionals and loops.
    The `num` variable declared outside of the `while` loop may now be moved into
    the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The same rule applies to the `if` statement, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'C++11 introduced the range-based `for` loop, which makes the syntax much clearer.
    For example, let''s call all the arithmetic operations we defined earlier using
    the new `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterating  `unordered_map` returns a pair with the first and second members,
    the first being the key, and the second being the value mapped to that key. C++17
    moved us even further, allowing us to write the same loop as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Knowing what the compiler actually generates is key in designing and implementing
    efficient software. We touched on the low-level details of conditionals and loops,
    which are at the base of almost every program.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the details of program execution. We discussed
    functions and the `main()` function with some of its special properties. We found
    out how the recursion works and that the `main()` function cannot be called recursively.
  prefs: []
  type: TYPE_NORMAL
- en: As C++ is one of the few high-level languages that supports low-level programming
    concepts such as accessing memory bytes by their address, we studied how data
    resides in the memory and how can we incorporate pointers in accessing that data.
    Understanding these details is a must for a professional C++ programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we touched on the topic of conditionals and loops from the perspective
    of an assembly language. Throughout the chapter, we introduced C++20 features.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn more about **object-oriented programming**
    (**OOP**), including the inner details of the language object model. We will dive
    into the details of virtual functions and see how to use polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How many parameters does the `main()` function have?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `constexpr` specifier used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it advised to use iteration over recursion?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between the stack and the heap?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the size of the `ptr` if it is declared as `int*`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is access to an array element considered a constant time operation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What will happen if we forget the `break` keyword in any case of the `switch`
    statement?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you implement the `multiply()` and `divide()` functions from the arithmetic
    operations example as lambda expressions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can refer to the following book for more information on the topics covered
    in this chapter: *C++ High Performance*, by Viktor Sehr and Bjorn Andrist ([https://www.amazon.com/gp/product/1787120953](https://www.amazon.com/gp/product/1787120953)).
  prefs: []
  type: TYPE_NORMAL
