- en: Elastic Beanstalk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we have focused on the use of Elastic Container Service
    (ECS) and its variant, AWS Fargate, to manage and deploy Docker applications. 
    The remainder of this book will focus on alternative technologies that you can
    use to run your Docker applications in AWS, and the first of these that we will
    cover is Elastic Beanstalk.
  prefs: []
  type: TYPE_NORMAL
- en: Elastic Beanstalk falls into a category that is commonly referred to by the
    industry as **Platform as a service** (**PaaS**), and is a service that is intended
    to provide a managed runtime environment for your applications that lets you focus
    on developing, deploying, and operating your application, rather than worry about
    the surrounding infrastructure.  To reinforce this paradigm, Elastic Beanstalk
    is focused around supporting various popular programming languages and today includes
    support for Node.js, PHP, Python, Ruby, Java, .NET, and Go applications.  When
    you create an Elastic Beanstalk application, you specify the target programming
    language, and Elastic Beanstalk will deploy an environment that supports your
    programming language and associated runtimes and application frameworks.  Elastic
    Beanstalk will also deploy supporting infrastructure such as load balancers and
    databases, and more importantly will configure your environment so that you have
    easy access to logs, monitoring information, and alerts, ensuring you can not
    only deploy your applications, but also monitor them and ensure, they are up and
    running in an optimal state.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the aforementioned programming languages, Elastic Beanstalk also
    supports Docker environments, meaning it can support any application that can
    be run in a Docker container, regardless of programming language or application
    runtime, and in this chapter you will learn how you can use Elastic Beanstalk
    to manage and deploy your Docker applications.  You will learn how to create an
    Elastic Beanstalk application using the AWS console and create an environment,
    which includes an application load balancer and RDS database instance that's required
    for our application. You will encounter some issues with the initial setup, and
    learn how to diagnose and troubleshoot these issues using the AWS console and
    Elastic Beanstalk command-line tools.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve these issues, you will configure a feature known as **ebextensions**,
    which is an advanced configuration feature of Elastic Beanstalk that can be used
    to apply a number of custom configuration scenarios to your application.  You
    will leverage ebextensions to address permissions issues with Docker volumes,
    transform default environment variables generated by Elastic Beanstalk to the
    format expected by your application, and finally ensure single shot deployment
    tasks such as executing database migrations are only run on a single instance
    for each application deployment.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is not intended to provide exhaustive coverage of Elastic Beanstalk
    and will only focus on core scenarios related to deploying and managing Docker
    applications.  For coverage of support for other programming languages and more
    advanced scenarios, refer to the [AWS Elastic Beanstalk Developer Guide](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/Welcome.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Elastic Beanstalk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Elastic Beanstalk applications using the AWS console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Elastic Beanstalk applications using the Elastic Beanstalk CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing Elastic Beanstalk applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying and testing Elastic Beanstalk applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the technical requirements for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Administrator access to an AWS account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local environment configured as per the instructions in Chapter 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A local AWS profile, configured as per the instructions in Chapter 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 2.7 or 3.x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PIP package manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CLI version 1.15.71 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker 18.06 CE or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose 1.22 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GNU Make 3.82 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter assumes you have successfully completed all of the configuration
    tasks covered so far in this book
  prefs: []
  type: TYPE_NORMAL
- en: The following GitHub URL contains the code samples that are used in this chapter: [https://github.com/docker-in-aws/docker-in-aws/tree/master/ch14](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch14).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2MDhtj2](http://bit.ly/2MDhtj2)'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Elastic Beanstalk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in the introduction to this chapter, Elastic Beanstalk is a PaaS
    offering from AWS that allows you to focus on application code and features rather
    than worry about the surrounding infrastructure required to support your application.
    To this end, Elastic Beanstalk is somewhat opinionated in its approach and generally
    works in a specific way.  Elastic Beanstalk does leverage other AWS services as
    much as possible, and tries to take the effort and complexity out of integrating
    with these services, which works well if you follow the way Elastic Beanstalk
    expects you to use these services.  If you are running a small team in a small
    to medium sized organization, Elastic Beanstalk can bring a lot of value to the
    table, providing lots of functionality out of the box. However, as soon as your
    organization grows and you look to optimize and standardize the way you deploy,
    monitor, and operate your applications, you may find that you outgrow the individual
    application-focused approach of Elastic Beanstalk.
  prefs: []
  type: TYPE_NORMAL
- en: For example, it is important to understand that Elastic Beanstalk operates on
    the concept of a single ECS task definition per EC2 instance, so if you are wanting
    to run multiple container workloads on a shared infrastructure, Elastic Beanstalk
    is not the right choice for you.  The same applies for logging and operational
    tools—in general, Elastic Beanstalk provides its own toolchain that is very focused
    on individual applications, whereas your organization may want to adopt standard
    toolsets that operate across multiple applications. Personally, I prefer the more
    flexible and extensible approach that using ECS offers, but I must admit some
    of the out of the box operational and monitoring tools that you essentially get
    for free with Elastic Beanstalk are very attractive for getting an application
    up and running, and fully integrated with other AWS services.
  prefs: []
  type: TYPE_NORMAL
- en: Elastic Beanstalk concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is solely focused on running Docker applications using Elastic
    Beanstalk, so don't expect exhaustive coverage of Elastic Beanstalk and all of
    its supported programming languages. It is important to understand the basic concepts
    however, which I will cover off briefly now before we get started with creating
    an Elastic Beanstalk application.
  prefs: []
  type: TYPE_NORMAL
- en: When using Elastic Beanstalk, you create *applications* which can define one
    or more *environments*.  Using the todobackend application as an example, you
    would define the todobackend application as an Elastic Beanstalk application,
    and create an environment called Dev and an environment called Prod to mirror
    the development and production environments we have deployed to date. Each environment
    references a specific version of your application, which contains the deployable
    code for your application. In the case of Docker applications, the source code
    includes a specification called `Dockerrun.aws.json` that defines the container
    environment for your application, which may reference an external Docker image
    or reference a local Dockerfile that is used to build your application.
  prefs: []
  type: TYPE_NORMAL
- en: Another important concept to understand is that behind the scenes, Elastic Beanstalk
    runs your application on regular EC2 instances, and follows a very strict paradigm
    of one instance of your application per EC2 instance. Each Elastic Beanstalk EC2
    instance runs a specially curated environment based upon your target application—for
    example, in the case of a multi container Docker application, the EC2 instance
    includes the Docker Engine and ECS agent.  Elastic Beanstalk also allows you to
    access and manage these EC2 instances via SSH in the case of Linux servers (which
    we will be using in this chapter), although you should generally reserve this
    access for troubleshooting purposes and never attempt to modify the configuration
    of these instances directly yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Elastic Beanstalk application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you understand the basic concepts of Elastic Beanstalk, let''s turn
    our attention to creating a new Elastic Beanstalk application. You can create
    and configure Elastic Beanstalk applications using a variety of methods:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CLI and SDKs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CloudFormation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elastic Beanstalk CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will first create an Elastic Beanstalk application in the
    AWS console, and then use the Elastic Beanstalk CLI to manage, update, and refine
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are creating a Docker application, it is important to understand that
    Elastic Beanstalk supports two kinds of Docker applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Single-container applications: [https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/docker-singlecontainer-deploy.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/docker-singlecontainer-deploy.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-container applications: [https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_docker_ecs.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_docker_ecs.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our use case, we will be following a very similar approach to how we configured
    the todobackend application for the ECS in previous chapters, hence we will require
    a multi container application, given we previously defined a main application
    container definition called **todobackend** and a **collectstatic** container
    definition in our ECS task definition (see the *Defining an ECS task definition
    using CloudFormation* section from the chapter *Deploying Applications using ECS*). 
    In general, I recommend the multi container approach, regardless of whether or
    not your application is a single container application, as the original single
    container application model goes against Docker best practices and forces you
    to run everything from a single container should your application requirements
    ever change or grow.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Dockerrun.aws.json file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regardless of the type of Docker application you are creating, you must first
    create a file called `Dockerrun.aws.json`, which defines the various containers
    that comprise your application. This file is defined in a JSON format and is based
    upon the ECS task definition format that you configured in earlier chapters, which
    we will use as a basis for the settings in the `Dockerrun.aws.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a folder called `eb` in the `todobackend-aws` repository, and
    define a new file called `Dockerrun.aws.json` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When defining a multi container Docker application, you must specify and use
    version 2 of the specification format, which is configured via the `AWSEBDockerrunVersion`
    property.  If you refer back to the *Defining an ECS task definition using CloudFormation*
    in the chapter *Deploying applications using ECS*, you can see that the version
    2 specification of the `Dockerrun.aws.json` file is very similar, although the
    format is JSON as opposed to the YAML format we have been using in our CloudFormation
    templates. We use camel case naming to define each parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The file includes two container definitions—one for the main todobackend application
    and one that generates static content—and we define a volume called `public` that
    is used to store static content.  We also configure a static port mapping from
    the container port 8000 to port 80 on the host, as port 80 is where Elastic Beanstalk
    expects your web applications to be listening by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there are some important differences from the approach we used for
    ECS:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Image**: We reference the same ECR image, however we do not specify an image
    tag, meaning the latest version of the Docker image will always be deployed. 
    The `Dockerrun.aws.json` file does not support parameter or variable references,
    so if you wanted to reference an explicit image, you would need a continuous delivery
    workflow that automatically generates this file as part of the build process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment**: Notice that we do not specify any environment variables related
    to database configuration, such as `MYSQL_HOST` or `MYSQL_USER`. We will discuss
    the reasons for this later on in this chapter, however for now understand that
    when you use the integrated support for RDS in Elastic Beanstalk, the environment
    variables that are automatically available to your applications follow a different
    format that we need to transform to meet the expectations of our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logs**: I have removed the CloudWatch logging configuration to simplify this
    chapter, however there is no reason why you cannot include a CloudWatch logs configuration
    with your containers. Note that if you did use CloudWatch logs, you would need
    to modify the Elastic Beanstalk  EC2 service role to include permissions for writing
    your logs to CloudWatch logs. We will see an example of this later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I have also removed the `XRAY_DAEMON_ADDRESS` environment variable to keep things
    simple, as you may no longer have the X-Ray daemon running in your environment. 
    Note that if you did want to support X-Ray, you would need to ensure the instance
    security group attached to your Elastic Beanstalk instances included security
    rules permitting network communications to the X-Ray daemon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined a `Dockerrun.aws.json` file, we need to create a ZIP
    archive that includes this file.  Elastic Beanstalk requires your application
    source to be uploaded in a ZIP or WAR archive format, hence this requirement.
    You can do this from the command line by using the `zip` utility as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will create an archive called `app.zip` in the `todobackend-aws/eb` folder,
    with the `-r` flag specifying that zip should recursively add all files in any
    folders that may exist (this will be the case later on in this chapter). After
    specifying an archive name of `app.zip`, we reference the current working directory
    by specifying `.` rather than `*`, as using the `.` syntax will include any hidden
    directories or files (again, this will be the case later on in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Also note that in a macOS environment, you can use the `-x` flag to exclude
    `.DS_Store` directory metadata files from being included in your archive.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Elastic Beanstalk application using the AWS console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now ready to create an Elastic Beanstalk application using the AWS console.
    To get started, select **Services** | **Elastic Beanstalk** and then click on
    the **Get started** button to create a new application.  In the **Create a web
    app** screen, specify an application name of todobackend, configure a platform
    of **multicontainer Docker**, and finally upload the `app.zip` file you created
    previously using the **Upload your code** option for the **Application code**
    setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d841d257-68b2-4f59-8ea4-50c2ff17d47f.png)Creating an Elastic Beanstalk
    web application'
  prefs: []
  type: TYPE_NORMAL
- en: Next, click on the **Configure more options** button, which will present a screen
    called **Configure Todobackend-Env** that allows you to customize your application.
    Note that by default, Elastic Beanstalk names your first application environment
    `<application-name>-Env`, hence the name **Todobackend-Env**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Configuration presets section, select the **High availability** option,
    which will add a load balancer to your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5e471f97-8e8c-4707-9949-f22419a59c26.png)Configuring an Elastic
    Beanstalk web application'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you review the current settings, you will notice that the **EC2 instance
    type** is **t1.micro** in the **Instances** section, the **Load balancer type**
    is **classic** in the **Load balancer** section, and that the **Database** section
    currently is not configured. Let''s first modify the **EC2 instance type** to
    be the free tier **t2.micro** instance type by clicking the **Modify** link in
    the **Instances** section, changing the **Instance type** and then clicking **Save**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6955ffa0-6782-47dd-aed1-eca0baed8119.png)Modifying EC2 instance
    type'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, change the **Load balancer type** to **Application Load Balancer** by
    clicking the **Modify** link in the **Load Balancer**s section and then slicking
    **Save**.  Note that the default settings expect to expose your application on
    Port - `80` to the outside world, as defined in the **Application Load Balancer**
    and **Rules** sections, and that your containers are exposed on Port 80 on your
    EC2 instances, as defined in the **Processes** section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cb26c7fb-cf9e-4789-bf21-df41b88b4254.png)'
  prefs: []
  type: TYPE_IMG
- en: Modifying load balancer type
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to define a database configuration for the application by
    clicking the **Modify** link in the **Database** section.  Select **mysql** as
    the **Engine**, specify an appropriate **Username** and **Password**, and finally
    set the **Retention** to **Delete**, given that we are only using this environment
    for test purposes.  The defaults for the other settings are sufficient, so you
    can click on the **Save** button after completing your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2a591e2a-6b48-4839-bcc2-e776bfeb2e48.png)Configuring database settings'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you have completed the configuration of your application and
    can click on the **Create app** button at the bottom of the **Configure Todobackend-env**
    screen. Elastic Beanstalk will now start creating you application and show you
    the progress of this in the console.
  prefs: []
  type: TYPE_NORMAL
- en: The Elastic Beanstalk application wizard creates a CloudFormation stack behind
    the scenes that includes all of the resources and configuration you specified. 
    It is also possible to create your own Elastic Beanstalk environments using CloudFormation
    without using the wizard.
  prefs: []
  type: TYPE_NORMAL
- en: 'After some time, the application''s creation will complete, although you can
    see that there are problems with the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a97cdb26-7e8f-412b-b2d9-570cd14d3b30.png)Initial application state'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the EC2 instance profile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created a new Elastic Beanstalk application, however the current health
    of the application is logged as Severe due to several errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you select the **Logs** option on the left hand menu and then select **Request
    Logs** | **Last 100 Lines**, you should be presented with a **Download** link
    that allows you to review the most recent log activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d8b79e73-f968-41de-8d12-f59c8321ea8b.png)Initial application state'
  prefs: []
  type: TYPE_NORMAL
- en: 'A separate tab should open in your browser, displaying various Elastic Beanstalk
    logs. At the top, you should see the ECS agent logs, and the most recent error
    should indicate that the ECS agent cannot pull the image into your `Dockerrun.aws.json`
    specification from ECR:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a7babaa2-adec-436b-a371-eb476c40aa2e.png)Elastic Beanstalk ECS agent
    error'
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve this, we need to configure the IAM role associated with the EC2
    instance profile that is attached to our Elastic Beanstalk instances to include
    permissions to pull images from ECR.  We can see which role Elastic Beanstalk
    is using by selecting **Configuration** from the left hand menu and reviewing
    the **Virtual machine instance profile** setting in the **Security** section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2d1d05a4-22bd-4106-b6d2-d9ec1c92ef5e.png)Viewing security configuration'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that an IAM role called **aws-elasticbeanstalk-ec2-role** is being
    used, so if you select **Services** | **IAM** from the navigation bar, select
    **Roles**, and then locate the IAM role, you need to attach the `AmazonEC2ContainerRegistryReadOnly`
    policy to the role as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4c1d7e88-a2ae-4e62-8813-813fe2d2bc81.png)Attaching the AmazonEC2ContainerRegistryReadOnly
    policy to the Elastic Beanstack EC2 instance role'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we should have resolved the permissions issue that caused our
    application to fail to start previously.  You now need to configure Elastic Beanstalk
    to attempt to restart the application, which you can do using any one of the following
    techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: Upload a new application source file—this will trigger a new application deployment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restart app servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rebuild the environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given our application source (which in the case of a Docker application is the
    `Dockerrun.aws.json` file) has not changed, the least destructive and fastest
    option is to restart the app servers, which you can do by selecting **Actions** |
    **Restart App Server(s)** in the top right hand corner of the **All Applications**
    | **todobackend** | **Todobackend-env** configuration screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a few minutes, you will notice that your application still has problems,
    and if you repeat the process of obtaining the most recent logs, scanning these
    logs will show you that the **collectstatic** container is failing due to a permissions
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d000d79b-4c00-425c-9d45-95325d27e079.png)collectstatic permissions
    error'
  prefs: []
  type: TYPE_NORMAL
- en: Recall, earlier in this book, how we configured a folder with the correct permissions
    on our ECS container instances to host the public volume that the **collectstatic**
    container writes to? With Elastic Beanstalk, the default EC2 instance that is
    created for a Docker application is obviously not configured in such a fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will resolve this issue shortly, but for now it is important to understand
    there are also other problems. To understand these problems, you need to actually
    attempt to access the application, which you can do so by clicking the URL link
    at the top of the All Applications | todobackend | Todobackend-env configuration
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/44aeed70-ba34-4753-b83c-b25340f5d855.png)Obtaining the Elastic Beanstalk
    application URL'
  prefs: []
  type: TYPE_NORMAL
- en: 'Browsing to this link should show you immediately that static content files
    are not being generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/def30500-bb83-4fd9-a5d0-0a8b0d026721.png)Missing static content'
  prefs: []
  type: TYPE_NORMAL
- en: 'And if you click on the **todos** link to view the current list of Todo items,
    you will receive an error indicating that the application cannot connect to the
    MySQL database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/232faa9e-1890-4f51-8bdb-3b829aaad7fc.png)Database connectivity error'
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that we haven't added any database configuration to our `Dockerrun.aws.json`
    file, hence our application is defaulting to using localhost in an attempt to
    locate the database.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Elastic Beanstalk applications using the CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will resolve the issues that still exist with our application shortly, but
    in order do so we are going to use the Elastic Beanstalk CLI to continue configuring
    our application and address these issues.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start using the Elastic Beanstalk CLI, it is important to understand
    that the current version of this application does have some challenges when interacting
    with the multi-factor authentication (MFA) requirements we introduced for all
    console and API access in earlier chapters. If you continue to use MFA, you will
    notice that you are prompted each and every time you execute an Elastic Beanstalk
    CLI command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To work around this, we can temporarily remove the MFA requirement by first
    removing your user from the `Users` group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, comment out the `mfa_serial` line within the `docker-in-aws` profile
    inside your local `~/.aws/config` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note, this is not ideal, and in a real world scenario you probably would not
    have the ability to, nor want to, temporarily disable MFA for a given user.  Bear
    this in mind when considering Elastic Beanstalk, as you will generally rely on
    the Elastic Beanstalk CLI for a number of operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'With MFA now temporarily disabled, you can install the Elastic Beanstalk CLI,
    which you can do by using the Python `pip` package manager. Once it''s been installed,
    it will be accessible via the `eb` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to initialize the CLI in the `todobackend/eb` folder that
    you created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `eb init` command uses the `--profile` flag to specify a local AWS profile,
    and then prompts for the region that you will be interacting with. The CLI then
    checks to see if there are any existing Elastic Beanstalk applications, and prompts
    you as to whether you want to manage an existing application or create a new application. 
    Once you have made your selections, the CLI will add project information to the
    current folder under the a folder called `.elasticbeanstalk`, and will also create
    or append to a `.gitignore` file. Given our `eb` folder is a a subdirectory of
    the **todobackend** repository, it is a good idea to append the contents of the `.gitignore`
    file to the root of the **todobackend** repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now use the CLI to view the current status of your application, list
    your application environments, and perform many other administrative tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `eb status` command lists the URL of your application in the
    `CNAME` property—take note of this URL as you will need it to test your application
    throughout this chapter.  You can also use the `eb open` command to access your
    application, which will open the application URL in your default browser.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Elastic Beanstalk EC2 instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using Elastic Beanstalk, it is useful to be able to have access to the
    Elastic Beanstalk EC2 instances, especially if you need to do some troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CLI includes the ability to establish SSH connections to your Elastic Beanstalk
    EC2 instances, which you can set up by running the `eb ssh --setup` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that setting up SSH access requires you to terminate existing instances
    and create new instances, given you can only associate an SSH key pair with an
    EC2 instance upon creation. After selecting the existing `admin` key pair that
    you created earlier in this book, the CLI terminates the existing instances, creates
    a new auto scaling launch configuration that enables SSH access, and then launches
    new instances.
  prefs: []
  type: TYPE_NORMAL
- en: You can avoid this step by configuring an EC2 key pair in the Security section
    of the configuration wizard when creating the Elastic Beanstalk application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now SSH into your Elastic Beanstalk EC2 instance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By default, the `eb ssh` command will attempt to use an SSH private key called
    `~/.ssh/<ec2-keypair-name>.pem`, which in this case is `~/.ssh/admin.pem`.  If
    your SSH private key is in a different location, you can use the `-e` flag to
    override the file that is used, as demonstrated in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now take a look around at your Elastic Beanstalk EC2 instance. Given
    we are running a Docker application, you might be first inclined to run the `docker
    ps` command to see what containers are currently running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Somewhat surprisingly, the standard `ec2-user` does not have access to Docker—to
    resolve this, we need to add more advanced configuration referred to as **ebextensions**.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing Elastic Beanstalk applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in the previous section, we need to add an ebextension, which is
    simply a configuration file that can be used to customize your Elastic Beanstalk
    environment to our existing Elastic Beanstalk application.  This is an important
    concept to understand, as we will ultimately use this same approach to resolve
    all of the issues that our application currently has.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure `ebextensions`, you first need to create a folder called `.ebextensions`
    in the `eb` folder where you are currently storing your `Dockerrun.aws.json` file
    (note that you will need to disconnect from the SSH session, go to your Elastic
    Beanstalk EC2 instance, and perform this in your local environment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Each file with a `.config` extension in the `.ebextensions` folder will be
    treated as an ebextension and processed by Elastic Beanstalk during an application
    deployment. In the preceding example, we create a file called `init.config`, which
    we can now configure to allow the `ec2-user` access to the Docker Engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We add a command directive called `01_add_ec2_user_to_docker_group` to the `commands`
    key, which is a top-level property that defines commands that should be run *before*
    the latest version of your application is set up and deployed to your instances. 
    This command runs the `usermod` command to ensure that the `ec2-user` is a member
    of the `docker` group, which will grant `ec2-user` access to the Docker Engine.
    Notice that you can use the `ignoreErrors` property to ensure any command failures
    are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this configuration in place, we can deploy a new version of our application
    by running the `eb deploy` command in the `eb` folder, which will automatically
    create a ZIP archive of our existing `Dockerrun.aws.json` and the new `.ebextensions/init.config`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We first remove the initial `app.zip` archive you created when you first created
    the Elastic Beanstalk application, as the `eb deploy` command automatically takes
    care of this. You can see that once the new configuration is uploaded, the deployment
    process involves stopping and starting the ECS task that is running our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the deployment is complete, if you establish a new SSH session to the
    Elastic Beanstalk EC2 instance, you should see that you are now able to run `docker`
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the instance is currently running the todobackend container,
    and also runs the ECS agent. This demonstrates that the Docker support in Elastic
    Beanstalk uses ECS in the background to manage and deploy container-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving Docker volume permissions issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, we ran into a problem where the collectstatic container
    was unable to write to the public volume.  The issue here is that the ECS agent
    running on the Elastic Beanstalk EC2 instance creates a *bind* mount, which are
    always created with root permissions. This prevents the app user that our collectstatic
    container runs as from writing to the public volume, so we need some way to resolve
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have already seen, the `ebextensions` feature can run commands on Elastic
    Beanstalk EC2 instances, and we will once again leverage this functionality to
    ensure that the public volume is configured to allow the `app` user in our containers
    to read and write in the `.ebextensions/init.config` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We add a new command directive called `02_docker_volumes`, which will be executed
    after the `01_add_ec2_user_to_docker_group` command.  Notice that you can use
    the YAML pipe operator (`|`) to specify a multi-line command string, allowing
    you to specify multiple commands to run.  We first create the `/tmp/public` folder
    that the public volume host `sourcePath` property refers to in the `Dockerrun.aws.json`
    file, and then ensure that the user ID/group ID values of `1000:1000` own this
    folder.  Because the app user has a user ID of 1000 and a group ID of 1000, this
    will enable any process running as that user to write to and read from the public
    volume.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you can use the `eb deploy` command to upload a new application
    configuration to Elastic Beanstalk (see earlier examples). Once the deployment
    is complete, you can browse to the URL of your application by running the `eb
    open` command, and you should now see that the static content and formatting of
    the todobackend application is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring database settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have resolved the issue with accessing the public volume, however the application
    is still not working because we are not passing in any environment variables to
    configure database settings.  The reason for this is that when you configure a
    database in Elastic Beanstalk, all database settings are made available via the
    following environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RDS_HOSTNAME`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RDS_USERNAME`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RDS_PASSWORD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RDS_DB_NAME`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RDS_PORT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problem for the todobackend application is that it expects database-related
    settings that are prefixed with MYSQL—for example, `MYSQL_HOST` is used to configure
    the database hostname. Although we could update our application to use the RDS
    prefixed environment variables, we might want to deploy our application to other
    cloud providers, and RDS is an AWS specific technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative, albeit more complicated approach, is to write the environment
    variable mappings to a file on the Elastic Beanstalk instance, configure this
    as a volume that the todobackend application containers can access, and then modify
    our Docker image to inject these mappings at container startup.  This requires
    us to modify the entrypoint script for the todobackend application that is located
    in the `entrypoint.sh` file at the root of the `todobackend` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we added a new test expression that checks for the
    existence of a file called `/init/environment` using the syntax `[ -f /init/environment
    ]`. If this file is found, we assume that the file includes one or more environment
    variable settings in the format `<environment variable>=<value>`—for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding format, we then use the `export $(cat /init/environment |
    xargs)` command, which expands to `export MYSQL_HOST=abc.xyz.com MYSQL_USERNAME=todobackend
    ... ...` using the preceding example, ensuring that each environment variable
    defined in the `/init/environment` file is exported into the environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you now commit your changes to the `todobackend` repository and run the `make
    login`, `make test`, `make release`, and `make publish` commands, the latest `todobackend`
    Docker image will now include the updated entrypoint script. Now, we need to modify
    the `Dockerrun.aws.json` file in the `todobackend-aws/eb` folder to define a new
    volume and mount called `init`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With this volume mapped to `/tmp/init` on the Elastic Beanstalk EC2 instance
    and `/init` in the `todobackend` container, all we need to do now is write environment
    variable settings to `/tmp/init/environment` on the EC2 instance, which will appear
    as `/init/environment` in the `todobackend` container, and trigger processing
    of the file using the modifications we made to the entrypoint script. The idea
    here is that we will write the Elastic Beanstalk RDS instance settings to the
    appropriate environment variable settings that the todobackend application expects.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can do this, we need a mechanism to be able to obtain the RDS settings—fortunately,
    there is a file called `/opt/elasticbeanstalk/deploy/configuration/containerconfiguration`
    on each Elastic Beanstalk instance that includes the entire environment and application
    configuration in a JSON file format.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you SSH into an instance, you can use the `jq` utility (which is already
    pre-installed on Elastic Beanstalk instances) to extract the RDS instance settings
    for your Elastic Beanstalk application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'With this mechanism to extract RDS settings, we can now modify the `.ebextensions/init.config`
    file to write each of these settings to the `/tmp/init/environment` file that
    will be exposed to the `todobackend` container via the `init` volume at `/init/environment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We first modify the `02_docker_volumes` directive to create the `/tmp/init`
    path that the init volume is mapped to, and ensure that the app user running in
    the todobackend application has read/write access to this folder. Next, we add
    the `container_commands` key, which specifies commands that should be executed
    *after* the application configuration has been applied but *before* the application
    is started. Note that is different from the `commands` key, which executes commands
    *before* the application configuration is applied.
  prefs: []
  type: TYPE_NORMAL
- en: The naming of the `container_commands` key is somewhat confusing in that it
    implies commands will be run inside a Docker container. This is actually not the
    case and the `container_commands` key is completely unrelated to containers in
    the Docker sense.
  prefs: []
  type: TYPE_NORMAL
- en: The `01_rds_settings` command writes the various MYSQL prefixed environment
    variable settings the application requires, obtaining the appropriate value for
    each by executing the `jq` command, as we demonstrated earlier. Because this file
    is created by the root user, we finally ensure that the `app` user has read/write
    access to the `/tmp/init/environment` file, which will be present as `/init/environment`
    in the container via the init volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you now deploy your changes using the `eb deploy` command, once deployment
    is complete and you navigate to the todobackend application URL, if you attempt
    to list Todos items (by accessing `/todos`), notice that a new error is now displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0463b13c-678a-412c-a600-059010e23449.png)Accessing todobackend Todos
    items error'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that when you previously accessed the same URL, the todobackend application
    was attempting to access MySQL using localhost, however now we get an error indicating
    that the `todo_todoitem` table cannot be found in the `ebdb` database.  This confirms
    that the application is now communicating with the RDS instance, however because
    we have not run database migrations, the schema and tables to support the application
    are not in place.
  prefs: []
  type: TYPE_NORMAL
- en: Running database migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To fix the current issue with our application, we need to have a mechanism that
    allows us to run database migrations to create the required database schema and
    tables.  This must also happen on each application update, however this should
    only occur *once* per application update. For example, if you had multiple Elastic
    Beanstalk instances, you do not want migrations to run on each instance. Instead,
    you want migrations to run only once for each deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `container_commands` key that you were introduced to in the previous section
    includes a useful property called `leader_only`, which configures Elastic Beanstalk
    to only run the specified command on the leader instance. This is the first instance
    that becomes available to deploy to. We can therefore add a new directive to the
    `.ebextensions/init.config` file in the `todobackend-aws/eb` folder that will
    run migrations only once per application deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we write the `python3 manage.py migrate --no-input` command to the `/tmp/init/commands` file,
    which will be exposed to the application container at the location `/init/commands`. 
    This, of course, requires us to now modify the entrypoint script in the `todobackend`
    repository to look for such a file and execute the commands contained within it,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we add a new test expression that checks for the existence of the `/init/commands` file,
    and if this file exists we use the `source` command to execute each command contained
    within the file.  Because this file will only be written on the leader Elastic
    Beanstalk instance, the entrypoint script will only invoke these commands once
    per deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you need to rebuild the todobackend Docker image by running
    the  `make login`, `make test`, `make release`, and `make publish` commands, after
    which you can deploy your Elastic Beanstalk changes by running the `eb deploy`
    command from the `todobackend-aws/eb` directory.  Once this has completed successfully,
    if you SSH to your Elastic Beanstalk instance and review the logs of the current
    active todobackend application container, you should see that the database migrations
    were executed when the container was started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you now browse to the application URL, you should find that the application
    is fully functional, and you have successfully deployed a Docker application to
    Elastic Beanstalk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we wrap up this chapter, you should restore the MFA configuration you
    temporarily disabled earlier in this chapter by adding your user account back
    to the `Users` group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And then re-enable the `mfa_serial` line within the `docker-in-aws` profile
    inside your local `~/.aws/config` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can also delete your Elastic Beanstalk environment by browsing to the main
    Elastic Beanstalk dashboard and clicking the **Actions | Delete** application
    button next to the **todobackend** application.  This will delete the CloudFormation
    stack that was created by the Elastic Beanstalk environment, which includes the
    application load balancer, RDS database instance, and EC2 instances.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to deploy multi-container Docker applications
    using Elastic Beanstalk.  You learned why and when you would choose Elastic Beanstalk
    over other alternative container management services such as ECS, and the general
    conclusion here is that Elastic Beanstalk is great for smaller organizations with
    a small number of applications, but becomes less useful as your organization starts
    to grow and needs to start focusing on offering shared container platforms to
    reduce cost, complexity, and management overheads.
  prefs: []
  type: TYPE_NORMAL
- en: You created an Elastic Beanstalk application using the AWS console, which required
    you to define a single file called `Dockerrun.aws.json` that included the container
    definitions and volumes required to run your application, and then automatically
    deployed an application load balancer and RDS database instance with minimal configuration. 
    Getting your application up and running into a fully function state was a bit
    more challenging, and required you to define advanced configuration files called
    `ebextensions` that allowed you to adapt Elastic Beanstalk to meet the specific
    needs of your application.  You learned how to install and set up the Elastic
    Beanstalk CLI, connect to your Elastic Beanstalk instances using SSH, and deploy
    configuration changes to your `Dockerrun.aws.json` file and `ebextensions` files.
    This allowed you to set up volumes on the Elastic Beanstalk instances with correct
    permissions for container applications running as non-root users, and introduced
    a special init volume where you can inject environment variable settings and commands
    that should be executed as your container starts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at Docker Swarm and how you can deploy
    Docker Swarm clusters on AWS to deploy and run your Docker applications.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'True/false: Elastic Beanstalk only supports single container Docker applications.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the minimum required artifact to create a Docker application using Elastic
    Beanstalk?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/false: The `.ebextensions` folder stores YAML files that allow you to
    customise your Elastic Beanstalk instances.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You create a new Elastic Beanstalk service that deploys a Docker application
    whose Docker image is stored in ECR.  On initial creation. the application fails,
    with the Elastic Beanstalk logs showing an error including the words "CannotPullECRContainerError". 
    How would you resolve this issue?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/false: Out of the box without any additional configuration, Docker containers
    running as non-root users in an Elastic Beanstalk environment can read and write
    to Docker volumes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/false: You can set the `leader_only` property to true in the `commands`
    key to run a command on only one Elastic Beanstalk instance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/false: The `eb connect` command is used to establish SSH access to an
    Elastic Beanstalk instance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/false: Elastic Beanstalk supports application load balancer integration
    with your application.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can check the following links for more information about the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Elastic Beanstalk Developer Guide: [https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/Welcome.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/Welcome.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multicontainer Docker Environments: [https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_docker_ecs.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_docker_ecs.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Elastic Beanstalk with Other AWS Services: [https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/AWSHowTo.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/AWSHowTo.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced Environment Configuration with Configuration Files: [https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/ebextensions.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/ebextensions.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Elastic Beanstalk Command Line Interface: [https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/eb-cli3.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/eb-cli3.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
