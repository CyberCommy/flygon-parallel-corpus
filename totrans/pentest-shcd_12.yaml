- en: Detection and Prevention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, to the last chapter of the book. Here, we will talk about security
    mechanisms to prevent buffer overflow attacks. Let''s divide these mechanisms
    into three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: System approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiler approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developer approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will talk about built-in mechanisms inside some system kernels
    to prevent techniques, such as ASLR, in buffer overflow attacks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Address Space Layout Randomization** (**ASLR**) is a mitigation technique
    against overflow attacks that randomizes memory segments, which prevents hardcoded
    exploits. For example, if I want to use the return-to-lib technique, I have to
    get the address of the function, which will be used in the attack. However, since
    the addresses of memory segments are randomized, the only way to do it is to guess
    that location, and yes, we use this technique to bypass NX protection, but not
    bypass ASLR.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For security geeks out there, don''t worry; there are many ways to get around
    ASLR. Let''s take a look at how ASLR really works. Open your Linux victim machine
    and make sure that ASLR is disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00404.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'ASLR is disabled since the value of `randomize_va_space` is `0`. If it is enabled,
    set it to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at the addressing layout for any application, for example,
    `cat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open another Terminal. Now, we need to get the PID of this process using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00405.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The PID of `cat` is `5029`. Let''s get the memory layout for this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00406.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s stop the `cat` process using *Ctrl* + *C*, and then start it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, from another Terminal window, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00407.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, the PID of `cat` is `5164`. Let''s get the memory layout for this PID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00408.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Take a look at the memory layout of both PIDs; they are exactly the same. Everything
    is statically allocated in memory, such as libraries, stack, and heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s enable ASLR to see the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that ASLR is enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00409.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, let''s start any process, for example, `cat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, from another Terminal window, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00410.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The PID of `cat` is `5271`. Now, read its memory layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00411.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s stop `cat` and re-run it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s catch the PID of `cat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00412.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, read its memory layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00413.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's compare both addresses. They are totally different. Stack, heap, and libraries
    are all now dynamically allocated, and all addresses will become unique for every
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: Now to the next section, which is the compiler approach, such as executable-space
    protection and canary.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Executable-space protection is a technique used to mark some segments in memory
    as non-executable, such as stack and heap. So, if we even succeeded to inject
    a shellcode, then it would be impossible to make that shellcode run.
  prefs: []
  type: TYPE_NORMAL
- en: Executable-space protection in Linux is called **non-executable** (**NX**), and
    in Windows it is called **Data Execution Prevention** (**DEP**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to use our example from [Chapter 6](part0081.html#2D7TI0-5bf3e26315164e77bbeecc4f75207114),
    *Buffer Overflow Attacks*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, compile it with NX disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Open it in GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s run this exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside GDB, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00414.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s try the same exploit but with NX enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open it in GDB and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00415.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, why did the code get stuck at this address?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00416.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Because it refuses to even execute our No Operation (`nop`) from the stack,
    as the stack is now non-executable.
  prefs: []
  type: TYPE_NORMAL
- en: Let's talk about another technique, which is stack canary or stack protector.
    Stack canary is used to detect any attempt to smash the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a return value is stored in a stack, a value called **canary** value is
    written before storing the **return address**. So, any attempt to perform a stack
    overflow attack will overwrite the **canary** value, which will cause a flag to
    be raised to stop the execution because there is an attempt to smash the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00417.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, try to use our previous example, but let''s enable the stack `canary`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s re-run it inside GDB and try our exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00418.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at why it failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00419.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It tried to compare the original canary value with the stored value, and it
    failed because we did overwrite the original value with whatever was there in
    our exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00420.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: And as you can see, stack smashing was detected!
  prefs: []
  type: TYPE_NORMAL
- en: Developer approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now to the final part, which is the developer approach, where any developer
    should do all they can to protect their code against overflow attacks. I'll talk
    about C/C++, but the concept still remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, when using any string handling function, you should use safe functions.
    The next table shows unsafe functions and what to use instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Unsafe functions** | **Safe functions** |'
  prefs: []
  type: TYPE_TB
- en: '| `strcpy` | `strlcpy` |'
  prefs: []
  type: TYPE_TB
- en: '| `strncpy` | `strlcpy` |'
  prefs: []
  type: TYPE_TB
- en: '| `strcat` | `strlcat` |'
  prefs: []
  type: TYPE_TB
- en: '| `strncat` | `strlcat` |'
  prefs: []
  type: TYPE_TB
- en: '| `vsprintf` | `vsnprintf` or `vasprintf` |'
  prefs: []
  type: TYPE_TB
- en: '| `sprintf` | `snprintf` or `asprintf` |'
  prefs: []
  type: TYPE_TB
- en: Also, you should always use the `sizeof` function to calculate the size of a
    buffer in your code. Try to be precise when it comes to the buffer size by mixing
    it with a safe function; then, your code is much safer now.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the final chapter of the book, we discussed some protection techniques in
    operating systems and also some techniques in the C compiler, such as GCC. Then,
    we moved on to how to make your code safer.
  prefs: []
  type: TYPE_NORMAL
- en: This is not the end. There are more ways to work around each protection technique.
    With this book, you have been provided with strong basics to continue your journey.
    Keep going and I promise you that you will master this domain!
  prefs: []
  type: TYPE_NORMAL
