- en: Designing Your Cloud-Native Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计您的云原生应用程序
- en: In this chapter, we pause application development and take a step back to look
    at the bigger picture of designing cloud applications. As seen in the first chapter,
    applications in the cloud have more unique challenges than the traditional enterprise
    applications that we have been developing so far. Also, the business requirement
    of agility has to be met by not compromising on performance, stability, and resiliency.
    Hence, a look at the first principles becomes important.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们暂停应用程序开发，退一步看设计云应用的整体情况。正如在第一章中所看到的，云中的应用比我们迄今为止开发的传统企业应用有更多独特的挑战。此外，敏捷的业务需求必须在不牺牲性能、稳定性和弹性的情况下得到满足。因此，看待第一原则变得重要。
- en: In the first chapter, we had a look at the differences between cloud environments
    and traditional enterprises, and how the concepts of DevOps, 12-factor app, microservices,
    and ecosystems are important. Here, we will look at the various principles and
    techniques that enable us to design robust, scalable, and agile applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们看到了云环境和传统企业之间的差异，以及DevOps、12因素应用程序、微服务和生态系统的概念是如何重要的。在这里，我们将看一下各种原则和技术，使我们能够设计健壮、可扩展和敏捷的应用程序。
- en: Some of the areas we will cover include the dominance of the REST, HTTP, and
    JSON for building APIs, the role of the API gateways, how to decouple applications,
    how to identify microservices, various microservice design guidelines, the role
    of the data architecture, and the role of security in designing the APIs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖的一些领域包括使用REST、HTTP和JSON构建API的主导地位，API网关的作用，如何解耦应用程序，如何识别微服务，各种微服务设计指南，数据架构的作用，以及在设计API时安全性的作用。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下主题：
- en: Popularity of REST, HTTP, and JSON
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST、HTTP和JSON的流行
- en: Rise and popularity of the APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API的兴起和流行
- en: Role of API gateways
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API网关的角色
- en: Decoupling—the need for smaller application boundaries
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解耦-需要更小的应用边界
- en: Microservice identifications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务识别
- en: Microservice design guidelines
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务设计指南
- en: Microservice patterns
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务模式
- en: Data architecture
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据架构
- en: Role of security
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全角色
- en: The trio – REST, HTTP, and JSON
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三者-REST、HTTP和JSON
- en: The web has made HTTP tremendously popular and is the de facto integration mechanism
    for accessing content on the internet. Interestingly, this technology was not
    hugely popular within applications that relied on native and binary protocols,
    such as RMI and CORBA for inter-application access.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 网络使得HTTP变得非常流行，并成为访问互联网内容的事实集成机制。有趣的是，这项技术在依赖本地和二进制协议（如RMI和CORBA）进行应用程序访问的应用程序中并不是非常流行。
- en: When social consumer companies, such as Google, Amazon, Facebook, and Twitter,
    started publishing APIs to connect/integrate with their products, the de facto
    standard for integration across the web became HTTP/REST. Social consumer companies
    started investing in platforms for onboard developers to develop various applications
    leading to the proliferation of applications that relied on HTTP as the protocol.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当社交消费公司（如Google、Amazon、Facebook和Twitter）开始发布API以连接/集成其产品时，跨网络的集成的事实标准变成了HTTP/REST。社交消费公司开始投资于平台，以吸引开发人员开发各种应用程序，从而导致依赖HTTP作为协议的应用程序的大量增加。
- en: The applications on the browser side are a mix of HTML and JavaScript. Information
    returned from the server or across other applications needs to be in a simple
    and usable format. JavaScript supports data manipulation, and the data format
    that it suited most is **JavaScript Object Notation** (**JSON**).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器端的应用程序是HTML和JavaScript的混合。从服务器返回的信息或其他应用程序需要以简单和可用的格式。 JavaScript支持数据操作，最适合的数据格式是**JavaScript对象表示**（**JSON**）。
- en: 'REST is a state representational style that provides a way to deal with interchange
    over HTTP. REST has a lot factors in its favor:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: REST是一种状态表示风格，提供了一种处理HTTP交换的方式。 REST有很多优势：
- en: Utilizes the HTTP protocol standard, giving it an immense leg up for anything
    and everything on WWW
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用HTTP协议标准，为WWW上的任何事物提供了巨大的优势
- en: Mechanism to isolate the access to entities (`GET`/`PUT`/`POST`/`DELETE`) while
    still utilizing the same HTTP request model
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离对实体的访问（`GET`/`PUT`/`POST`/`DELETE`）的机制，同时利用相同的HTTP请求模型
- en: Supports JSON as the data format
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持JSON作为数据格式
- en: 'REST with JSON has become the dominant model over the SOAP/XML model. According
    to one statistic from ProgrammableWeb:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: REST与JSON已经成为主导模型，超过了SOAP/XML模型。根据可编程Web的统计数据：
- en: 73% of the APIs on Programmable Web use REST. SOAP is far behind but is still
    represented in 17% of the APIs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 73%的可编程Web API使用REST。 SOAP远远落后，但在17%的API中仍有所体现。
- en: 'Let''s cover some high-level reasons why the REST/JSON model is favored over
    the SOAP/XML model of service development:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些REST/JSON模型受欢迎的高级原因：
- en: SOAP model of contract first approach makes crafting web services difficult.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOAP的契约优先方法使得制作Web服务变得困难。
- en: SOAP is complex compared to REST, giving a steeper learning curve as compared
    to REST.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与REST相比，SOAP更复杂，学习曲线更陡。
- en: REST is lightweight compared to SOAP and does not tax the bandwidth as much
    as SOAP.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与SOAP相比，REST更轻量级，不会像SOAP那样占用带宽。
- en: Support for SOAP outside of the Java world is limited, relegating SOAP primarily
    to the enterprise world.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java世界之外，对SOAP的支持有限，主要将SOAP局限于企业世界。
- en: XML parsing on the client side is memory and compute intensive, which does not
    lend well to the mobile world.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端上的XML解析需要大量内存和计算资源，这不适合移动世界。
- en: XML Schema/markup provides structure definitions and validation models but at
    the expense of additional parsing. JSON has a loose syntax allowing rapid iterations
    on the data model.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML模式/标记提供了结构定义和验证模型，但需要额外的解析。 JSON具有松散的语法，允许对数据模型进行快速迭代。
- en: Today, the reality is REST/JSON has been adopted as the standard for integration
    across programming languages providing an easy and simple way to integrate APIs
    over the internet.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Rise and popularity of the APIs
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **Application Programming Interface** (**API**) provides a standard interface
    or contract to consume its services over the internet. The API defines the structure
    of the input and output and remains constant over the life of an API version.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: APIs are the contract between the client layer and the enterprise. They are
    consumer-oriented, that is, designed by the client, and they abstract the service
    implementation details from the client.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Coming back to the advent of social consumer companies, creating new applications
    meant not starting from scratch. For example, if my application needs to use geographical
    maps, I can make use of the Google Map APIs and build my application on top of
    that. Similarly, instead of building my own authentication model, I can make use
    of OAuth and use Google, Facebook, or Twitter as some of the OAuth providers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: This entire model of making a repeatable but often complex functionality available
    as a reusable service led to a model where the developer started building the
    applications using these pre-existing APIs, which in turn led to increased developer
    productivity and evolution of the modern day applications or mobile applications
    economy.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Companies started to look to see if they could monetize the APIs, which meant
    multiple companies were writing/publishing APIs that provided similar functionalities.
    This led to the democratization of the APIs allowing anyone and everyone access
    to features/functions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: This whole democratization of the API meant, suddenly, every process or functionality
    could be provided as a set of APIs that could be orchestrated or choreographed
    to build new features or functions. What took months or years earlier, now only
    takes weeks or days. All this productivity means shorter development cycles, allowing
    rapid iteration to provide new and innovative features.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, all kinds of APIs are available: from social companies such as Facebook,
    Google, and Twitter to enterprises such as Salesforce, NetSuite, and PaaS/IaaS
    providers, such as AWS, Azure, **Google Cloud Engine** (**GCE**), and so on, that
    all provide functionality from provisioning a VM to a database instance, to AI
    providers such as Watson, AWS AI, and Azure ML.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Role of API gateways
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An API gateway is a singular interface that handles all the incoming requests
    before redirecting to the internal servers. An API gateway typically provides
    the following functions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Routes the incoming traffic to the appropriate service hosted with the provider's
    data center/cloud. Provides a reverse proxy model to limit the exposure of various
    APIs and services hosted within the provider's data center/cloud.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filters all the incoming traffic from all kind of channels—web, mobile, and
    so on.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements security mechanisms (such as OAuth) to authenticate and log the service
    usage.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides ability to throttle and limit traffic to certain services.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforms data between the service consumer and provider.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Provides one or more APIs that map to an underlying service provider. For example,
    for different kind of consumers—mobile, web, paid service, or a free service,
    the same underlying service can be split into multiple custom APIs that are exposed
    to a different set of consumers, so that the consumer sees only the features it
    needs:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/5215f408-cc6f-4926-ad6a-70890fc44f04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: Benefits of an API gateway
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use of API gateways provides the following benefits:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '**Separation of concerns**: Insulates the microservice providers from the service
    consumers on the application side. This allows the separation of the application
    tier from the service requesting clients.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consumer oriented**: API gateways provide a unified hub for a large number
    of APIs and microservices. This allows the consumer to focus on API utility instead
    of locating where a service is hosted, managing service request limits, security,
    and so on.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向消费者：API网关为大量的API和微服务提供了一个统一的中心。这使得消费者可以专注于API的实用性，而不是寻找服务的托管位置，管理服务请求限制，安全性等。
- en: '**API oriented**: Provides an optimum API based on the type of the client and
    required protocols.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向API：根据客户端的类型和所需的协议提供最佳的API。
- en: '**Orchestration**: Provides the ability to orchestrate multiple services calls
    into one API call, which in turn simplifies the logic for a client. Now, instead
    of calling multiple services, it can invoke one API. Fewer requests means less
    invocation overhead and improve the consumer experience overall. An API gateway
    is essential for mobile applications.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编排：提供了将多个服务调用编排成一个API调用的能力，从而简化了客户端的逻辑。现在，它可以调用一个API而不是调用多个服务。较少的请求意味着较少的调用开销，从而提高了消费者的整体体验。API网关对移动应用程序至关重要。
- en: '**Monitor**: An API gateway also provides the ability to monitor API invocations,
    which in turn allows enterprises to evaluate the success of APIs and their usage.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控：API网关还提供了监控API调用的能力，从而使企业能够评估API的成功和使用情况。
- en: Besides the overall benefits, API gateways add more pieces to the overall puzzle.
    Meaning more infrastructure to manage, more configurations to manage, more points
    of failure, and additional hops to the requests. So, unless the benefits outweigh
    the drawbacks, use of API gateways needs be carefully scrutinized for the business
    requirements and benefits.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了总体利益外，API网关为整体拼图增加了更多的部分。这意味着需要管理更多的基础设施、更多的配置、更多的故障点和额外的请求跳转。因此，除非利益超过了缺点，否则需要仔细审查API网关的使用，以满足业务需求和利益。
- en: Next, we will see the process of breaking down the application functionalities
    as a set of APIs or microservices.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到将应用程序功能拆分为一组API或微服务的过程。
- en: Application decoupling
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序解耦
- en: The traditional model of application development, where all the features and
    functionalities were bundled in a large package called a monolithic application,
    is becoming less popular for multiple reasons. Monolith applications take on too
    many responsibilities in the form of function and logic. It is this characteristic
    which leaves them with high coupling and low cohesion. The reuse factor in monoliths
    tends to be low since one part of the functionality cannot be separated from the
    rest of the function and logic.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的应用程序开发模型，将所有功能和功能捆绑在一个称为单体应用程序的大型包中，由于多种原因而变得不太受欢迎。单体应用程序以功能和逻辑的形式承担了太多的责任。正是这一特征使它们具有高耦合和低内聚。单体应用程序中的重用因子往往较低，因为功能的一部分无法与其余的功能和逻辑分离。
- en: As we start breaking down the monolith functionality or even designing a new
    application, the focus needs to be on defining the service boundaries. Defining
    the right set of service boundaries and their related interactions is what leads
    to high cohesion and low coupling models.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始拆分单体功能或设计新应用程序时，重点需要放在定义服务边界上。定义正确的服务边界及其相关的交互是导致高内聚和低耦合模型的关键。
- en: The question becomes, what is the basis on which the application should be decoupled
    into services and defined service boundaries?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，应用程序应该根据什么基础被解耦为服务，并定义服务边界？
- en: Bounded context/domain-driven design
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有界上下文/领域驱动设计
- en: As part of the application design, the business domain needs to be broken down
    into smaller subdomains or business capabilities. We need to carefully examine
    the business entities and their attributes to define service boundaries. For example,
    in the case of customer ID entity, the address of the customer might be integral
    to the customer. Within the context of the application, address maintenance might
    be a separate activity and might need to be handled separately. Similarly, customer
    preferences or shopping habits might be required for personalization. In this
    case, the personalization engine is more interested in this set of attributes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为应用程序设计的一部分，业务领域需要被拆分为更小的子领域或业务能力。我们需要仔细审查业务实体及其属性，以定义服务边界。例如，在客户ID实体的情况下，客户的地址可能是客户的一部分。在应用程序的上下文中，地址维护可能是一个单独的活动，可能需要单独处理。同样，个性化可能需要客户偏好或购物习惯。在这种情况下，个性化引擎更感兴趣这一系列属性。
- en: Should we be slapping together one big customer service having all kind of attributes
    or can it be divided based on the perspectives derived from the business? These
    different perspectives are what led to the definition of bounded context as part
    of the domain-driven design.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该组合一个包含所有属性的大型客户服务，还是可以根据业务派生的不同视角进行划分？这些不同的视角导致了领域驱动设计中有界上下文的定义。
- en: 'The bounded context is a domain-driven design paradigm that helps to add a
    seam and create service groups. Bounded contexts work in solution-space to indicate
    that the services are related and belong to a common functional domain. It is
    built by one team that works with one business unit as per Inverse Conway''s law.
    A bounded context may communicate with the other services/business capabilities
    through:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有界上下文是一种领域驱动设计范式，有助于添加一个接缝并创建服务组。有界上下文在解决方案空间中工作，表明服务相关并属于一个共同的功能域。它是由一个团队根据反向康威定律与一个业务单元一起构建的。有界上下文可以通过以下方式与其他服务/业务能力进行通信：
- en: Exposing internal APIs or services
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴露内部API或服务
- en: Emitting events on the Event Bus
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在事件总线上发出事件
- en: A bounded context may have its own data store common to services or adopt a
    data store per service paradigm.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有界上下文可以拥有自己的数据存储，服务共用，或采用每个服务一个数据存储的范式。
- en: Each bounded context has a life of its own and forms a product. Teams are organized
    around these bounded contexts and they take the full responsibility of the full
    stack implementation of the services. The teams are cross-functional and bring
    skills from development, testing, user experience, database, deployment, and project
    management. Each product might be split into smaller sets of services that communicate
    asynchronously with each other. Remember, the focus is not on a set of functionalities
    but rather on business capability.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: We start building our services around business capabilities. The service owns
    its business data and functionality. The service is the master of such data, and
    other services cannot own any of this service data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Classification into up/downstream services
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to break down the application systems is to categorize them by upstream
    and downstream data flow models. Core entities in the system comprise the upstream
    services. These upstream services than raise events that are subscribed by the
    downstream services to augment their functionality. This is aimed at decoupling
    the systems and help improve the overall business agility. This works well with
    Reactive, also known as event-driven, architecture concepts.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a simplified view of an e-commerce application, where the core
    entities are **CUSTOMER** and **PRODUCT**. The **ORDER** service depends on information
    about customers and products from the core entities. Next, we are building services
    that provide **RECOMMENDATION** and **PERSONALIZATION** services to the customer.
    The **RECOMMENDATION** and **PERSONALIZATION** services depend upon data from
    the core entities—**CUSTOMER**, **PRODUCT**, and **ORDER**. When there is a change
    to any of the core entities, changes are published. These changes are picked up
    by the **RECOMMENDATION** and **PERSONALIZATION** services, where they augment
    this data with additional attributes to provide relevant services. The **RECOMMENDATION**
    and **PERSONALIZATION** services downstream these services:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6188e3d5-a83d-41a7-a81e-9ae52fde7529.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: This model of classifying the business capabilities into **UPSTREAM** and **DOWNSTREAM**
    help define the dependency relationships between services and change the impact
    of any upstream services on the downstream services.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Business events
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the system evolves, the services will start aggregating into natural allies.
    This means finding out whether the services are depending on a similar set of
    data elements or providing overlapping/side-kick functionality, and can potentially
    be part of the same bounded context.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Services within the bounded context working within the same domain might need
    to rely on the master for accurate functioning. This might mean, some of the master
    service data attributes need to be made available to the associated bounded context
    services. For example, in our previous example, we talked of customer preferences.
    Now, these preferences might need to be mapped to the location (address) of the
    customer. In this case, should the customer preference call the customer address
    service every time to build the preferences or can it copy the relevant attributes
    to its own domain? Without duplication of data, the two services start getting
    coupled tightly, leading to a two-way communication model. To break this tight
    coupling, we allow the customer preferences service to cache or duplicate the
    relevant customer attributes using the events. This asynchronous model breaks
    the temporal tight coupling between the services. Whenever there is a change of
    customer address, the service publishes a business event for the requisite change.
    The change is subscribed by the customer preferences, which picks up the change
    to update its preferences model.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'This asynchronous model allows us to make sure:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Ownership of data is still clear. Any change to data is declared to the dependent
    services. The dependent services are allowed to hold or duplicate data, but not
    change the local copy unless the master copy is updated (golden source principle).
    The dependent services store only the subset of data that is required and functionally
    relevant (need-to-know principle).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据所有权仍然清晰。对数据的任何更改都会通知依赖服务。允许依赖服务保存或复制数据，但不更改本地副本，除非更新主副本（黄金源原则）。依赖服务仅存储所需和功能相关的数据子集（需要知道原则）。
- en: Asynchronous business events lead to low coupling between services. Core service
    changes result in an event. Events travel downstream to interested dependent services.
    The only dependency is the format of the business event published.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步业务事件导致服务之间的低耦合。核心服务的更改会导致事件。事件向下游传递给感兴趣的依赖服务。唯一的依赖是发布的业务事件的格式。
- en: Downstream services follow the eventual consistency principle; all business
    events are stored in a sequential manner to construct/state a later time (event
    sourcing/CQRS). Query models can be different from the system of record.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下游服务遵循最终一致性原则；所有业务事件都以顺序方式存储，以构建/状态一个较晚的时间（事件源/CQRS）。查询模型可以与记录系统不同。
- en: Asynchronous models of business events also promote choreography over orchestration,
    leading to loosely coupled systems/services.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务事件的异步模型也促进了编排而不是管弦乐，从而导致了松散耦合的系统/服务。
- en: At times, when teams start on a new product, an upfront definition of bounded
    context or services decomposition might not be possible. So, teams start building
    the application as a monolithic application by exposing its functionality as a
    set of services. As the team implements more stories, they can identify pieces
    of functionality that are changing at a fast pace (typically experience or channel
    services) versus slow changing pieces (typically core services or entity services).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当团队开始一个新产品时，可能无法事先定义界限上下文或服务分解。因此，团队开始构建应用程序作为一个单片应用程序，通过将其功能公开为一组服务。随着团队实施更多的故事，他们可以确定功能的部分，这些功能以快速的速度变化（通常是体验或渠道服务）与变化缓慢的部分（通常是核心服务或实体服务）。
- en: The team can start putting the services into two categories—experience and system
    services. System services can further be grouped together around entities and
    interrelations. Experience services are mapped to the customer journeys. Teams
    will typically have sprints just to clean/refactor the code to clear the technical
    debt that accumulates with every cycle.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 团队可以开始将服务分为两类——体验和系统服务。系统服务可以进一步围绕实体和相互关系进行分组。体验服务映射到客户旅程。团队通常会有冲刺来清理/重构代码，以清除每个周期积累的技术债务。
- en: So, the next question is, what identifies a service as a microservice?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，下一个问题是，什么标识一个服务为微服务？
- en: Microservice identification
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务识别
- en: 'The name microservice does not necessarily mean that the service has to be
    small in size. But it has the following characteristics:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的名称并不一定意味着服务必须体积小。但它具有以下特点：
- en: '**Single responsibility principle**: This is the core design principle of microservices.
    They should do one business unit of a task and do it completely. If there is low
    coupling, the services will be easier to modify and deploy or even replace altogether.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一责任原则：这是微服务的核心设计原则。它们应该完成一个业务任务单元并完全完成它。如果耦合度低，服务将更容易修改和部署，甚至完全替换。
- en: '**Granular**: Microservice granularity is contained within the intersection
    of a single functional domain, a single data domain and its immediate dependencies,
    a self-sufficient packaging, and a technology domain.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒度：微服务的粒度包含在单个功能域、单个数据域及其直接依赖、自包含的打包和技术域的交集中。
- en: '**Bounded**: A service should have access to resources within its bounded context,
    which is managed by the same team. However, it should not access resources of
    other modules, such as cache and databases, directly. If a service needs to access
    other modules it should do so through an internal API or service layer. This helps
    reduce coupling and promotes agility.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 界限：服务应该可以访问其界限上下文中由同一团队管理的资源。但是，它不应直接访问其他模块的资源，如缓存和数据库。如果服务需要访问其他模块，应通过内部API或服务层进行。这有助于减少耦合并促进敏捷性。
- en: '**Independent**: Each microservice is developed, tested, and deployed independently,
    in its own source. It can use third-party or shared libraries.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立：每个微服务都是独立开发、测试和部署的，在其自己的源中。它可以使用第三方或共享库。
- en: Differences between microservices and service-oriented architecture (SOA)
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务和服务导向架构（SOA）之间的区别
- en: 'Here are the differences between microservices and **service-oriented architecture**
    (**SOA**):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是微服务和服务导向架构（SOA）之间的区别：
- en: A service executes the entire business unit of work. For example, if a service
    requires customer or product data, it is preferable to store it within the service
    data stores. Typically, there is no need to go to a customer service for getting
    a customer record through ESB.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务执行整个业务工作单元。例如，如果一个服务需要客户或产品数据，最好将其存储在服务数据存储中。通常，不需要通过ESB获取客户记录。
- en: A service has its own private database or a database that is shared only in
    its bounded context and can store the information required to service the business
    unit of work.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务有自己的私有数据库或仅在其界限上下文中共享的数据库，并且可以存储为服务业务工作单元提供所需的信息。
- en: A service is a smart endpoint and typically exposes a REST interface with a
    contract definition in Swagger or similar repository. Some of the services that
    are consumed by other divisions or clients are exposed through an API platform.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务是一个智能端点，通常通过Swagger或类似的存储库中的合同定义公开REST接口。一些被其他部门或客户使用的服务通过API平台公开。
- en: Service granularity
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务粒度
- en: 'Here are the types of services:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是服务的类型：
- en: '**Atomic or system services**: These are the services that do a unit level
    of work and are enough to service the request by either referring to a database
    or a downstream source.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子或系统服务**：这些服务执行单元级别的工作，并且足以通过引用数据库或下游源来服务请求。'
- en: '**Composite or process services**: These services depend on the coordination
    between two or more atomic services. Typically, composite microservices are discouraged
    unless the business case already involves using existing atomic services. An example
    is a credit card payment from a savings account that calls two services, one to
    debit the savings account, and an other to credit the card account. Composite
    microservices also introduce inherent complexity such as state management and
    transactions that are difficult in a distributed scenario.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复合或过程服务**：这些服务依赖于两个或多个原子服务之间的协调。通常情况下，除非业务案例已经涉及使用现有的原子服务，否则不鼓励使用复合微服务。例如，从储蓄账户进行信用卡支付需要调用两个服务，一个是借记储蓄账户，另一个是贷记信用卡账户。复合微服务还引入了固有的复杂性，例如在分布式场景中难以处理的状态管理和事务。'
- en: '**Experience services**: These services are tied to the customer journey and
    are deployed at the edge of the infrastructure. These services handle requests
    from the mobile and web applications. These services are exposed through a reverse
    proxy using tools such as API gateways.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**体验服务**：这些服务与客户旅程相关，并部署在基础架构的边缘。这些服务处理来自移动和Web应用程序的请求。这些服务通过使用诸如API网关之类的工具，通过反向代理公开。'
- en: Microservice design guidelines
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务设计指南
- en: The whole notion of microservices is about the separation of concerns. This
    requires a logical and architectural separation between the services with different
    responsibilities. Here are a few guidelines to design the microservices.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 整个微服务的概念是关于关注点的分离。这需要在具有不同责任的服务之间进行逻辑和架构上的分离。以下是设计微服务的一些建议。
- en: 'These guidelines are in line with the 12-factor applications guidelines given
    by Heroku engineers:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指南符合Heroku工程师提出的12因素应用程序指南。
- en: '**Lightweight**: Microservices have to be lightweight in order to facilitate
    smaller memory footprints and faster startup times. This facilitates faster MTTR,
    and allows for services to be deployed on smaller runtime instances, hence horizontally
    scaling better. Compared to heavy runtime times, such as application servers,
    smaller runtimes such as Tomcat, Netty, Node.js, and Undertow are more suited.
    Also, the services should exchange data in lightweight text formats, such as JSON,
    or binary formats, such as Avro, Thrift, or Protocol Buffers.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻量级**：微服务必须轻量级，以便实现更小的内存占用和更快的启动时间。这有助于更快的MTTR，并允许服务部署在更小的运行时实例上，因此在水平方面更好地扩展。与重型运行时（如应用服务器）相比，更适合的是较小的运行时，如Tomcat、Netty、Node.js和Undertow。此外，服务应该使用轻量级文本格式（如JSON）或二进制格式（如Avro、Thrift或Protocol
    Buffers）交换数据。'
- en: '**Reactive**: This is applicable to services with highly concurrent loads or
    slightly longer response times. Typical server implementations block threads to
    execute imperative programming styles. As microservices could depend on other
    microservices or I/O resources such as a database, blocking threads could increase
    operating system overheads. The Reactive style operates on non-blocking I/O, uses
    call back handlers, and reacts to events. This does not block threads and as a
    result, increases the scalability and load handling characteristics of the microservices
    much better. Database drivers have started supporting reactive paradigms, for
    example, MongoDB Reactive Streams Java Driver.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式**：这适用于具有高并发负载或稍长的响应时间的服务。典型的服务器实现会阻塞线程以执行命令式编程风格。由于微服务可能依赖于其他微服务或I/O资源（如数据库），阻塞线程可能会增加操作系统的开销。响应式风格采用非阻塞I/O，使用回调处理程序，并对事件做出反应。这不会阻塞线程，因此可以更好地增加微服务的可伸缩性和负载处理特性。例如，数据库驱动程序已开始支持响应式范例，比如MongoDB响应式流Java驱动程序。'
- en: '**Stateless**: Stateless services scale better and start faster as there is
    no state to be stored on disk on shutdown or activated on start-up. They are also
    more resilient, as termination of a service will not result in a loss of data.
    Being stateless is also a step towards being lightweight. If a state is required,
    a service can delegate state storage to a high speed persistent (key value) store,
    or hold it in distributed caches.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：无状态服务具有更好的扩展性和更快的启动速度，因为在关闭或启动时不需要在磁盘上存储状态。它们也更具弹性，因为终止服务不会导致数据丢失。无状态也是朝着轻量级的一步。如果需要状态，服务可以将状态存储委托给高速持久（键值）存储，或者将其保存在分布式缓存中。'
- en: '**Atomic**: This is the core design principle of microservices. They should
    be easy to change, test, and deploy. All these can be achieved if the services
    are reasonably small and do the smallest business unit of work that can be done
    independently. If there is low coupling, the services will be easier to modify
    and independently deploy. Composite microservices may be required on a need basis
    but should be limited in design.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子性**：这是微服务的核心设计原则。如果服务足够小并且执行可以独立完成的最小业务单元，那么它们应该易于更改、测试和部署。如果耦合度低，服务将更容易修改和独立部署。可能需要根据需要使用复合微服务，但设计应该受到限制。'
- en: '**Externalized configuration**: Typical application properties and configurations
    were traditionally managed as configuration files. Given the multiple and large
    deployments of microservices, this practice will start getting cumbersome, as
    the scale of the services increase. Hence, it is better to externalize the configurations
    in the configuration server, so that it can be maintained in a hierarchical structure
    per environment. Features such as hot changes can also be easier to reflect many
    services at once.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部化配置**：传统上，典型的应用程序属性和配置是作为配置文件进行管理的。鉴于微服务的多个和大规模部署，随着服务规模的增加，这种做法将变得繁琐。因此，最好将配置外部化到配置服务器中，以便可以按环境在分层结构中进行维护。诸如热更改之类的功能也可以更容易地同时反映多个服务。'
- en: '**Consistent**: Services should be written in a consistent style as per the
    coding standards and naming convention guidelines. Common concerns such as serialization,
    REST, exception handling, logging, configuration, property access, metering, monitoring,
    provisioning, validations, and data access should be consistently done through
    reusable assets, annotations, and so on. It should be easier for another developer
    from the same team to understand the intent and operation of the service.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilient**: Services should handle exceptions arising from technical reasons
    (connectivity, runtime), and business reasons (invalid inputs) and not crash.
    They should use patterns such as timeouts and circuit breakers to ensure that
    the failures are handled carefully.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good citizens**: Report their usage statistics, number of times accessed,
    average response times, and so on through JMX API, and/or publish it through libraries
    to central monitoring infrastructures, log audit, error, and business events in
    the standards prescribed. Expose their condition through health check interfaces,
    for example, as done by Spring Actuator.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versioned**: Microservices may need to support multiple versions for different
    clients, till all clients migrate to higher versions. Hence the deployments and
    URL should support semantic versioning, that is, X.X.X.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, microservices will need to leverage additional capabilities that
    are typically built at an enterprise level such as:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic service registry**: Microservice registers itself with a service
    registry when up.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log aggregation**: The logs generated by a microservice can be aggregated
    for central analysis and troubleshooting. The log aggregation is a separate infrastructure
    and typically built as an async model. Products such as Splunk and ELK Stack in
    conjunction with event streams such as Kafka are used to build/deploy the log
    aggregation systems.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External configuration**: The microservice can get the parameters and properties
    from an external configuration such as Consul and Zookeeper to initialize and
    run.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Provisioning and auto-scaling**: The service is automatically started by
    a PaaS environment if it detects a need to start an additional instance based
    on incoming load, some services failing, or not responding in time.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API gateway**: A microservice interface can be exposed to the clients or
    other divisions through an API gateway that provides abstraction, security, throttling,
    and service aggregation.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cover all the service design guidelines in subsequent chapters as we start
    building and deploying the services.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Design and deployment patterns
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you start designing the applications, you need to be aware of the various
    service design and integration patterns.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The microservice design patterns can be categorized into multiple categories
    depending upon the problem being solved. The most common categories and the relevant
    patterns are discussed in the following sections.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Content aggregation patterns
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With microservices and bounded context, there is an additional responsibility
    of content aggregation. A client may need information that spans multiple domains
    or business areas (or in solution terms, the bounded contexts). The content required
    may not be available with one service. These patterns help identify and model
    the experience services category mostly. Hence there are various patterns for
    aggregation that can be applied.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation by client
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Aggregation at the last mile. This applies to web browsers or a reasonable
    *processing capable* user interface, which is showing content from various domains.
    This pattern is typically used in the home page that aggregates various subject
    areas. Also, it''s the pattern popularly used by Amazon:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b012f926-e78e-4ed4-852f-7da40ffff847.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: '**Benefits**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits of using the aggregation by the client pattern are as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Decoupled approach at the services layer. Easier for agility and maintainability
    at each individual service.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务层的解耦方法。更容易实现每个单独服务的灵活性和可维护性。
- en: Faster perceived performance at the UI layer, since the requests, can run in
    parallel to populate the various areas on the screen. More enhanced when there
    is a higher bandwidth available to fetch data in parallel.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在UI层面，感知性能更快，因为请求可以并行运行，以填充屏幕上的各个区域。当有更高的带宽可用于并行获取数据时，效果更好。
- en: '**Trade-offs**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**权衡**'
- en: 'The trade-offs associated with the aggregation by the client pattern are as
    follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 与客户端模式相关的权衡如下：
- en: Sophisticated user interface processing capabilities, such as Ajax and single-page
    application required
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要复杂的用户界面处理能力，如Ajax和单页面应用程序。
- en: The knowledge of aggregation is exposed at the UI layer, hence if the similar
    output was given as a dataset to a third-party, aggregation would be required
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合的知识暴露在UI层，因此，如果类似的输出被作为数据集提供给第三方，就需要进行聚合。
- en: API aggregation
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API聚合
- en: 'Aggregation at the gates. This applies to mobile or third-party use cases that
    do not want to know the details of the aggregation and instead would want to expect
    one data structure over a single request. The API gateways are designed to do
    this aggregation and then expose a unified service to the client. The API gateways
    can also select to eliminate any data sections in the aggregate service if it
    is not required to be shown during content aggregation:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在门上进行聚合。这适用于不想了解聚合细节的移动或第三方用例，而是希望在单个请求中期望一个数据结构。API网关被设计用于进行此聚合，然后向客户端公开统一的服务。如果在内容聚合期间不需要显示任何数据部分，API网关也可以选择消除这些数据部分：
- en: '![](img/6350e60c-8796-421c-854a-487e27090da7.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/6350e60c-8796-421c-854a-487e27090da7.jpg)
- en: '**Benefits**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**好处**'
- en: 'The benefits of using the API aggregation pattern are as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用API聚合模式的好处如下：
- en: The individual service details are abstracted from the client by the API gateway.
    Hence it gives the flexibility to change the services internally without affecting
    the client tier.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API网关将客户端与个别服务的细节抽象出来。因此，它可以在不影响客户端层的情况下灵活更改服务。
- en: Better in bandwidth constrained scenarios where running parallel HTTP requests
    may not be a good idea.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在带宽受限的情况下更好，不适合运行并行HTTP请求的情况。
- en: Better in UI processing constrained scenarios where processing power might not
    be enough for concurrent page generation.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在UI处理受限的情况下更好，处理能力可能不足以进行并发页面生成。
- en: '**Trade-offs**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**权衡**'
- en: 'The trade-offs associated with the API aggregation pattern are as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与API聚合模式相关的权衡如下：
- en: Where there is sufficient bandwidth, the latency of this option is higher than
    the aggregation by the client. This is because the API gateway waits for all the
    content to be aggregated before sending the data out to the client.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在有足够带宽的情况下，此选项的延迟高于客户端的聚合。这是因为API网关在发送数据给客户端之前需要等待所有内容被聚合。
- en: Microservice aggregation
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务聚合
- en: 'Aggregation at the business tier. In this approach, a microservice aggregates
    the responses from the various constituent microservices. This pattern is useful
    if there is any real-time business logic to be applied while aggregating data.
    For example, showing the total value of customer holdings across various businesses:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 业务层的聚合。在这种方法中，一个微服务聚合来自各个组成微服务的响应。如果在聚合数据时需要应用任何实时业务逻辑，这种模式非常有用。例如，显示跨各种业务的客户持有总价值：
- en: '![](img/2a298f28-adc3-4fa9-890d-e21915cb946c.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/2a298f28-adc3-4fa9-890d-e21915cb946c.jpg)
- en: '**Benefits**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**好处**'
- en: 'The benefits of using the microservice aggregation pattern are as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务聚合模式的好处如下：
- en: Finer control on the aggregation. Also, there is a possibility of incorporating
    the business logic based on aggregated data. Thus, offering richer content aggregation
    capabilities.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对聚合的更精细控制。此外，还有可能根据聚合数据应用业务逻辑。因此，提供了更丰富的内容聚合能力。
- en: Lower dependency on API gateway capabilities.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对API网关能力的依赖较低。
- en: '**Trade-offs**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**权衡**'
- en: 'The trade-offs associated with the microservice aggregation pattern are as
    follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与微服务聚合模式相关的权衡如下：
- en: Lower latency and more code, as there is an additional hop introduced due to
    an additional step.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于引入了额外的步骤，延迟更低，代码更多。
- en: More chances of failure or making mistakes. Parallel aggregation from microservices
    will need sophisticated code such as reactive or call back mechanisms.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失败或出错的机会更多。来自微服务的并行聚合将需要诸如响应式或回调机制等复杂的代码。
- en: Database aggregation
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库聚合
- en: 'Aggregation at the data tier. In this approach, data is pre-aggregated into
    an **operational data store** (**ODS**) typically a document database. This approach
    is useful for scenarios where there is additional business inference on the aggregated
    data that is difficult to compute in real time through a microservice, and hence
    can be pre-computed by an analytical engine:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 数据层的聚合。在这种方法中，数据被预先聚合到一个**运营数据存储**（**ODS**）中，通常是文档数据库。这种方法对于存在额外业务推断的情况非常有用，这些推断很难通过微服务实时计算，因此可以由分析引擎预先计算：
- en: '![](img/bf820d8a-153c-4fe8-b19b-349ca501f6e3.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/bf820d8a-153c-4fe8-b19b-349ca501f6e3.jpg)
- en: '**Benefits**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**好处**'
- en: 'The benefits of using the database aggregation pattern are as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据库聚合模式的好处如下：
- en: Additional enrichment of data by analytical jobs is possible. For example, in
    a customer 360° view, based on the customer portfolio aggregated in the ODS, additional
    analytics can be applied for **next-best-action** (**NBA**) scenarios.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过分析作业对数据进行额外丰富。例如，在基于ODS中聚合的客户投资组合的客户360°视图中，可以应用额外的分析来实现**下一步最佳行动**（**NBA**）场景。
- en: More flexible and capable as compared to the earlier approaches, and finer control
    on the data model can be exercised.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与早期方法相比更灵活和功能更强，对数据模型可以进行更精细的控制。
- en: '**Trade-offs**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**权衡**'
- en: 'The trade-offs associated with the database aggregation pattern are as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Higher complexity
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data duplication and more data storage requirements
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional ETL or **change data capture** (**CDC**) tools required to send the
    data from the system of a record to a central ODS store
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coordination patterns
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ideally, microservices should be capable of doing a business unit of work. However,
    in some business scenarios, microservices have to leverage other services as a
    dependency, or as a composition. For example, consider a credit card payment that
    first debits a savings account and then credits a card account. In this case,
    the two underlying services, such as debit and credit, could be exposed by the
    respective savings account and credit card domains and coordination is required
    between them.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Business process management (BPM)
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Complex coordination that involves long-running processes are better done by
    BPM. An enterprise might already have a BPM product. However, BPM might be overkill
    for simple two- or three-step coordination.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Composite services
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The guideline is to use composite services for low complexity (or simple) coordination
    that is high in volume. Such coordination can be referred to as microflows for
    the rest of the discussion.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Why composite services?
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In microservices architecture, the implementation of the service definition
    is done by smaller deployable units instead of large monolith applications that
    run in application servers. This makes the services easier to write, faster to
    change and test, and quicker to deploy. But this also creates a challenge for
    microflows that span two or more microservices, perhaps across multiple bounded
    contexts. In a monolith application, such microflows could be coordinated as a
    single transaction across two modules deployed in a single deployable unit. In
    microservices architecture, distributed transactions are discouraged and hence,
    microflows have to be solved using a composition approach.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Capabilities for microservices coordination
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section lists the capabilities that the composite services require:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '**State management**: Often the state manager component is required to manage
    the output state of the services that it is coordinating. This state will need
    to be held in a persistent store that is immune to **server-side state management**
    (**SSM**) failure. Another SSM instance should be able to retrieve the state and
    start where it left off.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transaction control**: Transaction boundaries are affected by microservices.
    Two separate function calls to two methods in a single transaction now become
    two separate service calls through a composite service. There are two approaches
    to handle this scenario.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distributed transactions**: These support the two-phase commit protocol.
    They are not scalable, increase latency and deadlocking scenarios, and need expensive
    products and infrastructure to support them. They may not be supported over selected
    protocols, such as REST or messaging. The benefit of this style is that the system
    is always in a consistent state.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compensating transactions**: Where the transaction control is functionally
    enforced by running functionally reverse transactions instead of trying to roll
    back to an earlier transaction. This is a more decoupled, and hence scalable,
    approach.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We would recommend compensating transactions over distributed transactions due
    to simplification in the technical product requirements.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '**Post service call coordination**: Atomic service calls can result in success,
    that is, when the constituent services have finished their work successfully;
    or a failure, when either of the coordination services has either not responded
    or failed in processing due to a technical or functional error. The composite
    service will need to get the response of the completed services and decide on
    the next step of action.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timeout handling**: Initiate a timer when starting a microflow. If the services
    do not respond in a particular time from starting the microflow, then raise an
    event to send to the event bus.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configurability**: Multiple instances of the SSM component will run to cater
    for various microflows. In each of the microflows, the service coordination, timer,
    and actions will differ. Hence, it is important to provide a framework that can
    have parameterized configuration of the timers, compensation transactions, and
    post-processing actions.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coordination models
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will discuss the following coordination styles of composite service micro
    flows.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous parallel
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A composite service initiates the service calls asynchronously to the constituent
    atomic services and then listens to the service response. If either services fails,
    it sends a compensating transaction to the other service.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'This is similar to the Scatter-Gather or Composed Message Processor patterns
    of the EIP:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0536935-ad8e-4c6e-81b2-f071cd6a3f31.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: Asynchronous sequential
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In pipeline processing, composite services send messages to atomic services
    sequentially. It waits for the previous service to return success before calling
    the next service. If anyone service fails, then the composite service sends the
    compensating transaction to previously successful services. This is similar to
    the Process Manager pattern in the EIP:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70b88b81-c1d8-4343-9436-a0291742dc0c.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: Orchestration using request/response
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the preceding section, but in request/response and sync fashion instead
    of async messaging.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3730ee35-9058-4174-931c-36a88e596599.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: Collapsing the microservices
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An option for when there seems to be a coupling between composite and its constituent
    microservice collapsing the services, and run as a single component. For example,
    transferring funds can be implemented by an account service, with an additional
    method `transferFunds` accepting `fromAcc`, `toAcc`, and the fund amount. It can
    then issue the `debit` and `credit` method calls as part of a single transaction.
    However, this approach needs to be decided after due consideration. The drawbacks
    include coupling deploying of debit and credit services of the credit card and
    savings domain:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb3a11c8-fbb0-4660-b108-c5e79c1cbfcc.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: Deployment patterns
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices attempt to solve monolith problems such as dependencies, and achieve
    agility by having separate deployable units. We can deploy the microservices on
    the target runtime in various styles. The options are described in the order of
    increasing isolation (good) and cost (bad).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Multiple services per WAR file
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although development might be in a microservice style (separate code base for
    services, different teams working on different services), the deployment essentially
    follows the monolith style:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f48fa51a-45b9-43f8-8dd5-9ce28884b1af.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: Benefits and trade-offs
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only benefit compared to a complete monolith style is that due to separate
    code bases and lesser dependencies, there is lower dependency on common code elements.
    However, it does not offer any runtime isolation between service behavior, and
    hence does not have the true benefits of a microservice architecture model such
    as independent releases, scaling individual services, or limiting the impact of
    one service problem on the other services.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Suitability
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are not many scenarios in which this is useful as it does not offer runtime
    isolation. However, it might be an intermediary step toward releasing the full
    separation.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Service per WAR/EAR
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This model separates the build process for the services to create separate
    `.war`/`.ear` files per service. However, they end up being deployed to the same
    web container or application server:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c52a556c-117e-49b5-9ab9-f38453782e33.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: Benefits and trade-offs
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This style takes the isolation a step further, by separating the build process
    for each service to create a deployable unit. However, since they are deployed
    on the same web container or application server, they share the same process.
    Hence, there is no runtime isolation between the services.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Suitability
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some teams might experience constraints on target deployment to use the same
    software or hardware that they were using in monolith style development. In this
    case, this deployment style is suitable, as the teams can still do independent
    development without getting under each other's feet, but will have to coordinate
    the releases with other teams during deployment to their traditional production
    infrastructure.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Service per process
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This style uses the concept of the fat JAR discussed earlier to include the
    application server or web container as part of the deployment unit. Thus, the
    target runtime environment only needs a JVM to run the service. Dropwizard and
    Spring Boot frameworks encourage this type of deployment build. We have also seen
    an example of creating such a deployment unit in [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application*:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8fe032a-2988-45d1-a845-256cfb2f8eba.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
- en: Benefits and trade-offs
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The benefits and trade-offs associated with the service per process style are
    as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: This approach helps in separating the runtime processes on which the services
    run. Thus, it creates an isolation between the services, so that a memory leak
    or fat exception in one process does not affect the other services to some extent.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This allows for selective scaling of service, by allowing more deployments of
    a service compared to other services on the existing hardware.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also gives the freedom to teams of using a different application server/web
    container based on specific use cases or the needs of the team.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, it cannot prevent any one service from hogging system resources (such
    as CPU, I/O, and memory) that can affect the performance of the other services.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also reduces the control over the runtime of the operations team, as there
    is no central web container or application server present in this model.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This style requires good governance to limit variability in the deployment estate
    and having substantial use cases to support the divergence.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suitability
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This style offers the best compromise for teams that are constrained to using
    their existing production infrastructure and do not have Docker containers or
    small VM configurations in place yet.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Service per Docker container
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this style, a service deploys as a fat JAR in a Docker container, which
    has the necessary prerequisites, such as JVM. It takes the isolation a step higher
    than that provided by the Linux container technology:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f1a6c81-2592-44fa-8dc1-e9c7150e9978.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: Benefits and trade-offs
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The benefits and trade-offs associated with the service per Docker container
    style are as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: The Linux container technology limits the CPU and memory consumption of the
    service in addition to providing networking and file access isolation. This level
    of isolation is sufficient for many services.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers are fast to start up from an image. Hence, new containers based on
    an application or service image can be spawned very quickly to address the fluctuating
    demands of the application.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers can be orchestrated through various orchestration mechanisms, such
    as Kubernetes, Swarm, and DC/OS so that the entire application configuration can
    be created automatically based on a well-defined application blueprint.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As in the previous style, it is possible to run a variety of service technologies
    within a container. For example, running Node.js services in addition to Java
    services is possible as the container image would be at OS level and hence can
    be started seamlessly by the orchestration framework.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers have much lower overheads compared to the virtual machines in terms
    of resource requirements, as they are more lightweight. Hence, they are cheaper
    compared to running each service in its own virtual machine.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, containers reuse the kernel of the host system. Hence, it is not possible
    to run workloads demanding different operating systems, for example, Windows or
    Solaris on container technology.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suitability
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This style of deployment is a good balance of isolation and cost. It is the
    recommended style and suitable for most service deployments.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Service per VM
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this style, the fat JAR is deployed directly on the VM, as in the *Service
    per process* section. However, here there is only one service deployed per VM.
    This ensures a complete isolation of the service from the other services.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'The deployment is automated through tools such as Chef and Puppet, that can
    take a base image (such as having Java installed) and then run through a series
    of steps to install the application JAR and other utilities on the VM:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/297b14b8-8750-453a-9710-d2145cab55a1.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
- en: Benefits and trade-offs
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The benefits and trade-offs associated with the service per VM style are as
    follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: If there are any use cases that require a complete OS level isolation, then
    this style is suitable
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This style also allows us to mix completely different workloads, such as Linux,
    Windows and Solaris, together on the VMs
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, this style is more resource-intensive and slower to start up as compared
    to the previous style, as VMs include a complete guest OS start-up
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a result, it is less cost efficient as compared to earlier options
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suitability
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This style of deployment is tilting toward the increased cost. It is the recommended
    style, and suitable for cloud image based deployments such as creating **Amazon
    Machine Images** (**AMI**).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Service per host
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This takes the isolation from the hypervisor (for VMs) to the hardware level
    by deploying the services on different physical hosts. The concept of microservers
    or specialized appliances can be used for this purpose.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and trade-offs
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The benefits and trade-offs associated with the service per host style are
    as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: The hardware (such as processors, memory, and I/O) can be exactly tuned to the
    use case of the service. Intel offers a range of microservers that are tuned for
    specific tasks such as graphics processing, web content serving, and so on.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A very high density of components can be achieved in this solution.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This style of deployment is for very few use cases that would benefit from hardware-level
    isolation or specialized hardware needs.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a maturing technology and hence not many data center cloud providers
    offer it yet. However, it will have matured by the time this book gets published.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suitability
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This style of deployment is extremely rare, as very few use cases require this
    high level of isolation or specialized hardware requirements. Appliances for web
    content or graphics processing are a few, specialized use cases that will benefit
    from this deployment style.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Release patterns
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following are the different release patterns used in services:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '**Fat JAR**: As discussed in [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application* the fat JAR helps to bundle the
    web container with the deployable. This ensures that there is no inconsistency
    between the versions of the deployment in the development, test, and production
    environment.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blue-green deployment**: This pattern suggests maintaining two production
    environments that are identical. A new release goes to one of the unused environments,
    say green. The switch is done from a router to send traffic to the green deployment.
    If successful, the green environment becomes the new production environment and
    the blue environment can be made inactive. If there is an issue, rollback is easier.
    The next cycle happens in reverse, with deployment to the blue environment, thus
    alternating between the two environments. There are a few challenges such as databases
    upgrades. For async microservices, this technique can be used to release one microservice
    or a set of microservices with different input queues. The configuration loaded
    from connection parameters decides to drop the request message in one queue versus
    the other.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Semantic versioning**: Semantic versioning is about releasing software with
    version numbers, the way they change the meaning of the underlying code, and what
    has been modified from one version to the next. Refer to [http://semver.org/](http://semver.org/)
    for more details. In async microservices, a similar strategy of using an input
    queue per microservice applies. However, in this case, both services are active,
    one for the legacy and one with the new changes. Based on the request, content-based
    routing pattern can be used to switch the queue to send the request.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Canary release**: This pattern is used to introduce a change to a small set
    of users using a routing logic that selects a group of customers for a new service.
    In terms of asynchronous services, this can be handled by two sets of input queues,
    and the redirection logic now decides the queue to drop the request message to.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immutable server / immutable delivery**: Immutable Server and Immutable Delivery
    are related. The intent is to automatically build the server, (VM or container)
    and its software and applications from the configuration management repository.
    Once built, it is not changed, not even when moving from one environment to other.
    Only the configuration parameters are injected via the environment, JNDI, or separate
    config servers, such as Consul or using Git. This ensures that there are no ad-hoc
    changes made to the production deployment that are not recorded in the version
    control system.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feature toggle**: This allows features released in production to be toggled
    on or off from some configuration settings. This toggle is typically implemented
    at the frontend or API gates so that it can be made visible or not visible to
    the end users of the service/feature. This pattern is very useful for a dark launch
    capability, which is discussed in the following sections.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dark launch**: Popularized by Facebook. Dark launch means releasing the service/capability
    into the production well before its scheduled release. This gives the opportunity
    to test out the integration points and complex services in production environments.
    Only frontend or API changes are done using a Canary release and feature toggle
    as discussed earlier.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data architecture for microservices
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key design philosophies of microservices is the bounded context and
    the service(s) managing the data store. Within a bounded context, multiple services
    might have access to a common data store, or adopt a per service data store paradigm.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Since there are potentially multiple instances of a service running, how do
    we make sure the data read/update operations do not lead to a deadlock in resources?
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Command Query Responsibility Segregation (CQRS)
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CQRS introduces an interesting paradigm challenging the conventional thought
    of using the same data store to create/update and also query the systems. The
    idea is to separate the commands that change the state of the system from the
    queries that are idempotent. The materialized view is an example of this pattern.
    The separation also gives the flexibility to use a different data model for updates
    and queries. For example, the relational model could be used for updates, but
    the events generated from the updates can be used to update caches or document
    databases that are more read-friendly.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'The user requests can be broadly classified into two parts, such as commands
    that change the state of the system, and queries that get the state of the system
    for user consumption. For the command processing, the system of engagement collects
    enough business data so that it can call the respective service on a system of
    record to execute the commands. For queries, the system of engagement can choose
    to either call the system of record, or get the information from a local store
    that is designed for read workloads. This separation of strategy can yield immense
    benefits, such as reducing the load on the system of record and reducing the latency:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c93f51b6-b83a-48e0-82f8-bc87cf924514.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: The CQRS pattern helps to leverage legacy systems of records in conjunction
    with the newer document databases, and caches as well. We will cover how to implement
    CQRS in your service in the next chapter.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Duplicating data
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within the bounded context, the services are the custodians of the data. But
    what if another service requires a subset of your data? Some of the questions/solutions
    that arise are as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Should I invoke the service to get that data?
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increased chattiness among the services
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tight coupling of two services
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can I access the data store directly from another bounded context?
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaks the bounded context model
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, how does another service (residing in another bounded context) get access
    to the subset of the data? (For example, requiring address attributes for a customer
    (from customer service) in the personalization services.)
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the best way is to duplicate data from the master domain. The
    required changes are published as events by the master domain, which are subscribed
    to by any domain interested in those changes. The events are picked up from the
    event bus, and data from the event is used to update the changes in the duplicate
    data store:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6bcb5d57-6147-4089-91aa-1730ea807be3.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
- en: Benefits
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The benefits of duplicating data are as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Helps decouple the service boundaries
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A business event containing the data is the only relationship between the services
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helps avoid expensive distributed transaction models across boundaries
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows us to make changes to our service boundaries without impeding progress
    of other parts of the system
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can decide how quickly or slowly we want to see the rest of the outside world
    and eventually become consistent
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to store the data in our own databases using the technology appropriate
    for our service model
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexibility to make changes to our schema/databases
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows us to become much more scalable, fault tolerant, and flexible
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cons
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The cons associated with duplicating data are as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Large volume of data changes might mean a more robust infrastructure at both
    ends and the ability to handle lost events requires event durability
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leads to an eventual consistency model
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complicated system and very difficult to debug
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fit for purpose
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bounded context model means the data encompassed can be modified only through
    the defined service interfaces or APIs. This means the actual schema or the storage
    technology used to store the data has no bearing on the API functionality. This
    opens us up to the possibility of using a fit for purpose data store. If we are
    building a search functionality and an in-memory data store is a better fit for
    the given business requirement, we can go ahead with it.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'Since, access to the data is governed by the service APIs, the choice and structure
    of the data store is immaterial to the actual service consumers:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d5744e3-2db6-470b-9e66-1f0c55d6aef7.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
- en: The service APIs model also provides the flexibility to move from one data store
    to another, without an impact on the other consuming services, as long as the
    service contracts are maintained. Martin Fowler has termed it, polyglot persistence.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: The role of security
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the proliferation of microservices, the challenges of managing security
    for these services becomes a challenge. Some of the questions that need to be
    answered, besides the **Open Web Application Security Project** (**OWASP**) top
    ten web vulnerabilities, are as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Does the service require the client to authenticate before service invocation
    (such as OAuth)?
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can a client call any service or only the service for which it is authorized?
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the service know the identity of the client from where the request originated
    and does it get passed down to the downstream services? Do the downstream services
    have a mechanism to verify the authorization of their invocation?
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the traffic between service to service invocation secured (HTTPS)?
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we verify that a request received from an authenticated user hasn't been
    tampered with?
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we detect and reject a replay of a request?
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the distributed microservice model, we need to control and limit the privileges
    the calling party has, and how much data is accessible (least privilege) on each
    call in case of a security breach. A large number of microservices and supporting
    databases means there is a large attack surface that need to be protected. Server
    hardening across the services becomes an important and key activity to secure
    the network. It is very important to monitor the service access and model the
    threats to break down the processes where we are most vulnerable and focus our
    effort there. We will see the role of API gateways in addressing some of the security
    concerns.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This brings us to the conclusion of the design principles for your cloud applications.
    In this chapter, you learned about the reasons for the popularity of the APIs,
    how to decouple your monolith application, and various categories of microservice
    patterns and data architecture principles for microservices design. We also saw
    the role of security in microservices and the role of API gateways.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take our example from [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application*, and start adding more meat to it
    to make it more production grade. We will add data access, options to do caching
    and their considerations, applying CQRS, and error handling.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
