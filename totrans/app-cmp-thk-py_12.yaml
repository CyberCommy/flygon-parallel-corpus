- en: '*Chapter 10*: Control Flow'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will take a deeper look at problems and identify the input
    and output necessary to design an algorithm for our problems. Throughout this
    chapter, you will learn how algorithms are read and the order in which instructions
    are carried out. You will also learn how to use functions and loops to manipulate
    the control flow in your algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining control flow and its tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using if, for, and range() and other control flow tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using loops and conditionals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revisiting functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, we will learn how control flow is defined, how we
    use the `if`, `for`, and `range()` functionalities when designing algorithms in
    computational thinking, and how to incorporate these functionalities into function
    definitions in our algorithms. Let's take a look at what control flow is first.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the latest version of Python to run the codes in this chapter.
    You will find the full source code used in this chapter here: [https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter10](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter10)'
  prefs: []
  type: TYPE_NORMAL
- en: Defining control flow and its tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Simply defined, **control flow** is the order in which an algorithm reads and
    executes instructions, functions, and statements. Control flow means the computer
    will make a decision. Think about it this way: when I go outside my building,
    I''ll either use an umbrella or I won''t use an umbrella. That depends on whether
    or not it is raining (and whether or not I remembered my umbrella, I guess). Depending
    on that condition, we make a decision. That process is the control flow process
    in algorithm design.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some of the control flow statements available in the Python
    programming language:'
  prefs: []
  type: TYPE_NORMAL
- en: '`while`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`range()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`break`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`continue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: list comprehensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pass` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `try` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These tools allow the algorithm to do things such as run so long as a certain
    condition or set of conditions is met, stop or break when a condition happens,
    continue for a range of values only, and so on. Let's take a closer look at some
    of these tools.
  prefs: []
  type: TYPE_NORMAL
- en: Using if, for, and range() and other control flow statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with `if` statements, which we first discussed in [*Chapter 4*](B15413_04_Final_SK_ePub.xhtml#_idTextAnchor071),
    *Understanding Logical Reasoning*. These are probably the most commonly used and
    known statements in algorithm design. You may recall learning about **conditional
    statements** in geometry as you studied reasoning and proofs. In those classes,
    you would write statements in *if-then* format. Take the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '*When it rains, I wear a raincoat.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not a conditional statement, at least not yet. If we were going to
    write it as a conditional sentence, then we''d have to have the *if-then* format,
    much like this sentence. Take a look at the converted statement that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*If it rains, then I wear a raincoat.*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we use conditions as part of our everyday lives. We just don't
    point them out.
  prefs: []
  type: TYPE_NORMAL
- en: When writing algorithms, we have to explicitly state what we need the algorithm
    to do, so we have to explicitly state these statements. In programming, we have
    to state each condition. Additionally, if we have a series of conditions that
    need to be met, we sometimes need to *nest* the statements. This is best explained
    with some examples. Let's start with how we use nested statements.
  prefs: []
  type: TYPE_NORMAL
- en: Using nested if statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even in our everyday lives, some conditions depend on others. For example, if
    it's Monday, we have to go to work. If we have to go to work and it's raining,
    we may need an umbrella. But if we're not going to work (and assuming we're staying
    home), we won't need to check whether we need an umbrella. That's the same with
    nested statements. We use them to check one condition, then another, which is
    nested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we are playing a dice game. You roll a die and get points as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 2, 4, or 6 = 10 points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 or 3 = 5 points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5 = 0 points and removes all previous points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each round, a player has to roll twice. Let''s look at a flowchart with the
    first roll shown, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Flowchart of first roll scores'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.1_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – Flowchart of first roll scores
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the flowchart, the score depends on the number rolled.
    Now, let''s say you had rolled a **1**. Then, let''s take a look at what your
    second roll could look like in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Flowchart of the second roll after rolling 1'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.2_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – Flowchart of the second roll after rolling 1
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we have three possible total points by the player. To translate
    this into an algorithm, we''ll need to do a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the roll.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine the score based on the number rolled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Roll again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine the final score based on the second roll.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s first define that roll. We''ll need to virtually roll the dice. That
    means that we''ll need the program to choose a number between `1` and `6`. Let''s
    take a look at how we code that. Keep in mind that this is just a snippet of the
    larger code contained in this file. We''ll use the second `ready` (`ready2`) in
    a subsequent snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: ch10_rollDice.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice in the preceding snippet that we had to import the `random` library
    for this particular algorithm. Importing it as `rand` instead of `random` allows
    us to truncate a bit of the code so that we type less. So, instead of `random.randint()`,
    we use `rand.randint()`. We need the `random` library because we want to have
    access to the *random integer function* so that the algorithm can choose a number
    between `1` and `6` (including both endpoints). Let''s take a look at the output
    as it stands now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice from the preceding output that the instructions were provided first,
    then once the player chose to roll by pressing the `r` key, the game chose a random
    integer and displayed it. It also displayed the current score after round `1`.
    Now, let''s take a look at the next part of the algorithm, which does the second
    roll. Notice that the indentations follow the previous code snippet. This snippet
    is contained in the previous larger file as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the new code, it shows the *first-round score*, both rolls, and
    a final score for the game. Remember, if we roll a `5` in the second round, we
    lose all our points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the program printed a few things for us. First, we rolled a
    `2` and a `6`, so we did not lose our points. Second, both `2` and `6` carry a
    score of `10` each, for a final score of `20`. But let's look back at the nested
    `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: To even begin the game, we had to verify whether the player was ready to roll.
    That first `if` statement is necessary to carry on to the rest of the decisions.
    *Could we have rolled without the go-ahead?* Yes. But think of all the games out
    there, including app versions of traditional board games. In those apps, the player
    always hits a button or the die to play. This is a similar scenario.
  prefs: []
  type: TYPE_NORMAL
- en: After we have said we are ready to roll, decisions have to be made about the
    points. We needed `if`, `elif`, and `else` statements again to loop through the
    various options. Now, let's take a look at when we can use `for` loops and `range`.
  prefs: []
  type: TYPE_NORMAL
- en: Using for loops and range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we need to discuss with `for` loops is that there can sometimes
    be some confusion over variables and `for` loop conditions. To see what I mean,
    let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: ch10_forLoop1.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet of code, `letter` isn''t a variable. It''s just telling
    Python that we want to iterate over each character in the word `mountain`. However,
    I could have called it anything. The program will do the exact same thing if I
    wrote it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In each case, using `letter`, or `pin`, or whatever word makes me happy at
    that moment, the output of the program looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, Python iterated through each letter in the word `mountain`
    and printed it to the console. This same thing can be done with numbers in a range.
    For example, if I wanted to print the numbers `1` through `10`, I could use a
    `for` loop, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ch10_forLoop2.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Wait, I said I wanted the numbers 1 through 10, so why is there an 11 in the
    range function?* That''s because the `range()` function always includes the minimum
    value in the range, but not the upper boundary. So, we need to add `1` to whatever
    our top number is. Let''s take a look at what the output for this program looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, each number is printed on a separate line. So, let''s look
    at what we can do if we just wanted to add those same numbers to a list instead.
    Instead of printing them one at a time, we could append them to a new list, then
    print out the list. This is really helpful for some kinds of algorithms and games.
    But before I get into those, let''s first look at how we append the numbers with
    just a few more lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: ch10_forLoop3.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, pay close attention to when you print the list. If you have it indented
    in correctly, it will print the list every single time you append a new number.
    But if your indentation is correct, you''ll only print the final list so that
    the output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we now have representations of the same information. In this
    case, we printed out the list of numbers. This is helpful if you're trying to
    append specific things to a list, even if it is with user input. We'll look at
    another list problem in the next section as we look at `while` loops, but before
    we move on, let's look at one more `for` loop problem and algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you wanted an algorithm that will print out the cubes of a range
    of numbers. There is one condition: the range will vary depending on user input.
    Let''s take a look at an algorithm that does this:'
  prefs: []
  type: TYPE_NORMAL
- en: ch10_forLoop4.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s note a few things from the preceding program:'
  prefs: []
  type: TYPE_NORMAL
- en: We converted the inputs into `int` types. We did this so that we can use the
    number in the mathematical expression inside the `for` loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have an empty list so we can append the cubes to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added `1` to `maxRange` because if not, the number would not be included
    in our result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a range based on two variables, which are the user input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a printed list of the values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is what that program looks like when we enter the `range(3, 6)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the program took the input provided, a minimum of `3` and a
    maximum of `6`, and created a list of the cubes of the numbers in that range.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that to get the exponents, we use the `**` symbol in Python. So, *2**2*
    is *4*, *3**4* is *81*, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the *control flow* is the order in which things are done. With `for`
    loops and `range`, we are asking the program to repeat things without having to
    enter each line separately, effectively manipulating the control flow to do things
    in loops rather than one line after another after another.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've looked at `for` loops and `range`, let's take a look at other
    ways we can iterate in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Using other loops and conditionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python offers a variety of ways to iterate through information in addition to
    the `for` loop. One of the commonly used loops is a `while` loop. When using a
    `while` loop, we're checking for a condition constantly. Again, it's easier to
    understand this by looking at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we were playing a game and ask the user to provide as many animals
    as they can. We''d want to be able to do a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether the player has animals to add.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If yes, append each animal to a list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If no, end the program and provide the final list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the final list and a count for how many animals the player was able
    to enter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s take a look at an algorithm that does the basics for this game:'
  prefs: []
  type: TYPE_NORMAL
- en: ch10_whileLoop1.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break this code down a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: We created an empty list, `myAnimals`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then asked the player whether they were ready.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the answer was yes, we asked for an animal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we checked whether they had more to add.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We checked how many items were added to the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We printed the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that we had to use a `while` loop and `if` statements. That's because
    we want to continue asking the player to add animals until they are done or can't
    think of any more to add. So, while the player can still add items, we want the
    program to keep asking the question. But if the player is done, then they can
    say no to adding another animal, therefore ending the program.
  prefs: []
  type: TYPE_NORMAL
- en: Now, I want to be clear, this program can be made a lot better. We could add
    a timer to see how many items can be entered in 30 seconds. We could also add
    a conditional that breaks the program and explains why it does so when the player
    tries to enter an animal instead of saying yes first. You could add a condition
    for when the player tries to enter an animal that's already on the list. *A challenge
    for you would be to try to add those components to the existing program!*
  prefs: []
  type: TYPE_NORMAL
- en: 'But let''s take a look at what this program looks like when we run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the way this program is written requires us to answer whether we
    want to add an animal each time. That's because the conditions will run if we
    answer `yes` for as long as we answer `yes`. But once we answer `no`, the program
    ends, giving us the list of animals and how many we were able to name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at another `while` loop. This time, we''ll check whether
    or not the condition is `True`. Take a look at the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: ch10_whileLoop2.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding algorithm, the control flow dictates that we get asked for
    a number between `0` and `9` repeatedly. The program will continue to ask until
    we make a mistake. That''s because it will continue to be `True` if I give it
    a number between `0` and `9`. Let''s look at a sample output for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the program kept asking the same question over and over again.
    This is unhelpful sometimes if the user doesn''t know how to break the cycle.
    We could potentially add a line to our statement so that it asks the question
    but provides a hint. Take a look at the edited code:'
  prefs: []
  type: TYPE_NORMAL
- en: ch10_whileLoop3.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are now telling the user that if they get tired of providing
    ranges, then they can opt out by providing an input outside of the range. While
    this example doesn't seem very useful, think of all the applications you could
    have. This type of algorithm can be used for card games, for example. You could
    also use something like this to check input against an existing list.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at functions again, but now combining some of our loops
    and adding some capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you recall from [*Chapter 8*](B15413_08_Final_SK_ePub.xhtml#_idTextAnchor114),
    *Introduction to Python*, we looked at built-in functions, but we also looked
    at how we can define our own functions. We are now going to talk about arguments
    in *functions* and *loops*, as we delve deeper into how *control flow* works in
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s think about problems that involve range. The range takes two arguments:
    a minimum and a maximum. However, in Python, I should note that you can just give
    one argument, which then assumes your minimum is `0`. For example, if I write
    `range(8)`, that''s the same as `range (0, 8)`. Take a look at what happens if
    you type `range(2)` in the Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Python range interpretation with one argument'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.3_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – Python range interpretation with one argument
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 10.3*, you can see that the program interpreted the code as `range(0,
    2)`. But let''s say you are always changing your range. Think of the range algorithm
    we wrote earlier. We are now going to rewrite it using a function. This function
    now has a `for` loop inside it as well:'
  prefs: []
  type: TYPE_NORMAL
- en: ch10_functions1.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we are calling the function based on user input. When this program
    runs, it calls the function based on that input. We will revisit that and run
    the program by calling multiple ranges within the algorithm in a second, but take
    a look at what the preceding snippet gives as the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we also adjusted the maximum number in the range in the `for` loop
    to include the top number provided. That's so that we get the full list of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take out the input completely. We are going to call the function
    multiple times using different ranges within the algorithm. Take a look at the
    updated snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: ch10_functions2.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The final three statements are where we call the function. Since we defined
    the function to take two arguments, it uses both the arguments to run the function.
    Because we called the function three times, we should see three lists as output.
    Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we printed each range on a separate line. That's one of the
    most useful things functions can do for us. If we were working with images, for
    example, which we can do with libraries, then we could create a shape, then define
    a function with loops that changes some parameters. With one function and a few
    loops, we can create multiple circles in different locations with different radiuses
    based on calling the function and using some loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions are also not limited to two arguments. We can have multiple arguments
    and define them within the functions. Let''s look at a function that uses three
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: ch10_functions3.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we''re calling the function with the values already given. *I
    love, and I mean love, Mexican food*. So, that menu would make me extremely happy!
    Here''s what that output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the function uses each argument in the `print` statements. The
    `%s` statements are used to let the program know where the values will be substituted.
    The `%()` statements let the program know which value to grab from the call function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the code if we wanted to get input from the user:'
  prefs: []
  type: TYPE_NORMAL
- en: ch10_functions4.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, our definitions and arguments are repeated. We use `input`
    statements to get information from the program user, then print out statements.
    Here''s what that looks like now in the Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – User input in function with three arguments'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.4_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – User input in function with three arguments
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the first three lines take the user input, then the last three
    lines incorporate the inputs into the function definition. Depending on what you
    are looking to create, this matters. If you are building an online menu for a
    store, for example, you would want user input, but you would also want to be able
    to confirm purchases. Same with online libraries if you wanted to confirm an e-book
    being lent out, and so on. We use **confirmation statements** often in algorithms.
    After looking at these, go check out some of your favorite websites and see where
    there are confirmation statements based on user input. You'll see that the use
    is widespread. Functions allow us to simplify that process.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, let's work with a few algorithms that provide the same information
    using our different loops and functions. Remember, we're looking at iterations
    because control flow means **order**. The iterations, functions, range, and more
    are ways in which we tell the program how it should respond to the instructions
    in the algorithm and when to repeat or move on from our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a function that prints the triple of the given user maximum
    input:'
  prefs: []
  type: TYPE_NORMAL
- en: ch10_functions5.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `while` loop and function definitions depend on the user input.
    The program will then print the triple of the value provided by the user, then
    reduce that number by one and find the triple of that number. Let''s take a look
    at what that means:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the program found the triple of `4`, which is `12`, then the
    triple of `3`, which is `9`, and so on. It stopped because we told it to run the
    loop while the number was greater than `0`. But recall that we can also just add
    those to a list, and we can use a `for` loop instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a similar program with a function, but a `for` loop rather
    than the `while` loop and using `range`:'
  prefs: []
  type: TYPE_NORMAL
- en: ch10_functions6.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice we defined some more things and added an empty list to the algorithm.
    While it has a few more lines of code, it does essentially the same thing as the
    previous code. Notice too that we started the range at `1`; otherwise, it would
    also include `0` in the list. Take a look at the output for this algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We have the same information but organized from least to greatest and in a list.
    From our algorithm, the order of things happening is important, of course. We
    first gathered the user input. The algorithm then defined the empty list, before
    defining a function. The function then used a `for` loop that uses the input to
    create a range and iterate over the range of numbers. Each iteration was then
    appended to the list. Finally, the algorithm printed the list.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are multiple ways to get to the same information. We just
    have to look at what works best for our scenarios, how to organize the information
    so that the program can read it, and write an algorithm that will organize the
    information in a way that can be read when running the program.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed control flow and order by looking at `for` loops,
    `range`, `while` loops, and functions. **Control flow** refers to the order a
    program reads an algorithm. Typically in Python, one line is read right after
    the other. In this chapter, we learned how you can control that order. Specifically,
    we learned that we could do so by iterating through data. Here are some important
    points to remember: `while` loops run so long as a condition is met, `for` loops
    iterate over a sequence (string, numerical, list, dictionary, set, or tuple),
    and `range` is used to create a sequence of numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: We also learned that we can combine these things when creating conditions, defining
    functions, and designing our algorithms. The most important thing to continue
    keeping in mind is that order matters, so we need to be careful about when we
    define necessary variables and how to write the algorithms so that they don't
    run infinitely or break before they should. Control flow is important so that
    our algorithms work without errors.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use the knowledge gained so far to complete the
    computational thinking process when solving challenges in multiple disciplines.
  prefs: []
  type: TYPE_NORMAL
