- en: Chapter 4. Identifying Range Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the process of creating machines to create
    our test lab architecture foundation. We will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building the machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting network connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing range components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will provide us with a solid foundation as we explore how to build
    environments to support the testing types that we have to perform.
  prefs: []
  type: TYPE_NORMAL
- en: Building the machines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have planned and prepared our testing work, it is time to look
    at the building of the machines. We briefly covered this in [Chapter 3](ch03.html
    "Chapter 3. Planning a Range"), *Planning a Range*, but now we will focus on building
    an environment for our pen testing lab. There are a number of ways to build a
    testing architecture, and we will build the labs in accordance with the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the machines](img/477-1_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The previous diagram shows an architecture that provides us with multiple layers
    of defense; using this as our reference point going forward will enable us to
    carry out a wide variety of testing techniques. Furthermore, we can add machines
    and connect to the virtual switches in the architecture in the order that we need
    for our testing. The diagram provides us with the capability to emulate virtually
    any environment that you may encounter in your pen testing travels.
  prefs: []
  type: TYPE_NORMAL
- en: Note the **Bastion Host**; this is the box that will function as our firewall
    of the architecture. We can install pretty much any software-based firewall and
    use it in the testing. An important point to note is that in most cases, the internal
    network will use **Network Address Translation** (**NAT**), and in a normal external
    testing scenario, we will not be able to route packets into the internal network.
    To do this, we would require client interaction, and this will be covered as we
    progress through the different techniques of pen testing. For now, we have the
    diagram and the information we need, so it is time to build it!
  prefs: []
  type: TYPE_NORMAL
- en: As we showed in [Chapter 3](ch03.html "Chapter 3. Planning a Range"), *Planning
    a Range*, there are a number of products we can use as our virtualization platform,
    and you are free to use any; consequently, the first stages of the lab setup may
    differ from what we show here in the book. It really does not matter which solution
    you use; once the machine is built, they all are pretty much the same when you
    boot them.
  prefs: []
  type: TYPE_NORMAL
- en: For our purpose, we will use the VMware Workstation tool. We have three choices
    with the tool when it comes to creating machines. We will discuss the three choices
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Building new machines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building new machines has been covered, and it provides us with the choice of
    booting from an ISO image as we did in [Chapter 3](ch03.html "Chapter 3. Planning
    a Range"), *Planning a Range*. Alternatively, it provides us with the choice of
    using the installation media, mounting it, and then working through the installation
    process in the same way as if you were installing the OS on a dedicated machine.
    Note the fact that the VMware Workstation tool provides us with an easy install
    wizard, and if it recognizes the OS that you are creating for the machine, then
    it will create, build, and install the OS for the most part unattended.
  prefs: []
  type: TYPE_NORMAL
- en: 'One word of caution: when you create the virtual machine, make sure that you
    create a machine with the version that you will need. That is, if you are using
    the latest version, which is 10 at the time of writing this book, when you create
    a machine, it will by default make it a Version 10\. If you move it to a platform
    that is prior to this version, the VM will not work. This has happened on more
    than one occasion, so ensure that you consider the environment your virtual machines
    may be used in when you are creating them.'
  prefs: []
  type: TYPE_NORMAL
- en: Conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is another option that we briefly covered in [Chapter 2](ch02.html "Chapter 2. Choosing
    the Virtual Environment"), *Choosing the Virtual Environment*. We looked at converting
    a physical machine to a virtual one, or P2V as it is referred to; consequently,
    there is nothing new to cover here.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning a virtual machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until now, we have not discussed the concept of cloning our virtual machines.
    This is a valuable method to use to build our environments. It is a little bit
    more involved than the next technique we will discuss, which is snapshot. With
    cloning, we have two choices; we can create a linked clone that will be linked
    to the original machine. By selecting a linked clone, we are assuming that there
    will be access to the original machine at all times because it is required to
    start the virtual machine. An advantage of a linked clone is that it takes less
    space for storage. The other option and the one that is more common is to create
    a full clone; this is a complete copy of the original machine in its current state.
    As it is completely independent, it requires more disk space for storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage and power of cloning is that once we have a machine built that
    we use for our testing labs, we just clone it and make changes to the configuration
    without having to build another one. We will do this now. Start the VMware Workstation,
    and once the program opens up open a virtual machine of your choice, you can use
    the one we created in [Chapter 3](ch03.html "Chapter 3. Planning a Range"), *Planning
    a Range*, or create a new one, and navigate to **VM** | **Manage**. This will
    bring up the menu, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cloning a virtual machine](img/477-1_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing the menu (the cropped text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Clone** in the window that comes up and then click on **Next**.
    In the **Clone Source** selection window, accept the default setting of the current
    state in the virtual machine and click on **Next**. This will bring up the window
    to select the clone type; select **Create a full clone** and click on **Next**,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cloning a virtual machine](img/477-1_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the next window, it is time to select a name for the clone and also a location
    to store it. This is another way to create the clone and then store it across
    a shared device or even to a removable drive. These are all options we might want
    to consider when creating our machine. Enter a name of your choice or accept the
    default name, and if you want to store the clone in another location, browse to
    it. Once you have entered the required information, click on **Finish**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If all goes well, your cloning operation should start once you click on **Finish**,
    and in a short amount of time, you should see the message that the cloning operation
    is **Done**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cloning a virtual machine](img/477-1_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's it! You now have a full clone of the virtual machine that will operate
    independently of the original. This is a powerful way to build our lab machines.
    It allows us to create as many machines as we need for our pen testing labs. Click
    on **Close** and your cloned virtual machine will open up in a new window. From
    this point, you can start the virtual machine or do anything you want just like
    with the original machine.
  prefs: []
  type: TYPE_NORMAL
- en: The last concept we want to talk about is snapshots. As cloning can create an
    entire machine, it is sometimes advantageous to just create a snapshot of a machine.
    A snapshot is exactly as it sounds; a snapshot of the machine at that point of
    time. We like to liberally use snapshots during development; this is in keeping
    with the concept in engineering that you always leave yourself a way back to the
    initial state. This is critical when it comes to building our machines. Before
    you write any new code, program, or anything that has a potential to cause a problem,
    ensure that you take a snapshot of the machine at its current state so that you
    can get back to a normal state if something goes wrong. This is a practice I wish
    the vendors would use with their software updates.
  prefs: []
  type: TYPE_NORMAL
- en: It is very frustrating to get a new patch, and when you install it, the message
    says that you cannot revert to the original state once the patch is installed!
    This violates all best practices of engineering and moreover, programming design!
    We always need to have a path back to the original. The process for snapshots
    is best explained with an example. One of the challenges we have when we build
    our own open sources tools is finding the right versions for all of the dependencies
    required for the software we are running. Therefore, it is imperative that we
    take snapshots before we install or update any software on a system. This will
    allow us to always return to our original state.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting network connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at the networking choices we have when it comes
    to building our environment. It is critical that we use the networking features
    of the VMware Workstation tool and take advantage of the capabilities it provides
    for us. Open your VMware Workstation software and open a virtual machine of your
    choice. When you do this, you will see a network adapter that is a part of the
    configuration. We will look at this later. Navigate to **Edit virtual machine
    settings** | **Network Adapter**. This will bring up the configuration window
    for the adapter, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting network connections](img/477-1_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, there are a number of settings that
    we can make on the network. What we want to do is to understand that each of these
    settings represents a switch, and when you create a network adapter with that
    setting, it is equivalent to connecting that machine to a switch. We will take
    a closer look at this once we discuss the different options and what they mean.
  prefs: []
  type: TYPE_NORMAL
- en: The bridged setting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we configure a network adapter to use the bridged setting, it connects
    the network adapter to the actual physical network. This is the same as connecting
    a separate machine to the network. VMware indicates this as the VMware VMnet0
    interface. This can be changed, but for the most part, we do not need to do this.
    There are also a number of other settings we can use, but they are beyond the
    scope and not required for what we are building. Unless you need to access your
    virtual environment from an external machine, bridged networking is not something
    we normally will configure.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the bridged setting is shown in the next diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The bridged setting](img/477-1_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The bridged setting provides us with the virtual machine that has its own place
    on the network; this means it does not share the network connection with the host.
  prefs: []
  type: TYPE_NORMAL
- en: Network Address Translation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the most part, NAT is the setting we will use the most. When we select
    the NAT setting, we share the host network card with the guest and do not have
    our own address but still have the capability to access the Internet. The switch
    that is reserved for NAT is VMnet8\. It is worth mentioning that when you create
    virtual machines, the default setting is NAT. As the NAT setting is a private
    network setup within the architecture, a DHCP server is provided to assign the
    addresses as required. An example of the NAT configuration is shown in the next
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Network Address Translation](img/477-1_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the NAT configuration, the host system has a virtual network adapter that
    is connected to the NAT network. This enables the host and virtual machines to
    communicate with each other. The process is when data is received for the VMnet8
    network, the external network identifies incoming data packets intended for each
    virtual network machine, and then it sends them to the correct destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'While in the normal configuration, the NAT machine is not accessible from the
    external network. However, it is possible to change this and set up port forwarding
    so that the external machine can initiate connections and send traffic into the
    machine that is connected to the NAT device. For our purpose, we prefer to leave
    the default settings for NAT and not configure the port forwarding as we prefer
    to not have external machines connecting to the internal machine because this
    is how the majority of networks that we test from an external location will be
    configured. Despite the fact that we are not using this capability, it might be
    something you want to experiment with. Building virtual testing labs is all about
    experimenting and finding what works for you. Therefore, to access the port forwarding
    configuration, open VMware Workstation and navigate to **Edit** | **Virtual Network
    Editor…** | **VMnet8** | **NAT Settings…** | **Add**. This will open the port
    forwarding settings window, and there are additional settings you can customize
    here, but for the most part, the defaults work well for our purpose. An example
    of the port forwarding options is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Network Address Translation](img/477-1_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One important thing to add here is the fact that with all switches you add in
    VMware, the IP address for the host will be `X.X.X.1` and the gateway will be
    `X.X.X.2`, and if you are using the DHCP server, the addresses will start at `X.X.X.100`.
    These are the default settings, but as with most things, you can modify this to
    meet the settings that you require for your environment.
  prefs: []
  type: TYPE_NORMAL
- en: The host-only switch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned in [Chapter 3](ch03.html "Chapter 3. Planning a Range"), *Planning
    a Range*, the host-only switch that is configured by default when you install
    the VMware Workstation is VMnet1\. The host-only connection means that the virtual
    machine cannot access the Internet. The switch is isolated for communication between
    the virtual machines and the host with no connection capability outside the host.
    In effect, we have an isolated network that is completely contained within the
    host. This is another great feature for us when we build our pen testing labs.
    With an isolated private network, we can force traffic to use the route that we
    want for our testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the host-only configuration, the network connection between the virtual
    machine and the host system is provided by a virtual network adapter that is visible
    on the host OS. As with the other switches provided by the VMware workstation,
    the switch has a DHCP server associated with it that provides IP addresses for
    the machines that are connected to the network. An example of the host-only network
    configuration is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The host-only switch](img/477-1_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A couple of caveats need to be mentioned here. We stated earlier that a host-only
    network is an isolated network. Well, like most things with virtualization, there
    are ways you can change this to have the isolated network not remain completely
    isolated. Again, for our purpose, this is not something we will explore, but we
    only wanted to briefly cover some of the methods of breaking or at least weakening
    the isolation. You can set up routing or a proxy to connect the network to the
    external net, and if you are using Windows Server 2003 or Windows XP, you can
    use the **Internet Connection Sharing** option to connect to an external network.
  prefs: []
  type: TYPE_NORMAL
- en: The custom settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we looked at the three switches that are included when you install the
    VMware Workstation software, and these provide us with the Bridged, NAT, and host-only
    configuration capabilities. However, building our network architecture as we have
    planned, having only these three switches limits us and does not provide us with
    what we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time to put everything all together and start building our layered architecture.
    As you may recall, the architecture we displayed some time ago was at a high-level
    black box view. We now have the knowledge to present the architecture in a complete
    form. An example of this is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The custom settings](img/477-1_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the preceding diagram shows, we now have our defined switches, and this
    is the power of customization. We can build and configure these switches to our
    specifications using the techniques we have previously covered. Going forward,
    we will define the following IP addressing scheme for the switches:'
  prefs: []
  type: TYPE_NORMAL
- en: 'VMnet8: 192.168.177.0/24'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'VMnet1: 10.1.0.0/24'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'VMnet2: 10.2.0.0/24'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'VMnet3: 10.3.0.0/24'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'VMnet4: 10.4.0.0/24'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These will be used throughout the book. You can use your own addressing schemes,
    but then the machines that are built within the book will be different from the
    ones you build. As you may have noticed, we do not have VMnet1 listed in the previous
    diagram, but we have an IP address assigned for it. This is because we want to
    have one switch dedicated for our testing. We will explain this in detail in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have covered how to customize the network switches previously, but to save
    you the trouble of having to go back and look this up; we will repeat the steps
    here for the VMnet1 switch. We configured the VMnet8 switch as part of [Chapter
    3](ch03.html "Chapter 3. Planning a Range"), *Planning a Range*. Open your VMware
    Workstation and navigate to **Edit** | **Virtual Network Editor…** | **VMnet1**.
    In the Subnet IP box, enter `10.1.0.0`. Leave the rest of the settings at their
    default. You can verify whether your settings match those shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The custom settings](img/477-1_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have verified your settings, click on **Apply** and then click on
    **OK**. Perform the same steps to configure the rest of the networks. For VMnet2
    and VMnet4, you will have to select the box to use the DHCP server; this is enabled
    by default with VMnet1, but not for the rest of the switches. Once you have completed
    configuring the networks, verify whether your settings match to those shown in
    the following screenshot before continuing to the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The custom settings](img/477-1_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing the settings (the cropped text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: We should now have our network switches and architecture set up for the layered
    environment we want to implement. We are going to configure at least two network
    cards on all machines we create, and this is done so that we can perform our first
    round of testing against a flat network. This is because if we cannot attack it
    when the network is flat and a directly connected, then there is no reason to
    layer the architecture and then try again. The concept of this is often overlooked,
    and the networks you see in the **Capture The Flag** (**CTF**) competitions are
    all flat. They may have multiple network cards so that you can perform pivoting
    (using the compromised machine to reach the next target), but they are flat, and
    this does not represent a true testing environment. Furthermore, they have the
    firewall disabled, or it is enabled but configured to allow the traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Putting all this together, we will have, on all machines, a network adapter
    that is connected to the switch in the architecture where the machine is located
    and a second adapter connected to the VMnet1 network. Consequently, this will
    allow us to test all machines across the VMnet1 switch, and once that test is
    complete and successful, we will then look at it from the true architecture point
    on the network. To prevent any packet leakage that is possible within a virtual
    environment, all testing after the first test will consist of disabling or removing
    the network adapter that is connected to the VMnet1 switch. So, it is time to
    start populating our architecture with machines by choosing components!
  prefs: []
  type: TYPE_NORMAL
- en: Choosing range components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we want to select the components we will use throughout our
    architecture. The main point is that we have a network design diagram, so now
    all we have to do is populate it. The first and one of the most important machines
    we want to place in the architecture is the machine we will use to carry out the
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: The attacker machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of choices when it comes to the machine we select as our
    attacker. This is usually based on what experience the tester has with different
    tools and more importantly, operating systems. It is common to build multiple
    attacker machines and customize them to work in different environments. You can
    always create and build your own machine, but in this book, we will use one of
    the most popular distributions and that is Kali Linux. Another thing that you
    may want to do is build a Backtrack 5R3 distribution machine. It is true that
    Kali Linux is the continuation of the Backtrack distribution, but there are tools
    in Backtrack 5R3 that are no longer in Kali, such as Gerix WiFi Cracker and Nessus.
    Again, this is largely a matter of personal preference. For the purpose of this
    book, we are going to focus on the Kali distribution as our choice of platform.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Planning a Range"), *Planning a Range*,
    we built a virtual machine using the Kali ISO image, and this can be used, but
    we prefer to actually use a virtual machine and not a live boot image for our
    main attacker machine. You can still keep the ISO image one we created in [Chapter
    3](ch03.html "Chapter 3. Planning a Range"), *Planning a Range*, but we want to
    get the actual distribution that is already in the VMware VMDK format. An advantage
    of this is that the VMware tools are already installed and this provides us with
    a better integration with the OS while it is in a virtual environment. To begin
    with, we need to download the virtual machine from the Kali site; you can download
    it at [http://www.kali.org/downloads/#](http://www.kali.org/downloads/#).
  prefs: []
  type: TYPE_NORMAL
- en: For those of you who want to build your own machine, there is a reference document
    located at [http://docs.kali.org/downloading/live-build-a-custom-kali-iso](http://docs.kali.org/downloading/live-build-a-custom-kali-iso)
    that can assist you with this task.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have downloaded the virtual machine, extract it to a location of your
    choice and then open it using VMware Workstation. Once you have opened it, the
    first thing we want to do is to add another network adapter because the virtual
    machine has one adapter that is connected to the NAT-VMnet8 interface, and this
    provides us with connectivity to the external points. However, we also want our
    machine to be connected to the VMnet1 switch so that we can directly test things
    before we add filters and layers of protections.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of our Kali configuration is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The attacker machine](img/477-1_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing an example of our Kali configuration (the cropped text is not
    important)
  prefs: []
  type: TYPE_NORMAL
- en: 'As the preceding screenshot shows, we now have two network cards in our Kali
    Linux machine: one connected to the VMnet8 NAT switch and the other connected
    to the VMnet1 Host-only switch. This provides us with direct access to these two
    networks without having to configure any additional settings. As we have mentioned,
    we will use the VMnet1 switch for testing, and once the testing is complete, we
    will place the target in the location required in the architecture and then carry
    out the test on this.'
  prefs: []
  type: TYPE_NORMAL
- en: We have mentioned it before, but it is worth repeating; you have to attack the
    target on a flat network and verify whether it works. Otherwise, putting a filter
    in place will just be a waste of time.
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at a simple example. In your Kali virtual machine in VMware
    Workstation, click on **Power on this virtual machine** to start the virtual machine.
    Once the machine is loaded, you will log in by clicking on **Other**. This will
    bring up the login page for the machine. Enter `root` as the username and `toor`
    as the password. Once the desktop comes up, navigate to **Applications** | **Accessories**
    | **Terminal** to open a terminal window. In the window, enter `ifconfig eth1`
    to view the IP address information for the interface that is connected to the
    switch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we do anything else, we will update the Kali distribution. A note of
    caution here: sometimes, the update will get errors, so before we perform the
    update, it is highly recommended that we take a snapshot of the machine. In VMware
    Workstation, navigate to **VM** | **Take snapshot**. In the window that opens,
    enter a name for your snapshot and click on **Take snapshot**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have discussed, in VMware, the host will be the first IP address of the
    subnet, so the host for us is **10.1.0.1**. Now, we will conduct a small experiment.
    We are going to use the popular tool, Nmap, and scan our host. We want to ensure
    that our firewall is disabled on the host. In the terminal window, enter `nmap
    -sS 10.1.0.1` and scan the host machine. When the scan is complete, you should
    see results similar to the ones shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The attacker machine](img/477-1_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the host has a number of ports that are open on it, but now we
    want to turn the firewall on. Once you have turned the firewall on, conduct the
    same scan again. As you will see, now that the firewall is on, the results are
    different. This is the thing that many who do testing do not understand; this
    is the Windows firewall and we used to consider it easy to penetrate, but as our
    little experiment has just shown that is no longer the case. If you search around
    the Internet and look for guidance on how to penetrate a firewall, you will read
    about fragmentation scans and a number of other methods. You are encouraged to
    try all of these different techniques on your own, rather than cover each one
    of them here; we will go to the creator of the tool Nmap, Fyodor. He has some
    advanced scanning references, and one of those is actually a book. So, as we look
    around, we find that to penetrate a firewall it is recommended to use a custom
    scan. As with anything you read about, the process is to create a lab environment
    and then test and verify for yourself. In your terminal window on Kali, enter
    `nmap -sS -PE -PP -PS80,443 -PA3389 -PU40125 -A -T4 10.1.0.1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will conduct a scan using a number of additional parameters that are reported
    to get through a firewall. We will not cover each one of these options here, but
    encourage you to read the man page and explore what each one of these options
    do. Additionally, you might want to run Wireshark and see what the scan is doing
    at the packet level. Once you have run the scan, was it successful? An example
    output of the scan is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The attacker machine](img/477-1_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, there really is not much information gathered
    from the scan. So, the claim that this can penetrate the firewall does not work,
    at least not against the Windows firewall. This is something that we, as testers,
    have to understand. If the environment is well configured and the firewall has
    strong rules for both ingress (inbound) and egress (outbound) traffic, it can
    present a formidable target. This is not a bad thing; in the end, we all want
    to improve the security posture for our clients. Unfortunately, from a security
    standpoint, there are always weaknesses in the majority of the architectures that
    we come up against. While this is bad for security, it is great for our testing!
  prefs: []
  type: TYPE_NORMAL
- en: Router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An example of a part of our architecture that we looked at earlier is shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Router](img/477-1_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous diagram shows, in our architecture, the first level of defense
    that we encounter is the router. There are a number of different devices we can
    encounter, and if we have the luxury of a lab environment that is not mobile,
    we can use actual physical devices. A source that I am sure many of you know about
    is the auction sites such as eBay that help to pick up used equipment at a reasonable
    rate. Another site that I have personally used many times to get used Cisco devices
    is [http://www.routermall.com](http://www.routermall.com). What I like about the
    site is that you will get cables and also the IOS software when you purchase equipment
    from them. As we have said before, we are more concerned with building a pen testing
    lab that we can carry on our laptop, so a physical router will not provide us
    with that capability. Therefore, we have to look at solutions that we can place
    into a machine and either emulate or perform the functions of a router for our
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: While it is true that we can make any machine into a routing device using the
    packet forward capability of the device, this is not the only thing we want to
    accomplish with our routing device. When you encounter a perimeter device in your
    testing, that device will more than likely have some form of filtering on it.
    Therefore, we want our chosen router component to have the capability to perform
    some form of filtering.
  prefs: []
  type: TYPE_NORMAL
- en: The one solution we want to share with you is the Cisco router emulation software,
    Dynamips, originally written by Christophe Follet in 2005 and maintained until
    2008\. The original Dynamips software is no longer maintained, but for our purpose,
    the last release will provide all of the functionalities that we will require.
    There is one requirement to use any of the Cisco emulators and that is you have
    to have a version of the Cisco IOS to access and boot. We will offer an alternative
    solution in the next section to those who do not have the capability to obtain
    a Cisco IOS image.
  prefs: []
  type: TYPE_NORMAL
- en: From this point forward, we will work with the **Dynamips** software and then
    the text-based frontend that is **Dynagen**. For those of you who want a GUI-based
    interface and also the latest version of Dynamips, you can go to [www.gns3.net](http://www.gns3.net)
    and get the required software there. Additionally, you can get numerous resources
    and documentation on the software, and not only does it provide for Cisco devices
    but also does for Juniper devices. It is an excellent reference to proceed with
    your development of labs to emulate a variety of devices. The software also has
    a Windows installer package and you can run the emulator within a Windows environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example that explains more details about the GNS3 tool is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Router](img/477-1_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enough discussion on this, let's build a router! We want to use Ubuntu as our
    router emulations software platform. You can go to the Ubuntu website and download
    the software from [http://www.ubuntu.com/download/desktop](http://www.ubuntu.com/download/desktop).
    The latest stable version at the time of writing this book is 12.04, and this
    is what we will be using for our router platform. There can be some challenges
    with the 64-bit version; for our purpose, both the 32-or 64-bit version will work.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have downloaded the ISO image, you will create a new machine in VMware
    Workstation and mount the ISO image. We covered the steps in [Chapter 3](ch03.html
    "Chapter 3. Planning a Range"), *Planning a Range*, so you should be familiar
    with them. If not, you can refer to the chapter for the exact sequence of steps.
    VMware Workstation will more than likely recognize the ISO image and offer to
    perform the easy installation. This is something that you can accept, or not,
    depending on personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: After you have created the machine and booted from the ISO image, you will work
    through the installation prompts and install the software into the hard drive
    of the virtual machine. For the most part, you can accept the defaults for the
    installation, but feel free to make changes as needed. Remember, this is one of
    the advantages of virtual environments. If we blow something up, we can create
    another one, or as we discussed, if we have taken a snapshot, we can restore to
    that. A great thing about Ubuntu is the ability to add packages once the installation
    has been completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the installation completes, the virtual machine, by default, will have
    one network adapter connected to the NAT switch, but as we have architected our
    design, we know that we need two interfaces on our router. This is to provide
    the connectivity as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Router](img/477-1_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To create our architecture with the Ubuntu machine, we have to add a network
    adapter and connect it to the VMnet2 switch. With VMware Workstation, you do not
    have to shut the virtual machine down to add a new adapter. In the software, navigate
    to **View** | **Console View** to bring up the configuration view for the virtual
    machine. Click on **Edit virtual machine settings** and add a network adapter
    and connect it to VMnet2\. An example of the required configuration is shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Router](img/477-1_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have the configuration set for our router machine, we need to get
    an IOS image and copy it into the machine. As we have mentioned, if you do not
    have access to an IOS image, you will not be able to use the Dynamips tool. In
    the next section, we will provide a solution that does not require access to an
    IOS image and provides the same functionality of filtering that we require.
  prefs: []
  type: TYPE_NORMAL
- en: The Dynamips software is available from the software repository for Ubuntu;
    in your Ubuntu machine, open a terminal window by clicking on the terminal icon
    on the menu bar on the left-hand side of the screen. If you do not see the terminal
    icon, you can click on **Ubuntu Software Center** and search for it.
  prefs: []
  type: TYPE_NORMAL
- en: In the terminal window, enter `sudo apt-get install dynamips`. This will fetch
    the Dynamips software and install it. Once we have installed it, we will then
    install the frontend application for the tool. Enter `sudo apt-get install dynagen`
    in the terminal window.
  prefs: []
  type: TYPE_NORMAL
- en: To stop having to type `sudo` for each command, enter `sudo –i`. The configuration
    files that we use to configure our router are copied to a rather long path, and
    we will fix this now. We will use the example configuration file, `simple1.net`.
    Enter `cp /usr/share/doc/dynagen/examples/sample_labs/simple1/simple1.net /opt/config.net`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the configuration file copied, let''s take a look at it. Enter
    `more /opt/config.net`. An example of the default configuration file is shown
    in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Router](img/477-1_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are two areas we will concentrate on for our configuration. In the section
    for the router image, we have to specify the path to the IOS image on the system.
    The second area is the router section. In the example, we are going to use the
    name `R1` for the router, and as you can see, the router R1 has one serial interface
    that is connected to the serial interface of R2\. This is a two-router sample
    configuration, and for our purpose, we do not need so many routers. You are welcome
    to explore different configurations, but in this book, we will concentrate on
    just having one router as this is our perimeter device we have identified in our
    design.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want our R1 router configuration to have two network interfaces; one will
    connect to the VMnet8 NAT switch and the other will connect to the VMnet2 switch.
    Consequently, we have two network cards on the Ubuntu machine that are configured
    in this manner, so it is just a matter of entering the configuration for the interfaces
    into the `config.net` file. We have to enter the configuration that will recognize
    the interfaces, this is what is known as a tap interface, and this is beyond the
    scope for us to discuss here; however, if you would like to find out more, refer
    to [http://www.innervoice.in/blogs/2013/12/08/tap-interfaces-linux-bridge](http://www.innervoice.in/blogs/2013/12/08/tap-interfaces-linux-bridge).
    Open your `config.net` file by entering `gedit /opt/config.net`. Change the path
    to the path of your IOS image file as required, and then in the R1 router section,
    enter the following in the place of the current serial interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`f0/0 = NIO_linux_eth:eth0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`f1/0 = NIO_linux_eth:eth1`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will connect the fast Ethernet interfaces to the interfaces of the Ubuntu
    machine. One other setting you may want to change is the RAM allocation. The default
    is at 160 MB, and this is a little low, so I recommend that you increase it to
    **320**. An example of what the configuration at this step should look like is
    shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Router](img/477-1_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is also a good idea to comment out the router R2 as we are not using it.
    We are now ready to test our configuration. In a terminal window, enter `dynamips
    –H 7200`. This will start the Dynamips server on port 7200\. If all goes well,
    you should see an output similar to that shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Router](img/477-1_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next step is to start our configuration file and that will interact with
    the Cisco IOS that we have loaded on the machine. The example IOS image we are
    using in the book is for a 7200 series router, so we can configure a number of
    interfaces on it. However, for our purpose, we need just the two fast Ethernet
    interfaces to perform our routing and more importantly, as we progress the filtering
    of traffic between the segments of our architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'In another terminal window, enter `dynagen /opt/config.net`. This will read
    the configuration file we have created and load the IOS image for access. Hopefully,
    you will not encounter any error here, but if you do, then it is time to troubleshoot.
    The most common error is a typo in the path. If it is a path error, you will see
    a message that says the image could not be found. An example of what you should
    see is shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Router](img/477-1_04_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, we are ready to start the router R1; you accomplish this by
    entering the the `console R1` command in the Dynagen prompt. This will log you
    in to the router as if you were connecting via a console cable. You should see
    another window open. This is the access to the router. Pressing the *Enter* key
    should bring you to a login prompt as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Router](img/477-1_04_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From here, it is a matter of using router commands to configure the two interfaces
    for our router; enter `en` at the router prompt to enter the privileged mode on
    the router. Once you are in the privileged mode, enter `show ip int brief` to
    bring up the interface configuration of the router. You will see that there is
    no interface configuration yet, so we have to configure it. An example of the
    output of the command is shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Router](img/477-1_04_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We now want to configure these interfaces (f0/0 and f1/0) as they are currently
    not set. We do this with the global configuration from the terminal option. To
    access this, enter `conf t` at the router command prompt. This will place you
    in the configuration mode. Enter `int f0/0` to access the interface configuration
    menu and enter the IP address `192.168.177.10 255.255.255.0`. This will create
    a configuration for the f0/0 interface that will connect to our VMnet8 NAT switch.
    To bring up the interface, enter the `no shut` command. Once we have done this,
    we will do the same thing for the next interface. In the prompt window, enter
    `int f1/0` to access the configuration menu for the f1/0 interface. Next, we have
    to configure the IP address that is connected to our VMnet2 switch, so enter the
    IP address `10.2.0.10 255.255.255.0`. In the interface configuration window, bring
    up the interface by entering `no shut`. We should now have the interface all configured.
    To return to the main router prompt, press *Ctrl* + *Z*. Verify your configuration
    by entering `show ip int brief`. Next, we will verify whether we have connectivity
    on the VMnet8 switch by entering `ping 192.168.177.1`. An example of the completed
    configuration is shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Router](img/477-1_04_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will not be able to verify the other switch until you connect something
    to the inside virtual switch. This is because the VMnet2 switch is not an adapter
    in your host machine unless you had selected that option while creating it. The
    next thing we will do is save our configuration; this is also one of the most
    important things'. To do this, enter `write mem`. For those of you reading this,
    you might know of an alternative method, and that is the `copy run start` command.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a complete Cisco 7200 router on an Ubuntu machine, and we can configure
    anything within the IOS that we want, such as IPsec and other things. For now,
    we will stop with the Dynamips tool and move on for those of you who want a solution
    without having to get a Cisco IOS image. In your dynagen prompt, enter `stop R1`
    to bring the router down.
  prefs: []
  type: TYPE_NORMAL
- en: 'For those of you who do not have access to a Cisco IOS image, we can accomplish
    what we need to for our architecture with pretty much any Linux or Unix machine
    that you want to use. As we have used the Ubuntu platform for the first example,
    we will use another one here. The intent is to have the filtering capability,
    and we can achieve this by using an OS that has the iptables software installed.
    We will use a Debain distribution to accomplish this task. You can download Debian
    from the official Debian site at [www.debian.org](http://www.debian.org). Once
    you have downloaded the image, you will need to create a virtual machine and run
    the installation process. After you have installed the OS, you will need to configure
    the network. One installed network adapter will be on the VMnet8 NAT switch and
    the second one will need to be connected to the VMnet2 switch. Once you have made
    the configuration changes, your settings should match those shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Router](img/477-1_04_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our configuration for the two virtual switches we have created provides us with
    a DHCP server to assign IP addresses, but as this is going to function as a router.
    It is better to set a static address for the interfaces as this will allow us
    to have more granular filtering rules when we create them. Moreover, we don't
    have to change settings each time we boot the machine as the addressing will not
    change like it does with DHCP.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Debian distribution uses a configuration file to set the parameters that
    you want the network card to have once you boot it. Using an editor of your choice,
    open `/etc/network/interfaces`; we want to configure our two network interfaces,
    eth0 and eth1\. An example of the completed configuration is shown in the next
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Router](img/477-1_04_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We could have configured the same addresses that we used in the Dynamips, but
    then if sometime in the future we want to run the Debian and Ubuntu machines at
    the same time, we would have an IP address conflict. Therefore, it is always a
    good design decision to plan for this possibility and configure unique addresses.
    We want to use the IP tables'' tools to execute our filtering, boot the Debian
    machine, and log in. To verify whether iptables is installed, in a terminal window,
    enter `iptables -h` to show the usage of the tool. An example of the output from
    this command is shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Router](img/477-1_04_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We now have successfully set up the Debian machine, and the next step is to
    configure the IP tables to support the filtering that we need. This is something
    we will do when we start testing the devices.
  prefs: []
  type: TYPE_NORMAL
- en: Firewall
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have configured and set a router, the next component in our architecture
    is a firewall. As with the router options, there are many options that we can
    choose. First, let''s take a look at our network architecture with respect to
    the firewall. This is shown in the next diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Firewall](img/477-1_04_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the previous diagram, we have three interfaces on our Bastion Host
    that serves as our firewall; this will require us to connect to three switches.
    The firewall we are going to use is the free version of the **Smoothwall** firewall.
    Again, an important point here is that the firewall you put into your architecture
    is sometimes determined by the contract you are planning for. Therefore, our intent
    here is to provide a firewall so that we can test a number of different configurations
    when we are practicing against different vulnerabilities that we have found during
    our research. You can download the ISO image for the Smoothwall firewall from
    [http://www.smoothwall.org/download/](http://www.smoothwall.org/download/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have downloaded the ISO image, create a virtual machine. We want this
    machine to have three interfaces to provide us with the connectivity that we require
    to meet our network design. An example of this configuration is shown in the next
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Firewall](img/477-1_04_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This machine requires three network cards, and each of these cards will be
    connected to the Bastion Host interfaces, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: VMnet2—eth0—Red
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VMnet3—eth1—Green
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VMnet4—eth2—Orange
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other thing we need to do is change the hard drive type. By default, the
    installer will make it a SCSI hard disk and this causes problems with the tool.
    So to avoid this, we will change the setting to IDE. Navigate to **Edit virtual
    machines settings** | **Hard Disk** | **Remove**. Once the hard disk has been
    removed, navigate to **Edit virtual machines settings** | **Hard Disk** | **Next**
    | **IDE** | **Next** | **Next** | **Finish**.
  prefs: []
  type: TYPE_NORMAL
- en: When you boot the machine, the installation package will start. Read the explanation
    of the different steps and accept the defaults for the installation process. Accept
    the default configuration of **half-open**. This setting will install the prudent
    approach to security, that is, nothing is allowed without explicitly defining
    it in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: In the **Network Configuration** type, we want to change the configuration to
    match the required switch design, that is, green, orange, and red. In the network
    configuration window, select **GREEN + ORANGE + RED** and then press *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You cannot use a mouse, so you will need to use the arrow keys and the *TAB*
    key to move around the menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify your connection settings as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Firewall](img/477-1_04_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next thing we need to set is the card assignments; when you select this,
    the network configuration we have created will be probed. So, each time a network
    card is detected, it will assign it to an interface. The order of the interfaces
    will be Red, Green, and then Orange. So we need to assign them in this order as
    it will match eth0, eth1, and eth2, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all the cards have been assigned, the next thing to do is set the IP addresses.
    The IP addresses will be configured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Red—DHCP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Green—10.4.0.10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orange—10.3.0.10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the network cards have been assigned, you will then be prompted to set
    two passwords: one for the remote access and the other for the root user. I recommend
    that you make them easy to remember as this is only for a testing environment.
    I usually use the name of the user followed by `pw`. So, for the root user, the
    password would be `rootpw`. You are free to set any password you like. After you
    have set the passwords, the system will reboot. Once it reboots, you will have
    to log in and verify that the three interfaces are set as we intended. Once you
    have logged in, verify that the interfaces are configured as shown in the next
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Firewall](img/477-1_04_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preferred method is to access the configuration from the green interface
    via a web browser. We can set up another machine on the VMnet4 switch, or another
    method is to use the host for our configuration. To have this capability, we have
    to connect the switch to the host. In VMware Workstation, navigate to **Edit**
    | **Virtual Network Editor** | **VMnet4** and select the **Connect a host virtual
    adapter to this network**. An example of the completed configuration is shown
    in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Firewall](img/477-1_04_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to open a browser of your choice and enter `https://10.4.0.10:441`;
    this will open the web login interface. Enter the username of the admin with a
    password that you configured during the installation. Once you have logged in,
    you will be in the main menu of the firewall. Navigate to **Networking** | **incoming**,
    and this will show the rules that are configured for inbound traffic. An example
    is shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Firewall](img/477-1_04_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The previous screenshot shows that, by default, Smoothwall does not allow any
    initiated traffic to come inbound; this is the way an architecture should start.
    Then, the process is to add the protocols that an organization wants to allow
    by policy. For our purpose, when we want to test something and place it in the
    orange interface, we will have to place a rule for that here. If we want to go
    to the internal network or the green interface, then it will not let you configure
    that unless you force it. This is because from the outside, no connections should
    be allowed to the inside. By using this platform, we now have a well-configured
    Bastion Host that is closed by default. The next thing we want to look at is the
    outgoing or egress traffic. Click on **outgoing** to bring up the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this default configuration is shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Firewall](img/477-1_04_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The default configuration allows any machines on the green interface to access
    any of the services that most network users would need. This is the power of a
    half-open installation; it allows us to bind all of the ports we need on the inside
    interface of the firewall and then have no ports open on the outside interface,
    with the exception of the ones we require to meet the needs of our security policy.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we will stop here as we have covered the main configuration of the
    firewall as a Bastion Host, and it is time to move on to another topic. You are
    encouraged to experiment with the firewall and test it as you feel necessary.
    One good way to test it is to bring up the hacking tool of your choice and set
    the target as the interface on the Bastion Host's red interface.
  prefs: []
  type: TYPE_NORMAL
- en: Web server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now have our architecture built, so it is time to add components to it for
    our testing. This again is something that will largely be dependent on the results
    from the testing methodology that we follow. That being said, we want to have
    a number of different web servers to test and practice against. In [Chapter 3](ch03.html
    "Chapter 3. Planning a Range"), *Planning a Range*, we downloaded and used the
    broken web application virtual machine from the OWASP group. So, we have an excellent
    web server there. Next, we will download another vulnerable web server to practice
    with. We want to download and use the virtual machine metasploitable that is provided
    for us from Rapid7\. You can download the virtual machine from the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.rapid7.com/metasploit](http://www.rapid7.com/metasploit)'
  prefs: []
  type: TYPE_NORMAL
- en: You will have to register to download the application. Once you have downloaded
    it, open the virtual machine and add a network adapter that is connected to the
    VMnet1 interface. As with most virtual machines, the network adapter is set at
    the VMnet8 interface by default, and we can use this for the direct testing. Any
    time we want to move the web server to another location of our architecture, we
    just change the switch to which the adapter is connected. Additionally, we could
    take a snapshot and have one for each location we want to test with the machine;
    furthermore, we could clone the machine and have clones around our architecture.
    It really does not matter how we do it. The intent is to have machines to test
    our skills and then place obstacles around or between us and the target and learn
    methods to get past them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the machine running, log in to the machine with a username of
    `msfadmin` and a password of `msfadmin`. Once you are logged in, note the IP address
    and open a browser and connect to the web server on the machine. An example of
    the home page of the machine is shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Web server](img/477-1_04_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the previous screenshot, the metasploitable virtual machine provides
    us with multiple testing sites; we have Mutillidae, Damn Vulnerable Web App, and
    many others. This will provide us with a multitude of techniques to test on the
    network.
  prefs: []
  type: TYPE_NORMAL
- en: For now, the metasploitable machine in combination with the virtual machine
    we downloaded will suffice for now. There are a number of components we still
    need to build into our network architecture, and we will address them in the later
    chapters throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have examined the planning and preparation required for
    us to be able to build the range. We looked at the process of creating machines
    and also a plan of placing machines on our network that allows us to emulate a
    number of different layered architectures.
  prefs: []
  type: TYPE_NORMAL
- en: We then began a discussion on the range components and we identified the need
    for a routing device at the perimeter that had the capability to perform filtering.
    Additionally, we explored the options for a Bastion Host machine that could run
    our software. We concluded this section with a discussion on how to create a web
    server. For this, we downloaded the metasploitable virtual machine. As we discussed
    in the chapter, we will add more components to our range, but for now, the components
    we have added are enough to move forward. In the next chapter, we will look at
    a number of the testing methodologies that are available for us to follow when
    we perform our professional testing.
  prefs: []
  type: TYPE_NORMAL
