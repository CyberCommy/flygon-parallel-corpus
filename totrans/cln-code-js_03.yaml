- en: The Tenets of Clean Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last chapter, we discussed the purpose that sits at the very beginning
    of a piece of code: solving a problem for a user. We discussed the difficulties
    of catering to both the machine and the human. We reminded ourselves that, at
    its core, writing code is about communicating intent.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will derive four core tenets from those foundations that
    are necessary to think about when creating software. These tenets are reliability,
    efficiency, maintainability, and usability. A good piece of software can be said
    to have all of these qualities. A bad piece of software can be said to have none
    of them. Crucially, however, these tenets are not rules. Instead, it is useful
    to see them as lenses through which you can look at your code. For each tenet,
    we will discover why it is important through a mix of analogies and JavaScript
    examples. You should come away from this chapter with an ability to apply these
    tenets to your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will be covering the following tenets:'
  prefs: []
  type: TYPE_NORMAL
- en: Reliability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficiency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintainability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reliability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reliability is the core underpinning of a good software system. Without reliability,
    the usefulness of technology quickly dissipates, leaving us in a position where
    we may have been better going without it. Technology's entire purpose can be undermined
    by unreliability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reliability, however, is not only a characteristic of large and complex software
    systems. Each and every line of code can be constructed to be either unreliable
    or reliable. But what do we mean by this? Reliability, the word, refers to the
    quality of being reliable. What does it mean to write code that people can rely
    on? It helps by defining reliability in terms of three distinct qualities: *Reliability
    is the quality of being correct, stable, and resilient*.'
  prefs: []
  type: TYPE_NORMAL
- en: Correctness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Code that is correct is code which conforms to a set of expectations and requirements.
    If I write a function to validate email addresses, then the expectation is that
    the function can be called with all types of email addresses and correctly establish
    their validity or invalidity as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To write correct code, we must first have an idea of what the requirements
    are. Requirements are our formalized expectations for how the code will behave.
    For the previous case of an email validation function, we might have the following
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The function will return `true` when a valid email address is passed as the
    first argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function will otherwise return `false`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first requirement is ambiguous though. We need to discern what it means
    for an email address to even be valid. Email addresses are a seemingly simple
    format; however, there are in fact many edge cases and oddly valid manifestations.
    For example, the following email addresses are technically valid according to
    the RFC 5322 specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '`admin@mailserver1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`example@s.example`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`john..doe@example.org`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To know whether our function should align fully with the RFC specification,
    we first need to understand its true use case. Is it a utility for email client
    software, or is it perhaps utilized in user registration for a social media website?
    In the latter case, we may want to establish the more exotic email addresses as
    invalid, similar to those listed previously. We may even want to ping the mail
    server at the domain to confirm its existence. The point is to discern what exact
    requirements will provide for us the meaning of *correct*.
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, composing your own email validation function is very ill-advised,
    as there are many edge cases that need to be taken into account. This highlights
    an important consideration in our quest for reliability; often, we can achieve
    the highest level of reliability by using existing *tried-and-tested* open source
    libraries and utilities. In [Chapter 17](0fe4d928-ff4f-4758-a54f-e8ee8dab6571.xhtml),
    *Other Peoples' Code*, we discuss the process of selecting third-party code in
    detail, and what to look out for.
  prefs: []
  type: TYPE_NORMAL
- en: The requirements we are coding should always derive directly from how our code
    will be used. It is vital to start with the user and their problem; from that,
    we can establish a set of clear requirements that can be independently tested.
    Testing our code is necessary so that we can confirm, to ourselves and our stakeholders,
    that our code fulfills all of the distinct requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the previous example of email address validation, a good set of tests
    would encompass many variations of email addresses, ensuring that all edge cases
    are fully accounted for. In [Chapter 13](58d1cced-ee45-4200-b01b-9c02a40f1195.xhtml), *The
    Landscape of Testing,* we discuss testing in far more detail. For now, however,
    it''s sufficient to simply reflect on the importance of correctness and the ways
    in which we can establish and confirm it:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the problem being solved and what users want
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refine your requirements until it's explicitly clear what's required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test your code to verify its correctness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Stability is a characteristic that we desire in all technology. Without stability,
    things get precarious; we become unsure of whether things will break at any moment.
    Stability is best exemplified by a common piece of real-world technology. Compare
    these two bridges:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c224e100-b1c7-471e-a03c-953e8872b160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Photos from Unsplash / by Zach Lezniewicz / by Jacalyn Beales]'
  prefs: []
  type: TYPE_NORMAL
- en: They both technically operate correctly as bridges. However, one has previously
    suffered damage and has been fixed with a simple plank of wood. Which bridge would
    you trust to safely convey a hundred people across? Probably the one on the right.
    It is firmly in place with guard rails, and, crucially, no gaps through which
    you can fall.
  prefs: []
  type: TYPE_NORMAL
- en: In code, we can say that stability is about *the continued correct behavior
    given different valid inputs and situations*. JavaScript in the browser is especially
    liable to failures in this way. It has to run in a multitude of conditions, on
    different hardware, operating systems, screen sizes, and often in browsers that
    have varying capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we write code that is strongly dependent on certain conditions, then it
    may be unwieldy and undependable when those conditions do not exist. If, for example,
    we were designing and implementing a layout for a web application, we may forget
    to consider and cater for screen sizes less than 1,024 pixels wide, resulting
    in the following mess:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/52ddaeae-50b9-42d0-868d-6b44f903c2ee.png)'
  prefs: []
  type: TYPE_IMG
- en: This is an example of instability. The web application cannot be depended upon
    to deliver its correct behavior when a certain environmental factor is different.
    A situation in which screen size is less than 1,024 pixels is entirely possible
    and reasonable in a world of increasing mobile device usage; it's an absolutely
    valid use case of our web application and failure to accommodate it has a negative
    effect on our user's ability to rely on it.
  prefs: []
  type: TYPE_NORMAL
- en: Stability is gained through having a full understanding of all the different
    valid inputs and situations that your code may be exposed to. Similar to correctness,
    stability is best confirmed with a set of tests that expose your code to the full
    gamut of inputs and situations.
  prefs: []
  type: TYPE_NORMAL
- en: Resilience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Resilience is about avoiding failure. Where stability mostly concerns itself
    with expected inputs, resilience concerns itself with what happens when your code
    is exposed to unexpected or nonroutine inputs. Resilience in software systems
    is also known as **fault tolerance** and is sometimes spoken about in terms of
    *redundancies* or *contingencies*. Fundamentally, these are all in service of
    the same goal—to minimize the effects of failure.
  prefs: []
  type: TYPE_NORMAL
- en: For critical systems, where lives depend on ongoing functionality, various contingencies
    are often built into the system. If a failure or fault arises, the system can
    isolate and tolerate that failure by utilizing its contingencies.
  prefs: []
  type: TYPE_NORMAL
- en: NASA, when building flight control systems for the Space Shuttle, built resilience
    into the system by having a set of synchronized redundant machines. If one failed,
    due to an unforeseen circumstance or a bug, then another would take over. Back
    on earth, we build contingency into our hospitals, with backup power generators
    that'll activate immediately if the electricity grid is down. Similarly, some
    urban transport networks benefit from contingencies in the form of *replacement*
    bus services in the case of trains not operating.
  prefs: []
  type: TYPE_NORMAL
- en: 'These large and complex systems may seem light years away from the world of
    JavaScript. But often, without realizing it, we are also routinely thinking about
    and implementing resilience into our code bases. One way we do this is via graceful
    degradation. When we write JavaScript for a browser environment, we have some
    key expectations:'
  prefs: []
  type: TYPE_NORMAL
- en: That the JavaScript will be correctly delivered via HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That the version of JavaScript is supported by the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That JavaScript is not blocked by an ad-blocker or another add-on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That the browser has not generally disabled JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any of these conditions do not hold up, then the user might be faced with
    an entirely unusable website or web application. The way to alleviate these concerns
    is to build with graceful degradation in mind. Graceful degradation involves aspects
    of your application *degrading* to a state in which they can still be used, remaining
    useful to the user even in the face of unexpected failures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Graceful degradation is often illustrated with a simple escalator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/65cae2e4-2180-4240-a7e2-5c4b54bdbb0c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Photo via Unsplash, taken by Teemu Laukkarinen]'
  prefs: []
  type: TYPE_NORMAL
- en: An escalator, when functioning correctly, will convey people via a set of moving
    metallic steps driven by a powerful gear system and motor. If the system fails
    for whatever reason, then the escalator remains static, acting as a regular flight
    of stairs. So, the escalators can be said to be resilient because, even when unexpected
    failures occur, they remain usable. Users can still convey themselves up and down
    the escalators, though, perhaps the journey will take longer.
  prefs: []
  type: TYPE_NORMAL
- en: 'When writing JavaScript, we can build resilience into our code by detecting
    features we are relying upon and only employing them if they are available. For
    example, I might wish to play MP3 audio to a user. To accomplish this, I will
    make use of the HTML5 Audio element. Before doing this, however, I will detect
    whether the browser supports MP3 audio. If it doesn''t, I can notify the user
    and point them toward a transcript of the audio instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses the HTMLMediaElement's `canPlayType` method to discern
    support. We've abstracted this into a `detectAudioMP3Support` function, which
    we then call to decide whether we'll go ahead and play the audio, or alternatively,
    display the transcript of the audio. Displaying the transcript of the audio is
    a form of graceful degradation as it still allows users to gain some utility from
    the audio without being able to play it.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that feature detection by itself is not graceful degradation.
    If I detected MP3 support but then silently failed if it wasn't available, then
    that would not achieve much. However, the activation of an alternative pathway
    for our users—in this case, enabling the reading of the transcript—is a perfect
    example of graceful degradation and resilience to failure.
  prefs: []
  type: TYPE_NORMAL
- en: There's something curious about building resilience into the software. By thinking
    about and accommodating potential unexpected failure states, we are, in effect,
    making those failure states expected. This makes our software more stable and
    more usable. Over time, what we once had to be resilient towards will now be an
    everyday part of our software's stability.
  prefs: []
  type: TYPE_NORMAL
- en: Resilience is a vital part of writing clean, reliable code. Fundamentally, we
    write code to solve problems for users. If our code can tolerate and accommodate
    edge-cases, unforeseen circumstances, and unexpected inputs, then it will fulfill
    this purpose more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We live in a world of scarcity. Resources are finite. In order to write the
    best possible code, we need to take this scarcity into account. So, when designing
    and implementing our ideas, we should be doing so with an eye toward efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll explore the different facets of efficiency and tie them
    into the world of JavaScript through examples. Hopefully, you will come away with
    an appreciation for how efficiency is not only about going fast but that it encompasses
    many indirect effects, spanning the gamut from economy to ecology.
  prefs: []
  type: TYPE_NORMAL
- en: Time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One key scarcity that we are always aware of is time. Time is a vital resource
    that we should seek to only spend with due consideration. In the world of programming,
    we should seek to optimize the amount of time, or CPU cycles, spent on any given
    task. This is to be accommodating to our end users, as they themselves have limited
    time, but also to be prudent with limited and expensive hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given almost any function in JavaScript, there are ways for it to be written
    more efficiently and less efficiently. Take, for example, this function, which
    removes duplicate strings within an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code is reliable, fulfills the requirements, and, for most intents and
    purposes, is perfectly fine. But it is doing needless work. On every iteration
    of the array, it is reiterating the entire array, from the current index to discover
    whether duplicate values exist ahead of where it is currently. This may seem a
    somewhat intuitive approach, but it is wasteful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of checking ahead of the entire input array, we can instead just check
    the existing output array for the specific value. If the output array already
    contains the value, then we know we don''t need to add it again. Here is our slightly
    optimized `if` condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There are other ways to optimize this, depending on how many unique values there
    are, and how large the input array is. We could, for example, store found values
    as keys in an object (a *HashMap* approach), which would, in some scenarios, decrease
    the lookup time.
  prefs: []
  type: TYPE_NORMAL
- en: Be wary of making micro-optimizations to your code. They may not always be worth
    the cost. Instead, first measure your code's performance, then work on the real
    performance bottlenecks that exist.
  prefs: []
  type: TYPE_NORMAL
- en: Spending too long on a task can end up having a significant effect on the user's
    ability to perform their tasks. Later in the chapter, we will discuss the tenet
    of usability, but, for now, it's just important to note that efficiency with time
    is not only important on principle; it's important because, at scale, these often
    tiny efforts of efficiency can have massively positive effects on usability.
  prefs: []
  type: TYPE_NORMAL
- en: Space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Space is a type of scarcity and is concerned with the size of things. Data shuttles
    across networks and into machines where it is stored ephemerally in RAM and possibly
    saved to permanent storage in the form of hard or solid-state-drives (HDDs, SSDs).
    As proponents of efficiency, we are interested in only using the space necessary
    to do a given task, and part of this is using the available space in the most
    efficient manner, and only moving data when it is prudent to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the high-level nature of the JavaScript language and the applications
    it usually builds, we rarely have to think about ephemeral RAM usage or permanent
    storage. However, JavaScript has gained significant ground as a legitimate language
    in performance-sensitive environments, such as database infrastructure and HTTP
    middleware, so these concerns are far more relevant nowadays.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the demands of client-side applications, both in the browser and
    within native environments, has drastically increased. The complexity of these
    applications means that we must always be on our toes, thinking about how to optimize
    memory and bandwidth usage on servers, user devices, and across increasingly layered
    networks. The bandwidth we absorb in a web application will have a direct effect
    on the time the user has to wait for the application to become usable.
  prefs: []
  type: TYPE_NORMAL
- en: Time to first render is a common metric that we are interested in when developing
    frontend of web applications. This can be optimized by being prudent with large
    resources and not blocking the initial load time with unnecessary resources.
  prefs: []
  type: TYPE_NORMAL
- en: '*Time* and *space* efficiency are inextricably linked with both directly affecting
    the other. The overarching theme of efficiency is about only doing what''s necessary,
    avoiding waste, and being thrifty with the resources you have available.'
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency's effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Efficiency in terms of space and time is responsible for many other effects,
    both in the software itself and in the wider world. No optimization exists in
    isolation. The savings made in one area will always have knock-on effects in other
    areas. And likewise, any needless costs will often create bottlenecks and issues
    further down the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are too many of these effects to list, but some of the most obvious ones
    in the world of software would include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The ecological effects of power consumption (for example, climate change)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cognitive burden of having to use slow software (for example, distraction and
    annoyance)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The battery life of the user's devices and therefore what tasks they choose
    to prioritize
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's essential to always consider the knock-on effects of the choices we make,
    whether those are made in the service of efficiency or some other requirement.
    None of what we create exists in a vacuum.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintainability is the ease with which appropriate changes can be made to your
    code. Unlike a motor vehicle, code does not typically need routine maintenance
    to avoid things such as rust, but it does, nonetheless, need to be fixed from
    time to time. Changes to its functionality are also often required, especially
    when under active development. Much of the code we work on is also being actively
    worked on by others. This shared ownership relies heavily on the tenet of maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Making code maintainable should not be a sidelined priority. It is as vital
    as any other requirement that the code is fulfilling. In the first chapter, we
    spoke a lot about the importance of considering who your users are. It would be
    disingenuous not to see that those who maintain and make changes to our code are
    also our users. They wish to wield what we have created to fulfill a purpose;
    therefore, they are our users. And, as such, we need to think about how we can
    best cater to their needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this next section, we''ll explore two aspects of maintainability: adaptability
    and familiarity.'
  prefs: []
  type: TYPE_NORMAL
- en: Adaptability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arguably, the best type of maintenance is that which does not need to occur.
    Adaptability refers to the ability of your code to cater to and adapt to different
    needs and environments. The code cannot be infinitely adaptive. The very nature
    of code is that it is made for a specific purpose; to solve a specific problem
    for the user. We can and should provide a level of configuration in our code,
    allowing for varying needs, but we cannot foresee all possibilities. Eventually,
    someone with new requirements may need to come along and make changes to the underlying
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to create a JavaScript component that displays a carousel of images
    (a slideshow), it''s obvious to imagine that users will want to configure the
    specific images displayed. We may, for example, also have a configuration option
    for enabling or disabling the *fade-in *or *fade-out* behavior of the carousel.
    Our complete set of configuration options may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(Array) images**: The image URLs you wish to display in the carousel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**(Boolean) fadeEffectEnabled**: Whether to fade between images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**(Number) imageTimeout**: The number of milliseconds a single image will display
    for'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**(Boolean) cycleEnabled**: Whether to keep repeating the slideshow'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These configuration options define the extent to which our component is adaptable.
    It can be used in a variety of different ways by wielding these options. If a
    user wants it to behave in a way that is not made possible by these options, then
    they may wish to change its behavior by modifying the underlying code.
  prefs: []
  type: TYPE_NORMAL
- en: 'When changes need to be made to the underlying code, it is important that they
    can be made with as little trouble as possible. Two harmful characteristics that
    might cause trouble are fragility and rigidity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fragility** is the characteristic of being brittle whenever changes are attempted.
    If one area of code is changed to make a bug fix or add a feature, and it affects
    several seemingly unrelated things in a different part of the code base, then
    we can say the code is *fragile*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rigidity** is the characteristic of failing to accommodate change easily.
    If one behavior needs to be changed, ideally, we should only have to make that
    change in one place. But if we have to rewrite code all over the place just to
    accomplish that one change, then we can say the code is *rigid*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fragility and rigidity are usually symptoms of larger code bases, where there
    are many interdependencies between modules. This is why we say that modularity
    is so important. Modularity refers to the separation of concerns into distinct
    areas of code in a way that reduces intertwining code paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various principles and design patterns we can use to accomplish modularity.
    These are discussed in [Chapter 4](98ac69ed-3848-4359-b9fb-1a9f8b8daed4.xhtml),
    *SOLID and Other Principles*, and, with more code examples, in [Chapter 11](9ef81929-c89f-4988-aa66-436c59f7f43f.xhtml), *Design
    Patterns*. Even at this early stage, it is useful to ask yourself: in what ways
    can I accomplish modularity?'
  prefs: []
  type: TYPE_NORMAL
- en: Working to avoid fragility and rigidity is a good goal and will make our code
    more accommodating to changes, but the most crucial aspect of a code base for
    a maintainer is its comprehensibility. That is, the extent to which it can be
    understood. Without understanding what, the maintainer cannot even begin to make
    changes. In fact, in obscure and confusing code bases, it is sometimes impossible
    to discern whether changes are even required. This is why we will now be exploring
    familiarity as an aspect of maintainability. By utilising familiar conventions
    and intuitive patterns, we can help to ensure a high level of understanding among
    our maintainers.
  prefs: []
  type: TYPE_NORMAL
- en: Familiarity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Familiarity is a lovely feeling. It's a feeling of comfort where you know what's
    happening because you've seen it before. This is the feeling we should hope to
    instill in all maintainers that may come across our code.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine for a moment that you are a skilled mechanic. You open the hood of an
    old car. You expect all of the various components to be visible in their respective
    places. You are adept at recognizing specific components, and, even without having
    to move things about, you can see how components are linked together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some minor modifications have been made; maybe the owner has previously installed
    a turbocharged engine or modified the gear ratios, but overall, you see that everything
    is more or less where it should be. For you, the mechanic, making changes is going
    to be nice and simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0de08cc1-5bc2-4569-b607-36614e7c11b8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Unsplash image (Public Domain) by Hosea Georgeson]'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, everything under the hood is in its expected and designated
    location. Even though cars vary in many ways, their underlying functionality is
    the same, and so it makes sense that the layout and design are familiar to the
    mechanic.
  prefs: []
  type: TYPE_NORMAL
- en: When we think about it, software is not so dissimilar. Most software we end
    up creating is similar to other software in many ways. Most web applications,
    for example, will have a way for users to register, to login, and change their
    name. Most software, regardless of the problem domain, will have the concept of
    **creation, read, update, and delete** (**CRUD)**. These make up the famous verbs
    of persistent storage. Most software can be thought of as fancy middleware sitting
    atop persistent storage. So, even though we may consider all software applications
    to be quite different, their fundamentals are usually very similar. It should,
    therefore, not be so difficult for us to write code that caters to the *mechanic
    who opens the hood*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the mechanic''s work as simple as possible, we need to focus foremost
    on the familiarity of our code. It''s not simple to do this because different
    things are familiar to different people, but, on the whole, we can take heed from
    the following guides:'
  prefs: []
  type: TYPE_NORMAL
- en: Don't stray too far from common design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be consistent with syntax and presentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lend clarity to unfamiliar problem domains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last point alludes to *unfamiliar problem domains*. This is something that
    you, as the programmer, will have to think about when it comes to each code base
    you work on. To discern if something can be considered unfamiliar, you can ask
    yourself: *Would another programmer working within another industry be able to
    understand this with little introduction?*
  prefs: []
  type: TYPE_NORMAL
- en: Usability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While maintainability is predominantly about catering to other programmers,
    usability is about catering to *all* users, whoever they may be. We can say that
    there are two broad groups of users that are engaged in our service:'
  prefs: []
  type: TYPE_NORMAL
- en: People wishing to wield the power of our code via interfaces (GUIs, APIs, and
    so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: People wishing to make changes to our code to accomplish new tasks or fix bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usability is about making our code, and the functions and interactions it enables,
    as useful and easy to use as possible for the full gamut of users. All code is
    written with at least one use case in mind, and so it is fair to judge code based
    on the extent to which it fulfills that purpose. Usability, however, goes further
    than this. Usability is not only about fulfillment of user requirements; it's
    about creating experiences that enable a user to achieve their goals with minimal
    hassle, time, and cognitive effort.
  prefs: []
  type: TYPE_NORMAL
- en: Usability is vital whether we are creating user interfaces on the web or deeply
    embedded server infrastructure that'll rarely see the light of day. In both cases,
    there are users we are providing for, and so we must care about usability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at this function''s signature and try to discern how you would
    go about using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is a real function signature from a code base I once worked on.
    It had no documentation and the code within it was spaghetti. It was used to calculate
    whether a given time could be considered a *new year* and would decide when a
    *Happy New Year* message would be shown to a user. It''s incredibly unclear how
    to use it though, or how it works. Some open questions I would have upon discovering
    this function might be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: What is *configuration* and what is available to configure in such a simple
    function?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presumably, SMH is *seconds, minutes, and hours*, but what kind of value is
    it expected to be? An object?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presumably, MDY is *months, days, and years*, but what kind of value is it expected
    to be? An object?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What year does the function compare the passed date for when discerning whether
    it is a *new year*?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Would any date in the ostensible *new year* work or only, for example, January
    1?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why are there *filter* and *formatter* arguments and what do they do? Are they
    optional?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does the function return? A Boolean? The *formatter* argument would suggest
    not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why can't I just pass a date object instead of individual date components?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function may do as required, but, as you can see, it's not very usable.
    It takes significant time and cognitive effort to figure out how it works. To
    figure it out fully, we'd have to study its usages in other parts of the code
    and try to decipher the spaghetti within. As a *user* of this function, I would
    personally find the entire process utterly painful.
  prefs: []
  type: TYPE_NORMAL
- en: Usability is, if anything, about avoiding this pain and burden. As programmers,
    we engage in the creation of abstractions to simplify complex tasks, but all the
    preceding code achieves is further complication of a simple problem.
  prefs: []
  type: TYPE_NORMAL
- en: User stories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Usability is the degree to which something is easy to use for a given purpose.
    Its purpose is defined by a well-understood model of a problem and a set of clear
    requirements. A useful technique for articulating these purposes is via *user
    stories*, made famous by Scrum and Agile methodologies. User stories typically
    take the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: As a {persona}, I want to {want}, so that {purpose}...
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of the types of user stories you''d expect if we were
    designing a *Contacts* application:'
  prefs: []
  type: TYPE_NORMAL
- en: As a **user**, I want to **add a new contact** so that **I can later recall
    that contact from my contacts list**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a **user**, I want to **delete a contact** so that **I will no longer see
    that contact in my contacts list**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a **user**, I want to **easily find a contact by their surname** so that
    **I can contact them**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User stories help to define the purposes that you are catering towards and help
    to focus the mind on the perspective of the user. Whether you're creating a five-line
    function or a ten-thousand-line system, it's always worth planning out your user
    stories.
  prefs: []
  type: TYPE_NORMAL
- en: Intuitive design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To design something intuitively is to design it so that users don't have to
    dedicate cognitive effort to figure out how something works. The idea at the core
    of intuitive design is that *it just works*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we write code, we are partaking in its design, its grand architecture,
    its functionality, and its line-by-line syntax. All of these are vital parts of
    that design. Using intuitive patterns of design is vital to crafting usable code.
    All users are attuned to a set of patterns that are employed on their level of
    abstraction. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**In a GUI**: Using an *X* button to indicate exiting a program or process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In code**: A function or method starting with *is* indicates a Boolean return
    value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In a GUI**: Using green for affirmative actions and red for negative actions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In code**: Upper-casing constants, for example, `VARIABLE_NAME`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In a GUI**: Using a floppy disk icon to indicate the concept of saving'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the assumptions and expectations that many users carry around with
    them as they navigate software. Tapping into these assumptions means that your
    code and the interactions it facilitates can be monumentally easier to use.
  prefs: []
  type: TYPE_NORMAL
- en: Accessibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Accessibility is a key principle within usability that states the importance
    of catering to all users, regardless of their abilities and circumstances. Usability
    tends to concern itself with the user as if they are a single entity. We usually
    make specific assumptions about the user, bestowing them with a set of characteristics
    and capabilities that may not be reflected in reality. Accessibility, however,
    is about the real users who will end up having to use whatever you''ve created.
    These real users are a diverse set of individuals and may have all manner of differences.
    When we talk about accessibility in software, we are usually concerned with types
    of differences that directly affect a person''s ability to make use of that software.
    These may include the follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning disorders or differences such as dyslexia.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical disabilities. For example, limited mobility of the hands or blindness.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developmental disorders such as Autism and ADHD.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less access to technology due to mobility, economy, or infrastructure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to these, there are many other differences that span the gamut of
    human existence, so we should always be ready to learn and adapt according to
    new needs and differences that we encounter among our users.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are engaged in the creation of web applications, both on the server and
    in the browser. As JavaScript programmers, we sit very close to the interfaces
    that are served to end users. Therefore, it''s vital that we have an excellent
    grasp of accessibility on the web. This includes an awareness of the **Web Content
    Accessibility Guidelines** (**WCAG 2.0**) published by the W3C, which include
    the following provisions:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide text alternatives for any non-text content (guideline 1.1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make all functionality available from a keyboard (guideline 2.1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make text content readable and understandable (guideline 3.1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessibility is not only about the non-programmer end user. As mentioned, we
    should consider other programmers to also be our *users* in the same sense as
    the *end users* of GUIs or other web interfaces. It is vital that we cater to
    other programmers. Some programmers are blind or partially sighted. Some programmers
    have learning or cognitive difficulties. Not all programmers work on the latest
    and fastest hardware. Neither do all programmers understand all the things you
    may take for granted. It's important to take all of these things into consideration
    in the code we write.
  prefs: []
  type: TYPE_NORMAL
- en: Having now finished this chapter, you may have a sense of feeling overwhelmed
    by the number of tenets, principles, and guidelines. Things may seem complex,
    but they aren't if we follow one simple rule—**always focus on the user**. Also,
    remember that other programmers who may work on your code *are* your users as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'As programmers, we sit in a position where we wield unprecedented power in
    helping to define the behaviors that people conduct in the execution of all manner
    of tasks. The original programmers who worked at Twitter, Google, or Microsoft
    likely did not foresee the number of times their code would run. They probably
    couldn''t have originally imagined how many humans their code would end up affecting.
    We should always remain humble to this power and try in earnest to be accountable
    to all of the users we serve, and all the myriad tasks they seek to carry out.
    If you were to come away with one thing from this chapter, I hope it would be
    simply this: a humble and continued consideration of the user, in every line of
    code you write.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've explored the vital tenets of reliability, efficiency,
    maintainability, and usability. Using these tenets as lenses through which we
    can look at our code bases ensures that we will be far more likely to write cleaner
    code. One of the most important things we've learned in this chapter is always
    to consider the human in the code we write. The user may be a human sitting on
    the other side of a GUI or a fellow programmer making use of our APIs. Either
    way, being constantly aware of this human is vital.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll continue the theme of studying the underlying characteristics
    of clean code by looking at the enemies to be aware of, such as cargo-cult programming
    and ego.
  prefs: []
  type: TYPE_NORMAL
