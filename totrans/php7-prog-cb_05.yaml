- en: Chapter 5. Interacting with a Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using PDO to connect to a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an OOP SQL query builder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling pagination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining entities to match database tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tying entity classes to RDBMS queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding secondary lookups into query results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing jQuery DataTables PHP lookups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover a series of database connectivity recipes that
    take advantage of the **PHP Data Objects** (**PDO**) extension. Common programming
    problems such as **Structured Query Language** (**SQL**) generation, pagination,
    and tying objects to database tables, will be addressed. Finally, at the end,
    we will present code that processes secondary lookups in the form of embedded
    anonymous functions, and using jQuery DataTables to make AJAX requests.
  prefs: []
  type: TYPE_NORMAL
- en: Using PDO to connect to a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**PDO** is a highly performant and actively maintained database extension that
    has a unique advantage over vendor-specific extensions. It has a common **Application
    Programming Interface** (**API**) that is compatible with almost a dozen different
    **Relational Database Management Systems** (**RDBMS**). Learning how to use this
    extension will save you hours of time trying to master the command subsets of
    the equivalent individual vendor-specific database extensions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'PDO is subdivided into four main classes, as summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Functionality |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `PDO` | Maintains the actual connection to the database, and also handles
    low-level functionality such as transaction support |'
  prefs: []
  type: TYPE_TB
- en: '| `PDOStatement` | Processes results |'
  prefs: []
  type: TYPE_TB
- en: '| `PDOException` | Database-specific exceptions |'
  prefs: []
  type: TYPE_TB
- en: '| `PDODriver` | Communicates with the actual vendor-specific database |'
  prefs: []
  type: TYPE_TB
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Set up the database connection by creating a `PDO` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You need to construct a **Data Source Name** (**DSN**). The information contained
    in the DSN varies according to the database driver used. As an example, here is
    a DSN used to connect to a **MySQL** database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, **SQlite**, a simpler extension, only requires the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**PostgreSQL**, on the other hand, includes the username and password directly
    in the DSN:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The DSN could also include server-specific directives, such as `unix_socket`,
    as shown in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best practice**'
  prefs: []
  type: TYPE_NORMAL
- en: Wrap the statement that creates the PDO instance in a `try {} catch {}` block.
    Catch a `PDOException` for database-specific information in case of failure. Catch
    `Throwable` for errors or any other exceptions. Set the PDO error mode to `PDO::ERRMODE_EXCEPTION`
    for best results. See step 8 for more details about error modes.
  prefs: []
  type: TYPE_NORMAL
- en: In PHP 5, if the PDO object cannot be constructed (for example, when invalid
    parameters are used), the instance is assigned a value of `NULL`. In PHP 7, an
    `Exception` is thrown. If you wrap the construction of the PDO object in a `try
    {} catch {}` block, and the `PDO::ATTR_ERRMODE` is set to `PDO::ERRMODE_EXCEPTION`,
    you can catch and log such errors without having to test for `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Send an SQL command using `PDO::query()`. A `PDOStatement` instance is returned,
    against which you can fetch results. In this example, we are looking for the first
    20 customers sorted by ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PDO also provides a convenience method, `PDO::exec()`, which does not return
    a result iteration, just the number of rows affected. This method is best used
    for administrative operations such as `ALTER TABLE`, `DROP TABLE`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterate through the `PDOStatement` instance to process results. Set the **fetch
    mode** to either `PDO::FETCH_NUM` or `PDO::FETCH_ASSOC` to return results in the
    form of a numeric or associative array. In this example we use a `while()` loop
    to process results. When the last result has been fetched, the result is a boolean
    `FALSE`, ending the loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PDO fetch operations involve a **cursor** that defines the direction (that is,
    forward or reverse) of the iteration. The second argument to `PDOStatement::fetch()`
    can be any of the `PDO::FETCH_ORI_*` constants. Cursor orientations include prior,
    first, last, absolute, and relative. The default cursor orientation is `PDO::FETCH_ORI_NEXT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the fetch mode to `PDO::FETCH_OBJ` to return results as a `stdClass` instance.
    Here you will note that the `while()` loop takes advantage of the fetch mode,
    `PDO::FETCH_OBJ`. Notice that the `printf()` statement refers to object properties,
    in contrast with the preceding example, which references array elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to create an instance of a specific class while processing a query,
    set the fetch mode to `PDO::FETCH_CLASS`. You must also have the class definition
    available, and `PDO::query()` should set the class name. As you can see in the
    following code snippet, we have defined a class called `Customer`, with public
    properties `$id`, `$name`, and `$level`. Properties need to be `public` for the
    fetch injection to work properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When fetching objects, a simpler alternative to the technique shown in step
    5 is to use `PDOStatement::fetchObject()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also use `PDO::FETCH_INTO`, which is essentially the same as `PDO::FETCH_CLASS`,
    but you need an active object instance instead of a class reference. Each iteration
    through the loop re-populates the same object instance with the current information
    set. This example assumes the same class `Customer` as in step 5, with the same
    database parameters and PDO connections as defined in step 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you do not specify an error mode, the default PDO error mode is `PDO::ERRMODE_SILENT`.
    You can set the error mode using the `PDO::ATTR_ERRMODE` key, and either the `PDO::ERRMODE_WARNING`
    or the `PDO::ERRMODE_EXCEPTION` value. The error mode can be specified as the
    fourth argument to the PDO constructor in the form of an associative array. Alternatively,
    you can use `PDO::setAttribute()` on an existing instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us assume you have the following DSN and SQL (before you start thinking
    that this is a new form of SQL, please be assured: this SQL statement will not
    work!):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you then formulate your PDO connection using the default error mode, the
    only clue that something is wrong is that instead of producing a `PDOStatement`
    instance, the `PDO::query()` will return a boolean `FALSE`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The next example shows setting the error mode to `WARNING` using the constructor
    approach:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you need full separation of the prepare and execute phases, use `PDO::prepare()`
    and `PDOStatement::execute()` instead. The statement is then sent to the database
    server to be pre-compiled. You can then execute the statement as many times as
    is warranted, most likely in a loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first argument to `PDO::prepare()` can be an SQL statement with placeholders
    in place of actual values. An array of values can then be supplied to `PDOStatement::execute()`.
    PDO automatically provides database quoting, which helps safeguard against **SQL
    Injection**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best practice**'
  prefs: []
  type: TYPE_NORMAL
- en: Any application in which external input (that is, from a form posting) is combined
    with an SQL statement is subject to an SQL injection attack. All external input
    must first be properly filtered, validated, and otherwise sanitized. Do not put
    external input directly into the SQL statement. Instead, use placeholders, and
    provide the actual (sanitized) values during the execution phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'To iterate through the results in reverse, you can change the orientation of
    the **scrollable cursor**. Alternatively, and probably more easily, just reverse
    the `ORDER BY` from `ASC` to `DESC`. This line of code sets up a `PDOStatement`
    object requesting a scrollable cursor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You also need to specify cursor instructions during the fetch operation. This
    example gets the last row in the result set, and then scrolls backwards:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Neither MySQL nor SQLite support scrollable cursors! To achieve the same results,
    try the following modifications to the preceding code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'PDO provides support for transactions. Borrowing the code from step 9, we can
    wrap the `INSERT` series of commands into a transactional block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to keep everything modular and re-usable, we can wrap the PDO connection
    into a separate class `Application\Database\Connection`. Here, we build a connection
    through the constructor. Alternatively, there is a static `factory()` method that
    lets us generate a series of PDO instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'An important component of this `Connection` class is a generic method that
    can be used to construct a DSN. All we need for this to work is to establish the
    `PDODriver` as a prefix, followed by "`:"`. After that, we simply append key/value
    pairs from our configuration array. Each key/value pair is separated by a semi-colon.
    We also need to strip off the trailing semi-colon, using `substr()` with a negative
    limit for that purpose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, you can copy the initial connection code from step 1 into a `chap_05_pdo_connect_mysql.php`
    file. For the purposes of this illustration, we will assume you have created a
    MySQL database called `php7cookbook`, with a username of cook and a password of
    book. Next, we send a simple SQL statement to the database using the `PDO::query()`
    method. Finally, we use the resulting statement object to fetch results in the
    form of an associative array. Don''t forget to wrap your code in a `try {} catch
    {}` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the resulting output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the option to the PDO constructor, which sets the error mode to `EXCEPTION`.
    Now alter the SQL statement and observe the resulting error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You will observe something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Placeholders can be named or positional. **Named placeholders** are preceded
    by a colon (`:`) in the prepared SQL statement, and are references as keys in
    an associative array provided to `execute()`. **Positional placeholders** are
    represented as question marks (`?`) in the prepared SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, named placeholders are used to represent values in
    a `WHERE` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This example shows using positional placeholders in an `INSERT` operation.
    Notice that the data to be inserted as the fourth customer includes a potential
    SQL injection attack. You will also notice that some awareness of the SQL syntax
    for the database being used is required. In this case, MySQL column names are
    quoted using back-ticks (`''`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the use of a prepared statement with named parameters, modify the SQL
    statement to add a `WHERE` clause that checks for customers with a balance less
    than a certain amount, and a level equal to either `BEG`, `INT`, or `ADV` (that
    is, beginning, intermediate, or advanced). Instead of using `PDO::query()`, use
    `PDO::prepare()`. Before fetching results, you must then perform `PDOStatement::execute()`,
    supplying the values for balance and level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the resulting output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Instead of providing parameters when calling `PDOStatement::execute()`, you
    could alternatively bind parameters. This allows you to assign variables to placeholders.
    At the time of execution, the current value of the variable is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we bind the variables `$min`, `$max`, and `$level` to the
    prepared statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When the values of these variables change, the next execution will reflect the
    modified criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best practice**'
  prefs: []
  type: TYPE_NORMAL
- en: Use `PDO::query()` for one-time database commands. Use `PDO::prepare()` and
    `PDOStatement::execute()` when you need to process the same statement multiple
    times but using different values.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For information on the syntax and unique behavior associated with different
    vendor-specific PDO drivers, have a look this article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://php.net/manual/en/pdo.drivers.php](http://php.net/manual/en/pdo.drivers.php)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a summary of PDO predefined constants, including fetch modes, cursor orientation,
    and attributes, see the following article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://php.net/manual/en/pdo.constants.php](http://php.net/manual/en/pdo.constants.php)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an OOP SQL query builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP 7 implements something called a **context sensitive lexer**. What this means
    is that words that are normally reserved can be used if the context allows. Thus,
    when building an object-oriented SQL builder, we can get away with using methods
    named `and`, `or`, `not`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We define a `Application\Database\Finder` class. In the class, we define methods
    that match our favorite SQL operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Each function used to generate an SQL fragment returns the same property, `$instance`.
    This allows us to represent the code using a fluent interface, such as this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Copy the code defined precedingly into a `Finder.php` file in the `Application\Database`
    folder. You can then create a `chap_05_oop_query_builder.php` calling program,
    which initializes the autoloader defined in [Chapter 1](ch01.html "Chapter 1. Building
    a Foundation"), *Building a Foundation*. You can then run `Finder::select()` to
    generate an object from which the SQL string can be rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result of the precding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information on the context-sensitive lexer, have a look at this article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://wiki.php.net/rfc/context_sensitive_lexer](https://wiki.php.net/rfc/context_sensitive_lexer)'
  prefs: []
  type: TYPE_NORMAL
- en: Handling pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pagination involves providing a limited subset of the results of a database
    query. This is usually done for display purposes, but could easily apply to other
    situations. At first glance, it would seem the `LimitIterator` class is ideally
    suited for the purposes of pagination. In cases where the potential result set
    could be massive; however, `LimitIterator` is not such an ideal candidate, as
    you would need to supply the entire result set as an inner iterator, which would
    most likely exceed memory limitations. The second and third arguments to the `LimitIterator`
    class constructor are offset and count. This suggests the pagination solution
    we will adopt, which is native to SQL: adding `LIMIT` and `OFFSET` clauses to
    a given SQL statement.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we create a class called `Application\Database\Paginate` to hold the
    pagination logic. We add properties to represent values associated with pagination,
    `$sql`, `$page`, and `$linesPerPage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Next, we define a `__construct()` method that accepts a base SQL statement,
    the current page number, and the number of lines per page as arguments. We then
    need to refactor the SQL string modifying or adding the `LIMIT` and `OFFSET` clauses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the constructor, we need to calculate the offset using the current page
    number and the number of lines per page. We also need to check to see if `LIMIT`
    and `OFFSET` are already present in the SQL statement. Finally, we need to revise
    the statement using lines per page as our `LIMIT` with the recalculated `OFFSET`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to execute the query using the `Application\Database\Connection`
    class discussed in the first recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our new pagination class, we add a `paginate()` method, which takes a `Connection`
    instance as an argument. We also need the PDO fetch mode, and optional prepared
    statement parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'It might not be a bad idea to provide support for the query builder class mentioned
    in the previous recipe. This will make updating `LIMIT` and `OFFSET` much easier.
    All we need to do to provide support for `Application\Database\Finder` is to use
    the class and modify the `__construct()` method to check to see if the incoming
    SQL is an instance of this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all that remains to be done is to add a `getSql()` method in case we need
    to confirm that the SQL statement was correctly formed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Copy the preceding code into a `Paginate.php` file in the `Application/Database`
    folder. You can then create a `chap_05_pagination.php` calling program, which
    initializes the autoloader defined in [Chapter 1](ch01.html "Chapter 1. Building
    a Foundation"), *Building a Foundation*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, use the `Application\Database\Finder`, `Connection`, and `Paginate` classes,
    create an instance of `Application\Database\Connection`, and use `Finder` to generate
    SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now get the page number and balance from `$_GET` parameters, and create
    the `Paginate` object, ending the PHP block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output portion of the script, we simply iterate through the pagination
    using a simple `foreach()` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is page 3 of the output, where the balance is less than 1,000:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information on the `LimitIterator` class, refer to this article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://php.net/manual/en/class.limititerator.php](http://php.net/manual/en/class.limititerator.php)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining entities to match database tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very common practice among PHP developers is to create classes that represent
    database tables. Such classes are often referred to as **entity** classes, and
    form the core of the **domain model** software design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, we will establish some common features of a series of entity classes.
    These might include common properties and common methods. We will put these into
    a `Application\Entity\Base` class. All future entity classes will then extend
    `Base`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the purposes of this illustration, let''s assume all entities will have
    two properties in common: `$mapping` (discussed later), and `$id` (with its corresponding
    getter and setter):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: It's not a bad idea to define a `arrayToEntity()` method, which converts an
    array to an instance of the entity class, and vice versa (`entityToArray()`).
    These methods implement a process often referred to as **hydration**. As these
    methods should be generic, they are best placed in the `Base` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following methods, the `$mapping` property is used to translate between
    database column names and object property names. `arrayToEntity()` populates values
    of this object instance from an array. We can define this method as static in
    case we need to call it outside of an active instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `entityToArray()` produces an array from current instance property values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: To build the specific entity, you need to have the structure of the database
    table you plan to model at hand. Create properties that map to the database columns.
    The initial values assigned should reflect the ultimate data-type of the database
    column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this example we''ll use the `customer` table. Here is the `CREATE` statement
    from a MySQL data dump, which illustrates its data structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now in a position to flesh out the class properties. This is also a
    good place to identify the corresponding table. In this case, we will use a `TABLE_NAME`
    class constant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: It is considered a best practice to define the properties as `protected`. In
    order to access these properties, you will need to design `public` methods that
    `get` and `set` the properties. Here is a good place to put to use the PHP 7 ability
    to data-type to the return value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following block of code, we have defined getters and setters for `$name`
    and `$balance`. You can imagine how the remainder of these methods will be defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is not a good idea to data type check the incoming values on the setters.
    The reason is that the return values from a RDBMS database query will all be a
    `string` data type.
  prefs: []
  type: TYPE_NORMAL
- en: If the property names do not exactly match the corresponding database column,
    you should consider creating a `mapping` property, an array of key/value pairs
    where the key represents the database column name and the value the property name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will note that three properties, `$securityQuestion`, `$confirmCode`, and
    `$profileId`, do not correspond to their equivalent column names, `security_question`,
    `confirm_code`, and `profile_id`. The `$mapping` property will ensure that the
    appropriate translation takes place:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Copy the code from steps 2, 4, and 5 into a `Base.php` file in the `Application/Entity`
    folder. Copy the code from steps 8 through 12 into a `Customer.php` file, also
    in the `Application/Entity` folder. You will then need to create getters and setters
    for the remaining properties not shown in step 10: `email`, `password`, `status`,
    `securityQuestion`, `confirmCode`, `profileId`, and `level`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then create a `chap_05_matching_entity_to_table.php` calling program,
    which initializes the autoloader defined in [Chapter 1](ch01.html "Chapter 1. Building
    a Foundation"), *Building a Foundation*, uses the `Application\Database\Connection`,
    and the newly created `Application\Entity\Customer` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, get a database connection, and use the connection to acquire an associative
    array of data for one customer at random:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can create a new `Customer` entity instance from the array and
    use `var_dump()` to view the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many good works that describe the domain model. Probably the most
    influential is *Patterns of Enterprise Application Architecture* by Martin Fowler
    (see [http://martinfowler.com/books/eaa.html](http://martinfowler.com/books/eaa.html)).
    There is also a nice study, also available as a free download, entitled *Domain
    Driven Design Quickly* by InfoQ (see [http://www.infoq.com/minibooks/domain-driven-design-quickly](http://www.infoq.com/minibooks/domain-driven-design-quickly)).
  prefs: []
  type: TYPE_NORMAL
- en: Tying entity classes to RDBMS queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most commercially viable RDBMS systems evolved at a time when procedural programming
    was at the fore. Imagine the RDBMS world as two dimensional, square, and procedurally
    oriented. In contrast, entities could be thought of as round, three dimensional,
    and object oriented. This gives you a picture of what we want to accomplish by
    tying the results of an RDBMS query into an iteration of entity instances.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **relational model**, upon which modern RDBMS systems are based, was first
    described by the mathematician Edgar F. Codd in 1969\. The first commercially
    viable systems evolved in the mid-to-late 1970s. So, in other words, RDBMS technology
    is over 40 years old!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we need to design a class which will house our query logic. If
    you are following the Domain Model, this class might be called a **repository**.
    Alternatively, to keep things simple and generic, we could simply call the new
    class `Application\Database\CustomerService`. The class will accept an `Application\Database\Connection`
    instance as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will define a `fetchById()` method, which takes a customer ID as an
    argument, and returns a single `Application\Entity\Customer` instance or boolean
    `FALSE` on failure. At first glance, it would seem a no-brainer to simply use
    `PDOStatement::fetchObject()` and specify the entity class as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The danger here, however, is that `fetchObject()` actually populates the properties
    (even if they are protected) before the constructor is called! Accordingly, there
    is a danger that the constructor could accidentally overwrite values. If you don't
    define a constructor, or if you can live with this danger, we're done. Otherwise,
    it starts to get tougher to properly implement the tie between RDBMS query and
    OOP results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach for the `fetchById()` method is to create the object instance
    first, thereby running its constructor, and setting the fetch mode to `PDO::FETCH_INTO`,
    as shown in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here again, however, we encounter a problem: `fetch()`, unlike `fetchObject()`,
    is not able to overwrite protected properties; the following error message is
    generated if it tries. This means we will either have to define all properties
    as `public`, or consider another approach.![How to do it...](graphics/B05314_05_07.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last approach we will consider will be to fetch the results in the form
    of an array, and manually *hydrate* the entity. Even though this approach is slightly
    more costly in terms of performance, it allows any potential entity constructor
    to run properly, and keeps properties safely defined as `private` or `protected`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To process a query that produces multiple results, all we need to do is to
    produce an iteration of populated entity objects. In this example, we implement
    a `fetchByLevel()` method that returns all customers for a given level, in the
    form of `Application\Entity\Customer` instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The next method we wish to implement is `save()`. Before we can proceed, however,
    some thought must be given to what value will be returned if an `INSERT` takes
    place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Normally, we would return the newly completed entity class after an `INSERT`.
    There is a convenient `PDO::lastInsertId()` method which, at first glance, would
    seem to do the trick. Further reading of the documentation reveals, however, that
    not all database extensions support this feature, and the ones that do are not
    consistent in their implementation. Accordingly, it would be a good idea to have
    a unique column other than `$id` that can be used to uniquely identify the new
    customer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this example we have chosen the `email` column, and thus need to implement
    a `fetchByEmail()` service method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now we are ready to define the `save()` method. Rather than distinguish between
    `INSERT` and `UPDATE`, we will architect this method to update if the ID already
    exists, and otherwise do an insert.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we define a basic `save()` method, which accepts a `Customer` entity
    as an argument, and uses `fetchById()` to determine if this entry already exists.
    If it exists, we call an `doUpdate()` update method; otherwise, we call a `doInsert()`
    insert method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define `doUpdate()`, which pulls `Customer` entity object properties
    into an array, builds an initial SQL statement, and calls a `flush()` method,
    which pushes data to the database. We do not want the ID field updated, as it''s
    the primary key. Also we need to specify which row to update, which means appending
    a `WHERE` clause:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `doInsert()` method is similar, except that the initial SQL needs to start
    with `INSERT INTO ...` and the `id` array element needs to be unset. The reason
    for the latter is that we want this property to be auto-generated by the database.
    If this is successful, we use our newly defined `fetchByEmail()` method to look
    up the new customer and return a completed instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we are in a position to define `flush()`, which does the actual preparation
    and execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'To round off the discussion, we need to define a `remove()` method, which deletes
    a customer from the database. Again, as with the `save()` method defined previously,
    we use `fetchById()` to ensure the operation was successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Copy the code described in steps 1 to 5 into a `CustomerService.php` file in
    the `Application/Database` folder. Define a `chap_05_entity_to_query.php` calling
    program. Have the calling program initialize the autoloader, using the appropriate
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now create an instance of the service, and fetch a single customer
    at random. The service will then return a customer entity as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now copy the code shown in steps 6 to 15 into the service class. Add the data
    to insert to the `chap_05_entity_to_query.php` calling program. We then generate
    a `Customer` entity instance using this data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then examine the ID before and after the call to `save()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we modify the balance, and again call `save()`, viewing the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output from the calling program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on the relational model, please refer to [https://en.wikipedia.org/wiki/Relational_model](https://en.wikipedia.org/wiki/Relational_model).
    For more information on RDBMS, please refer to [https://en.wikipedia.org/wiki/Relational_database_management_system](https://en.wikipedia.org/wiki/Relational_database_management_system).
    For information on how `PDOStatement::fetchObject()` inserts property values even
    before the constructor, have a look at the comment by "rasmus at mindplay dot
    dk" in the php.net documentation reference on `fetchObject()` ([http://php.net/manual/en/pdostatement.fetchobject.php](http://php.net/manual/en/pdostatement.fetchobject.php)).
  prefs: []
  type: TYPE_NORMAL
- en: Embedding secondary lookups into query results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the road towards implementing relationships between entity classes, let us
    first take a look at how we can embed the code needed to perform a secondary lookup.
    An example of such a lookup is when displaying information on a customer, have
    the view logic perform a second lookup that gets a list of purchases for that
    customer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The advantage of this approach is that processing is deferred until the actual
    view logic is executed. This will ultimately smooth the performance curve, with
    the workload distributed more evenly between the initial query for customer information,
    and the later query for purchase information. Another benefit is that a massive
    `JOIN` is avoided with its inherent redundant data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, define a function that finds a customer based on their ID. For
    the purposes of this illustration, we will simply fetch an array using the fetch
    mode `PDO::FETCH_ASSOC`. We will also continue to use the `Application\Database\Connection`
    class discussed in [Chapter 1](ch01.html "Chapter 1. Building a Foundation"),
    *Building a Foundation*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we analyze the purchases table to see how the `customer` and `product`
    tables are linked. As you can see from the `CREATE` statement for this table,
    the `customer_id` and `product_id` foreign keys form the relationships:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We now expand the original `findCustomerById()` function, defining the secondary
    lookup in the form of an anonymous function, which can then be executed in a view
    script. The anonymous function is assigned to the `$results[''purchases'']` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming we have successfully retrieved customer information into a `$results`
    array, in the view logic, all we need to do is to loop through the return value
    of the anonymous function. In this example, we retrieve customer information at
    random:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In the view logic, we loop through the results returned by the secondary lookup.
    The call to the embedded anonymous function is highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a `chap_05_secondary_lookups.php` calling program and insert the code
    needed to create an instance of `Application\Database\Connection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the `findCustomerById()`function shown in step 3\. You can then pull
    information for a random customer, ending the PHP part of the calling program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'For the view logic, you can display core customer information as shown in several
    of the preceding recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'You can display information on purchases like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The critical piece is that the secondary lookup is performed as part of the
    view logic by calling the embedded anonymous function, `$result[''purchases'']($result[''id''],
    $conn)`. Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing jQuery DataTables PHP lookups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another approach to secondary lookups is to have the frontend generate the request.
    In this recipe, we will make a slight modification to the secondary lookup code
    presented in the preceding recipe, Embedding secondary lookups into QueryResults.
    In the previous recipe, even though the view logic is performing the lookup, all
    processing is still done on the server. When using **jQuery DataTables**, however,
    the secondary lookup is actually performed directly by the client, in the form
    of an **Asynchronous JavaScript and XML** (**AJAX**) request issued by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First we need to spin-off the secondary lookup logic (discussed in the recipe
    above) into a separate PHP file. The purpose of this new script is to perform
    the secondary lookup and return a JSON array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new script we will call `chap_05_jquery_datatables_php_lookups_ajax.php`.
    It looks for a `$_GET` parameter, `id`. Notice that the `SELECT` statement is
    very specific as to which columns are delivered. You will also note that the fetch
    mode has been changed to `PDO::FETCH_NUM`. You might also notice that the last
    line takes the results and assigns it to a `data` key in a JSON-encoded array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is *extremely* important when dealing with zero configuration jQuery DataTables
    to only return the exact number of columns matching the header.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to modify the function that retrieves customer information by
    ID, removing the secondary lookup embedded in the previous recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, in the view logic, we import the minimum jQuery, DataTables, and
    stylesheets for a zero configuration implementation. At a minimum, you will need
    jQuery itself (in this example `jquery-1.12.0.min.js`) and DataTables (`jquery.dataTables.js`).
    We''ve also added a convenient stylesheet associated with DataTables, `jquery.dataTables.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define a jQuery document `ready` function, which associates a table
    with DataTables. In this case, we assign an id attribute of `customerTable` to
    the table element that will be assigned to DataTables. You''ll also notice that
    we specify the AJAX data source as the script defined in step 1, `chap_05_jquery_datatables_php_lookups_ajax.php`.
    As we have the `$id` available, this is appended to the data source URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'In the body of the view logic, we define the table, making sure the `id` attribute
    matches the one specified in the preceding code. We also need to define headers
    that will match the data presented in response to the AJAX request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Now, all that remains to do is to load the page, choose the customer ID (in
    this case, at random), and let jQuery make the request for the secondary lookup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a `chap_05_jquery_datatables_php_lookups_ajax.php` script, which will
    respond to an AJAX request. Inside, place the code to initialize auto-loading
    and create a `Connection` instance. You can then append the code shown in step
    2 of the preceding recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a `chap_05_jquery_datatables_php_lookups.php` calling program
    that will pull information on a random customer. Add the function described in
    step 3 of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The calling program will also contain the view logic that imports the minimum
    JavaScript to implement jQuery DataTables. You can add the code shown in step
    3 of the preceding code. Then, add the document `ready` function and the display
    logic shown in steps 5 and 6\. Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on jQuery, please visit their website at [https://jquery.com/](https://jquery.com/).
    To read about the DataTables plugin to jQuery, refer to this article at [https://www.datatables.net/](https://www.datatables.net/).
    Zero configuration data tables are discussed at [https://datatables.net/examples/basic_init/zero_configuration.html](https://datatables.net/examples/basic_init/zero_configuration.html).
    For more information on AJAX sourced data, have a look at [https://datatables.net/examples/data_sources/ajax.html](https://datatables.net/examples/data_sources/ajax.html).
  prefs: []
  type: TYPE_NORMAL
