- en: Privilege Escalation of AWS Accounts Using Stolen Keys, Boto3, and Pacu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important aspect of pentesting AWS environments is the process of enumerating
    what permissions your user has, and then escalating those privileges, if possible.
    Knowing what you have access to is the first battle, and it will allow you to
    formulate an attack plan in the environment. Next is privilege escalation, where
    if you can gain further access to the environment, you can perform more devastating
    attacks. In this chapter, we will dive into the Python `boto3` library to learn
    how to make AWS API calls programmatically, learn how to use it to automate the
    enumeration of our permissions, and then finally, learn how to use it to escalate
    our permissions if our user is vulnerable to escalation.
  prefs: []
  type: TYPE_NORMAL
- en: The enumeration of our permissions is very important for a multitude of reasons.
    One of these is that we will avoid needing to guess what our permissions are,
    preventing many access denied errors in the process. Another is that it can possibly
    disclose information about other parts of the environment, such as if a specific
    resource is marked in one of our **Identity and Access Management** (**IAM**)
    policies, we then know that the resource is in use and is important to some degree.
    Further, we can compare our list of permissions against a list of known privilege
    escalation methods to see if we can grant ourselves more access. The more access
    we can gain to the environment, the higher the impact and the more dangerous our
    attack will be to our client if we were real malicious attackers instead of pentesters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `boto3` library for reconnaissance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dumping all the account information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permissions enumeration with compromised AWS keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Privilege escalation and gathering credentials using Pacu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of permissions enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any case, whether you can escalate your privileges or not, having a definitive
    list of what permissions you do have is extremely important. This can save you
    a lot of time when attacking an environment as you don't need to spend time trying
    to guess what access you might have, and instead, you can do manual analysis offline
    to leave a smaller logging footprint. By knowing what access you have, you can
    avoid the need to run test commands to determine whether you have privileges or
    not. This is beneficial because API errors, especially access denied errors, can
    be very noisy, and will likely alert a defender to your activity.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, you might find that your user does not have enough permissions
    to be able to enumerate their full list of permissions. In these situations, it
    is generally recommended to make assumptions based on the information that you
    already have, such as where the keys were retrieved from. Maybe you got these
    compromised keys from a web app that uploads files to `S3`. It will be safe to
    assume that the keys have permission to upload files to `S3` and that they could
    have read/list permissions as well. It will be unlikely that this set of keys
    has access to the IAM service, so it could be rather noisy to make IAM API calls,
    because it will most likely return an access denied error. This doesn't mean you
    shouldn't ever decide to try those permissions though, as sometimes it is your
    only option, and you may need to make some noise in the account to figure out
    what your next steps will be.
  prefs: []
  type: TYPE_NORMAL
- en: Using the boto3 library for reconnaissance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Boto3 is the AWS **software development kit** (**SDK**) for Python and can
    be found here: [https://boto3.amazonaws.com/v1/documentation/api/latest/index.html](https://boto3.amazonaws.com/v1/documentation/api/latest/index.html).
    It provides an interface to the AWS APIs, allowing us to interact with them programmatically,
    meaning that we can automate and control what we are trying to do in AWS. It is
    managed by AWS, so it is constantly updated with the latest features and offerings
    from AWS. It is also used on the backend of the AWS **Command Line Interface**
    (**CLI**), so it makes more sense for us to interact with this library than to
    try and run AWS CLI commands from within our code.'
  prefs: []
  type: TYPE_NORMAL
- en: Because we are going to be using Python for our scripts, `boto3` is the perfect
    option to allow us to interact with the AWS APIs. This way, we can automate our
    reconnaissance/information gathering phase with a lot of the extra stuff already
    taken care of (such as signing the HTTP requests to the AWS API). We'll be using
    the AWS APIs to gather information about our target account, allowing us to determine
    our level of access to the environment and helping us to formulate our attack
    plan with precision.
  prefs: []
  type: TYPE_NORMAL
- en: This section will assume that you have Python 3 installed along with the `pip`
    package manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing `boto3` is as simple as running a single `pip install` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `boto3` and its dependencies should be installed on your computer. If the
    `pip3` command does not work for you, you may need to invoke `pip` directly through
    the Python command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Our first Boto3 enumeration script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once `boto3` is installed, it just needs to be imported to your Python script.
    For this chapter, we will begin with the following Python script that declares
    itself as `python3` and then imports `boto3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There are a few different ways that we can set up credentials with `boto3`,
    but we are going to stick with just one, and that is by creating a `boto3` `session` to
    make our API calls ([https://boto3.amazonaws.com/v1/documentation/api/latest/reference/core/session.html](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/core/session.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we created our IAM user and saved their keys to the
    AWS CLI, so now with `boto3`, we can retrieve those credentials and use them in
    our scripts. We will do that by first instantiating a `boto3` `session` for the
    `us-west-2` region with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This code creates a new `boto3` `session` and will search the computer for the
    AWS CLI profile with the name of `Test`, which we have already set up. By using
    this method to handle credentials within our scripts, we don't need to directly
    include hardcoded credentials in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our session created, we can use that session to create `boto3`
    clients, which are then used to make API calls to AWS. Clients accept multiple
    parameters when they are created to manage different configuration values, but
    in general, there is only one that we need to worry about and that is the `service_name` parameter.
    It is a positional parameter and will always be the first parameter we pass to
    the client. The following line of code sets up a new `boto3` client with our credentials,
    which targets the EC2 AWS service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now we can use this newly created client to make AWS API calls to the EC2 service.
  prefs: []
  type: TYPE_NORMAL
- en: For a list of available methods, you can visit the EC2 reference page in the
    `boto3` documentation at [https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#client](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#client).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many methods to choose from, but for the sake of information enumeration,
    we are going to start out with the `describe_instances` method, which, just as
    we showed previously (that is, in the *Using IAM access keys* section of [Chapter
    9](08482ee1-cf12-4e93-81b7-633cc6c71e7b.xhtml), *Identity Access Management on
    AWS*)with the AWS CLI, will enumerate EC2 instances in the target region. We can
    run this API call and retrieve the results with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `describe_instances` method accepts some optional arguments, but for the
    first call we make, we don't need any yet. One thing that the documentation for
    this method ([https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#EC2.Client.describe_instances](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#EC2.Client.describe_instances))
    tells us is that it supports pagination. Depending on the number of EC2 instances
    in the account you're targeting, you may not receive all the results in the first
    API call. We can take care of this by creating a separate variable to house all
    the enumerated instances and checking if the results are complete or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous line of code that we added (`response = client.describe_instances()`)
    will need to be rearranged a little bit, so that it will end up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now we can be sure that even in large environments with `1000s` of EC2 instances,
    we have a complete list of them.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Well, now we have the list of EC2 instances, but what should we do with it?
    A simple solution is to output the data to a local file so that it can be referenced
    later. We can do this by importing the `json` Python library and dumping the contents
    of `instances` to a file in the same directory as our script. Let''s add the following
    code to our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the full script (without comments) should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can run this script with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A new file named `ec2-instances.json` should be created in the current directory,
    and when you open it up, you should see something like the following screenshot,
    where a JSON representation of all EC2 instances in the `us-west-2` region is
    listed. This JSON data holds basic information on the EC2 instances, including
    identifying information, networking information, and other configurations applicable
    to EC2 instances. However, all these details aren''t important at the moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12e9ca4d-6999-4d21-9b92-f52d23776c29.png)'
  prefs: []
  type: TYPE_IMG
- en: This file should now have all the enumerated information for all the instances
    in the region we previously specified in the code (`us-west-2`).
  prefs: []
  type: TYPE_NORMAL
- en: Adding some S3 enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's say that we want to enumerate what `S3` buckets exist in the account
    and what files are in those buckets. Currently, our test IAM user does not have
    `S3` permissions, so I have gone ahead and directly attached the AWS-managed policy
    `AmazonS3ReadOnlyAccess` to our user. If you need help doing so for your own user,
    refer to [Chapter 9](08482ee1-cf12-4e93-81b7-633cc6c71e7b.xhtml), *Identity Access
    Management on AWS*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add the following code to the bottom of the existing script that we
    have already created. First, we will want to figure out what `S3` buckets are
    in the account, so we will need a new `boto3` client set up to target `S3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will use the `list_buckets` method to retrieve a list of `S3` buckets
    in the account. Note that unlike the `ec2:DescribeInstances` API call, the `s3:ListBuckets`
    API call is not paginated, and you can expect all the buckets in the account in
    a single response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The data returned comes with some information that we aren''t interested in
    right now (such as the bucket creation date), so we are going to iterate through
    the response and only pull out the names of the buckets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the names of all the buckets in the account, we can go ahead
    and list out the files in each one by using the `list_objects_v2` API call. The
    `list_objects_v2` API call is a paginated operation, so it is possible that not
    every object will be returned to us in the first API call, so we will take that
    into account in our script. We will add the following code to our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When that loop completes, we should end up with `bucket_objects` being a dictionary,
    where each key is a bucket name in the account and it contains a list of objects
    that are stored in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly to how we dumped all the EC2 instance data to `ec2-instances.json`,
    we are now going to dump all the file information into multiple different files,
    where the name is the name of the bucket. We can add the following code to do
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the final code that we have added to our original script should look like
    this (without comments):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can run our script again with the same command as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When it completes, it should have again enumerated the EC2 instances and stored
    them in the `ec2-instances.json` file, and there should now also be a file for
    each bucket in the account that contains the filenames and file sizes of all the
    objects in them. The following screenshot shows a snippet of the information that
    was downloaded from one of our `test` buckets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e52f85b-0308-4d24-9a49-a31bca5e6399.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we know what files exist, we could try using the AWS S3 API command, `get_object`,
    to download files that sound interesting, but I will leave that as a task for
    you. Bear in mind that data transfer incurs charges for the AWS account that it
    occurs in, so it is generally not a good idea to write scripts that try to download
    every single file in a bucket. If you did do that, you could easily run into a
    bucket with terabytes of data in it and cause a lot of unexpected charges to the
    AWS account. That is why it is important to pick and choose the files that you
    want to download based on name and size.
  prefs: []
  type: TYPE_NORMAL
- en: Dumping all the account information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS makes it possible to retrieve data from an account via multiple methods
    (or APIs), and some of these are easier than others. This works to our advantage
    as an attacker because we may be denied access to one permission, but allowed
    access to another, which can, ultimately, be used to reach the same goal.
  prefs: []
  type: TYPE_NORMAL
- en: A new script – IAM enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to start out with a new script, and the goal
    will be to have it enumerate various points of data about the IAM service and
    the AWS account. The script will start with some of the things that we have already
    filled in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We have declared the file to be a `python3` file, imported the `boto3` library,
    created our `boto3` `session` using the credentials from the `Test` profile in
    the `us-west-2` region, and then created a `boto3` client for the IAM service
    with those credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to start off with the `get_account_authorization_details` API
    call ([https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/iam.html#IAM.Client.get_account_authorization_details](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/iam.html#IAM.Client.get_account_authorization_details)),
    which returns a wealth of information from the account, including user, role,
    group, and policy information. This is a paginated API call, so we will start
    off by creating empty lists to accumulate the data as we enumerate it, and then
    make our first API call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to check if the response is paginated and if we need to make another
    API call to get more results. Just like before, we can do this with a simple loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that there are inconsistencies with the names and structures
    of AWS API call arguments and responses (such as `ContinuationToken` versus `NextToken`
    versus `Marker`). There is no way around this, the `boto3` library is just inconsistent
    in its naming schemes, so it is important to read the documentation for the commands
    you are running.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the data (again)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, just like before, we will want to save this data somewhere. We will store
    it in four separate files, `users.json`, `groups.json`, `roles.json`, and `policies.json`,
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This should end up with the final script (without comments) looking like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can run the script with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The current folder should end up with four new files created in it with the
    details of the users, groups, roles, and policies in the account.
  prefs: []
  type: TYPE_NORMAL
- en: Permission enumeration with compromised AWS keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can now extend the script from the previous section to use the collected
    data to determine what exact permissions your current user has by correlating
    the data stored in the different files. To do this, we will first need to find
    our current user in the list of users we pulled down.
  prefs: []
  type: TYPE_NORMAL
- en: Determining our level of access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In an attack scenario, it is possible that you don''t know the username of
    your current user, so we will add this line of code that uses the `iam:GetUser`
    API to determine that information (note that this call will fail if your credentials
    belong to a role):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will iterate through the user data we collected and look for our current
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We can now check a few different pieces of information that may or may not be
    attached to our user object. If a certain piece of information doesn't exist,
    then that means there are no values for it that we need to worry about.
  prefs: []
  type: TYPE_NORMAL
- en: 'To come up with a complete list of permissions for our user, we will need to
    inspect the following data: `UserPolicyList`, `GroupList`, and `AttachedManagedPolicies`.
    `UserPolicyList` will contain all inline policies that are attached to our user,
    `AttachedManagedPolicies` will include all managed policies attached to our user,
    and `GroupList` will contain the list of groups that our user is a part of. For
    each of the policies, we will need to pull the documents associated with them
    and for the groups, we will then need to check what inline policies and managed
    policies are attached to it, and then pull the documents associated with those
    to finally come up with a definitive list of permissions.'
  prefs: []
  type: TYPE_NORMAL
- en: Analysing policies attached to our user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to start out by gathering the inline policy documents attached
    to our user. Luckily for us, the entire document for any inline policies is included
    with our user. We will add the following code to our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `my_policies` should include all the inline policies that are directly
    attached to our user. Next, we will gather the managed policy documents that are
    attached to our user. The policy documents are not directly attached to our user,
    so we must use the identifying information to find the policy document in our
    `policy_details` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `my_policies` should include all the inline policies and managed policies
    that are directly attached to our user. Next, we will figure out what groups we
    are a part of, then enumerate the inline policies and managed policies that are
    attached to each of those groups. When that is complete, we will have a complete
    list of the permissions that are assigned to our user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the script should be complete and our `my_policies` variable should have
    the policy documents for all inline and managed policies that are directly attached
    to our user, as well as all inline and managed policies attached to each group
    that our user is a member of. We can check these results out by adding one final
    snippet that outputs the data to a local file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the file with the same command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can check the generated `my-user-permissions.json`, which should contain
    the list of all policies and permissions that apply to your user. It should look
    something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a13046f-3011-49de-9475-47e670bddbcc.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we have a nice list of what permissions we have, what resources we can use
    those permissions on, and under what conditions we can apply those permissions.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important point to note is that this script will fail if the user does not
    have the `iam:GetAccountAuthorization` permission, because they will not be able
    to gather the list of users, groups, roles, and policies. To potentially solve
    this problem, we can refer to the beginning of this section, where it was noted
    that sometimes there is more than one way to do something through the AWS API,
    and those different ways require different sets of permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case where our user does not have the `iam:GetAccountAuthorizationDetails` permission,
    but they do have other IAM read permissions, it might still be possible to enumerate
    our list of permissions. We will not be running through and creating a script
    that does this, but here is a general guide if you should like to try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: Check if we have the `iam:GetAccountAuthorizationDetails` permission
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If so, run the script that we just created
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If not, go to step 2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `iam:GetUser` API to determine what user we are (note that this won't
    work for roles!)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `iam:ListUserPolicies` API to fetch the list of inline policies that
    are attached to our user
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `iam:GetUserPolicy` API to fetch the documents for each inline policy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `iam:ListAttachedUserPolicies` API to fetch the list of managed policies
    that are attached to our user
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `iam:GetPolicy` API to determine the default version for each managed
    policy that is attached to our user
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `iam:GetPolicyVersion` API to fetch the policy document for each managed
    policy that is attached to our user
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `iam:ListGroupsForUser` API to find out what groups our user is a part
    of
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `iam:ListGroupPolicies` API to list the inline policies that are attached
    to each group
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `iam:GetGroupPolicy` API to get the document for each inline policy
    that is attached to each group
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `iam:ListAttahedGroupPolicies` API to list the managed policies that
    are attached to each group
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `iam:GetPolicy` API to determine the default version for each managed
    policy that is attached to each group
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `iam:GetPolicyVersion` API to fetch the policy document for each managed
    policy that is attached to each group
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can probably tell, this method of permission enumeration requires far
    more API calls to AWS, and it will likely be a lot louder to a listening defender
    than our first method. However, it might be the right choice if you don't have
    the `iam:GetAccountAuthorizationDetails` permission but you do have the permissions
    required to follow all the steps that are listed.
  prefs: []
  type: TYPE_NORMAL
- en: Privilege escalation and gathering credentials using Pacu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prior to trying to detect and exploit privilege escalation for our target user,
    we are going to add another policy that will make the user vulnerable to privilege
    escalation. Add an inline policy named `PutUserPolicy` to our original `Test` user
    with the following document before proceeding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This policy gives our user access to run the `iam:PutUserPolicy` API action
    on any user.
  prefs: []
  type: TYPE_NORMAL
- en: Pacu – an open source AWS exploitation toolkit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Pacu** is an open source AWS exploitation toolkit written by Rhino Security
    Labs. It was built to aid penetration testers in attacking AWS environments; so,
    now we will quickly install and set up Pacu to automate these attacks that we
    have been trying.'
  prefs: []
  type: TYPE_NORMAL
- en: More in-depth instructions for installation and configuration can be found in
    [Chapter 19](aeb03296-ac3a-4d61-ac6a-c6a11f267f95.xhtml), *Putting It All Together-Real-World
    AWS Pentesting*; these steps aim to get you set up and using Pacu as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pacu is available through GitHub, so we will need to run a few commands to
    get everything installed (we are running Kali Linux). First, let''s confirm we
    have `git` installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will clone the Pacu repository from GitHub ([https://github.com/RhinoSecurityLabs/pacu](https://github.com/RhinoSecurityLabs/pacu)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will switch into the Pacu directory and run the install script, which
    will ensure we have the correct Python version installed (Python 3.5 or later),
    and install the necessary dependencies with `pip3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now Pacu should be successfully installed, and we can start it up with this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'A few messages will appear to let you know that a new settings file was generated
    and that a new database was created. It will detect that we have not set up a
    `session` yet, so it will ask us to name a new session to create. A Pacu session
    is basically a project, in that you can have multiple Pacu sessions in the same
    installation that are separate. The session data is stored in a local SQLite database,
    and each individual session can be thought of as a project or target company.
    It allows you to keep data and credentials separated when you are working on more
    than one environment. Logs and configuration are also separate between each Pacu
    session; we are going to name our session `Demo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58a56fd7-354a-48e5-aa14-01e84088d581.png)'
  prefs: []
  type: TYPE_IMG
- en: Once our new session is successfully created, we will be presented with some
    helpful information relating to Pacu that we will go into in more depth later.
  prefs: []
  type: TYPE_NORMAL
- en: Kali Linux detection bypass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because we are running Pacu on Kali Linux, we are presented with an extra message
    about our user agent after the help output, similar to what is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bfd49e7-c99d-4886-89c8-3d794ea0a6c5.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that Pacu has detected that we are running Kali Linux and modified
    our user agent as a result. `GuardDuty` is one of the many security services that
    AWS offers, and it is used to detect and alert to suspicious behavior going on
    in an AWS environment. One thing that `GuardDuty` checks for is if you are making
    AWS API calls that originate from Kali Linux ([https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_pentest.html#pentest1](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_pentest.html#pentest1)).
    We want to trigger as few alerts as possible in an account we are attacking, so
    Pacu has it built-in to automatically bypass this security measure. `GuardDuty`
    checks the user agent of whoever is making the API call to see if it recognizes
    Kali Linux from it, and alerts to it if it does. Pacu modifies our user agent
    to a generic user agent that does not look suspicious to `GuardDuty`.
  prefs: []
  type: TYPE_NORMAL
- en: The Pacu CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Right after that output, we can see something called the Pacu CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5db694f7-e5df-446b-a60f-cf8b6eed15db.png)'
  prefs: []
  type: TYPE_IMG
- en: What this is showing us is that we are in the Pacu CLI, our active session is
    named Demo, and we have no active keys. We can add some AWS keys to the Pacu database
    in a few different ways, such as using the `set_keys` command, or importing them
    from the AWS CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already set up our AWS keys to work with the AWS CLI, so the simplest
    approach will be to import them from the AWS CLI. We can import our `Test` AWS
    CLI profile by running the following Pacu command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This command should return the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we run the `whoami` command, we should be able to see that our access
    key ID and secret access key have been imported, and if we look at the Pacu CLI
    we can see that now instead of `No Keys Set`, it says the name of the keys we
    imported. The location of the Pacu CLI indicates what the active set of credentials
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a20c952-5fa3-427d-9756-85a44e405fef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have Pacu set up, we can retrieve the list of current modules by
    running the `ls` command from the Pacu CLI. To automate one of the processes that
    we worked through earlier in this chapter, we are going to use the `iam__enum_permissions` module.
    This module will perform the necessary API calls and parsing of the data to gather
    a confirmed list of permissions for our active set of credentials. This module
    can also be run against other users or roles in the account, so to get a better
    understanding of its capabilities, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you should be able to see a description of the module and what arguments
    it supported. To run this module for our own user, we don''t need to pass in any
    arguments, so we can just run the following command to execute the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If the current set of credentials has permission to enumerate their privileges
    (which they should, because of what we set up earlier in the chapter), the output
    should indicate that the module successfully gathered the permissions for that
    user or role:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66bcf05a-27fc-4c4e-9df3-a19880b75ab2.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that the permissions for our user have been enumerated, we can view the
    enumerated data by running the `whoami` command again. This time, most of the
    data will be filled in.
  prefs: []
  type: TYPE_NORMAL
- en: The Groups field will contain information on any groups that our user is a part
    of and the Policies field will contain information on any IAM policies attached
    to our user. Identifying information such as the `UserName`, `Arn`, `AccountId`,
    and `UserId` fields should be filled in as well.
  prefs: []
  type: TYPE_NORMAL
- en: Towards the bottom of the output, we can see the `PermissionsConfirmed` field,
    which holds true or false, and it indicates whether we were able to successfully
    enumerate the permissions we have. The value will be false if we are denied access
    to some APIs and are not able to gather a complete list of our permissions.
  prefs: []
  type: TYPE_NORMAL
- en: The `Permissions` field will contain each IAM permission that our user is given,
    the resources those permissions can be applied to, and the conditions required
    to use them. Just like the script we wrote earlier in the chapter, this list contains
    permissions granted by any inline or managed policies attached to our user, as
    well as any inline or managed policies attached to any groups that our user is
    a member of.
  prefs: []
  type: TYPE_NORMAL
- en: From enumeration to privilege escalation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our permissions have been enumerated, so now we will move into trying to use
    those permissions for privilege escalation in the environment. There is also a
    Pacu module for this called `iam_privesc_scan`. This module will run and check
    the set of permissions that you enumerated to see if your user is vulnerable to
    any methods out of 21 different known privilege escalation methods in AWS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rhino Security Labs wrote an article that details these 21 different privilege
    escalation methods and how they can be manually exploited, which you can refer
    to here: [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the module checks to see if we are vulnerable to any of those methods,
    it will then try to exploit them to do the privilege escalation for us, which
    makes our job easy. If you are interested in reading more about the privilege
    escalation module, you can use the `help` command to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this module can also be run against other users and roles in
    the account to determine whether they are vulnerable to privilege escalation as
    well, but for the time being we are only going to target our own user.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already enumerated our permissions, so we can go ahead and run just
    the privilege escalation module without any arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The module will execute, search your permissions to see if you are vulnerable
    to any of the escalation methods it checks for, and then it will try to exploit
    them. In the case of our `Test` user, it should detect that we are vulnerable
    to the `PutUserPolicy` privilege escalation method. It will then try to abuse
    that permission to put (essentially attach) a new inline policy on our user. We
    are in control of the policy that we attach to our user, so we can specify an
    administrator level IAM policy and attach it to our user, where we will then be
    given administrator access. The module will do this automatically by adding the
    following policy document to our user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows output that should be similar to what you see
    when you run the privilege escalation module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f7c65a0-0008-42aa-bb2a-0d36becbb74d.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we can see the line `Successfully added an inline
    policy named jea70c72mk! You should not have administrator permissions.` This
    sounds good, but let's confirm this just to be sure.
  prefs: []
  type: TYPE_NORMAL
- en: We can confirm this in a few different ways; one is to run the `iam__enum_permissions` module
    again and then view the Permissions field. It should include a new permission
    that is just a star (`*`), which is a wildcard that says `all permissions`. That
    means we have administrator access to the environment!
  prefs: []
  type: TYPE_NORMAL
- en: 'If we view our user in the AWS web console, we will see that we have a new
    policy named `jea70c72mk` attached to our user, and when we click on the arrow
    next to it to drop-down the document, we can see the administrator policy placed
    inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a70a6049-18db-4ef1-ad7a-1028fe8966d2.png)'
  prefs: []
  type: TYPE_IMG
- en: Using our new administrator privileges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pacu allows us to use AWS CLI directly from Pacu CLI for situations where you
    may want to run a single command, rather than a full module. Let's use this functionality
    and our new administrator permissions to run an AWS CLI command to request data
    that we didn't previously have. This can be done just by running the AWS CLI command
    as we normally would, so that we can try running a command to enumerate other
    resources in the account. We are currently in our own personal account, so this
    command might not return any valid data for you, but it will be important to check
    this API call in other accounts that you are attacking.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check if the account has `GuardDuty` enabled in the `us-east-1` region
    by running this command from the Pacu CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `Test` account, we do have `GuardDuty` running, so we get the output
    shown in the following screenshot. But if you do not have `GuardDuty` running,
    then the `DetectorIds` field will be empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a679d048-b454-47a5-b46a-d7f24af21fc0.png)'
  prefs: []
  type: TYPE_IMG
- en: The command returned a single `DetectorId` from AWS. For this API call, the
    presence of any data means that GuardDuty has been enabled previously for this
    region, so it is safe to assume that it is still enabled without making any more
    API calls. If `GuardDuty` is disabled in the target region, `DetectorIds` will
    just be an empty list. As an attacker, it is preferable for `GuardDuty` to be
    disabled, because then we know that it is not alerting our target to any malicious
    activity that we are performing.
  prefs: []
  type: TYPE_NORMAL
- en: Even if `GuardDuty` is enabled, however, this does not mean that our efforts
    are futile. There are many factors that come into play in an attack scenario like
    this, such as if anyone is even paying attention to the `GuardDuty` alerts that
    are being triggered, the response time for someone to react to the alerts if they
    do notice one, and whether the person reacting has a strong understanding of AWS
    to be able to trace your actions fully.
  prefs: []
  type: TYPE_NORMAL
- en: We can check for `GuardDuty`, and other logging and monitoring services by running
    the `detection__enum_services` Pacu module. This module will check for CloudTrail
    configurations, CloudWatch alarms, the active shield **Distributed Denial of Service** (**DDoS**) protection
    plan, `GuardDuty` configurations, Config configurations and resources, and **virtual
    private cloud (****VPC)** flow logs. These services all have different purposes,
    but as an attacker it is important to know what is watching you and what is tracking
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Pacu has many modules within the enum category that can be used to enumerate
    various resources in our target AWS account. Some interesting modules to check
    include the `aws__enum_account` module, which enumerates information about current
    AWS account; the `aws__enum_spend` module, which gathers a list of AWS services
    that money is being spent on (so you can determine what services are in use without
    needing to query that services API directly); or the `ec2__download_userdata` module,
    which downloads and decodes the EC2 user data that is attached to each EC2 instance
    in the account.
  prefs: []
  type: TYPE_NORMAL
- en: EC2 user data is essentially just some text that you add to an EC2 instance,
    and once the instance is online that data is made available to it. This can be
    used to set up the initial configuration of an instance or provide it with settings
    or values that it might need to query later. It is also possible to execute code
    through EC2 user data.
  prefs: []
  type: TYPE_NORMAL
- en: Often, users or software will place hardcoded secrets (such as API keys, passwords,
    and environment variables) into EC2 user data. This is bad practice and is discouraged
    by Amazon in their documentation, but it continues to be a problem. As an attacker,
    this works to our benefit. EC2 user data can be read by any user with the `ec2:DescribeInstanceAttribute` permission,
    so any hardcoded secrets are also made available to them. As an attacker, it is
    important to check this data for anything that may be useful.
  prefs: []
  type: TYPE_NORMAL
- en: The `ec2__download_userdata` Pacu module will automatically go through and download
    the user data for all the instances and launch templates that were enumerated
    in the account, making it easy for us to sift through the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the following command to start the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now Pacu will check each EC2 instance that it is aware of for user data, and
    if there is any, it will download it to the `./sessions/[session name]/downloads/ec2_user_data/`
    folder inside the main Pacu directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t already enumerated EC2 instances and launch templates in the
    target account with the `ec2__enum` module, you will be prompted to run it prior
    to the module executing. You will likely be presented with a message that confirms
    if you want to run the module against every AWS region, which for right now is
    fine, so we will answer `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d93c92a6-e74e-4a18-8066-ef9ce9be44a7.png)'
  prefs: []
  type: TYPE_IMG
- en: After the EC2 instances have been enumerated, it will likely ask you the same
    question for EC2 launch templates, which also hold user data. We can allow this
    to enumerate as well.
  prefs: []
  type: TYPE_NORMAL
- en: After instances and launch templates have been enumerated, the execution will
    switch back to our original `ec2__download_userdata` module to download and decode
    the user data associated with any instances or launch templates that we found.
  prefs: []
  type: TYPE_NORMAL
- en: 'The module found three EC2 instances and one EC2 launch template in our account
    that had user data associated with them. The following screenshot shows the output
    from the module, including the results of its execution and where it stored that
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed322637-f4f9-4021-9eb3-819e9fe9e0d6.png)'
  prefs: []
  type: TYPE_IMG
- en: The `ec2__download_userdata` module found user data attached to three out of
    four EC2 instances in the account and one out of one launch template found in
    the account. It then saved that data to the `./sessions/Demo/downloads/ec2_user_data/`
    folder of the Pacu directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we navigate to the folder that these files were downloaded to and open them
    in a text editor, we can see the data in plaintext. The following screenshot shows
    that the instance with the `i-0d4ac408c4454dd9b` ID instance in the `ap-northeast-2` region had
    the user data that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc42e7e7-0963-4aa3-bc64-ddcedaa894eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is just an example to demonstrate the concept, so basically when the EC2
    instance is started up, it will run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Then it will continue the boot process. Most of the time, scripts that are passed
    into the EC2 user data are only executed when an instance is first created, but
    by using the `#cloud-boothook` directive in the preceding user data, the instance
    is instructed to run this code on every single boot instead. This is a good method
    to use to gain persistent access to EC2 instances by placing a reverse shell in
    the user data to be executed on every instance reboot, but this will be looked
    at more in further chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered how to use the Python `boto3` library to our
    advantage during an AWS pentest. It allows us to quickly and simply automate parts
    of our attack process, where we specifically covered how to enumerate IAM permissions
    for ourselves and others in the environment (in two different ways) and how to
    apply that knowledge to escalate our privileges to hopefully become a full administrator
    of the account.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at how a lot of this process has already been automated for us
    in Pacu. As nice as it would be, Pacu can't encompass every idea, attack methodology,
    or exploit that you think of, so it is important to learn how to use the AWS libraries
    to properly interact with the AWS APIs outside of Pacu. Then, with that knowledge,
    you could even begin writing your own Pacu modules for others to enjoy.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to continue using `boto3` and Pacu to establish
    persistent access for our target environment. This allows us to survive detection
    by a defender and be sure that we can maintain our access to the environment,
    even in worst-case scenarios. This allows us to help train defenders in incident
    response, so that they can understand what areas of their environment they are
    blind to, and how they can fix them. There are many kinds of potential methods
    to establish persistence in AWS, some of which have already been automated by
    Pacu, and we will take a look at using IAM and Lambda to deploy methods like these.
  prefs: []
  type: TYPE_NORMAL
