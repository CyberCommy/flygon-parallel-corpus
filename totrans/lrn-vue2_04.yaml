- en: Chapter 4. Reactivity – Binding Data to Your Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。反应性-将数据绑定到您的应用程序
- en: In the previous chapter, you learned one of the most important concepts of Vue.js: components.
    You saw how to create components, how to register, how to invoke, and how to use
    and reuse them. You also learned the concept of single-file components and even
    used them in the shopping list and Pomodoro applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学习了Vue.js中最重要的概念之一：组件。您看到了如何创建组件，如何注册，如何调用以及如何使用和重用它们。您还学习了单文件组件的概念，甚至在购物清单和番茄钟应用程序中使用了它们。
- en: In this chapter, we will go deeper into the concept of data binding. We have
    already talked about it earlier, so you are already familiar with it. We will
    bind data in all possible ways in our components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨数据绑定的概念。我们之前已经谈论过它，所以你已经很熟悉了。我们将以所有可能的方式在我们的组件中绑定数据。
- en: 'Summing it up, in this chapter, we are going to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在本章中，我们将：
- en: Revisit the data binding syntax
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视数据绑定语法
- en: Apply data binding in our applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的应用程序中应用数据绑定
- en: Iterate over the array of elements and render each element using the same template
    with different data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历元素数组，并使用相同的模板渲染每个元素
- en: Revisit and apply the shorthands of data and events binding in our applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视并应用数据和事件绑定的速记方式在我们的应用程序中
- en: Revisiting data binding
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视数据绑定
- en: We have been talking about data binding and reactivity starting from the very
    first chapter. So, you already know that data binding is a mechanism of propagating
    changes from the data to the visible layer and vice versa. In this chapter, we
    will carefully revisit all the different ways of data binding and apply them in
    our applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从第一章开始就一直在谈论数据绑定和反应性。所以，你已经知道数据绑定是一种从数据到可见层以及反之的变化传播机制。在本章中，我们将仔细审视所有不同的数据绑定方式，并在我们的应用程序中应用它们。
- en: Interpolating data
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入数据
- en: 'Let''s imagine the following piece of HTML code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下以下的HTML代码：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Also, imagine the following JavaScript object:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 还想象以下JavaScript对象：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How can we render the values of data entries on the page? How can we access
    them so that we can use them inside our HTML? Actually, we have been doing this
    a lot with Vue.js during the last two chapters. There is no problem in understanding
    and doing it again and again.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在页面上呈现数据条目的值？我们如何访问它们，以便我们可以在HTML中使用它们？实际上，在过去的两章中，我们已经在Vue.js中大量做了这个。理解并一遍又一遍地做这件事并没有问题。
- en: '*"Repetitio est mater studiorum"*'
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “重复是学习之母”
- en: If you are already a professional of data interpolation, just skip this section
    and proceed to the expressions and filters.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经是数据插值的专业人士，只需跳过本节，然后继续表达式和过滤器。
- en: 'So, what should we do to populate the `<div>` with the value of `msg`? If we
    go the old-fashioned jQuery way, we would probably do something like the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们应该怎么做才能用`msg`的值填充`<div>`？如果我们按照老式的jQuery方式，我们可能会做类似以下的事情：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: But then, during runtime, if you change the value of `msg` and if you want this
    change to be propagated to the DOM, you must do it manually. By simply changing
    the `data.msg` value, nothing will happen.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在运行时，如果您更改`msg`的值，并且希望这种更改传播到DOM，您必须手动执行。仅仅改变`data.msg`的值，什么也不会发生。
- en: 'For example, let''s write the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们编写以下代码：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then the text that will appear in the `<div>` will, of course, be `Hello`. Check
    this JSFiddle at   [https://jsfiddle.net/chudaol/uevnd0e4/](https://jsfiddle.net/chudaol/uevnd0e4/).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后出现在`<div>`中的文本将是`Hello`。在[https://jsfiddle.net/chudaol/uevnd0e4/](https://jsfiddle.net/chudaol/uevnd0e4/)上检查这个JSFiddle。
- en: 'With Vue, the simplest interpolation is done with `{{ }}` (handlebars annotation).
    In our example, we would write the following HTML code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vue，最简单的插值是用`{{ }}`（句柄注释）完成的。在我们的示例中，我们将编写以下HTML代码：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The content of the `<div>` thus becomes bound to the `msg` data. Each time `msg`
    changes, the content of the `div` changes automatically following its content.
    Have a look at the jsfiddle example at [https://jsfiddle.net/chudaol/xuvqotmq/1/](https://jsfiddle.net/chudaol/xuvqotmq/1/)
    . `data.msg` is also changed after the Vue instantiation. The value that appears
    on the screen is the new one!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`<div>`的内容将与`msg`数据绑定。每次`msg`更改时，`div`的内容都会自动更改其内容。请查看[https://jsfiddle.net/chudaol/xuvqotmq/1/](https://jsfiddle.net/chudaol/xuvqotmq/1/)上的jsfiddle示例。Vue实例化后，`data.msg`也会更改。屏幕上显示的值是新的值！
- en: It is still one-way binding interpolation. If we change the value in the DOM,
    nothing will happen to data. Still, if we only need the values of the data to
    appear in the DOM and to be changed accordingly, it is a perfect and valid approach.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然是单向绑定的插值。如果我们在DOM中更改值，数据将不会发生任何变化。但是，如果我们只需要数据的值出现在DOM中，并相应地更改，这是一种完美有效的方法。
- en: At this moment, it should be really clear that if we want to use the values
    of the `data` object inside the template, we should surround them with `{{}}`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，应该非常清楚，如果我们想在模板中使用`data`对象的值，我们应该用`{{}}`将它们括起来。
- en: 'Let''s add the missing interpolations to our Pomodoro application. Please check
    the current situation in the [chapter4/pomodoro](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/pomodoro)
    folder. If you run `npm run dev` and have a look at the opened page, you will
    see that the page looks like the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向我们的番茄钟应用程序添加缺失的插值。请在[chapter4/pomodoro](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/pomodoro)文件夹中检查当前情况。如果您运行`npm
    run dev`并查看打开的页面，您将看到页面如下所示：
- en: '![Interpolating data](../Images/image00273.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![插入数据](../Images/image00273.jpeg)'
- en: Missing interpolations in our Pomodoro application
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们番茄钟应用程序中缺少的插值
- en: From the very first glance at the page, we are able to identify what is missing
    there.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从对页面的第一眼扫视中，我们能够确定那里缺少什么。
- en: The page is missing the timer, the kittens, the title of the Pomodoro state
    (the one that displays **`Work!`** or **`Rest!`**), and the logic that shows or
    hides the kittens' placeholder according to the Pomodoro state. Let's start by
    adding the title of the Pomodoro state and the minutes and seconds of the Pomodoro
    timer.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 页面缺少计时器、小猫、番茄钟状态的标题（显示**`工作！`**或**`休息！`**）、以及根据番茄钟状态显示或隐藏小猫占位符的逻辑。让我们首先添加番茄钟状态的标题和番茄钟计时器的分钟和秒。
- en: Adding title of the Pomodoro state
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加番茄钟状态的标题
- en: 'First of all, we should decide what component this element should belong to.
    Have a look at our four components. It is more than obvious that it should belong
    to `StateTitleComponent`. If you look at the following code, you will see that
    it actually already interpolates the title in its template:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该决定这个元素应该属于哪个组件。看看我们的四个组件。很明显，它应该属于`StateTitleComponent`。如果您查看以下代码，您将看到它实际上已经在其模板中插值了标题：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Good! In the previous chapter, we''ve already done most of the work. Now we
    just have to add the data that must be interpolated. In the `<script>` tag of
    this component, let''s add the `data` object with the `title` attribute inside.
    For now, let''s hardcode it to one of the possible values and then decide how
    to change it. What do you prefer? **`Work!`** or **`Rest!`**? I think I know the
    answer, so let''s add the following code to our `script` tag:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 好！在上一章中，我们已经完成了大部分工作。现在我们只需要添加必须被插值的数据。在这个组件的`<script>`标签中，让我们添加带有`title`属性的`data`对象。现在，让我们将其硬编码为可能的值之一，然后决定如何更改它。你更喜欢什么？**`工作！`**
    还是 **`休息！`**？我想我知道答案，所以让我们将以下代码添加到我们的`script`标签中：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's leave it like this for now. We will come back to this later in the methods
    and event handling section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就让它保持这样。我们将在以后的方法和事件处理部分回到这个问题。
- en: Exercise
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: In the same way in which we added the title of the Pomodoro state, please add
    the minutes and seconds timer counters to the `CountDownComponent`. They can be
    hardcoded for now.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以与我们添加Pomodoro状态标题相同的方式，请将分钟和秒计时器计数器添加到`CountDownComponent`中。它们现在可以是硬编码的。
- en: Using expressions and filters
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用表达式和过滤器
- en: In the previous example, we have used simple property keys inside the `{{}}`
    interpolations. Actually, Vue supports a lot more inside these nice curly brackets.
    Let's see what it is possible to do there.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在`{{}}`插值中使用了简单的属性键。实际上，Vue在这些花括号中支持更多的内容。让我们看看在那里可能做些什么。
- en: Expressions
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式
- en: It might sound unexpected, but Vue supports full JavaScript expressions inside
    the data binding brackets! Let's go to any of the Pomodoro application components
    and add any JavaScript expression to the template. You can do some experiments
    in the [chapter4/pomodoro2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/pomodoro2)
    folder.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来出乎意料，但Vue支持在数据绑定括号内使用完整的JavaScript表达式！让我们去Pomodoro应用程序的任何一个组件，并在模板中添加任何JavaScript表达式。你可以在[chapter4/pomodoro2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/pomodoro2)文件夹中进行一些实验。
- en: 'Try, for example, to open the `StateTitleComponent.vue` file. Let''s add some
    JavaScript expression interpolation to its template, for example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，尝试打开`StateTitleComponent.vue`文件。让我们在其模板中添加一些JavaScript表达式插值，例如：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Actually, you just need to uncomment the following lines:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你只需要取消注释以下行：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You will see number **`25`** on the page. Nice, isn''t it? Let''s replace some
    of our data bindings in the Pomodoro application with a JavaScript expression.
    For example, in the `CountdownComponent` component''s template, two directives,
    each for `min` and `sec`, can be replaced by one expression. Currently it looks
    as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在页面上看到数字**`25`**。很好，不是吗？让我们用JavaScript表达式替换Pomodoro应用程序中的一些数据绑定。例如，在`CountdownComponent`组件的模板中，每个用于`min`和`sec`的指令可以被一个表达式替换。目前它看起来是这样的：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can replace it with the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下代码替换它：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Where else can we add some expressions? Let''s have a look at `StateTitleComponent`.
    At this moment, we use the hardcoded title. We know, however, that somehow it
    should depend on the Pomodoro state. If it is in the *working* state, it should
    display **`Work!`**, otherwise it should display **`Rest!`**. Let''s create this
    attribute and call it `isworking`, and let''s assign it to the main `App.vue`
    component because it seems to belong to the global application state. Then we
    will reuse it inside the `StateTitleComponent` component''s `props` attribute.
    Thus, open `App.vue`, and add the Boolean property `isworking` and set it to `true`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 还有哪些地方可以添加一些表达式呢？让我们看看`StateTitleComponent`。此刻，我们使用的是硬编码的标题。然而，我们知道它应该以某种方式依赖于番茄钟的状态。如果它处于“工作”状态，它应该显示**`Work!`**，否则应该显示**`Rest!`**。让我们创建这个属性并将其命名为`isworking`，然后将其分配给主`App.vue`组件，因为它似乎属于全局应用状态。然后我们将在`StateTitleComponent`组件的`props`属性中重用它。因此，打开`App.vue`，添加布尔属性`isworking`并将其设置为`true`：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s now reuse this property in `StateTitleComponent`, add two string properties
    for each of the possible titles, and, finally, add the expression in the template
    that will conditionally render one title or another accordingly to the current
    state. Thus, the script of the component will look like the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在`StateTitleComponent`中重用这个属性，在每个可能的标题中添加两个字符串属性，并最后在模板中添加表达式，根据当前状态有条件地渲染一个标题或另一个标题。因此，组件的脚本将如下所示：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we can conditionally render one title or another based on the `isworking`
    property. Thus, the template of `StateTitleComponent` will look like the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以根据`isworking`属性有条件地渲染一个标题或另一个标题。因此，`StateTitleComponent`的模板将如下所示：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Look at the refreshed page. Strangely, it shows **`Rest!`** as the title. How
    did this happen if the `isworking` property is set to `true` in `App.vue`? We
    simply forgot to bind this property on the component invocation in the `App.vue`
    template! Open the `App.vue` component and add the following code on the `state-title-component`
    invocation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下刷新后的页面。奇怪的是，它显示**`Rest!`**作为标题。如果`App.vue`中的`isworking`属性设置为`true`，那么这是怎么发生的？我们只是忘记在`App.vue`模板中的组件调用上绑定这个属性！打开`App.vue`组件，并在`state-title-component`调用上添加以下代码：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, if you look at the page, the correct title appears as **`Work!`** If you
    open the devtools console and type `data.isworking = false`, you will see the
    title changing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你查看页面，正确的标题会显示为**`Work!`**。如果你打开开发工具控制台并输入`data.isworking = false`，你会看到标题改变。
- en: 'If the `isworking` attribute is `false`, the title is **`Rest!`**, as shown
    in the following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`isworking`属性为`false`，标题为**`Rest!`**，如下截图所示：
- en: '![Expressions](../Images/image00274.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![Expressions](../Images/image00274.jpeg)'
- en: 'If the `isworking` attribute is `true`, the title is **`Work!`**, as shown
    in the following screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`isworking`属性为`true`，标题为**`Work!`**，如下截图所示：
- en: '![Expressions](../Images/image00275.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![Expressions](../Images/image00275.jpeg)'
- en: Filters
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤器
- en: 'Besides expressions inside the curly interpolation brackets, it is also possible
    to use filters that are applied to the result of the expression. Filters are just
    functions. They are created by us and applied by using the pipe symbol:  `|`.
    If you create a filter that makes letters uppercase and call it uppercase, in
    order to apply it, just use it after the pipe symbol inside the mustache interpolation:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了花括号内的表达式之外，还可以使用应用于表达式结果的过滤器。过滤器只是函数。它们是由我们创建的，并且通过使用管道符号`|`应用。如果你创建一个将字母转换为大写的过滤器并将其命名为`uppercase`，那么要应用它，只需在双大括号内的管道符号后面使用它：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can chain as many filters as you want, for example, if you have filter
    `A`, `B`, `C`, you can do something like `{{ key | A | B | C }}`. Filters are
    created using `Vue.filter` syntax. Let''s create our `lowercase` filter:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以链接尽可能多的过滤器，例如，如果你有过滤器`A`，`B`，`C`，你可以做类似`{{ key | A | B | C }}`的事情。过滤器是使用`Vue.filter`语法创建的。让我们创建我们的`lowercase`过滤器：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s apply it to the Pomodoro title in the main `App.vue` component. In order
    to be able to use the filter, we should pass the `''Pomodoro''` string inside
    the handlebars interpolation notation. We should pass it as a JavaScript string
    expression and apply a filter using the pipe symbol:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其应用到主`App.vue`组件中的Pomodoro标题。为了能够使用过滤器，我们应该将`'Pomodoro'`字符串传递到句柄插值符号内。我们应该将它作为JavaScript字符串表达式传递，并使用管道符号应用过滤器：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Check the page; the **`Pomodoro`** title will actually appear written in the
    lowercase syntax.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 检查页面；**`Pomodoro`**标题实际上将以小写语法显示。
- en: Let's revisit our `CountdownTimer` component and have a look at the timer. For
    now, there are only hardcoded values, right? But when the application is fully
    functional, the values will come from some computation. The range of values will
    be from 0 to 60\. It is okay if the timer shows **`20:40`**, but it is not okay
    for fewer than ten values. For example, when it is only 1 minute and 5 seconds,
    it will be **`1:5`**, which is not good. We are expecting to see something like
    **`01:05`**. So, we need the `leftpad` filter! Let's create it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视我们的`CountdownTimer`组件并查看计时器。目前，只有硬编码的值，对吧？但是当应用程序完全功能时，值将来自某些计算。值的范围将从0到60。计时器显示**`20:40`**是可以的，但少于十的值是不可以的。例如，当只有1分钟和5秒时，它将是**`1:5`**，这是不好的。我们希望看到类似**`01:05`**的东西。所以，我们需要`leftpad`过滤器！让我们创建它。
- en: 'Go to the `main.js` file and add a `leftpad` filter after the uppercase filter
    definition:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 转到`main.js`文件，并在大写过滤器定义之后添加一个`leftpad`过滤器：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Open the `CountdownComponent` component and let''s again split `min` and `sec`
    to the different interpolation brackets and add filters to each of them:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`CountdownComponent`组件，让我们再次将`min`和`sec`拆分到不同的插值括号中，并为每个添加过滤器：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Replace `min` and `sec` in data with 1 and 5, respectively, and have a look.
    The numbers appear with a preceding "0"!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 用1和5替换数据中的`min`和`sec`，然后查看。数字出现了前面的"0"！
- en: Exercise
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Create two filters, `uppercase` and `addspace`, and apply them to the title
    **`Pomodoro:`**
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个过滤器，`大写`和`addspace`，并将它们应用到标题**`Pomodoro:`**
- en: The `uppercase` filter must do exactly what it says it does
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`大写`过滤器必须做到它所说的那样'
- en: The `addspace` filter must add a space on the right of the given string value
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addspace`过滤器必须在给定的字符串值右侧添加一个空格'
- en: 'Do not forget that **`Pomodoro`** is not a key, so inside the interpolation
    brackets, it should be treated as a string! The title before and after this exercise
    would look something like the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记**`Pomodoro`**不是一个关键字，所以在插值括号内，它应该被视为一个字符串！在这个练习之前和之后的标题看起来应该是这样的：
- en: '![Exercise](../Images/image00276.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![练习](../Images/image00276.jpeg)'
- en: The title of the Pomodoro application before and after applying filters uppercase
    and addspace
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用过滤器大写和添加空格之前和之后的Pomodoro应用程序的标题
- en: 'Check yourself: have a look at the [chapter4/pomodoro3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/pomodoro3)
    folder.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 自己检查：查看[chapter4/pomodoro3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/pomodoro3)文件夹。
- en: Revisiting and applying directives
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视和应用指令
- en: 'In the previous section, we saw how to interpolate the application''s data
    and how to bind it to the visual layer. Though the syntax is pretty powerful and
    offers a high possibility of data modification (using filters and expressions),
    it has some limitations. Try, for example, to implement the following using `{{}}`
    notation:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Use the interpolated data in the user input and apply the changes to the corresponding
    data when the user types in the input
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bind a specific element's attribute (for example, `src`) to the data
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render some element conditionally
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterate through an array and render some component with the elements of the
    array
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create event listeners on the elements
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s try at least the first one. Open, for example, the shopping list application
    (it''s in the [chapter4/shopping-list](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list)
    folder). Create an `input` element in the `App.vue` template and set its value
    to `{{ title }}`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Oh no! Errors, errors everywhere. **`Interpolation inside attributes has been
    removed,`** it says. Does it mean that prior to Vue 2.0 you could easily use the
    interpolation inside attributes? Yes, and no. You would not get an error if you'd
    use interpolations inside attributes, but changing the title inside the input
    would result in nothing. In Vue 2.0, as well as in the prior versions, to achieve
    this kind of behavior, we must use directives.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Directives** are special attributes of the elements that have a `v-` prefix.
    Why `v-`? Because Vue! Directives provide a tiny syntax that provides a richer
    set of possibilities than simple text interpolation. They have the power to reactively
    apply some special behavior to the visual layer on each data change.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Two-way binding using the v-model directive
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two-way binding is a type of binding where not only data changes are propagated
    to the DOM layer, but also the changes that occur to the bound data in the DOM
    are propagated to the data. To bind the data in such a way to the DOM, we can
    use the `v-model` directive.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'I am sure you still remember from the first chapter that the `v-model` directive
    is used as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this way, the value of the title will appear in the input, and if you type
    something in this input, the corresponding change will be immediately applied
    to the data and reflected in all interpolated values on the page.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Just replace the handlebars notation with `v-model` and open the page.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Try to type something in the input. You will see how the title is immediately
    changed!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Just remember, this directive can only be used with the following elements:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '`<input>`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<select>`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<textarea>`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try all of them and then delete this code. Our main purpose is to be able to
    change the title using the change title component.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Two-way binding between components
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember from the previous chapter that two-way binding between components cannot
    be easily achieved using the `v-model` directive. Due to architectural reasons,
    Vue just prevents children from easily changing the parents' scope.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: That's why we used the events system in the previous chapter to be able to change
    the title of the shopping list from the child component.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: We will do it again in this chapter. Just wait couple of paragraphs until we
    reach the section on `v-on` directives.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Binding attributes using the v-bind directive
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `v-bind` directive allows us to bind an element''s `attribute` or a `component`
    property to an expression. In order to apply it to the specific attribute, we
    use a colon delimiter:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '`v-bind:src="src"`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v-bind:class="className"`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any expression can be written inside the `""`. The data properties can be used
    as well, just like in the previous examples. Let's add the kitten image to `KittenComponent`
    in our Pomodoro application using `thecatapi` as the source. Open our Pomodoro
    application from the [chapter4/pomodoro3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/pomodoro3)
    folder.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `KittenComponent`, add `catimgsrc` to the component''s data, and bind
    it to the image template using `v-bind` syntax with the `src` attribute:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Open the page. Enjoy the kitten!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![Binding attributes using the v-bind directive](../Images/image00277.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: Pomodoro KittenComponent with applied source attribute
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Conditional rendering using v-if and v-show directives
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have paid enough attention in the earlier sections, and if I ask you
    to conditionally render something, you might be actually able to do it using JavaScript
    expressions inside the interpolation brackets `{{ }}`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: However, try to conditionally render some element or the whole component. It
    might not be as simple as applying an expression inside the brackets.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'The `v-if` directive allows to conditionally render the whole element, which
    might also be a component element depending on some condition. The condition can
    be any expression and it can use the data properties as well. For example, we
    can do the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Or even:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Or using the component''s data:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `v-show` attribute does the same job. The only difference is that `v-if`
    will or will not render the element to the condition accordingly, whereas the
    `v-show` attribute will always render the element, just applying `display:none`
    CSS property when the result of the condition is `false`. Let's see the difference.
    Open the `beer-time` project in the [chapter4/beer-time](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/beer-time)
    folder. Run `npm install` and `npm run dev`. Open the `App.vue` component and
    play with `true`/`false` values, and try to replace `v-if` with `v-show`. Open
    devtools and check the **`elements`** tab.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Let's first check how it looks when we switch between `true` and `false` in
    the `isadmin` property value using `v-if`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'When the condition is met, everything appears as expected; the element is rendered
    and appears on the page:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![Conditional rendering using v-if and v-show directives](../Images/image00278.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: Conditional rendering using the v-if directive. Condition is met.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'When the condition is not met, the element is not rendered:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![Conditional rendering using v-if and v-show directives](../Images/image00279.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: Conditional rendering using the v-if directive. Condition is not met.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Note that when the condition is not fulfilled, the corresponding element is
    not rendered at all!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s play with the condition result value using the `v-show` directive. When
    the condition is met, it appears in exactly the same way as it was in the previous
    case using `v-if`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![Conditional rendering using v-if and v-show directives](../Images/image00280.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: Conditional rendering using the v-show directive. Condition is met.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s check what will happen with the element using the `v-show` directive
    when the right condition is not met:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![Conditional rendering using v-if and v-show directives](../Images/image00281.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: Conditional rendering using the v-show directive. Condition is not met.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: In this case, everything is the same when the condition is met, but when the
    condition is not fulfilled, the element is rendered as well with the `display:none`
    CSS property.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: How do you decide which one is better to use? On the first render, if the condition
    is not met, the `v-if` directive will not render the element at all, hence reducing
    the computation costs on the initial rendering. But, if the property changes frequently
    during runtime, the cost of rendering/removing an element is higher than just
    to apply the `display:none` property. Thus, use `v-show` with frequently changing
    properties and `v-if` if the condition will not change too much during runtime.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Let's come back to our Pomodoro application. `KittensComponent` should be conditionally
    rendered when Pomodoro is not in its working state. So, open your Pomodoro application
    code in the [chapter4/pomodoro4](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/pomodoro4)
    folder.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'What do you think should be used? `v-if` or `v-show`? Let''s analyze. Independently
    from what we use, should this element be visible on the initial render? The answer
    is no, because on the initial render, the user starts her working day and starts
    the Pomodoro timer. It might be better to use `v-if` to not have the cost of initial
    rendering when there is no need. But, let''s analyze another factor—the frequency
    of toggling the state that will make the kittens component visible/invisible.
    This will happen at each Pomodoro interval, right? After 15-20 minutes of work
    and then after 5 minutes of rest interval, which is, actually, not so frequent
    and will not affect the cost of rendering that much. In this case, in my opinion,
    it doesn''t matter which one you use. Let''s use `v-show`. Open the `App.vue`
    file and apply the `v-show` directive to the `kittens-component` invocation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Open the page and try to toggle the value of `data.isworking` in the devtools
    console. You will see how the **kittens** container appears and disappears.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Array iteration using the v-for directive
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You probably remember that array iteration is done using the `v-for` directive
    with the following syntax:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Or with components:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For each item in the array, this will render a component and bind the component's `item`
    property to the value of the item. Of course, you remember that inside the `""`
    of the binding syntax you can use whatever JavaScript expression you want. So,
    just be creative!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not forget that the property we use in the binding syntax (`componentitem`)
    should be present in the component's data!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look, for example, at our shopping list application (The [chapter4/shopping-list](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list)
    folder). It already uses the `v-for` syntax in `ItemsComponent` to render the
    list of items:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`ItemComponent`, in turn, has the `item` property declared using `props`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, let's do something interesting with our shopping list application. Until
    now we were dealing only with one shopping list. Imagine that you want to have
    a different shopping list for different kind of shopping. For example, you might
    have a regular shopping list for the normal groceries shopping day. You might
    have a different shopping list for the holidays. You might also want to have a
    different shopping list when you buy a new house. Let's use the power of the reusability
    of the Vue components and transform our shopping list application into the list
    of shopping lists! We will display them using Bootstrap's tab panel; for more
    information, refer to [http://getbootstrap.com/javascript/#tabs](http://getbootstrap.com/javascript/#tabs)
    .
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Open your shopping list application in the IDE (the [chapter4/shopping-list](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list)
    folder).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we should add Bootstrap''s JavaScript file and jQuery, because
    bootstrap relies on it for doing its amazing magic. Go on and just add them manually
    to the `index.html` file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let''s establish a step-by-step overview of what we should do in order
    to transform our application into the list of shopping lists:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we must create a new component. Let's call it `ShoppingListComponent`
    and move the content of our current `App.vue` to there.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our new `ShoppingListComponent` should contain the `props` attribute with `title`
    and `items` that it will receive from `App.vue`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ItemsComponent` should receive `items` from the `props` attribute rather than
    having it hardcoded.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `App` component's `data`, let's declare and hardcode (for now) an array of
    `shoppinglists`, each of the items should have a title, an array of items, and
    an ID.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`App.vue` should import `ShoppingListComponent`, and in the template, iterate
    over the `shoppinglists` array, and for each of them, build the `html/jade` structure
    of the tabs panel for each of the shopping lists.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Okay, then, let's start!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Creating ShoppingListComponent and modifying ItemsComponent
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inside the `components` folder, create a new `ShoppingListComponent.vue`. Copy
    and paste the `App.vue` file''s content into this new file. Do not forget to declare
    `props` that will contain `title` and `items` and bind `items` to the `items-component`
    invocation inside the template. Your final code for this component should look
    something like the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that we removed the styling for the container and the container's `class`
    from the parent `div`. This part of the code should stay in `App.vue` because
    it defines the global application's container styling. Do not forget about the
    `props` attribute and binding `props` to `items-component`!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `ItemsComponent.vue` and ensure that it contains the `props` attribute
    with `items`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Modifying App.vue
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now go to `App.vue`. Remove all the code inside the `<script>` and `<template>`
    tags. In the `script` tag, import `ShoppingListComponent` and invoke it inside
    the `components` property:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add a `data` attribute and create a `shoppinglists` array there. Add arbitrary
    data for this array. Each of the objects of the array should have `id`, `title`,
    and `items` attributes. `items`, as you remember, must contain the `checked` and
    `text` properties. For example, your `data` property might look like the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Be more creative than me: add more lists, more items, something nice and interesting!'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create a structure for composing the bootstrap tab panel based on
    iteration over the shopping list! Let''s start by defining a basic structure needed
    for tabs to work. Let''s add all the necessary classes and jade structure pretending
    that we have only one element. Let''s also write in Caps Lock all the unknowns
    that will be reused from our shopping list array:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'There are two elements where we need to iterate over the shopping lists array—the
    `<li>` tag that contains an `<a>` attribute and the `tab-pane` div. In the first
    case, we must bind the ID of each shopping list to the `href` and `aria-controls`
    attribute and interpolate the title. In the second case, we need to bind the `id`
    attribute to the `id` property and render the shopping list item and bind the
    `items` array and `title` to it. Easy! Let''s go. Start by adding the `v-for`
    directive to each of the elements (to the `<li>` and to the `tab-pane div` element):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now replace the parts in Caps Lock with the proper bindings. Remember that to
    the `bind` attribute, we use the `v-bind:<corresponding_attribute>="expression"`
    syntax.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `href` attribute of the anchor element, we have to define an expression
    that appends the ID selector `#` to `id: v-bind:href="''#'' + list.id"`. The `aria-controls`
    attribute should be bound to the value of the ID. `title` can be bound using the
    simple `{{ }}` notation interpolation.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: For `shopping-list-component`, we must bind `title` and `items` to the corresponding
    values of the list item. Do you remember that we defined the `title` and `items`
    properties inside the `props` of the `ShoppingListComponent`? The bindings, thus,
    should look like `v-bind:title=list.title` and `v-bind:items=list.items`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'So after the proper binding attribution, the template will look like the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We''re almost done! If you open the page now, you will see both of the titles
    of the tabs appearing on the page:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![Modifying App.vue](../Images/image00282.jpeg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: Tab titles as seen on the screen after the modification
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: If you start clicking on the tabs titles, the corresponding tab panes will open.
    But this is not what we were expecting to see, right? What we were expecting is
    for the first tab to be visible (active) by default. For this to happen, we should
    add the `active` class  to the first `li` and to the first `tab-pane div`. But
    how can we do it if the code is the same for all the tabs as long as we are iterating
    through the array?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, for us, Vue allows us to provide not only the *iteration item*
    inside the `v-for` loop, but also `index`, and then reuse this `index` variable
    inside the expressions used in the templates. Thus, we can use it to conditionally
    render the `active` class if the index is "0". Using the `index` variable inside
    the `v-for` loop is as easy as the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The syntax for class binding is the same as for everything else (`class` is
    also an attribute):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Do you remember that we can write any JavaScript expression inside the quotes?
    In this case, we want to write a condition that evaluates the value of `index`,
    and in case it is "0", the value of class is `active`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add the `index` variable to the `v-for` modifiers and the `class` bindings
    to the `li` and to the `tab-pane` element, so that the final template code looks
    like following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Look at the page. Now you should see nice tabs that display the content by
    default:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![Modifying App.vue](../Images/image00283.jpeg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: The look and feel of  the shopping list application after the correct class
    binding
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: The final shopping list application code after these modifications can be found
    in the [chapter4/shopping-list2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list2)
    folder.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Event listeners using the v-on directive
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is very easy to listen to the events and call callbacks using Vue.js. Event
    listening is also done using a special directive with specific modifiers for each
    of the event types. The directive is `v-on`. The modifiers are applied after the
    colon:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Ok, you say, and where do I declare this method? You will probably not believe
    me, but all the component''s methods are declared inside the `methods` property!
    So, to declare the method called `myMethod`, you should do the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: All the `data` and `props` attributes are accessible inside the methods using
    the `this` keyword.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a method to add a new item to the `items` array. We have actually
    done it already in the previous chapter, when we learned how to pass data between
    parent and children components using the events emitting system. We will just
    recap this part here.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to be able to add new items within `AddItemComponent` to the shopping
    list that belongs to `ShoppingListComponent`, we should do the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that `AddItemComponent` has a `data` property called `newItem`.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an `addItem` method inside the `AddItemComponent` that pushes the `newItem`
    and emits the event `add`.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply an event listener to the **`Add!`** button using the `v-on:click` directive.
    This event listener should call the defined `addItem` method.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an `addItem` method inside the `ShoppingListComponent` that will receive
    the `text` as a parameter and push it to the `items` array.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bind the `v-on` directive with a custom `add` modifier to the `add-item-component`
    invocation inside the `ShoppingListComponent`. This listener will call the `addItem`
    method defined in this component.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's go then! Use the shopping list application from the [chapter4/shopping-list2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list2)
    folder and play with it.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by opening `AddItemComponent` and add the missing `v-on` directive to
    the **`Add!`** button and the `addItem` method:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Switch to `ShoppingListComponent` and bind the `v-on:add` directive to the
    invocation of `add-item-component` inside the `template` tag:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now create the `addItem` method inside the `ShoppingListComponent`. It should
    receive the text and just push it into the `this.items` array:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Open the page and try to add the items to the list by typing in the input box
    and clicking the button afterward. It works!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Now, I would like to ask you to switch your role from the application's developer
    to its user. Type the new item in the input box. What is the obvious user action
    after the item has been introduced? Aren't you trying to hit the *Enter* button?
    I bet you are! When nothing is happening, it is a little bit frustrating, isn't
    it? Don't worry, my friend, we just have to add one more event listener to the
    input box and call the same method as we did with the **`Add!`** button.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Sounds easy, right? What event is fired when we''re hitting the *Enter* button?
    Right, it is the keyup event. So, we just have to use the `v-on` directive with
    the `keyup` method after the delimiter colon: `v-on:keyup`. The problem is that
    this event is fired when any keyboard button is hit, which means that while we''re
    typing the new shopping list item, each time the new letter is being introduced,
    the method will be called. This is not what we want. Of course, we could add a
    condition inside our `addItem` method that would check for the `event.code` attribute
    and, only in case it''s `13` (which corresponds to the *Enter* key), we would
    call the rest of the method. Fortunately, for us, Vue provides a mechanism to
    provide keystroke modifiers to this method that allows us to only call a method
    if a certain key code was hit. It should be implemented using the dot (`.`) modifier.
    In our case, it is as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s add it to our input box. Go to `AddItemComponent` and add the `v-on:keyup.enter` directive
    to the input as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Open the page and try to add the item to the shopping list using the *Enter*
    button. It works!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do the same for title changing. The only difference is that the adding
    items, we used a custom `add` event and here we will use the native input event.
    We have already done it. We just have to perform the following steps:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Bind the model title using the `v-model` directive to `change-title-component`
    in the template of the `ShoppingListComponent`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Export `value` in the `props` attribute of the `ChangeTitleComponent`.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `onInput` method inside the `ChangeTitleComponent` that will emit
    the native `input` method with the value of the event target.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind `value` to `input` inside the `ChangeTitleComponent` component's template
    and the `v-on` directive with the `onInput` modifier.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Thus, the `change-title-component` invocation inside the `ShoppingListComponent`
    template will look like the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`ChangeTitleComponent` will look like the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The final code for this part can be found in the [chapter4/shopping-list3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list3)
    folder.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Shorthands
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of course, it is not time consuming to write the `v-bind` or `v-on` directive
    in the code each time. Developers tend to think that each time we decrease the
    amount of code, we win. Vue.js allows us to win! Just remember that the shorthand
    for the `v-bind` directive is a colon (`:`) and the shorthand for the `v-on` directive
    is the `@` symbol. This means that the following code does the same thing:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Exercise
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rewrite all the `v-bind` and `v-on` directives in the shopping list application
    using the shortcuts we just learned.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Check yourself by looking at the [chapter4/shopping-list4](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list4)
    folder.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Kittens
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we haven''t touched a lot on our Pomodoro application with
    its nice kittens. I promise you that we''ll do a lot of it in the next chapter.
    In the meantime, I hope that this kitten will make you happy:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![Kittens](../Images/image00284.jpeg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: Kitten asking "What's next?"
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had an extensive overview of all the possible ways of binding
    data to our presentation layer. You learned how to simply interpolate data using
    handlebars brackets (`{{ }}`). You also learned how to use JavaScript expressions
    and filters in such an interpolation. You learned and applied directives such
    as `v-bind`, `v-model`, `v-for`, `v-if`, and `v-show`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: We modified our applications so that they use richer and more efficient data-binding
    syntax.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about Vuex**,** the state management architecture
    inspired by Flux and Redux but with simplified concepts.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: We will create global application state management stores for both of our applications
    and explore their potential by working with it.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
