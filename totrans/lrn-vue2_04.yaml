- en: Chapter 4. Reactivity – Binding Data to Your Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned one of the most important concepts of Vue.js: components.
    You saw how to create components, how to register, how to invoke, and how to use
    and reuse them. You also learned the concept of single-file components and even
    used them in the shopping list and Pomodoro applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will go deeper into the concept of data binding. We have
    already talked about it earlier, so you are already familiar with it. We will
    bind data in all possible ways in our components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing it up, in this chapter, we are going to:'
  prefs: []
  type: TYPE_NORMAL
- en: Revisit the data binding syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply data binding in our applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterate over the array of elements and render each element using the same template
    with different data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revisit and apply the shorthands of data and events binding in our applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revisiting data binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been talking about data binding and reactivity starting from the very
    first chapter. So, you already know that data binding is a mechanism of propagating
    changes from the data to the visible layer and vice versa. In this chapter, we
    will carefully revisit all the different ways of data binding and apply them in
    our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolating data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s imagine the following piece of HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, imagine the following JavaScript object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How can we render the values of data entries on the page? How can we access
    them so that we can use them inside our HTML? Actually, we have been doing this
    a lot with Vue.js during the last two chapters. There is no problem in understanding
    and doing it again and again.
  prefs: []
  type: TYPE_NORMAL
- en: '*"Repetitio est mater studiorum"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you are already a professional of data interpolation, just skip this section
    and proceed to the expressions and filters.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what should we do to populate the `<div>` with the value of `msg`? If we
    go the old-fashioned jQuery way, we would probably do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: But then, during runtime, if you change the value of `msg` and if you want this
    change to be propagated to the DOM, you must do it manually. By simply changing
    the `data.msg` value, nothing will happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Then the text that will appear in the `<div>` will, of course, be `Hello`. Check
    this JSFiddle at   [https://jsfiddle.net/chudaol/uevnd0e4/](https://jsfiddle.net/chudaol/uevnd0e4/).
  prefs: []
  type: TYPE_NORMAL
- en: 'With Vue, the simplest interpolation is done with `{{ }}` (handlebars annotation).
    In our example, we would write the following HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The content of the `<div>` thus becomes bound to the `msg` data. Each time `msg`
    changes, the content of the `div` changes automatically following its content.
    Have a look at the jsfiddle example at [https://jsfiddle.net/chudaol/xuvqotmq/1/](https://jsfiddle.net/chudaol/xuvqotmq/1/)
    . `data.msg` is also changed after the Vue instantiation. The value that appears
    on the screen is the new one!
  prefs: []
  type: TYPE_NORMAL
- en: It is still one-way binding interpolation. If we change the value in the DOM,
    nothing will happen to data. Still, if we only need the values of the data to
    appear in the DOM and to be changed accordingly, it is a perfect and valid approach.
  prefs: []
  type: TYPE_NORMAL
- en: At this moment, it should be really clear that if we want to use the values
    of the `data` object inside the template, we should surround them with `{{}}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the missing interpolations to our Pomodoro application. Please check
    the current situation in the [chapter4/pomodoro](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/pomodoro)
    folder. If you run `npm run dev` and have a look at the opened page, you will
    see that the page looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interpolating data](../Images/image00273.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Missing interpolations in our Pomodoro application
  prefs: []
  type: TYPE_NORMAL
- en: From the very first glance at the page, we are able to identify what is missing
    there.
  prefs: []
  type: TYPE_NORMAL
- en: The page is missing the timer, the kittens, the title of the Pomodoro state
    (the one that displays **`Work!`** or **`Rest!`**), and the logic that shows or
    hides the kittens' placeholder according to the Pomodoro state. Let's start by
    adding the title of the Pomodoro state and the minutes and seconds of the Pomodoro
    timer.
  prefs: []
  type: TYPE_NORMAL
- en: Adding title of the Pomodoro state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we should decide what component this element should belong to.
    Have a look at our four components. It is more than obvious that it should belong
    to `StateTitleComponent`. If you look at the following code, you will see that
    it actually already interpolates the title in its template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Good! In the previous chapter, we''ve already done most of the work. Now we
    just have to add the data that must be interpolated. In the `<script>` tag of
    this component, let''s add the `data` object with the `title` attribute inside.
    For now, let''s hardcode it to one of the possible values and then decide how
    to change it. What do you prefer? **`Work!`** or **`Rest!`**? I think I know the
    answer, so let''s add the following code to our `script` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let's leave it like this for now. We will come back to this later in the methods
    and event handling section.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the same way in which we added the title of the Pomodoro state, please add
    the minutes and seconds timer counters to the `CountDownComponent`. They can be
    hardcoded for now.
  prefs: []
  type: TYPE_NORMAL
- en: Using expressions and filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we have used simple property keys inside the `{{}}`
    interpolations. Actually, Vue supports a lot more inside these nice curly brackets.
    Let's see what it is possible to do there.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It might sound unexpected, but Vue supports full JavaScript expressions inside
    the data binding brackets! Let's go to any of the Pomodoro application components
    and add any JavaScript expression to the template. You can do some experiments
    in the [chapter4/pomodoro2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/pomodoro2)
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try, for example, to open the `StateTitleComponent.vue` file. Let''s add some
    JavaScript expression interpolation to its template, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, you just need to uncomment the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see number **`25`** on the page. Nice, isn''t it? Let''s replace some
    of our data bindings in the Pomodoro application with a JavaScript expression.
    For example, in the `CountdownComponent` component''s template, two directives,
    each for `min` and `sec`, can be replaced by one expression. Currently it looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can replace it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Where else can we add some expressions? Let''s have a look at `StateTitleComponent`.
    At this moment, we use the hardcoded title. We know, however, that somehow it
    should depend on the Pomodoro state. If it is in the *working* state, it should
    display **`Work!`**, otherwise it should display **`Rest!`**. Let''s create this
    attribute and call it `isworking`, and let''s assign it to the main `App.vue`
    component because it seems to belong to the global application state. Then we
    will reuse it inside the `StateTitleComponent` component''s `props` attribute.
    Thus, open `App.vue`, and add the Boolean property `isworking` and set it to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now reuse this property in `StateTitleComponent`, add two string properties
    for each of the possible titles, and, finally, add the expression in the template
    that will conditionally render one title or another accordingly to the current
    state. Thus, the script of the component will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can conditionally render one title or another based on the `isworking`
    property. Thus, the template of `StateTitleComponent` will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the refreshed page. Strangely, it shows **`Rest!`** as the title. How
    did this happen if the `isworking` property is set to `true` in `App.vue`? We
    simply forgot to bind this property on the component invocation in the `App.vue`
    template! Open the `App.vue` component and add the following code on the `state-title-component`
    invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you look at the page, the correct title appears as **`Work!`** If you
    open the devtools console and type `data.isworking = false`, you will see the
    title changing.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `isworking` attribute is `false`, the title is **`Rest!`**, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Expressions](../Images/image00274.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If the `isworking` attribute is `true`, the title is **`Work!`**, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Expressions](../Images/image00275.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides expressions inside the curly interpolation brackets, it is also possible
    to use filters that are applied to the result of the expression. Filters are just
    functions. They are created by us and applied by using the pipe symbol:  `|`.
    If you create a filter that makes letters uppercase and call it uppercase, in
    order to apply it, just use it after the pipe symbol inside the mustache interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can chain as many filters as you want, for example, if you have filter
    `A`, `B`, `C`, you can do something like `{{ key | A | B | C }}`. Filters are
    created using `Vue.filter` syntax. Let''s create our `lowercase` filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s apply it to the Pomodoro title in the main `App.vue` component. In order
    to be able to use the filter, we should pass the `''Pomodoro''` string inside
    the handlebars interpolation notation. We should pass it as a JavaScript string
    expression and apply a filter using the pipe symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Check the page; the **`Pomodoro`** title will actually appear written in the
    lowercase syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Let's revisit our `CountdownTimer` component and have a look at the timer. For
    now, there are only hardcoded values, right? But when the application is fully
    functional, the values will come from some computation. The range of values will
    be from 0 to 60\. It is okay if the timer shows **`20:40`**, but it is not okay
    for fewer than ten values. For example, when it is only 1 minute and 5 seconds,
    it will be **`1:5`**, which is not good. We are expecting to see something like
    **`01:05`**. So, we need the `leftpad` filter! Let's create it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `main.js` file and add a `leftpad` filter after the uppercase filter
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `CountdownComponent` component and let''s again split `min` and `sec`
    to the different interpolation brackets and add filters to each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Replace `min` and `sec` in data with 1 and 5, respectively, and have a look.
    The numbers appear with a preceding "0"!
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create two filters, `uppercase` and `addspace`, and apply them to the title
    **`Pomodoro:`**
  prefs: []
  type: TYPE_NORMAL
- en: The `uppercase` filter must do exactly what it says it does
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `addspace` filter must add a space on the right of the given string value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Do not forget that **`Pomodoro`** is not a key, so inside the interpolation
    brackets, it should be treated as a string! The title before and after this exercise
    would look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercise](../Images/image00276.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The title of the Pomodoro application before and after applying filters uppercase
    and addspace
  prefs: []
  type: TYPE_NORMAL
- en: 'Check yourself: have a look at the [chapter4/pomodoro3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/pomodoro3)
    folder.'
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting and applying directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we saw how to interpolate the application''s data
    and how to bind it to the visual layer. Though the syntax is pretty powerful and
    offers a high possibility of data modification (using filters and expressions),
    it has some limitations. Try, for example, to implement the following using `{{}}`
    notation:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the interpolated data in the user input and apply the changes to the corresponding
    data when the user types in the input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bind a specific element's attribute (for example, `src`) to the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render some element conditionally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterate through an array and render some component with the elements of the
    array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create event listeners on the elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s try at least the first one. Open, for example, the shopping list application
    (it''s in the [chapter4/shopping-list](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list)
    folder). Create an `input` element in the `App.vue` template and set its value
    to `{{ title }}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Oh no! Errors, errors everywhere. **`Interpolation inside attributes has been
    removed,`** it says. Does it mean that prior to Vue 2.0 you could easily use the
    interpolation inside attributes? Yes, and no. You would not get an error if you'd
    use interpolations inside attributes, but changing the title inside the input
    would result in nothing. In Vue 2.0, as well as in the prior versions, to achieve
    this kind of behavior, we must use directives.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Directives** are special attributes of the elements that have a `v-` prefix.
    Why `v-`? Because Vue! Directives provide a tiny syntax that provides a richer
    set of possibilities than simple text interpolation. They have the power to reactively
    apply some special behavior to the visual layer on each data change.'
  prefs: []
  type: TYPE_NORMAL
- en: Two-way binding using the v-model directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two-way binding is a type of binding where not only data changes are propagated
    to the DOM layer, but also the changes that occur to the bound data in the DOM
    are propagated to the data. To bind the data in such a way to the DOM, we can
    use the `v-model` directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'I am sure you still remember from the first chapter that the `v-model` directive
    is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this way, the value of the title will appear in the input, and if you type
    something in this input, the corresponding change will be immediately applied
    to the data and reflected in all interpolated values on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Just replace the handlebars notation with `v-model` and open the page.
  prefs: []
  type: TYPE_NORMAL
- en: Try to type something in the input. You will see how the title is immediately
    changed!
  prefs: []
  type: TYPE_NORMAL
- en: 'Just remember, this directive can only be used with the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<input>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<select>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<textarea>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try all of them and then delete this code. Our main purpose is to be able to
    change the title using the change title component.
  prefs: []
  type: TYPE_NORMAL
- en: Two-way binding between components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember from the previous chapter that two-way binding between components cannot
    be easily achieved using the `v-model` directive. Due to architectural reasons,
    Vue just prevents children from easily changing the parents' scope.
  prefs: []
  type: TYPE_NORMAL
- en: That's why we used the events system in the previous chapter to be able to change
    the title of the shopping list from the child component.
  prefs: []
  type: TYPE_NORMAL
- en: We will do it again in this chapter. Just wait couple of paragraphs until we
    reach the section on `v-on` directives.
  prefs: []
  type: TYPE_NORMAL
- en: Binding attributes using the v-bind directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `v-bind` directive allows us to bind an element''s `attribute` or a `component`
    property to an expression. In order to apply it to the specific attribute, we
    use a colon delimiter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`v-bind:src="src"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v-bind:class="className"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any expression can be written inside the `""`. The data properties can be used
    as well, just like in the previous examples. Let's add the kitten image to `KittenComponent`
    in our Pomodoro application using `thecatapi` as the source. Open our Pomodoro
    application from the [chapter4/pomodoro3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/pomodoro3)
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `KittenComponent`, add `catimgsrc` to the component''s data, and bind
    it to the image template using `v-bind` syntax with the `src` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Open the page. Enjoy the kitten!
  prefs: []
  type: TYPE_NORMAL
- en: '![Binding attributes using the v-bind directive](../Images/image00277.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Pomodoro KittenComponent with applied source attribute
  prefs: []
  type: TYPE_NORMAL
- en: Conditional rendering using v-if and v-show directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have paid enough attention in the earlier sections, and if I ask you
    to conditionally render something, you might be actually able to do it using JavaScript
    expressions inside the interpolation brackets `{{ }}`.
  prefs: []
  type: TYPE_NORMAL
- en: However, try to conditionally render some element or the whole component. It
    might not be as simple as applying an expression inside the brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `v-if` directive allows to conditionally render the whole element, which
    might also be a component element depending on some condition. The condition can
    be any expression and it can use the data properties as well. For example, we
    can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Or even:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Or using the component''s data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `v-show` attribute does the same job. The only difference is that `v-if`
    will or will not render the element to the condition accordingly, whereas the
    `v-show` attribute will always render the element, just applying `display:none`
    CSS property when the result of the condition is `false`. Let's see the difference.
    Open the `beer-time` project in the [chapter4/beer-time](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/beer-time)
    folder. Run `npm install` and `npm run dev`. Open the `App.vue` component and
    play with `true`/`false` values, and try to replace `v-if` with `v-show`. Open
    devtools and check the **`elements`** tab.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first check how it looks when we switch between `true` and `false` in
    the `isadmin` property value using `v-if`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the condition is met, everything appears as expected; the element is rendered
    and appears on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Conditional rendering using v-if and v-show directives](../Images/image00278.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Conditional rendering using the v-if directive. Condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the condition is not met, the element is not rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Conditional rendering using v-if and v-show directives](../Images/image00279.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Conditional rendering using the v-if directive. Condition is not met.
  prefs: []
  type: TYPE_NORMAL
- en: Note that when the condition is not fulfilled, the corresponding element is
    not rendered at all!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s play with the condition result value using the `v-show` directive. When
    the condition is met, it appears in exactly the same way as it was in the previous
    case using `v-if`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Conditional rendering using v-if and v-show directives](../Images/image00280.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Conditional rendering using the v-show directive. Condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s check what will happen with the element using the `v-show` directive
    when the right condition is not met:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Conditional rendering using v-if and v-show directives](../Images/image00281.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Conditional rendering using the v-show directive. Condition is not met.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, everything is the same when the condition is met, but when the
    condition is not fulfilled, the element is rendered as well with the `display:none`
    CSS property.
  prefs: []
  type: TYPE_NORMAL
- en: How do you decide which one is better to use? On the first render, if the condition
    is not met, the `v-if` directive will not render the element at all, hence reducing
    the computation costs on the initial rendering. But, if the property changes frequently
    during runtime, the cost of rendering/removing an element is higher than just
    to apply the `display:none` property. Thus, use `v-show` with frequently changing
    properties and `v-if` if the condition will not change too much during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Let's come back to our Pomodoro application. `KittensComponent` should be conditionally
    rendered when Pomodoro is not in its working state. So, open your Pomodoro application
    code in the [chapter4/pomodoro4](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/pomodoro4)
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'What do you think should be used? `v-if` or `v-show`? Let''s analyze. Independently
    from what we use, should this element be visible on the initial render? The answer
    is no, because on the initial render, the user starts her working day and starts
    the Pomodoro timer. It might be better to use `v-if` to not have the cost of initial
    rendering when there is no need. But, let''s analyze another factor—the frequency
    of toggling the state that will make the kittens component visible/invisible.
    This will happen at each Pomodoro interval, right? After 15-20 minutes of work
    and then after 5 minutes of rest interval, which is, actually, not so frequent
    and will not affect the cost of rendering that much. In this case, in my opinion,
    it doesn''t matter which one you use. Let''s use `v-show`. Open the `App.vue`
    file and apply the `v-show` directive to the `kittens-component` invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Open the page and try to toggle the value of `data.isworking` in the devtools
    console. You will see how the **kittens** container appears and disappears.
  prefs: []
  type: TYPE_NORMAL
- en: Array iteration using the v-for directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You probably remember that array iteration is done using the `v-for` directive
    with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Or with components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For each item in the array, this will render a component and bind the component's `item`
    property to the value of the item. Of course, you remember that inside the `""`
    of the binding syntax you can use whatever JavaScript expression you want. So,
    just be creative!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not forget that the property we use in the binding syntax (`componentitem`)
    should be present in the component's data!
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look, for example, at our shopping list application (The [chapter4/shopping-list](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list)
    folder). It already uses the `v-for` syntax in `ItemsComponent` to render the
    list of items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`ItemComponent`, in turn, has the `item` property declared using `props`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's do something interesting with our shopping list application. Until
    now we were dealing only with one shopping list. Imagine that you want to have
    a different shopping list for different kind of shopping. For example, you might
    have a regular shopping list for the normal groceries shopping day. You might
    have a different shopping list for the holidays. You might also want to have a
    different shopping list when you buy a new house. Let's use the power of the reusability
    of the Vue components and transform our shopping list application into the list
    of shopping lists! We will display them using Bootstrap's tab panel; for more
    information, refer to [http://getbootstrap.com/javascript/#tabs](http://getbootstrap.com/javascript/#tabs)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Open your shopping list application in the IDE (the [chapter4/shopping-list](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list)
    folder).
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we should add Bootstrap''s JavaScript file and jQuery, because
    bootstrap relies on it for doing its amazing magic. Go on and just add them manually
    to the `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s establish a step-by-step overview of what we should do in order
    to transform our application into the list of shopping lists:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we must create a new component. Let's call it `ShoppingListComponent`
    and move the content of our current `App.vue` to there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our new `ShoppingListComponent` should contain the `props` attribute with `title`
    and `items` that it will receive from `App.vue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ItemsComponent` should receive `items` from the `props` attribute rather than
    having it hardcoded.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `App` component's `data`, let's declare and hardcode (for now) an array of
    `shoppinglists`, each of the items should have a title, an array of items, and
    an ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`App.vue` should import `ShoppingListComponent`, and in the template, iterate
    over the `shoppinglists` array, and for each of them, build the `html/jade` structure
    of the tabs panel for each of the shopping lists.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Okay, then, let's start!
  prefs: []
  type: TYPE_NORMAL
- en: Creating ShoppingListComponent and modifying ItemsComponent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inside the `components` folder, create a new `ShoppingListComponent.vue`. Copy
    and paste the `App.vue` file''s content into this new file. Do not forget to declare
    `props` that will contain `title` and `items` and bind `items` to the `items-component`
    invocation inside the template. Your final code for this component should look
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note that we removed the styling for the container and the container's `class`
    from the parent `div`. This part of the code should stay in `App.vue` because
    it defines the global application's container styling. Do not forget about the
    `props` attribute and binding `props` to `items-component`!
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `ItemsComponent.vue` and ensure that it contains the `props` attribute
    with `items`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Modifying App.vue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now go to `App.vue`. Remove all the code inside the `<script>` and `<template>`
    tags. In the `script` tag, import `ShoppingListComponent` and invoke it inside
    the `components` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `data` attribute and create a `shoppinglists` array there. Add arbitrary
    data for this array. Each of the objects of the array should have `id`, `title`,
    and `items` attributes. `items`, as you remember, must contain the `checked` and
    `text` properties. For example, your `data` property might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Be more creative than me: add more lists, more items, something nice and interesting!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create a structure for composing the bootstrap tab panel based on
    iteration over the shopping list! Let''s start by defining a basic structure needed
    for tabs to work. Let''s add all the necessary classes and jade structure pretending
    that we have only one element. Let''s also write in Caps Lock all the unknowns
    that will be reused from our shopping list array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two elements where we need to iterate over the shopping lists array—the
    `<li>` tag that contains an `<a>` attribute and the `tab-pane` div. In the first
    case, we must bind the ID of each shopping list to the `href` and `aria-controls`
    attribute and interpolate the title. In the second case, we need to bind the `id`
    attribute to the `id` property and render the shopping list item and bind the
    `items` array and `title` to it. Easy! Let''s go. Start by adding the `v-for`
    directive to each of the elements (to the `<li>` and to the `tab-pane div` element):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now replace the parts in Caps Lock with the proper bindings. Remember that to
    the `bind` attribute, we use the `v-bind:<corresponding_attribute>="expression"`
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `href` attribute of the anchor element, we have to define an expression
    that appends the ID selector `#` to `id: v-bind:href="''#'' + list.id"`. The `aria-controls`
    attribute should be bound to the value of the ID. `title` can be bound using the
    simple `{{ }}` notation interpolation.'
  prefs: []
  type: TYPE_NORMAL
- en: For `shopping-list-component`, we must bind `title` and `items` to the corresponding
    values of the list item. Do you remember that we defined the `title` and `items`
    properties inside the `props` of the `ShoppingListComponent`? The bindings, thus,
    should look like `v-bind:title=list.title` and `v-bind:items=list.items`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So after the proper binding attribution, the template will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re almost done! If you open the page now, you will see both of the titles
    of the tabs appearing on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Modifying App.vue](../Images/image00282.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tab titles as seen on the screen after the modification
  prefs: []
  type: TYPE_NORMAL
- en: If you start clicking on the tabs titles, the corresponding tab panes will open.
    But this is not what we were expecting to see, right? What we were expecting is
    for the first tab to be visible (active) by default. For this to happen, we should
    add the `active` class  to the first `li` and to the first `tab-pane div`. But
    how can we do it if the code is the same for all the tabs as long as we are iterating
    through the array?
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, for us, Vue allows us to provide not only the *iteration item*
    inside the `v-for` loop, but also `index`, and then reuse this `index` variable
    inside the expressions used in the templates. Thus, we can use it to conditionally
    render the `active` class if the index is "0". Using the `index` variable inside
    the `v-for` loop is as easy as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax for class binding is the same as for everything else (`class` is
    also an attribute):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Do you remember that we can write any JavaScript expression inside the quotes?
    In this case, we want to write a condition that evaluates the value of `index`,
    and in case it is "0", the value of class is `active`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `index` variable to the `v-for` modifiers and the `class` bindings
    to the `li` and to the `tab-pane` element, so that the final template code looks
    like following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the page. Now you should see nice tabs that display the content by
    default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Modifying App.vue](../Images/image00283.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The look and feel of  the shopping list application after the correct class
    binding
  prefs: []
  type: TYPE_NORMAL
- en: The final shopping list application code after these modifications can be found
    in the [chapter4/shopping-list2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list2)
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Event listeners using the v-on directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is very easy to listen to the events and call callbacks using Vue.js. Event
    listening is also done using a special directive with specific modifiers for each
    of the event types. The directive is `v-on`. The modifiers are applied after the
    colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Ok, you say, and where do I declare this method? You will probably not believe
    me, but all the component''s methods are declared inside the `methods` property!
    So, to declare the method called `myMethod`, you should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: All the `data` and `props` attributes are accessible inside the methods using
    the `this` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a method to add a new item to the `items` array. We have actually
    done it already in the previous chapter, when we learned how to pass data between
    parent and children components using the events emitting system. We will just
    recap this part here.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to be able to add new items within `AddItemComponent` to the shopping
    list that belongs to `ShoppingListComponent`, we should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that `AddItemComponent` has a `data` property called `newItem`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an `addItem` method inside the `AddItemComponent` that pushes the `newItem`
    and emits the event `add`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply an event listener to the **`Add!`** button using the `v-on:click` directive.
    This event listener should call the defined `addItem` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an `addItem` method inside the `ShoppingListComponent` that will receive
    the `text` as a parameter and push it to the `items` array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bind the `v-on` directive with a custom `add` modifier to the `add-item-component`
    invocation inside the `ShoppingListComponent`. This listener will call the `addItem`
    method defined in this component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's go then! Use the shopping list application from the [chapter4/shopping-list2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list2)
    folder and play with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by opening `AddItemComponent` and add the missing `v-on` directive to
    the **`Add!`** button and the `addItem` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Switch to `ShoppingListComponent` and bind the `v-on:add` directive to the
    invocation of `add-item-component` inside the `template` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create the `addItem` method inside the `ShoppingListComponent`. It should
    receive the text and just push it into the `this.items` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Open the page and try to add the items to the list by typing in the input box
    and clicking the button afterward. It works!
  prefs: []
  type: TYPE_NORMAL
- en: Now, I would like to ask you to switch your role from the application's developer
    to its user. Type the new item in the input box. What is the obvious user action
    after the item has been introduced? Aren't you trying to hit the *Enter* button?
    I bet you are! When nothing is happening, it is a little bit frustrating, isn't
    it? Don't worry, my friend, we just have to add one more event listener to the
    input box and call the same method as we did with the **`Add!`** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sounds easy, right? What event is fired when we''re hitting the *Enter* button?
    Right, it is the keyup event. So, we just have to use the `v-on` directive with
    the `keyup` method after the delimiter colon: `v-on:keyup`. The problem is that
    this event is fired when any keyboard button is hit, which means that while we''re
    typing the new shopping list item, each time the new letter is being introduced,
    the method will be called. This is not what we want. Of course, we could add a
    condition inside our `addItem` method that would check for the `event.code` attribute
    and, only in case it''s `13` (which corresponds to the *Enter* key), we would
    call the rest of the method. Fortunately, for us, Vue provides a mechanism to
    provide keystroke modifiers to this method that allows us to only call a method
    if a certain key code was hit. It should be implemented using the dot (`.`) modifier.
    In our case, it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add it to our input box. Go to `AddItemComponent` and add the `v-on:keyup.enter` directive
    to the input as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Open the page and try to add the item to the shopping list using the *Enter*
    button. It works!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do the same for title changing. The only difference is that the adding
    items, we used a custom `add` event and here we will use the native input event.
    We have already done it. We just have to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Bind the model title using the `v-model` directive to `change-title-component`
    in the template of the `ShoppingListComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Export `value` in the `props` attribute of the `ChangeTitleComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `onInput` method inside the `ChangeTitleComponent` that will emit
    the native `input` method with the value of the event target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind `value` to `input` inside the `ChangeTitleComponent` component's template
    and the `v-on` directive with the `onInput` modifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Thus, the `change-title-component` invocation inside the `ShoppingListComponent`
    template will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`ChangeTitleComponent` will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The final code for this part can be found in the [chapter4/shopping-list3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list3)
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Shorthands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of course, it is not time consuming to write the `v-bind` or `v-on` directive
    in the code each time. Developers tend to think that each time we decrease the
    amount of code, we win. Vue.js allows us to win! Just remember that the shorthand
    for the `v-bind` directive is a colon (`:`) and the shorthand for the `v-on` directive
    is the `@` symbol. This means that the following code does the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rewrite all the `v-bind` and `v-on` directives in the shopping list application
    using the shortcuts we just learned.
  prefs: []
  type: TYPE_NORMAL
- en: Check yourself by looking at the [chapter4/shopping-list4](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list4)
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Kittens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we haven''t touched a lot on our Pomodoro application with
    its nice kittens. I promise you that we''ll do a lot of it in the next chapter.
    In the meantime, I hope that this kitten will make you happy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Kittens](../Images/image00284.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Kitten asking "What's next?"
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had an extensive overview of all the possible ways of binding
    data to our presentation layer. You learned how to simply interpolate data using
    handlebars brackets (`{{ }}`). You also learned how to use JavaScript expressions
    and filters in such an interpolation. You learned and applied directives such
    as `v-bind`, `v-model`, `v-for`, `v-if`, and `v-show`.
  prefs: []
  type: TYPE_NORMAL
- en: We modified our applications so that they use richer and more efficient data-binding
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about Vuex**,** the state management architecture
    inspired by Flux and Redux but with simplified concepts.
  prefs: []
  type: TYPE_NORMAL
- en: We will create global application state management stores for both of our applications
    and explore their potential by working with it.
  prefs: []
  type: TYPE_NORMAL
