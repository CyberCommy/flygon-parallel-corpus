- en: '05'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Your Own Types with Object-Oriented Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about making your own types using **object-oriented programming**
    (**OOP** ). You will learn about all the different categories of members that
    a type can have, including fields to store data and methods to perform actions.
    You will use OOP concepts such as aggregation and encapsulation. You will also
    learn about language features such as tuple syntax support, out variables, inferred
    tuple names, and default literals.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Talking about OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building class libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing data with fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing and calling methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling access with properties and indexers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching with objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Talking about OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An object in the real world is a thing, such as a car or a person, whereas an
    object in programming often represents something in the real world, such as a
    product or bank account, but this can also be something more abstract.
  prefs: []
  type: TYPE_NORMAL
- en: In C#, we use the `class` (mostly) or `struct` (sometimes) C# keywords to define
    a type of object. You will learn about the difference between classes and structs
    in *Chapter 6* , *Implementing Interfaces and Inheriting Classes* . You can think
    of a type as being a blueprint or template for an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concepts of OOP are briefly described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulation** is the combination of the data and actions that are related
    to an object. For example, a `BankAccount` type might have data, such as `Balance`
    and `AccountName` , as well as actions, such as `Deposit` and `Withdraw` . When
    encapsulating, you often want to control what can access those actions and the
    data, for example, restricting how the internal state of an object can be accessed
    or modified from the outside.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composition** is about what an object is made of. For example, a `Car` is
    composed of different parts, such as four `Wheel` objects, several `Seat` objects,
    and an `Engine` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aggregation** is about what can be combined with an object. For example,
    a `Person` is not part of a `Car` object, but they could sit in the driver''s
    `Seat` and then become the car''s `Driver` —two separate objects that are aggregated
    together to form a new component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inheritance** is about reusing code by having a **subclass** derive from
    a **base** or **superclass** . All functionality in the base class is inherited
    by and becomes available in the **derived** class. For example, the base or super
    `Exception` class has some members that have the same implementation across all
    exceptions, and the sub or derived `SqlException` class inherits those members
    and has extra members only relevant to when a SQL database exception occurs, like
    a property for the database connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abstraction** is about capturing the core idea of an object and ignoring
    the details or specifics. C# has the `abstract` keyword that formalizes this concept.
    If a class is not explicitly **abstract** , then it can be described as being
    **concrete** . Base or superclasses are often abstract, for example, the superclass
    `Stream` is abstract, and its subclasses, like `FileStream` and `MemoryStream`
    , are concrete. Only concrete classes can be used to create objects; abstract
    classes can only be used as the base for other classes because they are missing
    some implementation. Abstraction is a tricky balance. If you make a class more
    abstract, more classes will be able to inherit from it, but at the same time,
    there will be less functionality to share.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polymorphism** is about allowing a derived class to override an inherited
    action to provide custom behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building class libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Class library assemblies group types together into easily deployable units (DLL
    files). Apart from when you learned about unit testing, you have only created
    console applications or .NET Interactive notebooks to contain your code. To make
    the code that you write reusable across multiple projects, you should put it in
    class library assemblies, just like Microsoft does.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first task is to create a reusable .NET class library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred coding tool to create a new class library, as defined in
    the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Class Library** / `classlib`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `Chapter05`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `PacktLibrary`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `PacktLibrary.csproj` file, and note that by default class libraries
    target .NET 6 and therefore can only work with other .NET 6-compatible assemblies,
    as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: <Project Sdk="Microsoft.NET.Sdk"
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: <PropertyGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <TargetFramework>net6.0
  prefs: []
  type: TYPE_NORMAL
- en: </TargetFramework>
  prefs: []
  type: TYPE_NORMAL
- en: <Nullable>enable</Nullable>
  prefs: []
  type: TYPE_NORMAL
- en: <ImplicitUsings>enable</ImplicitUsings>
  prefs: []
  type: TYPE_NORMAL
- en: </PropertyGroup>
  prefs: []
  type: TYPE_NORMAL
- en: </Project>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the framework to target .NET Standard 2.0 and remove the entries that
    enable nullable and implicit usings, as shown highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: <Project Sdk="Microsoft.NET.Sdk"
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: <PropertyGroup>
  prefs: []
  type: TYPE_NORMAL
- en: '**<TargetFramework>netstandard**'
  prefs: []
  type: TYPE_NORMAL
- en: '**2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: '**</TargetFramework>**'
  prefs: []
  type: TYPE_NORMAL
- en: </PropertyGroup>
  prefs: []
  type: TYPE_NORMAL
- en: </Project>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Save and close the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the file named `Class1.cs` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compile the project so that other projects can reference it later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Visual Studio Code, enter the following command: `dotnet build` .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, navigate to **Build** | **Build PacktLibrary** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice** : To use the latest C# language and .NET platform features,
    put types in a .NET 6 class library. To support legacy .NET platforms like .NET
    Core, .NET Framework, and Xamarin, put types that you might reuse in a.NET Standard
    2.0 class library.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a class in a namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next task is to define a class that will represent a person:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new class file named `Person.cs` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Statically import `System.Console` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the namespace to `Packt.Shared` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice** : We''re doing this because it is important to put your classes
    in a logically named namespace. A better namespace name would be domain-specific,
    for example, `System.Numerics` for types related to advanced numbers. In this
    case, the types we will create are `Person` , `BankAccount` , and `WondersOfTheWorld`
    and they do not have a typical domain so we will use the more generic `Packt.Shared`
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your class file should now look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System;
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: System.Console;
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Person
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the C# keyword `public` is applied before class. This keyword is an
    **access modifier** , and it allows for any other code to access this class.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not explicitly apply the `public` keyword, then it will only be accessible
    within the assembly that defined it. This is because the implicit access modifier
    for a class is `internal` . We need this class to be accessible outside the assembly,
    so we must make sure it is `public` .
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying namespace declarations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To simplify your code if you are targeting .NET 6.0 and therefore using C#
    10 or later, you can end a namespace declaration with a semi-colon and remove
    the braces, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System;
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: ; // the class in this file is in this namespace
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Person
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This is known as a file-scoped namespace declaration. You can only have one
    file-scoped namespace per file. We will use this in a class library that targets
    .NET 6.0 later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Put each type that you create in its own file so that you
    can use file-scoped namespace declarations.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This type does not yet have any members encapsulated within it. We will create
    some over the following pages. Members can be fields, methods, or specialized
    versions of both. You''ll find a description of them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fields** are used to store data. There are also three specialized categories
    of field, as shown in the following bullets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constant** : The data never changes. The compiler literally copies the data
    into any code that reads it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read-only** : The data cannot change after the class is instantiated, but
    the data can be calculated or loaded from an external source at the time of instantiation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event** : The data references one or more methods that you want to execute
    when something happens, such as clicking on a button or responding to a request
    from some other code. Events will be covered in *Chapter 6* , *Implementing Interfaces
    and Inheriting Classes* .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Methods** are used to execute statements. You saw some examples when you
    learned about functions in *Chapter 4* , *Writing, Debugging, and Testing Functions*
    . There are also four specialized categories of method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constructor** : The statements execute when you use the `new` keyword to
    allocate memory to instantiate a class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Property** : The statements execute when you get or set data. The data is
    commonly stored in a field but could be stored externally or calculated at runtime.
    Properties are the preferred way to encapsulate fields unless the memory address
    of the field needs to be exposed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Indexer** : The statements execute when you get or set data using "array"
    syntax `[]` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operator** : The statements execute when you use an operator like `+` and
    `/` on operands of your type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiating a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will make an instance of the `Person` class.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing an assembly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we can instantiate a class, we need to reference the assembly that contains
    it from another project. We will use the class in a console app:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred coding tool to add a new console app to the `Chapter05` workspace/solution
    named `PeopleApp` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are using Visual Studio Code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `PeopleApp` as the active OmniSharp project. When you see the pop-up
    warning message saying that required assets are missing, click **Yes** to add
    them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit `PeopleApp.csproj` to add a project reference to `PacktLibrary` , as shown
    highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: <Project Sdk="Microsoft.NET.Sdk"
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: <PropertyGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <OutputType>Exe</OutputType>
  prefs: []
  type: TYPE_NORMAL
- en: <TargetFramework>net6.0
  prefs: []
  type: TYPE_NORMAL
- en: </TargetFramework>
  prefs: []
  type: TYPE_NORMAL
- en: <Nullable>enable</Nullable>
  prefs: []
  type: TYPE_NORMAL
- en: <ImplicitUsings>enable</ImplicitUsings>
  prefs: []
  type: TYPE_NORMAL
- en: </PropertyGroup>
  prefs: []
  type: TYPE_NORMAL
- en: '**<ItemGroup>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**<ProjectReference Include=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"../PacktLibrary/PacktLibrary.csproj"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**/>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**</ItemGroup>**'
  prefs: []
  type: TYPE_NORMAL
- en: </Project>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal, enter a command to compile the `PeopleApp` project and its dependency
    `PacktLibrary` project, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: dotnet build
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Visual Studio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the startup project for the solution to the current selection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Solution Explorer** , select the `PeopleApp` project, navigate to **Project**
    | **Add Project Reference…** , check the box to select the `PacktLibrary` project,
    and then click **OK** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Build** | **Build PeopleApp** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Importing a namespace to use a type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we are ready to write statements to work with the `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PeopleApp` project/folder, open `Program.cs` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the `Program.cs` file, delete the comment, and add statements
    to import the namespace for our `Person` class and statically import the `Console`
    class, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared;
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: System.Console;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of the `Person` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output the instance using a textual description of itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `new` keyword allocates memory for the object and initializes any internal
    data. We could use `var` in place of the `Person` class name, but then we would
    need to specify `Person` after the `new` keyword, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // var bob = new Person(); // C# 1.0 or later
  prefs: []
  type: TYPE_NORMAL
- en: Person bob = new
  prefs: []
  type: TYPE_NORMAL
- en: (); // C# 9.0 or later
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(bob.ToString());
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering, "Why does the `bob` variable have a method named `ToString`
    ? The `Person` class is empty!" Don't worry, we're about to find out!
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared.Person
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although our `Person` class did not explicitly choose to inherit from a type,
    all types ultimately inherit directly or indirectly from a special type named
    `System.Object` .
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the `ToString` method in the `System.Object` type simply
    outputs the full namespace and type name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the original `Person` class, we could have explicitly told the compiler
    that `Person` inherits from the `System.Object` type, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Person
  prefs: []
  type: TYPE_NORMAL
- en: ': System.Object'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: When class B inherits from class A, we say that A is the base or superclass
    and B is the derived or subclass. In this case, `System.Object` is the base or
    superclass and `Person` is the derived or subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the C# alias keyword `object` , as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Person
  prefs: []
  type: TYPE_NORMAL
- en: ': object'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting from System.Object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s make our class explicitly inherit from `object` and then review what
    members all objects have:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify your `Person` class to explicitly inherit from `object` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click inside the `object` keyword and press F12 , or right-click on the `object`
    keyword and choose **Go to Definition** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the Microsoft-defined `System.Object` type and its members. This
    is something you don''t need to understand the details of yet, but notice that
    it has a method named `ToString` , as shown in *Figure 5.1* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email Description automatically
    generated](img/Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: System.Object class definition'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Assume other programmers know that if inheritance is not
    specified, the class will inherit from `System.Object` .'
  prefs: []
  type: TYPE_NORMAL
- en: Storing data within fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be defining a selection of fields in the class to store
    information about a person.
  prefs: []
  type: TYPE_NORMAL
- en: Defining fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say that we have decided that a person is composed of a name and a date
    of birth. We will encapsulate these two values inside a person, and the values
    will be visible outside it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `Person` class, write statements to declare two public fields for
    storing a person''s name and date of birth, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Person
  prefs: []
  type: TYPE_NORMAL
- en: ': object'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // fields
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: Name;
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: DateTime DateOfBirth;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: You can use any type for a field, including arrays and collections such as lists
    and dictionaries. These would be used if you needed to store multiple values in
    one named field. In this example, a person only has one name and one date of birth.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding access modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Part of encapsulation is choosing how visible the members are.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, as we did with the class, we explicitly applied the `public` keyword
    to these fields. If we hadn't, then they would be implicitly `private` to the
    class, which means they are accessible only inside the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four access modifier keywords, and two combinations of access modifier
    keywords that you can apply to a class member, like a field or method, as shown
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Access Modifier | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `private` | Member is accessible inside the type only. This is the default.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `internal` | Member is accessible inside the type and any type in the same
    assembly. |'
  prefs: []
  type: TYPE_TB
- en: '| `protected` | Member is accessible inside the type and any type that inherits
    from the type. |'
  prefs: []
  type: TYPE_TB
- en: '| `public` | Member is accessible everywhere. |'
  prefs: []
  type: TYPE_TB
- en: '| `internal``protected` | Member is accessible inside the type, any type in
    the same assembly, and any type that inherits from the type. Equivalent to a fictional
    access modifier named `internal_or_protected` . |'
  prefs: []
  type: TYPE_TB
- en: '| `private``protected` | Member is accessible inside the type and any type
    that inherits from the type and is in the same assembly. Equivalent to a fictional
    access modifier named `internal_and_protected` . This combination is only available
    with C# 7.2 or later. |'
  prefs: []
  type: TYPE_TB
- en: '**Good Practice** : Explicitly apply one of the access modifiers to all type
    members, even if you want to use the implicit access modifier for members, which
    is `private` . Additionally, fields should usually be `private` or `protected`
    , and you should then create `public` properties to get or set the field values.
    This is because it controls access. You will do this later in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting and outputting field values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we will use those fields in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: At the top of `Program.cs` , make sure the `System` namespace is imported. We
    need to do this to use the `DateTime` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After instantiating `bob` , add statements to set his name and date of birth,
    and then output those fields formatted nicely, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: bob.Name = "Bob Smith"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: bob.DateOfBirth = new
  prefs: []
  type: TYPE_NORMAL
- en: DateTime(1965
  prefs: []
  type: TYPE_NORMAL
- en: ', 12'
  prefs: []
  type: TYPE_NORMAL
- en: ', 22'
  prefs: []
  type: TYPE_NORMAL
- en: ); // C# 1.0 or later
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine(format: "{0} was born on {1:dddd, d MMMM yyyy}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: bob.Name,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: bob.DateOfBirth);'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We could have used string interpolation too, but for long strings it will wrap
    over multiple lines, which can be harder to read in a printed book. In the code
    examples in this book, remember that `{0}` is a placeholder for `arg0` , and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Bob Smith was born on Wednesday, 22 December 1965
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Your output may look different based on your locale, that is, language and culture.
  prefs: []
  type: TYPE_NORMAL
- en: The format code for `arg1` is made of several parts. `dddd` means the name of
    the day of the week. `d` means the number of the day of the month. `MMMM` means
    the name of the month. Lowercase `m` is used for minutes in time values. `yyyy`
    means the full number of the year. `yy` would mean the two-digit year.
  prefs: []
  type: TYPE_NORMAL
- en: You can also initialize fields using a shorthand **object initializer** syntax
    using curly braces. Let's see how.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements underneath the existing code to create another new person named
    Alice. Note the different format code for the date of birth when writing her to
    the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Person alice = new
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Name = "Alice Jones"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: DateOfBirth = new
  prefs: []
  type: TYPE_NORMAL
- en: (1998
  prefs: []
  type: TYPE_NORMAL
- en: ', 3'
  prefs: []
  type: TYPE_NORMAL
- en: ', 7'
  prefs: []
  type: TYPE_NORMAL
- en: ) // C# 9.0 or later
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine(format: "{0} was born on {1:dd MMM yy}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: alice.Name,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: alice.DateOfBirth);'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Alice Jones was born on 07 Mar 98
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Storing a value using an enum type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, a value needs to be one of a limited set of options. For example,
    there are seven ancient wonders of the world, and a person may have one favorite.
    At other times, a value needs to be a combination of a limited set of options.
    For example, a person may have a bucket list of ancient world wonders they want
    to visit. We are able to store this data by defining an `enum` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `enum` type is a very efficient way of storing one or more choices because,
    internally, it uses integer values in combination with a lookup table of `string`
    descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new file to the `PacktLibrary` project named `WondersOfTheAncientWorld.cs`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `WondersOfTheAncientWorld.cs` file, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: enum
  prefs: []
  type: TYPE_NORMAL
- en: WondersOfTheAncientWorld
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: GreatPyramidOfGiza,
  prefs: []
  type: TYPE_NORMAL
- en: HangingGardensOfBabylon,
  prefs: []
  type: TYPE_NORMAL
- en: StatueOfZeusAtOlympia,
  prefs: []
  type: TYPE_NORMAL
- en: TempleOfArtemisAtEphesus,
  prefs: []
  type: TYPE_NORMAL
- en: MausoleumAtHalicarnassus,
  prefs: []
  type: TYPE_NORMAL
- en: ColossusOfRhodes,
  prefs: []
  type: TYPE_NORMAL
- en: LighthouseOfAlexandria
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : If you use are writing code in a .NET Interactive notebook,
    then the code cell containing the `enum` must be above the code cell defining
    the `Person` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Person` class, add the following statement to your list of fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: WondersOfTheAncientWorld FavoriteAncientWonder;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add the following statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: bob.FavoriteAncientWonder = WondersOfTheAncientWorld.StatueOfZeusAtOlympia;
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(
  prefs: []
  type: TYPE_NORMAL
- en: 'format: "{0}''s favorite wonder is {1}. Its integer is {2}."'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: bob.Name,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: bob.FavoriteAncientWonder,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg2: (int'
  prefs: []
  type: TYPE_NORMAL
- en: )bob.FavoriteAncientWonder);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Bob Smith's favorite wonder is StatueOfZeusAtOlympia. Its integer is 2.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The `enum` value is internally stored as an `int` for efficiency. The `int`
    values are automatically assigned starting at `0` , so the third world wonder
    in our `enum` has a value of `2` . You can assign `int` values that are not listed
    in the `enum` . They will output as the `int` value instead of a name since a
    match will not be found.
  prefs: []
  type: TYPE_NORMAL
- en: Storing multiple values using an enum type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the bucket list, we could create an array or collection of instances of
    the `enum` , and collections will be explained later in this chapter, but there
    is a better way. We can combine multiple choices into a single value using `enum`
    **flags** :'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `enum` by decorating it with the `[System.Flags]` attribute, and
    explicitly set a `byte` value for each wonder that represents different bit columns,
    as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '**[**'
  prefs: []
  type: TYPE_NORMAL
- en: '**System.Flags**'
  prefs: []
  type: TYPE_NORMAL
- en: '**]**'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: enum
  prefs: []
  type: TYPE_NORMAL
- en: WondersOfTheAncientWorld
  prefs: []
  type: TYPE_NORMAL
- en: '**:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**byte**'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '**None                     =**'
  prefs: []
  type: TYPE_NORMAL
- en: '**0b**'
  prefs: []
  type: TYPE_NORMAL
- en: '**_0000_0000,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**// i.e. 0**'
  prefs: []
  type: TYPE_NORMAL
- en: GreatPyramidOfGiza
  prefs: []
  type: TYPE_NORMAL
- en: '**=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**0b**'
  prefs: []
  type: TYPE_NORMAL
- en: '**_0000_0001,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**// i.e. 1**'
  prefs: []
  type: TYPE_NORMAL
- en: HangingGardensOfBabylon
  prefs: []
  type: TYPE_NORMAL
- en: '**=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**0b**'
  prefs: []
  type: TYPE_NORMAL
- en: '**_0000_0010,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**// i.e. 2**'
  prefs: []
  type: TYPE_NORMAL
- en: StatueOfZeusAtOlympia
  prefs: []
  type: TYPE_NORMAL
- en: '**=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**0b**'
  prefs: []
  type: TYPE_NORMAL
- en: '**_0000_0100,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**// i.e. 4**'
  prefs: []
  type: TYPE_NORMAL
- en: TempleOfArtemisAtEphesus
  prefs: []
  type: TYPE_NORMAL
- en: '**=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**0b**'
  prefs: []
  type: TYPE_NORMAL
- en: '**_0000_1000,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**// i.e. 8**'
  prefs: []
  type: TYPE_NORMAL
- en: MausoleumAtHalicarnassus
  prefs: []
  type: TYPE_NORMAL
- en: '**=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**0b**'
  prefs: []
  type: TYPE_NORMAL
- en: '**_0001_0000,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**// i.e. 16**'
  prefs: []
  type: TYPE_NORMAL
- en: ColossusOfRhodes
  prefs: []
  type: TYPE_NORMAL
- en: '**=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**0b**'
  prefs: []
  type: TYPE_NORMAL
- en: '**_0010_0000,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**// i.e. 32**'
  prefs: []
  type: TYPE_NORMAL
- en: LighthouseOfAlexandria
  prefs: []
  type: TYPE_NORMAL
- en: '**=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**0b**'
  prefs: []
  type: TYPE_NORMAL
- en: '**_0100_0000**'
  prefs: []
  type: TYPE_NORMAL
- en: '**// i.e. 64**'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We are assigning explicit values for each choice that would not overlap when
    looking at the bits stored in memory. We should also decorate the `enum` type
    with the `System.Flags` attribute so that when the value is returned it can automatically
    match with multiple values as a comma-separated `string` instead of returning
    an `int` value.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, an `enum` type uses an `int` variable internally, but since we don't
    need values that big, we can reduce memory requirements by 75%, that is, 1 byte
    per value instead of 4 bytes, by telling it to use a `byte` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to indicate that our bucket list includes the *Hanging Gardens of
    Babylon* and the *Mausoleum at Halicarnassus* ancient world wonders, then we would
    want the `16` and `2` bits set to `1` . In other words, we would store the value
    `18` :'
  prefs: []
  type: TYPE_NORMAL
- en: '| 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 0 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'In the `Person` class, add the following statement to your list of fields,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: WondersOfTheAncientWorld BucketList;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to set the bucket list using the `|` operator
    (bitwise logical OR) to combine the enum values. We could also set the value using
    the number 18 cast into the enum type, as shown in the comment, but we shouldn''t
    because that would make the code harder to understand, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: bob.BucketList =
  prefs: []
  type: TYPE_NORMAL
- en: WondersOfTheAncientWorld.HangingGardensOfBabylon
  prefs: []
  type: TYPE_NORMAL
- en: '| WondersOfTheAncientWorld.MausoleumAtHalicarnassus;'
  prefs: []
  type: TYPE_NORMAL
- en: // bob.BucketList = (WondersOfTheAncientWorld)18;
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{bob.Name}'
  prefs: []
  type: TYPE_NORMAL
- en: '''s bucket list is'
  prefs: []
  type: TYPE_NORMAL
- en: '{bob.BucketList}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Bob Smith's bucket list is HangingGardensOfBabylon, MausoleumAtHalicarnassus
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Use the `enum` values to store combinations of discrete
    options. Derive an `enum` type from `byte` if there are up to eight options, from
    `ushort` if there are up to 16 options, from `uint` if there are up to 32 options,
    and from `ulong` if there are up to 64 options.'
  prefs: []
  type: TYPE_NORMAL
- en: Storing multiple values using collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now add a field to store a person''s children. This is an example of
    aggregation because children are instances of a class that is related to the current
    person but are not part of the person itself. We will use a generic `List<T>`
    collection type that can store an ordered collection of any type. You will learn
    more about collections in *Chapter 8* , *Working with Common .NET Types* . For
    now, just follow along:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs` , import the `System.Collections.Generic` namespace, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.Collections.Generic; // List<T>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare a new field in the `Person` class, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: List
  prefs: []
  type: TYPE_NORMAL
- en: <
  prefs: []
  type: TYPE_NORMAL
- en: Person
  prefs: []
  type: TYPE_NORMAL
- en: Children
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: = new
  prefs: []
  type: TYPE_NORMAL
- en: List<Person>();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '`List<Person>` is read aloud as "list of Person," for example, "the type of
    the property named `Children` is a list of `Person` instances." We explicitly
    changed the class library to target .NET Standard 2.0 (that uses the C# 7 compiler),
    so we cannot use target-typed new to initialize the `Children` field. If we had
    left it targeting .NET 6.0, then we could use target-typed new, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> Children = new
  prefs: []
  type: TYPE_NORMAL
- en: ();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We must ensure the collection is initialized to a new instance of a list of
    `Person` before we can add items to it, otherwise, the field will be `null` and
    it will throw runtime exceptions when we try to use any of its members like `Add`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Understanding generic collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The angle brackets in the `List<T>` type is a feature of C# called **generics**
    that was introduced in 2005 with C# 2.0\. It's a fancy term for making a collection
    **strongly typed** , that is, the compiler knows specifically what type of object
    can be stored in the collection. Generics improve the performance and correctness
    of your code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Strongly typed** has a different meaning to **statically typed** . The old
    `System.Collection` types are statically typed to contain weakly typed `System.Object`
    items. The newer `System.Collection.Generic` types are statically typed to contain
    strongly typed `<T>` instances.'
  prefs: []
  type: TYPE_NORMAL
- en: Ironically, the term *generics* means we can use a more specific static type!
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to add two children for `Bob` and then show
    how many children he has and what their names are, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: bob.Children.Add(new
  prefs: []
  type: TYPE_NORMAL
- en: Person { Name = "Alfred"
  prefs: []
  type: TYPE_NORMAL
- en: '}); // C# 3.0 and later'
  prefs: []
  type: TYPE_NORMAL
- en: bob.Children.Add(new
  prefs: []
  type: TYPE_NORMAL
- en: () { Name = "Zoe"
  prefs: []
  type: TYPE_NORMAL
- en: '}); // C# 9.0 and later'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(
  prefs: []
  type: TYPE_NORMAL
- en: $"
  prefs: []
  type: TYPE_NORMAL
- en: '{bob.Name}'
  prefs: []
  type: TYPE_NORMAL
- en: has
  prefs: []
  type: TYPE_NORMAL
- en: '{bob.Children.Count}'
  prefs: []
  type: TYPE_NORMAL
- en: children:"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: for
  prefs: []
  type: TYPE_NORMAL
- en: (int
  prefs: []
  type: TYPE_NORMAL
- en: childIndex = 0
  prefs: []
  type: TYPE_NORMAL
- en: ; childIndex < bob.Children.Count; childIndex++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{bob.Children[childIndex].Name}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We could also use a `foreach` statement to enumerate over the collection. As
    an extra challenge, change the `for` statement to output the same information
    using `foreach` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bob Smith has 2 children:'
  prefs: []
  type: TYPE_NORMAL
- en: Alfred
  prefs: []
  type: TYPE_NORMAL
- en: Zoe
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Making a field static
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fields that we have created so far have all been **instance** members, meaning
    that a different value of each field exists for each instance of the class that
    is created. The `alice` and `bob` variables have different `Name` values.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you want to define a field that only has one value that is shared
    across all instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are called **static** *members* because fields are not the only members
    that can be static. Let''s see what can be achieved using `static` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibrary` project, add a new class file named `BankAccount.cs` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the class to give it three fields, two instance fields and one static
    field, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: BankAccount
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: AccountName; // instance member
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: decimal
  prefs: []
  type: TYPE_NORMAL
- en: Balance; // instance member
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: decimal
  prefs: []
  type: TYPE_NORMAL
- en: InterestRate; // shared member
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Each instance of `BankAccount` will have its own `AccountName` and `Balance`
    values, but all instances will share a single `InterestRate` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to set the shared interest rate and then create
    two instances of the `BankAccount` type, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: BankAccount.InterestRate = 0.012
  prefs: []
  type: TYPE_NORMAL
- en: M; // store a shared value
  prefs: []
  type: TYPE_NORMAL
- en: BankAccount jonesAccount = new
  prefs: []
  type: TYPE_NORMAL
- en: (); // C# 9.0 and later
  prefs: []
  type: TYPE_NORMAL
- en: jonesAccount.AccountName = "Mrs. Jones"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: jonesAccount.Balance = 2400
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine(format: "{0} earned {1:C} interest."'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: jonesAccount.AccountName,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: jonesAccount.Balance * BankAccount.InterestRate);'
  prefs: []
  type: TYPE_NORMAL
- en: BankAccount gerrierAccount = new
  prefs: []
  type: TYPE_NORMAL
- en: ();
  prefs: []
  type: TYPE_NORMAL
- en: gerrierAccount.AccountName = "Ms. Gerrier"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: gerrierAccount.Balance = 98
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine(format: "{0} earned {1:C} interest."'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: gerrierAccount.AccountName,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: gerrierAccount.Balance * BankAccount.InterestRate);'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '`:C` is a format code that tells .NET to use the currency format for the numbers.
    In *Chapter 8* , *Working with Common .NET Types* , you will learn how to control
    the culture that determines the currency symbol. For now, it will use the default
    for your operating system installation. I live in London, UK, hence my output
    shows British Pounds (£).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the additional output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Mrs. Jones earned £28.80 interest.
  prefs: []
  type: TYPE_NORMAL
- en: Ms. Gerrier earned £1.18 interest.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Fields are not the only members that can be static. Constructors, methods, properties,
    and other members can also be static.
  prefs: []
  type: TYPE_NORMAL
- en: Making a field constant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the value of a field will never ever change, you can use the `const` keyword
    and assign a literal value at compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs` , add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // constants
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: const
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: Species = "Homo Sapien"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the value of a constant field, you must write the name of the class,
    not the name of an instance of the class. In `Program.cs` , add a statement to
    write Bob''s name and species to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{bob.Name}'
  prefs: []
  type: TYPE_NORMAL
- en: is a
  prefs: []
  type: TYPE_NORMAL
- en: '{Person.Species}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Bob Smith is a Homo Sapien
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of `const` fields in Microsoft types include `System.Int32.MaxValue`
    and `System.Math.PI` because neither value will ever change, as you can see in
    *Figure 5.2* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email Description automatically
    generated](img/Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Examples of constants'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Constants are not always the best choice for two important
    reasons: the value must be known at compile time, and it must be expressible as
    a literal `string` , `Boolean` , or number value. Every reference to the `const`
    field is replaced with the literal value at compile time, which will, therefore,
    not be reflected if the value changes in a future version and you do not recompile
    any assemblies that reference it to get the new value.'
  prefs: []
  type: TYPE_NORMAL
- en: Making a field read-only
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often a better choice for fields that should not change is to mark them as
    read-only:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs` , add a statement to declare an instance read-only field to
    store a person''s home planet, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // read-only fields
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: readonly
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: HomePlanet = "Earth"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add a statement to write Bob''s name and home planet to the
    console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{bob.Name}'
  prefs: []
  type: TYPE_NORMAL
- en: was born on
  prefs: []
  type: TYPE_NORMAL
- en: '{bob.HomePlanet}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Bob Smith was born on Earth
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Use read-only fields over constant fields for two important
    reasons: the value can be calculated or loaded at runtime and can be expressed
    using any executable statement. So, a read-only field can be set using a constructor
    or a field assignment. Every reference to the field is a live reference, so any
    future changes will be correctly reflected by the calling code.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also declare `static` `readonly` fields whose values will be shared
    across all instances of the type.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing fields with constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fields often need to be initialized at runtime. You do this in a constructor
    that will be called when you make an instance of the class using the `new` keyword.
    Constructors execute before any fields are set by the code that is using the type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs` , add statements after the existing read-only `HomePlanet` field
    to define a second read-only field and then set the `Name` and `Instantiated`
    fields in a constructor, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // read-only fields
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: readonly
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: HomePlanet = "Earth"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '**public**'
  prefs: []
  type: TYPE_NORMAL
- en: '**readonly**'
  prefs: []
  type: TYPE_NORMAL
- en: '**DateTime Instantiated;**'
  prefs: []
  type: TYPE_NORMAL
- en: '**// constructors**'
  prefs: []
  type: TYPE_NORMAL
- en: '**public**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Person**'
  prefs: []
  type: TYPE_NORMAL
- en: '**()**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**// set default values for fields**'
  prefs: []
  type: TYPE_NORMAL
- en: '**// including read-only fields**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name =**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"Unknown"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**;**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Instantiated = DateTime.Now;**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to instantiate a new person and then output
    its initial field values, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Person blankPerson = new
  prefs: []
  type: TYPE_NORMAL
- en: ();
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine(format:'
  prefs: []
  type: TYPE_NORMAL
- en: '"{0} of {1} was created at {2:hh:mm:ss} on a {2:dddd}."'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: blankPerson.Name,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: blankPerson.HomePlanet,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg2: blankPerson.Instantiated);'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Unknown of Earth was created at 11:58:12 on a Sunday
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Defining multiple constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can have multiple constructors in a type. This is especially useful to
    encourage developers to set initial values for fields:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs` , add statements to define a second constructor that allows
    a developer to set initial values for the person''s name and home planet, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: Person
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: initialName,
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: homePlanet
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Name = initialName;
  prefs: []
  type: TYPE_NORMAL
- en: HomePlanet = homePlanet;
  prefs: []
  type: TYPE_NORMAL
- en: Instantiated = DateTime.Now;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to create another person using the constructor
    with two parameters, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Person gunny = new
  prefs: []
  type: TYPE_NORMAL
- en: '(initialName: "Gunny"'
  prefs: []
  type: TYPE_NORMAL
- en: ', homePlanet: "Mars"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine(format:'
  prefs: []
  type: TYPE_NORMAL
- en: '"{0} of {1} was created at {2:hh:mm:ss} on a {2:dddd}."'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: gunny.Name,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: gunny.HomePlanet,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg2: gunny.Instantiated);'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Gunny of Mars was created at 11:59:25 on a Sunday
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Constructors are a special category of method. Let's look at methods in more
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: Writing and calling methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Methods** are members of a type that execute a block of statements. They
    are functions that belong to a type.'
  prefs: []
  type: TYPE_NORMAL
- en: Returning values from methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Methods can return a single value or return nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: A method that performs some actions but does not return a value indicates this
    with the `void` type before the name of the method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method that performs some actions and returns a value indicates this with
    the type of the return value before the name of the method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, in the next task, you will create two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WriteToConsole` : This will perform an action (writing some text to the console),
    but it will return nothing from the method, indicated by the `void` keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetOrigin` : This will return a text value, indicated by the `string` keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s write the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs` , add statements to define the two methods that I described
    earlier, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // methods
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: WriteToConsole
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{Name}'
  prefs: []
  type: TYPE_NORMAL
- en: was born on a
  prefs: []
  type: TYPE_NORMAL
- en: '{DateOfBirth:dddd}'
  prefs: []
  type: TYPE_NORMAL
- en: ."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: GetOrigin
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: $"
  prefs: []
  type: TYPE_NORMAL
- en: '{Name}'
  prefs: []
  type: TYPE_NORMAL
- en: was born on
  prefs: []
  type: TYPE_NORMAL
- en: '{HomePlanet}'
  prefs: []
  type: TYPE_NORMAL
- en: ."
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to call the two methods, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: bob.WriteToConsole();
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(bob.GetOrigin());
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Bob Smith was born on a Wednesday.
  prefs: []
  type: TYPE_NORMAL
- en: Bob Smith was born on Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Combining multiple returned values using tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each method can only return a single value that has a single type. That type
    could be a simple type, such as `string` in the previous example, a complex type,
    such as `Person` , or a collection type, such as `List<Person>` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we want to define a method named `GetTheData` that needs to return
    both a `string` value and an `int` value. We could define a new class named `TextAndNumber`
    with a `string` field and an `int` field, and return an instance of that complex
    type, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: TextAndNumber
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: Text;
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: Number;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: LifeTheUniverseAndEverything
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: TextAndNumber
  prefs: []
  type: TYPE_NORMAL
- en: GetTheData
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: TextAndNumber
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Text = "What's the meaning of life?"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: Number = 42
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: But defining a class just to combine two values together is unnecessary, because
    in modern versions of C# we can use **tuples** . Tuples are an efficient way to
    combine two or more values into a single unit. I pronounce them as tuh-ples but
    I have heard other developers pronounce them as too-ples. To-may-toe, to-mah-toe,
    po-tay-toe, po-tah-toe, I guess.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples have been a part of some languages such as F# since their first version,
    but .NET only added support for them with .NET 4.0 in 2010 using the `System.Tuple`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Language support for tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It was only with C# 7.0 in 2017 that C# added language syntax support for tuples
    using the parentheses characters `()` and at the same time, .NET added a new `System.ValueTuple`
    type that is more efficient in some common scenarios than the old .NET 4.0 `System.Tuple`
    type. The C# tuple syntax uses the more efficient one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs` , add statements to define a method that returns a tuple that
    combines a `string` and `int` , as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: (string
  prefs: []
  type: TYPE_NORMAL
- en: ', int'
  prefs: []
  type: TYPE_NORMAL
- en: ) GetFruit()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: ("Apples"
  prefs: []
  type: TYPE_NORMAL
- en: ', 5'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to call the `GetFruit` method and then output
    the tuple''s fields automatically named `Item1` and `Item2` , as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: (string
  prefs: []
  type: TYPE_NORMAL
- en: ', int'
  prefs: []
  type: TYPE_NORMAL
- en: ) fruit = bob.GetFruit();
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{fruit.Item1}'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: '{fruit.Item2}'
  prefs: []
  type: TYPE_NORMAL
- en: there are."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Apples, 5 there are.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Naming the fields of a tuple
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To access the fields of a tuple, the default names are `Item1` , `Item2` , and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can explicitly specify the field names:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs` , add statements to define a method that returns a tuple with
    named fields, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: (string
  prefs: []
  type: TYPE_NORMAL
- en: Name, int
  prefs: []
  type: TYPE_NORMAL
- en: Number) GetNamedFruit()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: '(Name: "Apples"'
  prefs: []
  type: TYPE_NORMAL
- en: ', Number: 5'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to call the method and output the tuple''s
    named fields, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: fruitNamed = bob.GetNamedFruit();
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"There are
  prefs: []
  type: TYPE_NORMAL
- en: '{fruitNamed.Number}'
  prefs: []
  type: TYPE_NORMAL
- en: '{fruitNamed.Name}'
  prefs: []
  type: TYPE_NORMAL
- en: ."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: There are 5 Apples.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Inferring tuple names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are constructing a tuple from another object, you can use a feature introduced
    in C# 7.1 called **tuple name inference** .
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , create two tuples, made of a `string` and `int` value each,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: thing1 = ("Neville"
  prefs: []
  type: TYPE_NORMAL
- en: ', 4'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{thing1.Item1}'
  prefs: []
  type: TYPE_NORMAL
- en: has
  prefs: []
  type: TYPE_NORMAL
- en: '{thing1.Item2}'
  prefs: []
  type: TYPE_NORMAL
- en: children."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: thing2 = (bob.Name, bob.Children.Count);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{thing2.Name}'
  prefs: []
  type: TYPE_NORMAL
- en: has
  prefs: []
  type: TYPE_NORMAL
- en: '{thing2.Count}'
  prefs: []
  type: TYPE_NORMAL
- en: children."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In C# 7.0, both things would use the `Item1` and `Item2` naming schemes. In
    C# 7.1 and later, `thing2` can infer the names `Name` and `Count` .
  prefs: []
  type: TYPE_NORMAL
- en: Deconstructing tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also deconstruct tuples into separate variables. The deconstructing
    declaration has the same syntax as named field tuples, but without a named variable
    for the tuple, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // store return value in a tuple variable with two fields
  prefs: []
  type: TYPE_NORMAL
- en: (string
  prefs: []
  type: TYPE_NORMAL
- en: TheName, int
  prefs: []
  type: TYPE_NORMAL
- en: TheNumber) tupleWithNamedFields = bob.GetNamedFruit();
  prefs: []
  type: TYPE_NORMAL
- en: // tupleWithNamedFields.TheName
  prefs: []
  type: TYPE_NORMAL
- en: // tupleWithNamedFields.TheNumber
  prefs: []
  type: TYPE_NORMAL
- en: // deconstruct return value into two separate variables
  prefs: []
  type: TYPE_NORMAL
- en: (string
  prefs: []
  type: TYPE_NORMAL
- en: name, int
  prefs: []
  type: TYPE_NORMAL
- en: number) = GetNamedFruit();
  prefs: []
  type: TYPE_NORMAL
- en: // name
  prefs: []
  type: TYPE_NORMAL
- en: // number
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This has the effect of splitting the tuple into its parts and assigning those
    parts to new variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to deconstruct the tuple returned from the
    `GetFruit` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: (string
  prefs: []
  type: TYPE_NORMAL
- en: fruitName, int
  prefs: []
  type: TYPE_NORMAL
- en: fruitNumber) = bob.GetFruit();
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Deconstructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '{fruitName}'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: '{fruitNumber}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deconstructed: Apples, 5'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Deconstructing types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tuples are not the only type that can be deconstructed. Any type can have special
    methods named `Deconstruct` that break down the object into parts. Let''s implement
    some for the `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs` , add two `Deconstruct` methods with `out` parameters defined
    for the parts we want to deconstruct into, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // deconstructors
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: Deconstruct
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: out
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: name,
  prefs: []
  type: TYPE_NORMAL
- en: out
  prefs: []
  type: TYPE_NORMAL
- en: DateTime dob
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: name = Name;
  prefs: []
  type: TYPE_NORMAL
- en: dob = DateOfBirth;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: Deconstruct
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: out
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: name,
  prefs: []
  type: TYPE_NORMAL
- en: out
  prefs: []
  type: TYPE_NORMAL
- en: DateTime dob,
  prefs: []
  type: TYPE_NORMAL
- en: out
  prefs: []
  type: TYPE_NORMAL
- en: WondersOfTheAncientWorld fav
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: name = Name;
  prefs: []
  type: TYPE_NORMAL
- en: dob = DateOfBirth;
  prefs: []
  type: TYPE_NORMAL
- en: fav = FavoriteAncientWonder;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to deconstruct `bob` , as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // Deconstructing a Person
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: (name1, dob1) = bob;
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Deconstructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '{name1}'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: '{dob1}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: (name2, dob2, fav2) = bob;
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Deconstructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '{name2}'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: '{dob2}'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: '{fav2}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deconstructed: Bob Smith, 22/12/1965 00:00:00'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deconstructed: Bob Smith, 22/12/1965 00:00:00, StatueOfZeusAtOlympia'
  prefs: []
  type: TYPE_NORMAL
- en: B
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Defining and passing parameters to methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Methods can have parameters passed to them to change their behavior. Parameters
    are defined a bit like variable declarations but inside the parentheses of the
    method, as you saw earlier in this chapter with constructors. Let''s see more
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs` , add statements to define two methods, the first without parameters
    and the second with one parameter, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: SayHello
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: $"
  prefs: []
  type: TYPE_NORMAL
- en: '{Name}'
  prefs: []
  type: TYPE_NORMAL
- en: says 'Hello!'"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: SayHelloTo
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: name
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: $"
  prefs: []
  type: TYPE_NORMAL
- en: '{Name}'
  prefs: []
  type: TYPE_NORMAL
- en: says 'Hello
  prefs: []
  type: TYPE_NORMAL
- en: '{name}'
  prefs: []
  type: TYPE_NORMAL
- en: '!''"'
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to call the two methods and write the return
    value to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(bob.SayHello());
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(bob.SayHelloTo("Emily"
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Bob Smith says 'Hello!'
  prefs: []
  type: TYPE_NORMAL
- en: Bob Smith says 'Hello Emily!'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'When typing a statement that calls a method, IntelliSense shows a tooltip with
    the name and type of any parameters, and the return type of the method, as shown
    in *Figure 5.3* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, website Description automatically generated](img/Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: An IntelliSense tooltip for a method with no overloads'
  prefs: []
  type: TYPE_NORMAL
- en: Overloading methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of having two different method names, we could give both methods the
    same name. This is allowed because the methods each have a different signature.
  prefs: []
  type: TYPE_NORMAL
- en: A **method signature** is a list of parameter types that can be passed when
    calling the method. Overloaded methods cannot differ only in the return type.
  prefs: []
  type: TYPE_NORMAL
- en: In `Person.cs` , change the name of the `SayHelloTo` method to `SayHello` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Program.cs` , change the method call to use the `SayHello` method, and note
    that the quick info for the method tells you that it has one additional overload,
    1/2, as well as 2/2, as shown in *Figure 5.4* :![Graphical user interface Description
    automatically generated with medium confidence](img/Image00067.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 5.4: An IntelliSense tooltip for an overloaded method'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Use overloaded methods to simplify your class by making
    it appear to have fewer methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Passing optional and named parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to simplify methods is to make parameters optional. You make a parameter
    optional by assigning a default value inside the method parameter list. Optional
    parameters must always come last in the list of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now create a method with three optional parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs` , add statements to define the method, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: OptionalParameters
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: command  =
  prefs: []
  type: TYPE_NORMAL
- en: '"Run!"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: double
  prefs: []
  type: TYPE_NORMAL
- en: number =
  prefs: []
  type: TYPE_NORMAL
- en: '0.0'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: active =
  prefs: []
  type: TYPE_NORMAL
- en: 'true'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: .Format(
  prefs: []
  type: TYPE_NORMAL
- en: 'format: "command is {0}, number is {1}, active is {2}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: command,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: number,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg2: active);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add a statement to call the method and write its return value
    to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(bob.OptionalParameters());
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Watch IntelliSense appear as you type the code. You will see a tooltip, showing
    the three optional parameters with their default values, as shown in *Figure 5.5*
    :![Graphical user interface, text, application, chat or text message Description
    automatically generated](img/Image00068.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 5.5: IntelliSense showing optional parameters as you type code'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: command is Run!, number is 0, active is True
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add a statement to pass a `string` value for the `command`
    parameter and a `double` value for the `number` parameter, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(bob.OptionalParameters("Jump!"
  prefs: []
  type: TYPE_NORMAL
- en: ', 98.5'
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and see the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: command is Jump!, number is 98.5, active is True
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The default values for the `command` and `number` parameters have been replaced,
    but the default for `active` is still `true` .
  prefs: []
  type: TYPE_NORMAL
- en: Naming parameter values when calling methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Optional parameters are often combined with naming parameters when you call
    the method, because naming a parameter allows the values to be passed in a different
    order than how they were declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add a statement to pass a `string` value for the `command`
    parameter and a `double` value for the `number` parameter but using named parameters,
    so that the order they are passed through can be swapped around, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(bob.OptionalParameters(
  prefs: []
  type: TYPE_NORMAL
- en: 'number: 52.7'
  prefs: []
  type: TYPE_NORMAL
- en: ', command: "Hide!"'
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: command is Hide!, number is 52.7, active is True
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: You can even use named parameters to skip over optional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add a statement to pass a `string` value for the `command`
    parameter using positional order, skip the `number` parameter, and use the named
    `active` parameter, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(bob.OptionalParameters("Poke!"
  prefs: []
  type: TYPE_NORMAL
- en: ', active: false'
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: command is Poke!, number is 0, active is False
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling how parameters are passed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a parameter is passed into a method, it can be passed in one of three
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By **value** (this is the default): Think of these as being *in-only* .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By **reference** as a `ref` parameter: Think of these as being *in-and-out*
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an `out` parameter: Think of these as being *out-only* .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see some examples of passing parameters in and out:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs` , add statements to define a method with three parameters, one
    `in` parameter, one `ref` parameter, and one `out` parameter, as shown in the
    following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: PassingParameters
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: x,
  prefs: []
  type: TYPE_NORMAL
- en: ref
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: y,
  prefs: []
  type: TYPE_NORMAL
- en: out
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: z
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // out parameters cannot have a default
  prefs: []
  type: TYPE_NORMAL
- en: // AND must be initialized inside the method
  prefs: []
  type: TYPE_NORMAL
- en: z = 99
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: // increment each parameter
  prefs: []
  type: TYPE_NORMAL
- en: x++;
  prefs: []
  type: TYPE_NORMAL
- en: y++;
  prefs: []
  type: TYPE_NORMAL
- en: z++;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to declare some `int` variables and pass them
    into the method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: a = 10
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: b = 20
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: c = 30
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Before: a ='
  prefs: []
  type: TYPE_NORMAL
- en: '{a}'
  prefs: []
  type: TYPE_NORMAL
- en: ', b ='
  prefs: []
  type: TYPE_NORMAL
- en: '{b}'
  prefs: []
  type: TYPE_NORMAL
- en: ', c ='
  prefs: []
  type: TYPE_NORMAL
- en: '{c}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: bob.PassingParameters(a, ref
  prefs: []
  type: TYPE_NORMAL
- en: b, out
  prefs: []
  type: TYPE_NORMAL
- en: c);
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"After: a ='
  prefs: []
  type: TYPE_NORMAL
- en: '{a}'
  prefs: []
  type: TYPE_NORMAL
- en: ', b ='
  prefs: []
  type: TYPE_NORMAL
- en: '{b}'
  prefs: []
  type: TYPE_NORMAL
- en: ', c ='
  prefs: []
  type: TYPE_NORMAL
- en: '{c}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before: a = 10, b = 20, c = 30'
  prefs: []
  type: TYPE_NORMAL
- en: 'After: a = 10, b = 21, c = 100'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: When passing a variable as a parameter by default, its current value gets passed,
    not the variable itself. Therefore, `x` has a copy of the value of the `a` variable.
    The `a` variable retains its original value of `10` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When passing a variable as a `ref` parameter, a reference to the variable gets
    passed into the method. Therefore, `y` is a reference to `b` . The `b` variable
    gets incremented when the `y` parameter gets incremented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When passing a variable as an `out` parameter, a reference to the variable gets
    passed into the method. Therefore, `z` is a reference to `c` . The value of the
    `c` variable gets replaced by whatever code executes inside the method. We could
    simplify the code in the `Main` method by not assigning the value `30` to the
    `c` variable since it will always be replaced anyway.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplified out parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In C# 7.0 and later, we can simplify code that uses the out variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to declare some more variables including an
    `out` parameter named `f` declared inline, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: d = 10
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: e = 20
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Before: d ='
  prefs: []
  type: TYPE_NORMAL
- en: '{d}'
  prefs: []
  type: TYPE_NORMAL
- en: ', e ='
  prefs: []
  type: TYPE_NORMAL
- en: '{e}'
  prefs: []
  type: TYPE_NORMAL
- en: ', f doesn''t exist yet!"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: // simplified C# 7.0 or later syntax for the out parameter
  prefs: []
  type: TYPE_NORMAL
- en: bob.PassingParameters(d, ref
  prefs: []
  type: TYPE_NORMAL
- en: e, out
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: f);
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"After: d ='
  prefs: []
  type: TYPE_NORMAL
- en: '{d}'
  prefs: []
  type: TYPE_NORMAL
- en: ', e ='
  prefs: []
  type: TYPE_NORMAL
- en: '{e}'
  prefs: []
  type: TYPE_NORMAL
- en: ', f ='
  prefs: []
  type: TYPE_NORMAL
- en: '{f}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ref returns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C# 7.0 or later, the `ref` keyword is not just for passing parameters into
    a method; it can also be applied to the `return` value. This allows an external
    variable to reference an internal variable and modify its value after the method
    call. This might be useful in advanced scenarios, for example, passing around
    placeholders into big data structures, but it's beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting classes using partial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working on large projects with multiple team members, or when working with
    especially large and complex class implementations, it is useful to be able to
    split the definition of a class across multiple files. You do this using the `partial`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine we want to add statements to the `Person` class that are automatically
    generated by a tool like an object-relational mapper that reads schema information
    from a database. If the class is defined as `partial` , then we can split the
    class into an autogenerated code file and a manually edited code file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write some code that simulates this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs` , add the `partial` keyword, as shown highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: '**partial**'
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Person
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibrary` project/folder, add a new class file named `PersonAutoGen.cs`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add statements to the new file, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: partial
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Person
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code we write for this chapter will be written in the `PersonAutoGen.cs`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling access with properties and indexers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier, you created a method named `GetOrigin` that returned a `string` containing
    the name and origin of the person. Languages such as Java do this a lot. C# has
    a better way: properties.'
  prefs: []
  type: TYPE_NORMAL
- en: A property is simply a method (or a pair of methods) that acts and looks like
    a field when you want to get or set a value, thereby simplifying the syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Defining read-only properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `readonly` property only has a `get` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `PersonAutoGen.cs` , in the `Person` class, add statements to define three
    properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first property will perform the same role as the `GetOrigin` method using
    the property syntax that works with all versions of C# (although, it uses the
    string interpolation syntax from C# 6 and later).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second property will return a greeting message using the lambda expression
    body `=>` syntax from C# 6 and later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third property will calculate the person's age.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // a property defined using C# 1 - 5 syntax
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: Origin
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: get
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: $"
  prefs: []
  type: TYPE_NORMAL
- en: '{Name}'
  prefs: []
  type: TYPE_NORMAL
- en: was born on
  prefs: []
  type: TYPE_NORMAL
- en: '{HomePlanet}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // two properties defined using C# 6+ lambda expression body syntax
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: Greeting => $"
  prefs: []
  type: TYPE_NORMAL
- en: '{Name}'
  prefs: []
  type: TYPE_NORMAL
- en: says 'Hello!'"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: Age => System.DateTime.Today.Year - DateOfBirth.Year;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : This isn''t the best way to calculate someone''s age, but
    we aren''t learning how to calculate an age from a date of birth. If you need
    to do that properly, read the discussion at the following link: [https://stackoverflow.com/questions/9/how-do-i-calculate-someones-age-in-c](https://stackoverflow.com/questions/9/how-do-i-calculate-someones-age-in-c)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add the statements to get the properties, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Person sam = new
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Name = "Sam"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: DateOfBirth = new
  prefs: []
  type: TYPE_NORMAL
- en: (1972
  prefs: []
  type: TYPE_NORMAL
- en: ', 1'
  prefs: []
  type: TYPE_NORMAL
- en: ', 27'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(sam.Origin);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(sam.Greeting);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(sam.Age);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Sam was born on Earth
  prefs: []
  type: TYPE_NORMAL
- en: Sam says 'Hello!'
  prefs: []
  type: TYPE_NORMAL
- en: '49'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The output shows 49 because I ran the console application on August 15, 2021
    when Sam was 49 years old.
  prefs: []
  type: TYPE_NORMAL
- en: Defining settable properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a settable property, you must use the older syntax and provide a
    pair of methods—not just a `get` part, but also a `set` part:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `PersonAutoGen.cs` , add statements to define a `string` property that has
    both a `get` and `set` method (also known as a getter and setter), as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: FavoriteIceCream { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; } // auto-syntax
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Although you have not manually created a field to store the person's favorite
    ice cream, it is there, automatically created by the compiler for you.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you need more control over what happens when a property is set. In
    this scenario, you must use a more detailed syntax and manually create a `private`
    field to store the value for the property.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `PersonAutoGen.cs` , add statements to define a `string` field and `string`
    property that has both a `get` and `set` , as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: private
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: favoritePrimaryColor;
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: FavoritePrimaryColor
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: get
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: favoritePrimaryColor;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: set
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: switch
  prefs: []
  type: TYPE_NORMAL
- en: (value
  prefs: []
  type: TYPE_NORMAL
- en: .ToLower())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: case
  prefs: []
  type: TYPE_NORMAL
- en: '"red"'
  prefs: []
  type: TYPE_NORMAL
- en: ':'
  prefs: []
  type: TYPE_NORMAL
- en: case
  prefs: []
  type: TYPE_NORMAL
- en: '"green"'
  prefs: []
  type: TYPE_NORMAL
- en: ':'
  prefs: []
  type: TYPE_NORMAL
- en: case
  prefs: []
  type: TYPE_NORMAL
- en: '"blue"'
  prefs: []
  type: TYPE_NORMAL
- en: ':'
  prefs: []
  type: TYPE_NORMAL
- en: favoritePrimaryColor = value
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: break
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: default
  prefs: []
  type: TYPE_NORMAL
- en: ':'
  prefs: []
  type: TYPE_NORMAL
- en: throw
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: System.ArgumentException(
  prefs: []
  type: TYPE_NORMAL
- en: $"
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: value
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: is not a primary color. "
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: '"Choose from: red, green, blue."'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Avoid adding too much code to your getters and setters.
    This could indicate a problem with your design. Consider adding private methods
    that you then call in setters and getters to simplify your implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to set Sam''s favorite ice cream and color,
    and then write them out, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: sam.FavoriteIceCream = "Chocolate Fudge"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Sam's favorite ice-cream flavor is
  prefs: []
  type: TYPE_NORMAL
- en: '{sam.FavoriteIceCream}'
  prefs: []
  type: TYPE_NORMAL
- en: ."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: sam.FavoritePrimaryColor = "Red"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Sam's favorite primary color is
  prefs: []
  type: TYPE_NORMAL
- en: '{sam.FavoritePrimaryColor}'
  prefs: []
  type: TYPE_NORMAL
- en: ."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Sam's favorite ice-cream flavor is Chocolate Fudge.
  prefs: []
  type: TYPE_NORMAL
- en: Sam's favorite primary color is Red.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: If you try to set the color to any value other than red, green, or blue, then
    the code will throw an exception. The calling code could then use a `try` statement
    to display the error message.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Use properties instead of fields when you want to validate
    what value can be stored when you want to data bind in XAML, which we will cover
    in *Chapter 19* , *Building Mobile and Desktop Apps Using .NET MAUI* (available
    at [https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf](https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf)
    ), and when you want to read and write to a field without using a method pair
    like `GetAge` and `SetAge` .'
  prefs: []
  type: TYPE_NORMAL
- en: Requiring properties to be set during instantiation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C# 10 introduces the `required` modifier. If you use it on a property, the
    compiler will ensure that you set the property to a value when you instantiate
    it, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Book
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: required string
  prefs: []
  type: TYPE_NORMAL
- en: Isbn { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: Title { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you attempt to instantiate a `Book` without setting the `Isbn` property
    you will see a compiler error, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Book novel = new
  prefs: []
  type: TYPE_NORMAL
- en: ();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The `required` keyword might not make it into the final release version of .NET
    6 so treat this section as theoretical.
  prefs: []
  type: TYPE_NORMAL
- en: Defining indexers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Indexers allow the calling code to use the array syntax to access a property.
    For example, the `string` type defines an **indexer** so that the calling code
    can access individual characters in the `string` .
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define an indexer to simplify access to the children of a person:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `PersonAutoGen.cs` , add statements to define an indexer to get and set
    a child using the index of the child, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // indexers
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: Person this
  prefs: []
  type: TYPE_NORMAL
- en: '[int'
  prefs: []
  type: TYPE_NORMAL
- en: index]
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: get
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: Children[index]; // pass on to the List<T> indexer
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: set
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Children[index] = value
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: You can overload indexers so that different types can be used for their parameters.
    For example, as well as passing an `int` value, you could also pass a `string`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to add two children to `Sam` , and then access
    the first and second child using the longer `Children` field and the shorter indexer
    syntax, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: sam.Children.Add(new
  prefs: []
  type: TYPE_NORMAL
- en: () { Name = "Charlie"
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: sam.Children.Add(new
  prefs: []
  type: TYPE_NORMAL
- en: () { Name = "Ella"
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Sam's first child is
  prefs: []
  type: TYPE_NORMAL
- en: '{sam.Children['
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '].Name}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Sam's second child is
  prefs: []
  type: TYPE_NORMAL
- en: '{sam.Children['
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '].Name}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Sam's first child is
  prefs: []
  type: TYPE_NORMAL
- en: '{sam['
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '].Name}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Sam's second child is
  prefs: []
  type: TYPE_NORMAL
- en: '{sam['
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '].Name}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Sam's first child is Charlie
  prefs: []
  type: TYPE_NORMAL
- en: Sam's second child is Ella
  prefs: []
  type: TYPE_NORMAL
- en: Sam's first child is Charlie
  prefs: []
  type: TYPE_NORMAL
- en: Sam's second child is Ella
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching with objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 3* , *Controlling Flow, Converting Types, and Handling Exceptions*
    , you were introduced to basic pattern matching. In this section, we will explore
    pattern matching in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and referencing a .NET 6 class library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The enhanced pattern matching features are only available in modern .NET class
    libraries that support C# 9 or later.
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred coding tool to add a new class library named `PacktLibraryModern`
    to the workspace/solution named `Chapter05` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `PeopleApp` project, add a reference to the `PacktLibraryModern` class
    library, as shown highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: <Project Sdk="Microsoft.NET.Sdk"
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: <PropertyGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <OutputType>Exe</OutputType>
  prefs: []
  type: TYPE_NORMAL
- en: <TargetFramework>net6.0
  prefs: []
  type: TYPE_NORMAL
- en: </TargetFramework>
  prefs: []
  type: TYPE_NORMAL
- en: <Nullable>enable</Nullable>
  prefs: []
  type: TYPE_NORMAL
- en: <ImplicitUsings>enable</ImplicitUsings>
  prefs: []
  type: TYPE_NORMAL
- en: </PropertyGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <ProjectReference Include="../PacktLibrary/PacktLibrary.csproj"
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: '**<ProjectReference**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Include=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"../PacktLibraryModern/PacktLibraryModern.csproj"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**/>**'
  prefs: []
  type: TYPE_NORMAL
- en: </ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: </Project>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Build the `PeopleApp` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining flight passengers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we will define some classes that represent various types of
    passengers on a flight and then we will use a switch expression with pattern matching
    to determine the cost of their flight.
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibraryModern` project/folder, rename the file `Class1.cs` to `FlightPatterns.cs`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `FlightPatterns.cs` , add statements to define three types of passengers
    with different properties, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: ; // C# 10 file-scoped namespace
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: BusinessClassPassenger
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: override
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: ToString
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: $"Business Class"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: FirstClassPassenger
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: AirMiles { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: override
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: ToString
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: $"First Class with
  prefs: []
  type: TYPE_NORMAL
- en: '{AirMiles:N0}'
  prefs: []
  type: TYPE_NORMAL
- en: air miles"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: CoachClassPassenger
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: double
  prefs: []
  type: TYPE_NORMAL
- en: CarryOnKG { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: override
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: ToString
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: $"Coach Class with
  prefs: []
  type: TYPE_NORMAL
- en: '{CarryOnKG:N2}'
  prefs: []
  type: TYPE_NORMAL
- en: KG carry on"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to define an object array containing five
    passengers of various types and property values, and then enumerate them, outputting
    the cost of their flight, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: object
  prefs: []
  type: TYPE_NORMAL
- en: '[] passengers = {'
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: FirstClassPassenger { AirMiles = 1
  prefs: []
  type: TYPE_NORMAL
- en: _419 },
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: FirstClassPassenger { AirMiles = 16
  prefs: []
  type: TYPE_NORMAL
- en: _562 },
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: BusinessClassPassenger(),
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: CoachClassPassenger { CarryOnKG = 25.7
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: CoachClassPassenger { CarryOnKG = 0
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (object
  prefs: []
  type: TYPE_NORMAL
- en: passenger in
  prefs: []
  type: TYPE_NORMAL
- en: passengers)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: decimal
  prefs: []
  type: TYPE_NORMAL
- en: flightCost = passenger switch
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: FirstClassPassenger p when
  prefs: []
  type: TYPE_NORMAL
- en: p.AirMiles > 35000
  prefs: []
  type: TYPE_NORMAL
- en: => 1500
  prefs: []
  type: TYPE_NORMAL
- en: M,
  prefs: []
  type: TYPE_NORMAL
- en: FirstClassPassenger p when
  prefs: []
  type: TYPE_NORMAL
- en: p.AirMiles > 15000
  prefs: []
  type: TYPE_NORMAL
- en: => 1750
  prefs: []
  type: TYPE_NORMAL
- en: M,
  prefs: []
  type: TYPE_NORMAL
- en: FirstClassPassenger _                         => 2000
  prefs: []
  type: TYPE_NORMAL
- en: M,
  prefs: []
  type: TYPE_NORMAL
- en: BusinessClassPassenger _                      => 1000
  prefs: []
  type: TYPE_NORMAL
- en: M,
  prefs: []
  type: TYPE_NORMAL
- en: CoachClassPassenger p when
  prefs: []
  type: TYPE_NORMAL
- en: p.CarryOnKG < 10.0
  prefs: []
  type: TYPE_NORMAL
- en: => 500
  prefs: []
  type: TYPE_NORMAL
- en: M,
  prefs: []
  type: TYPE_NORMAL
- en: CoachClassPassenger _                         => 650
  prefs: []
  type: TYPE_NORMAL
- en: M,
  prefs: []
  type: TYPE_NORMAL
- en: _                                             => 800
  prefs: []
  type: TYPE_NORMAL
- en: M
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Flight costs
  prefs: []
  type: TYPE_NORMAL
- en: '{flightCost:C}'
  prefs: []
  type: TYPE_NORMAL
- en: for
  prefs: []
  type: TYPE_NORMAL
- en: '{passenger}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'While reviewing the preceding code, note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: To pattern match on the properties of an object, you must name a local variable
    that can then be used in an expression like `p` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To pattern match on a type only, you can use `_` to discard the local variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The switch expression also uses `_` to represent its default branch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Flight costs £2,000.00 for First Class with 1,419 air miles
  prefs: []
  type: TYPE_NORMAL
- en: Flight costs £1,750.00 for First Class with 16,562 air miles
  prefs: []
  type: TYPE_NORMAL
- en: Flight costs £1,000.00 for Business Class
  prefs: []
  type: TYPE_NORMAL
- en: Flight costs £650.00 for Coach Class with 25.70 KG carry on
  prefs: []
  type: TYPE_NORMAL
- en: Flight costs £500.00 for Coach Class with 0.00 KG carry on
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Enhancements to pattern matching in C# 9 or later
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous examples worked with C# 8\. Now we will look at some enhancements
    in C# 9 and later. First, you no longer need to use the underscore to discard
    when doing type matching:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , comment out the C# 8 syntax and add C# 9 and later syntax
    to modify the branches for first-class passengers to use a nested switch expression
    and the new support for conditionals like `>` , as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: decimal
  prefs: []
  type: TYPE_NORMAL
- en: flightCost = passenger switch
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: /* C# 8 syntax
  prefs: []
  type: TYPE_NORMAL
- en: FirstClassPassenger p when p.AirMiles > 35000 => 1500M,
  prefs: []
  type: TYPE_NORMAL
- en: FirstClassPassenger p when p.AirMiles > 15000 => 1750M,
  prefs: []
  type: TYPE_NORMAL
- en: FirstClassPassenger                           => 2000M, */
  prefs: []
  type: TYPE_NORMAL
- en: // C# 9 or later syntax
  prefs: []
  type: TYPE_NORMAL
- en: FirstClassPassenger p => p.AirMiles switch
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '35000'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: => 1500
  prefs: []
  type: TYPE_NORMAL
- en: M,
  prefs: []
  type: TYPE_NORMAL
- en: '15000'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: => 1750
  prefs: []
  type: TYPE_NORMAL
- en: M,
  prefs: []
  type: TYPE_NORMAL
- en: _       => 2000
  prefs: []
  type: TYPE_NORMAL
- en: M
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: BusinessClassPassenger                        => 1000
  prefs: []
  type: TYPE_NORMAL
- en: M,
  prefs: []
  type: TYPE_NORMAL
- en: CoachClassPassenger p when
  prefs: []
  type: TYPE_NORMAL
- en: p.CarryOnKG < 10.0
  prefs: []
  type: TYPE_NORMAL
- en: => 500
  prefs: []
  type: TYPE_NORMAL
- en: M,
  prefs: []
  type: TYPE_NORMAL
- en: CoachClassPassenger                           => 650
  prefs: []
  type: TYPE_NORMAL
- en: M,
  prefs: []
  type: TYPE_NORMAL
- en: _                                             => 800
  prefs: []
  type: TYPE_NORMAL
- en: M
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Run the code to view the results, and note they are the same as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You could also use the relational pattern in combination with the property
    pattern to avoid the nested switch expression, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'FirstClassPassenger { AirMiles: > 35000'
  prefs: []
  type: TYPE_NORMAL
- en: '} => 1500'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'FirstClassPassenger { AirMiles: > 15000'
  prefs: []
  type: TYPE_NORMAL
- en: '} => 1750'
  prefs: []
  type: TYPE_NORMAL
- en: M,
  prefs: []
  type: TYPE_NORMAL
- en: FirstClassPassenger => 2000
  prefs: []
  type: TYPE_NORMAL
- en: M,
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Working with records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into the new records language feature of C# 9 and later, let
    us see some other related new features.
  prefs: []
  type: TYPE_NORMAL
- en: Init-only properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have used object initialization syntax to instantiate objects and set initial
    properties throughout this chapter. Those properties can also be changed after
    instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you want to treat properties like `readonly` fields so they can be
    set during instantiation but not after. The new `init` keyword enables this. It
    can be used in place of the `set`  keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibraryModern` project/folder, add a new file named `Records.cs`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Records.cs` , define an immutable person class, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: ; // C# 10 file-scoped namespace
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: ImmutablePerson
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '? FirstName { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; init
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '? LastName { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; init
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to instantiate a new immutable person and
    then try to change one of its properties, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: ImmutablePerson jeff = new
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: FirstName = "Jeff"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: LastName = "Winger"
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: jeff.FirstName = "Geoff"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile the console app and note the compile error, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Program.cs(254,7): error CS8852: Init-only property or indexer ''ImmutablePerson.FirstName''
    can only be assigned in an object initializer, or on ''this'' or ''base'' in an
    instance constructor or an ''init'' accessor. [/Users/markjprice/Code/Chapter05/PeopleApp/PeopleApp.csproj]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Comment out the attempt to set the `FirstName` property after instantiation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Init-only properties provide some immutability to C#. You can take the concept
    further by using **records** . These are defined by using the `record` keyword
    instead of the `class` keyword. That can make the whole object immutable, and
    it acts like a value when compared. We will discuss equality and comparisons of
    classes, records, and value types in more detail in *Chapter 6* , *Implementing
    Interfaces and Inheriting Classes* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Records should not have any state (properties and fields) that changes after
    instantiation. Instead, the idea is that you create new records from existing
    ones with any changed state. This is called non-destructive mutation. To do this,
    C# 9 introduced the `with` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Records.cs` , add a record named `ImmutableVehicle` , as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: record
  prefs: []
  type: TYPE_NORMAL
- en: ImmutableVehicle
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: Wheels { get
  prefs: []
  type: TYPE_NORMAL
- en: ; init
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '? Color { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; init
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '? Brand { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; init
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to create a `car` and then a mutated copy
    of it, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: ImmutableVehicle car = new
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Brand = "Mazda MX-5 RF"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: Color = "Soul Red Crystal Metallic"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: Wheels = 4
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: ImmutableVehicle repaintedCar = car
  prefs: []
  type: TYPE_NORMAL
- en: with
  prefs: []
  type: TYPE_NORMAL
- en: '{ Color = "Polymetal Grey Metallic"'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Original car color was
  prefs: []
  type: TYPE_NORMAL
- en: '{car.Color}'
  prefs: []
  type: TYPE_NORMAL
- en: ."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"New car color is
  prefs: []
  type: TYPE_NORMAL
- en: '{repaintedCar.Color}'
  prefs: []
  type: TYPE_NORMAL
- en: ."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code to view the results, and note the change to the car color in the
    mutated copy, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Original car color was Soul Red Crystal Metallic.
  prefs: []
  type: TYPE_NORMAL
- en: New car color is Polymetal Grey Metallic.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Positional data members in records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The syntax for defining a record can be greatly simplified using positional
    data members.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying data members in records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of using object initialization syntax with curly braces, sometimes
    you might prefer to provide a constructor with positional parameters as you saw
    earlier in this chapter. You can also combine this with a deconstructor for splitting
    the object into individual parts, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: record
  prefs: []
  type: TYPE_NORMAL
- en: ImmutableAnimal
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: Name { get
  prefs: []
  type: TYPE_NORMAL
- en: ; init
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: Species { get
  prefs: []
  type: TYPE_NORMAL
- en: ; init
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: ImmutableAnimal
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: name,
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: species
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Name = name;
  prefs: []
  type: TYPE_NORMAL
- en: Species = species;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: Deconstruct
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: out
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: name,
  prefs: []
  type: TYPE_NORMAL
- en: out
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: species
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: name = Name;
  prefs: []
  type: TYPE_NORMAL
- en: species = Species;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The properties, constructor, and deconstructor can be generated for you:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Records.cs` , add statements to define another record using simplified
    syntax known as positional records, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // simpler way to define a record
  prefs: []
  type: TYPE_NORMAL
- en: // auto-generates the properties, constructor, and deconstructor
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: record
  prefs: []
  type: TYPE_NORMAL
- en: ImmutableAnimal
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: Name,
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: Species
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to construct and deconstruct immutable animals,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: ImmutableAnimal oscar = new
  prefs: []
  type: TYPE_NORMAL
- en: ("Oscar"
  prefs: []
  type: TYPE_NORMAL
- en: ', "Labrador"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: (who, what) = oscar; // calls Deconstruct method
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{who}'
  prefs: []
  type: TYPE_NORMAL
- en: is a
  prefs: []
  type: TYPE_NORMAL
- en: '{what}'
  prefs: []
  type: TYPE_NORMAL
- en: ."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application and view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Oscar is a Labrador.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: You will see records again when we look at C# 10 support for creating `struct`
    records in *Chapter 6* , *Implementing Interfaces and Inheriting Classes* .
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore this chapter's topics with deeper research.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5.1 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the six combinations of access modifier keywords and what do they do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `static` , `const` , and `readonly` keywords
    when applied to a type member?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does a constructor do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you apply the `[Flags]` attribute to an `enum` type when you want
    to store combined values?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the `partial` keyword useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a tuple?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `record` keyword do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does overloading mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a field and a property?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you make a method parameter optional?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 5.2 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more detail about the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-5---building-your-own-types-with-object-oriented-programming](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-5---building-your-own-types-with-object-oriented-programming)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about making your own types using OOP. You learned
    about some of the different categories of members that a type can have, including
    fields to store data and methods to perform actions, and you used OOP concepts,
    such as aggregation and encapsulation. You saw examples of how to use modern C#
    features like relational and property pattern matching enhancements, init-only
    properties, and records.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will take these concepts further by defining delegates
    and events, implementing interfaces, and inheriting from existing classes.
  prefs: []
  type: TYPE_NORMAL
