- en: Going Functional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter introduces a programming paradigm called functional programming and
    its applicability in Java 11\. We will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using standard functional interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a functional interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using method references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging lambda expressions in your programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming is the ability to treat a certain piece of functionality
    as an object and pass it as a parameter or the return value of a method. This
    feature is present in many programming languages, and Java acquired it with the
    release of Java 8.
  prefs: []
  type: TYPE_NORMAL
- en: It avoids creating a class, its object, and managing the object state. The result
    of a function depends only on the input data, no matter how many times it is called.
    This style makes the outcome more predictable, which is the most attractive aspect
    of functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Its introduction to Java also allows us to improve parallel programming capabilities
    in Java by shifting the responsibility of parallelism from the client code to
    the library. Before this, in order to process elements of Java collections, the
    client code had to acquire an iterator from the collection and organize the processing
    of the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the default methods of Java collections accept a function (an implementation
    of a functional interface) as a parameter and then apply it to each element of
    the collection. So, it is the library's responsibility to organize the processing. One
    example is the `forEach(Consumer)` method that is available in every `Iterable` interface,
    where `Consumer` is a functional interface. Another example is the `removeIf(Predicate)` method
    that is available for every `Collection` interface, where `Predicate` is a functional
    interface too. Also, the `sort(Comparator)` and `replaceAll(UnaryOperator)` methods
    were added to the `List` interface, and the `compute()` method was added to `Map`.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions take advantage of functional interfaces and significantly
    simplify their implementation, making the code shorter, clearer, and more expressive.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we will discuss the advantages of functional programming,
    define and explain functional interfaces and lambda expressions, and demonstrate
    all the related features in code examples.
  prefs: []
  type: TYPE_NORMAL
- en: Making functions first-class citizens of the language adds more power to Java.
    But taking advantage of this language capability requires—from those not exposed
    to functional programming yet—a new way of thinking and organizing the code.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining this new feature and sharing the best practices of using it is the
    purpose of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using standard functional interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn what a functional interface is and why it was
    added to Java, along with 43 ready-to-use functional interfaces of the standard
    Java library that comes with JDK 8 in the `java.util.function` package.
  prefs: []
  type: TYPE_NORMAL
- en: Without functional interfaces, the only way to pass a functionality into a method
    would be through writing a class, creating its object, and then passing it as
    a parameter. But even the least involved style—using an anonymous class—requires
    writing too much code. Using functional interfaces helps to avoid all of that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any interface that has one and only one abstract method is called a functional
    interface. To help avoid a runtime error, the `@FunctionalInterface` annotation
    can be added in front of the interface. It tells the compiler about the intent,
    so the compiler can check to see whether there is actually one abstract method
    in that interface, including those inherited from other interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our demo code in the previous chapters, we''ve already had an example of
    a functional interface, even if we did not annotate it as functional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The presence of `enum` types or any implemented (default or static) methods
    does not make it a non-functional interface. Only abstract (not implemented) methods
    count. So, this is an example of a functional interface too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To recap what you have already learned about a default method of an interface
    in [Chapter 2](db468cc9-60fa-4966-890a-872bef36ff01.xhtml), *Fast Track to OOP
    - Classes and Interfaces*, the `getWeightPounds()` method will return `-1` when
    called by `getWeightKg()` or directly, using the object of a class that implements
    the `Vehicle` interface. However, this is only true if the `getWeightPounds()`
    method is not implemented in a class. Otherwise, the class implementation will
    be used and return a different value.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to default and static interface methods, a functional interface
    can include any and all abstract methods of the `java.lang.Object` base. In Java,
    every object is provided with the default implementation of `java.lang.Object`
    methods, so the compiler and Java runtime ignore such abstract methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this is a functional interface, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is not a functional interface, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is because the `Car` interface has two abstract methods—its own `getPassengersCount()`
    method and the `setSpeedModel(SpeedModel speedModel)` method inherited from the
    `Vehicle` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can try to add the `@FunctionalInterface` annotation to the `Car` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do that, the compiler generates the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df18df69-1aed-4f20-b3cf-b2c5f741d2f6.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the `@FunctionalInterface` annotation helps to not only catch errors at
    compile-time, but it also secures reliable communication of the design intent
    between programmers. It helps you or other programmers remember that this interface
    cannot have more than one abstract method, which is especially important when
    some code exists already that relies on such an assumption.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the same reason, the `Runnable` and `Callable` interfaces (they''ve existed
    in Java since its earlier versions) were annotated as `@FunctionalInterface` in
    Java 8 to make this distinction explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you create your own functional interface, consider using one of the 43
    functional interfaces provided in the `java.util.function` package first. Most
    of them are specializations of the `Function`, `Consumer`, `Supplier`, and `Predicate` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps you can follow to get familiar with functional
    interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the `Function<T,R>` functional interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the `<T,R>` generics, the only method of this interface
    takes a parameter of the `T` type and returns a value of the `R` type. According
    to the JavaDoc, this interface has the `R apply(T t)` method. We can create an
    implementation of this interface using an anonymous class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `R apply(T t)` method in our implementation accepts a value of the `Integer` type
    (or the `int` primitive, which is going to be auto-boxed), multiplies it by `10`,
    and returns the value of the `Double` type so that we can use our new function
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the recipe *Understanding lambda expressions* below, we will introduce a
    lambda expression and show you how its usage makes the implementation much shorter.
    But for now, we will continue using an anonymous class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the `Consumer<T>` functional interface. The name helps us to remember
    that the method of this interface accepts a value but does not return anything—it
    only consumes. Its only method is `void accept(T)`. The implementation of this
    interface can look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `void accept(T t)` method in our implementation receives a value of the `String` type
    and prints it. For example, we can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the `Supplier<T>` functional interface. The name helps you to remember
    that the method of this interface does not accept any value but does return something—only
    supplies. Its only method is `T get()`. Based on this, we can create a function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `T get()` method in our implementation does something and then returns
    a value of the `String` type, so we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the `Predicate<T>` functional interface. The name helps to remember
    that the method of this interface returns a Boolean—it predicates something. Its
    only method is `boolean test(T t)`, which means that we can create the following
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Its `boolean test(T t)` method of our implementation accepts a value of the `Double` type
    as a parameter and returns the value of the `boolean` type, so we can use it as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7d9f55b-d73b-41f4-9142-39cfb2f4fe29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Look at the other 39 functional interfaces in the `java.util.function` package.
    Notice that they are variations of the four interfaces we have discussed already.
    These variations are created for the following reasons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For better performance by avoiding auto-boxing and unboxing via the explicit
    usage of the `int`, `double`, or `long` primitives
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: For accepting two input parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a shorter notation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following functional interfaces are just a few examples from the list of
    39 interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IntFunction<R>` functional interface has the `R apply(int i)` abstract
    method. It provides a shorter notation (without generics for the parameter type)
    and avoids auto-boxing (by defining the `int` primitive as the parameter). Here''s
    an example of its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BiFunction<T,U,R>` functional interface has abstract method, `R apply(T,U)`.
    Here''s an example of its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BinaryOperator<T>` functional interface has an abstract method, `T apply(T,T)`.
    It provides a shorter notation by avoiding repeating the same type three times.
    Here''s an example of its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IntBinaryOperator` functional interface has the `int applyAsInt(int,int)` abstract
    method. We can use it to reproduce the same functionality as in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: More examples of the usage of such specializations will be provided in the following
    recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can compose the whole method using only the functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gets the value from the source, processes it, and then decides
    whether the result is successful—all based on the functions provided as parameters.
    Now, let''s create these functions and invoke the method. The source parameter
    we decided to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In real-life code, this function could pull data from a database or any other
    source of data. We keep it simple—with a hardcoded return value—in order to get
    a predictable result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The processing function and predicate will remain the same as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And the consumers will be almost identical, except for the different prefix
    before printing the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now invoke the calculate method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to quickly test various combinations of the source value and the
    predicate condition, we can create the `testSourceAndCondition(int src, int limit)` method,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we pass the `src` value into the `source` supplier, and the `limit` value
    into the `condition` predicate. Now, we can run the `testSourceAndCondition(int
    src, int limit)` method with different input values in search of the combination
    of the `src` value and the `limit` value that brings success:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many of the functional interfaces in the `java.util.function` package have
    default methods that not only enhance their functionality but also allow you to
    chain the functions and pass the result of one as an input parameter to another.
    For example, we can use the `Function<T,V> andThen(Function<R,V> after)` default
    method of the `Function<T,R>` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, our `process` function is now a combination of our original
    function (which multiplies the source value by 10.0) and a new function, `after`,
    that adds 10.0 to the result of the first function. If we call the `testSourceAndCondition(int
    source, int condition)` method as  `testSourceAndCondition(42, 20)`, the result
    will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `Supplier<T>` interface does not have methods that allow us to chain several
    functions, but the `Predicate<T>` interface has the `and(Predicate<T> other)` and `or(Predicate<T>
    other)` default methods, which allow us to construct more complex Boolean expressions.
    The `Consumer<T>` interface has the `andThen(Consumer<T> after)` default method,
    too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how the type of the input value of the `after` function has to match
    the result type of the `before` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The resulting function accepts a value of the `T` type and produces a value
    of the `V` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to achieve the same result is to use the `Function<V,R> compose(Function<V,T>
    before)` default method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Which of the methods—`andThen()` or `compose()`—to use depends on which of the
    functions is available to invoke the aggregating method. Then, one is considered
    a base, while another is a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: If this coding looks a bit over-engineered and convoluted, that's because it
    is. We did it for demo purposes only. The good news is that lambda expressions
    presented in the next recipe allow us to achieve the same results in a much shorter
    and clearer way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functional interfaces of the `java.util.function` package have other helpful
    default methods. The one that stands out is the `identity()` method, which returns
    a function that always returns its input argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `identity()` method is very helpful when a method requires you to provide
    a certain function, but you do not want this function to modify the result.
  prefs: []
  type: TYPE_NORMAL
- en: Other default methods are mostly related to conversion, boxing, unboxing, and
    extracting the min and max of two parameters. We encourage you to walk through
    the API of all the functional interfaces of the `java.util.function` and get an
    idea of the possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a functional interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create and use a custom functional interface
    when none of the standard interfaces in the `java.util.function` package satisfies
    the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a functional interface is easy. One just has to make sure there is
    only one abstract method in the interface, including methods inherited from other
    interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, interface `C` is not a functional interface because
    it has two abstract methods—`m1()`, inherited from interface `A`, and its own
    method, `m3()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also already seen the `SpeedModel` functional interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We have annotated it to express the intent and to be warned in case another
    abstract method will be added to the `SpeedModel` interface. And, to make it simpler,
    we have removed `enum` classes from it. This interface is used in the `Vehicle`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And the reason the `Vehicle` implementation needs it is because `SpeedModel`
    is the source of the functionality that calculates the speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned in [Chapter 2](db468cc9-60fa-4966-890a-872bef36ff01.xhtml),
    *Fast Track to OOP – Classes and Interfaces*, such a design is called aggregation.
    It is a preferred way of composing the desired behavior as it allows for more
    flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: With functional interfaces, such a design becomes even more flexible. To demonstrate
    it, let's implement our custom interface—`SpeedModel`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The traditional approach would be to create a class that implements the `SpeedModel` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can use this implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: To change the way the speed is calculated, we need to change the `SpeedModelImpl` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, using the fact that `SpeedModel` is an interface, we can introduce
    changes faster and even avoid having the `SpeedModelImpl` class in the first place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the preceding implementation does not take advantage of the interface
    being functional. If we comment out the annotation, we can add another method
    to the `SpeedModel` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code, not only `SpeedModel` interface has
    another abstract method `m1()`, but the anonymous class has yet another method `m2()` that
    is not listed in the `SpeedModel` interface. So, an anonymous class does not require
    the interface to be functional. But lambda expression does.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using lambda expressions, we can rewrite the preceding code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We will discuss the lambda expressions format in the next recipe. For now, we
    would like only to point out the importance of functional interfaces for an implementation
    such as the preceding one. As you can see, there is only the name of the interface
    specified and no method name at all. That is possible because a functional interface
    has only one method that has to be implemented, and that is how JVM can figure
    it out and generate a functional interface implementation behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to define a generic custom functional interface that looks similar
    to the standard functional interfaces. For example, we could create the following
    custom functional interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'It allows three input parameters, which is exactly what we need to calculate
    the speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this function instead of the `SpeedModel` interface, we could change
    the `Vehicle` interface and its implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code produces the same result as before—with the `SpeedModel`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The name of the custom interface and the name of its only method can be anything
    we like. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Well, since we are going to create a new interface anyway, using the `SpeedModel` name
    and the `getSpeedMph()` method name is probably a better solution since it makes
    the code more readable. But there are cases when a generic custom functional interface
    is a better choice. In such cases, you can use the preceding definition and enhance
    it however you need to.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have mentioned lambda expressions several times already and stated that their
    usage in Java justified the introduction of functional interfaces in the `java.util.function` package.
    The lambda expression allows us to simplify function implementation by removing
    all boilerplate code of anonymous classes, leaving only minimally necessary information.
    We have also explained that this simplification is possible because a functional
    interface has only one abstract method, so the compiler and JVM match the provided
    functionality with the method signature and generate the functional interface
    implementation behind the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to define the lambda expression syntax and see the range of possible
    forms of lambda expressions, before we start using them to make our code shorter
    and more readable than when we used anonymous classes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the 1930s, the mathematician Alonzo Church, in the course of his research
    into the foundations of mathematics, introduced lambda calculus—a universal model
    of computation that can be used to simulate any Turing machine. Well, at that
    time, the Turing machine hadn't been created. Only later, when Alan Turing invented
    his *a-machine* (automatic machine), also called the *universal Turing machine*,
    did he and Church join forces and produce a Church-Turing thesis that showed that
    lambda calculus and the Turing machine had very similar capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Church used the Greek letter *lambda* to describe anonymous functions, and it
    became an unofficial symbol of the field of programming language theory. The first
    programming language that took advantage of lambda calculus formalism was Lisp.
    Java added functional programming to its capabilities in 2014, with the release
    of Java 8.
  prefs: []
  type: TYPE_NORMAL
- en: A lambda expression is an anonymous method that allows us to omit modifiers,
    return types, and parameter types. That makes for a very compact notation. The
    syntax of a lambda expression includes the list of parameters, an arrow token
    (`->`), and a body. The list of parameters can be empty (just brackets, `()`),
    without brackets (if there is only one parameter), or a comma-separated list of
    parameters surrounded by brackets. The body can be a single expression without
    brackets or a statement block surrounded by brackets.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a few examples. The following lambda expression has no input
    parameters and always returns `33`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lambda expression accepts one parameter of the integer type, increments
    it by 1, and returns the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lambda expression accepts two parameters and returns their sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lambda expression accepts two parameters, compares them, and
    returns the `boolean` result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'And the last lambda expression accepts two parameters, calculates, and prints
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, a lambda expression can include a code block of any size—similarly
    to any method. The preceding example does not return any value. Here is another
    example of a code block that returns the `String` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at that last example again. If there is a `String m1(double x,
    double y)` method defined in a *functional* interface, `A`, and if there is a `m2(A
    a)` method that accepts an object of the `A` type, we can invoke it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code means that the passed-in object has the following implementation
    of the `m1()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The fact that `m2(A a)` has the `A` object as a parameter tells us that the
    code of `m2(A a)` probably uses at least one of the `A` interface methods (there
    may be also defaulted or static methods in the `A` interface). But, in general,
    there is no guarantee that the method uses the passed-in object because the programmer
    may have decided to stop using it and left the signature unchanged just to avoid
    breaking the client code, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, the client must pass into the method an object that implements
    the `A` interface, which means its only abstract method has to be implemented.
    And that is what the lambda expression does. It defines the abstract method functionality
    using the minimal amount of code—a list of the input parameters and a code block
    of the method's implementation. This is all the compiler and JVM need to generate
    an implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Writing such compact and efficient code became possible because of the combination
    of a lambda expression and functional interface.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As in an anonymous class, the variable created outside but used inside a lambda
    expression becomes effectively final and cannot be modified. You can write the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you cannot change the value of the `v` variable outside the lambda
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You cannot change it inside the expression, either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this restriction is that a function can be passed and executed
    for different arguments in different contexts (different threads, for example),
    and the attempt to synchronize these contexts would frustrate the original idea
    of the distributed evaluation of functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another lambda expression feature worth mentioning is its interpretation of
    the `this` keyword, which is quite different from its interpretation by an anonymous
    class. Inside an anonymous class, `this` refers to the instance of the anonymous
    class, but inside the lambda expression, `this` refers to the instance of the
    class that surrounds the expression. Let''s demonstrate it, assuming that we have
    the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, in the `method()` code, the `Consumer` functional interface
    is implemented twice—using the lambda expression and using an anonymous class.
    Let''s invoke this method in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/324ceaa7-1714-4153-bd7a-43ae67258283.png)'
  prefs: []
  type: TYPE_IMG
- en: The lambda expression is not an inner class and cannot be referred to by `this`.
    The lambda expression just does not have fields or properties. It is stateless.
    That's why in a lambda expression, the `this` keyword refers to the surrounding
    context. And that is another reason for the requirement that all the variables
    of the surrounding context used by the lambda expression must be final or effectively
    final.
  prefs: []
  type: TYPE_NORMAL
- en: Using lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use lambda expressions in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating and using lambda expressions is actually much simpler than writing
    a method. One just needs to list the input parameters, if any, and the code that
    does what has to be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s revisit our implementation of standard functional interfaces from the
    first recipe of this chapter and rewrite them using lambda expressions. Here''s
    how we have implemented the four main functional interfaces using anonymous classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s how they look with lambda expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The examples of specialized functional interfaces we have presented are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s how they look with lambda expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code is less cluttered and more readable.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Those who have some traditional code-writing experience, when starting functional
    programming, equate functions with methods.  They try to create functions first
    because that was how we all used to write traditional code—by creating methods.
    Yet, functions are just smaller pieces of functionality that modify some aspects
    of the behavior of the methods or provide the business logic for the otherwise
    non-business-specific code. In functional programming, as in traditional programming,
    methods continue to provide the code structure, while functions are the nice and
    helpful additions to it. So, in functional programming, creating a method comes
    first, before the functions are defined. Let's demonstrate this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the basic steps of code writing. First, we identify the well-focused
    block of code that can be implemented as a method. Then, after we know what the
    new method is going to do, we can convert some pieces of its functionality into
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `calculate()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding pseudocode outlines the idea of the `calculate()` method''s functionality.
    It can be implemented in a traditional style—by using methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'But some of these methods may be very small, so the code becomes fragmented
    and less readable with so many additional indirections. This disadvantage becomes
    especially glaring in the case when the methods come from outside the class where
    the `calculate()` method is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in the case where each of the external methods is small, the
    amount of plumbing code may substantially exceed the payload it supports. Besides,
    the preceding implementation creates many tight dependencies between classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we can implement the same functionality using functions.
    The advantage is that the functions can be as small as they need to be, but the
    plumbing code will never exceed the payload because there is no plumbing code.
    Another reason to use functions is when we need the flexibility to change sections
    of the functionality on the fly, for the algorithm''s research purpose. And if
    these pieces of functionality have to come from outside the class, we do not need
    to build other classes just for the sake of passing a method into `calculate()`.
    We can pass them as functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how the functions may look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding code is going to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The lambda expression acts as a regular method, except when you think about
    testing each function separately. How to do it?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to address this issue. First, since the functions are typically
    small, there is often no need to test them separately, and they are tested indirectly
    when the code that uses them is tested. Second, if you still think the function
    has to be tested, it is always possible to wrap it in the method that returns
    the function, so you can test that method as any other method. Here is an example
    of how it can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can write the function unit tests as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Typically, lambda expressions (and functions in general) are used for specializing
    otherwise generic functionalities—by adding business logic to a method. A good
    example is stream operations, which we are going to discuss in [Chapter 5](eaa70333-8e9d-453d-a9b6-063152fcc1e1.xhtml), *Streams
    and Pipelines.* The library authors have created them to be able to work in parallel,
    which required a lot of expertise. And now the library users can specialize the
    operations by passing into them the lambda expressions (functions) that provide
    the application's business logic.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since, as we have mentioned already, functions are often simple one-liners,
    they are often inlined when passed in as parameters, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: But one should not push it too far, as such inlining may decrease code readability.
  prefs: []
  type: TYPE_NORMAL
- en: Using method references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use a method reference, with the constructor
    reference being one of the cases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a one-line lambda expression consists only of a reference to an existing
    method implemented somewhere else, it is possible to further simplify the lambda
    notation by using the *method reference*.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of the method reference is `Location::methodName`, where `Location`
    indicates where (in which object or class) the `methodName` method can be found.
    The two colons (`::`) serve as a separator between the location and the method
    name. If there are several methods with the same name at the specified location
    (because of the method overload), the reference method is identified by the signature
    of the abstract method of the functional interface implemented by the lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The exact format of the method reference depends on whether the referred method
    is static or non-static. The method reference can also be *bound* or *unbound*,
    or to be more formal, the method reference can have a *bound receiver* or an *unbound
    receiver.* A receiver is an object or class that is used to invoke the method.
    It *receives* the call. It can be bound to a particular context or not (unbound).
    We will explain what this means during the demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: The method reference can also refer to a constructor with or without parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the method reference is applicable *only when the expression
    consists of only one method call and nothing else*. For example, a method reference
    can be applied to the `() -> SomeClass.getCount()` lambda expression. It will
    look like `SomeClass::getCount`. But the expression `() -> 5 + SomeClass.getCount()` cannot
    be replaced with method reference because there are more operations in this expression
    than just a method call.
  prefs: []
  type: TYPE_NORMAL
- en: Static unbound method reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To demonstrate a static method reference, we will use the `Food` class with
    two static methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the first method, `String getFavorite()`, does not accept any input parameters and
    returns a value, it can be implemented as a functional interface, `Supplier<T>`.
    The lambda expression that implements the function that consists of the call to
    the `String getFavorite()` static method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the method reference, the preceding line changes to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the preceding format defines the location of the method (as
    the `Food` class), the name of the method, and the value of the return type (as
    `String`). The name of the functional interface indicates that there are no input
    parameters, so the compiler and JVM can identify the method among the methods
    of the `Food` class.
  prefs: []
  type: TYPE_NORMAL
- en: A static method reference is unbound because there's no object being used to
    invoke the method. In the case of a static method, a class is the call receiver,
    not an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second static method, `String getFavorite(int num)`, accepts one parameter
    and returns a value. It means we can use the `Function<T,R>` functional interface
    to implement the function that consists only of a call to this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'But when the method reference is used, it changes to exactly the same form
    as the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference is in the specified functional interface. It allows the compiler
    and Java runtime to identify the method to be used: the method is named `getFavorite()`,
    accepts the `Integer` value, and returns `String` value. And there is only one
    such method in the `Food` class. Actually, there is no need to even look at which
    value the method returns, because it is not possible to overload a method by the
    return value only. The signature of the method—name, and list of parameter types—is
    enough for the method''s identification.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the implemented functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding code, the result is going to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b59f41b3-3172-45ff-b858-7967323967de.png)'
  prefs: []
  type: TYPE_IMG
- en: Non-static bound method reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To demonstrate a non-static bound method reference, let''s enhance the `Food` class by
    adding a `name` field, two constructors, and two `String sayFavorite()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create three instances of the `Food` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding is the context—the code that surrounds the lambda expression
    we are going to create now. We use the local variables of the preceding context
    to implement three different suppliers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We used `Supplier<T>` because the `String`, `sayFavorite()` method does not
    require any parameter and just produces (supplies) the `String` value. Using the
    method reference, we can rewrite the preceding lambda expressions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The method `sayFavorite()` belongs to an object that was created in a certain
    context. In other words, this object (the call receiver) is bound to a certain
    context, which is why such method reference is called a *bound method reference*
    or *bound receiver method reference*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can pass the newly created functions as any other object and use them anywhere
    we need, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cf07e4c-f18c-4df7-8b95-20f98446228f.png)'
  prefs: []
  type: TYPE_IMG
- en: Please note that the receiver remains bound to the context, so its state may
    change and affect the output. That is the significance of the distinction of being
    *bound*. Using such a reference, one has to be careful not to change the state
    of the receiver in the context of its origination. Otherwise, it may lead to unpredictable
    results. This consideration is especially pertinent for parallel processing when
    the same function can be used in different contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another case of a bound method reference using the second non-static
    method, `String sayFavorite(String name)`. First, we create an implementation
    of a functional interface, `UnaryOperator<T>`, using the same objects of the `Food` class
    that we used in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The reason we have used the `UnaryOperator<T>` functional interface is that
    the `String sayFavorite(String name)` method accepts a parameter and produces
    the value of the same type. And that is the purpose of functional interfaces with
    the name `Operator` in them—to support cases when the input value and the result
    have the same type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method reference allows us to change the lambda expression as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use the preceding functions (operators) anywhere in the code, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f873fc74-fbd0-4b23-bde2-85d3643d2469.png)'
  prefs: []
  type: TYPE_IMG
- en: Non-static unbound method reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To demonstrate an unbound method reference to the `String sayFavorite()` method,
    we will use the `Function<T,R>` functional interface because we would like to
    use an object of the `Food` class (the call receiver) as a parameter and get back
    a `String` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The method reference allows us to rewrite the preceding lambda expression as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the same objects of the `Food` class we created in the previous examples,
    we use the newly created function in the following code, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the parameter (the call receiver object) comes from the current
    context only, as any parameter does. Wherever the function is passed, it does
    not carry the context with it. Its receiver is not bound to the context that was
    used for the function's creation. That is why this method reference is called
    *unbound*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3dda0849-946f-42dd-a499-97cd5b6628aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And, to demonstrate another case of the unbound method reference, we will use
    the second method, `String sayFavorite(String name)`, with the same `Food` objects
    we have used all along. The functional interface we are going to implement this
    time is called `BiFunction<T,U,R>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason we select this functional interface is that it accepts two parameters—exactly
    what we need in this case—to have the receiver object and `String` value as parameters.
    The method reference version of the preceding lambda expression looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the preceding function by writing the following code, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce301b7b-80bd-49e0-afb6-7b4b0e72e77e.png)'
  prefs: []
  type: TYPE_IMG
- en: Constructor method references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the method reference for a constructor is very similar to a static method
    reference because it uses a class as the call receiver, not an object (it has
    not been created yet). Here is the lambda expression that implements the `Supplier<T>`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is its version with the method reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding code, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34b6cfe4-9407-41fb-81a5-f23f2f307e52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s add another constructor to the `Food` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we do this, we can express the preceding constructor using the method
    reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/882157fe-d4e8-4439-ba19-cc505020fbf8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the same manner, we can add a constructor with two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we do that, we can express it via `BiFunction<String, String>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/981b14a2-265d-4fe6-a524-5785d675f49a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To express a constructor that accepts more than two parameters, we can create a
    custom functional interface with any number of parameters. For example, we can
    use the following custom functional interface, which we discussed in the previous
    recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s assume that we need to use the `AClass` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write the following code by using the method reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several simple but very helpful method references because it gets
    its call receiver that is often used in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also a few useful methods for working with arrays and lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the results of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dda4ac9d-511a-44dd-918d-7d48e26f2c87.png)'
  prefs: []
  type: TYPE_IMG
- en: We leave it up to you to analyze how the preceding lambda expressions were created
    and used.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging lambda expressions in your programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to apply a lambda expression to your code.
    We will get back to the demo application and modify it by introducing a lambda
    expression where it makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Equipped with functional interfaces, lambda expressions, and the best practices
    of a lambda-friendly API design, we can substantially improve our speed-calculating
    application by making its design more flexible and user-friendly. Let's set up
    some background as close to a real-life problem as possible without making it
    too complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'Driverless cars are in the news these days, and there is good reason to believe
    it is going be this way for quite some time. One of the tasks in this domain is
    the analysis and modeling of the traffic flow in an urban area based on real data.
    A lot of such data already exists and will continue to be collected in future.
    Let''s assume that we have access to such a database by date, time, and geographical
    location. Let''s also assume that the traffic data from this database comes in
    units, each capturing details about one vehicle and the driving conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The `enum` types—`VehicleType`, `RoadCondition`, and `TireCondition`—were already
    constructed in  [Chapter 2](db468cc9-60fa-4966-890a-872bef36ff01.xhtml), *Fast
    Track to OOP - Classes and Interfaces*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface of accessing traffic data may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of the access to the preceding methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: The number `17` is an hour of a day (5 pm) and `Main1035` is a traffic light
    identification.
  prefs: []
  type: TYPE_NORMAL
- en: 'The call to the second method returns multiple results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter, `20`, is the number of the requested units of traffic.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, such a traffic factory provides data about traffic in a particular
    location at a particular time (between 5 pm and 6 pm in our example). Each call
    to the factory yields a different result, while the list of traffic units describes statistically-correct
    data (including the most probable weather conditions) in the specified location.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also change the interfaces of `FactoryVehicle` and `FactorySpeedModel` so
    they could build `Vehicle` and `SpeedModel` based on the `TrafficUnit` interface.
    The resulting demo code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The `printResult()` method has the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51e23141-3a9a-4765-9790-3e73337b7c89.png)'
  prefs: []
  type: TYPE_IMG
- en: Since we use the "real" data now, every run of this program produces a different
    result, based on the statistical properties of the data. In a certain location,
    a car or dry weather would appear more often at that date and time, while in another
    location, a truck or snow would be more typical.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this run, the traffic unit brought a wet road, new tires, and `Truck` with
    such an engine power and load that in 10 seconds it was able to reach a speed
    of 22 mph. The formula we used to calculate the speed (inside an object of `SpeedModel`)
    is familiar to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `traction` value comes from `TrafficUnit`. In the class that implements
    the `TrafficUnit` interface, the `getTraction()` method looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: The `getRoadCondition()` and `getTireCondition()` methods return the elements
    of the corresponding `enum` types we just described.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to improve our speed-calculating application using the lambda
    expressions discussed in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to use lambda expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start building an API. We will call it `Traffic`. Without using functional
    interfaces, it might look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Its implementation may be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write sample code that uses the `Traffic` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'We get results similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/038d044d-970e-4fa4-bb1f-cea021a97788.png)'
  prefs: []
  type: TYPE_IMG
- en: As mentioned before, since we are using real data, the same code does not produce
    exactly the same result every time. One should not expect to see the speed values
    of the preceding screenshot, but instead something that looks very similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use a lambda expression. The preceding API is quite limited. For example,
    it does not allow you to test different speed-calculation formulas without changing
    `FactorySpeedModel`. Meanwhile, the `SpeedModel` interface has only one abstract
    method, called `getSpeedMph()` (which makes it a functional interface):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'We can take advantage of `SpeedModel` being a functional interface, and add
    another method to the `Traffic` interface that is able to accept the `SpeedModel`
    implementation as a lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem though is the `traction` value does not come as a parameter to
    the `getSpeedMph()` method, so we cannot implement it as a function passed as
    a parameter into the `speedAfterStart()` method. Look closer at the speed calculation
    by `FactorySpeedModel.generateSpeedModel(TrafficUnit trafficUnit)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `traction` value is a multiplier to the calculated value
    of `speed` and that is the only dependency on traffic unit. We can remove traction
    from the speed model and apply traction after the speed is calculated using the
    speed model. It means we can change the implementation of `speedAfterStart()`
    of the `TrafficImpl` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'This change allows the users of the `Traffic` API pass `SpeedModel` as a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: The result of the preceding code is the same as when `SpeedModel` was generated
    by `FactorySpeedModel`. But now the API users can come up with their own speed-calculating
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can Annotate the `SpeedModel` interface as `@FunctionalInterface`, so everybody
    who tries to add another method to it would be dutifully warned and would not
    be able to add another abstract method without removing this annotation and being
    aware of the risk of breaking the code of the existing clients that have implemented
    this functional interface already.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can enrich the API by adding various criteria that slice all of the possible
    traffic into segments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, API users might want to analyze only cars, trucks, cars with an engine
    bigger than 300 horsepower, or trucks with an engine bigger than 400 horsepower.
    The traditional way to accomplish this would be by creating methods such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we can just add standard functional interfaces to the existing `speedAfterStart()` method
    of the `Traffic` interface and let the API user decide which slice of traffic
    to extract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'The `speedAfterStart()` method implementation in the `TrafficImpl` class would
    change as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Traffic` API users can then define the traffic they need as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are now limited to cars with an engine smaller than 250 `hp` and
    trucks with an engine smaller than 400 `hp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d601ea9c-2be1-4f90-971f-e6ecb0259f05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In fact, a `Traffic` API user can now apply any criteria for limiting the traffic
    as long as they are applicable to the values in the `TrafficUnit` object. A user
    can write, for example, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, they can write any other combination of limits on the values
    that come from `TrafficUnit`. If a user decides to remove the limit and analyze
    all of the traffic, this code will do it too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is a need to select traffic units by speed, we can apply the predicate
    criteria after the speed calculations (notice how we replaced `Predicate` with
    `BiPredicate` since we need to use two parameters now):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Traffic` API users can now write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The predicate above selects traffic units that exceed the speed limit by more
    than a certain amount (which is different for different driving conditions). If
    needed, it can disregard the speed completely and limit traffic exactly the same
    way the previous predicate did. The only drawback of this implementation is that
    it is slightly less efficient because the predicate is applied after the speed
    calculations. This means that the speed calculation will be done for each generated
    traffic unit, not to a limited number, as in the previous implementation. If this
    is a concern, you might leave all the different signatures we have discussed in
    this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: This way, the API user decides which of the methods to use, more flexible or
    more efficient, and decide whether the default speed-calculation implementation
    is acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have not given the API user a choice of the output format. Currently,
    it is implemented as the `printResult()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it more flexible, we can add another parameter to our API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we take the `timeSec` value-not as one of the function parameters,
    but from the enclosed scope of the function. We can do this because it remains
    constant (and can be effectively final) throughout the calculations. In the same
    manner, we can add any other object to the `output` function—a filename or another
    output device, for example—thus leaving all the output-related decisions to the
    API user. To accommodate this new function, the API implementation changes to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: It took us a while to come to this point—where the power of functional programming
    starts to shine and justify the effort of learning it. Yet, when used to process
    streams, as described in the next chapter, lambda expressions yield even more
    power.
  prefs: []
  type: TYPE_NORMAL
