- en: Chapter 7. Crypto, Hash, and Conversion Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cryptography can play an important role in certain types of information security
    vulnerability, as it helps to implement secure delivery of authenticating data
    in one direction, secure delivery of the authentication token, access control,
    and much more. One-way cryptographic functions are used in websites to store passwords
    in a manner that they cannot be retrieved. In this chapter, we will discuss various
    cryptographic functions in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Hash functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secret key (Encryption algorithms)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public key algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cryptographic algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following three types of cryptography algorithms are used most often:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hash functions**: Hash functions are also known as **one-way encryption**,
    and have no key. A hash function outputs a fixed-length hash value for plaintext
    inputs, and it''s impossible to recover the length or content of the plaintext.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keyed hash functions**: Keyed hashing is used to build **message authentication
    codes** (**MACs**); MACs are intended to prevent brute-force attacks. So, they
    are intentionally designed to be slow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Symmetric encryption / Secret key (Encryption algorithms)**: Encryption algorithms
    output a ciphertext for some text inputs using a variable key and, we can decrypt
    the ciphertext using the same key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public key algorithms**: For public key algorithms, we have two different
    keys: one for encryption and the other to decrypt. So, we can share the public
    key that can encrypt the message, but it can only be decrypted using the decrypt
    key, which is not shared.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hash functions are mainly used in cryptography to check the integrity of messages,
    digital signatures, manipulation detection, fingerprints, and password storage.
    A function is a good hash function if the input string cannot be guessed based
    on the output. As hash functions convert random amounts of data to fixed-length
    strings, there may be some inputs that hash into the same string. Hash functions
    are created in such a way as to make these collisions extremely difficult to find.
    The most used hash functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hash functions](img/image_07_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**MD2**, **MD4**, and **MD5** have **128-bits** length and are not secure.
    **SHA-1** has **160-bits** length, but it is also not secure.'
  prefs: []
  type: TYPE_NORMAL
- en: Hashed Message Authentication Code (HMAC)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Hashed Message Authentication Code** (**HMAC**) is used when we need to check
    for *integrity* and *authenticity*. It provides both server and client with a
    public key and a private key. The private key is only known to the server and
    client, but the public key is known to all.'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of HMAC, the key and the message are hashed in separate steps. The
    client creates a hash per request by merging and hashing the data along with the
    private key and sends this as part of the request. After receiving the request
    in the server, it generates another hash and compares it with the one received.
    If they are equal, then we can consider that the client is authentic.
  prefs: []
  type: TYPE_NORMAL
- en: Message-digest algorithm (MD5)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MD5 is used for data integrity through 128-bit message digest from data. According
    to the standard, it is *computationally infeasible*, as two messages may have
    the same message digest as the output or may create a false message.
  prefs: []
  type: TYPE_NORMAL
- en: Secure Hash Algorithm (SHA)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SHA** series is widely used in security applications and protocols, including
    TLS/SSL, PGP, and SSH. SHA-1 is used in version-control systems like Git and Mercurial
    to identify revisions and to detect data corruption. There are some weaknesses
    reported for SHA-0 and SHA-1\. So, the SHA-2 family of hash functions is recommended.
    We should use the SHA-2 family on applications that require collision resistance.'
  prefs: []
  type: TYPE_NORMAL
- en: HMAC in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating the hash of a file is simple with Python. To create a HMAC hash with
    the default MD5 algorithm, we can use the `hmac` module in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first line imports the `hmac` module. The `hmac` module comes with default
    Python installation starting from Python 2.2\. Then, start the `hmac` instance
    with the shared secret key as the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Then read the file in 1024-byte blocks and create the `digest`, and finally,
    print the `digest`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though the default cryptographic algorithm for the `hmac` module Python
    is MD5 which is considered insecure, we should use a SHA algorithm. To use SHA256,
    we have to use the `hashlib` module. Hashlib comes with default Python installation
    from version 2.5 onwards. So, we can update the preceding script to use SHA256:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Likewise, we could include other `hashlib` methods in `hmac`.
  prefs: []
  type: TYPE_NORMAL
- en: hashlib algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use a specific hash algorithm, we can make use of the appropriate constructor
    function from the `hashlib` module, which will create a hash object that can be
    used to interact with the hash. The `hashlib` module is backed by OpenSSL, so
    all the algorithms in OpenSSL, like `md5`, `sha1`, `sha224`, `sha256`, `sha384`,
    and `sha512` are available in `hashlib`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![hashlib algorithms](img/image_07_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are important `hashlib` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hashlib.md5()`: Creates the MD5 hash object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hashlib.sha1()`: Creates the SHA1 hash object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hashlib.new(hash_name)`: Used to pass the algorithm by name to create a hash
    object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, try the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will create a hash object of the hash algorithm name we passed as a first
    argument. The method `update()` will call the hash calculator repeatedly and update
    the digest accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Password hashing algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MD5, SHA1, and all SHA variants are intended to be very fast. In the case of
    passwords, fast algorithms are prone to brute-force attacks, as the hashes for
    MD5 and SHA1 can be produced at a rate of millions or billions per second. There
    are some algorithms specifically designed for passwords. We could use Argon2,
    and consider this as your first choice when solid implementations are available.
    The other main two options are `pbkdf2` and `bcrypt`. These functions are expensive
    to compute, so it will you protect from brute-force and wordlist attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `argon2` module to use Argon2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Also, we could use modules `bcrypt` and `pbkdf2` to make use of these algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example for using `bcrypt` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will hash the password with a randomly generated salt.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example for using `pbkdf2` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will create a 24-byte-long hash using `1000` iterations. We can slow down
    the hash function by increasing the iterations.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric encryption algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Symmetric encryption algorithms, or secret key algorithms, convert their input
    data or plaintext to a cipher text using a private variable key. We can decrypt
    the cipher text using the same key that was used to encrypt the message. Cipher
    is simply a method for encrypting and decrypting messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Encryption algorithms are mainly grouped into two:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithms used in symmetric encryption**: Symmetric encryption is the one
    which uses a single key for both encryption and decryption. Some examples of symmetric
    encryption algorithms are AES, Blowfish, DES, IDEA, serpent, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Algorithms used in asymmetric encryption**:Asymmetric encryption use two
    keys: a private key and a public key—one for encryption and the other for decryption.
    Examples for asymmetric algorithms are Diffe-Hellman (**DH**) and **RSA**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can read more on symmetric encryption here: [http://www.cs.cornell.edu/courses/cs5430/2010sp/TL03.symmetric.html](http://www.cs.cornell.edu/courses/cs5430/2010sp/TL03.symmetric.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Block  and stream cipher
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **block cipher** encrypts fixed-size data which is known as a block. Usually,
    each block has the relatively large size of 64 bits, 128 bits, or 256 bits. So,
    a block cipher will take each block and encrypt it separately to the same size
    as the cipher text. In cases where input bits are shorter than the block size,
    padding schemes are called into play. The same key is used at each block. Examples
    of block ciphers are AES, DES, Blowfish, and IDEA.
  prefs: []
  type: TYPE_NORMAL
- en: A **stream cipher** encrypts small blocks of one bit or byte of plaintext at
    a time. It uses an infinite stream of pseudorandom bits as the key and this pseudorandom
    generator should be unpredictable. Also, the key should never be reused to implement
    the stream cipher in a secure way.
  prefs: []
  type: TYPE_NORMAL
- en: PyCrypto
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PyCrypto**, which stands for **Python Cryptography Toolkit**, is a collection
    of different cryptographic modules that include both hash functions and encryption
    algorithms. The PyCrypto module provides all needed functions for implementing
    strong cryptography in a Python program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use an encryption algorithm, we can import it from `Crypto.Cipher`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create the ciphertext. As the PyCrypto block-level encryption API
    is very low-level, it only accepts 16-, 24-, or 32-bytes-long keys for AES-128,
    AES-196, and AES-256, respectively. The longer the key, the stronger the encryption.
    We can decrypt it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now we will get our plaintext back.
  prefs: []
  type: TYPE_NORMAL
- en: AES encryption of a file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Advanced Encryption Standard** (**AES**) is a symmetric block cipher, which
    consists of three block ciphers: AES-128, AES-192, and AES-256\. Each one encrypts/decrypts
    data in blocks of 128 bits with keys of 128, 192, and 256 bits, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: The following script encrypts the file provided. Also, it handles the random
    generation of **initialization vector** (**IV**).
  prefs: []
  type: TYPE_NORMAL
- en: 'First we load all required modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, define the function to encrypt the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we create the initialization vector inside the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can initialize the AES encryption method in the PyCrypto module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Read the file and write the encrypted output file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, call the function to encrypt the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can check how to decrypt this encrypted file. To write a function that
    can decrypt, we have to import the same modules. Then, define the function as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Read the encrypted file and output the decrypted file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the `decryptor` method to decrypt the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, output the original decrypted file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed the hashing and cryptographic modules used in Python. Now
    you will be able to use these modules in your scripts. We will look at some keylogging
    techniques in the next chapter.
  prefs: []
  type: TYPE_NORMAL
