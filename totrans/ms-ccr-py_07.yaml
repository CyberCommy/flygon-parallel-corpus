- en: Reduction Operators in Processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of reduction operators—in which many or all elements of an array
    are reduced into one single result—is closely associated with concurrent and parallel
    programming. Specifically, because of the associative and communicative nature
    of the operators, concurrency and parallelism can be applied to greatly improve
    their execution time.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter discusses the theoretical concurrent approach to designing and
    writing a reduction operator from the perspective of programmers and developers.
    From here, this chapter also makes connections to similar problems that can be
    solved using concurrency in similar ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a reduction operator in computer science
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The communicative and associative properties of reduction operators, and therefore
    the reason why concurrency can be applied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to identify problems that are equivalent to a reduction operator and how
    to apply concurrent programming in such cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a list of prerequisites for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You must have Python 3 installed on your computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the GitHub repository from [https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During this chapter, we will be working with the subfolder titled `Chapter07`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out the following video to see the Code in Action: [http://bit.ly/2TD5odl](http://bit.ly/2TD5odl)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of reduction operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As experienced programmers, you have undoubtedly encountered situations where
    you need to calculate the sum or the product of all the numbers in an array, or
    compute the result of applying the `AND` operator to all Boolean elements of an
    array to see whether there is any false value in that array. These are called
    **reduction operators**, which take a set or an array of elements and perform
    some form of computation to return only one single result.
  prefs: []
  type: TYPE_NORMAL
- en: Properties of a reduction operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Not every mathematical or computer science operator is a reduction operator.
    In fact, even if an operator is capable of reducing an array of elements into
    one single value, there is no guarantee that it is a reduction operator. An operator
    is a reduction operator if it satisfies the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: The operator can reduce an array of elements into one scalar value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The end result (the scalar value) must be obtained through creating and computing
    partial tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first condition is indicative of the phrase "reduction operators", as all
    elements of the input array have to be combined and reduced into one single value.
    However, the second condition is, essentially, in terms of concurrency and parallelism.
    It requires the computation of any reduction operator to be able to be divided
    into smaller partial computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s consider one of the most common reduction operators: addition.
    For example, consider the input array `[1, 4, 8, 3, 2, 5]`—the sum of the elements
    in this array is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding computation, we reduced the numbers in our array into their
    sum, `23`, in a sequential order. In other words, we went through each and every
    element of the array from the beginning to the end and added the current sum.
    Now, we know that addition is a commutative and associative operator, which means:
    *a + b = b + a* and *(a + b) + c = a + (b + c)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we can perform the preceding computation in a more efficient way
    by breaking the summation into smaller summations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This technique is at the heart of applying concurrency and parallelism (specifically
    multiprocessing) to a reduction operator. By breaking the whole task into smaller
    subtasks, multiple processes can perform those small computations simultaneously,
    and the system as a whole can arrive at the result much more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the same reason, the communicative and associative properties are considered
    to be equivalent to the requirements for a reduction operator that we discussed
    earlier. In other words, the operator ![](assets/bbe67805-00e5-4140-b1f5-532e3c676f83.png) is
    a reduction operator that''s communicative and associative. Specifically the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Communicative: *a ![](assets/1f978d15-59d3-4b54-90f2-d6e8fb68d558.png) b =
    b ![](assets/4d6c15e7-49c7-4ce9-9c36-f989c275b760.png) a*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Associative: *(a ![](assets/8ad90b0c-03cd-429a-8561-f8a1b19082a7.png) b) ![](assets/a00626a1-0076-4aa4-94a7-e01e50e9e8ad.png) c
    = a ![](assets/bd4efb4b-bd8a-4177-8b48-0bb94835babb.png) (b ![](assets/f73dbfc9-7675-46b9-9b07-ae58721000a3.png) c)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here *a*, *b*, and *c* are elements of input arrays.
  prefs: []
  type: TYPE_NORMAL
- en: So, if an operator is a reduction operator, it has to be communicative and associative,
    and therefore has the ability to break down a big task into smaller, more manageable
    subtasks, which can be computed in a more efficient way using multiprocessing.
  prefs: []
  type: TYPE_NORMAL
- en: Examples and non-examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen that addition is one example of a reduction operator. To
    perform addition as a reduction operator, we first divide the elements from our
    input array into groups of two, each of which is one of our subtasks. We then
    perform addition on each group, take the added result from each group, and divide
    them into groups of two again.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process continues until we arrive at one single number. This process follows
    a model called binary tree reduction, which utilizes groups of two to form the
    subtasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7cad13ee-22a1-4512-8731-75e2c3dbaa52.png)'
  prefs: []
  type: TYPE_IMG
- en: Diagram of binary tree reduction for addition
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example with the array [1, 4, 8, 3, 2, 5], after dividing the
    numbers into three different groups of two numbers (1 and 4, 8 and 3, 2 and 5),
    we used three separate processes to add the pairs of numbers together. We then
    obtained the array [5, 11, 7], which we used for one process to obtain [16, 7],
    and again another process to finally obtain 23\. So, with three CPUs or more,
    an addition operator of six elements can be done in log[2]6 = 3 steps instead
    of five steps in sequential addition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other common examples of reduction operators are multiplication and logical
    AND. For example, reducing the same array of numbers [1, 4, 8, 3, 2, 5] using
    multiplication as a reduction operator would be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To reduce an array of Boolean values, for example (`True`, `False`, `False`,
    `True`), using the logical `AND` operator, we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A non-example of reduction operators is the power function, as changing the
    order of computation would change the final result (that is, the function is not
    communicative). For example, reducing the array `[2, 1, 2]` sequentially would
    give us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we were to change the order of operation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We would obtain a different value. Therefore, the power function is not a reduction
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: Example implementation in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned previously, due to their communicative and associative properties,
    reduction operators can have their partial tasks created and processed independently,
    and this is where concurrency can be applied. To truly understand how a reduction
    operator utilizes concurrency, let's try implementing a concurrent, multiprocessing
    reduction operator from scratch—specifically the add operator.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to what we saw in the previous chapter, in this example, we will be
    using a task queue and a result queue to facilitate our interprocess communication.
    Specifically, the program will store all of the numbers in the input array in
    the task queue as individual tasks. As each of our consumers (individual processes)
    executes, it will call `get()` on the task queue **twice** to obtain two task
    numbers (except for some edge cases where there is no or only one number left
    in the task queue), add them together, and put the result in the result queue.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to adding pairs of numbers together, like we did in the previous section,
    after our processes iterate through the tasks queue one time and put the added
    pairs of task numbers in the result queue, the number of elements in the input
    array will have been reduced by half. For example, an input array of `[1, 4, 8,
    3, 2, 5]` will become `[5, 11, 7]`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our program will assign the new task queue to be the result queue (so,
    in this example, `[5, 11, 7]` is now the new task queue), and our processes will
    continue going through it and adding pairs of numbers together to generate a new
    result queue, which will become the next task queue. This process repeats itself
    until the result queue only contains one element, since we know that that single
    number is the sum of the numbers in the original input array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the changes in the task queue and the result queue
    in each iteration of processing the input array `[1, 4, 8, 3, 2, 5]`; the process
    stops when the result queue contains only one number (`23`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/56cfb844-7f33-473a-9489-38b1f4cb11cd.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample diagram of the multiprocessing add operator
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `ReductionConsumer` class in the `Chapter07/example1.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We implement the `ReductionConsumer` class by overriding the `multiprocessing.Process`
    class. This consumer class takes in a task queue and a result queue when initialized,
    and handles the consumer process logic of the program, which calls `get()` twice
    on the task queue to obtain two numbers from the queue, and adds their sum to
    the result queue.
  prefs: []
  type: TYPE_NORMAL
- en: While doing this, the `ReductionConsumer` class also handles cases where there
    is no or only one number left in the task queue (that is, when either the `num1`
    or `num2` variable is `None`, which, as we know from the previous chapter, is
    what we use to indicate a poison pill).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, recall that the `JoinableQueue` class of the `multiprocessing`
    module is used to implement our task queues, and that it requires the `task_done()`
    function to be called after each time the `get()` function is called, otherwise
    the subsequent `join()` function that we will call on the task queue later will
    block indefinitely. So, in the case where the consumer process calls `get()` two
    times, it is important to call `task_done()` on the current task queue twice,
    and when we only call `get()` once (when the first number is a poison pill), then
    we should call `task_done()` only once. This is one of the more complex considerations
    while working with multiprocessing programs that facilitate interprocess communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'To process and coordinate different consumer processes as well as manipulate
    the task queue and the result queue after each iteration, we have a separate function
    called `reduce_sum()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This function takes in a Python list of numbers to compute the sum of its elements.
    Aside from a task queue and a result queue, the function also keeps track of another
    variable called `result_size`, which indicates the number of elements in the current
    result queue.
  prefs: []
  type: TYPE_NORMAL
- en: After initializing its base variables, the function spawns its consumer processes
    to reduce the current task queue inside a while loop. As we discussed previously,
    in each iteration of the while loop, the elements in the task queue are added
    together pairwise, and the added results are stored in the result queue. After
    that, the task queue will take over the elements of that result queue, and add
    additional `None` values to the queue to implement the poison pill technique.
  prefs: []
  type: TYPE_NORMAL
- en: In each iteration, a new empty result queue is also initialized as a `JoinableQueue`
    object—this is different from the `multiprocessing.Queue` class that we used for
    our result queue in the previous chapter, since we will be assigning `tasks =
    results` at the beginning of the next iteration, and the task queue needs to be
    a `JoinableQueue` object.
  prefs: []
  type: TYPE_NORMAL
- en: We also update the value of `result_size` at the end of each iteration through
    `result_size = result_size // 2 + (result_size % 2)`. It is important to note
    here that while the `qsize()` method from the `JoinableQueue` class is a potential
    method to keep track of the length of its object (that is, the number of elements
    in a `JoinableQueue` object), this method is usually considered to be unreliable
    for various reasons—it is not even implemented in Unix operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Since we can easily predict how the number of remaining numbers from our input
    array will change after each iteration (it is halved if it is an even number,
    otherwise it is halved by integer division, and then `1` is added to that result),
    we can keep track of that number using a separate variable called `result_size`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for our main program for this example, we simply pass a Python list to the
    `reduce_sum()` function. Here, we are adding numbers from 0 to 19:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the script, your output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Real-life applications of concurrent reduction operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The communicative and associative nature of the way reduction operators process
    their data enables the subtasks of an operator to be processed independently,
    and is thus highly connected to concurrency and parallelism. Consequently, various
    topics in concurrent programming could be related to reduction operators, and
    by applying the same principles of reduction operators, problems regarding those
    topics could be made more intuitive and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, add and multiply operators are reduction operators. More generally,
    number-crunching problems that usually involve communicative and associative operators
    are prime candidates for applying concurrency and parallelism. This is actually
    a true case for the famous, and arguably one of the most used modules in Python—NumPy,
    whose code is implemented to be as parallelizable as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, applying the logic operators AND, OR, or XOR to an array of Boolean
    values works the same way as reduction operators. Some real-world applications
    for concurrent bitwise reduction operators include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Finite state machines, which commonly take advantage of logic operators while
    processing logic gates. Finite state machines can be found in both hardware structures
    and software designs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication across sockets/ports, which typically involves parity and stop
    bits to check for data errors, or flow control algorithms. These techniques utilize
    logic values of individual bytes to process information through the use of logic
    operators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compression and encryption techniques, which heavily depend on bitwise algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Careful considerations need to be made while implementing multiprocessing reduction
    operators in Python, especially if the program utilizes task queues and result
    queues to facilitate communication across the consumer processes.
  prefs: []
  type: TYPE_NORMAL
- en: The operations of various real-world problems resemble reduction operators,
    and the use of concurrency and parallelism for these problems could greatly improve efficiency
    and thus productivity of the programs processing them. It is therefore important
    to be able to identify these problems, and relate back to the concept of reduction
    operators to implement their solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will be discussing a specific real-world application
    for multiprocessing programs in Python: image processing. We will be going over
    the basic ideas behind image processing and how concurrency—specifically multiprocessing—could
    be applied to image-processing applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a reduction operator? What conditions must be satisfied so that an operator
    can be a reduction one?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What properties do reduction operators have that are equivalent to the required
    conditions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the connection between reduction operators and concurrent programming?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are some of the considerations that must be made while working with multiprocessing
    programs that facilitate interprocess communication in Python?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are some real-life applications of concurrent reduction operators?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Python Parallel Programming Cookbook*, Giancarlo Zaccone, Packt Publishing
    Ltd, 2015'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Learning Concurrency in Python: Build highly efficient, robust, and concurrent
    applications.*, Elliot Forbes (2017)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Parallel Programming in OpenMP*, Morgan Kaufmann, Chandra, Rohit (2001)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Fundamentals of Parallel Multicore Architecture*, Yan Solihin (2016), CRC
    Press'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
