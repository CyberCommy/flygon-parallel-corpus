- en: Reduction Operators in Processes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程中的减少运算符
- en: The concept of reduction operators—in which many or all elements of an array
    are reduced into one single result—is closely associated with concurrent and parallel
    programming. Specifically, because of the associative and communicative nature
    of the operators, concurrency and parallelism can be applied to greatly improve
    their execution time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 减少运算符的概念——其中数组的许多或所有元素被减少为一个单一结果——与并发和并行编程密切相关。具体来说，由于运算符的结合和交换性质，可以应用并发和并行性来大大提高它们的执行时间。
- en: This chapter discusses the theoretical concurrent approach to designing and
    writing a reduction operator from the perspective of programmers and developers.
    From here, this chapter also makes connections to similar problems that can be
    solved using concurrency in similar ways.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了从程序员和开发人员的角度设计和编写减少运算符的理论并发方法。从这里开始，本章还将建立与可以以类似方式使用并发性解决的类似问题的联系。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The concept of a reduction operator in computer science
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机科学中的减少运算符的概念
- en: The communicative and associative properties of reduction operators, and therefore
    the reason why concurrency can be applied
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少运算符的交换和结合属性，以及并发可以应用的原因
- en: How to identify problems that are equivalent to a reduction operator and how
    to apply concurrent programming in such cases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何识别与减少运算符等价的问题，以及如何在这种情况下应用并发编程
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following is a list of prerequisites for this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章的先决条件列表：
- en: You must have Python 3 installed on your computer
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的计算机必须安装Python 3
- en: Download the GitHub repository from [https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从[https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)下载GitHub存储库
- en: During this chapter, we will be working with the subfolder titled `Chapter07`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用名为`Chapter07`的子文件夹
- en: Check out the following video to see the Code in Action: [http://bit.ly/2TD5odl](http://bit.ly/2TD5odl)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码实际运行情况：[http://bit.ly/2TD5odl](http://bit.ly/2TD5odl)
- en: The concept of reduction operators
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少运算符的概念
- en: As experienced programmers, you have undoubtedly encountered situations where
    you need to calculate the sum or the product of all the numbers in an array, or
    compute the result of applying the `AND` operator to all Boolean elements of an
    array to see whether there is any false value in that array. These are called
    **reduction operators**, which take a set or an array of elements and perform
    some form of computation to return only one single result.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为经验丰富的程序员，您无疑遇到过需要计算数组中所有数字的和或乘积，或者计算将`AND`运算符应用于数组的所有布尔元素以查看该数组中是否存在任何假值的情况。这些被称为**减少运算符**，它们接受一组或一个元素数组，并执行某种形式的计算，以返回一个单一的结果。
- en: Properties of a reduction operator
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少运算符的属性
- en: 'Not every mathematical or computer science operator is a reduction operator.
    In fact, even if an operator is capable of reducing an array of elements into
    one single value, there is no guarantee that it is a reduction operator. An operator
    is a reduction operator if it satisfies the following conditions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个数学或计算机科学运算符都是减少运算符。事实上，即使一个运算符能够将一个元素数组减少为一个单一值，也不能保证它是一个减少运算符。如果运算符满足以下条件，则运算符是减少运算符：
- en: The operator can reduce an array of elements into one scalar value
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作员可以将一个元素数组减少为一个标量值
- en: The end result (the scalar value) must be obtained through creating and computing
    partial tasks
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终结果（标量值）必须通过创建和计算部分任务来获得
- en: The first condition is indicative of the phrase "reduction operators", as all
    elements of the input array have to be combined and reduced into one single value.
    However, the second condition is, essentially, in terms of concurrency and parallelism.
    It requires the computation of any reduction operator to be able to be divided
    into smaller partial computations.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个条件表明了“减少运算符”这个短语，因为输入数组的所有元素都必须被组合并减少为一个单一的值。然而，第二个条件本质上是关于并发和并行性。它要求任何减少运算符的计算都能够被分解为较小的部分计算。
- en: 'First, let''s consider one of the most common reduction operators: addition.
    For example, consider the input array `[1, 4, 8, 3, 2, 5]`—the sum of the elements
    in this array is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑最常见的减少运算符之一：加法。例如，考虑输入数组`[1, 4, 8, 3, 2, 5]`的元素之和如下：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding computation, we reduced the numbers in our array into their
    sum, `23`, in a sequential order. In other words, we went through each and every
    element of the array from the beginning to the end and added the current sum.
    Now, we know that addition is a commutative and associative operator, which means:
    *a + b = b + a* and *(a + b) + c = a + (b + c)*.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的计算中，我们按顺序将数组中的数字减少到它们的总和`23`。换句话说，我们从数组的开头到结尾遍历了每个元素，并添加了当前的总和。现在，我们知道加法是一个可交换和可结合的运算符，这意味着：*a
    + b = b + a* 和 *(a + b) + c = a + (b + c)*。
- en: 'Therefore, we can perform the preceding computation in a more efficient way
    by breaking the summation into smaller summations:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过将前面的计算分解为更高效的方式来进行更高效的计算：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This technique is at the heart of applying concurrency and parallelism (specifically
    multiprocessing) to a reduction operator. By breaking the whole task into smaller
    subtasks, multiple processes can perform those small computations simultaneously,
    and the system as a whole can arrive at the result much more quickly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术是应用并发和并行（特别是多进程）到减少运算符的核心。通过将整个任务分解为较小的子任务，多个进程可以同时执行这些小计算，整个系统可以更快地得出结果。
- en: 'For the same reason, the communicative and associative properties are considered
    to be equivalent to the requirements for a reduction operator that we discussed
    earlier. In other words, the operator ![](assets/bbe67805-00e5-4140-b1f5-532e3c676f83.png) is
    a reduction operator that''s communicative and associative. Specifically the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Communicative: *a ![](assets/1f978d15-59d3-4b54-90f2-d6e8fb68d558.png) b =
    b ![](assets/4d6c15e7-49c7-4ce9-9c36-f989c275b760.png) a*'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Associative: *(a ![](assets/8ad90b0c-03cd-429a-8561-f8a1b19082a7.png) b) ![](assets/a00626a1-0076-4aa4-94a7-e01e50e9e8ad.png) c
    = a ![](assets/bd4efb4b-bd8a-4177-8b48-0bb94835babb.png) (b ![](assets/f73dbfc9-7675-46b9-9b07-ae58721000a3.png) c)*'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here *a*, *b*, and *c* are elements of input arrays.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: So, if an operator is a reduction operator, it has to be communicative and associative,
    and therefore has the ability to break down a big task into smaller, more manageable
    subtasks, which can be computed in a more efficient way using multiprocessing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Examples and non-examples
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen that addition is one example of a reduction operator. To
    perform addition as a reduction operator, we first divide the elements from our
    input array into groups of two, each of which is one of our subtasks. We then
    perform addition on each group, take the added result from each group, and divide
    them into groups of two again.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'This process continues until we arrive at one single number. This process follows
    a model called binary tree reduction, which utilizes groups of two to form the
    subtasks:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7cad13ee-22a1-4512-8731-75e2c3dbaa52.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: Diagram of binary tree reduction for addition
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example with the array [1, 4, 8, 3, 2, 5], after dividing the
    numbers into three different groups of two numbers (1 and 4, 8 and 3, 2 and 5),
    we used three separate processes to add the pairs of numbers together. We then
    obtained the array [5, 11, 7], which we used for one process to obtain [16, 7],
    and again another process to finally obtain 23\. So, with three CPUs or more,
    an addition operator of six elements can be done in log[2]6 = 3 steps instead
    of five steps in sequential addition.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Other common examples of reduction operators are multiplication and logical
    AND. For example, reducing the same array of numbers [1, 4, 8, 3, 2, 5] using
    multiplication as a reduction operator would be done as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To reduce an array of Boolean values, for example (`True`, `False`, `False`,
    `True`), using the logical `AND` operator, we could do the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A non-example of reduction operators is the power function, as changing the
    order of computation would change the final result (that is, the function is not
    communicative). For example, reducing the array `[2, 1, 2]` sequentially would
    give us the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And if we were to change the order of operation as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We would obtain a different value. Therefore, the power function is not a reduction
    operation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Example implementation in Python
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned previously, due to their communicative and associative properties,
    reduction operators can have their partial tasks created and processed independently,
    and this is where concurrency can be applied. To truly understand how a reduction
    operator utilizes concurrency, let's try implementing a concurrent, multiprocessing
    reduction operator from scratch—specifically the add operator.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Similar to what we saw in the previous chapter, in this example, we will be
    using a task queue and a result queue to facilitate our interprocess communication.
    Specifically, the program will store all of the numbers in the input array in
    the task queue as individual tasks. As each of our consumers (individual processes)
    executes, it will call `get()` on the task queue **twice** to obtain two task
    numbers (except for some edge cases where there is no or only one number left
    in the task queue), add them together, and put the result in the result queue.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Similar to adding pairs of numbers together, like we did in the previous section,
    after our processes iterate through the tasks queue one time and put the added
    pairs of task numbers in the result queue, the number of elements in the input
    array will have been reduced by half. For example, an input array of `[1, 4, 8,
    3, 2, 5]` will become `[5, 11, 7]`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Now, our program will assign the new task queue to be the result queue (so,
    in this example, `[5, 11, 7]` is now the new task queue), and our processes will
    continue going through it and adding pairs of numbers together to generate a new
    result queue, which will become the next task queue. This process repeats itself
    until the result queue only contains one element, since we know that that single
    number is the sum of the numbers in the original input array.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the changes in the task queue and the result queue
    in each iteration of processing the input array `[1, 4, 8, 3, 2, 5]`; the process
    stops when the result queue contains only one number (`23`):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/56cfb844-7f33-473a-9489-38b1f4cb11cd.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: Sample diagram of the multiprocessing add operator
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `ReductionConsumer` class in the `Chapter07/example1.py` file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We implement the `ReductionConsumer` class by overriding the `multiprocessing.Process`
    class. This consumer class takes in a task queue and a result queue when initialized,
    and handles the consumer process logic of the program, which calls `get()` twice
    on the task queue to obtain two numbers from the queue, and adds their sum to
    the result queue.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: While doing this, the `ReductionConsumer` class also handles cases where there
    is no or only one number left in the task queue (that is, when either the `num1`
    or `num2` variable is `None`, which, as we know from the previous chapter, is
    what we use to indicate a poison pill).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, recall that the `JoinableQueue` class of the `multiprocessing`
    module is used to implement our task queues, and that it requires the `task_done()`
    function to be called after each time the `get()` function is called, otherwise
    the subsequent `join()` function that we will call on the task queue later will
    block indefinitely. So, in the case where the consumer process calls `get()` two
    times, it is important to call `task_done()` on the current task queue twice,
    and when we only call `get()` once (when the first number is a poison pill), then
    we should call `task_done()` only once. This is one of the more complex considerations
    while working with multiprocessing programs that facilitate interprocess communication.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'To process and coordinate different consumer processes as well as manipulate
    the task queue and the result queue after each iteration, we have a separate function
    called `reduce_sum()`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This function takes in a Python list of numbers to compute the sum of its elements.
    Aside from a task queue and a result queue, the function also keeps track of another
    variable called `result_size`, which indicates the number of elements in the current
    result queue.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: After initializing its base variables, the function spawns its consumer processes
    to reduce the current task queue inside a while loop. As we discussed previously,
    in each iteration of the while loop, the elements in the task queue are added
    together pairwise, and the added results are stored in the result queue. After
    that, the task queue will take over the elements of that result queue, and add
    additional `None` values to the queue to implement the poison pill technique.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: In each iteration, a new empty result queue is also initialized as a `JoinableQueue`
    object—this is different from the `multiprocessing.Queue` class that we used for
    our result queue in the previous chapter, since we will be assigning `tasks =
    results` at the beginning of the next iteration, and the task queue needs to be
    a `JoinableQueue` object.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: We also update the value of `result_size` at the end of each iteration through
    `result_size = result_size // 2 + (result_size % 2)`. It is important to note
    here that while the `qsize()` method from the `JoinableQueue` class is a potential
    method to keep track of the length of its object (that is, the number of elements
    in a `JoinableQueue` object), this method is usually considered to be unreliable
    for various reasons—it is not even implemented in Unix operating systems.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Since we can easily predict how the number of remaining numbers from our input
    array will change after each iteration (it is halved if it is an even number,
    otherwise it is halved by integer division, and then `1` is added to that result),
    we can keep track of that number using a separate variable called `result_size`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'As for our main program for this example, we simply pass a Python list to the
    `reduce_sum()` function. Here, we are adding numbers from 0 to 19:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After running the script, your output should be similar to the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Real-life applications of concurrent reduction operators
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The communicative and associative nature of the way reduction operators process
    their data enables the subtasks of an operator to be processed independently,
    and is thus highly connected to concurrency and parallelism. Consequently, various
    topics in concurrent programming could be related to reduction operators, and
    by applying the same principles of reduction operators, problems regarding those
    topics could be made more intuitive and efficient.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, add and multiply operators are reduction operators. More generally,
    number-crunching problems that usually involve communicative and associative operators
    are prime candidates for applying concurrency and parallelism. This is actually
    a true case for the famous, and arguably one of the most used modules in Python—NumPy,
    whose code is implemented to be as parallelizable as possible.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, applying the logic operators AND, OR, or XOR to an array of Boolean
    values works the same way as reduction operators. Some real-world applications
    for concurrent bitwise reduction operators include the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Finite state machines, which commonly take advantage of logic operators while
    processing logic gates. Finite state machines can be found in both hardware structures
    and software designs.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication across sockets/ports, which typically involves parity and stop
    bits to check for data errors, or flow control algorithms. These techniques utilize
    logic values of individual bytes to process information through the use of logic
    operators.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compression and encryption techniques, which heavily depend on bitwise algorithms.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Careful considerations need to be made while implementing multiprocessing reduction
    operators in Python, especially if the program utilizes task queues and result
    queues to facilitate communication across the consumer processes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The operations of various real-world problems resemble reduction operators,
    and the use of concurrency and parallelism for these problems could greatly improve efficiency
    and thus productivity of the programs processing them. It is therefore important
    to be able to identify these problems, and relate back to the concept of reduction
    operators to implement their solutions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will be discussing a specific real-world application
    for multiprocessing programs in Python: image processing. We will be going over
    the basic ideas behind image processing and how concurrency—specifically multiprocessing—could
    be applied to image-processing applications.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a reduction operator? What conditions must be satisfied so that an operator
    can be a reduction one?
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What properties do reduction operators have that are equivalent to the required
    conditions?
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the connection between reduction operators and concurrent programming?
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are some of the considerations that must be made while working with multiprocessing
    programs that facilitate interprocess communication in Python?
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用Python进行进程间通信的多处理程序中，必须考虑哪些因素？
- en: What are some real-life applications of concurrent reduction operators?
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发减少运算符的一些真实应用是什么？
- en: Further reading
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, you can refer to the following links:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参考以下链接：
- en: '*Python Parallel Programming Cookbook*, Giancarlo Zaccone, Packt Publishing
    Ltd, 2015'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python并行编程食谱*，Giancarlo Zaccone，Packt Publishing Ltd，2015'
- en: '*Learning Concurrency in Python: Build highly efficient, robust, and concurrent
    applications.*, Elliot Forbes (2017)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习Python并发：构建高效、健壮和并发的应用程序*，Elliot Forbes (2017)'
- en: '*Parallel Programming in OpenMP*, Morgan Kaufmann, Chandra, Rohit (2001)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*OpenMP中的并行编程*，Morgan Kaufmann，Chandra, Rohit (2001)'
- en: '*Fundamentals of Parallel Multicore Architecture*, Yan Solihin (2016), CRC
    Press'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*并行多核架构基础*，Yan Solihin (2016)，CRC Press'
