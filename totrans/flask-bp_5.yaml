- en: Chapter 5. Shutterbug, the Photo Stream API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will build a (primarily) JSON-based API that allows us to
    view a reverse chronologically ordered list of photos that have been added—this
    has become quite popular in recent years due to Instagram and similar photo sharing
    applications. For the sake of simplicity, we will forgo the usual social aspect
    that many of these applications are typically built around; however, you are encouraged
    to combine the knowledge of the previous chapters with the information in this
    chapter to build such an application.
  prefs: []
  type: TYPE_NORMAL
- en: Shutterbug, the minimal API-only application that we are about to embark on,
    will allow a user to upload a photograph of their choosing via an authenticated,
    JSON-based API.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we will use one of the lesser-known features of Flask (Werkzeug,
    really) to create a custom middleware that will allow us to intercept inbound
    requests and modify the global application environment for very simple API versioning.
  prefs: []
  type: TYPE_NORMAL
- en: Starting off
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once more, as we did in the previous chapters, let''s create a completely new
    directory and virtual environment for this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the following application layout to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The application layout presented here is different from the typical Blueprint-based
    structure that we used in previous chapters; we will use the suggested layout
    for typical Flask-RESTful applications, which also suits the simplicity of the
    Shutterbug application.
  prefs: []
  type: TYPE_NORMAL
- en: The application factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the application factory pattern again in this chapter; let''s add
    our skeleton `create_app` method to the `application/__init__.py` module and include
    our Flask-SQLAlchemy database initialization as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s include our barebones `run.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us the ability to run the application using the built-in Werkzeug
    application server via the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Interlude – Werkzeug
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've spoken about Werkzeug a few times during the course of this book but we
    haven't really explained what it is, why we use it, or why it's useful. To understand
    Werkzeug, we first need to know why it exists. For this, we will need to understand
    the origins of the Python Web Server Gateway Interface specification, most commonly
    abbreviated as WSGI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, choosing a Python web application framework is a relatively simple matter
    of preference: most developers choose a framework based on a previous experience,
    necessity (for example, one that is designed for an asynchronous request processing
    such as Tornado), or some other quantifiable or unquantifiable criteria.'
  prefs: []
  type: TYPE_NORMAL
- en: Several years ago, however, the choice of an application framework affected
    the web server that you could use. As all Python web application frameworks at
    the time implemented their own HTTP request processing in a slightly different
    manner, they were often only compatible with a subset of web servers. Developers,
    tired of this somewhat inconvenient status quo, put forth a proposal to unify
    the interaction of web servers with Python applications through a common specification,
    WSGI.
  prefs: []
  type: TYPE_NORMAL
- en: The WSGI specification, once established, was adopted by all the major frameworks.
    Additionally, several so-called *utility* tools were created; they had the sole
    purpose of bridging the official WSGI specification, which can be somewhat unfriendly
    to work with for new developers, with a more robust intermediate API that aided
    the development of modern web applications. Moreover, these utility libraries
    could then be used as the foundation for more feature-complete and robust application
    frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have guessed by now, Werkzeug is one of these WSGI utility libraries.
    When combined with Jinja, the templating language, and some convenient defaults
    for configuration, routing, and other basic web application necessities, we have
    Flask.
  prefs: []
  type: TYPE_NORMAL
- en: Flask is what we primarily deal with in this book, but a fairly large part of
    the hard work abstracted away from you is contained in Werkzeug. While it largely
    goes unnoticed, it is possible to interact with it directly in order to intercept
    and modify portions of a request before Flask has the chance to process it. We'll
    explore some of these possibilities later on in the chapter when we implement
    a custom Werkzeug middleware for optionally versioning JSON API requests.
  prefs: []
  type: TYPE_NORMAL
- en: Simple APIs with Flask-RESTful
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the great joys of using Flask is the seemingly infinite extensibility
    and composability that it offers. As it's a rather thin layer that sits atop Werkzeug
    and Jinja, it does not impose much on the developer in terms of constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to this flexibility, we have extensions such as Flask-RESTful at our disposal,
    which make creating JSON-based APIs a joy. First, let''s install the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s initialize the extension in our application factory in the usual
    fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The primary building block of the Flask-RESTful extension is the concept of
    a resource. A resource is, for all intents and purposes, a `Flask` method view
    with some very useful defaults set for content-type negotiation. If you haven''t
    encountered the concept of a `MethodView` in Flask until now, don''t fret! They''re
    quite straightforward and provide you with a relatively simple interface to separate
    the RESTful resources by allowing you to define methods on a class that maps directly
    to the basic HTTP verbs: `GET`, `PUT`, `POST`, `PATCH`, and `DELETE`. The Flask-RESTful
    resource, in turn, extends the `MethodView` class and thus allows for the same
    style of verb-based route handling.'
  prefs: []
  type: TYPE_NORMAL
- en: 'More concretely, it means that the Flask-RESTful API nouns can be written in
    the following way. We will first add our photo resource view handlers to `application/resources/photos.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding two `Resource` subclasses, we defined a subset of the HTTP
    verbs that are possible to handle; we are not required to define handlers for
    all the possible verbs. If, for example, our application were to receive a PATCH
    request to one of the preceding resources, Flask would return an HTTP/1.1 405
    Method Not Allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we will import these view handlers to our application factory in `application/__init__.py`
    in order to bind these two classes to our Flask-RESTful API object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we have bound the resources to the API object before we call `api.init_app(app)`.
    If we initialize before we bind the resources, the routes will not exist on the
    Flask application object.
  prefs: []
  type: TYPE_NORMAL
- en: We can confirm that the routes we defined are mapped to the application object
    by starting an interactive Python session and checking the `url_map` attribute
    of our Flask application.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Start the session from the parent of the application folder so that the `PYTHONPATH`
    is set correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output lists a Werkzeug `Map` object, which contains three `Rule`
    objects, each of which lists a URI, the HTTP verbs that are valid against this
    URI, and a normalized identifier (as view handlers can be functions as well as
    `MethodView` subclasses in addition to a few other options) that indicates which
    view handler will be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Flask will automatically handle the HEAD and OPTIONS verbs for all the defined
    endpoints and also add a default `/static/<filename>` route for the static file
    handling. This default static route can be disabled, if necessary, by setting
    the `static_folder` argument to the `Flask` object initialization in our application
    factory to `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s do the same thing for our skeleton user view resource handlers, which
    we will declare in `application/resources/users.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we could have put the `post` method handler on the `SingleUser` resource
    definition but instead, we split it out to its own resource. This is not strictly
    necessary but will make things a bit easier to follow for our application and
    only cost us a few extra lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to what we did with our photo views, we''ll add them to our Flask-RESTful
    API object in our application factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Improved password handling with hybrid attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our `User` model will be quite similar to the one that we used in the previous
    chapter and will use a class attribute `getter`/`setter` for the `password` attribute.
    This will ensure a consistent application of the Bcrypt key derivation function
    to the raw user password regardless of whether we set the value at the time of
    object creation or manually set the attribute of an already created object.
  prefs: []
  type: TYPE_NORMAL
- en: This consists of using the `hybrid_property` descriptor from SQLAlchemy, which
    allows us to define properties that act differently when accessed at the class-level
    (for example, `User.password`, where we want the SQL expression for the password
    field of the user model to be returned) versus instance-level (for example, `User().password`,
    where we want the actual encrypted password string of a user object to be returned
    instead of the SQL expression).
  prefs: []
  type: TYPE_NORMAL
- en: We will define the password class attribute as `_password`, which will ensure
    that we avoid any nasty attribute/method name collisions, so that we can define
    the hybrid `getter` and `setter` methods correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'As our application will be relatively simple in terms of data modeling, we
    can use a single module for our models in `application/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same module, we can then declare our `Photo` model, which will be charged
    with maintaining all the metadata related to an image but not the image itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: API authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For most applications and APIs, the concepts of authentication and authorization
    are central to nontrivial operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: This asserts the veracity of the credentials provided and
    also ensures that they belong to a known entity; in simple terms, this means ensuring
    that the username and password provided to an application belong to a valid user.
    Once verified, the application assumes that the requests performed with these
    credentials are being performed on behalf of the given user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**: These are the permissible actions of an authenticated (or
    unauthenticated) entity in the bounds of the application. In most situations,
    authorization presupposes that a pre-existing authentication step was performed.
    An entity may be authenticated but not authorized to access certain resources:
    if you enter your card and PIN in an ATM (thus authenticating yourself), you can
    view your own accounts, but attempting to view the accounts of another person
    will (hopefully!) result in a refusal as you are not authorized to access that
    information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Shutterbug, we are only concerned with authentication. If we were to add
    various features that included, say, the ability to create private groups of users
    that have access to a shared pool of photos, then systematized authorization would
    be required to determine which users can access which subsets of resources.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication protocols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many developers will already be familiar with several authentication protocols:
    the usual identifier/password combination that is standard across most web applications
    in existence and OAuth for many modern APIs (for example, Twitter, Facebook, GitHub,
    and others). For our own application, we will use the incredibly simple HTTP Basic
    authentication protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: While HTTP Basic is not the most flexible nor secure (it provides no encryption
    whatsoever, actually), it is reasonable to implement this protocol for simple
    applications, demos, and prototype APIs. In the early days of Twitter, it was
    actually the only method by which you could authenticate with their API! Moreover,
    when transmitting data over HTTPS, which we should do in any production-level
    environment, we are assured that the plaintext request that includes our user
    identifier and password is encrypted from any malicious third parties that may
    be listening in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the HTTP Basic authentication is not overly complex,
    but it''s most definitely something that we can offload to an extension. Let''s
    go ahead and install Flask-HTTPAuth to our environment, which consists of creating
    an instance of the extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And set up the extension in our `application/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Flask-HTTPAuth includes various decorators to declare handlers/callbacks in
    order to perform parts of the authentication process. We''ll implement the one
    that gives us the most control over how the authentication is performed and put
    this in a new module in `application/authentication.py`. In addition to the verification
    of the credentials, we will attach the SQLAlchemy user object to the Flask context
    local `g` on successful authentication so that we can utilize this data in other
    parts of the request processing and response generation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `auth.verify_password` decorator allows us to specify a function that accepts
    a username and password, both of which are extracted out of the Authorization
    header that is sent with the request. We will then use this information to query
    our database for a user with the same username, and upon successfully finding
    one, we will ensure that the provided password hashes to the same value that we
    stored for this user. If the password does not match or the username does not
    exist, we will return False and Flask-HTTPAuth will return a 401 Unauthorized
    header to the requesting client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to actually use the HTTP Basic authentication, we need to add the `auth.login_required`
    decorator to the view handlers that will require authentication. We know that
    all user operations (except creating a new user) will require an authenticated
    request, so let''s implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due to the fact that the self argument for a method of a Resource object refers
    to the Resource instance and not the method, we cannot use regular view decorators
    on the individual methods of the view. Rather, we must use the `method_decorators`
    class attribute, which will apply the declared functions (in order!) to the view
    method that has been invoked to handle the request.
  prefs: []
  type: TYPE_NORMAL
- en: Getting users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we''ve figured out the authentication portion of the application,
    let''s implement the API endpoints to create a new user and fetch the existing
    user data. We can flesh out the `get()` method of the `SingleUser` resource class
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'There are quite a few new things happening in the preceding method, so let''s
    deconstruct it. First, we will check that the `user_id` specified in the request
    (for example, `GET /users/1`) is the same as the currently authenticated user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: While this may seem redundant at the moment, it plays a dual role in allowing
    simpler future modifications to the authorization scheme in addition to adhering
    to a somewhat more RESTful approach. Here, a resource is uniquely specified by
    its URI, which is constructed in part by the unique primary key identifier of
    a user object.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the authorization check, we will pull the relevant user out of the database
    by querying it via the `user_id` parameter passed as a named URI parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If no such user is found, then we will abort the current request with an HTTP
    404 Not Found and specify a message in order to make the reason for the non-20x
    response more clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will construct a dictionary of the user data that we want to return
    as a response. We clearly don''t want to return the hashed password or other sensitive
    information, so we will explicitly specify which fields we want to be serialized
    in the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to Flask-RESTful, we do not need to explicitly convert our dictionary
    to a JSON string: The response representation is `application/json` by default.
    There''s one small catch, however: the JSON encoder that Flask-RESTful uses as
    a default does not know how to convert Python `datetime` objects to their RFC822
    string representations. This can be fixed by specifying the `application/json`
    MIME type representation handler and ensuring that we use the `flask.json` encoder
    instead of the default `json` module from the Python standard library.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add the following to our `application/__init__.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Creating new users
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The analog to fetch the existing users from the API is, of course, to create
    new users. While typical web applications do this with a signup process that has
    you fill out various form fields, creating a new user via our API requires that
    the information be submitted to the server via a POST request, validated, and
    then a new user is inserted in the database. The implementation of these steps
    should be put in the `post()` method of our `CreateUser` resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `request.json` file is populated with the POST data if, and only if, the
    content-type of the request is set to `application/json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s nothing too surprising in the preceding method implementation: we
    fetched the POST data from `request.json`, created a `User` object (Very insecurely!
    You can see a bit later on in this chapter for a better alternative.) from it,
    attempted to add it to the database and catch the exception raised if a user of
    the same username or e-mail address already exists, and then serialized an HTTP
    201 Created response with a `Location` header that includes the URI of the newly
    created user.'
  prefs: []
  type: TYPE_NORMAL
- en: Input validation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While Flask includes a relatively simple way of accessing the POST'ed data via
    the `flask.request` proxy object, it does not contain any functionality to validate
    that the data is formatted as we expect it to be. This is okay! Flask attempts
    to be as agnostic as possible with regards to the data storage and manipulation,
    leaving this to the developer. Luckily for us, Flask-RESTful includes the `reqparse`
    module that can be used for the data validation and its usage is very similar
    in spirit to the popular `argparse` library used for CLI argument parsing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will set up our new user data parser/validator in our `application/resources/users.py`
    module and declare our fields and their types and whether they are required in
    the POST data to be considered as valid requests or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the `new_user_parser` setup in our module, we can modify the
    `CreateUser.post()` method to utilize this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `new_user_parser.parse_args(strict=True)` invocation will attempt to match
    the declared types and requirements for the fields that we defined via `add_argument`
    earlier and will internally `abort()` with an HTTP 400 error in case any fields
    do not pass validation or there are additional fields in the request that we have
    not explicitly accounted for. (Thanks to the `strict=True` option.)
  prefs: []
  type: TYPE_NORMAL
- en: The use of `reqparse` to validate the POST'ed data can be more cumbersome than
    the direct assignment that we had previously, but is more secure by an order of
    magnitude. With the direct assignment technique a malicious user might send arbitrary
    data in the hope of overriding fields that they should not have access to. For
    example, our database could contain the internal only `subscription_exipires_on
    datetime` field and a nefarious user could then submit a POST request containing
    a value for this field set to the far future. Definitely something that we'd like
    to avoid!
  prefs: []
  type: TYPE_NORMAL
- en: API testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's apply some of the knowledge that we gained in the previous chapters with
    regards to functional and integration testing with `pytest`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first step (after the requisite pip install `pytest-flask`, of course)
    is to add a `conftest.py` file as we did in the previous chapters, which is sibling
    to our `application/` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `conftest.py` file contains the basic test fixtures that we will
    need in order to write our API tests properly; there should be no surprises here.
    We will then add our `test_settings.py` file, which is sibling to the newly created
    `conftest.py`, and populate it with the application configuration values that
    we want for our test runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is in place, we can begin writing our test functions and assertions
    in `tests/test_users.py`. Our first test will ensure that we can create a new
    user via the API and the URI of the newly created resource is returned to us in
    the `Location` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve established that a user can be created, the next logical step is
    to test that an error is returned if a client attempts to create a user with invalid
    or missing parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As a sanity check for our HTTP Basic authentication implementation, let''s
    also add a test to fetch a single user record, which requires the request to be
    authenticated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The associated test for an unauthenticated request for a single user record
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also test that our very simple authorization implementation functions
    as expected (Recall that we only allow authenticated users to view their own information
    and not that of any other users in the system.) with a test that creates two users
    and attempts to access each other''s data via authenticated requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Interlude – Werkzeug middlewares
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For certain tasks, we sometimes need the ability to modify the inbound request
    data and/or environment before the request is routed to a handler function or
    method. In many situations, the easiest way to achieve this would be to register
    a function with the `before_request` decorator; this is often used to set `request-global`
    values on the `g` object or create a database connection.
  prefs: []
  type: TYPE_NORMAL
- en: While this should suffice for a large portion of the most common use cases,
    sometimes it's more convenient to drop down below the Flask application object
    (when the request proxy object is constructed) but above the HTTP server. For
    this, we have the concept of middlewares. Additionally, a properly written middleware
    will be portable across other compatible WSGI implementations; there's nothing
    stopping you (barring any application-specific oddities) from using a middleware
    originally written for a Django application in our current Flask application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Middlewares are relatively simple things: they are essentially any callable
    (classes, instances, functions, or methods that can be invoked in a manner similar
    to a function) that return the proper response format so that the other middlewares
    in the chain can be invoked correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: One example of a middleware that is useful for our current API-based application
    is one that allows us to extract an optional version number from the request URIs
    and store this information in the environment so that it can be used at various
    points during the request processing. For example, a request to `/v0.1a/users/2`
    will be routed to the handler for `/users/2` and `v0.1a` will be accessible via
    `request.environ['API_VERSION']` in the Flask application itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new module in `application/middlewares.py`, we can implement it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We will bind this middleware to the application object in our factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When adding multiple WSGI middlewares, their order can sometimes matter. Be
    sure to keep this in mind when adding middlewares that can modify the WSGI environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once bound, the middleware is inserted into the request processing before Flask
    receives the request even though we clearly instantiated a Flask application object.
    Accessing the `API_VERSION` value in your application is a simple matter of querying
    the key bound to the request environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The parsing of the API version numbers could also be extended to examining the
    HTTP headers (custom or otherwise) in addition to the URL-based version extraction
    that we have provided here; a case could be made for the convenience of either.
  prefs: []
  type: TYPE_NORMAL
- en: Back to Shutterbug – uploading photos
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have a minimal but functional API to create and fetch users, we
    need a similar one to upload photos. First, we will use the same resource pattern
    that we used previously in addition to defining a `RequestParser` instance to
    validate the user submitted data regarding the photos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the preceding `UploadPhoto` resource, we are accessing `request.files`
    to extract the binary data that was POST'ed to the endpoint. We then parsed out
    the extension, generated a unique random string to act as the filename, and finally
    saved the file to a known `UPLOAD_FOLDER` that we configured in our application
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we used the `werkzeug.utils.secure_filename` function to sanitize
    the extension of the uploaded image in order to ensure that it is not vulnerable
    to path traversal or other filesystem-based exploits that are common when dealing
    with user uploaded binary data.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other verifications and sanitization steps (for example, ensuring
    that the MIME type of the file matches the extension and binary data that was
    actually uploaded, limiting the size/dimensions of the image) that should be performed
    when accepting untrusted data that will be persisted to a filesystem, but we omit
    them for the sake of brevity. Data validation techniques and best practices could
    fill an entire book in themselves.
  prefs: []
  type: TYPE_NORMAL
- en: The local filesystem path that we end up persisting the image to is then added
    to our photo SQLAlchemy record along with the optional comment that may have accompanied
    the photo upload. The whole lot is then added to the session and committed to
    the database before returning a 201 response with the location of the newly created
    asset in the headers. There are some simple error conditions that we avoid handling
    in this so that we can focus on the core concepts presented and their implementation
    is left as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before taking any of the new photo upload functionalities out for a spin, make
    sure to bind the resource to the API object in our application factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: File uploads in distributed systems
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We have greatly simplified the treatment of file uploads in modern web applications.
    Of course, simplicity often has several downsides.
  prefs: []
  type: TYPE_NORMAL
- en: The most glaring of these is that in the preceding implementation, we are restricted
    to a single application server. If multiple application servers existed, ensuring
    that the uploaded files remain synchronized across these multiple servers then
    becomes a major operational concern. While there are many solutions to this particular
    problem (for example, distributed filesystem protocols such as NFS, uploading
    the assets to remote storage such as Amazon's **Simple Storage Service** (**S3**),
    and so on), they all require additional thought and consideration to evaluate
    their pros and cons and significant changes to your application's structure.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the photo uploads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we''re on somewhat of a testing roll, let''s keep this ball rolling by writing
    some simple tests in order to validate the behavior of our `UploadPhoto` resource
    in `tests/test_photos.py`. First, let''s try to upload some binary data with an
    unauthenticated request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s check the obvious success path with a properly authenticated request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s ensure that when we submit the (optional) comment, it is persisted
    to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Fetching the user's photos
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Other than the ability to upload photos, the meat of the Shutterbug application
    lies in the ability to fetch a list, in a reverse chronological order, of photos
    that were uploaded by the authenticated user. For this, we will flesh out the
    `ListPhoto` resource in `application/resources/photos.py`. As we want the ability
    to paginate this list of returned photos, we will also create a new instance of
    `RequestParser` to handle the common page/limit query arguments. Additionally,
    we will use the marshalling feature of Flask-RESTful to serialize the returned
    `Photo` objects that are returned from SQLAlchemy so that they can then be converted
    to JSON and sent over the wire to the requesting client.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Marshalling** is something that web applications (and most other kinds of
    applications!) do all the time even if you might have never heard of the word.
    Simply, you take the data in some form of an in-memory representation, such as
    a Python dictionary or list, and convert it to a format that is more suitable
    for transmission. In the case of our application, this transformation is to JSON
    and the transmission occurs over HTTP to the client that made the request.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the preceding `ListPhoto.get()` handler, we calculated an offset
    value based on the page and limit that are provided by the request parameters.
    The page and limit are independent of the size of our dataset and easy to understand
    for clients that are consuming the API. SQLAlchemy (and most database APIs, for
    that matter), only understand offset and limit. The conversion formula is a well-known
    one and is applicable to any sorted dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter began somewhat differently than the previous ones. Our objective
    was to create a JSON-based API instead of a typical web application that produced
    HTML and consumed submitted HTML form data.
  prefs: []
  type: TYPE_NORMAL
- en: We first took a bit of a sidestep to explain the existence and usefulness of
    Werkzeug and then created a basic API with a Flask extension called Flask-RESTful.
    Next, we made sure that our API could be protected by requiring authentication
    and explained the subtle but fundamental difference between authentication and
    authorization.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at how we could implement validation rules for our API in order
    to ensure that clients could create valid resources (for example, new users, upload
    photos, and so on). We implemented several functional and integration-level unit
    tests using the `py.test` framework.
  prefs: []
  type: TYPE_NORMAL
- en: We finished off the chapter by implementing the most important feature, photo
    uploads. We ensured that this feature functioned as expected with a few more test
    cases and then implemented the reverse chronological view of the photos necessary
    for a consumer of the API to display the uploaded images to the user. Along the
    way, we discussed the concept of Werkzeug middlewares, a powerful but often overlooked
    way of introspecting and (possibly) modifying a request before Flask has had a
    chance to process it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the usage and creation of command line
    tools that will allow us to interface and manage our web applications via CLI.
  prefs: []
  type: TYPE_NORMAL
