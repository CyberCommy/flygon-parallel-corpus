- en: '*Chapter 3*: Building Better Apps with ES6+ Features'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll review certain important features of JavaScript in its
    latest ES6+ form (I've added the plus sign to indicate ES6 and beyond). It is
    important to understand that although this book uses TypeScript, the two languages
    are complementary. In other words, TypeScript does not replace JavaScript. It
    augments and enhances JavaScript, adding features that make it better. Therefore,
    we'll do a review of some of the most important features in the JavaScript language.
    We'll review variable scoping and the new `const` and `let` keywords. Also, we'll
    dive deeper into the `this` keyword and how we can switch it if needed. We'll
    also learn about the many new features in JavaScript, such as the new array functions
    and `async await`. This knowledge will give us a solid foundation upon which we
    can code in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about ES6 variable types and JavaScript scoping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about arrow functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the `this` context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about spread, de-structuring, and rest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about new array functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about new collection types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about `async await`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The requirements for this chapter are the same as for [*Chapter 2*](B15508_02_Final_JC_ePub.xhtml#_idTextAnchor025)*,
    Exploring TypeScript*. You should have a basic understanding of JavaScript and
    web technologies. You will once again be using Node and **Visual Studio Code**
    (**VSCode**).
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository is at [https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node).
    Use the code in the `Chap3` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set up this chapter''s code folder:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to your `HandsOnTypescript` folder and create a new folder called `Chap3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open VSCode and go to `Chap3` folder you just created. Then, select **View**
    | **Terminal** and enable the terminal window within your VSCode window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type the `npm init` command, as in the previous chapter, to initialize the project
    for `npm`, and accept all the defaults (you can also use `npm init -y` to accept
    all defaults automatically).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type the `npm install typescript` command, as in the previous chapter, to install
    TypeScript.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we're ready to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about ES6 variable types and JavaScript scoping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about JavaScript's scoping rules and some new
    variable types that help to clarify and improve upon some issues regarding these
    scope rules. This information is valuable since you will be creating variables
    constantly throughout your career as a software developer, and it is important
    to understand under what scope a variable can be accessed and under what circumstances
    it may be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most other languages, variable scoping happens within any arbitrary set
    of brackets or *begin end* scope statements. However, scope in JavaScript is handled
    by the body of a function, which means when a variable is declared inside a function
    body using the `var` keyword, that variable is only accessible within that body.
    Let''s take a look at an example of this. Create a new file called `functionBody.ts`
    and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In VSCode, you should see an error indication on the call to `console.log(val2)`,
    whereas the call to `console.log(val1)` works just fine. You might have thought
    that since `val1` is declared within the brackets of the `if` statement, it would
    not be accessible later. However, clearly it is. But on the other hand, `val2`
    scoped by the `go` function is not accessible outside of it. This shows that as
    far as variable declaration using `var` is concerned, it is functions that act
    as scoping containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This feature is actually the source of much confusion in JavaScript. So, in
    ES6, a new set of variable declaration prefixes have been created: `const` and
    `let`. Let''s review them here.'
  prefs: []
  type: TYPE_NORMAL
- en: '`const` variables support something called block-level scoping. Block-level
    scoping is scoping between any squiggly brackets. For example, in our previous
    example, that would be the `if` statement. In addition, as the name implies, `const`
    creates a constant variable value that, once set, cannot be reset to something
    else. However, what this means is a little bit different from some other languages.
    In JavaScript, this means that the variable''s assignment cannot be changed. However,
    the variable itself can be edited. This is hard to imagine, so let''s look at
    some examples. Create a new file called `const.ts` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In VSCode, this code will show an error for `val1 = 2`, but it will be OK for
    `val2.push('hello')`. The reason for this is that in the case of `val1`, the variable
    is actually being reset into an entirely new value, which is not allowed. However,
    for `val2`, the array value remains the same and a new element is being added
    to it. So, this is allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the `let` keyword. `let` variables are, like `const` variables,
    also block-scoped. However, they can be set and reset at will (of course, in TypeScript,
    the type needs to stay the same). Let''s show an example of `let`. Create a file
    called `let.ts` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So, here, we have two sets of `let` variables. `val1` is not scoped in a block,
    but `val2` is scoped in an `if` block. As you can see, only the call to `console.log(val2)`
    is failing, since `val2` only exists inside the `if` block.
  prefs: []
  type: TYPE_NORMAL
- en: So then, which variable declaration method do you use? The current best practice
    in the community is to prefer using `const`, as immutability is a beneficial attribute
    and also, using constants adds a tiny performance benefit. However, if you know
    that you need to be able to reset the variable later, then use `let` instead.
    Finally, avoid using `var`.
  prefs: []
  type: TYPE_NORMAL
- en: We've learned about scoping and the new `const` and `let` variable types in
    ES6\. Understanding scoping and knowing when to use `const` versus `let` is an
    important skill for doing modern JavaScript development. In newer JavaScript code,
    you'll see these keywords often. Next, we'll review the `this` context and arrow
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about arrow functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arrow functions were a new addition to ES6\. Basically, they serve two main
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: They shorten the syntax for writing functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They also automatically make the immediate scope parent, the `this` object,
    the arrow function's parent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let me explain `this` a bit more before continuing as it's critical knowledge
    for JavaScript developers.
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, the `this` object, the owner object instance that member properties
    and methods belong to, can change based on the context of a call. So, when a function
    is called directly—for example, `MyFunction()`—the parent `this` would be the
    caller of the function; that is to say, the current scope's `this` object. For
    browsers, that would usually be the `window` object. However, in JavaScript, functions
    can also be used as object constructors—for example, `new MyFunction()`. In this
    case, the `this` object inside the function would be the object instance that
    was created from the `new MyFunction` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example to clarify as this is a really important feature
    of JavaScript. Create a new file called `testThis.ts` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you compile and then run this code, you will see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – testThis result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.01_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – testThis result
  prefs: []
  type: TYPE_NORMAL
- en: So, when `MyFunction` is called directly, the immediate scope parent is going
    to be Node's global object, since we are not running in a browser. Next, if we
    create a new object from `MyFunction` using `new MyFunction()`, the `this` object
    becomes its own object instance since the function was used to create an object
    as opposed to being run directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have that out of the way, let''s see what an arrow function looks
    like. Create the `arrowFunction.ts` file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you compile and run this code, you'll see that `hello` is printed out. The
    syntax is very similar to a function type; however, they are not the same. If
    we look at the code, you can see a colon after the parameter parentheses and then
    the void type after the parameter parentheses. This is the return type of the
    function. In the case of function types, the return type is indicated after the
    `=>` symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Here are some additional things to note about arrow functions. All non-arrow
    functions in JavaScript have access to a collection called `arguments`. This is
    a collection of all the parameters given to the function. Arrow functions do not
    have their own `arguments` collection. However, they do have access to the immediate
    function parent's `arguments` collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The arrow function has several body styles. Here are examples of the three
    styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at each of the three styles:'
  prefs: []
  type: TYPE_NORMAL
- en: The first function, `func`, shows the case where only a single line of code
    is used in the function body, and nothing is returned, as you can see that the
    body has no closing braces or parentheses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second function, `func1`, shows when there is only a single line, but something
    is returned. In this case, the `return` keyword is not needed, and parentheses
    are needed only if an object is returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final case is `func2`. In this case, squiggly brackets are needed because
    it is a multi-line statement (regardless of whether it returns or not).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We covered arrow functions in this section. Arrow functions are used a great
    deal in modern JavaScript and TypeScript code, so it's beneficial to know about
    this feature in depth.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the this context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already discussed the `this` context object in the previous section. As
    mentioned, in JavaScript, functions have access to an internal object called `this`
    that represents the caller of the function. Now, the confusing part of using `this`
    is that the value of `this` can change depending on how the function is called.
    So, JavaScript provides helpers that allow you to reset the `this` object of a
    function to the one you want, instead of the one given to you. There are several
    methods, including `apply` and `call`, but the most important one for us to learn
    is the `bind` keyword. This is important for us to know because `bind` is used
    often in React class-based components. It''s a bit early to show a full-blown
    React example. So, let''s start with something a little easier. Create a new file
    called `bind.ts` and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from this code, there are two distinct classes: `A` and `B`.
    Both of these classes have a `go` function that writes the specific class name
    to the log. Now, when we reset the `this` object''s `bind` of our `b` object''s
    `go` function to be the `a` object, it switches the `console.log(this.name)` statement
    to use `a` as the `this` object. So, if we compile and run, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – bind'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.02_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – bind
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `a.go()` writes `A` but `b.go()` also writes `A`, instead of
    `B`, since we switched `this` to be `a` instead of `b`. Note that also, in addition
    to taking the `this` argument, `bind` can also take any number of parameters thereafter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be wondering what the difference between using `bind`, `call`, and
    `apply` is. `bind` is used to make the `this` context change and later, when the
    function is called, it will have the changed `this` object. However, `call` and
    `apply` are used at the time the function is called and immediately replace the
    `this` context at the time of calling. The difference between `call` and `apply`
    is that `call` takes an indeterminate number of parameters and `apply` takes an
    array of parameters. Let''s look at some examples. Create a file called `call.js`
    and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we are creating a new object called `callerObj` that has a field called
    `name`, which is `jon`. After that, we declare a `checkMyThis` function, which
    tests what `this` is currently and whether it has a name. Finally, we run both
    calls. Note that the second call looks weird but `checkMyThis.call` is an actual
    execution of the `checkMyThis` function. If we run this code, we will see something
    interesting. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – node call'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.03_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – node call
  prefs: []
  type: TYPE_NORMAL
- en: The first execution of the `checkMyThis` function uses the global object by
    default, since it was not overridden. Again, for Node, it's Node's global object,
    but for browsers, it's the `window` object. We also see that the `name` and `age`
    fields are undefined, since Node's global object does not have the `name` field
    and the age was not passed as a parameter to `checkMyThis`. However, on the second
    execution of the function, the one that uses `call`, we see that the object has
    changed to a standard object type and it has a name of `jon`, which is the `name`
    field for `callerObj`, and an `age` field equal to `25`, which is the parameter
    we passed into `call`. You should note the order of the parameters list for `call`
    follows the order of the parameters list of the function being called. The usage
    of `apply` would be identical; however, it takes parameters as an array.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the difficulties of working with the `this`
    context and how to deal with this using `bind`. We will use `bind` extensively
    later once we start creating React components. But even beyond that specific use
    case, you will find that your code will sometimes need the ability to change the
    `this` context and possibly some parameters for your functions. So, this ability
    is a very useful feature to have.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about spread, destructuring, and rest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In ES6+, there are new methods for handling object copying and displaying variables
    and parameters. These capabilities go a long way in making JavaScript code both
    shorter and easier to read. These features have become standard practice in modern
    JavaScript, so it is important that we know about them and use them properly.
  prefs: []
  type: TYPE_NORMAL
- en: Spread, Object.assign, and Array.concat
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Object.assign`, and `Array.concat` JavaScript features are fairly similar.
    Basically, you are appending multiple objects or arrays together into one object
    or array. However, strictly speaking, there are some differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of objects, there are two ways of merging or concatenating objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Spread—for example, `{ … obja, …objb }`: You are creating a non-modified copy
    of these two objects and then creating a brand-new object. Note that spread can
    handle more than just two objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.assign`—`(obja, objb)`: You are adding the properties from `objb` into
    `obja` and returning `obja`. Therefore, `obja` is being modified. Here''s an example.
    Create a new file called `spreadObj.ts` and add the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: tsc spreadObj –target 'es6'
  prefs: []
  type: TYPE_NORMAL
- en: node spreadObj
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 3.4 – spreadObj'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.04_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – spreadObj
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `c` has both `aname` and `bname` properties but is a unique
    object unto itself. However, `d` is actually object `a` with the properties of
    object `b`, which is demonstrated by the `aname` variable being equal to `a1`
    after `a.aname = 'a1'` was set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, for merging or concatenating arrays, you also have two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The spread operator: Like spread for objects, it merges the arrays and returns
    a single new array. Original arrays are not modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.concat`: Creates a new array by merging the two source arrays into a
    single array. Original arrays are not modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example using both methods. Create a file called `spreadArray.ts`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, array `c` is created using spread from two arrays: `a` and
    `b`. Then, array `d` is created using `a.concat(b)`. In this case, both resulting
    arrays are unique and do not refer to any of the original arrays. Let''s compile
    and run this code as we did before and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – spreadArray'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.05_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – spreadArray
  prefs: []
  type: TYPE_NORMAL
- en: You will see that `a.push(10)` has no effect on the `console.log('d after',
    d)` statement even though array `d` was created from array `a`. This shows that
    both spread and `concat` for arrays create new arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring
  prefs: []
  type: TYPE_NORMAL
- en: '**Destructuring** is the ability to display and directly use the internal properties
    of an object instead of relying on the object name alone. I''ll explain this later
    with an example, but please be aware that this is a very frequently used feature
    in modern JavaScript development, especially in React hooks, so we need to be
    comfortable with it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of object destructuring. For this example, let''s
    just use a JavaScript file, as the example will be clearer that way. Create a
    new file called `destructuring.js` and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let's pretend for a moment that the `getEmployee` function goes to a server
    and retrieves the information of an employee by `id`. Now, as you can see, the
    `employee` object has lots of fields and perhaps not every caller of the function
    will need every field. So, we use object destructuring to select only the fields
    we care about. Note, in addition, that we also give the field name an alias of
    `fullName` by using the colon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Destructuring is also possible for arrays. Let''s add the following code to
    this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of this example, the `getEmployeeWorkInfo` function returns an
    array of facts about the employee''s work location; but it returns it as an array.
    So, we can also destructure an array as well, but note that the order of the elements
    does matter at destructure time. Let''s look at the results for both functions.
    Note that we only need to call Node since this is a JavaScript file. Run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following results for both functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Destructuring'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.06_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – Destructuring
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, both functions have returned the correct relative data.
  prefs: []
  type: TYPE_NORMAL
- en: Rest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`…` keyword. Any rest parameters are arrays and therefore have access to all
    array functions. The rest keyword refers to "the rest of the items" and not "pause"
    or ''''stop." This keyword allows more flexibility when creating your function
    signature, as it allows the caller to determine how many parameters they want
    to pass. Please note that only the last parameter can be a rest parameter. Here''s
    an example of using rest. Create a file called `rest.js` and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `…others` refers to the rest of the parameters after `a`. This
    indicates that rest parameters do not have to be the only parameters for a function.
    So, if you run this code, you get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Rest'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.07_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – Rest
  prefs: []
  type: TYPE_NORMAL
- en: 'The `doSomething` function receives two parameters: the `a` variable and the
    `a` parameter, the rest parameter (which again is an array of parameters), and
    the last element of the rest parameter are written. Rest is not as frequently
    used as spread and destructuring. Nevertheless, you will see it, so you should
    be aware of it.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about JavaScript features that make code shorter
    and easier to read. The usage of these features is very common in modern JavaScript
    programming, so you'll benefit greatly from learning how to use these capabilities.
    In the next section, we'll learn about some very important array manipulation
    techniques that streamline dealing with arrays and are also very popularly used.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about new array functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will review the many methods added for manipulating arrays
    in ES6\. It is a very important section as you will have to deal with arrays frequently
    in JavaScript programming, and using these performance-optimized methods is preferable
    over creating your own. The use of these standard methods also makes code more
    consistent and readable by other developers on your team. We will take advantage
    of these methods extensively in both our React and Node development. Let's get
    started.
  prefs: []
  type: TYPE_NORMAL
- en: find
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `find` keyword allows you to grab the first instance of an element from
    an array that matches your search criteria. Let''s look at a simple example. Create
    `find.ts` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the code for `find`, you can see that it takes a function as
    the parameter and the function is looking for an item with the name of `jon`.
    The function does a truth check to see whether the item''s name is equal to `jon`.
    If the item truth check is true, `find` will return that item. However, you can
    also see that there are two `jon` items in the array. Let''s compile and run this
    code and see which one returns. Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After compiling and running the preceding commands, you should see the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – find'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.08_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – find
  prefs: []
  type: TYPE_NORMAL
- en: You can see in the output that the first `jon` item found is returned. This
    is how `find` works; it always gives back only one item—the first one found in
    the array.
  prefs: []
  type: TYPE_NORMAL
- en: filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`filter` is similar to `find` except it returns all items that match a search
    criterion. Let''s create a new file called `filter.ts` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `filter` function can also take an optional second parameter
    for the index number of the item in the array. But moving on, internally, it looks
    identical to how `find` works in that there is a truth check to see whether a
    certain match is found. However, for `filter`, all matches get returned, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – filter'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.09_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – filter
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, for `filter`, all items that meet the filter criteria are returned,
    which in this sample case is both `jon` items.
  prefs: []
  type: TYPE_NORMAL
- en: map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `map` function is one of the more important array functions to know about
    for ES6 style coding. It appears frequently in React component creation in order
    to create a collection of component elements from an array of data. Note that
    the `map` function is different from the `Map` collection, which we''ll cover
    later in this chapter. Create a new file called `map.ts` and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `map` function has two parameters, `item` and `index` (you
    can call them whatever you like, but the order matters), and it maps custom return
    values to each array element. To be clear, `return` means to return each item
    back into a new array. It does not mean to return and stop running the iteration.
    If we run the code, it results in the following DOM string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – map'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.10_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – map
  prefs: []
  type: TYPE_NORMAL
- en: This function may in fact be the most common ES6 array function, so it is very
    important that you understand how it works. Try modifying the code and practice
    using it with different array item types.
  prefs: []
  type: TYPE_NORMAL
- en: reduce
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `reduce` function is an aggregator that takes each element in an array
    and, based on custom logic, creates a single final value. Let''s look at an example.
    Create a `reduce.js` file—again, we''ll use a JavaScript file to remove some noise
    from the TypeScript compiler and focus—and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, let''s imagine we need to calculate the total tonnage capacity
    a trucking company can carry with all its trucks. So then, `allTrucks` lists out
    the tonnage of each of its trucks. Then, we use `allTrucks.reduce` to get the
    total capacity of all trucks. The `initialCapacity` variable is used only to have
    some starting point, which is currently set at `0`. Then, when we log out the
    final value, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – reduce'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.11_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – reduce
  prefs: []
  type: TYPE_NORMAL
- en: The total capacity of all the trucks is `24` since the sum of each truck's capacity
    is 24\. Notice the logic of the reducer can be anything; it does not have to be
    a sum. It could be a subtraction or any other logic that you may need. The core
    point is that at the end, you will have only a single value or object result.
    This is why it is called `reduce`.
  prefs: []
  type: TYPE_NORMAL
- en: some and every
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These functions are designed to test for certain criteria. So, they only return
    `true` or `false`. `some` tests to see whether *any* element in an array meets
    certain criteria and `every` tests whether *all* elements meet a certain criteria.
    Let''s take a look at both. Create a file called `someEvery.js` and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is pretty straightforward and both conditions of `some` and `every`
    are tested. If you run this code, you''ll see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – someEvery'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.12_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – someEvery
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the results are valid for each test.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the many new functions added to ES6 that help
    us deal with and use arrays in JavaScript more efficiently. You will definitely
    be using many of these functions in your own code later when we build our app.
    Next, we'll learn about some new collection types that can be used instead of
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about new collection types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 has two new collection types, `Set` and `Map`, which can be useful for certain
    specific scenarios. In this section, we will learn about these two types and how
    to write code for them so that we can use them later when we start building our
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Set` is a collection of unique values or objects. This is a good function
    to use when you simply want to see whether an item is contained in a large complex
    list. Let''s see an example. Create a new file called `set.js` and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There are many members for the `Set` object, but these are some of its most
    important features. As you can see, `Set` has a constructor that can take an array,
    which makes that array a unique set.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: In regard to sets, `size` is used to check quantity not length.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom, notice how iterating `Set` is different from the normal way
    of using array indexes. Running this file will result in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Set'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.13_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – Set
  prefs: []
  type: TYPE_NORMAL
- en: Conceptually, it is still quite similar to an array but is optimized for unique
    collections.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Map` is a collection of key-value pairs. In other words, it''s a dictionary.
    Every member of `Map` has a unique key. Let''s create a sample `Map` object. Create
    a new file called `mapCollection.js` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, some of the calls are quite similar to `Set`. One difference,
    however, is the iteration loop at the bottom, which uses an array to indicate
    the key and value. Running this file results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – mapCollection'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.14_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14 – mapCollection
  prefs: []
  type: TYPE_NORMAL
- en: It's pretty straightforward. First, a list of all `Map` objects is logged. Then,
    we get the `jim` item by using its key value with `get`. Next is `size`, and then
    finally an iteration over all elements.
  prefs: []
  type: TYPE_NORMAL
- en: This section showed the two new collection types in ES6\. These types are not
    used that frequently but can come in handy should you have the needs that these
    collections address. In the next section, we'll discuss `async await`, which is
    an ES7 feature. `async await` has seen very rapid adoption by the JavaScript developer
    community because it makes difficult-to-read asynchronous code much more readable
    and makes it appear as if it is synchronous.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about async await
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before explaining `async` and `await`, let's explain what asynchronous code
    is. In most languages, code is usually synchronous, which means that statements
    run one after another. If you have statements `A`, `B`, and `C`, statement `B`
    cannot run until statement `A` is completed and statement `C` cannot run until
    statement `B` is completed. However, in asynchronous programming, if statement
    `A` is asynchronous, it will start but then immediately after that, statement
    `B` will start. So then, statement `B` never waits for `A` to complete before
    it runs. This is great for performance but makes code harder to read and fix.
    `async` `await` in JavaScript attempts to address some of these difficulties.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, asynchronous programming provides faster performance because statements
    can run simultaneously without having to wait for each other. However, in order
    to understand asynchronous programming, we need to first understand callbacks.
    Callbacks are a core feature of Node.js programming since its inception, so it
    is important to understand. Let''s look at an example of callbacks. Create a new
    file called `callback.js` and enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If we look at this code, we can see that the `letMeKnowWhenComplete` function
    has two parameters. The first one indicates the size of an iteration to do a math
    calculation and the second one is the actual callback. As you can see from the
    code, `callback` is a function that is executed once the math work is complete,
    hence the name. To be precise, technically a callback is not actually asynchronous.
    However, it does provide capabilities that are effectively the same in that secondary
    work, the callback, is done exactly once the primary is complete without needing
    to wait or poll. So now, let's look at JavaScript's first method for doing asynchronous
    completion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first capability JavaScript received to do asynchronous execution was with
    the `setTimeout` and `setInterval` functions. These functions are simple; they
    take a callback that is executed once a certain specified time completes. In the
    case of `setInterval`, the only difference is that it repeats. The reason why
    these functions are truly asynchronous is that when a timer runs, it runs outside
    of the current `setTimer.js` and enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s review this code. I''ve added comments to separate out the main sections.
    First, under comment 1, we have a log message indicating that this code is starting.
    Then, under comment 2, we have `setTimeout`, which will execute our arrow function
    callback after waiting 3 seconds. When the callback runs, it will log that it
    finished. After `setTimeout`, we see another log message, under comment 3, asking
    whether the timer has finished yet. Now, when you run this code, a strange thing
    will happen, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – setTimer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.15_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15 – setTimer
  prefs: []
  type: TYPE_NORMAL
- en: The last log message asking `Did I finish yet?` will run first, and then the
    log for `I waited and am done now`.' will complete. Why is that? `SetTimeout`
    is an asynchronous function, so when it executes, it allows whatever code was
    written after it to execute immediately (even though `setTimeout` is not done
    yet). That means in this case, the log in comment 3 actually runs before the callback
    in comment 2\. So then, if we imagine that comment 3 had some important code that
    needed to run right away, without waiting for comment 2, we can see how using
    an asynchronous call would be helpful for performance. Now, let's combine our
    understanding of callbacks and asynchronous calls and take a look at Promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before `async await`, asynchronous code was handled using Promises. A `Promise`
    is an object with a delayed completion at some indeterminate future time. An example
    of `Promise` code would be something like this. Create a file called `promise.js`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we first create a `Promise` object and internally, we use an asynchronous
    timer to execute a statement after 500 milliseconds. On the first try, we are
    deliberately failing the timer by calling `reject` and this causes the code below
    the `Promise` definition to go to the `catch` handler. Now, if we comment out
    `reject` and then uncomment `resolve`, the bottom code will then go to the `then`
    handler. Clearly, this code works, but if you imagine a much more complex `Promise`,
    having many `then` statements, or even many Promises, things become increasingly
    complex to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where `async await` can help. It does two main things: it cleans up
    the code and makes it simpler and smaller and it also makes the code easier to
    follow as it *looks* like synchronous code. Let''s view an example. Create a new
    file called `async.js` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This code has a function called `delayedResult`, which, as you can see, has
    the `async` prefix in front of it. Prefixing a function with `async` tells the
    runtime that this function will return a `Promise` and therefore should be handled
    asynchronously. After `delayedResult`, we see a function called `execAsyncFunc`
    that is both declared and executed simultaneously. If you are not familiar with
    it, this capability is called an `execAsyncFunc` function is also `async`-capable
    and as you can see, internally, it uses the `await` keyword. The `await` keyword
    tells the runtime that we are about to execute an asynchronous function, so it
    should wait on our behalf, and then, once the statement completes, give us the
    actual return value instead. If we run this code, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – async'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.16_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.16 – async
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `result` variable contains the `I completed successfully`
    string instead of the `Promise` that `delayedResult` normally returns. This syntax
    is clearly much shorter and easier to read than having many nested `Promise` `then`
    statements. Please note that `async` and `await` have taken over asynchronous
    development in the JavaScript community. You must understand it well in order
    to succeed with modern JavaScript. We'll look at one more example to further our
    understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: We had to use an IIFE for the `execAsyncFunc` function because in current JavaScript,
    top-level `await` is not allowed. Top-level `await` basically means being able
    to run a call to await a function that is not inside of another `async` function.
    In the ECMAScript 2020 version of JavaScript, this is enabled, but as of the time
    of writing, it is not yet completely supported across all browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `async await` is so important, let''s look at one more example. Let''s
    make a call to a network resource to get some data. We''ll use the `fetch` API,
    but since Node does not support it natively, we''ll need to install one more `npm`
    package first. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command in your terminal to install `fetch`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `fetch.js` and enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice, in this example, the easy-to-read and natural flow of the code. As you
    can see, we are using the `fetch` API, which allows us to make asynchronous network
    calls. After importing `fetch`, we again create an `async` wrapper function to
    execute `await` calls to our `fetch` function. If you're wondering, the URL is
    a public API for Pokémon characters that requires no authentication. The first
    call to `await` is for the actual network call itself. Once that call completes,
    a check for success is made using `response.ok`. If successful, another call to
    `await` is made to convert the data into JSON format. Each call to `await` blocks
    the code at that point until the function completes and returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are *awaiting* because we cannot continue without this data from the network
    API and therefore we have no choice but to wait. If you run this code, you will
    see the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – fetch'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.17_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.17 – fetch
  prefs: []
  type: TYPE_NORMAL
- en: When this code ran, you probably noticed a small delay before the code completed.
    This shows the code needed to wait until the network call for the data to complete.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned what asynchronous programming is. We also discussed
    both Promises, the foundation of asynchronous programming in JavaScript, and `async
    await`, which provides us with a means to streamline our asynchronous code. You
    will see `async await` used heavily in both React and Node development.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at a lot of the newer, cutting-edge features of JavaScript
    programming, such as methods for merging objects and arrays with `async await`,
    a new and very popular way of working with asynchronous code. It is very important
    to understand these features as they are extensively used in modern JavaScript
    and React development.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will begin digging into single-page application development
    using React. We will start using many of the features that we learned about in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
