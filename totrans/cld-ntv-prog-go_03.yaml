- en: Securing Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the third chapter in our journey to learn modern Go cloud programming.
    In this chapter, we will secure the restful API service that was authored in the
    preceding chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start diving into the code we need to write, there are some key concepts
    that we have to cover in order to provide a decent knowledge foundation.
  prefs: []
  type: TYPE_NORMAL
- en: As we covered in the preceding chapter, web applications need to make use of
    HTTP (which is an application-level protocol) in order to communicate. HTTP by
    itself is not secure, which means that it sends data over plain text. Obviously,
    if we are trying to send credit card information or sensitive personal data, we
    would never want to send it as a clear text. Fortunately, HTTP communications
    can be secured via a protocol known as **TLS** (**Transport Layer Security**).
    The combination of HTTP and TLS is known as HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The internal workings of HTTPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing microservices in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To practically understand HTTPS, we will need to first talk about the TLS protocol.
    TLS is a protocol that can be utilized to encrypt data communicated over a computer
    network. TLS relies on two types of cryptography algorithms to achieve its goals—**symmetric
    cryptography** and **public-key cryptography**.
  prefs: []
  type: TYPE_NORMAL
- en: Public-key cryptography is also known as asymmetrical cryptography. We will
    cover where the name came from shortly. On the other hand, symmetric cryptography
    can also be called symmetric-key algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric cryptography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core idea of data encryption is the use of complex mathematical equations
    to encode (or cipher) data, which in effect will make this data unreadable to
    humans. In the world of secure software communication, the encrypted data can
    then be sent to the intended receiver, which will be expected to decrypt the data
    back to its original human-readable form.
  prefs: []
  type: TYPE_NORMAL
- en: In almost all cases, to encrypt a piece of data, you will need an **encryption
    key**. Encryption keys are simply a piece of the complex mathematical equations
    used to encode the data. In some encryption algorithms, you can use the same encryption
    key to decrypt your data back to its original form. In others, a **decryption
    key** that is different than the encryption key is needed to perform the decryption.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric cryptography or symmetric-key algorithms are the algorithms that make
    use of the same key to encrypt and decrypt the data, which is why they are called
    **symmetric**. The following diagram shows where an encryption key is utilized
    to encrypt the word **Hello** into an encoded form, then the same key is used
    with the encoded data to decrypt it back to the word **Hello**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64412289-eba5-4bf4-a5a4-6229a4aecf23.png)'
  prefs: []
  type: TYPE_IMG
- en: Symmetric cryptography
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric-key algorithms in HTTPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's return to the world of web applications and HTTP. In general, web
    applications are just different pieces of software that communicate using the
    HTTP protocol. As mentioned earlier in the chapter, to secure HTTP and transform
    it to HTTPS, we will combine it with another protocol called TLS. The TLS protocol
    makes use of symmetric-key algorithms to encrypt HTTP data between a client and
    a server. In other words, the web client and the web server start their communication
    by agreeing on a shared encryption key (some call it a shared secret), which is
    then used to protect the data going back and forth between them.
  prefs: []
  type: TYPE_NORMAL
- en: The sender application uses the key to encrypt the data before sending it to
    the recipient application, which in turn utilizes a copy of the same key to decrypt
    this data. This process is the symmetric-key algorithm part of the TLS protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a41dc9a4-96d8-4b53-b608-2d6a864725ec.png)'
  prefs: []
  type: TYPE_IMG
- en: Symmetric-key algorithms in HTTPS
  prefs: []
  type: TYPE_NORMAL
- en: This sounds all good and well, but how exactly would a web client and web server
    securely agree on the same encryption key before starting to use it to send encrypted
    data? Obviously, the web client can't just send the key in plain text to the web
    server and not expect the key to being captured by an unauthorized third party
    that can then simply decrypt any secure communication via the stolen key. The
    answer to that question as we mentioned earlier is that the TLS protocol relies
    on not one, but two types of cryptography algorithms to secure HTTP. The symmetric-key
    algorithms, which we have covered so far, are utilized to secure most of the communication;
    however, the public-key algorithms are used for the initial handshake. This is
    where the client and the server say hi and identify each other, then agree on
    an encryption key to use thereafter.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric cryptography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike symmetric-key algorithms, asymmetric cryptography or public-key algorithms
    that utilize two keys for protection of data. One key to encrypt the data is known
    as the public key, and it can be shared safely with other parties. Another key
    to decrypt the data is known as the private key, and it must not be shared.
  prefs: []
  type: TYPE_NORMAL
- en: The public key can be used by any person to encrypt data. However, only the
    person with the private key that corresponds to the public key can decrypt the
    data back to its original human-readable form. The public and private keys are
    generated using complex computational algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: In a typical scenario, a person who owns a pair of public and private keys would
    share the public key with other people that they want to communicate with. The
    other people would then use the public key to encrypt the data being sent to the
    key owner. The key owner, in turn, can use their private key to decrypt this data
    back to its original content.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a good example—courtesy of Wikipedia—that showcases the idea. Let's
    say Alice want to communicate with her friends securely over the internet. For
    that, she uses an application that generates a pair of public-private keys.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/222b0883-4987-4d8f-b015-c5528b6fa682.png)'
  prefs: []
  type: TYPE_IMG
- en: Alice's public-private key
  prefs: []
  type: TYPE_NORMAL
- en: Now, a friend of Alice called Bob would like to send her a secure message over
    the internet. The message is simply **Hello Alice!** Alice first needs to send
    Bob a copy of her public key so that Bob can use it to encrypt his message before
    sending it to Alice. Then, when Alice receives the message, she can use her private
    key, which is not shared with anyone, to decrypt the message back to the human-readable
    text and see that Bob said hello.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aaed743e-4890-4438-b629-2f12c677c270.png)'
  prefs: []
  type: TYPE_IMG
- en: Asymmetric cryptography between Alice and Bob
  prefs: []
  type: TYPE_NORMAL
- en: With this, you should have enough practical understanding of public-key algorithms.
    However, how is this utilized in the HTTPS protocol?
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetrical cryptography in HTTPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier in this chapter, asymmetrical cryptography is utilized
    between a web client and web server to agree on a shared encryption key (also
    known as shared secret or session key) that is then used in symmetrical cryptography.
    In other words, the key is used by both the web client and web server to encrypt
    mutual HTTP communications. We have already covered the symmetrical cryptography
    part of this interaction, so now let's dive a bit deeper into how the asymmetrical
    cryptography part is carried out.
  prefs: []
  type: TYPE_NORMAL
- en: A **handshake** occurs between the web client and web server, where the client
    indicates its intention to start a secure communication session to the server.
    Typically, this entails agreeing on some mathematical details on how the encryption
    occurs.
  prefs: []
  type: TYPE_NORMAL
- en: The server then replies with a **digital certificate**. If you are not familiar
    with the concept of digital certificates, then now is the time to shed some light
    on what it is. A digital certificate (or a public-key certificate) is an electronic
    document that proves the ownership of a public key. To understand the importance
    of digital certificates, let's take a couple of steps back to remember what a
    public key is.
  prefs: []
  type: TYPE_NORMAL
- en: As covered earlier, a public key is an encryption key used in asymmetric cryptography
    (or public-key algorithms); the key can only encrypt data but can never decrypt
    it back, and it can be shared with anyone who we wish to communicate with. The
    issuer of the public key always holds a corresponding key called the private key,
    which can decrypt the data encrypted by the public key.
  prefs: []
  type: TYPE_NORMAL
- en: This sounds great, but what happens if a client requests a public key to communicate
    with a server, then a bad agent intercepts this request and replies with its own
    public key (this is known as a man-in-the-middle attack)? The client will then
    keep communicating with this bad agent thinking that it is the legitimate server;
    the client may then send sensitive information, such as credit card numbers or
    personal data, to the bad agent. Obviously, if we seek true protection and security,
    we want to avoid this scenario at all costs, hence comes the need for certificates.
  prefs: []
  type: TYPE_NORMAL
- en: A digital certificate is a digital document that gets issued by a trusted third-party
    entity. The document contains a public encryption key, the server name that the
    key belongs to, and the name of the trusted third-party entity who verifies that
    the information is correct and that the public key belongs to the expected key
    owner (also called the issuer of the certificate). The trusted third-party entity
    who issues the certificate is known as a **CA** (**certificate authority**). There
    are multiple known CA who issue a certificate and verify identities for businesses
    and organizations. They typically charge a fee for their service. For larger organizations
    or government bodies, they issue their own certificates; this process is known
    as **self-signing**, and hence, their certificates are known as self-signed certificates.
    Certificates can have expiry dates by which the certificates will need to be renewed;
    this is for extra protection to protect in case the entity that owned the certificate
    in the past had changed.
  prefs: []
  type: TYPE_NORMAL
- en: A web client typically contains a list of certificate authorities that it knows
    of. So, when the client attempts to connect to a web server, the web server responds
    with a digital certificate. The web client looks for the issuer of the certificate
    and compares the issuer with the list of certificate authorities that it knows.
    If the web client knows and trusts the certificate issuer, then it will continue
    with the connection to that server and make use of the public key in the certificate.
  prefs: []
  type: TYPE_NORMAL
- en: The public key obtained from the server will then be used to encrypt communications
    in order to securely negotiate a shared encryption key (or session key or shared
    secret) to then be used in symmetrical cryptography communications between the
    web client and web server. There is a number of algorithms that can be used to
    generate this session key, but they are beyond the scope of this chapter. What
    we need to know is that once a session key is agreed on, the initial handshake
    between the web client and web server will conclude, allowing the actual communication
    session to proceed securely under the protection of the shared session key.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we now have sufficient practical understanding of how web communications
    are secured. This is used for secure Restful web APIs and secure web page loads.
    One more important remark to add is that the URL utilized for secure web communications
    starts with `https://` instead of `http://`. This is obvious because secure web
    communications utilize HTTPS instead of just HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Secure web services in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it's time to find out how to write secure web services in the Go language.
    Fortunately, Go was built from the grounds up with modern software architectures
    in mind, which includes secure web applications. Go comes with a powerful standard
    library that allows a smooth transition from HTTP servers to HTTPS servers. Before
    we start looking into the code, let's answer the simple question of how to obtain
    a digital certificate to use in our web server.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining a certificate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default method to obtain a digital certificate for your organization, start-up,
    or website is to buy the service of verifying your identity and issuing a certificate
    from a certificate authority provider. As we mentioned earlier, there are multiple
    certificate authority providers. A list of the most popular providers can be found
    in Wikipedia at: [https://en.wikipedia.org/wiki/Certificate_authority#Providers](https://en.wikipedia.org/wiki/Certificate_authority#Providers)
  prefs: []
  type: TYPE_NORMAL
- en: There are also certificate authorities who provide the service for free. For
    example, in 2016, the **Mozilla Foundation** along with the **Electronic Frontier
    Foundation** and the **University of Michigan** collaborated to found a certificate
    authority called *Let's Encrypt*, which can be found at: [https://letsencrypt.org/](https://letsencrypt.org/).
    *Let's Encrypt* is a free service that performs the validation, signing, and issuing
    of certificates in an automated fashion.
  prefs: []
  type: TYPE_NORMAL
- en: That sounds great. However, what if we just want to test some local web application
    such as the event's microservice we built in the preceding chapter? In this case,
    we will need a more straightforward way to generate certificates that we can work
    and test with. Then, after that, when we deploy to production, we can use a trusted
    certificate authority to issue certificates for us that will be respected by web
    browsers and clients connected to the internet.
  prefs: []
  type: TYPE_NORMAL
- en: The straightforward approach to generating certificates for our testing, in
    this case, would be to manually create our own certificates and self-sign them.
    The advantage of this is that we can generate numerous certificates to use in
    our internal testing without getting through a verification process. The disadvantage,
    however, is the fact that any third-party web clients, such as web browsers, that
    would try to connect to our web applications via our self-signed certificates
    would not identify the issuer of those certificates and hence will generate a
    lot of warnings before allowing us to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate our newly minted self-signed digital certificates, we will need
    to use specialized tools that understand the algorithms enough to create the necessary
    outputs. Remember that in order to initiate an HTTPS session, we need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A digital certificate which will contain the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A public key that can be shared with other parties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server name or domain name who owns the certificate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The issuer of the certificate. In case of a self-signed certificate, the issuer
    would just be us. In case of a certificate issued by a trusted certificate authority,
    the issuer will be the CA.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A private key that we need to keep a secret and not share with anyone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenSSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of such specialized tools that can generate a TLS digital certificate and
    is very popular is called **OpenSSL**. OpenSSL can be found at: [https://www.openssl.org/](https://www.openssl.org/).
    OpenSSL is an open source commercial grade TLS toolkit that can be used to perform
    a variety of tasks; among them is to generate self-signed digital certificates.
    The OpenSSL organization by itself does not provide prebuilt binaries for the
    tool. However, there is a wiki page that lists third-party places where a binary
    can be downloaded for the tool. The wiki page can be found at: [https://wiki.openssl.org/index.php/Binaries](https://wiki.openssl.org/index.php/Binaries).
    Once you have the tool downloaded, here is an example of how to make use of it
    to generate a digital certificate in addition to its private key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first word in the preceding code is obviously the name of the binary. Let''s
    cover the arguments one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`req`: Stands for the request; it indicates that we request a certificate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-x509`: This will indicate that we want to output a self-signed certificate.
    In the world of cryptography, the notion `X.509` is a standard that defines the
    format of public key certificates. Digital certificates used in many internet
    protocols utilize this standard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-newkey`: This option indicates that we would like a new certificate with
    a paired private key. As mentioned before, a certificate is nothing but a public
    key combined with a bunch of identifiers. So, to perform asymmetric cryptography,
    we will need a private key paired with this public key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rsa:2048`: This is an argument to the `-newkey` option, indicating the type
    of encryption algorithm that we would like to use for generating the key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-keyout`: This option provides the filename to write the newly created private
    key to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`key.pem`: This is the argument to the `-keyout` option. It indicates that
    we would like the private key to be stored in a file called `key.pem`. This key
    needs to be kept private and not shared with anyone, as mentioned earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-out`: This option provides the filename to write the newly created self-signed
    certificate to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cert.pem`: This is the argument to the `-out` option; it indicates that we
    would like to save the certificate in a file called `cert.pem`. This certificate
    can then be shared with web clients attempting to communicate securely with our
    web server in order to invoke HTTPS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-days`: The number of days that the certificate should be valid for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`365`: This is the argument for the `-days` option. It is simply us saying
    that we would like the certificate to be valid for 365 days, or simply one year.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: generate_cert.go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the world of the Go language, there is another approach besides OpenSSL
    to generate self-signed certificates to utilize in our testing. If you go to the
    `GOROOT` folder, which is where the Go language is installed and then head to
    the `/src/crypto/tls` folder, you will find a file called `generate_cert.go`.
    This file is nothing but a simple tool that can easily and efficiently generate
    certificates for our testing pleasure. In my computer, the `GOROOT` folder is
    located at `C:\Go`. The following is a screenshot of the `generate_cert.go` file
    on my machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9aa3dd4-46e3-46c9-88f7-28e13a51d22d.png)'
  prefs: []
  type: TYPE_IMG
- en: generate_cert.go file
  prefs: []
  type: TYPE_NORMAL
- en: 'The `generate_cert.go` is a self-contained Go program that can run simply via
    the `go run` command. Once you run it, it will create a certificate and private
    key files for you and place them in your current folder. The tool supports a number
    of arguments, but typically the most commonly used argument is `--host`, which
    indicates the name of the web server that we would like to generate the certificate
    and the key for. The following is how we would run the tool via the `go run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command was executed on the Windows operating system, which is
    why it represents the `GOROOT` environmental path variable as `%GOROOT%`. How
    the environmental variable is represented differs from one operating system to
    another. In the case of Linux, for example, the environmental variable would be
    represented as `$GOROOT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now instruct the command to build a certificate and a private key for
    a server called `localhost`. The command will generate the certificate and the
    key for us, then place them in the current folder, as mentioned earlier. Here
    is a screenshot showing a successful execution of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d8b88d7-f667-43bf-85e7-f1fac5b17ad6.png)'
  prefs: []
  type: TYPE_IMG
- en: generate_cert.go command
  prefs: []
  type: TYPE_NORMAL
- en: 'The `generate_cert` tool supports other options besides `--host`. It is worth
    it to cover some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--start-date`: This option indicates the start validation date of the certificate.
    The argument to this option needs to be formatted as Jan 1 15:04:05 2011, for
    example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--duration`: This option indicates the duration that the certificate is valid
    for in hours. The default value is a year.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--rsa-bits`: This option indicates the number of bits to be utilized in the
    rsa encryption of the keys. The default value is 2,048.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--help`: This provides a list of supported options with their descriptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the certificate and key files are generated, we can obtain and use them
    in our web server application in order to support HTTPS. We'll see how to do just
    that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Building an HTTPS server in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s finally time to dig into some code. Since Go is very well-suited for
    building modern web software, writing an HTTPS web server is easy. Let''s begin
    by reviewing the piece of code we wrote in the preceding chapter to establish
    an HTTP web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It was a single line of code, a function called `ListenAndServe()`, which belongs
    to the HTTP Go package in the standard library. The first argument to `ListenAndServe()`
    was the endpoint to which we would like our web server to listen to. So, for example,
    if we would like our web server to listen to local port 8181, the endpoint would
    be `:8181` or `localhost:8181`. The second argument is the object that describes
    the HTTP routes and their handlers—this object was created by the Gorilla `mux`
    package. The code to create it from the preceding chapter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert the web server from the preceding chapter from HTTP to HTTPS, we
    will need to perform one simple change—instead of calling the `http.ListenAndServer()`
    function, we''ll utilize instead another function called `http.ListenAndServeTLS()`.
    The code will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, the `http.ListenAndServeTLS()` function takes
    more arguments than the `original http.ListenAndServe()` function. The extra arguments
    are the second and third arguments. They are simply the digital certificate filename
    and the private key filename. The first argument is still the web server listening
    endpoint, whereas the last argument is still the handler object (which, in our
    case, is a Gorilla `*Router` object). We have already generated the certificate
    and private key files from the preceding step, so all we need to do here is to
    ensure that the second and third arguments point to the correct files.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. This is all what we need to do in order to create an HTTPS web server
    in Go; the Go HTTP standard package will then take the certificate and private
    key and utilize them as required by the TLS protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, what if we would like to support both HTTP and HTTPS in our microservice?
    For this, we will need to get a little creative. The first logical step would
    be to run both the `http.ListenAndServe()` and the `http.ListenAndServeTLS()`
    functions in our code, but then we come across an obvious challenge: how would
    both functions listen on the same local port? We simply solve this by picking
    a listening port for HTTPS that is different than the listening port of HTTP.
    In the preceding chapter, we used a variable called **endpoint** to hold the value
    of the local HTTP server listening address. For HTTPS, let''s assume that the
    local listening address is stored in a variable called `tlsendpoint`. With this,
    the code will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That sounds great, but now we are faced with another hurdle, both of `http.ListenAndServeTLS()` and
    the `http.ListenAndServe()` are blocking functions. This means that whenever we
    call them, they block the current goroutine indefinitely until an error occurs.
    This means that we can't call both functions on the same goroutine.
  prefs: []
  type: TYPE_NORMAL
- en: A goroutine is a vital language component in Go. It can be considered as a lightweight
    thread. Go developers make use of goroutines everywhere to achieve efficient concurrency.
    To communicate information between multiple goroutines, we use another Go language
    components called Go channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the solution for this is simple. We call one of the functions in a different
    goroutine. This can be simply achieved by placing the word go before the function
    name. Let''s run the `http.ListenAndServe()` function in a different goroutine.
    Here is what the code would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect! With this, our web server can function as an HTTP server for clients
    who would like to use HTTP or an HTTPS server for clients who prefer to use HTTPS.
    Now, let''s address another question: both of the `http.ListenAndServe()` and
    the `http.ListenAndServeTLS()` functions return error objects to report any issues
    in case of failure; so, can we capture errors produced from either function in
    case of failure, even though they run on different goroutines? For this, we''ll
    need to make use of Go channels, which is the Go idiomatic way to communicate
    between two goroutines. Here is how the code will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we create two Go channels, one called `httpErrChan` and
    the other one called `httptlsErrChan`. The channels will hold an object of type
    error. One of the channels will report errors observed from the `http.ListenAndServe()`
    function, whereas the other will report errors returned from the `http.ListenAndServeTLS()`
    function. We then use two goroutines with anonymous functions in order to run
    the two `ListenAndServe` functions and push their results into the corresponding
    channels. We use anonymous functions here because our code entails more than just
    calling the `http.ListenAndServe()` or the `http.ListenAndServeTLS()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: You may note that we now run both of the `ListenAndServe` functions in goroutines
    instead of just one. The reason we do that is to prevent either of them from blocking
    the code, which will allow us to return both of the `httpErrChan` and the `httptlsErrChan`
    channels to the caller code. The caller code, which is the main function in our
    case, can then handle the errors as it pleases if any errors occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding chapter, we placed this code in a function called `ServeAPI()`;
    let''s now look at the completed code of this function after our changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The function now takes a new string argument called `tlsendpoint`, which will
    hold the HTTPS server listening address. The function will also return two error
    channels. The function code then proceeds to define the HTTP routes that our REST
    API supports. From there, it will create the error channels we discussed, call
    the HTTP package `ListenAndServe` functions in two separate goroutines, and return
    the error channels. The next logical step for us is to cover the code that will
    call the `ServeAPI()` function and see how it handles the error channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'As discussed earlier, our main function is what calls the `ServeAPI()` function,
    so this will put the burden of handling the returned error channels on the main
    function as well. Here is what the code in the main function will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The code will call the `ServeAPI()` function, which will then capture the two
    returned error channels into two variables. We will then use the power of the
    Go's `select` statement to handle those channels. A `select` statement in Go can
    block the current goroutine to wait for multiple channels; whatever channel returns
    first will invoke the `select` case that corresponds to it. In other words, if
    `httpErrChan` returns, the first case will be invoked, which will print a statement
    in the standard output reporting that an HTTP error occurred with the error found.
    Otherwise, the second case will be invoked. Blocking the main goroutine is important,
    because if we don't block it then the program will just exit, which is something
    we don't want happening if there are no failures. In the past, the `http.ListenAndServe()`
    function used to block our main goroutine and prevent our program from exiting
    if no errors occurred. However, since we now have run both of the `ListenAndServe`
    functions on separate goroutines, we needed another mechanism to ensure that our
    program does not exit unless we want it to.
  prefs: []
  type: TYPE_NORMAL
- en: In general, whenever you try to receive a value from a channel or send a value
    to a channel, the goroutine will be blocked till a value is passed. This means
    that if no errors are returned from the `ListenAndServe` functions, then no value
    will pass through the channels, which will block the main goroutine till an error
    happens.
  prefs: []
  type: TYPE_NORMAL
- en: There is another type of channels in Go beside regular channels called buffered
    channels, which can allow you to pass values without blocking your current goroutine.
    However, in our case here, we use regular channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last piece of code we need to cover here is to update the configuration.
    Remember—in the previous chapter—that we used a configuration object in order
    to process configuration information for our microservice. The configuration information
    entailed database addresses, HTTP endpoints, and so on. Since we now also need
    an HTTPS endpoint, we need to add it to the configuration. The configuration code
    existed in the `./lib/configuration.go` file. Here is what it should now look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we did three main things from the last chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We added a constant called `RestfulTLSEPDefault`, which will default to `localhost:9191`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added a new field to the `ServiceConfig` struct. The field is called `RestfulTLSEndPint`;
    it will be expected to correspond to a JSON field called `restfulapi-tlsendpoint`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `ExtractConfiguration()` function, we set the default value of the `RestfulTLSEndPint`
    field of the initialized `ServiceConfig` struct object to `RestfulTLSEPDefault`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With those three changes, our configuration layer will be able to read the HTTPS
    endpoint value from a configuration JSON file if a configuration override exists.
    If either no configuration file exists, or no `restfulapi-tlsendpoint` JSON field
    is set in the configuration file, then we will take the default value, which is
    `localhost:9191`.
  prefs: []
  type: TYPE_NORMAL
- en: Any code that will call the `ExtractConfiguration()` function will get access
    to this functionality and be able to obtain either a default or a configured value
    for the HTTPS endpoint. In our code, the main function will call the `ExtractConfiguration()`
    function and will obtain the necessary information to call the `ServeAPI()` function,
    which will run our RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: Perfect! With this last piece, we conclude our chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a deep dive into the world of secure web software and
    how it works internally. We explored HTTPS, symmetric and asymmetric cryptography,
    and how to secure web services in the Go language.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will cover a key topic in the world of distributed
    microservices architectures: message queues.'
  prefs: []
  type: TYPE_NORMAL
