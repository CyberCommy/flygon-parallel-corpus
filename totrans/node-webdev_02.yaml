- en: About Node.js
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is at the fingertips of every frontend web developer, making it a
    very popular programming language, so much so that it is stereotyped as being
    for client-side code in web pages. The chances are that, having picked up this
    book, you've heard of Node.js, a programming platform for coding in JavaScript
    outside web browsers. Now about ten years old, Node.js is becoming a mature programming
    platform that's widely used in projects both big and small.
  prefs: []
  type: TYPE_NORMAL
- en: 'This book will give you an introduction to Node.js. By the end of this book,
    you will have learned about the complete lifecycle of developing server-side web
    applications using Node.js, from concept to deployment and security. In writing
    this book, we have presumed the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You already know how to write software.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are familiar with JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You know something about developing web applications in other languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we evaluate a new programming tool, do we latch on because it's the popular
    new tool? Maybe some of us do that, but the mature approach is to weigh one tool
    against another. That's what this chapter is about, presenting the technical rationale
    for using Node.js. Before getting to the code, we must consider what Node.js is
    and how it fits in the overall marketplace of software development tools. Then
    we will dive right into developing working applications and recognize that often
    the best way to learn is by rummaging around in working code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What you can do with Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why you should use Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The architecture of Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance, utilization, and scalability with Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js, microservice architecture, and testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the twelve-factor app model with Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js is an exciting new platform for developing web applications, application
    servers, any sort of network server or client, and general-purpose programming.
    It is designed for extreme scalability in networked applications through an ingenious
    combination of server-side JavaScript, asynchronous I/O, and asynchronous programming.
  prefs: []
  type: TYPE_NORMAL
- en: While only ten years old, Node.js has quickly grown in prominence and is now
    playing a significant role. Companies, both large and small, are using it for
    large-scale and small-scale projects. PayPal, for example, has converted many
    services from Java to Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js architecture departs from a typical choice made by other application
    platforms. Where threads are widely used to scale an application to fill the CPU,
    Node.js eschews threads because of their inherent complexity. It's claimed that
    with single-thread event-driven architectures, the memory footprint is low, throughput
    is high, the latency profile under load is better, and the programming model is
    simpler. The Node.js platform is in a phase of rapid growth, and many see it as
    a compelling alternative to the traditional web application architectures using Java,
    PHP, Python, or Ruby on Rails.
  prefs: []
  type: TYPE_NORMAL
- en: At its heart, it is a standalone JavaScript engine with extensions that is suitable
    for general-purpose programming and that has a clear focus on application server
    development. Even though we're comparing Node.js to application-server platforms,
    it is not an application server. Instead, Node.js is a programming runtime akin
    to Python, Go, or Java SE. While there are web application frameworks and application
    servers written in Node.js, it is simply a system to execute JavaScript programs.
  prefs: []
  type: TYPE_NORMAL
- en: The key architectural choice is that Node.js is event-driven, rather than multithreaded.
    The Node.js architecture rests on dispatching blocking operations to a single-threaded
    event loop, with results arriving back to the caller as an event that invokes
    an event handler function. In most cases, the event is converted into a promise
    that is handled by an `async` function. Because Node.js is based on Chrome's V8
    JavaScript engine, the performance and feature improvements implemented in Chrome
    quickly flow through to the Node.js platform.
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js core modules are general enough to implement any sort of server
    that is executing any TCP or UDP protocol, whether it's a **D****omain Name System** (**DNS**),
    HTTP, **internet relay chat** (**IRC**), or FTP. While it supports the development
    of internet servers or clients, its biggest use case is regular website development,
    in place of technology such as an Apache/PHP or Rails stack, or to complement
    existing websites—for example, adding real-time chat or monitoring existing websites
    can easily be done with the Socket.IO library for Node.js. Its lightweight, high-performance
    nature often sees Node.js used as a **glue** service.
  prefs: []
  type: TYPE_NORMAL
- en: A particularly intriguing combination is the deployment of small services on
    modern cloud infrastructure using tools such as Docker and Kubernetes, or function-as-a-service
    platforms, such as AWS Lambda. Node.js works well when dividing a large application
    into easily deployable microservices at scale.
  prefs: []
  type: TYPE_NORMAL
- en: With a high-level understanding of Node.js under our belt, let's dig a little
    deeper.
  prefs: []
  type: TYPE_NORMAL
- en: The capabilities of Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js is a platform for writing JavaScript applications outside web browsers.
    This is not the JavaScript environment we are familiar with in web browsers! While
    Node.js executes the same JavaScript language that we use in browsers, it doesn't
    have some of the features associated with the browser. For example, there is no
    HTML DOM built into Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond its native ability to execute JavaScript, the built-in modules provide
    capabilities of the following sort:'
  prefs: []
  type: TYPE_NORMAL
- en: Command-line tools (in shell script style)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interactive-terminal style of program—that is, a **read-eval-print loop**
    (**REPL**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Excellent process control functions to oversee child processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A buffer object to deal with binary data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP or UDP sockets with comprehensive, event-driven callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DNS lookup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An HTTP, HTTPS, and HTTP/2-client server layered on top of the TCP library filesystem
    access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in rudimentary unit testing support through assertions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The network layer of Node.js is low level while being simple to use—for example,
    the HTTP modules allow you to write an HTTP server (or client) using a few lines
    of code. This is powerful, but it puts you, the programmer, very close to the
    protocol requests and makes you implement precisely those HTTP headers that you
    should return in request responses.
  prefs: []
  type: TYPE_NORMAL
- en: Typical web-application developers don't need to work at a low level of the
    HTTP or other protocols; instead, we tend to be more productive working with higher-level
    interfaces—for example, PHP coders assume that Apache/Nginx/and so on are already
    there providing the HTTP, and that they don't have to implement the HTTP server
    portion of the stack. By contrast, a Node.js programmer does implement an HTTP
    server, to which their application code is attached.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the situation, the Node.js community has several web application
    frameworks, such as Express, providing the higher-level interfaces required by
    typical programmers. You can quickly configure an HTTP server with baked-in capabilities,
    such as sessions, cookies, serving static files, and logging, letting developers
    focus on their business logic. Other frameworks provide OAuth 2 support or focus
    on REST APIs, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The community of folks using Node.js has built an amazing variety of things
    on this foundation.
  prefs: []
  type: TYPE_NORMAL
- en: What are folks doing with Node.js?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Node.js is not limited to web service application development; the community
    around Node.js has taken it in many other directions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build tools**: Node.js has become a popular choice for developing command-line
    tools that are used in software development or communicating with service infrastructure.
    Grunt, Gulp, and Webpack are widely used by frontend developers to build assets
    for websites. Babel is widely used for transpiling modern ES-2016 code to run
    on older browsers. Popular CSS optimizers and processors, such as PostCSS, are
    written in Node.js. static website generation systems, such as Metalsmith, Punch,
    and AkashaCMS, run at the command line, and generate website content that you
    upload to a web server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web UI testing**: Puppeteer gives you control over a headless Chrome web-browser
    instance. With it, you can develop Node.js scripts by controlling a modern, full-featured
    web browser. Some typical use cases are web scraping and web application testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Desktop applications**: Both Electron and **node-webkit** (**NW.js**) are
    frameworks for developing desktop applications for Windows, macOS, and Linux.
    These frameworks utilize a large chunk of Chrome, wrapped by Node.js libraries,
    to develop desktop applications using web UI technologies. Applications are written
    with modern HTML5, CSS3, and JavaScript, and can utilize leading-edge web frameworks,
    such as Bootstrap, React, VueJS, and AngularJS. Many popular applications have
    been built using Electron, including the Slack desktop client application, the
    Atom, Microsoft Visual Code programming editors, the Postman REST client, the
    GitKraken GIT client, and Etcher, which makes it incredibly easy to burn OS images
    to flash drives to run on single-board computers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mobile applications**: The Node.js for Mobile Systems project lets you develop
    smartphone or tablet computer applications using Node.js for both iOS and Android.
    Apple''s App Store rules preclude incorporating a JavaScript engine with JIT capabilities,
    meaning that normal Node.js cannot be used in an iOS application. For iOS application
    development, the project uses Node.js-on-ChakraCore to skirt around the App Store
    rules. For Android application development, the project uses regular Node.js on
    Android. At the time of writing, the project is in an early stage of development,
    but it looks promising.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internet of things** (**IoT**): Node.js is a very popular language for Internet-of-Things
    projects, and Node.js runs on most ARM-based, single-board computers. The clearest
    example is the NodeRED project. It offers a graphical programming environment,
    letting you draw programs by connecting blocks together. It features hardware-oriented
    input and output mechanisms—for example, to interact with **General Purpose I/O**
    (**GPIO**) pins on Raspberry Pi or Beaglebone single-board computers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may already be using Node.js applications without realizing it! JavaScript
    has a place outside the web browser, and it's not just thanks to Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quit scratching your head, already! Of course, you're doing it, scratching your head
    and mumbling to yourself, "What's a browser language doing on the server?" In
    truth, JavaScript has a long and largely unknown history outside the browser.
    JavaScript is a programming language, just like any other language, and the better
    question to ask is "Why should JavaScript remain trapped inside web browsers?"
  prefs: []
  type: TYPE_NORMAL
- en: Back in the dawn of the web age, the tools for writing web applications were
    at a fledgling stage. Some developers were experimenting with Perl or TCL to write
    CGI scripts, and the PHP and Java languages had just been developed. Even then,
    JavaScript saw use on the server side. One early web application server was Netscape's
    LiveWire server, which used JavaScript. Some versions of Microsoft's ASP used
    JScript, their version of JavaScript. A more recent server-side JavaScript project
    is the RingoJS application framework in the Java universe. Java 6 and Java 7 were
    both shipped with the Rhino JavaScript engine. In Java 8, Rhino was dropped in
    favor of the newer Nashorn JavaScript engine.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, JavaScript outside the browser is not a new thing, even if it
    is uncommon.
  prefs: []
  type: TYPE_NORMAL
- en: You have learned that Node.js is a platform for writing JavaScript applications
    outside of web browsers. The Node.js community uses this platform for a huge array
    of application types, far more than was originally conceived for the platform.
    This proves that Node.js is popular, but we must still consider the technical
    rationale for using it.
  prefs: []
  type: TYPE_NORMAL
- en: Why should you use Node.js?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of the many available web-application development platforms, why should you
    choose Node.js? There are many stacks to choose from; what is it about Node.js
    that makes it rise above the others? We will learn the answer to this in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Popularity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js is quickly becoming a popular development platform, and is being adopted
    by plenty of big and small players. One of these players is PayPal, who are replacing
    their incumbent Java-based system with one written in Node.js. Other large Node.js
    adopters include Walmart's online e-commerce platform, LinkedIn, and eBay.
  prefs: []
  type: TYPE_NORMAL
- en: For PayPal's blog post about this, visit [https://www.paypal-engineering.com/2013/11/22/node-js-at-paypal/](https://www.paypal-engineering.com/2013/11/22/node-js-at-paypal/).
  prefs: []
  type: TYPE_NORMAL
- en: According to NodeSource, Node.js usage is growing rapidly (for more information,
    visit [https://nodesource.com/node-by-numbers](https://nodesource.com/node-by-numbers)). The
    evidence for this growth includes increasing bandwidth for downloading Node.js
    releases, increasing activity in Node.js-related GitHub projects, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Interest in JavaScript itself remains very strong but has been at a plateau
    for years, measured in search volume (Google Insights) and its use as a programming
    skill (Dice Skills Center). Node.js interest has been growing rapidly, but is
    showing signs of plateauing.
  prefs: []
  type: TYPE_NORMAL
- en: For more on this, see [https://itnext.io/choosing-typescript-vs-javascript-technology-popularity-ea978afd6b5f](https://itnext.io/choosing-typescript-vs-javascript-technology-popularity-ea978afd6b5f) or [http://bit.ly/2q5cu0w](http://bit.ly/2q5cu0w).
  prefs: []
  type: TYPE_NORMAL
- en: It's best to not just follow the crowd because there are different crowds, and
    each one claims that their software platform does cool things. Node.js does some
    cool things, but what is more important is its technical merit.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript everywhere
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having the same programming language on the server and client has been a long-time
    dream on the web. This dream dates back to the early days of Java, where Java
    applets in the browser were to be the frontend to server applications written
    in Java, and JavaScript was originally envisioned as a lightweight scripting language
    for those applets. Java never fulfilled its hype as a client-side programming
    language, and even the phrase "Java Applets" is fading into a dim memory of the
    abandoned client-side application model. We ended up with JavaScript as the principle
    in-browser, client-side language, rather than Java. Typically, the frontend JavaScript
    developers were in a different language universe than the server-side team, which
    was likely to be coding in PHP, Java, Ruby, or Python.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, in-browser JavaScript engines became incredibly powerful, letting
    us write ever-more-complex browser-side applications. With Node.js, we are finally
    able to implement applications with the same programming language on the client
    and server by having JavaScript at both ends of the web, in the browser and server.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common language for frontend and backend offers several potential benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: The same programming staff can work on both ends of the wire.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code can be migrated between the server and client more easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common data formats (JSON) between the server and client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common software tools exist for the server and client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common testing or quality-reporting tools for the server and client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When writing web applications, view templates can be used on both sides.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JavaScript language is very popular because of its ubiquity in web browsers.
    It compares favorably with other languages while having many modern, advanced
    language concepts. Thanks to its popularity, there is a deep talent pool of experienced
    JavaScript programmers out there.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging Google's investment in V8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make Chrome a popular and excellent web browser, Google invested in making
    V8 a super-fast JavaScript engine. Google, therefore, has a huge motivation to
    keep on improving V8. V8 is the JavaScript engine for Chrome, and it can also
    be executed in a standalone manner.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js is built on top of the V8 JavaScript engine, letting it take advantage
    of all that work on V8\. As a result, Node.js was able to quickly adopt new JavaScript
    language features as they were implemented by V8 and reap performance wins for
    the same reason.
  prefs: []
  type: TYPE_NORMAL
- en: Leaner, asynchronous, event-driven model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Node.js architecture, built on a single execution thread, with an ingenious
    event-oriented, asynchronous-programming model, and a fast JavaScript engine,
    is claimed to have less overhead than thread-based architectures. Other systems
    using threads for concurrency tend to have memory overhead and complexity, which
    Node.js does not have. We'll get into this more later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A new sensation in software development is the idea of the microservice. Microservices
    are focused on splitting a large web application into small, tightly-focused services
    that can be easily developed by small teams. While they aren't exactly a new idea—they're
    more of a reframing of old client–server computing models—the microservice pattern
    fits well with agile project-management techniques, and gives us a more granular
    application deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js is an excellent platform for implementing microservices. We'll get into
    this later.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js is stronger after a major schism and hostile fork
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During 2014 and 2015, the Node.js community faced a major split over policy,
    direction, and control. The **io.js** project was a hostile fork driven by a group
    that wanted to incorporate several features and change who was in the decision-making
    process. The end result was a merge of the Node.js and io.js repositories, an
    independent Node.js foundation to run the show, and the community working together
    to move forward in a common direction.
  prefs: []
  type: TYPE_NORMAL
- en: A concrete result of healing that rift is the rapid adoption of new ECMAScript language
    features. The V8 engine is adopting these new features quickly to advance the
    state of web development. The Node.js team, in turn, is adopting these features
    as quickly as they show up in V8, meaning that promises and `async` functions
    are quickly becoming a reality for Node.js programmers.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that the Node.js community not only survived the io.js fork
    and the later ayo.js fork, but the community and the platform it nurtured grew
    stronger as a result.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have learned several reasons to use Node.js. Not only is
    it a popular platform, with a strong community behind it, but there are also serious
    technical reasons to use it. Its architecture has some key technical benefits,
    so let's take a deeper look at these.
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js event-driven architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Node.js''s blistering performance is said to be because of its asynchronous
    event-driven architecture and its use of the V8 JavaScript engine. This enables
    it to handle multiple tasks concurrently, such as juggling between requests from
    multiple web browsers. The original creator of Node.js, Ryan Dahl, followed these
    key points:'
  prefs: []
  type: TYPE_NORMAL
- en: A single-thread, event-driven programming model is simpler to code and has less
    complexity and less overhead than application servers that rely on threads to
    handle multiple concurrent tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By converting blocking function calls into asynchronous code execution, you
    can configure the systems so that it issues an event when the blocking request
    is satisfied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can leverage the V8 JavaScript engine from the Chrome browser, and all the
    work goes into improving V8; all the performance enhancements going into V8, therefore,
    benefits Node.js.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most application servers, concurrency, or the ability to handle multiple
    concurrent requests, is implemented with a multithreaded architecture. In such
    a system, any request for data, or any other blocking function call, causes the
    current execution thread to suspend and wait for the result. Handling concurrent
    requests requires there to be multiple execution threads. When one thread is suspended,
    another thread can execute. This causes churn as the application server starts
    and stops the threads to handle requests. Each suspended thread (typically waiting
    on an input/output operation to finish) consumes a full call stack of memory,
    adding to overhead. Threads add complexity to the application server as well as server
    overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help us wrap our heads around why this would be, Ryan Dahl, the creator
    of Node.js, offered the following example. In his Cinco de NodeJS presentation
    in May 2010 ([https://www.youtube.com/watch?v=M-sc73Y-zQA](https://www.youtube.com/watch?v=M-sc73Y-zQA))
    Dahl asked us what happens when we execute a line of code such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: The programmer supplies a function that is called (hence the name *callback
    function*) when the result (or error) is available. The `query` function still
    takes the same amount of time. Instead of blocking the execution thread, it returns
    to the event loop, which is then free to handle other requests. The Node.js will
    eventually fire an event that causes this callback function to be called with
    the result or error indication.
  prefs: []
  type: TYPE_NORMAL
- en: A similar paradigm is used in client-side JavaScript, where we write event handler
    functions all the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advances in the JavaScript language have given us new options. When used with
    ES2015 promises, the equivalent code would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: Other than the `async` and `await` keywords, this looks like code we'd write
    in other languages, and is much easier to read. Because of what `await` does,
    it is still asynchronous code execution.
  prefs: []
  type: TYPE_NORMAL
- en: All three of these code snippets perform the same query that we wrote earlier.
    Instead of `query` being a blocking function call, it is asynchronous and does
    not block the execution thread.
  prefs: []
  type: TYPE_NORMAL
- en: With both the callback functions and the promise's asynchronous coding, Node.js
    had its own complexity issue. Oftentimes, we call one asynchronous function after
    another. With callback functions, that meant deeply nested callback functions,
    and with promises, that meant a long chain of `.then` handler functions. In addition
    to the complexity of the coding, we have errors and results landing in unnatural
    places. Instead of landing on the next line of code, the asynchronously executed
    callback function is invoked. The order of execution is not one line after another,
    as it is in synchronous programming languages; instead, the order of execution
    is determined by the order of the callback function execution.
  prefs: []
  type: TYPE_NORMAL
- en: The `async` function approach solves that coding complexity. The coding style
    is more natural since the results and errors land in the natural place, at the
    next line of code. The `await` keyword integrates asynchronous result handling
    without blocking the execution thread. A lot is buried under the covers of the
    `async/await` feature, and we'll be covering this model extensively throughout
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: But does the asynchronous architecture of Node.js actually improve performance?
  prefs: []
  type: TYPE_NORMAL
- en: Performance and utilization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some of the excitement over Node.js is due to its throughput (the requests per
    second that it can serve). Comparative benchmarks of similar applications—for
    example, Apache—show that Node.js has tremendous performance gains.
  prefs: []
  type: TYPE_NORMAL
- en: 'One benchmark going around is the following simple HTTP server (borrowed from [https://nodejs.org/en/](https://nodejs.org/en/)),
    which simply returns a `Hello World` message directly from memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a particularly simplistic approach to calculating Fibonacci numbers.
    Yes, there are many ways to calculate Fibonacci numbers more quickly. We are showing
    this as a general example of what happens to Node.js when event handlers are slow
    and not to debate the best ways to calculate mathematical functions. Consider
    the following server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: This is an equally silly way to calculate Fibonacci numbers, but by using `process.nextTick`,
    the event loop has an opportunity to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because this is an asynchronous function that takes a callback function, it
    necessitates a small refactoring of the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: This was an important insight on Ryan Dahl's part, and is what propelled Node.js's
    popularity. Certain actions take a long time to run, such as database queries,
    and should not be treated the same as operations that quickly retrieve data from
    memory. Because of the nature of the JavaScript language, Node.js had to express
    this asynchronous coding construct in an unnatural way. The results do not appear
    at the next line of code, but instead appear within this callback function. Furthermore,
    errors have to be handled in an unnatural way, inside that callback function.
  prefs: []
  type: TYPE_NORMAL
- en: The convention in Node.js is that the first parameter to a callback function
    is an error indicator and the subsequent parameters are the results. This is a
    useful convention that you'll find all across the Node.js landscape; however,
    it complicates working with results and errors because both land in an inconvenient
    location—that callback function. The natural place for errors and results to land
    is on the subsequent line(s) of code.
  prefs: []
  type: TYPE_NORMAL
- en: We descend further into callback hell with each layer of callback function nesting.
    The seventh layer of callback nesting is more complex than the sixth layer of
    callback nesting. Why? If nothing else, it's because the special considerations
    for error handling become ever more complex as callbacks are nested more deeply.
  prefs: []
  type: TYPE_NORMAL
- en: 'But as we saw earlier, this is the new preferred way to write asynchronous
    code in Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '```js\1'
  prefs: []
  type: TYPE_NORMAL
- en: Instead, ES2017 `async` functions return us to this very natural expression
    of programming intent. Results and errors land in the correct location while preserving
    the excellent event-driven asynchronous programming model that made Node.js great.
    We'll see how this works later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The TC-39 committee added many more new features to JavaScript, such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: An improved syntax for class declarations, making object inheritance and getter/setter
    functions very natural.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new module format that is standardized across browsers and Node.js.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New methods for strings, such as the template string notation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New methods for collections and arrays—for example, operations for `map`/`reduce`/`filter`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `const` keyword to define variables that cannot be changed and the `let`
    keyword to define variables whose scope is limited to the block in which they're
    declared, rather than hoisted to the front of the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New looping constructs and an iteration protocol that works with those new loops.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new kind of function, the arrow function, which is lighter in weight, meaning
    less memory and execution time impact.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Promise` object represents a result that is promised to be delivered in
    the future. By themselves, promises can mitigate the callback hell problem, and
    they form part of the basis for `async` functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generator functions are an intriguing way to represent asynchronous iteration
    over a set of values. More importantly, they form the other half of the basis
    for async functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may see the new JavaScript described as ES6 or ES2017\. What's the preferred
    name to describe the version of JavaScript that is being used?
  prefs: []
  type: TYPE_NORMAL
- en: ES1 through ES5 marked various phases of JavaScript's development. ES5 was released
    in 2009 and is widely implemented in modern browsers. Starting with ES6, the TC-39
    committee decided to change the naming convention because of their intention to
    add new language features every year. Therefore, the language version name now
    includes the year—for example, ES2015 was released in 2015, ES2016 was released
    in 2016, and ES2017 was released in 2017.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying ES2015/2016/2017/2018 JavaScript code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The elephant in the room is that often JavaScript developers are unable to use
    the latest features. Frontend JavaScript developers are limited by the deployed
    web browsers and the large number of old browsers in use on machines whose OS
    hasn't been updated for years. Internet Explorer version 6 has fortunately been
    almost completely retired, but there are still plenty of old browsers installed
    on older computers that are still serving a valid role for their owners. Old browsers
    mean old JavaScript implementations, and if we want our code to work, we need
    it to be compatible with old browsers.
  prefs: []
  type: TYPE_NORMAL
- en: One of the uses for Babel and other code-rewriting tools is to deal with this
    issue. Many products must be usable by folks using an old browser. Developers
    can still write their code with the latest JavaScript or TypeScript features,
    then use Babel to rewrite their code so that it runs on the old browser. This
    way, frontend JavaScript programmers can adopt (some of) the new features at the
    cost of a more complex build toolchain and the risk of bugs being introduced by
    the code-rewriting process.
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js world doesn't have this problem. Node.js has rapidly adopted ES2015/2016/2017
    features as quickly as they were implemented in the V8 engine. Starting with Node.js
    8, we were able to freely use `async` functions as a native feature. The new module
    format was first supported in Node.js version 10.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, while frontend JavaScript programmers can argue that they must
    wait a couple of years before adopting ES2015/2016/2017 features, Node.js programmers
    have no need to wait. We can simply use the new features without needing any code-rewriting
    tools, unless our managers insist on supporting older Node.js releases that predate
    the adoption of these features. In that case, it is recommended that you use Babel.
  prefs: []
  type: TYPE_NORMAL
- en: Some advances in the JavaScript world are happening outside the TC-39 community.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript and Node.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The TypeScript language is an interesting offshoot of the JavaScript environment.
    Because JavaScript is increasingly able to be used for complex applications, it
    is increasingly useful for the compiler to help catch programming errors. Enterprise
    programmers in other languages, such as Java, are accustomed to strong type checking
    as a way of preventing certain classes of bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Strong type checking is somewhat anathema to JavaScript programmers, but is
    demonstrably useful. The TypeScript project aims to bring enough rigor from languages
    such as Java and C# while leaving enough of the looseness that makes JavaScript
    so popular. The result is compile-time type checking without the heavy baggage
    carried by programmers in some other languages.
  prefs: []
  type: TYPE_NORMAL
- en: While we won't use TypeScript in this book, its toolchain is very easy to adopt
    in Node.js applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've learned that as the JavaScript language changes, the
    Node.js platform has kept up with those changes.
  prefs: []
  type: TYPE_NORMAL
- en: Developing microservices or maxiservices with Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: New capabilities, such as cloud deployment systems and Docker, make it possible
    to implement a new kind of service architecture. Docker makes it possible to define
    server process configuration in a repeatable container that's easy to deploy by
    the millions into a cloud-hosting system. It lends itself best to small, single-purpose
    service instances that can be connected together to make a complete system. Docker
    isn't the only tool to help simplify cloud deployments; however, its features
    are well attuned to modern application deployment needs.
  prefs: []
  type: TYPE_NORMAL
- en: Some have popularized the microservice concept as a way to describe this kind
    of system. According to the [microservices.io](http://microservices.io/) website,
    a microservice consists of a set of narrowly focused, independently deployable
    services. They contrast this with the monolithic application-deployment pattern
    where every aspect of the system is integrated into one bundle (such as a single
    WAR file for a Java EE app server). The microservice model gives developers much-needed
    flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some advantages of microservices are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Each microservice can be managed by a small team.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each team can work on its own schedule, so long as the service API compatibility
    is maintained.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices can be deployed independently should this be required, such as
    for easier testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's easier to switch technology stack choices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Where does Node.js fit in with this? Its design fits the microservice model
    like a glove:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js encourages small, tightly focused, single-purpose modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These modules are composed into an application by the excellent npm package
    management system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing modules is incredibly simple, whether via the NPM repository or a
    Git URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While an app framework such as Express can be used with large services, it works
    very well for small lightweight services and supports easy, simple deployment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, it's easy to use Node.js in a lean and agile fashion, building large
    or small services depending on your architecture preferences.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You learned a lot in this chapter. Specifically, you saw that JavaScript has
    a life outside web browsers and that Node.js is an excellent programming platform
    with many interesting attributes. While it is a relatively young project, Node.js
    has become very popular and is widely used not just for web applications but for
    command-line developer tools and much more. Because the Node.js platform is based
    on Chrome's V8 JavaScript engine, the project has been able to keep up with the
    rapid improvements to the JavaScript language.
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js architecture consists of asynchronous functions managed by an event
    loop triggering callback functions, rather than using threads and blocking I/O.
    This architecture has claimed performance benefits that seem to offer many benefits,
    including the ability to do more work with less hardware. But we also learned
    that inefficient algorithms can erase any performance benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Our focus in this book is the real-world considerations of developing and deploying
    Node.js applications. We'll cover as many aspects of developing, refining, testing,
    and deploying Node.js applications as we can.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've had this introduction to Node.js, we're ready to dive in and
    start using it. In [Chapter 2](bd2253cb-6a41-4fc5-ae86-cc9632d44da4.xhtml), *Setting
    up Node.js*, we'll go over how to set up a Node.js development environment on
    Mac, Linux, or Windows, and even write some code. So let's get started.
  prefs: []
  type: TYPE_NORMAL
