- en: '*Chapter 9*: Mastering PHP 8 Best Practices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will be introduced to the best practices that are currently
    enforced in PHP 8\. We will cover several significant method signature changes
    and how their new usage continues the general PHP trend of helping you produce
    better code. We will also have a look at how private methods, interfaces, traits,
    and anonymous class usage has changed. Finally, we will discuss important changes
    in how namespaces are parsed.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering the best practices that will be covered in this chapter will not only
    move you toward writing better code, but how to avoid the potential code breaks
    that might arise if you fail to grasp these new practices. In addition, the techniques
    discussed in this chapter will help you write code that's more efficient than
    was possible in the past.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Discovering method signature changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with private methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with interfaces and traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling anonymous class usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding changes in namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To examine and run the code examples provided in this chapter, the minimum
    recommended hardware is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: X86_64-based desktop PC or laptop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 GB free disk space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 GB of RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 500 Kbps or faster internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, you will need to install the following software:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please refer to the *Technical requirements* section of [*Chapter 1*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013),
    *Introducing New PHP 8 OOP Features,* for more information on how to install Docker
    and Docker Compose, as well as how to build the Docker container used to demonstrate
    the code in this book. In this book, we will refer to the directory that you restored
    the sample code in as `/repo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this chapter is located here: [https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices](https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices).
    We will start by examining significant method signature changes.'
  prefs: []
  type: TYPE_NORMAL
- en: Discovering method signature changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several **method signature changes** have been introduced in PHP 8\. Understanding
    these signature changes is important if your code extends any of the classes or
    implements any of the methods described in this section. As long as you are aware
    of these changes, your code will function correctly, resulting in fewer bugs.
  prefs: []
  type: TYPE_NORMAL
- en: The signature changes that were introduced in PHP 8 reflect the updated *best
    practices*. Accordingly, if you write code that uses the correct method signatures,
    you are following these best practices. We will begin our discussion by reviewing
    PHP 8 changes to magic method signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Managing magic method signatures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In PHP 8, the definition and use of **magic methods** has taken a significant
    step toward standardization. This was accomplished by introducing precise magic
    method signatures in the form of strict argument and return data types. As with
    most of the improvements seen in PHP 8, this update was included to prevent the
    misuse of magic methods. The overall result is better code with fewer bugs.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of this enhancement is that if you have code that provides an incorrect
    argument or return value type, an `Error` is thrown. On the other hand, if your
    code does provide the correct argument data type and return value type, or if
    your code does not use argument or return value data types at all, this enhancement
    will have no adverse effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block summarizes the new argument and return value data
    types for magic methods in PHP 8 and above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s have a look at three simple examples that illustrate the impact
    of the magic method signature changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first example involves the `NoTypes` class, which defines `__call()` but
    does not define any data types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example (in the same file as the preceding example) is of the
    `MixedTypes` class, which defines `__invoke()` but uses an `array` data type rather
    than a `mixed` one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the PHP 7 output for the code sample shown in the preceding steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the same code sample but running under PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the two sets of output are identical. The first class shown,
    `NoTypes`, works because no data type hints were defined. Interestingly, the `MixedTypes`
    class works in both PHP 8 and below since the new `mixed` data type is actually
    a union of all types. Accordingly, you are safe to use any specific data type
    in place of `mixed`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our final example, we will define the `WrongType` class. In this class,
    we will define a magic method called `__isset()` using a return data type that
    doesn''t match the PHP 8 requirement. Here, we are using `string`, whereas in
    PHP 8, its return type needs to be `bool`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This example works in PHP 7 because it relies on the fact that the empty string
    is returned in this example if the variable is not set, and is then interpolated
    as a `FALSE` Boolean. Here is the PHP 7 output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 8, however, because magic method signatures are now standardized, the
    example fails, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, PHP 8 strictly enforces its magic method signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: '*Best Practice*: Revise any code that uses magic methods to follow the new
    strict method signatures. For more information on strict magic method signatures,
    go to [https://wiki.php.net/rfc/magic-methods-signature](https://wiki.php.net/rfc/magic-methods-signature).'
  prefs: []
  type: TYPE_NORMAL
- en: You now have an idea of what to look for and how to correct potential code breaks
    involving magic methods. Now, let's have a look at Reflection extension method
    signature changes.
  prefs: []
  type: TYPE_NORMAL
- en: Examining Reflection method signature changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Backward compatible code breaks may occur if your application is using either
    the `invoke()` or `newInstance()` Reflection extension method. In PHP 7 and below,
    all three methods listed next accepted an unlimited number of arguments. However,
    in the method signature, only one argument was listed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ReflectionClass::newInstance($args)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReflectionFunction::invoke($args)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReflectionMethod::invoke($args)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In PHP 8, the method signatures accurately reflect reality in that `$args`
    is preceded by the `variadics` operator. Here are the new method signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ReflectionClass::newInstance(...$args)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReflectionFunction::invoke(...$args)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReflectionMethod::invoke($object, ...$args)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This change will only break your code if you have a custom class that extends
    any of these three classes, and where your custom class also overrides any of
    the three methods listed in the previous bulleted list.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `isBuiltin()` method has been moved from `ReflectionType` to `ReflectionNamedType`.
    This presents a potential code break if you are using `ReflectionType::isBuiltIn()`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's have a look at method signature changes in the PDO extension.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with PDO extension signature changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The PDO extension has two method signature changes that are of importance.
    These changes are needed to address inconsistencies in method calls when different
    **fetch modes** are applied. Here is the new method signature for `PDO::query()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the new signature for `PDOStatement::setFetchMode()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PDO::query()` method signature changes are referenced in the PHP 7.4 to
    PHP 8 migration guide, here: https://www.php.net/manual/en/ migration80.incompatible.php#migration80.incompatible.pdo.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The two new method signatures are much more uniform than the old signatures,
    and they completely cover syntactical differences when you''re using different
    fetch modes. A simple code example that performs `PDO::query()` using two different
    fetch modes illustrates why the method signature needed to be normalized:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by including a configuration file that contains database connection
    parameters. From this, we will create a `PDO` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define a SQL statement and send it so that it can be prepared:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will execute the prepared statement and set the fetch mode to `PDO::FETCH_ASSOC`.
    Notice that when we use this fetch mode, only one argument is provided to the
    `setFetchMode()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will execute the same prepared statement for a second time. This
    time, we will set the fetch mode to `PDO::FETCH_CLASS`. Notice that when we use
    this fetch mode, two arguments are provided to the `setFetchMode()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output in the first query is an associative array. The second query produces
    an `ArrayObject` instance. Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s important to observe that even though the method signatures have changed,
    you can keep your existing code as-is: this *does not* present a backward compatible
    code break!'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's have a look at methods that are declared as `static`.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with newly defined static methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another potentially significant change seen in PHP 8 is that several methods
    are now declared `static`. If you are already using the classes and methods described
    here as direct object instances, then you do not have a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following methods are now declared as static:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tidy::repairString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tidy::repairFile()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XMLReader::open()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XMLReader::xml()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The potential for a code break my occur if you override one of the classes
    mentioned previously. In this case, you *must* declare the overridden method as
    `static`. Here is a simple example that illustrates the potential problem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s define a string that has mismatched `<div>` tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define an anonymous class that extends `tidy`, fixes the string, and
    returns the string with all HTML tags in lowercase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, echo the repaired string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this code example in PHP 7, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the mismatched `<div>` tag has been repaired, and a properly
    formatted HTML document has been produced. You'll also note that all the tags
    are in lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP 8, however, a method signature issue arises, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, in PHP 8, the `repairString()` method is now declared as `static`.
    The method signature for `repairString()` in the anonymous class we defined earlier
    needs to be rewritten, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output (not shown), once rewritten, is the same as the PHP 7 output shown
    earlier. Also, note that the last line can now also be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know about the methods that are newly defined as static, let's
    look at a related topic; that is, the static return type.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the static return type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **static** keyword is used in several contexts in PHP. Its basic uses are
    beyond the scope of this discussion. In this section, we will focus on a new usage
    for `static` as a return data type.
  prefs: []
  type: TYPE_NORMAL
- en: Since `static` is considered a subtype of `self`, it can be used to widen the
    narrower return type of `self`. The `static` keyword cannot be used as a type
    hint, however, as it would violate the *Liskov Substitution Principle*. It would
    also confuse developers as `static` is already used in too many other contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'The following article describes the background discussion that preceded the
    introduction of the static return type: [https://wiki.php.net/rfc/static_return_type](https://wiki.php.net/rfc/static_return_type).
    The following documentation references late static binding: [https://www.php.net/manual/en/language.oop5.late-static-bindings.php](https://www.php.net/manual/en/language.oop5.late-static-bindings.php).
    The *Liskov Substitution Principle* was discussed in [*Chapter 5*](B16992_05_Final_JC_ePub.xhtml#_idTextAnchor104),
    *Discovering Potential OOP Backward-Compatibility Breaks*, in the *Understanding
    expanded PHP 8 variance support* section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common use for this new return data type would be in classes that
    use the **fluent interface**. The latter is a technique whereby an object method
    returns an instance of the current object state, thus allowing a chain of method
    calls to be used in a *fluent* (readable) manner. In the following example, note
    how the object builds a SQL `SELECT` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must define a `Where` class that accepts an unlimited number of arguments
    to form a SQL `WHERE` clause. Note the return data type of `static`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define the main class, `Select`, which provides methods for building
    parts of a SQL `SELECT` statement. Again, notice that the methods shown all return
    the current class instance and have a return data type of `static`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we must define a calling program that provides the values needed to
    build the SQL statement. Note that the `echo` statement uses the fluent interface
    to make programmatically creating the SQL statement much easier to follow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the code example running in PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This example doesn't work in PHP 7, of course, as the `static` keyword is not
    available as a return data type. Next, let's have a look at the extended use of
    the special `::class` constant.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the use of the ::class constant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The special `::class` constant is an extremely useful construct in that it can
    silently expand into a full namespace, plus a classname string. Understanding
    how it is used, as well as how its use has been extended in PHP 8, can save you
    lots of time. Its use can also make your code much more readable, especially if
    you're dealing with lengthy namespaces and class names.
  prefs: []
  type: TYPE_NORMAL
- en: The special `::class` constant is a combination of the **scope resolution operator**
    (`::`) and the `class` keyword. Unlike `::parent`, `::self`, and `::static`, however,
    the `::class` construct can be used outside a class definition. In a sense, the
    `::class` construct is a sort of *magic constant* in that it causes the class
    it's associated with to magically expand into its full namespace, plus class name.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into how its use has been expanded in PHP 8, let's have a look
    at its conventional usage.
  prefs: []
  type: TYPE_NORMAL
- en: Conventional ::class constant usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The special `::class` constant is frequently used in situations where you have
    a lengthy namespace and wish to not only save yourself a lot of unneeded typing,
    but also preserve the readability of your source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this simple example, using the `Php7\Image\Strategy` namespace, we wish
    to create a list of strategy classes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s identify the namespace and set up the autoloader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Before the special `::class` constant was introduced, to produce a list of
    full namespace class names, you had to write it all out as a string, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the special `::class` constant, you can reduce the amount of typing required,
    and you can also make the code more readable, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this code example, we''ll see that the two lists are identical in
    both PHP 7 and PHP 8\. Here''s the PHP 7 output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the special `::class` constant causes class names to be expanded
    into their full namespace, plus class name, at compile time, causing both lists
    to contain identical information.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's have a look at special `::class` constant usage in PHP 8.
  prefs: []
  type: TYPE_NORMAL
- en: Expanded special ::class constant usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In line with other improvements in syntax uniformity seen in PHP 8, it's now
    possible to use the special `::class` constant on active object instances. Although
    the effect is the same as using `get_class()`, it makes sense to use the special
    `::class` constant as part of the general best practice of moving away from procedural
    and toward OOP.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the extended `::class` syntax is used to determine the type
    of error that''s thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When an `Error` or `Exception` is thrown, it''s best practice to make an entry
    in the error log. In this example, which works in both PHP 7 and PHP 8, the class
    name of this `Error` or `Exception` is included in the log message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 8, you can achieve the same result by rewriting the example, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the second block of code, the syntax is more concise and
    avoids the use of a procedural function. We must stress, however, that in this
    example, there is no performance gain.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are aware of changes in special `::class` constant usage, let's
    have a quick look at commas.
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of trailing commas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'PHP has long allowed the use of trailing commas when defining arrays. For example,
    the syntax shown here is not uncommon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'However, doing the same thing in a function or method signature is not allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Although it's not really such a big deal, it's annoying to be able to add a
    trailing comma when defining an array, but not be allowed the same liberty when
    it comes to function or method signatures!
  prefs: []
  type: TYPE_NORMAL
- en: PHP 8 now allows you to use trailing commas in both function and method signatures.
    The new rule also applies to `use()` statements associated with anonymous functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this change, consider the following example. In this example,
    an anonymous function is defined that renders a full name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there''s a comma following the third argument to the anonymous
    function. Here is the output from PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 8, the trailing comma is allowed and the expected output appears, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Although having a trailing comma in function or method definitions is not necessarily
    a best practice, it does make PHP 8 consistent in its overall treatment of trailing
    commas.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's turn our attention to methods that still exist but no longer have
    any use.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about methods that are no longer required
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Primarily as a result of the PHP 8 resource-to-object migration, a number of
    functions and methods are no longer required. They are not deprecated at the time
    of writing, but these functions no longer serve any practical use.
  prefs: []
  type: TYPE_NORMAL
- en: As an analogy, in versions of PHP before PHP 8, you would use `fopen()` to open
    a file handle resource. Once you had finished working on the file, you would normally
    use `fclose()` on the file handle resource to close the connection.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's assume that you are using `SplFileObject` instead of `fopen()`. When
    the work with the file has been completed, you can simply unset the object. This
    accomplishes the same thing as using `fclose()`, making `fclose()` redundant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes functions that exist, and can still be used,
    but no longer have any practical value in PHP 8\. The ones marked with an asterisk
    are also deprecated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 9.1 – Functions that are no longer useful'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.1_B16992.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9.1 – Functions that are no longer useful
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an idea of what major method signature and usage changes have
    been made in PHP 8, let's have a look at the best practices to take into consideration
    when working with interfaces and traits.
  prefs: []
  type: TYPE_NORMAL
- en: Working with interfaces and traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PHP 8 trait implementation has been expanded in several ways. There are
    also several new interfaces that can potentially alter how you work with the DOM
    and DateTime extensions. For the most part, the changes improve the abilities
    of these two extensions. However, as method signatures have changed in some cases,
    you may run into a potential code break. Due to this, it's important to pay close
    attention to the discussion presented in this section to ensure that existing
    and future PHP code remains functional.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's have a look at the new DOM extension interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering new DOM extension interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *cost of living* economic statistic is issued each year by many world governments.
    It depicts how much it costs an average citizen to live year by year. As web technology
    matures, a similar principal has been applied – first to HTML, and now to DOM.
    The **DOM Living Standard** is maintained by the **Web Hypertext Application Technology
    Working Group** (**WHATWG**) ([https://whatwg.org/](https://whatwg.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: The reason why this information is important to PHP developers is that in PHP
    8, the decision was made to move the PHP DOM extension to the DOM Living Standard.
    Accordingly, starting with PHP 8, a series of incremental and continuous changes
    will be applied to this extension in accordance with changes to the living standard.
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, the changes are backward compatible. However, since some
    method signatures change to maintain adherence to the standard, you may experience
    code breaks. The most significant change to the DOM extension in PHP 8 is the
    introduction of two new interfaces. Let's examine these interfaces, and then discuss
    their impact on PHP development.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the new DOMParentNode interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first of the two new interfaces is **DOMParentNode**. The following classes
    implement this interface in PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DOMDocument`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOMElement`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOMDocumentFragment`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the interface definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: It's important to note that there is no *readonly* attribute available to PHP
    developers. However, the interface specification shows the properties as read
    only because they are internally generated and cannot be changed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: There actually was a PHP RFC that was introduced in 2014 that proposed adding
    a *readonly* attribute to class properties. This proposal was withdrawn, however,
    as the same effect can be achieved by defining a constant or simply marking a
    property `private`! For more information on this proposal, see [https://wiki.php.net/rfc/readonly_properties](https://wiki.php.net/rfc/readonly_properties).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the properties and methods of the new `DOMParentNode`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 9.2 – DOMParentNode interface methods and properties'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.2_B16992.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9.2 – DOMParentNode interface methods and properties
  prefs: []
  type: TYPE_NORMAL
- en: The functionality represented by the new interface doesn't add anything new
    to the existing DOM capabilities. Its main purpose is to bring the PHP DOM extension
    in line with the living standard.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another purpose for architecturally renovating the DOM extension in
    the future. In future versions of PHP, the DOM extension will have the capability
    of manipulating an entire branch of the DOM tree. When you issue an `append()`,
    for example, in the future, you will be able to append not only the one node,
    but all its child nodes as well. For more information, see the following RFC:
    [https://wiki.php.net/rfc/dom_living_standard_api](https://wiki.php.net/rfc/dom_living_standard_api).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's have a look at the second new interface.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the new DOMChildNode interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second of the two new interfaces is **DOMChildNode**. The `DOMElement` and
    `DOMCharacterData` classes implement this interface in PHP 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the interface definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table summarizes the methods and properties of `DOMChildNode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 9.3 – DOMChildNode interface methods and properties'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.3_B16992.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9.3 – DOMChildNode interface methods and properties
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the functionality departs slightly from the existing DOM capabilities.
    The most significant departure is `DOMChildNode::remove()`. Before PHP 8, to remove
    a node, you had to access its parent. Assuming that `$topic` is a `DOMElement`
    instance, PHP 7 or earlier code may appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 8, the same code can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Aside from the new methods mentioned in the two tables shown previously, DOM
    functionality remains the same. Now, let's have a look at how moving a child node
    might be rewritten in PHP 8 to take advantage of the new interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: DOM usage example – comparing PHP 7 and PHP 8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To illustrate the use of the new interfaces, let''s have a look at a code example.
    In this section, we will present a block of code that uses the DOM extension to
    move a node that represents `Topic X` from one document to another:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an HTML fragment that contains a set of nested `<div>` tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The second HTML fragment includes topics D, E, and F:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To create `DOMDocument` instances from each of the two fragments, we can make
    a static call; that is, `loadHTMLFile`. Note that this usage is deprecated in
    PHP 7 and has been removed in PHP 8:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can extract `Topic X` into `$topic` and import it into the second
    document as `$new`. Next, retrieve the target node; that is, `content`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is where PHP 7 and PHP 8 start to differ. In PHP 7, to move the node,
    the code must be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in PHP 8, when using the new interfaces, the code has more of an compact.
    To remove the topic in PHP 8, there''s no need to reference the parent node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'For both PHP 7 and PHP 8, we can view the resulting HTML like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Another difference is how to extract the value of the new last child element
    of `$main`. Here''s how it might appear in PHP 7:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the same thing in PHP 8:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'There are slight differences in the output for both code examples. In PHP 7,
    you will see a deprecation notice, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to run the PHP 7 code in PHP 8, a fatal `Error` will be thrown as
    the `loadHTMLFile()` method''s static usage is no longer allowed. Otherwise, if
    we run the pure PHP 8 example, the output will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in either case, `Topic X` was moved from the first and into
    the second HTML fragment.
  prefs: []
  type: TYPE_NORMAL
- en: In future versions of PHP, expect the DOM extension to continue to grow while
    following the living standard for DOM. Also, its usage continues to get easier,
    with more flexibility and efficiency being provided.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's turn our attention to changes in the `DateTime` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Using new DateTime methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with date and time, it's often useful to create `DateTimeImmutable`
    instances. `DateTimeImmutable` objects are the same as `DateTime` objects, except
    that their property values cannot be altered. Knowing how to switch back and forth
    between `DateTime` and `DateTimeImmutable` is a useful technique and can save
    you from many hidden logic errors.
  prefs: []
  type: TYPE_NORMAL
- en: Before we discuss the improvements that were made in PHP 8, let's have a look
    at the potential problem that `DateTimeImmutable` solves.
  prefs: []
  type: TYPE_NORMAL
- en: Use case for DateTimeImmutable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this simple example, an array of three instances will be created representing
    30, 60, and 90 days from today. These will be used to form the basis of a 30-60-90-day
    accounts receivable aging report:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s initialize a few key variables that represent the interval, date
    format, and array to hold the final values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's define a loop that adds the intervals to a `DateTime` instance to
    produce (hopefully!) an array representing days 0, 30, 60, and 90\. Veteran developers
    have most likely already spotted the problem!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, display the set of dates that have been produced:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, which is a complete disaster, is shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the problem is that the `DateTime` class is not immutable. Thus,
    every time we add a `DateInterval`, the original value is altered, resulting in
    the inaccurate dates shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'By making one simple alteration, however, we can correct this problem. Instead
    of originally creating a `DateTime` instance, all we need to do is create a `DateTimeImmutable`
    instance instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'To populate the array with `DateTime` instances, however, we need to convert
    from `DateTimeImmutable` into `DateTime`. In PHP 7.3, the `DateTime::createFromImmutable()`
    method was introduced. Accordingly, when the value is assigned to `$aging`, the
    revised code might appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, you''re stuck with creating a new `DateTime` instance, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'With this one change, the correct output will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: You now know how `DateTimeImmutable` might be used, and you also have an idea
    of how to convert into `DateTime`. You'll be pleased to know that in PHP 8, the
    conversion between the two object types has been made much easier with the introduction
    of the `createFromInterface()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the createFromInterface() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In PHP 8, it's much easier to convert between `DateTime` and `DateTimeImmutable`,
    and back again. A new method called `createFromInterface()` has been added to
    both classes. The method signature simply calls for a `DateTimeInterface` instance,
    which means that instances of either `DateTime` or `DateTimeImmutable` are acceptable
    arguments for this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following brief code example demonstrates how easy it is to convert from
    one type into another in PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s define a `DateTimeImmutable` instance and `echo` its class and
    date:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a `DateTime` instance from `$dti` and add an interval of 90 days,
    displaying its class and current date:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create a `DateTimeImmutable` instance from `$dtt` and display its
    class and date:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of this code example, running in PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we used the same `createFromInterface()` method to create instances.
    Bear in mind, of course, that we are not actually *converting* the class instance
    into another. Instead, we are creating cloned instances, but of a different class
    type.
  prefs: []
  type: TYPE_NORMAL
- en: You now know why you may want `DateTimeImmutable` instead of `DateTime`. You
    also know that in PHP 8, a new method called `createFromInterface()` provides
    a uniform way to create instances of one from the other. Next, we'll have a look
    at how handling traits has been refined in PHP 8.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding PHP 8 trait handling refinements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The implementation of **traits** was first introduced in PHP version 5.4\. Since
    that time, a continuous stream of refinements has been made. PHP 8 continues that
    trend by providing a means to clearly identify which methods are used when multiple
    traits have conflicting methods. Also, in addition to removing inconsistencies
    in visibility declarations, PHP 8 irons out problems in how traits handled (or
    did not handle!) abstract methods.
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, having a complete mastery of the use of traits enables you to
    write code that is both more efficient and easier to maintain. Traits can help
    you avoid producing redundant code. They solve the problem of needing the same
    logic available across namespaces, or across different class inheritance structures.
    The information presented in this section enables you to make proper use of traits
    in code running under PHP 8.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's examine how conflicts between traits are resolved in PHP 8.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving method conflicts between traits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Multiple traits can be used by simply listing the trait names separated by
    commas. A potential problem can arise, however, if two traits define the same
    method. To resolve such conflicts, PHP offers the `as` keyword. In PHP 7 and below,
    to avoid a conflict between two methods of the same name, you could simply rename
    one of the methods. The code to perform the renaming might appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with this approach, however, is that PHP is making a silent assumption:
    `METHOD` is assumed to come from `Trait1`! In its continuing efforts to enforce
    good coding practices, PHP 8 no longer allows this assumption. The solution in
    PHP 8 is to be more specific by using `insteadof` rather than `as`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a trivial example that illustrates this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s define two traits that define the same method, `test()`, but
    return a different result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define an anonymous class that uses both traits and specifies `test()`
    as `otherTest()` to avoid a naming collision:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define a block of code to `echo` the return value of both methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output in PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, PHP 7 silently assumes that we mean to rename `Trait1::test()`
    as `otherTest()`. From the example code, however, it's not at all clear that this
    is the programmer's intention!
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the same code example in PHP 8, we get a different result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Clearly, PHP 8 does not make such silent assumptions as they can easily lead
    to unexpected behavior. In this example, the best practice would be to use the
    scope resolution (`::`) operator. Here is the rewritten code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: If we were to rerun the code in PHP 8, the output would be the same as the output
    shown for PHP 7\. The scope resolution operator affirms that `Trait1` is the source
    trait for the `test()` method, thus avoiding any ambiguity. Now, let's have a
    look at how PHP 8 traits handle abstract method signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Working with trait abstract signature checking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As API developers are well aware, marking a method as `abstract` is how you
    can signal to API users that a method is mandatory, but has yet to be defined.
    This technique allows the API developer to dictate not only the method name, but
    its signature as well.
  prefs: []
  type: TYPE_NORMAL
- en: In PHP 7 and below, however, abstract methods defined in a trait ignored the
    signature, defeating part of the purpose of using an abstract method in the first
    place! When you use a trait with an abstract method in PHP 8, its signature is
    checked against the implementation in the class using the trait.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example works in PHP 7 but fails in PHP 8 as the method signature
    is different:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s declare strict type checking and define a trait with an abstract
    method; that is, `add()`. Note the method signature calls for integer data types
    all around:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define an anonymous class that uses the trait and defines `add()`. Note
    that the data types for the class are `float` all around:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, echo the results of adding `111.111` and `222.222`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of this small code example running in PHP 7 are surprising:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the results, the method signature of the abstract definition
    in the trait is completely ignored! In PHP 8, however, the outcome is much different.
    Here is the code''s output running in PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The preceding PHP 8 output shows us that good coding practices are enforced,
    regardless of the source of the abstract method definition.
  prefs: []
  type: TYPE_NORMAL
- en: The last topic in this section will show you how to handle abstract private
    methods in traits.
  prefs: []
  type: TYPE_NORMAL
- en: Handling private abstract methods in traits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generally, in PHP, you can't enforce control over an **abstract private method**
    in an abstract super class as it will not be inherited. In PHP 8, however, you
    can define an abstract private method in a trait! This can be used as a use-of-code
    enforcement mechanism when you're doing API development where the `using` class
    is required to define a specified private method.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that although you can designate an abstract method as private in
    a PHP 8 trait, trait method visibility can easily be overridden in the class that
    uses the trait. Accordingly, we will not show any code examples in this section
    as the effect of a private abstract trait method is exactly the same as using
    an abstract trait method at other visibility levels.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on trait abstract method handling in PHP 8, have a look
    at this RFC: [https://wiki.php.net/rfc/abstract_trait_method_validation](https://wiki.php.net/rfc/abstract_trait_method_validation).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's have a look at general usage changes in private methods.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with private methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the reasons why developers create a super class is to exert a certain
    degree of control over the method signatures of subclasses. During the parsing
    phase, PHP normally confirms that the method signatures match. This leads to proper
    use of your code by other developers.
  prefs: []
  type: TYPE_NORMAL
- en: In the same vein, it does not make sense to have PHP perform the same rigorous
    method signature check if a method is marked as `private`. The purpose of a private
    method is that it is invisible to the extending class. If you define a method
    of the same name in the extending class, you should be free to define it at will.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this problem, let''s define a class called `Cipher` with a private
    method called `encrypt()`. The `OpenCipher` subclass redefines this method, causing
    a fatal error when running under PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s define a `Cipher` class whose constructor generates random values
    for `$key` and `$salt`. It also defines a public method called `encode()` that
    makes a call to the private `encrypt()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s define a private method called `encrypt()` that produces encrypted
    text using `str_rot13()`. Note that the method is marked as `final`. Although
    this does not make any sense, for the purposes of this illustration, assume that
    this is intended:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s define a brief calling program that creates class instances
    and calls the methods that have been defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the calling program in PHP 7, we''ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that the output from `Cipher` was correctly produced. However,
    a fatal `Error` has been thrown, along with a message stating that we are unable
    to override a `final` method. Theoretically, a private method should be completely
    invisible to the subclass. However, as you can clearly see from the output, this
    is not the case. The method signature of a private method of the `Cipher` superclass
    affects our ability to redefine the same method in the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP 8, however, this paradox has been resolved. Here is the output of the
    same code running in PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding output, the application succeeded, and output
    from both the parent and child classes is being displayed. We can also see a `Warning`,
    informing us that the private methods cannot be marked as `final`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on the background discussion on private method signatures,
    have a look at this documentation reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://wiki.php.net/rfc/inheritance_private_methods](https://wiki.php.net/rfc/inheritance_private_methods).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an idea of how PHP 8 prevents subclasses from seeing private
    methods in the superclass, let's turn our attention to differences in anonymous
    classes in PHP 8.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling anonymous class usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Anonymous classes**, by their very definition, do not have a name. However,
    for the purposes of information, PHP informational functions such as `var_dump()`,
    `var_export()`, `get_class()`, and other classes in the Reflection extension will
    report the anonymous class simply as `class@anonymous`. However, when an anonymous
    class extends another class or implements an interface, it might be of some use
    to have PHP informational functions reflect this fact.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP 8, anonymous classes that extend a class or implement an interface now
    reflect that fact by changing the label that''s assigned to the anonymous class
    to `Xyz@anonymous`, where `Xyz` is the name of the class or interface. If the
    anonymous class implements more than one interface, only the first interface will
    appear. If the anonymous class extends a class and also implements one or more
    interfaces, the name of the class it extends will appear in its label. The following
    table summarizes these possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 9.4 – Anonymous class promotion'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.4_B16992.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9.4 – Anonymous class promotion
  prefs: []
  type: TYPE_NORMAL
- en: 'Bear in mind that PHP can already test the anonymous class to see if it falls
    under a certain line of inheritance. The `instanceof` operator, for example, can
    be used for this purpose. The following example illustrates how to test the anonymous
    class for inheritance, as well as how to view its new name:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we will define a `DirectoryIterator` instance that grabs
    a list of files from the current directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will define an anonymous class that extends `FilterIterator`. In this
    class, we will define the `accept()` method, which produces a Boolean result.
    If the result is `TRUE`, then that item will appear in the final iteration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will produce a list of files that contain `bc_break` in their name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next two lines, we will use `instanceof` to test whether the anonymous
    class implements `OuterIterface`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will simply dump the contents of the anonymous class using `var_dump()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Here is the output running under PHP 8\. We cannot run this example in PHP 7
    as that version lacks the `str_contains()` function!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `instanceof` correctly reports that the anonymous class implements
    `OuterInterface` (because it extends `FilterIterator`, which, in turn, implements
    `OuterInterface`). You can also see that `var_dump()` reports the name of the
    anonymous class as `FilterIterator@anonymous`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an idea of how anonymous class naming has changed in PHP 8,
    let's have a look at changes in namespace handling.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding changes in namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of a **namespace** was introduced in PHP 5.3 as a means of isolating
    hierarchies of classes. Unfortunately, the original algorithm that was used to
    parse namespace names had several flaws. In addition to being overly complicated,
    the way in which namespace and class names were **tokenized** internally was performed
    in an inconsistent manner, leading to unexpected errors.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into the benefits and potential backward compatible breaks, let's
    have a look at how the namespace tokenization process has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering differences in tokenization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tokenization process is an important part of the interpretation process
    and takes place when your PHP code is executed. In the process of producing byte
    code, the PHP program code is broken down into tokens by the PHP parsing engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes namespace tokenization changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 9.5 – Namespace tokenization differences in PHP 8'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.5_B16992.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9.5 – Namespace tokenization differences in PHP 8
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, PHP 8 namespace tokenization is much simpler and streamlined.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on parser tokens, have a look at the following documentation
    reference: [https://www.php.net/manual/en/tokens](https://www.php.net/manual/en/tokens).'
  prefs: []
  type: TYPE_NORMAL
- en: The impact of this change produces extremely positive results. For one, you
    can now use reserved key words as part of a namespace. Also, in the future, as
    new keywords are introduced into the language, PHP will not force you to change
    namespaces in your applications. The new tokenization process also facilitates
    the use of `Attributes` with namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's have a look at using keywords in a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Using reserved keywords in a namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The namespace tokenization process in PHP 7 produced a series of string (`T_STRING`)
    and backslash (`T_NS_SEPARATOR`) tokens. The problem with this approach is that
    if one of the strings happened to be a PHP keyword, a syntax error was immediately
    thrown during the parsing process. PHP 8, however, produces just a single token,
    as shown earlier, in *Table 9.5*. Ultimately, this means that you can put pretty
    much anything in a namespace and don't have to worry about reserved keyword conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example illustrates the difference in namespace handling
    between PHP 8 and earlier versions. In this example, a PHP keyword is being used
    as part of the namespace. In PHP 7, due to its inaccurate tokenization process,
    `List` is seen as a keyword rather than part of the namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output from PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 8, the program code snippet works as expected, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have an idea of how the tokenization process differs between PHP
    8 and earlier PHP versions, as well as its potential benefits, let's have a look
    at potential backward compatible code breaks.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing bad namespace naming practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The same PHP 8 tokenization process that releases you from having to worry about
    keyword conflicts may also end up exposing bad namespace naming practices. Any
    namespaces with white space in them are now considered invalid. However, it's
    a bad practice to include whitespace in a namespace anyhow!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following simple code example illustrates this principle. In this example,
    you''ll notice that the namespace includes white space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this code in PHP 7, it works OK. Here''s the PHP 7 output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 8, however, a `ParseError` is thrown, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The space serves as a delimiter that's used by the parser during the tokenization
    process. In this code example, PHP 8 assumes that the namespace is `Doesnt`. The
    next token is `\Work`, which marks a fully qualified class name. However, it's
    not expected at this point, which is why an error was thrown.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion on the changes that have been made to namespace
    handling in PHP 8\. You are now in a better position to create namespace names
    in PHP 8 that not only follow best practices, but also take advantage of its independence
    from keyword naming conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP 8, as you learned, is much stricter in terms of how it defines magic methods.
    In this chapter, you learned about method signature changes and how to reduce
    potential bugs by using magic methods properly. You also learned about the method
    signature changes in both the Reflection and PDO extensions. With the knowledge
    you've gained in this chapter, you can avoid potential problems when migrating
    to PHP 8\. In addition, you learned about changes in how static methods can be
    called, as well as a new static return type.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you learned how to make the best use of private methods, as well as how
    to exert greater control over anonymous classes. You also picked up a few tips
    on new syntax possibilities and which methods are now obsolete due to changes
    in the language.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned how to correctly use interfaces and traits to facilitate efficient
    use of your code. You learned about the new interfaces that were introduced to
    bring the DOM extension up to the new DOM Living Standard. In addition, you gained
    insights into using new methods introduced in the DateTime extension.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned how to clean up namespace usage and produce tighter code.
    You now have a better understanding of how the namespace tokenization process
    was inaccurate and how it's been improved in PHP 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapter will present you with something every developer strives for:
    tips, tricks, and techniques to improve performance.'
  prefs: []
  type: TYPE_NORMAL
