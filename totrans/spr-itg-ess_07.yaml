- en: Chapter 7. Integration with Spring Batch
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, a common user deals with web applications, mobile applications, and desktop
    software. All of these are interactive, which means they take user input and respond
    in real time. They might not even be aware of other kinds of applications—applications
    that run in the background, do not need continuous user interaction, and may go
    on for hours, days, or even weeks! Yes, I am talking about the batch job that
    is typically used for offline processing such as file type conversions, reporting,
    data mining, and so on. In the early days, machines were too slow and someone
    had to sit for hours to get a simple job done. In batch processing, you submit
    jobs and then go and do other work—you only come to collect the result! This revolutionized
    the computing world and justified the exorbitantly high prices of equipment and
    programmers. It would not be an exaggeration to say that batch jobs showed the
    real power and usefulness of computers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'If batch jobs are so important, it''s obvious that Spring would have a very
    good support for it. Spring Batch is the module that provides comprehensive support
    for batch processing. In this chapter, we will look into how Spring Integration
    integrates with the Spring Batch module. In sync with the Spring philosophy of
    modular approach, each module works independently and at the same time provides
    the necessary interfaces to be easily integrated with others in the family. Spring
    Integration can interact with the Spring Batch module via messaging and can provide
    an event-driven mechanism to trigger batch jobs. This chapter will cover two aspects:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction to Spring Batch
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Integration and Spring Batch
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Batch
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For a layman, a batch job can be defined as any job that can be run offline.
    Typically, it will be a manual trigger and the result can be collected after the
    expected completion time. If all goes well, then it''s really cool, but let''s
    list some of the challenges:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: What if the external system that is used for a batch job (say an FTP server
    that hosts files) fails?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the machine running a batch job is rebooted for some reason, will the batch
    job also restart?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What if some explicit parameters are required (for example, authentication details
    that might not be eligible for automation)?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will incomplete tasks be tried again or left out?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we deal with transaction and rollback?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we trigger and schedule the job at fixed intervals or in an event-driven
    fashion?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the jobs run in a thread, who will manage resource synchronization?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we deal with the failures? Can the batch job trigger some alarm or send
    out notifications?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a lot of things that need to be accounted for—just imagine the difficulty
    if each of them has to be implemented by the programmer! Do not worry; Spring
    Batch is there to help you. With the help of Spring Integration, even the initial
    triggering part can be programmed—manual interaction is not required at all.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: First of all, Spring Batch is not a scheduling framework like Quartz, Tivoli,
    and others—rather, it leverages these frameworks. It is a very lightweight framework
    that provides reusable components to address most of the concerns raised previously,
    for example, transaction support, database support for recoverable jobs, logging,
    auditing, and so on. Let's start with the configuration step and then we can move
    up to the examples.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can use the Spring Batch module, we need to add namespace support
    and Maven dependencies:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '**Namespace support**: Namespace support can be added by using the following
    code:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Maven entry**: Maven entry support can be added by using the following code:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Defining a Spring Batch job
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The unit of work in a Spring Batch is a *job*, which encapsulates all other
    aspects needed to complete a batch operation. Before we get into the details of
    how to configure and use Spring Batch components, let's familiarize ourselves
    with the basic terms used in a Spring Batch job.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Batch job language
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s familiarize ourselves with the basic domain language of Spring Batch,
    which will help us understand the example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '`Job`: This represents a batch process, and it has one-to-one mapping. For
    each batch process, there will be one job. It can be defined either in XML or
    the Java configuration—I have used the XML approach.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Step`: This is the logical breakdown of a job—a job has one or more steps.
    It encapsulates the phases of a job. A step is the logical unit that contains
    the actual details for running and controlling the batch job. Each job step can
    specify its fault tolerance—for example, skip an item on error, halt the job,
    and so on.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JobInstance`: This is one instance of a job. For example, a job must be run
    once a day, and each day run will be represented by a `JobInstance`.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JobParameter`: This is the parameter that is necessary for a `JobInstance`
    to complete.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JobExcecution`: When a `JobInstance` of a job is triggered, it may complete
    or fail. Each trigger of `JobInstance` is wrapped as `JobExecution`. So, for example,
    if a retry has been set and `JobInstance` is triggered thrice (due to failures)
    before it completes, then there are three instances of `JobExecution`.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StepExecution`: Similar to `JobExecution`, `StepExecution` is an instance
    of a single attempt to run a step. If a step completes after *n* retries, there
    will be *n* instances of `StepExecution`.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExecutionContext`: One of the important aspects of the batch job is the ability
    to restart and reschedule failed jobs; for that, it''s necessary to store enough
    information so that it can be triggered back, similar to a process context at
    the operating systemlevel. `ExecutionContext` is used to address this use case,
    which provides storage of key/value pairs of context-related properties.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JobRepository`: This is the persistence wrapper for all the aforementioned
    units. The underlying database provider can be from one of the many supported
    by Spring Batch.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JobLauncher`: This is an interface that is used to launch a job.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ItemReader`: This is an interface used by the step to read input. If the input
    set has been exhausted, `ItemReader` should indicate this by returning null.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ItemWriter`: This is the output interface of a step—one batch or chunk of
    items at a time.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ItemProcessor`: This is the intermediate state of `ItemReader` and `ItemWriter`.
    It provides the opportunity to apply transformation or business logic to an item.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the preceding introduction, we can understand the Spring Batch example
    a little bit better. So let''s start with one and define a batch job:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is the brief description of the tags used in the preceding configuration:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '`batch:job`: This is the parent tag that starts the definition of the batch
    job. `id` is used to uniquely identify this job, for example, to refer inside
    a `JobLauncher` to launch this job.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`batch:step`: This is one of the steps for this job.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`batch:tasklet`: This is the implementation that does the actual task of the
    step, leaving the step to take care of status maintenance, eventing, and so on.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`batch:chunk`: A `tasklet` can be a simple service or a very complex task,
    while a `chunk` is a logical unit of work that can be worked upon by a `tasklet`.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`batch:listeners`: These are used to propagate the events. We will revisit
    this later in this chapter.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the reader and writer? As the name suggests, reader reads the chunk
    of data while writer writes them back. There are standard readers provided by
    Spring to read a CSV file, but we can provide our own implementation. Let's look
    at a reader and writer used for this example.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: ItemReader
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The components used in the preceding code snippet are explained in the following
    bullet points:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '`itemReader`: This uses Spring''s default flat file reader, whose location
    has been mentioned by the `resource` property. The name will be retrieved from
    the `JobParameter` item passed to the job. We will see how to pass it when we
    write the launcher.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lineMapper`: This is a default implementation from Spring that has been used
    to map a line from the CSV file.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lineTokenizer`: It is very important how each token on a line should be interpreted.
    The value of the property `names` decides the order. For example, in the preceding
    example, it is `name,designation,dept,address`, which means if a sample file has
    an entry like this:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then each chunk will be interpreted as name, designation, department, and address,
    respectively.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '`fieldSetMapper`: Although some default implementations are available, most
    of the time it is a custom class that defines the mapping between the item in
    a CSV file and the domain model. The following is the code snippet of our example
    that uses the mapper:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ItemWriter
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A writer is used to write chunks of data. A writer is almost always user defined.
    It can be defined to write in a file, database, or JMS, or to any endpoint—it
    depends on our implementation. Towards the end of the chapter, we will discuss
    how this can be used to even trigger an event in the Spring Integration environment.
    Let''s first look at a simple writer configuration:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following code snippet is the implementation of the writer class:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For simplicity, I have printed the records, but as mentioned previously, it
    can be populated in the database or it can be used to do whatever we want to do
    inside this class.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so far we have defined the job, the reader, and the writer; then what''s
    stopping us from launching it? How do we launch this batch job? Spring provides
    the `Joblauncher` interface that can be used to launch the job. `Joblauncher`
    needs an interface of the type `JobRepository` to store the context of the job
    so that it can be recovered and restarted on failure. `JobRepository` can be configured
    to leverage any database that Spring can use, for example, in-memory, MySql, PostGres,
    and so on. Let''s define `jobLauncher` as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since `JobLauncher` cannot be used without a `JobRepository`, let''s configure
    `JobRepository`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The properties shown in the preceding code can be configured in a `properties`
    file, let''s say `batch.properties`. We can provide the properties in a class
    path and use the `property-placeholder` tag to inject the properties, as shown
    here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As soon as the database is there, we need transactions! Let''s configure the
    transaction manager:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Thank god, no more configurations! By the way, these are not specific to any
    batch job; any data source and transaction manager configured in the existing
    application can be used. With all these configurations, we are ready to launch
    the batch job. Let''s see the following sample code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s understand the code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '**Load the file**: We first load the configuration file.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extract the reference**: The next step is to retrieve the reference of the
    defined job using its unique ID.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Add parameters**: A job needs a parameter, so we define `JobParameter` using
    the `JobParameterBuilder` class. The name of the file being passed as a value
    of the key is `input.file.name`, which was configured in the job definition.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Launch the job**: Finally, use Spring''s `JobLauncher` class to launch the
    job.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hmm! Now we have a small and simple batch up and running. Let's see how Spring
    Integration can be used to reap its power and enhance the usage even further.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Spring Batch and Spring Integration
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typically, a batch application can be triggered via a command-line interface
    or programmatically, for example, from a web container. Let''s introduce Spring
    Integration and see the possibilities:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: It can be triggered on an event, for example, a file adapter listening for a
    file triggers Spring Integration on arrival of the file.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution can be chained in a flow—trigger the job, pass on the result, invoke
    the error path, and so on.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The message queue is not meant for huge amounts of data. So for big files, Spring
    Integration can act as the trigger, while delegating the actual task to Spring
    Batch. It can provide a strategy to chunk the files and distribute them across
    the Spring Batch job.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Integration not only triggers batch jobs, but can also collect the result
    and propagate it in the system. For example, a batch process triggered by Spring
    Integration may finish off in a day, after which `ItemWriter` can write an item
    to JMS on which the Spring Integration adapter is listening. Even without any
    awareness or locking in for the job started, messages from the queue will be processed
    by Spring Integration.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching the job
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enough theory! Let''s write some code. This time, we will trigger the batch
    job on some event instead of triggering manually. We are processing a file, what
    if we process a file adapter? Let''s write a file adapter that will listen for
    files in a directory and trigger a batch job on the availability of a file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: No need to define the file adapter tags, as they have been taken care of in
    the previous chapter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding configuration will listen for files in the configured directory.
    Files will be put on to `fileOutPutChannel` as `Message<File>`, and we need to
    convert it to a form so that `JobLauncher` can understand it. We will use the
    `transformer` component:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will have to write the logic to convert `Message<File>` to `JobLaunchRequest`.
    The following code is a very simple transformer that extracts the file path from
    the payload of `Message` (which is `File`) and then adds the retrieved path as
    `JobParameter`. This job parameter is then used to launch the job using Spring''s
    `JobLauncher`, as shown in the following code snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With this code in place, whenever a new file arrives in the directory, a batch
    job is triggered using Spring Integration. Moreover, file adapter was just an
    example, any adapter or gateway—such as mail, JMS, FTP, and others—can be plugged
    in to trigger the batch processing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Tracking the status of a batch job
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the time, we would want to have feedback about the task in progress—how
    can we do that? Spring Integration is an event-based framework so no surprise
    that we can configure listeners with a batch job. If you refer to the batch job
    definition at the beginning, it has a listener defined:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This code can have a Spring Integration gateway as a listener, which listens
    for the notification and puts the status of the batch job (of the type `JobExecution`)
    on the defined channel:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The status will be available on a channel where we have our processing done.
    Let''s plug in a simple service activator to print the status:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The other way round
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring Integration can launch the batch job, and Spring Batch can interact
    with the Spring Integration and trigger components. How can we do this? Spring
    Integration''s event-based components can be a good option. Let''s take a simple
    example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: There is an inbound JMS adapter in the Spring Integration application that listens
    for messages on the queue and, based on that, triggers some action.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we invoke this adapter from Spring Batch? We can define a custom `ItemWriter`
    class in Spring Batch that writes its output to the JMS queue where the Spring
    Integration component is listening.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As soon as `ItemWriter` writes to the JMS queue, the inbound adapter picks it
    up and passes it down the line for further processing.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding use case is just one example; we can gel the eventing mechanism
    of both the frameworks and achieve the required inter-app communication.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This completes our discussion on how Spring Integration and Spring Batch can
    intercommunicate. We covered the basics of Spring Batch, how it can be leveraged
    by Spring Integration to delegate the processing of huge payloads, how status
    can be tracked, and then in turn how Spring Batch can trigger events and start
    processing in the Spring Integration application!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对Spring Integration和Spring Batch如何相互通信的讨论。我们涵盖了Spring Batch的基础知识，以及它如何被Spring
    Integration利用来委托处理大量数据，如何跟踪状态，然后Spring Batch如何触发事件并在Spring Integration应用程序中开始处理！
- en: In the next chapter, we will discuss one of the most important aspects—testing.
    Keep up the energy!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论最重要的一个方面——测试。保持精力充沛！
