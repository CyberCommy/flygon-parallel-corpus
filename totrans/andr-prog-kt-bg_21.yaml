- en: Chapter 21. Threads and Starting the Live Drawing App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will get started on our next app. This app will be a kid's-style
    drawing app where the user can draw on the screen using their finger. The drawing
    app that we create will be slightly different, however. The lines that the user
    draws will be comprised of particle systems that explode into thousands of pieces.
    We will call the project *Live Drawing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the Live Drawing app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about real-time interaction, sometimes referred to as a **game loop**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about **threads**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding a real-time system that is ready to draw in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Live Drawing project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started, create a new project in Android Studio and call it `Live Drawing`.
    Use the **Empty Activity** project and leave the rest of the settings at their
    defaults.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the two drawing apps from the previous chapter, this app consists
    of Kotlin files only, and no layout files. The Kotlin files and all the code up
    to the end of this chapter can all be found in the `Chapter21` folder of the download
    bundle. The complete project can be found in the `Chapter22` folder of the download
    bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will create empty classes that we will code throughout the project
    over the next two chapters. Create a new class called `LiveDrawingView`, a new
    class called `ParticleSystem,` and a new class called `Particle`.
  prefs: []
  type: TYPE_NORMAL
- en: Looking ahead at the Live Drawing app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As this app is more in-depth and needs to respond in real time, it is necessary
    to use a slightly more in-depth structure. At first, this may seem like a complication,
    but in the long run, it will make our code simpler and easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have four classes in the Live Drawing app, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MainActivity`: The `Activity` class provided by the Android API is the class
    that interacts with the **operating system** (**OS**). We have already seen how
    the OS interacts with `onCreate` when the player clicks on the app icon to start
    an app. Rather than have the `MainActivity` class that does everything, this `Activity`-based
    class will just handle the startup and shutdown of our app, and offer some assistance
    with initialization by calculating the screen resolution. It makes sense that
    this class will be of the `Activity` type and not `AppCompatActivity`. However,
    as you will soon see, we will delegate interaction through touches to another
    class, that is, the same class that will also handle almost every aspect of the
    app. This will introduce us to a number of new and interesting concepts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LiveDrawingView`: This is the class that will be responsible for doing the
    drawing and creating the real-time environment that allows the user to interact
    at the same time as their creations are moving and evolving.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ParticleSystem`: This is the class that will manage up to thousands of instances
    of the `Particle` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Particle`: This class will be the simplest of them all; it will have a location
    on screen and a heading. It will update itself about 60 times per second when
    prompted to by the `LiveDrawingView` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we can start coding.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the MainActivity class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get started with coding the `Activity`-based class. As usual, the class
    is called `MainActivity`, and it was autogenerated for us when we created the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the class declaration and add the first part of the code for the `MainActivity`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows several errors that we will talk about shortly. The
    first thing to note is that we are declaring an instance of our `LiveDrawingView`
    class. Currently, this is an empty class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The next code gets the number of pixels (horizontally and vertically) for the
    device in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We create an object of the `Display` type, called `display`, and initialize
    it with `windowManager.defaultDisplay`, which is part of the `Activity` class.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create a new object, called `size`, of the `Point` type. We send `size`
    as an argument to the `display.getSize` function. The `Point` type has an `x`
    and `y` property and, therefore, so does the `size` object, which, after the third
    line of code, now holds the width and height (in pixels) of the display. Now,
    we have the screen resolution in the `x` and `y` properties tucked away in the
    `size` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in `onCreate`, we initialize `liveDrawingView` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: What we are doing is passing two arguments to the `LiveDrawingView` constructor.
    We have obviously not coded a constructor yet and, as we know, the default constructor
    takes zero arguments. Therefore, this line will cause an error until we fix this.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments that are passed in are interesting. First, `this`, which is a
    reference to `MainActivity`. The `LiveDrawingView` class will need to perform
    actions (use some functions) that it needs this reference for.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument is the horizontal screen resolution. It makes sense that
    our app will need these to perform tasks, such as scaling the other drawing objects
    to an appropriate size. We will discuss these arguments further when we get to
    coding the `LiveDrawingView` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, take a look at the even stranger line that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is where, in the Canvas Demo app, we set `ImageView` as the content for
    the app. Remember that the `Activity` class's `setContentView` function must take
    a `View` object, and `ImageView` is a `View` object. This preceding line of code
    seems to be suggesting that we will use our `LiveDrawingView` class as the visible
    content for the app? But `LiveDrawingView`, despite its name, isn't a `View` object.
    That is, at least not yet.
  prefs: []
  type: TYPE_NORMAL
- en: We will fix the constructor and the not-a-`View` problem after we add a few
    more lines of code to `MainActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these two overridden functions and then we will talk about them. Add them
    underneath the closing curly brace of `onCreate`, but before the closing curl
    `MainActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: What we have done here is override two more of the functions of the `Activity`
    class. We will see why we need to do this and what we will do inside these functions.
    The point to note is that by adding these overridden functions, we are giving
    the OS the opportunity to notify us of the user's intentions in two more situations,
    in the same way as we did when saving and loading our data in the Note to self
    app.
  prefs: []
  type: TYPE_NORMAL
- en: It makes sense at this point to move on to the `LiveDrawingView` class, which
    is the most significant class of this app. We will `MainActivity` toward the end
    of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the LiveDrawingView class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we will do is solve the problem of our `LiveDrawingView` class
    not being of the `View` type and having the wrong constructor. Update the class
    declaration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You will be prompted to import the `android.view.SurfaceView` class, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding the LiveDrawingView class](img/B12806_21_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on **OK** to confirm.
  prefs: []
  type: TYPE_NORMAL
- en: '`SurfaceView` is a descendant of `View` and now `LiveDrawingView` is, by inheritance,
    also a type of `View`. Look at the `import` statement that has been added. This
    relationship is made clear, as highlighted in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that it is because of polymorphism that we can send descendants of
    `View` to the `setContentView` function in the `MainActivity` class, and that
    it is because of inheritance that `LiveDrawingView` is now a type of `SurfaceView`.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few descendants of `View` that we could have extended to fix
    this initial problem, but we will see as we continue that `SurfaceView` has some
    very specific features that are perfect for real-time interactive apps and make
    this the right choice for us. We have also provided a constructor that matches
    the arguments called from `MainActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To import the `Context` class, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Place the mouse cursor on the red-colored `Context` text in the new constructor's
    signature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hold the *Alt* key and tap the *Enter* key. Choose **Import Class** from the
    pop-up options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The previous steps will import the `Context` class. Now, we have no errors in
    our `LiveDrawingView` class or the `MainActivity` class that initializes it.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, we could run the app and see that using `LiveDrawingView` as
    the `View` argument in `setContentView` has worked and that we have a beautiful
    blank screen, which is ready to draw our particle systems on. You can try this
    if you wish to, but we will be coding the `LiveDrawingView` class so that it does
    something next.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that `LiveDrawingView` cannot see the variables in `MainActivity`.
    By using the constructor, `MainActivity` is providing `LiveDrawingView` with a
    reference to itself (`this`) as well as the screen resolution in pixels contained
    in `size.x`.
  prefs: []
  type: TYPE_NORMAL
- en: We will be returning to this class constantly over the course of this project.
    What we will do right now is get the fundamentals set up ready to add the `ParticleSystem`
    instances after we have coded them in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we will first add a number of properties. Following this, we
    will get to code the `draw` function, which will reveal the new steps that we
    need to take to draw on the screen 60 times per second. Additionally, we will
    see some familiar code that uses our old friends, `Canvas`, `Paint`, and `drawText`,
    from the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we will need to discuss some more theory; items such as how we
    will time the animations of the particles, and how we can lock these timings without
    interfering with the smooth running of Android. These last two topics, that is,
    the **game loop** and **threads,** will then allow us to add the final code of
    the chapter and witness our particle system painting app in action, albeit with
    just a bit of text.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A game loop is a concept that describes allowing virtual systems to update and
    draw themselves at the same time as allowing them to be altered and interacted
    with by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the properties after the `LiveDrawingView` declaration and constructor
    that we have coded, as demonstrated in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you study the code, and then we will talk about it. Notice that
    all the properties are declared `private`. You can happily delete all the `private`
    access specifiers and the code will still work but, as we have no need to access
    any of these properties from outside of this class, it is sensible to guarantee
    that this can never happen by declaring them `private`.
  prefs: []
  type: TYPE_NORMAL
- en: The first property is `debugging`. We will use this so that we can manually
    switch between printing debugging information and not printing debugging information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two classes that we declared instances of will handle the drawing
    on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following two properties will give us a bit of insight into what we need
    to achieve our smooth and consistent animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Both properties are of the `long` type because they will be holding a large
    number that we will use to measure time. Computers measure time based on the number
    of milliseconds since 1970\. We will discuss this more when we learn about the
    game loop; however, for now, we need to know that monitoring and measuring the
    speed of each frame of animation is how we will make sure that the particles move
    exactly as they should.
  prefs: []
  type: TYPE_NORMAL
- en: The first variable, `fps`, will be reinitialized in every frame of animation
    at approximately 60 times per second. It will be passed into each of the `ParticleSystem`
    objects (every frame of animation) so that they know how much time has elapsed,
    and can then calculate how far to move or not.
  prefs: []
  type: TYPE_NORMAL
- en: The `millisInSecond` variable is initialized to `1000`. There are indeed `1000`
    milliseconds in a second. We will use this variable in calculations as it will
    make our code clearer than if we used the literal value, 1,000\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part of the code that we just added is shown here for convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `fontSize` and `marginSize` properties will be initialized, based on the
    screen resolution in pixels that were passed in through the constructor (`screenX`).
    They will hold a value in pixels to make the formatting of our text neat and more
    concise, rather than constantly doing calculations for each bit of text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, we should make clear that these are the `import` statements
    that you should currently have at the top of the `LiveDrawingView.kt` code file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's get ready to draw.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the draw function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the `draw` function immediately after the properties that we just added.
    There will be a couple of errors in the code. We will deal with them first, and
    then we will go into detail about how the `draw` function will work in relation
    to `SurfaceView` because there are a number of alien-looking lines of code in
    there, as well as some familiar ones. Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two errors – one error is that the `Color` class needs importing. You
    can fix this in the usual way or add the next line of code manually. Whatever
    method you choose, the following extra line needs to be added to the code at the
    top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let's now deal with the other error.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the printDebuggingText function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second error is the call to `printDebuggingText`. The function doesn''t
    exist yet; so, let''s add that now. Add the code after the `draw` function, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The previous code uses the local `debugSize` variable to hold a value that is
    half that of the `fontSize` property. This means that as `fontSize` (which is
    used for the **HUD**) is initialized dynamically based on the screen resolution,
    `debugSize` will always be half of that.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HUD stands for Heads Up Display and is a fancy way of referring to the buttons
    and text that overlays the other objects in the app.
  prefs: []
  type: TYPE_NORMAL
- en: The `debugSize` variable is then used to set the size of the font before we
    start drawing the text. The `debugStart` variable is a guess at a tidy vertical
    position to start printing the debugging text with a bit of padding so that it
    isn't squashed too close to the edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: These two values are then used to position a line of text on the screen that
    shows the current frames per second. As this function is called from `draw`, which,
    in turn, will be called from the game loop, this line of text will be constantly
    refreshed up to 60 times per second.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible that on very high- or very low-resolution screens, you might
    need to experiment with this value to find something that works for your screen.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore these new lines of code in the `draw` function and examine exactly
    how we can use `SurfaceView`, from which our `LiveDrawingView` class is derived,
    to handle all our drawing requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the draw function and the SurfaceView class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting in the middle of the function and working outward for a change, we
    have a few familiar things, such as the calls to `drawColor`, and then we set
    the color and text size as we have before. We can also see the comment that indicates
    where we will eventually add the code to draw the particle systems and the HUD:'
  prefs: []
  type: TYPE_NORMAL
- en: The `drawColor` code clears the screen with a solid color.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `textSize` property of `paint` sets the size of the text for drawing the
    HUD.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will code the process of drawing the HUD once we have explored particle systems
    a little more. We will let the player know how many particles and systems their
    drawing is comprised of.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What is completely new, however, is the code at the very start of the `draw`
    function, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `if` condition is `holder.surface.isValid`. If this line returns true, it
    confirms that the area of memory that we want to manipulate to represent our frame
    of drawing is available, and then the code continues inside the `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: This is necessary because all our drawing and other processing (such as moving
    the objects) will take place asynchronously with the code that detects the user
    input and listens to the OS for messages. This wasn't an issue in the previous
    project because our code simply sat there waiting for input, drew a single frame,
    and then sat there waiting again.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we want to continuously execute the code 60 times per second, we are
    going to need to confirm that we have access to the memory where the graphics
    are drawn to, before we access it.
  prefs: []
  type: TYPE_NORMAL
- en: This raises another question about how this code runs asynchronously. But that
    will be answered when we discuss threads shortly. For now, just know that the
    line of code checks whether another part of our code, or Android itself, is currently
    using the required portion of memory. If it is free, then the code inside the
    `if` statement executes.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the first line of code to execute inside the `if` statement calls
    `lockCanvas`, so that if another part of the code tries to access the memory while
    our code is accessing it, it won't be able to – and then we do all our drawing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in the `draw` function, the following line of code (plus comments)
    appears right at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `unlockCanvasAndPost` function sends our newly decorated `Canvas` object
    (`canvas`) for drawing to the screen and releases the lock so that other areas
    of code can use it, albeit very briefly, before the whole process starts again.
    This process happens for every single frame of animation.
  prefs: []
  type: TYPE_NORMAL
- en: We now understand the code in the `draw` function. However, we still don't have
    the mechanism that calls the `draw` function over and over. In fact, we don't
    even call the `draw` function once. Next, we will discuss game loops and threads.
  prefs: []
  type: TYPE_NORMAL
- en: The game loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what is a game loop anyway? Almost every live drawing, graphics-based app,
    and game has a game loop. Even games that you might not expect, such as turn-based
    games, still need to synchronize player input with drawing and AI, while following
    the rules of the underlying OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a constant need to update the objects in the app, such as by moving
    them and drawing everything in its current position while simultaneously responding
    to user input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The game loop](img/B12806_21_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our game loop comprises three main phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Update all game and drawing objects by moving them, detecting collisions, and
    processing the AI, such as particle movements and state changes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Based on the data that has just been updated, draw the frame of animation in
    its latest state
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Respond to screen touches from the user
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We already have a `draw` function for handling this part of the loop. This suggests
    that we will have a function to do all the updating as well. We will soon code
    the outline of an `update` function. In addition, we know that we can respond
    to screen touches, although we will need to adapt slightly from all the previous
    projects because we are no longer working inside an `Activity` class or using
    conventional UI widgets from a layout.
  prefs: []
  type: TYPE_NORMAL
- en: There is a further issue in that (as I briefly mentioned) all the updating and
    drawing happens asynchronously to detect screen touches and listen to the OS.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just to be clear, asynchronous means that it does not occur at the same time.
    Our code will work by sharing execution time with Android and the UI. The CPU
    will very quickly switch back and forth between our code and Android or user input.
  prefs: []
  type: TYPE_NORMAL
- en: But how exactly will these three phases be looped through? How will we code
    this asynchronous system, from which `update` and `draw` can be called, and how
    will we make the loop run at the correct speed (or frame rate)?
  prefs: []
  type: TYPE_NORMAL
- en: As you can probably guess, writing an efficient game loop is not as simple as
    a `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our game loop will, however, also contain a `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: We need to consider timing, starting, and stopping the loop, in addition to
    not causing the OS to become unresponsive because we are monopolizing the entire
    CPU within our single loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'But when and how do we call our `draw` function? How do we measure and keep
    track of the frame rate? With these things in mind, our finished game loop is
    probably better represented by the following diagram – notice the introduction
    to the concept of **threads**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The game loop](img/B12806_21_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we know what we want to achieve, let's learn about threads.
  prefs: []
  type: TYPE_NORMAL
- en: Threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what is a thread? You can think of threads in programming in the same way
    as you do threads in a story. In one thread of a story, we might have the primary
    character battling the enemy on the frontline, while in another thread, the soldier's
    family are living, day to day. Of course, a story doesn't have to have only two
    threads – we could introduce a third thread. For instance, the story also tells
    of the politicians and military commanders making decisions, and these decisions
    then subtly, or not so subtly, affect what happens in the other threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Programming threads are just like this. We create parts or threads in our program
    that control different aspects for us. In Android, threads are especially useful
    when we need to ensure that a task does not interfere with the main (UI) thread
    of the app, or if we have a background task that takes a long time to complete
    and must not interrupt the main thread of execution. We introduce threads to represent
    these different aspects for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: They make sense from an organizational point of view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are a proven way of structuring a program that works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nature of the system we are working on forces us to use them anyway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Android, we use threads for all three reasons simultaneously – because it
    makes sense, it works, and we must use threads since the design of the Android
    system requires it.
  prefs: []
  type: TYPE_NORMAL
- en: Often, we use threads without knowing it. This happens because we use classes
    that use threads on our behalf. All the animations that we coded in [Chapter 19](ch19.html
    "Chapter 19. Animations and Interpolations"), *Animations and Interpolations*,
    were all running in threads. Another such example in Android is the `SoundPool`
    class, which loads sound in a thread. We will see, or rather hear, `SoundPool`
    in action in [Chapter 23](ch23.html "Chapter 23. Android Sound Effects and the
    Spinner Widget"), *Android Sound Effects and the Spinner Widget*. We will see
    again that our code doesn't have to handle the aspects of threads that we are
    about to learn about because it is all handled internally by the class. In this
    project, however, we need to get a bit more involved.
  prefs: []
  type: TYPE_NORMAL
- en: In real-time systems, think about a thread that is receiving the player's button
    taps for moving left and right at the same time as listening for messages from
    the OS, such as calling `onCreate` (and other functions that we will see later)
    as one thread, and another thread that draws all the graphics and calculates all
    the movements.
  prefs: []
  type: TYPE_NORMAL
- en: Problems with threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programs with multiple threads can have problems associated with them, such
    as the threads of a story; if proper synchronization does not occur, then things
    can go wrong. What if our soldier went into battle before the battle or the war
    even existed?
  prefs: []
  type: TYPE_NORMAL
- en: Consider that we have a variable, `Int x`, that represents a key piece of data
    that three threads of our program use. What happens if one thread gets slightly
    ahead of itself and makes the data "wrong" for the other two? This problem is
    the problem of **correctness** caused by multiple threads racing to completion
    while remaining oblivious – because, after all, they are just dumb code.
  prefs: []
  type: TYPE_NORMAL
- en: The problem of correctness can be solved by close oversight of the threads and
    locking. **Locking** means temporarily preventing execution in one thread to make
    sure that things are working in a synchronized manner; this is similar to preventing
    a soldier from boarding a ship to war until the ship has docked and the gangplank
    has been lowered, thereby avoiding an embarrassing splash.
  prefs: []
  type: TYPE_NORMAL
- en: The other problem with programs with multiple threads is the problem of **deadlock**.
    Here, one or more threads become locked, waiting for the "right" moment to access
    `Int x`; however, that moment never comes and, eventually, the entire program
    grinds to a halt.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that it was the solution to the first problem (correctness)
    that is the cause of the second problem (deadlock).
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the problem has been solved for us. In the same way that we use
    the `Activity` class and override `onCreate` to know exactly when we need to create
    our app, we can also use other classes to create and manage our threads. For example,
    with `Activity,` we only need to know how to use them, not how they work.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, why did I tell you about threads when you don''t need to know about them,
    you rightly ask? This is simply because we will be writing code that looks different
    and is structured in an unfamiliar manner. We can then achieve the following goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the general concept of a thread in that it is the same as a story
    thread that happens almost simultaneously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn the few rules of using a thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By doing so, we will have no difficulty in writing our Kotlin code to create
    and work within our threads. There are a few different Android classes that handle
    threads, and different thread classes work best in different situations.
  prefs: []
  type: TYPE_NORMAL
- en: All we need to remember is that we will be writing parts of our program that
    run at *almost* the same time as each other.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What do you mean by almost? What is happening is that the CPU switches between
    threads in turn/asynchronously. However, this happens so fast that we will not
    be able to perceive anything but simultaneity/synchrony. Of course, in the story
    thread analogy, people do act entirely synchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a glimpse of what our thread code will look like. Don''t add any
    code to the project just yet. We can then declare an object of the `Thread` type,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then initialize and start it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one more conundrum to threads; take another look at the constructor
    that initializes the thread. Here is the line of code again for your convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at the argument that is passed to the constructor; we pass in `this`.
    Remember that the code is going inside the `LiveDrawingView` class, not `MainActivity`.
    We can, therefore, surmise that `this` is a reference to a `LiveDrawingView` class
    (which extends `SurfaceView`).
  prefs: []
  type: TYPE_NORMAL
- en: It seems very unlikely that when the engineers at Android HQ wrote the `Thread`
    class, they would have been aware that one day, we would be writing our `LiveDrawingView`
    class. So, how can this work?
  prefs: []
  type: TYPE_NORMAL
- en: The `Thread` class needs an entirely different type to be passed into its constructor.
    The `Thread` constructor needs a `Runnable` object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can confirm this fact by referring to the `Thread` class on the Android
    developer''s website here: [https://developer.android.com/reference/java/lang/Thread.html#Thread(java.lang.Runnable)](https://developer.android.com/reference/java/lang/Thread.html#Thread(java.lang.Runnable)).'
  prefs: []
  type: TYPE_NORMAL
- en: Do you recall that we discussed interfaces in [Chapter 12](ch12.html "Chapter 12. Connecting
    Our Kotlin to the UI and Nullability"), *Connecting Our Kotlin to the UI and Nullability*?
    As a reminder, we can implement an interface by adding the interface name after
    the class declaration.
  prefs: []
  type: TYPE_NORMAL
- en: We must then implement the abstract functions of the interface. `Runnable` has
    just one; it is the `run` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can confirm this preceding fact by looking at the `Runnable` interface
    on the Android developer''s website here: [https://developer.android.com/reference/java/lang/Runnable.html](https://developer.android.com/reference/java/lang/Runnable.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use the `override` keyword to change what happens when the OS allows
    our thread object to run its code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the overridden `run` function, we will call two functions, one that
    we have started already, `draw`, and the other is `update`. The `update` function
    is where all our calculations and AI will go. The code will be similar to the
    following block, but don''t add it yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When appropriate, we can also stop our thread as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, everything that is in the `run` function is executing in a separate thread,
    leaving the default or UI thread to listen for touches and system events. We will
    see how the two threads communicate with each other in the drawing project shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Note that precisely where all these parts of the code will go in our app has
    not been explained, but it is so much easier to show you in the real project.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the game loop with a thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have learned about the game loop and threads, we can put it all
    together to implement our game loop in the Living Drawing project.
  prefs: []
  type: TYPE_NORMAL
- en: We will add the entire code for the game loop, including writing code in two
    functions in the `MainActivity` class to start and stop the thread that will control
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Reader challenge**'
  prefs: []
  type: TYPE_NORMAL
- en: Can you work out for yourself how the `Activity`-based class will start and
    stop the thread in the `LiveDrawingView` class?
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Runnable and providing the run function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Update the class declaration by implementing `Runnable`, as shown in the following
    highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have a new error in the code. Hover the mouse cursor over the
    word `Runnable`, and you will see a message informing you that we need to implement
    the `run` function just as we discussed during the discussion on interfaces and
    threads in the previous section. Add the empty `run` function, including the `override`
    label.
  prefs: []
  type: TYPE_NORMAL
- en: 'It doesn''t matter where you add it, provided that it is within the `LiveDrawingView`
    class''s curly braces and not inside another function. Add the empty `run` function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The error is gone and now we can declare and initialize a `Thread` object.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the thread
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Declare some variables and instances underneath all our other members in the
    `LiveDrawingView` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can start and stop the thread – take a moment to think about where we
    might do this. Remember that the app needs to respond to the OS that is starting
    and stopping the app.
  prefs: []
  type: TYPE_NORMAL
- en: Starting and stopping the thread
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we need to start and stop the thread. We have seen the code that we need,
    but when and where should we do it? Let''s add code to two functions – one to
    start and one to stop – and then we can consider when and where to call these
    functions. Add these two functions inside the `LiveDrawingView` class. If their
    names sound familiar, it is not by chance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: What is happening is slightly given away by the comments. We now have a `pause`
    and `resume` function that stop and start the `Thread` object using the same code
    we discussed previously.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the new functions are `public`, and therefore, they are accessible
    from outside the class to any other class that has an instance of `LiveDrawingView`.
    Remember that `MainActivity` holds the fully declared and initialized instance
    of `LiveDrawingView`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use the Android Activity lifecycle to call these two new functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Activity lifecycle to start and stop the thread
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Update the overridden `onResume` and `onPause` functions in `MainActivity`,
    as shown in the following highlighted lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, our thread will be started and stopped when the OS is resuming and pausing
    our app. Remember that `onResume` is called after `onCreate` the first time that
    an app is started, not just after resuming from a pause. The code inside `onResume`
    and `onPause` uses the `liveDrawingView` object to call its `resume` and `pause`
    functions, which, in turn, has the code to start and stop the thread. This code
    then triggers the thread's `run` function to execute. It is in this `run` function
    (in `LiveDrawingView`) that we will code our game loop. Let's do that now.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the run function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although our thread is set up and ready to go, nothing happens because the
    `run` function is empty. Code the `run` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that there are two errors in Android Studio. This is because we have
    not written the `update` function yet. Let''s quickly add an empty function (with
    a comment) for it; I added mine after the `run` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's discuss in detail how the code in the `run` function achieves the
    aims of our game loop by looking at the entire thing one step at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'This first part initiates a `while` loop with the `drawing` condition, and
    then wraps the rest of the code inside `run` so that the thread will need to be
    started (for `run` to be called) and `drawing` will need to be true for the `while`
    loop to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of code inside the `while` loop declares and initializes a local
    variable, `frameStartTime`, with whatever the current time is. The `currentTimeMillis`
    function of the `System` class returns this value. If we later want to measure
    how long a frame has taken, then we need to know what time it started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, still inside the `while` loop, we check whether the app is paused, and
    only if the app is not paused does this next code get executed. If the logic allows
    execution inside this block, then `update` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Outside of the previous `if` statement, the `draw` function is called to draw
    all the objects in the just-updated positions. At this point, another local variable
    is declared and initialized with the length of time that it took to complete the
    entire frame (updating and drawing). This value is calculated by getting the current
    time, once again with `currentTimeMillis`, and subtracting `frameStartTime` from
    it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The next `if` statement detects whether `timeThisFrame` is greater than zero.
    It is possible for the value to be zero if the thread runs before the objects
    are initialized. If you look at the code inside the `if` statement, it calculates
    the frame rate by dividing the elapsed time by `millisInSecond`. If you divide
    by zero, the app will crash, which is why we perform the check.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `fps` gets the value assigned to it, we can use it in the next frame to
    pass to the `update` function, which updates all the particles that we will code
    in the next chapter. They will use the value to make sure that they move by precisely
    the correct amount based on their target speed and the length of time the frame
    of animation that has just ended has taken:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The result of the calculation that initializes `fps` in each frame is that `fps`
    will hold a fraction of one. As the frame rate fluctuates, `fps` will hold a different
    value and supply the particle systems with the appropriate number to calculate
    each move.
  prefs: []
  type: TYPE_NORMAL
- en: Running the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Click on the play button in Android Studio and the hard work and theory of
    the chapter will come to life:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the app](img/B12806_21_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see that we now have a real-time system created with our game loop and
    a thread. If you run this on a real device, you will easily achieve 60 frames
    per second at this stage.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was probably the most technical chapter so far. We explored threads, game
    loops, timing, using interfaces, and the `Activity` lifecycle – it's a very long
    list of topics to cram in.
  prefs: []
  type: TYPE_NORMAL
- en: If the exact interrelationship between these things is still not entirely clear,
    it is not a problem. All you need to know is that when the user starts and stops
    the app, the `MainActivity` class will handle starting and stopping the thread
    by calling the `LiveDrawingView` class's `pause` and `resume` functions. It achieves
    this through the overridden `onPause` and `onResume` functions, which are called
    by the OS.
  prefs: []
  type: TYPE_NORMAL
- en: Once the thread is running, the code inside the `run` function executes alongside
    the UI thread that is listening for user input. As we call the `update` and `draw`
    functions from the `run` function at the same time as keeping track of how long
    each frame is taking, our app is ready to rock and roll.
  prefs: []
  type: TYPE_NORMAL
- en: We just need to allow the user to add some particles to their artwork, which
    we can then update in each call to `update` and draw in each call to `draw`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be coding, updating, and drawing both the `Particle`
    and `ParticleSytem` classes. In addition, we will be writing code for the user
    to interact (do some drawing) with the app.
  prefs: []
  type: TYPE_NORMAL
