- en: Chapter 7. The Web Request Handling Layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The request handling layer is the glue that binds the HTTP client to the services
    provided by your application. It is the interpretation of requests and the transfer
    of data that is the realm of this layer. Our focus will be on the data that is
    consumed and submitted by Ext JS 4 clients. This data is in JSON format and we
    will hence discuss JSON parsing and generation using the Java API for JSON Processing.
    It is important to note, however, that any type of data can be exposed by an appropriate
    request handling implementation. It is just as easy to implement an RMI or RESTful
    interface, if required.
  prefs: []
  type: TYPE_NORMAL
- en: A brief history of Web MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It may seem strange to discuss the **Model-View-Controller** (**MVC**) paradigm
    in a historical context, as a majority of web applications still use this technology
    today. The MVC design pattern first came to prominence in the early 2000's with
    the open source Struts framework. This framework encouraged the use of MVC architecture
    to promote a clear demarcation of responsibilities when processing and serving
    requests. The MVC paradigm for server-side Java development has been around ever
    since in a variety of formats, culminating in the well-designed and powerful Spring
    MVC framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rationale for using an MVC approach is quite simple. The web layer implementing
    interactions between the clients and the application can be divided into the following
    three different kinds of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: Model objects that represent the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View objects that have the responsibility of displaying the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controller objects that respond to actions and provide model data for the view
    object to process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each MVC object would behave independently with loose coupling. For example,
    the view technology was of no concern to the controller. It did not matter if
    the view was generated by a FreeMarker template, an XSLT transformation, or a
    combination of Tiles and JSPs. The controller would simply pass on the responsibility
    to the view object to process the model data.
  prefs: []
  type: TYPE_NORMAL
- en: One important point to note in this historical discussion is that all of the
    MVC processing was performed *on the server*. With the rise in the number of JavaScript
    frameworks, in particular for Ext JS 4, the MVC paradigm has been moved from the
    server to the client browser. This is a fundamental change to how web applications
    are being developed and is the very reason that you are reading this book!
  prefs: []
  type: TYPE_NORMAL
- en: Request handling for enterprise web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram clearly identifies where the request handling layer resides
    in the overall application architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Request handling for enterprise web applications](img/5457OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The request handling layer accepts client requests and forwards the respective
    action to the appropriate service layer method. The returned DTO (or Value Object
    as it is also known in Domain-Driven Design) is examined and an appropriate response
    is then sent to the client. Unlike the historical server-side MVC programming,
    the request handling layer has no knowledge of presentation and simply acts as
    a request-processing interface to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Building the request handling layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The web request handling layer for Ext JS 4 clients is a JSON-generating proxy
    to the service layer interfaces. The domain entities are converted into JSON representations
    within this layer; so our first step is to create some helper code to make this
    task easier.
  prefs: []
  type: TYPE_NORMAL
- en: There are several excellent open source JSON generation projects that can assist
    in this task including Jackson ([http://jackson.codehaus.org](http://jackson.codehaus.org))
    and Google Gson ([http://code.google.com/p/google-gson/](http://code.google.com/p/google-gson/)).
    Such libraries parse POJOs into an appropriate JSON representation via their declared
    fields. With the release of Java EE 7, we no longer have a need for third-party
    libraries. The Java API for JSON Processing (JSR-353) is available in all Java
    EE 7-compliant application servers including GlassFish 4\. We will leverage this
    API for generating and parsing JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are unable to use a Java EE 7 application server, you will need to select
    an alternate JSON-generating strategy, such as Jackson or Google Gson.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for JSON generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our first addition is a new domain interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This very simple interface defines two methods to help with JSON generation.
    The `toJson` method creates a `JsonObject` that represents the entity. The `addJson`
    method adds the entity properties to a `JsonObjectBuilder` interface. We will
    see how these two methods are used very soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of our domain entities will need to implement the `JsonItem` interface,
    and this can be achieved by simply adding the interface to the abstract superclass
    of all the domain entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `JsonObjectBuilder` interface defines a set of methods that add the name/value
    pairs to the JSON object associated with the builder. The `builder` instance adds
    the fields defined in the descendent classes that implement the `addJson` method.
    We will start with the `Company` object.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Company addJson method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `addJson` method that needs to be added to the `Company` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `JsonObject` representation of the `Company` instance is created by calling
    the `builder.build()` method in the superclass. The generated `JsonObject` can
    then be written by a `JsonWriter` instance to an output source.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Project addJson method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `addJson` method that needs to be added to the `Project` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that it is always a good practice to perform `null` object tests before
    accessing the object methods. It is possible to create a `project` object without
    a `company` instance and hence we perform the `company != null` test prior to
    adding the `company` JSON properties to the project `builder` instance. We could
    have used the following code to add the `company` properties to the project `builder`
    instance directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: However, we would now have replicated the `builder.add("idCompany"…)` code across
    two classes (`Company.addJson` and `Project.addJson`), thus making the future
    maintenance prone to errors. Changing the JSON property name from `idCompany`
    to `companyId`, for example, would require the scanning of code to check for possible
    usage across all classes, not just the `Company` class. The creation of `Company`
    JSON should belong with the `Company` class as we have implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Task addJson method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This `Task` class will implement the `addJson` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note once again how we chain the call to `addJson` for both the `project` and
    `company` classes to add their JSON properties to the task's `builder` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the User addJson method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `User.addJson` method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `fullName` property is for convenience only; we can just as easily create
    a `fullName` field that concatenates the `firstName` and `lastName` fields in
    our Ext JS code. However, keeping this code at the source of the JSON generation
    allows for easier maintenance. Consider the business change request "add a `middleName`
    field to the `User` entity". The `fullName` inclusion of the new `middleName`
    field is then a trivial exercise and would be available to the Ext JS client without
    any further changes.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the TaskLog addJson method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `addJson` method adds all of the `TaskLog` fields to the `builder` instance.
    The `DATE_FORMAT_yyyyMMdd` constant is used to format the `taskLogDate` to an
    8-digit representation of the year/month/day and is added to the `TaskLog` class
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addJson` method will use the `SimpleDateFormat` instance to format the
    `taskLogDate` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `taskLogDate` field is being formatted in a way that cannot be misunderstood
    when converting to a JavaScript `Date` object in Ext JS clients. Without the use
    of the `SimpleDateFormat` instance, the `builder` instance would call the default
    `toString` method on the `taskLogDate` object to retrieve the String representation,
    resulting in an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using the `SimpleDateFormat` instance configured with a date pattern of `yyyyMMdd`
    will ensure that such a date is formatted to `20130814`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Date formatting in enterprise applications can cause many issues if not approached
    with a standard strategy. This is even more applicable when we are developing
    applications to be used worldwide, with multiple timezones and different languages.
    The dates should always be formatted in a way that can be interpreted in the same
    way regardless of language, timezone, and user preferences.
  prefs: []
  type: TYPE_NORMAL
- en: A note on JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be using JSON to transmit data between the GlassFish server and the
    Ext JS client. The transfer is bidirectional; the server will send the JSON data
    to the Ext JS client, and the Ext JS client will be sending the data in the JSON
    format back to the server. The server and client will consume *and* produce the
    JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are no rules for structuring the JSON data as long as it conforms to
    the specifications ([http://tools.ietf.org/html/rfc4627](http://tools.ietf.org/html/rfc4627)).
    Ext JS 4 models allow any form of valid JSON structure through the use of associations;
    our approach keeps the JSON structure to its simplest form. The previously defined
    `addJson` methods return simple, flat data structures without nesting or arrays.
    As an example, a `task` instance could be serialized into the following JSON object
    (formatting included for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `data` payload represents the `task` object that will be consumed by the
    Ext JS 4 client. We could have defined the JSON representation of the `task` object
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this structure we see that the `task` instance belongs to a `project`, which
    in turn belongs to a `company`. Both these JSON representations are legal; they
    both contain the same `task` data in valid JSON format. However, which of these
    two will be easier to parse? Which will be easier to debug? As an enterprise application
    developer we should always keep the KISS principle in mind. The **Keep It Simple,
    Stupid** (**KISS**)principle states that most systems work best if they are kept
    simple and unnecessary complexities should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep your JSON simple! We know that complex structures are possible; this is
    achieved only through additional complexities when defining the Ext JS 4 models
    along with the associated data processing when reading or writing JSON data. A
    simple JSON structure is easier to understand and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the request handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now build the handlers that are used to serve the HTTP requests from
    our Ext JS client. These handlers will be added to a new `web` directory, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the request handlers](img/5457OS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each handler will use the Spring Framework `@Controller` annotation to indicate
    that the class serves the role of a "controller". Strictly speaking, the handlers
    that we will be defining are *not* controllers in the traditional sense of a Spring
    MVC application. We will only be using a very small portion of the available Spring
    controller functionality to process requests. This will ensure that our request
    handling layer is very lightweight and easy to maintain. As always, we will start
    by creating a base class that all the handlers will implement.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the AbstractHandler superclass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `AbstractHandler` superclass defines several important methods that are
    used to simplify JSON generation. As we are working toward integration with Ext
    JS 4 clients, the structure of the JSON object generated by our handlers is specific
    to data structures expected by Ext JS 4 components. We will always generate a
    JSON object with a `success` property that holds a Boolean `true` or `false` value.
    Likewise, we will always generate a JSON object with a payload property named
    `data`. This `data` property will have a valid JSON object as its value, either
    as a simple JSON object or as a JSON array.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that all of the generated JSON objects will be in a format that can
    be consumed by Ext JS 4 components without the need for additional configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of the `AbstractHandler` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The overloaded `getJsonSuccessData` methods will each generate a JSON string
    with the `success` property set to `true` and an appropriate `data` JSON payload.
    The `getJsonXXXMsg` variants will also generate a JSON String with an appropriate
    `success` property (either `true` for a successful action or `false` for a failed
    action) and an `msg` property that holds the appropriate message for consumption
    by the Ext JS component.
  prefs: []
  type: TYPE_NORMAL
- en: The `parseJsonObject` method will parse a JSON string *into* a `JsonObject`
    using the `JsonReader` instance. The `toJsonString` method will *write* a `JsonObject`
    to its JSON string representation using the `JsonWriter` instance. These classes
    are part of the Java EE 7 `javax.json` package, and they make working with JSON
    very easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getIntegerValue` method is used to parse a `JsonValue` object into an
    `Integer` type. A `JsonValue` object may be of several different types as defined
    by the `javax.json.jsonValue.ValueType` constants, and appropriate checks are
    performed on the value prior to attempting to parse the `JsonValue` object into
    an `Integer`. This will allow us to send JSON data from Ext JS clients in the
    following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `idCompany` property has a value of `null`. The `getIntegerValue`
    method allows us to parse integers that *may* be `null`, something that is not
    possible when using the default `JsonObject.getInt(key)` method (which throws
    an exception if a `null` value is encountered).
  prefs: []
  type: TYPE_NORMAL
- en: Let's now define our first handler class that will process user authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the SecurityHandler class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We first define a simple helper class that can be used to verify whether a
    user session is active:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The static constant `SESSION_ATTRIB_USER` will be used as the name of the session
    property that holds the authenticated user. All handler classes will call the
    `SecurityHelper.getSessionUser` method to retrieve the authenticated `user` from
    the session. A user session may time out due to inactivity, and the HTTP session
    will then be removed by the application server. When this happens, the `SecurityHelper.getSessionUser`
    method will return `null`, and the 3T application must handle this gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: The `SecurityHandler` class is used to authenticate the user credentials. If
    a user is successfully authenticated, the `user` object is stored in the HTTP
    session using the `SESSION_ATTRIB_USER` attribute. It is also possible for the
    user to log out of the 3T application by clicking on the **Log Out** button. In
    this case the user is removed from the session.
  prefs: []
  type: TYPE_NORMAL
- en: 'The verification and logout functionalities are implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `SecurityHandler` class introduces many new Spring annotations and concepts
    that need to be explained in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The @Controller and @RequestMapping annotations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `@Controller` annotation indicates that this class serves the role of a
    Spring controller. The `@Controller` annotated classes are autodetected by Spring
    component scanning, the configuration of which is defined later in this chapter.
    But what exactly is a controller?
  prefs: []
  type: TYPE_NORMAL
- en: 'A Spring controller is part of the Spring MVC framework and usually acts with
    models and views to process requests. We have no need for either models or views;
    in fact, our processing lifecycle is managed entirely by the controller itself.
    Each controller is responsible for a URL mapping as defined in the class-level
    `@RequestMapping` annotation. This mapping maps a URL path to the controller.
    In our 3T application, any URL starting with `/security/` will be directed to
    the `SecurityHandler` class for further processing. Any subpath will then be used
    to match a method-level `@RequestMapping` annotation. We have two methods defined,
    each with their own unique mapping. This results in the following URL path-to-method
    mappings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/security/logon` will map to the `logon` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/security/logout` will map to the `logout` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other URL starting with `/security/` will not match the defined methods
    and would produce a `404` error.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the method is not important; it is the `@RequestMapping` annotation
    that defines the method used to serve a request.
  prefs: []
  type: TYPE_NORMAL
- en: There are two additional properties defined in the `logon` `@RequestMapping`
    annotation. The `method=RequestMethod.POST` property specifies that the logon
    request URL `/security/logon` must be submitted as a `POST` request. If any other
    request type was used for the `/security/logon` submission, a `404` error would
    be returned. Ext JS 4 stores and models using AJAX will submit `POST` requests
    by default. Actions that read data, however, will be submitted using a `GET` request
    unless configured otherwise. The other possible methods used in RESTful web services
    include `PUT` and `DELETE`, but we will only define the `GET` and `POST` requests
    in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is considered a best practice to ensure that each `@RequestMapping` method
    has an appropriate `RequestMethod` defined. The actions that modify data should
    always be submitted using a `POST` request. The actions that hold sensitive data
    (for example, passwords) should also be submitted using a `POST` request to ensure
    that the data is not sent in a URL-encoded format. The read actions may be sent
    as either a `GET` or a `POST` request depending on your application needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `produces = {"application/json"}` property defines the producible media
    types of the mapped request. All of our requests will produce JSON data that has
    the media type `application/json`. Each HTTP request submitted by a browser has
    an `Accept` header, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `Accept` request does not include the `produces` property media type,
    then the following `406 Not Acceptable` error is returned by the GlassFish 4 server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: All modern browsers will accept the `application/json` content type.
  prefs: []
  type: TYPE_NORMAL
- en: The @ResponseBody annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This annotation is used by Spring to identify the methods that should return
    the content directly to the HTTP response output stream (not placed in a model
    or interpreted as a view name, which is the default Spring MVC behavior). How
    this is achieved will depend on the return type of the method. All of our request
    handling methods will return Java Strings, and Spring will internally use a `StringHttpMessageConverter`
    instance to write the String to the HTTP response output stream with a `Content-Type`
    of value `text/plain`. This is a very easy way of returning JSON data object String
    to an HTTP client and thus makes request handling a trivial process.
  prefs: []
  type: TYPE_NORMAL
- en: The @RequestParam annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This annotation on a method argument maps a request parameter to the argument
    itself. In the `logon` method we have the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that the `logon` method was of the type `GET` (it is set to `POST`
    in the `SecurityHandler` class, and hence the following URL encoding would not
    work), a URL such as the following would call the method with a `username` value
    of `bjones` and a `password` value of `admin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/security/logon.json?username=bjones&password=admin`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could just as easily have written this method with the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This would then map a URL of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/security/logon.json?user=bjones&pwd=admin`'
  prefs: []
  type: TYPE_NORMAL
- en: Note that it is the `value` property of the `@RequestParam` annotation that
    maps to the request parameter name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `required` property of the `@RequestParam` annotation defines if this parameter
    is a required field. The following URL would result in an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/security/logon.json?username=bjones`'
  prefs: []
  type: TYPE_NORMAL
- en: The password parameter is obviously missing, which does not adhere to the `required=true`
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `required=true` property only checks for the existence of a request
    parameter that matches the `value` of the `@RequestParam` annotation. It is entirely
    valid to have a request parameter that is empty. The following URL would not throw
    an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/security/logon.json?username=bjones&password=`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Optional parameters may be defined by using the `required=false` property and
    may also include a `defaultValue`. Consider the following method argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Also consider the following three URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/user/address.json?address=Melbourne`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/user/address.json?address=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/user/address.json?`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first URL will result in an address value `Melbourne`, the second URL will
    have a null address, and the third URL will have an "unknown address". Note that
    the `defaultValue` will only be used if the request does not have a valid address
    parameter, and not if the address parameter is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating a user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `logon` method in our `SecurityHandler` class is very simple thanks to
    our implementation of the service-layer business logic. We call the `userService.findByUsernamePassword(username,
    password)` method and check the returned `Result`. If the `Result` is successful,
    the `SecurityHandler.logon` method will return a JSON representation of the authenticated
    user. This is achieved by the line `getJsonSuccessData(user)`, which will result
    in the following output being written to the HTTP response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding formatting is for readability only. The actual response
    will be a stream of characters. The authenticated user is then added to the HTTP
    session with the attribute `SESSION_ATTRIB_USER`. We are then able to identify
    the authenticated user by calling `SecurityHelper.getSessionUser(request)` in
    our request handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Result` instance that has failed will call the `getJsonErrorMsg(ar.getMsg())`
    method, which will result in the following JSON object being returned in the HTTP
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `msg` text is set on the `Result` instance in the `UserServiceImpl.findByUsernamePassword`
    method. The Ext JS frontend will process each result differently depending on
    the `success` property.
  prefs: []
  type: TYPE_NORMAL
- en: Logging out
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The logic in this method is very simple: remove the user from the session and
    return a successful JSON message. The Ext JS frontend will then take an appropriate
    action. There is no `RequestMethod` defined in the `@RequestMapping` annotation
    as no data is being sent. This means that any `RequestMethod` may be used to map
    this URL (`GET`, `POST`, and so on). The JSON object returned from this method
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Defining the CompanyHandler class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This handler processes company actions and is mapped to the `/company/` URL
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Each method is mapped to a different sub URL as defined by the method-level
    `@RequestMapping` annotation. The `CompanyHandler` class will hence be mapped
    to the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/company/find` will map it to the `find` method using a `GET` request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/company/store` will map it to the `store` method using a `POST` request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/company/findAll` will map it to the `findAll` method using a `GET` request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/company/remove` will map it to the `remove` method using a `POST` request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are a few things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: Each handler method is defined with either a `RequestMethod.POST` or `RequestMethod.GET`.
    The `GET` method is used for finder methods, and the `POST` method is used for
    data-modifying methods. These method types are the defaults used by Ext JS for
    each action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each method retrieves the user from the HTTP session by calling `getSessionUser(request)`
    and then tests if the `user` value is `null`. If the user is not in session, the
    message "`User is not logged on"` is returned in the JSON-encoded HTTP response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `POST` methods have a single request parameter that holds the JSON data
    submitted by the Ext JS client. This JSON string is then parsed into a `JsonObject`
    before calling the appropriate service layer method using the required parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A typical JSON data payload for adding a new company would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `idCompany` value is `null`. If you are modifying an existing
    company record, the JSON data payload must contain a valid `idCompany` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Note also that the JSON data holds exactly one company record. It is possible
    to configure Ext JS clients to submit multiple records per request by submitting
    a JSON array similar to the following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: However, we will restrict our logic to processing a single record per request.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the ProjectHandler class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ProjectHandler` class processes the project actions and is mapped to the
    `/project/` URL pattern as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ProjectHandler` class will hence be mapped to the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/project/find` will map to the `find` method using a `GET` request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/project/store` will map to the `store` method using a `POST` request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/project/findAll` will map to the `findAll` method using a `GET` request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/project/remove` will map to the `remove` method using a `POST` request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that in the `store` method, we are once again retrieving the required
    data from the parsed `JsonObject`. The structure of the JSON `data` payload when
    adding a new project is in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When updating an existing project, the JSON structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also notice that we once again have the same block of code replicated
    in each method, as we did in the `CompanyHandler` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Every method in each of the remaining handlers will also require the same check;
    a user *must* be in session to perform the action. This is precisely why we will
    simplify our code by introducing the concept of Spring request handler interceptors.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring HandlerInterceptor interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring''s request handling mapping mechanism includes the ability to intercept
    requests by using handler interceptors. These interceptors are used to apply some
    type of functionality to the requests as in our example of checking whether a
    user is in session. The interceptors must implement the `HandlerInterceptor` interface
    from the `org.springframework.web.servlet` package where it is possible to apply
    the functionality in the following three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Before the handler method is executed by implementing the `preHandle` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the handler method is executed by implementing the `postHandle` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the complete request has finished execution by implementing the `afterCompletion`
    method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `HandlerInterceptorAdapter` abstract class, along with the predefined empty
    implementations for each method, is normally used to implement custom handlers.
    Our `UserInSessionInterceptor` class is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When intercepting a request with the `UserInSessionInterceptor`, the code in
    the `preHandle` method checks if there is a user in session. If a `sessionUser`
    is found, the handler returns `true` to indicate that normal processing should
    continue. Normal processing may result in additional handler interceptors being
    called, if configured, before finally reaching the mapped handler method.
  prefs: []
  type: TYPE_NORMAL
- en: If a `sessionUser` is not found, a simple JSON string is immediately sent to
    the response output stream. The `preHandle` method then returns `false` to indicate
    that the interceptor has already dealt with the response and no further processing
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'By applying the `UserInSessionInterceptor` to each request that requires the
    user session test, we can remove the following code from each handler method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How do we apply the interceptor to the appropriate handler methods? This is
    done when we customize the Spring MVC configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring MVC configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Spring MVC framework can be configured with XML files or Java configuration
    classes. We will configure our application using Spring MVC configuration classes,
    the first being the `WebAppConfig` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `WebAppConfig` class extends `WebMvcConfigurerAdapter`, which is a convenient
    base class that provides empty implementations for each of the `WebMvcConfigurer`
    interface methods. We override the `addInterceptors` method to register our `UserInSessionInterceptor`
    and define the handler mappings that will be used to apply the interceptor. The
    path pattern `/**` will intercept *all* the mappings from which we *exclude* the
    `/security/**` mappings. The security mappings should *not* include a user session
    check because the user has not yet been authenticated and will not be in session.
  prefs: []
  type: TYPE_NORMAL
- en: The `@ComponentScan("com.gieman.tttracker.web")` annotation will trigger a scan
    for `@Controller` annotated classes in the `com.gieman.tttracker.web` package.
    Our handler classes will then be identified and loaded by Spring. The `@EnableWebMvc`
    annotation identifies this class as a Spring web MVC configuration class. This
    annnotation results in Spring loading the required `WebMvcConfigurationSupport`
    configuration properties. The remaining `@Configuration` annotation identifies
    the class as a candidate for component scanning during Spring application startup.
    The `WebAppConfig` class is then automatically loaded for use in the Spring MVC
    container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `WebAppConfig` class configures the MVC environment; it is the `WebApp`
    class that configures the `servlet` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `AbstractAnnotationConfigDispatcherServletInitializer` class was introduced
    in Spring 3.2 as a base class for `WebApplicationInitializer` implementations.
    These implementations register a `DispatcherServlet` configured with annotated
    classes as defined in the `WebAppConfig` class (note how this class is returned
    in the `getServletConfigClasses` method).
  prefs: []
  type: TYPE_NORMAL
- en: 'The final configuration item of interest is the `getServletMappings` method,
    which maps incoming requests to the `WebAppConfig` set of handlers that are discovered
    via the `@ComponentScan` annotation. Every URL in our application that starts
    with `/ttt/` will be directed to an appropriate request handler for processing.
    Some example URLs submitted from an Ext JS 4 client could include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/ttt/company/findAll.json` will map to the `CompanyHandler.findAll` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/ttt/project/find.json?idProject=5` will map to the `ProjectHandler.find`
    method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the `/ttt/` prefix in the URL defines the *entry point* to our Spring
    MVC components. URLs that do not start with `/ttt/` will *not* be handled by the
    Spring MVC container.
  prefs: []
  type: TYPE_NORMAL
- en: We will now implement one more handler to introduce data binding in Spring controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the TaskLogHandler class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `TaskLogHandler` class processes the task log actions and is mapped to
    the `/taskLog/` URL pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TaskLogHandler` class will, hence, be mapped to the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/taskLog/find` will map to the `find` method using a `GET` request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/taskLog/store` will map to the `store` method using a `POST` request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/taskLog/findByUser` will map to the `findByUser` method using a `GET` request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/taskLog/remove` will map to the `remove` method using a `POST` request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have also introduced a new annotation: the `@InitBinder` annotation.'
  prefs: []
  type: TYPE_NORMAL
- en: The @InitBinder annotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `@InitBinder` annotation is used to mark a method as "data binding aware".
    The method initializes the `WebDataBinder` object with editors that are used to
    transform String parameters into their Java equivalent. The most common need for
    this transformation is in the case of dates.
  prefs: []
  type: TYPE_NORMAL
- en: 'A date can be represented in many different ways. All of the following dates
    are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: 06-Dec-2013
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6 Dec 2013
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 06-12-2013 (UK date, short form)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12-06-2013 (U.S. date, short form)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 06-Dez-2013 (German date)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: December 6, 2013
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sending date representations via HTTP requests can be confusing to say the
    least! We all understand what most of these dates represent, but how can we convert
    these dates into a `java.util.Date` object? This is where the `@InitBinder` method
    is used. The code to specify the required date format involves registering a `CustomDateEditor`
    constructor for the `Date` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This will allow Spring to use the `DATE_FORMAT_yyyyMMdd` instance to parse
    the dates sent by clients in the `yyyyMMdd` format. The following URL will now
    be transformed correctly for the arguments required in the `findByUser` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/taskLog/findByUser?username=bjones&startDate=20130719&endDate=20130812`'
  prefs: []
  type: TYPE_NORMAL
- en: The `true` argument in the `CustomDateEditor` constructor ensures that empty
    dates are given the value `null`.
  prefs: []
  type: TYPE_NORMAL
- en: More on Spring MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our handler methods and Spring MVC implementations use only a small portion
    of the Spring MVC framework. There will be scenarios that the real-world applications
    encounter that have not been covered in this chapter. These include requirements
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: URI template patterns to access portions of a URL through path variables. They
    are especially useful to simplify RESTful processing and allow the handler methods
    to access the variables in URL patterns. The company `find` method could then
    be mapped to a URL such as `/company/find/5/`, where `5` represents the `idCompany`
    value. This is achieved through the use of the `@PathVariable` annotations and
    mappings in the form of `/company/find/{idCompany}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `@SessionAttrribute` annotation to store data in the HTTP session
    between requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping cookie values with the `@CookieValue` annotation to allow a method parameter
    to be bound to the value of an HTTP cookie.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping request header attributes with the `@RequestHeader` annotation to allow
    a method parameter to be bound to a request header.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous request processing to allow the main servlet container thread to
    be released and allowed to process other requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Spring MVC with Spring Security (highly recommended for enterprise
    applications).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing multipart requests to allow the users to upload files from HTML forms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The testing of the handler classes using the Spring MVC Test framework should
    also be considered for enterprise Spring MVC applications. For more information,
    see the comprehensive guide at [http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/testing.html#spring-mvc-test-framework](http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/testing.html#spring-mvc-test-framework).
    The framework provides JUnit support for testing the client- and server-side Spring
    MVC applications.
  prefs: []
  type: TYPE_NORMAL
- en: There is much more to the Spring MVC framework than can ever be covered in a
    single chapter. We recommend users find out more about Spring MVC capabilities
    from the excellent online resource at [http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mvc.html](http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mvc.html).
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implement the `UserHandler` and `TaskHandler` classes, mapping the requests
    to the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/task/find` will map to the `TaskHandler.find` method using a `GET` request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/task/store` will map to the `TaskHandler.store` method using a `POST` request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/task/findAll` will map to the `TaskHandler.findAll` method using a `GET`
    request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/task/remove` will map to the `TaskHandler.remove` method using a `POST` request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/user/find` will map to the `UserHandler.find` method using a `GET` request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/user/store` will map to the `UserHandler.store` method using a `POST` request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/user/findAll` will map to the `UserHandler.findAll` method using a `GET`
    request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/user/remove` will map to the `UserHandler.remove` method using a `POST` request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Java web interface is now complete—we have created a fully functional request
    handling layer that is optimized for Ext JS 4 clients. The HTTP client-accessible
    URLs are mapped to the request-handling classes through the `@RequestMapping`
    annotations at the class and method levels. Each handler method interacts with
    the service layer through well-defined interfaces and processes the `Result` data
    transfer objects before returning JSON data in the HTTP response. We have configured
    the Spring Web MVC container with Java configuration classes and implemented a
    Spring interceptor to check whether a user has been authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](ch08.html "Chapter 8. Running 3T on GlassFish"), *Running 3T
    on GlassFish*, we will complete our Spring configuration and deploy the 3T application
    on the GlassFish 4 server. Each layer in our application stack will then be ready
    to play its part in serving the Ext JS 4 client requests.
  prefs: []
  type: TYPE_NORMAL
