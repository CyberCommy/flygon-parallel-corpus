- en: '*Chapter 15*: Applied Computational Thinking Problems'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be providing examples in multiple areas for applications
    of the Python programming language and computational thinking. We will be exploring
    multiple areas, such as humanities, linguistics, cryptography, and more. We will
    use what we''ve learned so far about **computational thinking** and the **Python**
    programming language to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze historical speeches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write stories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate text readability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the most efficient route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement cryptography
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement cybersecurity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a chatbot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter is unlike the others, as we will be focused exclusively on presenting
    the problems and providing algorithmic solutions after evaluating each scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need the latest version of Python installed to run the code in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need the following libraries and packages installed for Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NLTK**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cairos**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pandas**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Matplotlib**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Seaborn**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the full source code used in this chapter here: [https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter15](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter15)'
  prefs: []
  type: TYPE_NORMAL
- en: Problem 1 – Using Python to analyze historical speeches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: History is quite fascinating, and there are many reasons why we would look at
    writing algorithms to evaluate historical data and contexts.
  prefs: []
  type: TYPE_NORMAL
- en: For this problem, we want to analyze some historical text. In particular, we
    are going to take a look at *Abraham Lincoln's second inaugural speech*. Our goal
    is to find some frequencies of words. There are many reasons why we'd want to
    perform some straightforward text analysis, especially for historical texts. We
    may want to compare them, understand underlying themes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: For our algorithm, we are going to use a fairly simple design using the `nltk`
    package. Because the installation of some of the components is a bit different
    to what we've done so far, we'll provide some information in case your packages
    have not been installed.
  prefs: []
  type: TYPE_NORMAL
- en: In the Python shell, if you are in the active console, create a new file and
    import `nltk` after installing the main package (using `pip install nltk`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note you should not be in the active **Shell** window. If you see `>>>`
    at the beginning of the line, click the **File** | **New File** option and then
    enter the following code instruction line for your empty shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice from the preceding code that you''ll also open the downloader in `nltk`.
    The preceding code will bring up a window as shown in the following screenshot
    (please note that the `nltk` library takes approximately 7 MB of memory, while
    installing the additional packages will require memory as well, with each ranging
    from a few KB to 14 to 15 MB):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1 – NLTK Downloader'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_15.01_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.1 – NLTK Downloader
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, my packages are all installed. If yours are not, select **all**,
    and then click the **Download** button at the bottom left-hand corner of that
    window. Once the packages are installed, you can close the window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because our problem is fairly simple, we''ll skip much of the computational
    thinking process for this particular section. We are only trying to get frequencies
    of words used in the speech. So let''s dive directly into the algorithm and see
    how we''ll use the `nltk` package to get what we need, including a visual representation
    of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll need to import `nltk` and the `word_tokenize` function. The `word_tokenize`
    function allows us to divide the speech into individual words and/or punctuation
    marks. We'll need the speech text. In this case, the speech is copied into the
    algorithm. You could potentially import the file into the algorithm and do it
    that way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `sent_tokenize` function is short for sentence tokenization. In the same
    way as word tokenization breaks down the text by words and punctuation marks,
    the sentence tokenization function allows breaking the text into full sentences.
    The output would contain sentences in a list separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to know that all quotation marks have been escaped using `\'`
    or `\"`, respectively, in order to maintain the original text without creating
    an error in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following algorithm contains everything we need in order to do the analysis
    of Abraham Lincoln''s second inaugural speech:'
  prefs: []
  type: TYPE_NORMAL
- en: ch15_historicalTextAnalysis.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The entire text of the speech is contained in the GitHub repository file. For
    length purposes, we''ve only included half of that text here. Please note that
    the output we''ll share after the algorithm and explanations will correspond to
    the truncated speech, but the visual plot will include the data from the entire
    speech. The `[…]`, seen in the following code at the end of the `text` definition,
    is simply used to show that there is additional text that goes there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve defined the text that we want analyzed, as shown in the preceding
    code snippet, we can tell the algorithm that we want to *tokenize* the text, that
    is, we want it divided into words. The algorithm will print out a list that contains
    each individual word or punctuation symbol separated by a comma, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have our list of words, we want to get the frequency distribution
    of the words. To do so, we''ll import the package from `nltk.probability`, as
    shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the distribution, we''ll want a visual plot of this data, so we''ll
    use `matplotlib` to create our distribution plot, as shown in the following code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s the entire algorithm we''ll need. When we run the algorithm, this is
    what our output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that `word tokenization` only included the truncated text. However,
    the frequency information and the plot that follow are for the entire speech.
    The `ch15_historicalTextAnalysis.py` GitHub file includes the full speech:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the frequency distribution visual plot for this
    algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2 – Frequency distribution plot for Abraham Lincoln''s second inaugural
    address'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_15.02_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.2 – Frequency distribution plot for Abraham Lincoln's second inaugural
    address
  prefs: []
  type: TYPE_NORMAL
- en: Once we have this information, we can start to look more closely at the words
    that were used most frequently. When working with this kind of analysis, you may
    want to consider removing some of the words, such as **to**, **a**, and **the**,
    as they would be irrelevant to our analysis. However, words such as **years**
    and **Union** may be relevant to our analysis.
  prefs: []
  type: TYPE_NORMAL
- en: There are many adjustments that can be made for this algorithm, but for now,
    we've managed to at least get a frequency distribution plot for a historical speech.
    Now, we'll move on to the next problem.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 2 – Using Python to write stories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at a fairly simple problem. In this section, we want to create an
    algorithm that produces a story based on input from a user. We can make this as
    simple as we want, or add some options. But let's dig into what this is.
  prefs: []
  type: TYPE_NORMAL
- en: Defining, decomposing, and planning a story
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, *what is it we''re trying to create?* Well, a story. Because
    of the nature of this problem, we''re going to start in reverse, with a sample
    of the output we want to achieve, that is, a sample story. Let''s take a look
    at a quick story generated by our algorithm before we actually get into the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output was created by an algorithm that substituted names, locations,
    time of day, pet, and pet name. It's a short story, but this is something that
    can be used in much wider applications, such as using input to write social media
    posts, and filling in information for things such as invitations, forms, and more.
  prefs: []
  type: TYPE_NORMAL
- en: So let's work backward a bit to write our algorithm. *And why did I start at
    the end this time?* Well, in this case, we know what we want from the end result.
    You could write your story. You could have an example of that wedding invitation
    template you need to fill in, or the form. Now we have to figure out how to get
    the input and then output what we wanted.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the story shown, here are the things we can get original input for:'
  prefs: []
  type: TYPE_NORMAL
- en: Character name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Town name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type of pet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name of pet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part of town visited
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time of day
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Favorite color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we write our algorithm, we''ll need to get all the aforementioned inputs.
    Let''s take a look at the algorithm found in the `ch15_storyTime.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need inputs from the user, so we want to use a `print` statement and
    input requests that include instructions for what is needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet grabs all the inputs from the user so we can write
    our story.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have those, we have to `print` our story. Notice that we wrote it in
    simple terms, using `%s` so we could replace it with the corresponding inputs.
    We also used backslashes so that we can see our code on multiple lines, rather
    than have it in one long line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run that code one more time and see what our story says now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice that details such as character and settings have changed. In an education
    learning environment, such a simple algorithm can be a great tool for showing
    students how to interact with stories and identify key information in them.
  prefs: []
  type: TYPE_NORMAL
- en: While this is a three-sentence story, these algorithms can be much more complex,
    providing an opportunity to write fantastic original stories with user input.
    If you wanted to try some of this out, you could even put conditions for which
    phrases you would use based on some of the input, such as changing the sentences
    used based on the length of the name entered, for example. *Have some fun with
    the code and writing some stories!*
  prefs: []
  type: TYPE_NORMAL
- en: Problem 3 – Using Python to calculate text readability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll look at an application relating to linguistics, specifically
    the readability level of any text. We will be using Martin Luther King's **I Have
    a Dream** speech in the code snippets that follow. You can substitute this for
    any text file, so long as you change the location of the file and filename to
    be accurately reflected in the code. The full code can be found in the `ch15_Readability.py`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into the code, let's talk first about what we're looking for and
    why it's important. Learning about the readability of texts can help us make decisions
    about whether or not to include them in a presentation, a school grade level,
    and much more. The **Flesch-Kincaid score** is used to determine readability and
    was developed in the 1940s.
  prefs: []
  type: TYPE_NORMAL
- en: Rudolf Flesch created it when working as a consultant with the Associated Press
    in an effort to improve the readability of newspapers. Originally called the **Flesch
    Reading Ease**, it was modernized into what is currently used by the US Navy.
    Rather than getting a score that then had to be converted into a grade level,
    the Flesch-Kincaid score now provides a grade-level score.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we won''t be using the formula, it is important to know the background
    of what we''re using. The Flesch Reading Ease formula is given by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/Formula_B15413_15_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Flesch-Kincaid grade-level formula is given by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/Formula_B15413_15_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The thing about the preceding formulas is that they exist in the readability
    package available for Python. If we import the package, we are able to perform
    a readability analysis with a fairly simple bit of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code we''ll need in order to perform a readability
    analysis for the Martin Luther King speech:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, remember to change the path for your file in the code and then import
    the necessary packages for the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ch15_readability.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, you'll see that we imported the `readability` package
    into our program. If you need to install the library/package, you can use `pip
    install readability` to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the requisite libraries, we can open the file we want to analyze.
    We also want to tell the algorithm to read the text, which I've called `text_up`
    here for text upload, so I don't forget that I am reading an open file. This is
    the text we've opened from the file location in the preceding code. Finally, we
    ask the program to analyze the text using the `Readability` function. Notice that
    we saved that to `r`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we''ve done all of that, we can `print` our grade level with the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run our algorithm, our output is fairly simple as well. Take a look
    at the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know how to verify the readability of any text, try to perform
    the analysis on other types of texts, including poems, stories, speeches, songs,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 4 – Using Python to find most efficient route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this problem, when learning about algorithms, we will use a common algorithm—the
    **Travelling Salesman Problem** (**TSP**). Let's set up the problem itself.
  prefs: []
  type: TYPE_NORMAL
- en: A salesman needs to travel to a set number of cities or locations. Let's say
    the salesman has 10 locations to go to. They could go to those 10 locations in
    a lot of different orders. Our goal with this algorithm is to create the best
    possible, most efficient route to hit those locations.
  prefs: []
  type: TYPE_NORMAL
- en: Note that for this particular scenario, as we will do in the next problem, we'll
    employ straightforward analysis by using the four elements of the computational
    thinking process.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the problem (TSP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This problem is a little more complex than how it appears initially. Think of
    it this way. If we have 10 destinations and we are calculating round-trip permutations
    to check the fastest routes, we're left with more than 300,000 possible permutations
    and combinations. As a reminder, a permutation takes order into consideration,
    while a combination does not.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the numbers *3344* and *3434* are two different permutations. However,
    they are only counted as one combination because the order of the numbers does
    not matter.
  prefs: []
  type: TYPE_NORMAL
- en: 'But back to our problem. All we need to know is that we want to create an algorithm
    that will take us to our destinations in the most efficient way. We have to identify
    the cities to be visited and identify the way we''ll travel as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: There are five cities in total, namely, **New York** (**NYC**), **Philadelphia**,
    **Baltimore**, **Chicago**, and **Cleveland**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use one vehicle because we're using TSP instead of a **vehicle routing
    problem** (**VRP**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first city is 0, which is NYC. The distance between NYC and itself is 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's look at the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing the pattern (TSP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For each city, there will be a total of five distances, with the distance to
    itself equal to 0\. We are going to need an array, or lists, for all the distances
    for each city. We will need to create a model in order to access the data in our
    algorithm. We'll look at that while designing the algorithm. First, let's talk
    about generalizing the pattern a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Generalizing (TSP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this particular problem, we'll enter the cities manually into the algorithm
    itself. One thing you may want to consider is how to get input from a user in
    order to create the arrays necessary with the distances.
  prefs: []
  type: TYPE_NORMAL
- en: You could also create a database for the distances between major cities that
    you can access from a `.csv` file so that the data for cities that a person inputs
    can be found there, which can then be added to our model. There are many additions
    to this particular algorithm and this isn't a problem that can be solved in just
    one way. For now, we're going to stay with a defined set of cities so that we
    can create our algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: As an aside, we have referred to the source code from [https://developers.google.com/optimization/routing/tsp](https://developers.google.com/optimization/routing/tsp)
    for this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the algorithm (TSP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s time to see what we''ve been talking about. Let''s start with NYC and
    construct that array first. The other arrays are created in the same way. All
    distances are in miles and have been approximated and rounded based on **Google
    Maps** data, given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Distance from NYC to NYC is 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distance from NYC to Philadelphia is 95.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distance from NYC to Baltimore is 192.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distance from NYC to Chicago is 789.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distance from NYC to Cleveland is 462.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table shows the distances from each city to each other and itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 15.1 – Distances from one city to another'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Table_15.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 15.1 – Distances from one city to another
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as you can in the preceding table, if we were to write these distances
    as an array, we would use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For Philadelphia, we would have the following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For Baltimore, we would have the following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For Chicago, we would have the following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, for Cleveland, we would have the following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we will give indexes to each of the cities in order to identify them.
    NYC is *0*, Philadelphia is *1*, Baltimore is *2*, Chicago is *3*, and Cleveland
    is *4*. Let''s see what the algorithm looks like for this problem (note that the
    **OR-Tools library** is used to optimize vehicle routes, linear programming, constraint
    programming, and more):'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s start by importing the packages and libraries we''ll need. The
    full file for this algorithm is `ch15_travel.py` and available on GitHub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that this algorithm would need to get a new distance matrix if you
    are planning to visit more cities and/or different cities. That is the only piece
    of the code you''d need to alter. The snippet of code that you will need to adjust
    each time is the matrix under `create_data_model()`, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After we''ve defined our data model, we''ll need to print a solution. The following
    function provides that information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code, we are creating a function so that we
    can print the solutions based on our arrays and the distances in those arrays.
    Recall that you will identify the point of origin, that is, the city you're leaving
    from. Then we run the algorithm to gather the information and create our `print`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll need to define our `main()` function in order to run our algorithm.
    The `main()` function tells the algorithm to go ahead and create that data model
    we had defined, and then store it as data. We then create the routing model to
    find our solution. Take a look at the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows how we define our `main()` function. As a note, a `main()`
    function can be named anything we want. When using multiple functions, we sometimes
    use `main()` to identify the function that will be outputting what we originally
    wanted from the algorithm. For this problem, we're creating a `main()` function
    that will identify the best route for our travels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at what we get for our output when we run this code.
    The code provides us with the `Objective` total of miles and the route we should
    take for the trip. Here''s the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, our trip from NYC and going back to NYC would be most efficient
    if we followed the route in this order: NYC | Philadelphia | Baltimore | Cleveland
    | Chicago | NYC.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not the only approach for the travel problem. It is also not necessarily
    the most user-friendly approach if we wanted to run this multiple times a day,
    for example, for different travelers. To do that, you''d want to automate a lot
    more of this, as mentioned earlier in the example. Some things you might consider
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Being able to input cities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having a calculator that grabs information to determine distances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an automated process for creating the distance matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*But for now, you''ve seen a TSP in action!* We will look at a new problem
    in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Problem 5 – Using Python for cryptography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cryptography** is what we use to code and decode messages. We used a simple
    **Caesar cipher** in [*Chapter 9*](B15413_09_Final_SK_ePub.xhtml#_idTextAnchor134),
    *Understanding Input and Output to Design a Solution Algorithm*. For this problem,
    we''re going to use some of the packages available in Python to encrypt and decode
    information.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that for this particular scenario, we'll use the straightforward analysis
    from using the four elements of the computational thinking process. While we don't
    always follow them exactly, this particular problem lends itself to a fairly straightforward
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the problem (cryptography)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are working on a classified project and need to encrypt your information
    to maintain its safety.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing the pattern (cryptography)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has a cryptography package that can be installed, much like when we installed
    other libraries, such as **Pandas** and **NumPy**. In our problem, one of the
    main things we need to know is that we may need to continue to encrypt messages.
    We may also want to decode messages that we receive, but we are going to focus
    on the encryption side of things first.
  prefs: []
  type: TYPE_NORMAL
- en: Generalizing (cryptography)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we design our algorithm, we'll want something we can continue to use throughout
    the life of our project with little effort. That is, any time we want to encrypt
    a new message, we can run the algorithm and input the message rather than add
    the message itself to the algorithm body every time. This is the generalized pattern
    for our particular problem. *That means we're ready to design.*
  prefs: []
  type: TYPE_NORMAL
- en: Designing the algorithm (cryptography)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To write our algorithm, let''s first take a look at what we''ll need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the letters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change all the letters to lowercase to run our algorithm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the required functions—`encryption`, `decoding`, and `main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the cryptography `main` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Tip:'
  prefs: []
  type: TYPE_NORMAL
- en: The full algorithm for this problem can be found in the `ch15_cryptographyA.py`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start designing our algorithm by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by defining our letters. The following code snippet defines our
    letters, and then renders each letter in lowercase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define our encryption function. This function will take two arguments—`message`
    and `key`. The `message` function will be user-defined, which will be done in
    the `main` function. For now, we''ll use an empty message by adding empty quotes
    (`''''`) as the definition of the `encryptedM` variable, as shown in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we iterate over the letters in the message we want to encrypt, and
    then we use the key that the user defines in the `main` function and encrypt the
    message. This function then returns the encrypted message.
  prefs: []
  type: TYPE_NORMAL
- en: '*But why haven''t we defined the* `main` *function yet if that''s where we
    are getting the inputs?* Because the `main` function will require the other two
    functions to either encrypt or decode the message. So bear with us; we''ll get
    to that `main` function soon.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the decoding function. This is what we''ll use when
    we have an encrypted message and want to know what the original message was:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows the function that we'll use to decode our messages.
    It uses the characters in the message and the encryption key to then decode the
    message. Note that you cannot decode a message if you don't have the original
    key, unless you have the time to sit and try each one of the keys, that is.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll need that `main` function we keep referring to. This is the function
    that takes all the inputs needed in order for this algorithm to run. Here are
    the three things necessary for it to run correctly—the message to be encrypted
    or decoded; the key, which can be any number in the range 1 to 26; and whether
    we are encrypting or decoding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Notice from the preceding code that we defined a `main` function. At the end
    of the code, we called that function. *Don't forget to call that* `main` *function
    in the algorithm!* That's how you get the algorithm to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample output when we try to encrypt the input message, `the name
    of the dog is King Kong,` using a key of `9` to encrypt the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we obtain the encrypted text, `cqnwjvnxocqnmxprbrwpxwp,` as
    the cipher text, and now we've created an algorithm that can encrypt or decode
    any message. Let's now move on to a new problem.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 6 – Using Python in cybersecurity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this problem, we've decided to perform a fairly short cybersecurity check.
    First, let's talk about cybersecurity. The market for cybersecurity is expected
    to grow by 10% by 2027, according to a *Grand View Research* report.
  prefs: []
  type: TYPE_NORMAL
- en: Translating that to the job market is a little tricky. Currently in the United
    States, for example, there are more cybersecurity needs for the market than people
    or jobs available. That job market growth is expected to be slightly above 30%
    between 2018 and 2028\. So learning a bit about cybersecurity and cryptography
    won't hurt.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this particular problem, we are going to explore a few things. First, let''s
    talk about **hashing**. In cybersecurity, hashing means those really long strings
    of numbers and letters that replace things such as passwords. For example, if
    you entered a password of `password1` (please don''t do that, never use `password`
    as a password), the hashing process would replace it with something that looks
    more like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When we are creating cryptography algorithms, we have to add random data, which
    we call **salts**. Salts just provide additional input and help us make passwords
    more secure when storing them.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use hashing in Python, we can use the `uuid` library. **UUID** stands
    for **Universal Unique Identifier**. The `uuid` library is used when we want to
    generate random, 128-bit objects as IDs. *But what are we really talking about?*
    Let''s take a look at the algorithm found in the `ch15_hashing.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will import libraries first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We are importing two libraries that will allow us to save our passwords using
    salting and hashing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next code snippet from the file, we define the function to hash our
    password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We salted the password using our `uuid` package, and then returned the hash
    using the secure hash algorithm 1, `sha1`. This is only one of the algorithms
    we can use. We could have used others, such as **SHA-256**, **SHA-384**, and more.
    The `sha1` hash has an output size of 160, while `sha256` has an output size of
    256\. Both `sha1` and `sha256` have block sizes of 512 bits, while `sha384` has
    a block size of 1,024 bits.
  prefs: []
  type: TYPE_NORMAL
- en: All of this becomes relevant when choosing the hash we'll use, how secure they
    are, and so on. We used `sha1` here more for *nostalgia*, but it is not as secure
    as `sha256` and `sha384`. When attacked, `sha1` will fail against a prolonged
    attack. The other two will hold out for longer, but are still not the best ones.
    Hashes such as **shake128** and **shake256** have more success against such attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at the `check` function. We always want to confirm a password
    by asking for it to be entered twice. The following snippet of code defines what
    the algorithm will do when it receives the second password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s ask for some input. First, we''ll ask for the password. Because
    we''re curious about what the program is doing, we''ll print the hashed password,
    but you can omit that line when we are building this into a site or other application.
    After that, we ask to verify the password and provide output for the user so they
    know whether they match, in which case, we''d probably want them to try again.
    For now, this algorithm either confirms it or lets the user know that it is now
    confirmed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the program, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3 – Output for a salted and hashed password confirmation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_15.03_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.3 – Output for a salted and hashed password confirmation
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding screenshot, the password was confirmed by
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see what happens when we enter two different passwords. Let's take
    a look at the following screenshot for that:![Figure 15.4 – Output for a salted
    and hashed password with confirmation fail
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_15.04_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.4 – Output for a salted and hashed password with confirmation fail
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the program asks the user to try again. However, the algorithm
    doesn't provide a way to do that unless the process is restarted. We can let it
    live like that or we can add conditions so that the program runs one more time,
    or two more times, or an infinite number of times, until a confirmation is reached.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's take a look at what happens if we run the algorithm using `sha256`
    instead of `sha1`. The following screenshot shows the result when a password is
    confirmed using `sha256`:![Figure 15.5 – Output when sha1 is replaced with sha256
    in the algorithm for confirming a password
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_15.05_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.5 – Output when sha1 is replaced with sha256 in the algorithm for
    confirming a password
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the hash has a longer length as regards the `sha256` algorithm.
    When we are working with cryptography, random and long are always helpful. It
    is easier to crack a password that is not random, such as `password` or `mycat`,
    than it is to crack a password that is very long and contains random numbers and
    letters. That's why we try to store data in ways that safeguard it against attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at what we could do to provide one more chance for someone
    to enter the password. At the end of the algorithm, let''s add some code after
    the last line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the last statement in our preceding snippet states `'Please try
    again later'`. This lets users know that if they want to save a password, they'll
    have to start the process again. The algorithm has, at that point, stopped.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we place the preceding code after our `else`, `print()` statement, then
    the algorithm will run one more time. The following screenshot shows the output
    when a user tries a second time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.6 – Output after running an algorithm with an incorrect match first'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_15.06_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.6 – Output after running an algorithm with an incorrect match first
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on from this example, notice that the hashed passwords provided
    are different even though our new password entered was `test` on both occasions.
    As we mentioned, the hashed password is created each time. Otherwise, everyone
    would know what the passwords were stored because `test` would be the same so
    long as we'd used the same hash, in this case, `sha256`.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot more to explore in cybersecurity and cryptography. This is just
    a taste of how we can encrypt information.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 7 – Using Python to create a chatbot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to create a simple chatbot. You've probably interacted with at least
    a dozen of these chatbots in the last few years. When you go to some websites,
    you might get a *person* who wants to chat with you and asks you a few simple
    questions, such as how you're doing, and what they can help you with. For most
    of those sites, the *person* is not a person, but a chatbot.
  prefs: []
  type: TYPE_NORMAL
- en: In some instances, the chatbots will then direct you to an actual human being.
    But most of the time, they'll just answer your questions by pointing you in the
    direction of the available answers on their website.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to create something like those chatbots here. There are some components
    we''ll need before we get started. One of them is an `intents` file. That file,
    which should be a `.json` file, contains the greetings and responses that the
    bot will be using and/or responding to. Here''s a sample of what the intents content
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is just a group of possible responses. The more data we
    give the `.json` file, the more robust and accurate our bot will be.
  prefs: []
  type: TYPE_NORMAL
- en: We should note that the `intents.json` file will need to be edited in a **JSON
    Editor**. There is an online editor you can use at [https://jsoneditoronline.org](https://jsoneditoronline.org)
    where you can create your own, or edit an existing, file.
  prefs: []
  type: TYPE_NORMAL
- en: '*Why would we need a bot?* There are a wide variety of uses for something like
    this, from creating and posting messages to social media to providing a customer
    with a bot that asks whether they require assistance as they visit a web page,
    for example. These are only some of the things we can do with a chatbot.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at an algorithm that creates a chatbot. The full file
    can be found in the repository. We''ve commented and described what goes on in
    some of the sections in snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by importing the libraries here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ch15_chatBot.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, note that you do not have to download the `nltk` modules
    each time. However, it won't hurt to have this code. The system won't install
    multiple copies each time; it will just identify that they are there and not install
    them a second time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue grabbing what we need from our libraries and packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have what we need, we have to look at our `.json` file. That file
    contains those intents, as mentioned earlier in this problem. We''ll need to not
    only open that file, but also divide the components and sort them in ways that
    our algorithm can understand. Take a look at the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the program won't run unless you specify the right location for
    the file you are trying to access, in this case, the `.json` file. Also notice
    this time that we are opening it in a slightly different manner, as shown in the
    preceding snippet. Opening the file like this, which is not the same as when we
    open `.csv` files with Pandas, means we do not need to use the double `\\` in
    the paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s tell the algorithm what to do with that file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are tokenizing our information, that is, we're breaking down everything
    into words and then adding them to lists. This is what makes it possible to process
    the information. After we split them up, we are going to group them by what the
    words mean.
  prefs: []
  type: TYPE_NORMAL
- en: 'The words are then sorted, as can be seen in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Notice in the preceding code that we used `pickle()`. Pickle is a method in
    Python that we can use to serialize data (or deserialize it). The method is used
    to then replace current file data so that it can be used as converted.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have done all of that, we need to create our training model. We
    won't go through all the sections of that process here, but the entire code can
    be found in the GitHub repository file. Remember that you first train, then create,
    and then compile the model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we have run through that process, we save the model so that we can use
    it. But now let''s look at the chatbot functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The first three functions work to create responses for the chatbot and also
    make predictions. Those classes will matter for how we get those responses from
    our bot. Let's think about it this way—if I say hello, I wouldn't want the chatbot
    to say goodbye. That would be rude. But remember that our bot is only as good
    as our training is. So if we don't have enough in the `.json` file and do not
    train the model correctly, the bot will be fairly useless.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s define how we get the responses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code snippet, the bot will craft a response
    and return it. We'll be calling those things in the next few pieces of code in
    our file.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we''ll skip that here and go into the look of our chatbot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we established some critical information in the preceding snippet.
    We established the size of the window and blocked it from being resized.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next code snippet, we''ll establish the background, add `scrollbar`,
    and establish the look of the **Send** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'So this is it, in a nutshell. *We created a chatbot!* *But what does it look
    like when it runs?* Take a look at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7 – The chatbot window'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_15.07_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.7 – The chatbot window
  prefs: []
  type: TYPE_NORMAL
- en: Notice our components, the scrollbar on the left, the pink **Send** button,
    and the title of our chatbot. And notice too that the maximize button is grayed
    out. That's because we said we don't want the window resized.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, when we click the **Send** button, we want the user to know whether
    it was clicked. Otherwise, you could click it multiple times if you are unsure.
    That''s why the active background color is changed in the code. The following
    screenshot shows what the button looks like when active:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.8 – Active Send button'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_15.08_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.8 – Active Send button
  prefs: []
  type: TYPE_NORMAL
- en: Many chatbots have features like this one so that we avoid errors with the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve said hello, the bot will respond. Before we move away from this
    problem, let''s take a look at a quick conversation with the chatbot in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.9 – The chatbot window with responses'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_15.09_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.9 – The chatbot window with responses
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a few lines of code and a file can be used to create an interactive
    experience with a chatbot.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to play around with the code to add some flair, create a different
    `intents.json` file, and make it more relevant to what you need.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've had a chance to explore Python in a few but very different
    applications while looking at actual problems.
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters, we learned about the computational thinking process, along
    with the elements of decomposition, pattern recognition, pattern generalization,
    and algorithm design, which make the algorithms make sense. When we tackle problems
    from clients or just while creating a script as a hobby, we have to go through
    the process necessary to define what we're creating with our algorithm. This critical
    process will ensure that we are designing the best possible algorithms we can.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned how to read from files, upload files, create ciphers
    and decoders, use algorithms to write stories with user input, and develop the
    most effective travel plan when given the cities we'll visit. In addition, we
    also created a basic chatbot, which can interact and adapt based on the user input.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue our exploration of Python and computational
    thinking with additional application problems in data analysis in scientific applications,
    housing, stock market analyses, and more.
  prefs: []
  type: TYPE_NORMAL
