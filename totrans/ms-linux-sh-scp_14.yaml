- en: Chapter 14. Using Python as a Bash Scripting Alternative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python is another scripting language and the newest that we have looked at
    so far. Similar to bash and Perl, Python is an interpreted language and makes
    use of the shebang. Although, it does not have a shell interface, we can access
    a console called the REPL where we can type Python codes to interact with the
    system. In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Python?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saying Hello the Python way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pythonic arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Significant whitespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read user input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Python to write to files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Python?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is an object-oriented interpreted language that is designed to be easy
    to use and to aid Rapid Application Development. This is achieved by the use of
    simplified semantics in the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python was born at the end of the 1980''s, towards the very end of December
    1989 by the Dutch developer, Guido van Rossum. A majority of the design of the
    language is aimed at clarity and simplicity and one of the main rules of the *Zen
    of Python* is:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"There should be one, and preferable only one, obvious way to do it."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Often systems will have both Python 2 and Python 3 installed; however, all newer
    distributions are switching to Python 3\. We will be working with Python 3, it
    being the latest version installed on the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although, there is no shell, we can interact with Python using REPL: read,
    evaluate, print, and loop. We can access this by typing `python3` in the command
    line. You should see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is Python?](img/00130.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that we are presented with the **>>>** prompt and this is known as
    the REPL console. We should emphasize that this is a scripting language and like
    bash and Perl, we will normally execute a code through the text files that we
    create. Those text files will normally be expected to have a `.py` suffix to their
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'While working with REPL, we can print the version independently by importing
    a module. In Perl, we will use the keyword, in bash we will use the command source
    and in Python we use `import`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With the module loaded, we can now investigate the object-oriented nature of
    Python by printing the version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We will navigate to the sys object within our namespace and call the version
    method from that object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Combining these two commands together, we should be able to see the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is Python?](img/00131.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To close this section about describing Python, we should take a look at the
    **Zen of Python**. From REPL, we can type `import this`, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is Python?](img/00132.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is far more than just the Zen of Python; it actually makes up a good rule
    for all programming languages and a guide for developers.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close the REPL, we will use *Ctrl* + *d* in Linux or *Ctrl* + *z*
    in Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Saying Hello World the Python way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code we write in Python should be clear and uncluttered, sparse is better
    than dense. We will need the shebang on the first line and then the `print` statement.
    The `print` function includes the newline and we do not need semicolons at the
    end of the line. We can see the edited version of `$HOME/bin/hello.py` in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will still need to add the execute permission, but we can run the code as
    earlier using `chmod`. This shown in the following command but we should be a
    little used to this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can now execute the code to see our greeting.
  prefs: []
  type: TYPE_NORMAL
- en: Again, knowing at least one language makes it easier to adapt to others and
    there is not a lot of new features in this.
  prefs: []
  type: TYPE_NORMAL
- en: Pythonic arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We should know by now that we will want to be able to pass command-line arguments
    to Python and we can do this using the `argv` array similar to Perl. However,
    we are more like bash, with Python we combine the program name into the array
    with the other arguments. Python also uses lowercase instead of uppercase in the
    object name.
  prefs: []
  type: TYPE_NORMAL
- en: The `argv` array is a part of the `sys` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sys.argv[0]` is the script name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sys.argv[1]` is the first argument supplied to the script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sys.argv[2]` is the second supplied argument and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The argument count will always be at least 1, so, keep this in mind when checking
    for supplied arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supplying arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we create the `$HOME/bin/args.py` file we can see this in action. The file
    should be created as follows and made executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the script with a supplied argument, we should be able to see something
    similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Supplying arguments](img/00133.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our code is still quite clean and simple; however, we may have noticed that
    we cannot combine the quoted text in the `print` statement with the argument.
    We use the `+` symbol to join or concatenate the two strings together. As there
    is no specific symbol to denote a variable or any other type of object, they cannot
    appear as a static text within quotes.
  prefs: []
  type: TYPE_NORMAL
- en: Counting arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As it was previously mentioned, the script name is the first argument at index
    `0` of the array. So, if we try to count the arguments, then the count should
    always be at the very least one In other words, if we have not supplied arguments,
    the argument count will be one. To count the items in an array, we can use the
    `len()` function. If we edit the script to include a new line we will see this
    work, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the code as we have earlier, we can see that we have supplied two
    arguments. The script name and then the string `fred`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Counting arguments](img/00134.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we try and have a single `print` statement to print the output and the number
    of arguments, then we will find that Python does not like mixing data types. The
    length value is an integer and this cannot be mixed with strings without conversion.
    The following code will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this is not a mammoth task and just requires an explicit conversion.
    From the Zen of Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Explicit is better than implicit."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The code will work if modified, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to run the script and omit to supply an argument, then there will
    be a null value in the array when we reference index `1`. This will give an error,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Counting arguments](img/00135.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We of course need to handle this to prevent the error and we can now pass into
    the section of significant whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: Significant whitespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A major difference between Python and most other languages is that additional
    whitespace can mean something. The indent level of your code defines the block
    of code to which it belongs. So far, we have not indented the code we have created
    past the start of the line. This means that all of the code is at the same indent
    level and belongs to the same code block. Rather than using brace brackets or
    do and done keywords to define the code block, we use indents. If we indent with
    four spaces, then we must stick to those four spaces. When we return to the previous
    indent level, we return to the previous code block.
  prefs: []
  type: TYPE_NORMAL
- en: 'This seems complex but it is really quite simple and keeps your code clean
    and uncluttered. If we edit the `arg.py` file to prevent unwelcomed errors, if
    an argument is not supplied, we can see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement checks if the argument count is greater than `1` or not.
    We now store for ease, the argument count has its own variable, which we call
    `count`. The code block starts with the colon and then all of the following code
    that is indented to four spaces is part of the code that will execute when the
    condition returns to true.
  prefs: []
  type: TYPE_NORMAL
- en: When we return to the previous indent level, we return to the main code block
    and we execute the code regardless of the status of the condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this illustrated in the following screenshot, where we can execute
    the script with and without the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Significant whitespace](img/00136.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Reading user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we want the welcome message to greet us by name no matter whether we supply
    the argument to the script or not, we can add in a prompt to capture the data
    while the script is running. Python makes this simple and easy to implement. We
    can see from the edited file shown in the screenshot that follows how this is
    achieved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reading user input](img/00137.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We make use of a new variable in the script that we set in the main block initially,
    to be an empty string. Set it here to make the variable available to the complete
    script and all code blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The `input` function in Python 3 or `raw_input` can be used in Python 2 to gain
    user input. We store that input in the `name` variable. If we have supplied an
    argument we pick it up on the code in the `else` block and set the `name` variable
    to the first supplied argument. It is this that is used in the `print` statement
    back in the main block.
  prefs: []
  type: TYPE_NORMAL
- en: Using Python to write to files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add some variety to this chapter, we will now look at printing this data
    to a file. Again using Python, this is quite a simple and easy way to pick up.
    We will start by making a copy of our existing `args.py`. We will copy this to
    `$HOME/bin/file.py`. The new `file.py` should read similar to the following screenshot
    and have the execute permission set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Python to write to files](img/00138.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You will notice that we have just altered the final lines and instead of print
    we now open a file. We also see more of the object-orientated life of Python that
    dynamically assigns the `write()` and `close()` methods to the object log, as
    it is seen as an instance of a file. When we open the file, we open it up for
    the purpose of appending, meaning that we do not overwrite the existing content
    if it is already there. If the file is not there, we will create a new file. If
    we use `w`, we will open the file for writing, which might translate to overwriting,
    so take care.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that this is an easy task and this is why Python is used in many
    applications and is taught widely in schools.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This now finishes our look at Python and it certainly has been a brief tour.
    We can again emphasize the similarities that you will see in many languages and
    the importance of learning any coding language. What you learn in one language
    will help in most of the other languages that you come across.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we learn from the Zen of Python will help us design and develop a great
    code. We can print the Zen of Python using the following Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can type the code on the REPL prompt. Keeping your code clean and well-spaced
    out will aid in the readability and ultimately this will help with the maintenance
    of the code.
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen that the Python likes you to be explicit in your code and
    will not implicitly convert the data types.
  prefs: []
  type: TYPE_NORMAL
- en: We are also at the end of the book but hopefully, the start of your scripting
    career. Good luck and thank you for reading.
  prefs: []
  type: TYPE_NORMAL
