- en: Authenticating Users with a Microservice
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: Now that our Notes application can save its data in a database, we can think
    about the next phase of making this a real application—namely, authenticating
    our users.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: It's so natural to log in to a website to use its services. We do it every day,
    and we even trust banking and investment organizations to secure our financial
    information through login procedures on a website. The **HyperText Transfer Protocol**
    (**HTTP**) is a stateless protocol, and a web application cannot tell much about
    one HTTP request compared with another. Because HTTP is stateless, HTTP requests
    do not natively know the user's identity, whether the user driving the web browser
    is logged in, or even whether the HTTP request was initiated by a human being.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The typical method for user authentication is to send a cookie containing a
    token to the browser, to carry the user's identity, and indicate whether that
    browser is logged in.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: With Express, the best way to do this is with the `express-session` middleware,
    which handles session management with a cookie. It is easy to configure but is
    not a complete solution for user authentication since it does not handle user
    login/logout.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The package that appears to be leading the pack in user authentication is Passport
    ([http://passportjs.org/](http://passportjs.org/)). In addition to authenticating
    users against local user information, it supports a long list of third-party services
    against which to authenticate. With this, a website can be developed that lets
    users sign up with credentials from another website—Twitter, for example.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: We will use Passport to authenticate users against either a locally stored database
    or a Twitter account. We'll also take this as an opportunity to explore a **representational
    state transfer** (**REST**)-based microservice with Node.js.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: The rationale is the greater opportunity to increase security by storing user
    information in a highly protected enclave. Many application teams store user information
    in a well-protected barricaded area with a strictly controlled **application programming
    interface** (**API**), and even physical access to the user information database,
    implementing as many technological barriers as possible against unapproved access.
    We're not going to go quite that far, but by the end of the book, the user information
    service will be deployed in its own Docker container.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll discuss the following three aspects of this phase:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Creating a microservice to store user profile/authentication data.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating a user with a locally stored password.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using OAuth2 to support authentication via third-party services. Specifically,
    we'll use Twitter as a third-party authentication service.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do is to duplicate the code used for the previous chapter.
    For example, if you kept that code in the `chap07/notes` directory, create a new
    directory, `chap08/notes`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Creating a user information microservice
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could implement user authentication and accounts by simply adding a user
    model and a few routes and views to the existing *Notes* application. While that's
    easy, is this what is done in a real-world production application?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Consider the high value of user identity information and the super-strong need
    for robust and reliable user authentication. Website intrusions happen regularly,
    and it seems the item most frequently stolen is user identities. To that end,
    we declared earlier an intention to develop a user information microservice, but
    we must first discuss the technical rationale for doing so.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Microservices are not a panacea, of course, meaning we shouldn't try to force-fit
    every application into the microservice box. By analogy, microservices fit with
    the Unix philosophy of small tools, each doing one thing well, which we mix/match/combine
    into larger tools. Another word for this is composability. While we can build
    a lot of useful software tools with that philosophy, does it work for applications
    such as Photoshop or LibreOffice?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: This is why microservices are popular today among application teams. Microservice
    architectures are more agile if used well. And, as we noted earlier, we're aiming
    for a highly secured microservice deployment.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'With that decision out of the way, there are two other decisions to be made
    with regard to security implications. They are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Do we create our own REST application framework?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we create our own user login/authentication framework?
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In many cases, it is better to use a well-regarded existing library where the
    maintainers have already stomped out lots of bugs, just as we used the Sequelize
    **ORM** (**Object-Relational Mapping**) library in the previous chapter, because
    of its maturity. We have identified two libraries for this phase of the Notes
    project.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: We already mentioned using Passport for user login support, as well as authenticating
    Twitter users.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: For REST support, we could have continued using Express, but instead will use
    Restify ([http://restify.com/](http://restify.com/)), which is a popular REST-centric
    application framework.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: To test the service, we'll write a command-line tool for administering user
    information in the database. We won't be implementing an administrative user interface
    in the Notes application, and will instead rely on this tool to administer the
    users. As a side effect, we'll have a tool for testing the user service.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Once this service is functioning correctly, we'll set about modifying the Notes
    application to access user information from the service, while using Passport
    to handle authentication.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to create a new directory to hold the user information microservice.
    This should be a sibling directory to the Notes application. If you created a
    directory named `chap08/notes` to hold the Notes application, then create a directory
    named `chap08/users` to hold the microservice.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `chap08/users` directory, run the following commands:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]js\1'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: As with our Sequelize-based model for Notes, we will use a **YAML Ain't Markup
    Language** (**YAML**) file to store connection configuration. We're even using
    the same environment variable, `SEQUELIZE_CONNECT`, and the same approach to overriding
    fields of the configuration. The approach is similar, with a `connectDB` function
    setting up the connection and initializing the SQUsers table.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: With this approach, we can use a base configuration file in the `SEQUELIZE_CONNECT`
    variable and then use the other environment variables to override its fields. 
    This will be useful when we start deploying Docker containers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The user profile schema shown here is derived from the normalized profile provided by
    Passport—for more information, refer to [http://www.passportjs.org/docs/profile](http://www.passportjs.org/docs/profile).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The Passport project developed this object by harmonizing the user information
    given by several third-party services into a single object definition. To simplify
    our code, we're simply using the schema defined by Passport.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several functions to create that will be an API to manage user data.
    Let''s add them to the bottom of `users-sequelize.mjs`, starting with the following
    code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]js\1'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'When we fetch an SQUser object from the database, Sequelize obviously gives
    us a Sequelize object that has many extra fields and functions used by Sequelize.
    We don''t want to send that data to our callers. Furthermore, we think it will
    increase security to not provide the *password* data beyond the boundary of this
    server. This function produces a simple, sanitized, anonymous JavaScript object
    from the SQUser instance. We could have defined a full JavaScript class, but would
    that have served any purpose? This anonymous JavaScript class is sufficient for
    this simple server, as illustrated in the following code block:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]js\1'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: This is just like the configuration files we used in the previous chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: That's what we need for the database side of this service. Let's now move on
    to creating the REST service.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Creating a REST server for user information
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The user information service is a REST server to handle user information data
    and authentication. Our goal is, of course, to integrate that with the Notes application,
    but in a real project, such a user information service could be integrated with
    several web applications. The REST service will provide functions we found useful
    while developing the user login/logout support in Notes, which we'll show later
    in the chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `package.json` file, change the `main` tag to the following line of
    code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]js\1'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, this is how we'll start our server. It uses the configuration file
    from the previous section and specifies that we'll listen on port `5858`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, create a file named `user-server.mjs` containing the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]js\1'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: This handler executes for every request and immediately follows `restify.plugins.authorizationParser`.
    It looks for authorization data—specifically, HTTP basic authorization—to have
    been supplied in the HTTP request. It then loops through the list of keys in the
    `apiKeys` array, and if the Basic Auth parameters supplied matched, then the caller
    is accepted.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: This should not be taken as an example of a best practice since HTTP Basic Auth
    is widely known to be extremely insecure, among other issues. But it demonstrates
    the basic concept, and also shows that enforcing token-based authorization is
    easily done with a similar handler.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: This also shows us the function signature of a Restify handler function—namely,
    that it is the same signature used for Express middleware, the `request` and `result`
    objects, and the `next` callback.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: There is a big difference between Restify and Express as to how the `next` callback
    is used. In Express, remember that a middleware function calls `next` unless that
    middleware function is the last function on the processing chain—for example if
    the function has called `res.send` (or equivalent) to send a response to the caller.
    In Restify, every handler function calls `next`. If a handler function knows it
    should be the last function on the handler chain, then it uses `next(false)`;
    otherwise, it calls `next()`. If a handler function needs to indicate an error,
    it calls `next(err)`, where `err` is an object where `instanceof Error` is `true`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following hypothetical handler function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]js\1'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: This is just the starting point of the command-line tool. For most of the REST
    handler functions, we'll also implement a sub-command in this tool. We'll take
    care of that code in the subsequent sections. For now, let's focus on how the
    command-line tool is set up.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: The Commander project suggests we name the default import `program`, as shown
    in the preceding code block. As mentioned earlier, we declare the command-line
    options and sub-commands by calling methods on this object.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to properly parse the command line, the last line of code in `cli.mjs` must
    be as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]js\1'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: This declares an option, either `-p` or `--port`, that Commander will parse
    out of the command line. Notice that all we do is write a text string and, from
    that, Commander knows it must parse these options. Isn't this easy?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: When it sees one of these options, the `<port>` declaration tells Commander
    that this option requires an argument. It will parse that argument out of the
    command line, and then assign it to `program.port`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, `program.port`, `program.host`, and `program.url` were all declared
    in a similar way. When Commander sees those options, it will create the matching
    variables, and then our `client` function will take that data and modify `connect_url`
    appropriately.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the side effects of these declarations is that Commander can generate
    help text automatically. The result we''ll achieve is being able to type the following
    code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]js\1'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: This handles a `POST` request on the `/create-user` URL. This should look very
    similar to an Express route handler function, apart from the use of the `next`
    callback. Refer back to the discussion on this. As we did with the Notes application,
    we declare the handler callback as an async function and then use a `try`/`catch`
    structure to catch all errors and report them as errors.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: The handler starts with `connectDB` to ensure the database is set up. Then,
    if you refer back to the `createUser` function, you see it gathers up the user
    data from the request parameters and then uses `SQUser.create` to create an entry
    in the database. What we will receive here is the sanitized user object, and we
    simply return that to the caller.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also add the following code to `user-server.mjs`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]js\1'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: By using `program.command`, we are declaring a sub-command—in this case, `add`.
    The `<username>` declaration says that this sub-command takes an argument. Commander
    will provide that argument value in the `username` parameter to the function passed
    in the `action` method.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: The structure of a `program.command` declaration is to first declare the syntax
    of the sub-command. The `description` method provides user-friendly documentation.
    The `option` method calls are options for this sub-command, rather than global
    options. Finally, the `action` method is where we supply a callback function that
    will be invoked when Commander sees this sub-command in the command line.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Any arguments declared in the `program.command` string end up as parameters
    to that callback function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Any values for the options for this sub-command will land in the `cmdObj` object.
    By contrast, the value for global options is attached to the `program` object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: With that understanding, we can see that this sub-command gathers information
    from the command line and then uses the `client` function to connect to the server.
    It invokes the `/create-user` URL, passing along the data gathered from the command
    line. Upon receiving the response, it will print either the error or the result
    object.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add the sub-command corresponding to the `/find-or-create` URL,
    as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]js\1'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'We run this in one command window to start the server. In another command window,
    we can run the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]js\1'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, we have success with the `find-or-create` command.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: That gives us the ability to create SQUser objects. Next, let's see how to read
    from the database.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Reading user data from the user information service
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing we want to support is to look for users in the user information
    service. Instead of a general search facility, the need is to retrieve an SQUser
    object for a given username. We already have the utility function for this purpose;
    it's just a matter of hooking up a REST endpoint.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'In `user-server.mjs`, add the following function:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]js\1'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: We know from the previous chapter that the `findAll` operation retrieves all
    matching objects and that passing an empty query selector such as this causes
    `findAll` to match every SQUser object. Therefore, this performs the task we described,
    to retrieve information on all users.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in `cli.mjs`, we add the following sub-command declarations:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]js\1'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: And, indeed, the results came in as we expected.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: The next operation we need is to update an SQUser object.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Updating user information in the user information service
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next functionality to add is to update user information. For this, we can
    use the Sequelize `update` function, and simply expose it as a REST operation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'To that end, add the following code to `user-server.mjs`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]js\1'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: As expected, this sub-command must take the same set of user information parameters.
    It then bundles those parameters into an object, posting it to the `/update-user`
    endpoint on the REST server.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to test the result, we run the command, like so:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]js\1'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: This is simple enough. We first look up the user to ensure it exists, and then
    call the `destroy` function on the SQUser object. There's no need for any result,
    so we send an empty object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'To exercise this function, add the following code to `cli.mjs`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]js\1'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: First, we deleted Snuffy's user record, and it gave us an empty response, as
    expected. Then, we tried to retrieve his record and, as expected, there was an
    error.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: While we have completed the CRUD operations, we have one final task to cover.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Checking the user's password in the user information service
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'How can we have a user login/logout service without being able to check their
    password? The question is: Where should the password check occur? It seems, without
    examining it too deeply, that it''s better to perform this operation inside the
    user information service. We earlier described the decision that it''s probably
    safer to never expose the user password beyond the user information service. As
    a result, the password check should occur in that service so that the password
    does not stray beyond the service.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the following function in `user-server.mjs`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]js\1'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: And, as expected, the code to invoke this operation is simple. We take the `username`
    and `password` parameters from the command line, send them to the server, and
    then print the result.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that it works, run the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]js\1'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, create a new file, `models/users-superagent.mjs`, containing the following
    code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]js\1'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: These are our `create` and `update` functions. In each case, they take the data
    provided, construct an anonymous object, and `POST` it to the server. The function
    is to be provided with the values corresponding to the SQUser schema. It bundles
    the data provided in the `send` method, sets various parameters, and then sets
    up the Basic Auth token.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: The SuperAgent library uses an API style called *method chaining*. The coder
    chains together method calls to construct a request. The chain of method calls
    can end in a `.then` or `.end` clause, either of which takes a callback function.
    But leave off both, and it will return a Promise, and, of course, Promises let
    us use this directly from an async function.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The `res.body` value at the end of each function contains the value returned
    by the REST server. All through this library, we'll use the `.auth` clause to
    set up the required authentication key.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'These anonymous objects are a little different than normal. We''re using a
    new **ECMAScript 2015** (**ES-2015**) feature here that we haven''t discussed
    so far. Rather than specifying the object fields using the `fieldName: fieldValue` notation,
    ES-2015 gives us the option to shorten this when the variable name used for `fieldValue` matches
    the desired `fieldName`. In other words, we can just list the variable names,
    and the field name will automatically match the variable name.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we've purposely chosen variable names for the parameters to match
    the field names of the object with parameter names used by the server. In doing
    so, we can use this shortened notation for anonymous objects, and our code is
    a little cleaner by using consistent variable names from beginning to end.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following function to support the retrieval of user records:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]js\1'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: One point about this method is worth noting. It could have taken the parameters
    in the URL instead of the request body, as is done here. But since request URLs
    are routinely logged to files, putting the username and password parameters in
    the URL means user identity information would be logged to files and be part of
    activity reports. That would obviously be a very bad choice. Putting those parameters
    in the request body not only avoids that bad result but if an HTTPS connection
    to the service were used, the transaction would be encrypted.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, let''s create our `find-or-create` function, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]js\1'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: As before, this is very straightforward.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: With this module, we can interface with the user information service, and we
    can now proceed with modifying the Notes user interface.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating login and logout routing functions in the Notes application
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we've built so far is a user data model, with a REST API wrapping that
    model to create our authentication information service. Then, within the Notes
    application, we have a module that requests user data from this server. As yet,
    nothing in the Notes application knows that this user model exists. The next step
    is to create a routing module for login/logout URLs and to change the rest of
    Notes to use user data.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'The routing module is where we use `passport` to handle user authentication.
    The first task is to install the required modules, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]js\1'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Express Session support, including all the various Session Store implementations,
    is documented on its GitHub project page at [https://github.com/expressjs/session](https://github.com/expressjs/session).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The strategy implemented in the `passport-local` package authenticates solely
    using data stored locally to the application—for example, our user authentication
    information service. Later, we'll add a strategy module to authenticate the use
    of OAuth with Twitter.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating the routing module, `routes/users.mjs`, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]js\1'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The `initPassport` function will be called from `app.mjs`, and it installs the
    Passport middleware in the Express configuration. We'll discuss the implications
    of this later when we get to `app.mjs` changes, but Passport uses sessions to
    detect whether this HTTP request is authenticated. It looks at every request coming
    into the application, looks for clues about whether this browser is logged in, and
    attaches data to the request object as `req.user`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The `ensureAuthenticated` function will be used by other routing modules and
    is to be inserted into any route definition that requires an authenticated logged-in
    user. For example, editing or deleting a note requires the user to be logged in
    and, therefore, the corresponding routes in `routes/notes.mjs` must use `ensureAuthenticated`.
    If the user is not logged in, this function redirects them to `/users/login` so
    that they can log in.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following route handlers in `routes/users.mjs`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]js\1'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: When the user requests to log out of Notes, they are to be sent to `/users/logout`.
    We'll be adding a button to the header template for this purpose. The `req.logout`
    function instructs Passport to erase their login credentials, and they are then
    redirected to the home page.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: This function deviates from what's in the Passport documentation. There, we
    are told to simply call `req.logout`, but calling only that function sometimes
    results in the user not being logged out. It's necessary to destroy the session
    object, and to clear the cookie, in order to ensure that the user is logged out.
    The cookie name is defined in `app.mjs`, and we imported `sessionCookieName` for
    this function.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `LocalStrategy` to Passport, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]js\1'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The preceding functions take care of encoding and decoding authentication data
    for the session. All we need to attach to the session is the `username`, as we
    did in `serializeUser`. The `deserializeUser` object is called while processing
    an incoming HTTP request and is where we look up the user profile data. Passport will
    attach this to the request object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Login/logout changes to app.mjs
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A number of changes are necessary in `app.mjs`, some of which we've already
    touched on. We did carefully isolate the Passport module dependencies to `routes/users.mjs`.
    The changes required in `app.mjs` support the code in `routes/users.mjs`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an import to bring in functions from the User router module, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]js\1'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Because Passport uses sessions, we need to enable session support in Express,
    and these modules do so. The `session-file-store` module saves our session data
    to disk so that we can kill and restart the application without losing sessions.
    It's also possible to save sessions to databases with appropriate modules. A filesystem
    session store is suitable only when all Notes instances are running on the same
    server computer. For a distributed deployment situation, you'll need to use a
    session store that runs on a network-wide service, such as a database.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: We're defining `sessionCookieName` here so that it can be used in multiple places.
    By default, `express-session` uses a cookie named `connect.sid` to store the session
    data. As a small measure of security, it's useful when there's a published default
    to use a different non-default value. Any time we use the default value, it's
    possible that an attacker might know a security flaw, depending on that default.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `app.mjs`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]js\1'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: This is the same initialization, but using `MemoryStore` instead of `FileStore`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about session store implementations see:  [http://expressjs.com/en/resources/middleware/session.html#compatible-session-stores](http://expressjs.com/en/resources/middleware/session.html#compatible-session-stores)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Mount the User router, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]js\1'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we ensured that `req.user` has the user profile data, which we
    did in `deserializeUser`. We simply check for this and make sure to add that data
    when rendering the views template.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: We'll be making similar changes to most of the other route definitions. After
    that, we'll go over the changes to the view templates, in which we use `req.user`
    to show the correct buttons on each page.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Login/logout changes required in routes/notes.mjs
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The changes required here are more significant but still straightforward, as
    shown in the following code snippet:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]js\1'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: We'll be making similar changes throughout this module, adding calls to `ensureAuthenticated`
    and using `req.user` to check whether the user is logged in. The goal is for several
    routes to ensure that the route is only available to a logged-in user, and—in
    those and additional routes—to pass the `user` object to the template.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we added is to call `usersRouter.ensureAuthenticated` in the
    route definition. If the user is not logged in, they'll be redirected to `/users/login` thanks
    to that function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Because we've ensured that the user is authenticated, we know that `req.user`
    will already have their profile information. We can then simply pass it to the
    view template.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: For the other routes, we need to make similar changes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `/save` route handler, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]js\1'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: For this route, we don't require the user to be logged in. We do need the user's
    profile information, if any, sent to the view template.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `/edit` and `/destroy` route handlers, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]js\1'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: What we're doing here is controlling which buttons to display at the top of
    the screen, depending on whether the user is logged in. The earlier changes ensure
    that the `user` variable will be `undefined` if the user is logged out; otherwise,
    it will have the user profile object. Therefore, it's sufficient to check the
    `user` variable, as shown in the preceding code block, to render different user
    interface elements.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是控制屏幕顶部显示哪些按钮，这取决于用户是否已登录。较早的更改确保了如果用户已注销，则`user`变量将为`undefined`；否则，它将具有用户配置文件对象。因此，只需检查`user`变量即可，如前面的代码块所示，以渲染不同的用户界面元素。
- en: A logged-out user doesn't get the ADD Note button and gets a Log in button.
    Otherwise, the user gets an ADD Note button and a Log Out button. The Log in button
    takes the user to `/users/login`, while the Log Out button takes them to `/users/logout`.
    Both of those buttons are handled in `routes/users.js` and perform the expected
    function.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 未登录的用户不会看到“添加笔记”按钮，并会看到一个登录按钮。否则，用户会看到“添加笔记”按钮和一个注销按钮。登录按钮将用户带到`/users/login`，而注销按钮将他们带到`/users/logout`。这两个按钮都在`routes/users.js`中处理，并执行预期的功能。
- en: The Log Out button has a Bootstrap badge component displaying the username. This
    adds a little visual splotch in which we'll put the username that's logged in. As
    we'll see later, it will serve as a visual clue to the user as to their identity.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注销按钮具有Bootstrap徽章组件显示用户名。这为已登录的用户名提供了一个小的视觉标识。稍后我们将看到，它将作为用户身份的视觉提示。
- en: Because `nav` is now supporting login/logout buttons, we have changed the `navbar-toggler`
    button so that it controls a `<div>` with `id="navbarLogIn"`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`nav`现在支持登录/注销按钮，我们已经更改了`navbar-toggler`按钮，以便它控制具有`id="navbarLogIn"`的`<div>`。
- en: 'We need to create `views/login.hbs`, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建`views/login.hbs`，如下所示：
- en: '[PRE31]js\1'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE31]js\1'
- en: That's straightforward—if the user is logged in, display the form; otherwise,
    display the message in `partials/not-logged-in.hbs`. We determine which of these
    to display based on the `user` variable.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单 - 如果用户已登录，则显示表单；否则，在`partials/not-logged-in.hbs`中显示消息。我们根据`user`变量确定要显示其中哪一个。
- en: 'We could insert something such as the code shown in the following block in
    `partials/not-logged-in.hbs`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`partials/not-logged-in.hbs`中插入以下代码块中显示的代码：
- en: '[PRE32]js\1'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE32]js\1'
- en: That is, at the bottom we add a segment that, for non-logged-in users, pulls
    in the `not-logged-in` partial.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，在底部我们添加了一个段落，对于未登录的用户，引入了`not-logged-in`部分。
- en: The **Bootstrap jumbotron** component makes a nice and large text display that
    stands out nicely and will catch the viewer's attention. However, the user should
    never see this because each of those templates is used only when we've pre-verified
    the fact that the user is logged in.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bootstrap jumbotron**组件可以创建一个漂亮而大的文本显示，非常引人注目。然而，用户不应该看到这一点，因为这些模板只在我们预先验证用户已登录时使用。'
- en: A message such as this is useful as a check against bugs in your code. Suppose
    that we slipped up and failed to properly ensure that these forms were displayed
    only to logged-in users. Suppose that we had other bugs that didn't check the
    form submission to ensure it's requested only by a logged-in user. Fixing the
    template in this way is another layer of prevention against displaying forms to
    users who are not allowed to use that functionality.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的消息对于检查代码中的错误非常有用。假设我们疏忽了，并且未能确保这些表单仅显示给已登录用户。假设我们有其他错误，未检查表单提交以确保它仅由已登录用户请求。以这种方式修复模板是另一层防止向未被允许使用该功能的用户显示表单的预防措施。
- en: We have now made all the changes to the user interface and are ready to test
    the login/logout functionality.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经对用户界面进行了所有更改，并准备测试登录/注销功能。
- en: Running the Notes application with user authentication
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用用户身份验证运行Notes应用程序
- en: We have created the user information REST service, created a module to access
    that service from Notes,  modified the router modules to correctly access the
    user information service, and changed other things required to support login/logout.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了用户信息REST服务，创建了一个模块来从Notes访问该服务，修改了路由模块以正确访问用户信息服务，并更改了其他支持登录/注销所需的内容。
- en: 'The final task that is necessary is to change the scripts section of `package.json`,
    as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 必要的最后一个任务是修改`package.json`的脚本部分，如下所示：
- en: '[PRE33]js\1'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE33]js\1'
- en: 'Then, in another window, start the Notes application, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在另一个窗口中，按照以下方式启动Notes应用程序：
- en: '[PRE34]js\1'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE34]js\1'
- en: 'The documentation says we should load the `dotenv` package and then call `dotenv.config()`
    very early in the start up phase of our application, and that we must do this
    before accessing any environment variables. However, reading the documentation
    more closely, it seems best to add the following code to `app.mjs`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 文档表示我们应该加载`dotenv`包，然后在应用程序启动阶段非常早的时候调用`dotenv.config()`，并且我们必须在访问任何环境变量之前这样做。然而，仔细阅读文档后，似乎最好将以下代码添加到`app.mjs`中：
- en: '[PRE35]js\1'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE35]js\1'
- en: This is exactly the syntax we'd expect since it is the same as for shell scripts.
    In this file, we need two variables to be defined, `TWITTER_CONSUMER_KEY` and `TWITTER_CONSUMER_SECRET`.
    We will use these variables in the code we'll write in the next section. Since
    we are putting configuration values in the `scripts` section of `package.json`,
    feel free to add those environment variables to `.env` as well.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们期望的语法，因为它与shell脚本的语法相同。在这个文件中，我们需要定义两个变量，`TWITTER_CONSUMER_KEY`和`TWITTER_CONSUMER_SECRET`。我们将在下一节中编写的代码中使用这些变量。由于我们正在将配置值放在`package.json`的`scripts`部分中，因此可以将这些环境变量添加到`.env`中。
- en: 'The next step is to avoid committing this file to a source code control system
    such as Git. To ensure that this does not happen, you should already have a `.gitignore`
    file in the `notes` directory, and make sure its contents are something like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是避免将此文件提交到Git等源代码控制系统中。为了确保这不会发生，您应该已经在`notes`目录中有一个`.gitignore`文件，并确保其内容类似于以下内容：
- en: '[PRE36]js\1'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE36]js\1'
- en: 'In `routes/users.mjs`, let''s start making some changes, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]js\1'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: This registers a `TwitterStrategy` instance with `passport`, arranging to call
    the user authentication service as users register with the Notes application.
    This `callback` function is called when users successfully authenticate using
    Twitter.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: If the environment variables containing the Twitter tokens are not set, then
    this code does not execute. Clearly, it would be an error to set up Twitter authentication
    without the keys, so we avoid the error by not executing the code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: To help other code know whether Twitter support is enabled, we export a flag
    variable - `twitterLogin`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: We defined the `usersModel.findOrCreate` function specifically to handle user
    registration from third-party services such as Twitter. Its task is to look for
    the user described in the profile object and, if that user does not exist, to
    create that user account in Notes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The `consumerKey` and `consumerSecret` values are supplied by Twitter, after
    you've registered your application. These secrets are used in the OAuth protocol
    as proof of identity to Twitter.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The `callbackURL` setting in the `TwitterStrategy` configuration is a holdover
    from Twitter's OAuth1-based API implementation. In OAuth1, the callback URL was
    passed as part of the OAuth request. Since `TwitterStrategy` uses Twitter's OAuth1
    service, we have to supply the URL here. We'll see in a moment where that URL
    is implemented in Notes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: The `callbackURL`, `consumerKey`, and `consumerSecret` settings are all injected
    using environment variables. Earlier, we discussed how it is a best practice to
    not commit the values for `consumerKey` and `consumerSecret` to a source repository,
    and therefore we set up the `dotenv` package and a `.env` file to hold those configuration
    values. In Chapter 10,* Deploying Node.js Applications to Linux Servers*, we'll
    see that these keys can be declared as environment variables in a Dockerfile.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following route declaration:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]js\1'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: This route handles the callback URL, and it corresponds to the `callbackURL`
    setting configured earlier. Depending on whether it indicates a successful registration,
    Passport will redirect the browser to either the home page or back to the `/users/login`
    page.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Because `router` is mounted on `/user`, this URL is actually `/user/auth/twitter/callback`.
    Therefore, the full URL to use in configuring the `TwitterStrategy`, and to supply
    to Twitter, is `http://localhost:3000/user/auth/twitter/callback`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: In the process of handling the callback URL, Passport will invoke the callback
    function shown earlier. Because our callback uses the `usersModel.findOrCreate`
    function, the user will be automatically registered if necessary.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: We're almost ready, but we need to make a couple of small changes elsewhere in
    Notes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'In `partials/header.hbs`, make the following changes to the code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]js\1'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: This imports the variable, and then, in the data passed to `res.render`, we
    add this variable. This will ensure that the value reaches `partials/header.hbs`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'In `routes/notes.mjs`, we have a similar change to make in several router functions:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]js\1'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, use a browser to visit `http://localhost:3000`, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2eaeb209-1f22-424a-ab86-0563fa7474c1.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: Notice the new button. It looks about right, thanks to having used the official
    Twitter branding image. The button is a little large, so maybe you want to consult
    a designer. Obviously, a different design is required if you're going to support
    dozens of authentication services.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Run it while leaving out the Twitter token environment variables, and the Twitter
    login button should not appear.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on this button takes the browser to `/users/auth/twitter`, which is
    meant to start Passport running the OAuth protocol transactions necessary to authenticate.
    Instead, you may receive an error message that states Callback URL not approved
    for this client application. Approved callback URLs can be adjusted in your application
    settings. If this is the case, it is necessary to adjust the application configuration
    on `developer.twitter.com`. The error message is clearly saying that Twitter saw
    a URL being used that was not approved.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'On the page for your application, on the App Details tab, click the Edit button.
    Then, scroll down to the Callback URLs section and add the following entries:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbe8f693-9128-44b9-b8f4-928b960c9770.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: As it explains, this box lists the URLs that are allowed to be used for Twitter
    OAuth authentication. At the moment, we are hosting the application on our laptop
    using port `3000`. If you are accessing it from other base URLs, such as `http://MacBook-Pro-4.local`,
    then that base URL should be used in addition.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the callback URLs correctly configured, clicking on the Login
    with Twitter button will take you to a normal Twitter OAuth authentication page.
    Simply click for approval, and you'll be redirected back to the Notes application.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'And then, once you''re logged in with Twitter, you''ll see something like the following
    screenshot:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e324c9a-3128-40c1-9d5c-1d90d2682130.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: We're now logged in, and will notice that our Notes username is the same as
    our Twitter username. You can browse around the application and create, edit,
    or delete notes. In fact, you can do this to any note you like, even ones created
    by others. That's because we did not create any sort of access control or permissions
    system, and therefore every user has complete access to every note. That's a feature
    to put on the backlog.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: By using multiple browsers or computers, you can simultaneously log in as different
    users, one user per browser.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run multiple instances of the Notes application by doing what we did
    earlier, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]js\1'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'In another command window, run the following command:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]js\1'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: This is after logging in using a Twitter account. You can see that the Twitter
    account name is stored here in the session data.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: What if you want to clear a session? It's just a file in the filesystem. Deleting
    the session file erases the session, and the user's browser will be forcefully
    logged out.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: The session will time out if the user leaves their browser idle for long enough.
    One of the `session-file-store` options, `ttl`, controls the timeout period, which
    defaults to 3,600 seconds (an hour). With a timed-out session, the application
    reverts to a logged-out state.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've gone through the full process of setting up support for
    login using Twitter's authentication service. We created a Twitter developer account
    and created an application on Twitter's backend. Then, we implemented the required
    workflow to integrate with Twitter's OAuth support. To support this, we integrated
    the storage of user authorizations from Twitter in the user information service.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next task is extremely important: to keep user passwords encrypted.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Keeping secrets and passwords secure
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve cautioned several times about the importance of safely handling user
    identification information. The intention to handle that data safely is one thing,
    but it is important to follow through and actually do so. While we''re using a
    few good practices so far, as it stands, the Notes application would not withstand
    any kind of security audit for the following reasons:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: User passwords are kept in clear text in the database.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The authentication tokens for Twitter et al. are in clear text.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The authentication service API key is not a cryptographically secure anything;
    it's just a clear text **universally unique identifier** (**UUID**).
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you don't recognize the phrase *clear text*, it simply means unencrypted.
    Anyone could read the text of user passwords or the authentication tokens. It's
    best to keep both encrypted to avoid information leakage.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Keep this issue in the back of your mind because we'll revisit these—and other—security
    issues in [Chapter 14](4cccad1e-fe7e-495a-9e90-8818820b890a.xhtml), *Security
    in Node.js Applications*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we leave this chapter, let''s fix the first of those issues: storing
    passwords in plain text. We made the case earlier that user information security
    is extremely important. Therefore, we should take care of this from the beginning.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: The `bcrypt` Node.js package makes it easy to securely store passwords. With
    it, we can easily encrypt the password right away, and never store an unencrypted
    password.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: For `bcrypt` documentation, refer to [https://www.npmjs.com/package/bcrypt](https://www.npmjs.com/package/bcrypt).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `bcrypt` in both the `notes` and `users` directories, execute the
    following command:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]js\1'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: This brings in the `bcrypt` package, and then we configure a constant that governs
    the CPU time required to decrypt a password. The `bcrypt` documentation points
    to a blog post discussing why the algorithm of `bcrypt` is excellent for storing
    encrypted passwords. The argument boils down to the CPU time required for decryption.
    A brute-force attack against the password database is harder, and therefore less
    likely to succeed if the passwords are encrypted using strong encryption, because
    of the CPU time required to test all password combinations.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: The value we assign to `saltRounds` determines the CPU time requirement. The
    documentation explains this further.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following function:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]js\1'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: That is, in each, we make the callback function an async function so that we
    can use `await`. Then, we call the `hashpass` function to encrypt the password.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: This way, we are encrypting the password right away, and the user information
    server will be storing an encrypted password.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in `user-server.mjs`, the `password-check` handler must be rewritten
    to accommodate checking an encrypted password.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `user-server.mjs`, add the following import:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]js\1'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The `bcrypt.compare` function compares a plain text password, which will be
    arriving as `req.params.password`, against the encrypted password that we've stored.
    To handle encryption, we needed to refactor the checks, but we are testing for
    the same three conditions. And, more importantly, this returns the same objects
    for those conditions.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'To test it, start the user information server as we''ve done before, like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]js\1'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: We've done both these steps before. Where it differs is what we do next.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the database to see what was stored, as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]js\1'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: We performed this same test earlier, but this time, it is against the encrypted
    password.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: We have verified that a REST call to check the password will work. Our next
    step is to implement the same changes in the Notes application.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Implementing encrypted password support in the Notes application
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we've already proved how to implement encrypted password checking, all
    we need to do is duplicate some code in the Notes server.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'In `users-superagent.mjs`, add the following code to the top:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]js\1'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: In those places where it is appropriate, we must encrypt the password. No other
    change is required.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Because the `password-check` backend performs the same checks, returning the
    same object, no change is required in the frontend code.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: To test, start both the user information server and the Notes server. Then,
    use the application to check logging in and out with both a Twitter-based user
    and a local user.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: We've learned how to use encryption to safely store user passwords. If someone
    steals our user database, cracking the passwords will take longer thanks to the
    choices made here.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: We're almost done with this chapter. The remaining task is simply to review
    the application architecture we've created.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Running the Notes application stack
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Did you notice earlier when we said to run the Notes application stack? It's
    time to explain to the marketing team what's meant by that phrase. They may want
    to put an architecture diagram on marketing brochures or websites. It's also useful
    for developers such as us to take a step back and draw a picture of what we've
    created, or are planning to create.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the sort of diagram that an engineer might draw to show the marketing
    team the system design (the marketing team will, of course, hire a graphics artist
    to clean it up):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56c15d1d-4fe7-45a8-8e6d-5410f048234e.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
- en: The box labeled Notes Application in the preceding diagram is the public-facing
    code implemented by the templates and the router modules. As currently configured,
    it's visible from our laptop on port `3000`. It can use one of several data storage
    services. It communicates with the User Authentication Service backend over port
    `5858` (or port `3333`, as shown in the preceding diagram).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](176ce11c-dd6f-4ebf-ba14-529be6db28da.xhtml),* Deploying Node.js
    Applications to Linux Servers,* we'll be expanding this picture a bit as we learn
    how to deploy on a real server.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've covered a lot of ground in this chapter, looking at not only user authentication
    in Express applications, but also microservices development.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, you covered session management in Express, using Passport for
    user authentication—including Twitter/OAuth, using router middleware to limit
    access, creating a REST service with Restify, and when to create a microservice.
    We've even used an encryption algorithm to ensure that we only store encrypted
    passwords.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to handle login/logout, especially OAuth login from third-party
    services, is an essential skill for web application developers. Now that you've
    learned this, you'll be able to do the same for your own applications.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take the Notes application to a new level with semi-real-time
    communication between application users. To do this, we'll write some browser-side
    JavaScript and explore how the Socket.io package can let us send messages between
    users.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
