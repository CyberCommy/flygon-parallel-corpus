- en: Chapter 7. Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we are developing an application, we should always be thinking about how
    we can make our microservices more secure. There are some techniques and methods
    that every developer should know in order to avoid security problems. In this
    chapter, you will discover the ways to use authentication and authorization to
    use in your microservices, and how to manage the permissions of each functionality
    once your users log in. You will also discover the different methods you can use
    to encrypt your data.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption in microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can define encryption as the process of transforming information in such
    a way that only authorized parties are able to read it. This process can be done
    practically at any level of your application. For example, you can encrypt your
    whole database, or you can add the encryption in the transport layer with SSL/TSL
    or with **JSON Web Token** (**JWT**).
  prefs: []
  type: TYPE_NORMAL
- en: 'These days, the encryption/decryption process is done through modern algorithms
    and the highest level where the encryption is added is on the transport layer.
    All the algorithms used in this layer provide at least the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: This feature allows you to verify the origin of a message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrity**: This feature gives you proof that the content of the message
    wasn''t changed on its way from the origin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final mission of the encryption algorithms is to provide you with a security
    layer so that you can interchange or store sensitive data without having to worry
    about someone stealing your information, but it is not free of cost. Your environment
    will use some resources dealing with encryption, decryption, or handshakes among
    other related things.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a developer, you need to think that you will be deployed to a hostile environment--production
    is a war zone. If you start thinking this way, you will probably start asking
    yourself the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Will we deploy to hardware or to a virtualized environment? Will we share resources?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we trust all the possible neighbors of our application?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will we split our application into different and separated zones? How will we connect
    our zones?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will our application be PCI compliant or will it need a very high degree of
    security due to the data we store/manage?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you start answering all these questions (among others), you will start
    figuring out the level of security needed for your application.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will show you the most common ways to encrypt the data in
    your application so that you can later choose which one to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are not considering full disk encryption because it is considered
    to be the weakest method to protect your data.
  prefs: []
  type: TYPE_NORMAL
- en: Database encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are dealing with sensitive data, the most flexible and with lower overhead
    method of protecting your data is using encryption in your application layer.
    However, what happens if, for some reason, you cannot change your application?
    The next most powerful solution is to encrypt your database.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our application, we have chosen a *relational database*; specifically,
    we are using Percona, a MySQL fork. Currently, you have two different options
    to encrypt your data in this database:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable the encryption through MariaDB patch (another MySQL form that is pretty
    similar to Percona). This patch is available in 10.1.3 and the later versions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The InnoDB tablespace level encryption method is available from Percona Server
    5.7.11 or MySQL 5.7.11.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perhaps you are wondering why we are talking about MariaDB and MySQL when we
    have chosen Percona. This is because the three of them have the same core, sharing
    most of their core functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the major database softwares allow you to encrypt your data. If you are
    not using Percona, check the official documentation of your database to find the
    required steps needed to allow encryption.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a developer, you need to know the weakness of using a database level encryption
    in your application. Among others, we can highlight the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: Privileged database users have access to the key ring file, so be strict with
    user permissions in your database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data is not encrypted while is stored in the RAM of your server, it is only
    encrypted when the data is written in the hard drive. A privileged and malicious
    user can use some tools to read the server memory and as a consequence, your application
    data too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some tools like GDB can be used to change the root user password structure,
    allowing you to copy data without any issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encryption in MariaDB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine that instead of using Percona, you want to use MariaDB; database encryption
    is available thanks to the `file_key_management` plugin. In our application example,
    we are using Percona as data storage for the secrets microservice, so let's add
    a new container for MariaDB only so that you can later give it a try and interchange the
    two RDBMS.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a `mariadb` folder in your Docker repository inside the secrets
    microservice on the same level as the database folder. Here, you can add a `Dockerfile`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are pulling the latest official MariaDB image, updating
    it, and creating some certificates that we will need for our encryption. The long
    string saved in the `keys.txt` file is a key we generated ourselves with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The last command of our `Dockerfile` will copy our bespoke database configurations
    inside the container. Create our custom database configuration in `etc/encryption.cnf`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are telling our database engine where we store our
    certs and we enable the encryption. Now, you can edit our `docker-compose.yml`
    file and add the following container definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code, we are not defining anything new; you
    now probably have enough experience with Docker to understand that we are defining
    where our `Dockerfile` is located. We set up some environment variables and mapped
    the `7777` local port to the container `3306` port. As soon as you have made all
    your changes, a simple `docker-compose build microservice_secret_database` command
    will generate the new container.
  prefs: []
  type: TYPE_NORMAL
- en: 'After building the container, it''s time to check whether everything is working.
    Spin up the new container with `docker-compose up microservice_secret_database` and
    try to connect it to our local `7777` port. Now, you can start using encryption
    in this container. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we added some extra tags to our SQL; they enable the
    encryption in the table and use the encryption key with the ID `1` we stored in
    `keys.txt` (the file we used to start our database). Give it a try and, if everything
    runs smoothly, feel free to make the necessary changes to use this new database
    container instead of the other one we have in our project.
  prefs: []
  type: TYPE_NORMAL
- en: InnoDB encryption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Percona and MySQL 5.7.11+ versions come with a new feature out of the box--support
    for **InnoDB** tablespace level encryption. With this feature, you can encrypt
    all your InnoDB tables without too much fuss or configuration. In our example
    application, we are using Percona 5.7 on the secrets microservice. Let's look
    at how to encrypt our tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to make some small amendments to our Docker environment; first
    of all, open `microservices/secret/database/Dockerfile` and replace all the content
    with the following the lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point in the book, you probably don''t need an explanation of what
    we did in our `Dockerfile`, so let''s create a new `config` file that we will
    later copy to our container. Inside the `secret microservice` folder, create an
    `etc` folder and generate a new `encryption.cnf` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the configuration file we created earlier, we are loading the `keyring` lib,
    where our database can find and store the generated keyrings used to encrypt our
    data.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you have everything you need to enable the encryption, so rebuild
    the container with `docker-compose build microservice_secret_database` and spin
    all your containers up again with `docker-compose up -d`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything is fine, you should be able to open your database without any
    problems and you can alter the tables we stored with the following SQL command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You may be wondering why we altered our `secrets` table if we already enabled
    the encryption in the database. The reason behind this is because the encryption
    doesn't come enabled by default, so you need to explicitly tell the engine which
    tables you want to encrypt.
  prefs: []
  type: TYPE_NORMAL
- en: Performance overhead
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using encryption in your database will reduce the performance of your application.
    Your machines/containers will use some resources dealing with the encrypt/decrypt
    process. In some tests, this overhead can be over 20% when you are not using the
    tablespace level encryption (MySQL/Percona +5.7). Our recommendation is to measure
    the average performance of your application with and without the encryption enabled.
    This way, you can ensure that the encryption will not have a high impact on your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we showed you two quick ways of adding an extra layer of security
    to your application. The final decision for using these features depends on you
    and the specifications of your application.
  prefs: []
  type: TYPE_NORMAL
- en: TSL/SSL protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Transport Layer Security** (**TSL**) and **Secure Sockets Layer** (**SSL**)
    are cryptographic protocols used to secure communication in an untrusted network,
    for example, the Internet or LAN of your ISP. SSL is the predecessor of TSL and
    both of them are often used interchangeably or in conjunction with TLS/SSL. These
    days, SSL and TSL are practically the same thing and it makes no difference if
    you choose to use one or the other, you will be using the same level of encryption,
    dictated by the server. If an application, for example, an e-mail client, gives
    you the option to choose between SSL or TSL, you are only selecting how the secure
    connection is initiated, nothing else.'
  prefs: []
  type: TYPE_NORMAL
- en: All the power and security of these protocols rely on what we know as certificates.
    TSL/SSL certificates can be defined as small data files that digitally bind a
    cryptographic key to an organization or a person's details. You can find all kinds
    of companies that sell TSL/SSL certificates, but if you don't want to spend money
    (or you are in the development phase), you can create self-signed certificates.
    These kinds of certificates can be used to encrypt data, but the clients will not
    trust them unless you skip the validation.
  prefs: []
  type: TYPE_NORMAL
- en: How the TSL/SSL protocol works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you start using TSL/SSL in your application, you need to know how it
    works. There are many other books dedicated to explaining how these protocols
    work, so we will only give you a sneak peek.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is a summary of how the TSL/SSL protocol works; first,
    you need to know that TSL/SSL is a TCP client-server protocol and the encryption
    starts after a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How the TSL/SSL protocol works](graphics/B06142_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: TSL/SSL protocol
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps of the TSL/SSL protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: Our client wants to start a connection to a server/service secured with TSL/SSL,
    so it asks the server to identify itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server attends to the petition and sends the client a copy of its TSL/SSL
    certificate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client checks if the TSL/SSL certificate is a trusted one and if so, sends
    a message to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server returns a digitally signed acknowledgement to start a session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After all the previous steps (handshake), the encrypted data is shared between
    the client and the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can imagine, the terms *client* and *server* are ambiguous; a client
    can be a browser trying to reach your page or the client can be a microservice
    trying to communicate with another microservice.
  prefs: []
  type: TYPE_NORMAL
- en: TSL/SSL termination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you learned before, adding a TSL/SSL layer to your application adds a little
    overhead to the overall performance of your app. To mitigate this problem, we
    have what we call TSL/SSL termination, a form of TSL/SSL offloading, which moves
    the responsibility of encryption/decryption from the server to a different part
    of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'TSL/SSL termination relies on the fact that once all the data is decrypted,
    you trust all the communication channels you are using to move this decrypted
    data. Let''s see an example with a microservice; take a look at the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![TSL/SSL termination](graphics/B06142_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: TSL/SSL termination in a microservice
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding image, all the in/out communications are encrypted using a
    specific component of our microservice architecture. This component will be acting
    as a proxy and it will be dealing with all the TSL/SSL stuff. As soon as a request
    from a client comes, it manages all the handshake and decrypts the request. Once
    the request is decrypted, it is proxied to the specific microservice component
    (in our case, it is NGINX) and our microservice does what is needed, for example,
    getting some data from the database. Once the microservice needs to return a response,
    it uses the proxy where all our response is encrypted. If you have multiple microservices,
    you can scale out this small example and do the same--encrypt all the communications
    between the different microservices and use encrypted data inside the microservice.
  prefs: []
  type: TYPE_NORMAL
- en: TSL/SSL with NGINX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can find multiple softwares that you can use to do TSL/SSL termination.
    Among others, the following list flags the most well known:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Load balancer**: Amazon ELB and HaProxy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proxies**: NGINX, Traefik, and Fabio'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our case, we will use NGINX to manage all the TSL/SSL termination, but feel
    free to try other options.
  prefs: []
  type: TYPE_NORMAL
- en: As you probably know already, NGINX is one of the most versatile softwares in
    the market. You can use it as a reverse proxy or a web server with a high performance
    level and stability.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explain how to do a TSL/SSL termination in NGINX, for example, for
    the battle microservice. First, open the `microservices/battle/nginx/Dockerfile`
    file and add the following command just before the CMD command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created some self-signed certificates and stored them inside the `/etc/nginx`
    folder of the `nginx` container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have our certificates, it''s time to change the NGINX configuration
    file. Open the `microservices/battle/nginx/config/nginx/nginx.conf.ctmpl` file
    and add the following server definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding piece of code sets up a new listener in the `nginx` server, in
    the `443` port. As you can see, it is very similar to the default server settings;
    the difference lies in the ports and the location of the certificates we created
    in the previous step.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this new TSL/SSL endpoint, we need to make some small changes to the
    `docker-compose.yml` file and map the `443` NGINX port. To do this, you only need
    to go to the `microservice_battle_nginx` definition and add a new line in the
    ports declaration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The new line will map our `8443` port to the `nginx` container `443` port, allowing
    us to connect through TSL/SSL. You can give it a try now with Postman but, due
    to the fact that it is a self-signed certificate, by default it is not accepted.
    Open **Preferences** and disable **SSL certificate verification**. As homework,
    you can change all our example services to only use the TSL/SSL layer to communicate
    with each other.
  prefs: []
  type: TYPE_NORMAL
- en: In this section of the chapter, we have shown you the main ways in which you
    can add an extra layer of security to your application, encrypting your data and
    the communication channel used to interchange messages. Now that we are sure that
    our application has at least some level of encryption, let's continue with another
    important aspect of any application--authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The starting point of every project is the authentication system, in which it
    is possible to identify the users or customers who will use our application or
    API. There are many libraries to implement the different ways to authenticate
    users; in this book, we will see two of the most important ways: **OAuth 2** and
    **JWT**.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we already know, microservices are *stateless*, which means that they should
    communicate with each other and users using an *access token* instead of cookies
    and sessions. So, let''s look at what the workflow of the authentication is like
    using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Authentication](graphics/B06142_07_03-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Authentication by token workflow
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the preceding image, this should be the process of getting
    a list of secrets required by a customer or user:'
  prefs: []
  type: TYPE_NORMAL
- en: '**USER** asks **FRONTEND LOGIN** for a list of secrets.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FRONTEND LOGIN** asks **BACKEND** for the list of secrets.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**BACKEND** asks **FRONTEND LOGIN** for the user access token.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FRONTEND LOGIN** asks **GOOGLE** (or any other provider) for the access token.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**GOOGLE** asks **USER** for their credentials.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**USER** provides credentials to **GOOGLE**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**GOOGLE** provides user access token to **FRONTEND LOGIN**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FRONTEND LOGIN** provides **BACKEND** the user access token.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**BACKEND** checks with **GOOGLE** who the user of that access token is.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**GOOGLE** tells **BACKEND** who the user is.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**BACKEND** checks the user and tells **FRONTEND LOGIN** the list of secrets.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FRONTEND LOGIN** shows **USER** the list of secrets.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obviously, in this process, everything happens without the user knowing it.
    The user only has to provide his/her credentials to the proper service. In the
    preceding example, the service is **GOOGLE**, but it can even be our own application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will build a new docker container in order to create and set up a database
    to authenticate users using OAuth 2 and JWT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Dockerfile` in the docker user microservice under the ` docker/microservices/user/database/Dockerfile`
    database folder with the following line. We will use Percona as we did for the
    secret microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have created the `Dockerfile,` open the `docker-composer.yml` file
    and add the user database microservice configuration at the end of the User microservice
    section (just before the source containers). Also, add `microservice_user_database`
    to the `microservice_user_fpm` links section to make the database visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have set the configuration, it is time to build it, so run the following
    command on your terminal to create the new container we have just set up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It can take some time; when it finishes, we have to start the containers again
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can check whether the user database microservice was created correctly by
    executing `docker ps`, so check to see the new `microservice_user_database` on
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time to set up the user microservice to be able to use the database container
    we have just created, so add the following line to the  `bootstrap/app.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, create the `config/database.php` file with the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in the preceding code, we have used the same credentials we used
    on the `docker-compose.yml` file in order to connect to the database container.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is everything. We now have a new database container connected to user
    microservice and it is ready to be used. Add a new users table by creating a migration
    or executing the following query in your favorite SQL client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: OAuth 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's introduce a secure and especially useful in microservices authentication
    system based on access tokens.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2 is a standard protocol that allows us to limit some methods of our API
    REST to specific users, avoiding having to ask the users for their usernames and
    passwords.
  prefs: []
  type: TYPE_NORMAL
- en: This protocol is very common because it is more secure as it avoids sharing
    passwords or delicate credentials when communicating between APIs.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2 uses an access token that needs to be obtained by the user in order
    to use the application. The token will have an expiration time and it can be refreshed
    without having to give the user credentials again.
  prefs: []
  type: TYPE_NORMAL
- en: How to use OAuth 2 on Lumen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, we will explain how to install, set up, and try OAuth 2 authentication
    on Lumen. The goal of this is to have a microservice using OAuth 2 for your methods;
    in other words, the consumer will need to provide a token before using the methods
    that require authentication.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2 installation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Go to the user microservice by executing the following commands on the docker
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we are in the User microservice, it is necessary to install OAuth 2 by
    adding the following line in the `composer.json` file in the `require` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Then, execute `composer update` and the package will install OAuth 2 on your
    microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once the package is installed, we have to set up some important things in order
    to run OAuth 2\. Firstly, we need to copy the OAuth 2 config file located at `/vendor/lucadegasperi/oauth2-server-laravel/config/oauth2.php`
    to `/config/oauth2.php`; if the `config` folder does not exist, create it. Also,
    we need to copy the migration files included in the `/vendor/lucadegasperi/oauth2-server-laravel/database/migrations
    to /database/migrations` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do not forget to register OAuth 2 by adding the following lines to `/bootstrap/app.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of the file, before the `app->withFacades();` line (if it is not
    uncommented, do it), add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will execute the migrations in order to create the necessary tables
    in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have issues in executing the migrations, try adding the `'migrations'
    => 'migrations', 'fetch' => PDO::FETCH_CLASS,` line to the `config/database.php`
    file and then, execute `php artisan migrate:install --database=mysql`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have created all the necessary tables, insert a register in the `oauth_clients`
    table using Lumen seeders or by executing the following query on your favorite
    SQL client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to add a new route on `/app/Http/routes.php` in order to get a
    valid token for the user we have just created. For example, the route can be `oauth/access_token`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, modify the `grant_types` value on the `/config/oauth2.php` file, changing
    it to the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Let's try OAuth2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We are now ready to get our token by doing a POST call on Postman to `http://localhost:8084/api/v1/oauth/access_token`,
    including the following parameters on the body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we enter the wrong credentials, it will give the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If the credentials are correct, we will get the `access_token` in JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have a valid access token, we can restrict some methods for unregistered
    users. This is very easy on Lumen. We just have to enable route middlewares on
    `/bootstrap/app.php`, so add the following code in that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to the controller `UserController.php` file and add a `__construct()` function
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This will affect all the methods on the controller, but we can exclude some
    of them with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now we can test the index function by doing a GET call to `http://localhost:8084/api/v1/user`.
    Do not forget to include a header called `Authorization` with the `Bearer anU2e6xgXiLm7UARSSV7M4Wa7u86k4JryKWrIQhu` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we excluded the index function or if we enter the token properly, we will
    get the JSON response with status code 200:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we did not exclude the index method and we enter a wrong token, we will
    get an error code 401 and the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now you have a secure and better application. Remember that you can add the
    error handling you learned in the last chapter to your authorization methods.
  prefs: []
  type: TYPE_NORMAL
- en: JSON Web Token
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**JSON Web Token** (**JWT**) is group of security methods to be used in HTTP
    requests and to be transferred between the client and the server. A JWT token
    is a JSON object that is digitally signed using JSON web signature.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a token with JWT, we need the user credentials, a secret
    key, and the encryption type to be used; it can be HS256, HS384, or HS512.
  prefs: []
  type: TYPE_NORMAL
- en: How to use JWT on Lumen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is possible to install JWT on Lumen using composer. So, once you are in
    the user microservice container, execute the following command in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to install the library is to open your `composer.json` file and
    add `"tymon/jwt-auth": "^1.0@dev"` to the list of required libraries. Once it
    is installed, we need to register JWT on register service providers as we did
    with OAuth 2\. On Lumen, it is possible to do this by adding the following line
    in the `bootstrap/app.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, uncomment the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Your ` bootstrap/app.php` file should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Setting up JWT
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we need a secret key, so run the following command in order to generate
    and place it on the JWT config file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it is generated, you can see the secret key placed in the `.env` file
    (your secret key will be different). Check this and ensure that your `.env` looks
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go to the `config/jwt.php` file; this is the JWT `config` file, ensure
    that your file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also necessary to set up `config/app.php` properly. Ensure that you entered
    the user model correctly, it will define the table where JWT should search for
    the user and password provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to define the methods that require authentication by editing
    `/app/Http/routes.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You can see in the preceding code that our middleware only affects the methods
    included in the group that we defined the middleware in. We can create all the
    groups we want in order to pass the methods through the middleware(s) that we
    select.
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, edit the `/app/Providers/AuthServiceProvider.php` file and add
    the following highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to make some changes on your user model file, so go to `/app/Model/User.php`
    and add the following lines of `JWTSubject` to the class implements list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Do not forget to add the `getJWTIdentifier()` and `getJWTCustomClaims()` functions,
    as you can see in the preceding code. These functions are necessary to implement
    `JWTSubject`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try JWT
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In order to test this, we have to create a new user in the users table of the
    database. So, add it by making a migration or executing the following query in
    your favorite SQL client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The hashed password inserted manually corresponds to '123456'. Lumen will save
    your user passwords hashed for security reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Postman and give it a try by making a POST call to `http://localhost:8084/user`.
    You should receive the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This is happening because the `http://localhost:8084/user` method is protected
    by an authentication middleware. You can check this on your `routes.php` file.
    In order to get the user, it is necessary to provide a valid access token.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method to get a valid access token is `http://localhost:8084/login`, so
    make a POST call with the parameters that correspond to the user we added, `email
    = john@phpmicroservices.com`, and password, `123456`. If they are correct, we
    will get a valid access token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'So now, we can use the preceding access token to make the POST call to `http://localhost:8084/user` as
    we did before. This time, we will get the user info:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is very simple to protect your methods using a valid access
    token. It will make your application more secure.
  prefs: []
  type: TYPE_NORMAL
- en: Access Control List
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a very common system in all applications regardless of their size. **Access
    Control List** (**ACL**) provides us with an easy way to manage and filter the
    permissions of every user. Let's look at this in a little more detail.
  prefs: []
  type: TYPE_NORMAL
- en: What is ACL?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The method that an application uses to identify every single user of the application
    is ACL. This is the system that informs the application what access rights or
    permissions a user or group of users have for a specific task or action.
  prefs: []
  type: TYPE_NORMAL
- en: Every task (function or action) has an attribute to identify which users can
    use it, and ACL is a list that links every task with every action, such as read,
    write, or execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'ACL has the following two featured advantages for the applications that use
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Management**: Using ACL in our application allows us to add users to groups
    and manage the permissions for each group. Also, it is easier to add, modify,
    or remove permissions to many users or groups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: Having different permissions for each user is better for the
    application''s security. It avoids fake users or exploits breaking the application
    just by giving different permissions to normal users and administrators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our application based on microservices, we recommend having a different
    ACL for each microservice; this avoids having a single point of entry for the
    entire application. Remember that we are building microservices, and one of the
    requirements was that microservices should be isolated and independent; so, having
    a microservice to control the rest of them is not a good practice.
  prefs: []
  type: TYPE_NORMAL
- en: This is not a difficult task, it makes sense because every microservice should
    have different tasks and every task is different for each user in terms of permissions.
    Imagine that we have a user who has the following permissions. This user can create
    secrets and check the nearby secrets, but is not allowed to create battles or
    new users. Managing the ACL globally will be a problem in terms of scalability
    when a new microservice is added to the system or even when new developers join
    the team and they have to understand the complex system of global ACL. As you
    can see, it is better to have an ACL system for each microservice, so when you
    add a new one, it is not necessary to modify the ACL for the rest.
  prefs: []
  type: TYPE_NORMAL
- en: How to use ACL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lumen provides us with an authentication process in order to get a user to sign
    up, log in, log out, and reset the password, and it also provides an ACL system
    whose classes are called `Gate`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Gate` allows us to know whether a specific user has permissions to do a specific
    action. This is very easy and it can be used in every method of your API.'
  prefs: []
  type: TYPE_NORMAL
- en: To set up ACL on Lumen, you have to enable facades on your `bootstrap/app.php`
    by removing the semicolon from the `app->withFacades();` line; if this line does
    not appear on your file, add it.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also necessary to create a new file on `config/Auth.php` with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is necessary to use the `Gate` class on our controller in
    order to check the user permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is set up, we have to define the different actions or situations
    available for a specific user. To do this, open the `app/Providers/AuthServiceProvider.php` file;
    on the `boot()` function, we can define every action or situation by writing the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have defined the situation, we can put it into our function. There
    are three different ways to use it: *allows*, *checks* and *denies*. The first
    two are the same, they return true when the defined situation returns true, and
    the last one returns true when the defined situation returns false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is not necessary to send the `$user` variable, it will get
    the current user automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Security of the source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most likely situation is that your project will connect to an external service
    using some credentials, for example, a database. Where will you store all this
    information? The most common way is to have a configuration file inside your source
    where you place all your credentials. The main problem with this approach is that
    you will commit the credentials, and any person with access to the source will
    have access to them. It doesn't matter that you trust the people who have access
    to the repo; it is not a good idea to store credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can''t store credentials in your source code, you are probably wondering
    how you will store them. You have two main options:'
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at each one so that you can choose which option is better
    for your project.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This way of storing credentials is very easy to implement--you only define the
    variables you want to store in the environment and later, you can get them in
    your source.
  prefs: []
  type: TYPE_NORMAL
- en: 'The framework we have chosen for our project is Lumen and with this framework,
    it is very easy to define your environment variables and later use them in the
    code. The most important file is the `.env` file, located in the root of your
    source. By default, this file is in `gitignore` to avoid being committed, but
    the framework comes with an `.env.example` example so that you can check how to
    define the variables. In this file, you can find definitions, such as the following
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The preceding definitions will create the environment variables and you can
    get the values in your code with a simple `env('DB_DATABASE');` or `env('DB_DATABASE',
    'default_value');`. The `env()` function supports two parameters, so you can define
    a default value in case the variable you are trying to get is not defined.
  prefs: []
  type: TYPE_NORMAL
- en: The main benefit of using environment variables is that you can have different
    environments without needing to change anything in your source; you can even change
    the values without making any changes to your code.
  prefs: []
  type: TYPE_NORMAL
- en: External services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This way of storing credentials uses an external service to store all the credentials
    and they work more or less like the environment variables. When you need any credentials,
    you have to ask this service.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the mainstream credential storage systems these days is the HashiCorp
    Vault project, an open source tool that allows you to create a secure place where
    you can store your credentials. It has multiple benefits and we highlight, among
    them, the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key rolling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audit logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for multiple secret backends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main disadvantage of using an external service is the extra complexity you
    are adding to your application; you will add a new component to manage and keep
    up to date.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking and monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are dealing with security in your application, it is important to keep
    track and monitor what is happening in it. In [Chapter 6](ch06.html "Chapter 6. Monitoring"),
    *Monitoring*, we implemented Sentry as a log and monitoring system and we also
    added Datadog as our APM, so you can use these tools to keep track of what is
    happening and to send you alerts.
  prefs: []
  type: TYPE_NORMAL
- en: However, what do you want to track? Let's imagine that you have a login system,
    this component is a good place to add your tracking. If you track each failed
    login for a user, you can know if somebody is trying to attack your login system.
  prefs: []
  type: TYPE_NORMAL
- en: Does your application allow users to add, modify, and delete content? Track
    any changes to the content so that you can detect untrusted users.
  prefs: []
  type: TYPE_NORMAL
- en: In security, there are no standards about what to track and what not to track,
    simply use your common sense. Our main recommendation is to create a list of sensitive
    points in your application that cover at least where the users can login, create
    content, or delete it and later use these lists as a starting point to add tracking
    and monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with any other part of the application, when you are dealing with security,
    there are some well-known best practices you need to follow or at least be aware
    of to avoid future issues. Here, you can find the most common ones related to
    web development.
  prefs: []
  type: TYPE_NORMAL
- en: File permissions and ownership
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most basic security mechanisms is file/folder permissions and ownership.
    Assuming that you are working on a Linux/Unix system, the main recommendation
    is to assign the ownership of your source code to the web server or PHP engine
    user. Regarding file permissions, you should be using the following setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '**500 permissions for directories (dr-x------)**: This setting prevents any
    accidental deletion or modification of files in the directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**400 permissions for files (-r--------)**: This setting prevents any users
    from overwriting files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**700 permissions (drwx------)**: This is for any writable directories. It
    gives full control to the owner and is used in upload folders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**600 permissions (-rw-------)** : This setting is for any writable files.
    It avoids any modification of your files by any user who is not an owner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP execution locations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Avoid any future problems by allowing the execution of PHP scripts only on selected
    paths and deny any kind of execution in sensitive (writable) directories, for
    example, any upload directories.
  prefs: []
  type: TYPE_NORMAL
- en: Never trust users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a rule of thumb, never trust the user. Filter any input that comes from anybody,
    you never know the dark intentions behind a form submit. Of course, never rely
    only on frontend filtering and validation. If you added filtering and validation
    to the frontend, do it again in the backend.
  prefs: []
  type: TYPE_NORMAL
- en: SQL injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nobody wants their data to be exposed or to be accessed by someone who does
    not have permission and this type of attack against your application is due to
    bad filtering or validation of the inputs. Imagine that you use a field to store
    the name of the user that is not correctly filtered, a malicious user can use
    this field to execute SQL queries. To help you to avoid this issue, use the ORM
    filtering methods or any filtering method available in your favorite framework
    when you are dealing with databases.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-site scripting XSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is another type of attack against your application and is due to bad filtering.
    If you allow your users to post any kind of content on your page, it may be possible
    for some malicious users to add scripts to the page without your permission. Imagine
    that you have a comments section on your page and your input filtering is not
    the best, a malicious user can add a script as a comment that opens a spam pop
    up. Remember what we told you before--never trust your users--filter and validate
    everything.
  prefs: []
  type: TYPE_NORMAL
- en: Session hijacking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this attack, the malicious user steals another user's session keys, giving
    the malicious user the opportunity to be like the other user. Imagine that your
    application deals with financial information and a malicious user can steal an
    admin session key, now this user can get all the information they need. Most of
    the time, sessions are stolen using an XSS attack, so first, try to avoid any
    XSS attacks. Another way of mitigating this issue is preventing JavaScript from
    having access to the session ID; you can do this in your `php.ini` with the `session.cookie.httponly` setting.
  prefs: []
  type: TYPE_NORMAL
- en: Remote files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Including remote files from your application can be very dangerous, you will
    never be 100% sure that the remote file you are including can be trusted. If at
    some point, the included remote file is compromised, attackers can do what they
    want, for example, remove all the data from your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'An easy way to avoid this is to disable the remote files in your `php.ini`.
    Open it and disable the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`allow_url_fopen`: This is enabled by default'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allow_url_include`: This is disabled by default; if you disable the `allow_url_fopen`
    setting, it forces this to be disabled too'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Never store any passwords in plain text. When we say never, we mean never. If
    you think that you will need to check a user's password you are wrong, any kind
    of restoring or resupplying a missing password needs to go through a recovery
    system. When you store a password, you store the password hash that is mixed with
    some random salt.
  prefs: []
  type: TYPE_NORMAL
- en: Password policies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you keep sensitive data and you don''t want your application to be exposed
    by the passwords of your users, put a very strict password policy in place. For
    example, you can create the following password policy to reduce cracking and dictionary
    attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: At least 18 characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At least 1 uppercase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At least 1 number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At least 1 special character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not been used before
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not being a concatenation of the user data, changing vowels to numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expires every 3 months
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source code revelation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Keep the source code out of sight of curious eyes, if for some reason your server
    is broken, all the source code will be exposed as plain text. The only way to
    avoid this is to only keep the required files in the web server root folder. As
    an addition, be careful with special files, such as `composer.json`. If we expose
    our `composer.json`, everybody will know the different versions of each of our
    libraries, giving them an easy way of knowing any possible bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Directory traversal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This kind of an attack tries to access files that are stored outside the web
    root folder. Most of the time, this is due to bugs in the code, so the malicious
    user can manipulate variables that reference files. There is no easy way to avoid
    this; however, if you use external frameworks or libraries, keeping them up to
    date will help you.
  prefs: []
  type: TYPE_NORMAL
- en: These are the most obvious security concerns you need to be aware of, but this
    is not an exhaustive list. Subscribe to security newsletters and keep all your
    code up to date to reduce risks to the minimum.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about security and authentication. We showed you
    how you can encrypt your data and communication layers; we even showed you how
    to build a robust login system, and how you can deal with the secrets of your
    application. Security is a very important aspect in any project, so we gave you
    a small list of common security risks you need to be aware of and, of course,
    the main recommendation--never trust your users.
  prefs: []
  type: TYPE_NORMAL
