- en: Dealing with Console I/O and Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers recipes based on the console, streaming, and file I/O using
    the C++ Standard Library. We've been reading parameters into the programs we've
    written in other chapters but there are several other ways to do this. We'll deep
    dive into these topics and we will learn the alternatives, tips, and best practices
    for each with specific and dedicated hands-on recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, our main focus is to try to write system programming software by
    using C++ (and its standard library) as much as we can, so the code will have
    very limited C and POSIX solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing I/O to and from the console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating I/O strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to let you try the programs right from the start, we've set up a Docker
    image that has all the tools and libraries we'll need throughout the book. It
    is based on Ubuntu 19.04.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to set it up, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install the Docker Engine from [www.docker.com](https://www.docker.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull the image from Docker
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hub: `docker pull kasperondocker/system_programming_cookbook:latest`
  prefs: []
  type: TYPE_NORMAL
- en: The image should now be available. Type in the following command to view the
    image: `docker images`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should have this image now: `kasperondocker/system_programming_cookbook`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Docker image with an interactive shell with the help of the following
    command: `docker run -it **-**-cap-add sys_ptrace kasperondocker/system_programming_cookbook:latest /bin/bash`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The shell on the running container is now available. Use `root@39a5a8934370/#
    cd /BOOK/` to get all the programs that we develop throughout the book, organized
    by chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `--cap-add sys_ptrace` argument is needed to allow GDB in the Docker container
    to set breakpoints, which Docker does not allow by default.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing I/O to and from the console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe focuses on console I/O. Most programs we write need some kind of
    interaction with the user: we need to get inputs, do some processing, and return
    the output. Think, for example, about user inputs you could collect in an application
    that you''ll build. In this recipe, we''ll write code that shows different ways
    to get input from the console and return the output.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write some code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the Docker image running, let''s create a new file named `console_01.cpp`
    and type this code into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another file now called `console_02.cpp` and type this code in to see
    the limitation of this approach:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s create a new file and name it `console_03.cpp`; let''s see
    how `std::getline` and `std::cin` can overcome this previous limitation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Although these are very simple examples, they show the C++ way of interacting
    with the console standard input and output.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first step, the `console_01.cpp` program just uses `std::cin` and `std::cout`
    to get the `name` and the `surname` information of the user and save it in the
    `std::string` variables. These are the first things to use when a simple interaction
    with the standard input and output is needed. By building and running the `console_01.cpp`
    file, we''ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c32601b-b89d-43d4-857c-f37964704b56.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The second step of the recipe shows the limitation of `std::cin` and `std::cout`.
    The user gives `name` and `surname` in the command line to the running process
    as programmed, but strangely enough, just the name is stored in the `fullNameWithCin`
    variable, completely skipping the surname. How come? The reason is simple: `std:cin`
    always considers spaces, tabs, or newlines as delimiters of the value captured
    from the standard input. How can we get the full line from the standard input,
    then? By compiling and running `console_02.cpp`, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ebac7a09-1cfb-49bb-aa61-fe0dcce7482a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The third step shows the use of the `getline` function in conjunction with
    `std::cin` to get the full line from the standard input. `std::getline` gets the
    line from `std::cin` and stores it in the `fullName` variable. In general, `std::getline`
    accepts any `std::istream` as input with the possibility of specifying the delimiter.
    The available prototypes in the standard library are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'These make `getline` a very flexible method. By building and running `console_03.cpp`,
    we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/313c17da-22e0-4075-9502-54c86b4e5119.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s have a look at the following example, where we pass a stream to the
    method, the variable to store the extracted piece of information, and the delimiter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6272f92b-7756-45a2-b4c5-a7fb7102e7b7.png)'
  prefs: []
  type: TYPE_IMG
- en: This can form the foundation for building your own tokenizer method.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::cin` and `std::cout` allow chain requests, which makes the code more
    readable and concise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`std::cin` expects the user to pass their name, and then their surname. They
    have to be separated by a space, tab, or newline character.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Learning how to manipulate I/O strings* recipe covers how to manipulate
    strings as a complement of console I/O.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to manipulate I/O strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: String manipulation is a very important aspect of almost any software. Being
    able to manipulate strings simply and effectively is a key aspect of software
    development. How would you read the configuration file of your application or
    parse it? This recipe will teach you what tools C++ offers to make this an enjoyable
    task with the `std::stringstream` class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll develop a program by using `std::stringstream` to parse
    streams, which can actually come from any source: files, strings, input arguments,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s develop a program that prints all the entries of a file. Type the following
    code into a new CPP file, `console_05.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`std::stringstream` is very handy when we have to parse strings into variables.
    Let''s see this in action by writing the following code in a new file, `console_06.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And, to complement the second step, parsing and creating string streams is
    easy too. Let''s do this in `console_07.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding three programs show how simple it is parsing a string in C++.
    The next section will explain them step by step.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Step 1* shows that `std::getline` accepts any stream as input, not just the
    standard input (that is, `std::cin`). In this case, it gets the stream coming
    from a file. We include `iostream` for `std::cout`, `string` to be able to use
    strings, and `fstream` to be able to read the file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we open the `file_console_05.txt` file by using `std::fstream` (file
    stream). In its constructor, we pass the filename and the flags (in this case,
    just the information that is an input file with `std::ifstream::in`). We pass
    the file stream to `std::getline`, which will take care of copying each line from
    the stream and storing it in the `std::string` variable `line`, which is just
    printed. The output of this program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/867418ac-6e1b-4f44-ba9c-7ce3e3c45e78.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Step 2* shows the same program reading the `file_console_05.txt` file, but,
    this time we want to parse each line of the file. We do this by passing the `line` string
    variable to the `sline` `std::stringstream` variable. `std::stringstream` offers
    convenient and easy-to-use parsing capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By just writing the line `sline >> name >> surname >> age`, the `operator>>`
    of the `std::stringstream` class will save the `name`, `surname`, and `age` into
    the respective variables, taking care of the type conversion (that is, for the
    `age` variable, from `string` to `int`), assuming these variables appear in that
    order in the file. The `operator>>` will parse the string and, by skipping leading
    **whitespaces***,* for each token will call the appropriate method (for example, `basic_istream&
    operator>>( short& value );` or `basic_istream& operator>>( long long& value );`,
    among many others). The output of this program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/137a9b31-5a6d-45c2-9966-1de8b3c8cc6b.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Step 3* shows that the same simplicity of parsing a stream into variables
    applies when building a stream too. The same `std::stringstream` variable `sline`
    is used with the `<<` operators, representing that the stream of data now flows
    in the direction of the `string stream` variable, which is printed to the standard
    output in two lines in the following screenshot. The output of this program is,
    as expected, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0bfd621e-e616-449c-b2a4-5c4a1be90335.png)'
  prefs: []
  type: TYPE_IMG
- en: '`std::stringstream` makes it really easy to parse strings and streams, wherever
    they come from.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''re looking for low latency, streams manipulation with `std::stringstream`
    might not be your first choice. We always suggest that you measure the performance
    and make a decision based on data. If that''s the case, you have different solutions
    you can try:'
  prefs: []
  type: TYPE_NORMAL
- en: Just focus on the low-latency part of the code to optimize, if you can.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write your layer using a standard C or C++ method to parse data, for example,
    the typical `atoi()`  method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use any open source low-latency framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Implementing I/O to and from the console* recipe covers how to deal with
    I/O from the console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will teach you the fundamental knowledge needed to deal with files.
    The C++ Standard Library historically offers a very good interface, but C++ 17
    added a namespace called `std::filesystem`, which further enriches the offer.
    We'll not take advantage of the C++17 `std::filesystem` namespace, though, as
    it was already introduced in [Chapter 2](1bf083f4-9d12-4b2e-bf5c-35a2e3d99c36.xhtml),
    *Revisiting C++*. Think about a concrete use case of creating a configuration
    file, or where you'd need to make a copy of that configuration file. This recipe
    will teach you how C++ makes this task easy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll write three programs to learn how to work with files
    by using `std::fstream`, `std::ofstream`, and `std::ifstream`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s develop a program that opens and writes into a new file, `file_01.cpp`,
    by using `std::ofstream`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In a new source file, `file_02.cpp`, let''s read from a file and print to standard
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we want to combine the flexibility of opening a file for both reading and
    writing. We''ll use `std::fstream` to copy the contents of `file_01.txt` into
    `file_03.txt` and then print its content. In another source file, `file_03.cpp`,
    type the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how this recipe works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before getting deep into the preceding three programs, we have to clarify how
    the standard library is structured with regards to file streams. Let''s have a
    look at this following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  | `<fstream>` |'
  prefs: []
  type: TYPE_TB
- en: '| `<ios>` | <--`<ostream>` | <--`ofstream` |'
  prefs: []
  type: TYPE_TB
- en: '| `<ios>` | <-- `<istream>` | <--`ifstream` |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s break it down as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<ostream>`: The streams class responsible for output streams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<istream>`: The streams class responsible for input streams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ofstream`: The streams class for writing to files. Present in the `fstream`
    header file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ifstream`: The streams class for reading from files. Present in the `fstream`
    header file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both `std::ofstream` and `std::ifstream` inherit from the generic stream classes
    of `std::ostream` and `std::istream`, respectively. As you can imagine, `std::cin`
    and `std::cout` also inherit from `std::istream` and `std::ostream` (not shown
    in the preceding table).
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 1*: The first thing we do is include `<iostream>` and `<fstream>` in
    order to use `std::cout` and `std::ofstream` to read the `file_01.txt` file. Then
    we call the `open` method, which, in this case opens the file in writing mode,
    as we''re using the `std::ofstream` class. We are now ready to write our strings
    into the `fout` file stream with the `<<` operator. Finally, we have to close
    the stream, which will end up closing the file. By compiling and running the program,
    we''ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54d34028-d689-4189-be42-0a164bbe3750.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Step 2*: We do the opposite in this case: we read from the `file_01.txt` file
    and print to the standard output. The only difference, in this case, is that we
    use the `std::ifstream` class, which represents a reading file stream. By calling
    the `open()` method, the file is opened in reading mode (`std::ios::in`). By using
    the `std::getline` method, we can print to the standard output all the rows of
    the file. The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d24e9dd6-2fda-49c5-905b-b1e690ba9987.png)'
  prefs: []
  type: TYPE_IMG
- en: The final third step shows the usage of the `std::fstream` class, which gives
    us more freedom by allowing us to open a file in both reading and writing mode
    (`std::ios::out` | `std::ios::in`). We also want to truncate the file if it exists
    (`std::ios::trunc`). There are many more options available to pass to the `std::fstream`
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++17 made a huge improvement by adding the `std::filesystem` to the standard
    library. It is not completely new – it is hugely inspired by the Boost library.
    The main public members exposed are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `path` | Represents a path |'
  prefs: []
  type: TYPE_TB
- en: '| `filesystem_error` | An exception on filesystem errors |'
  prefs: []
  type: TYPE_TB
- en: '| `directory_iterator` | An iterator to the content of the directory (the recursive
    version is available too) |'
  prefs: []
  type: TYPE_TB
- en: '| `space_info` | Information about free and available space on the filesystem
    |'
  prefs: []
  type: TYPE_TB
- en: '| `perms` | Identifies file system permissions system |'
  prefs: []
  type: TYPE_TB
- en: In the `std::filesystem` namespace, there are also helper functions that give
    information about the file, such as `is_directory()`, `is_fifo()`, `is_regular_file()`,
    `is_socket()`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Understanding the filesystem *recipe in [Chapter 2](1bf083f4-9d12-4b2e-bf5c-35a2e3d99c36.xhtml), *Revisiting
    C++*, gives a refresher on the topic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
