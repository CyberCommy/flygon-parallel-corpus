- en: Deploying Goophr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 6](../Text/Ch06.xhtml), *Goophr Concierge* and [Chapter 7](../Text/Ch07.xhtml),
    *Goophr Librarian*, we built two components of Goophr: Concierge and Librarian.
    We took time to understand the rationale behind the design of each of the components
    and how they are expected to work together.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will conclude building Goophr by achieving the following
    objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: Update `concierge/api/query.go` so that Concierge can query multiple instances
    of Librarians for the search terms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update `docker-compose.yaml` so that we can run the complete Goophr system with
    little effort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the setup by adding documents to the index and querying the index via the
    REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating Goophr Concierge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to make Concierge fully functional as per the design of Goophr, we
    need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Request search results from multiple Librarians
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rank the combined search results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss these points in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Handle multiple Librarians
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The core functionality of Goophr Librarian is to update the index and return
    relevant `DocID`s based on the search terms. As we saw while implementing the
    codebase for Librarian, we need to update the index, retrieve relevant `DocID`s,
    and then, based on relevance, sort them before returning query results. Many operations
    are involved and a lot of maps are being used for lookups and updates. These operations
    might seem trivial. However, as the size of the lookup table (map) increases,
    the performance of operations on the lookup table will start to decline. In order
    to avoid such a decline in performance, many approaches can be taken.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our primary goal is to understand distributed systems in the context of Go,
    and, for this reason, we will split Librarian to handle only a certain set of
    the index. Partitioning is one of the standard techniques used in databases, where
    the database is split into multiple partitions. In our case, we  we will have
    three instances of Librarian running, each of which is responsible for handling
    index for all tokens that are within character range, that are assigned to each
    of the partitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`a_m_librarian`: Librarian responsible for tokens starting with character "A"
    to "M"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n_z_librarian`: Librarian responsible for tokens starting with character "N"
    to "Z"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`others_librarian`: Librarian responsible for tokens starting with numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregated search results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next step would be to aggregate results of the search terms from the multiple
    instances of Librarian and return them as a payload to the query request. This
    would require us to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Get a list of the URLs for all of the Librarians available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request search results from all the Librarians when a query is received
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregate search results based on `DocID`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sort the results in descending order of relevance score
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form and return the JSON payload as per the Swagger API definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand the rationale behind having multiple instances of Librarian,
    and how we are going to handle queries based on this new configuration, we can
    apply these changes to `concierge/api/query.go`.
  prefs: []
  type: TYPE_NORMAL
- en: Orchestrating with docker-compose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have been running the servers for Librarian and Concierge on our system''s
    localhost at hardcoded network port values. We haven''t faced any issues with
    it so far. However, when we consider that we will be running three instances of
    Librarian, requiring to connect all of them to Concierge and be able to easily
    start and monitor the servers, we realize that there are a lot of moving parts.
    This can lead to unnecessary errors while operating the system. In order to make
    our life easy, we can rely on `docker-compose`, which will take care of all this
    complexity for us. All we have to do is define a configuration YAML file called
    `docker-compose.yaml` that will provide the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the services we want to run together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The location or name of the respective Dockerfile or Docker image for every
    service defined in the YAML file so that we can build Docker images for all of
    them and run them as containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ports to expose for each of the running containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any further environment variables we might want to inject into our server instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that Concierge's container has access to all other running containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment variables and API ports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We mentioned that we will specify the port we want each of the containers to
    run on in `docker-compose.yaml`. However, we also need to update `{concierge,librarian}/main.go`
    so that they can start the servers at ports defined by environment variables.
    We will also need to update `concierge/query.go` so that it can access the Librarian
    instances on URLs and ports as defined by `docker-compose`.
  prefs: []
  type: TYPE_NORMAL
- en: The file server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to quickly test our setup by loading documents into the indexes, to
    be able to query the system and validate the query results, we will also be including
    a simple HTTP server that serves documents containing a few words.
  prefs: []
  type: TYPE_NORMAL
- en: The Goophr source code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous two chapters, [Chapter 6](../Text/Ch06.xhtml), *Goophr Concierge*
    and [Chapter 7](../Text/Ch07.xhtml), *Goophr Librarian*, we discussed the code
    for Concierge and Librarian respectively. In order to run the complete Goophr
    application using `docker-compose`, we will need to merge the codebases of both
    Librarian and Concierge into a single codebase. The codebase will also include
    `docker-compose.yaml` and code for the file server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will not list the code for all the files in Librarian and
    Concierge but only the files with changes. Let''s start by looking at the structure
    of the complete project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: librarian/main.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We want to allow the Librarian to start on a custom port based on the environment
    variable, `API_PORT`, passed to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: concierge/main.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Allow Concierge to start on a custom port based on the environment variable,
    `API_PORT`, passed to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: concierge/api/query.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Query all the available Librarian instances to retrieve search query results,
    rank them in order, and then send back the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: simple-server/Dockerfile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s use `Dockerfile` to create a simple file server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: simple-server/main.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at a simple program that returns a set of words as an HTTP response
    based on `bookID`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: docker-compose.yaml
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This file will allow us to build, run, connect and stop our containers from
    a single interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Linked services can be referred to using the service name as the domain name.
  prefs: []
  type: TYPE_NORMAL
- en: .env
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`.env` is used within `docker-compose.yaml` to load template variables. It
    follows the format of `<template-variable>=<value>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can view the `docker-compose.yaml` with substituted values by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Running Goophr with docker-compose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have everything in place, let''s start the complete application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Adding documents to Goophr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since we have three documents in our file server, we can add them to Goophr
    using the following `curl` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the logs for the preceding cURL requests as seen by `docker-compose`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Searching for keywords with Goophr
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the complete application running and some documents in the
    index, let''s test it by searching for some of the keywords. The following is
    the list of terms we will be searching for and the expected order:'
  prefs: []
  type: TYPE_NORMAL
- en: '**"apple"** - book1 (score: 2), book 3 (score: 1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**"cake"** - book 3 (score: 2), book 2 (score: 1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**"apple"**, "**cake"** - book 3 (score 3), book 1 (score: 2), book 2 (score:
    1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search – "apple"
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us search for `"apple"` alone using the cURL command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the `docker-compose` logs when we search for `"apple"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Search – "cake"
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us search for `"cake"` alone using the cURL command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the `docker-compose` logs when we search for `"cake"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Search – "apple", "cake"
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us search for `"apple"` and `"cake"` together using the cURL command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the `docker-compose` logs when we search for `"apple"` and `"cake"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Individual logs with docker-compose
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also view logs of each service separately. The following are the logs
    for Concierge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Authorization on a web server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our search application trusts every incoming request. However, sometimes restricting
    access might be the right way to go. It would be desirable if, for every incoming
    request, we could accept and identify requests from certain users. This can be
    achieved using **authorization tokens** (**auth tokens**). An auth token is a
    secret code/phrase sent in the header for the key, **Authorization**.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization and auth tokens are deep and important topics. It would not be
    possible to cover the complexity of the subject in this section. Instead, we will
    build a simple server that will make use of auth tokens to accept or reject a
    request. Let us look at the source code.
  prefs: []
  type: TYPE_NORMAL
- en: secure/secure.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`secure.go` shows the logic for the simple server. It has been divided into
    four functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The `requestHandler` function to respond to incoming HTTP requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `isAuthorized` function to check if the incoming request is authorized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getAuthorizedUser` function to check if the token has an associated user.
    If the token does not have an associated user, then the token is considered to
    be invalid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `main` function to start the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: secure/secure_test.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we will try to test the logic we have written in `secure.go` using unit
    tests. A good practice is to test each of the functions for all possible cases
    of success and failure. The test names explain the intent of the test, so let''s
    look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Test results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, let us run the tests and see if they produce the expected results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we started by trying to understand why we need to run multiple
    instances of Goophr Librarian. Next, we looked at how to implement the updated `concierge/api/query.go` so
    that it can work with multiple instances of Librarian. Then we looked into why
    using `docker-compose` to orchestrate the application might be a good idea and
    what may be the various factors to keep in mind to make it work. We also updated
    the Librarian and Concierge codebase so that they would work seamlessly with `docker-compose`.
    Finally, we tested the complete application using a few small documents and reasoning
    about the expected order of results.
  prefs: []
  type: TYPE_NORMAL
- en: We were able to orchestrate all the servers we needed to run the complete Goophr
    application on our local machine using `docker-compose`. However, designing the
    architecture of a resilient web application to withstand heavy user traffic on
    the internet can be quite challenging. [Chapter 9](../Text/Ch09.xhtml), *Foundations
    of Web Scale Architecture* tries to address this issue by providing some basic
    knowledge of things to take into consideration while designing for the web.
  prefs: []
  type: TYPE_NORMAL
