- en: Using the Standard Library Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Standard Library provides several types of containers; each is provided
    through a templated class so that the behavior of the container can be used for
    items of any type. There are classes for sequential containers, where the ordering
    of the items in the container is dependent on the order that the items are inserted
    into the container. Also there are sorted and unsorted associated containers that
    associate a value with a key, and subsequently the value is accessed using the
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although not containers themselves, in this chapter we will also cover two
    related classes: `pair` that links two values together in one object, and `tuple`,
    that can hold one or more values in a single object.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with pairs and tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many cases you will want to associate two items together; for example, an
    associative container allows you to create a type of array where items other than
    numbers are used as an index. The `<utility>` header file contains a templated
    class called `pair`, which has two data members called `first` and `second`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the class is templated, it means that you can associate any items, including
    pointers or references. Accessing the members is simple since they are public.
    You can also use the `get` templated function, so for a `pair` object `p` you
    can call `get<0>(p)` rather than `p.first`. The class also has a copy constructor,
    so that you can create an object from another object, and a move constructor.
    There is also a function called `make_pair` that will deduce the types of the
    members from the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Be wary because the compiler will use the type that it thinks is most appropriate;
    in this case the `pair` object created will be `pair<const char*, int>`, but if
    you want the `first` item to be a `string`, it is simpler to use the constructor.
    You can compare `pair` objects; the comparison is performed on the first member
    and only if they are equal is the second then compared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters can be references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `make_pair` function will deduce the types from the parameters. The compiler
    cannot tell the difference between a variable and a reference to a variable. In
    C++11 you can use the `ref` function (in `<functional>`) to specify that the `pair`
    will be for references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to return two values from a function, you could do it via parameters
    passed by reference, but the code is less readable because you expect a return
    value to come through the return of a function rather than through its parameters.
    The `pair` class allows you to return two values in one object. One example is
    the `minmax` function in `<algorithm>`. This returns a `pair` object containing
    the parameters in order of the smallest first, and there is an overload where
    you can provide a predicate object if the default operator `<` should not be used.
    The following will print `{10,20}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pair` class associates two items. The Standard Library provides the `tuple`
    class that has a similar functionality, but since the template is variadic it
    means that you can have any number of parameters of any type. However, the data
    members are not named as in `pair`, instead you access them via the templated
    `get` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates a `tuple` that holds three `int` items and it is initialized
    using an initialize list (you could use constructor syntax). The `tuple` is then
    printed to the console by accessing each data member in the object using a version
    of the `get` function where the template parameter indicates the index of the
    item. Note that the index is a template parameter, so you cannot provide it at
    runtime using a variable. If this is what you want to do, then it is a clear indication
    that you need to use a container such as `vector`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get` function returns a reference, so this can be used to change the value
    of the item. For a `tuple t3`, this code changes the first item to `42` and the
    second to `99`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also extract all the items with one call, by using the `tie` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tie` function returns a `tuple` in which each parameter is a reference
    and initialized to the variables that you pass as parameters. The previous code
    is easier to understand if you write it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A `tuple` object can be created from a `pair` object, and so you can use the
    `tie` function to extract values from a `pair` object too.
  prefs: []
  type: TYPE_NORMAL
- en: There is a helper function called `make_tuple`, which will deduce the types
    of the parameters. As with the `make_pair` function, you have to be wary of the
    deductions, so a floating-point number will be deduced to be a `double` and an
    integer will be an `int`. If you want the parameters to be references to specific
    variables, you can use the `ref` function or the `cref` function for a `const`
    reference.
  prefs: []
  type: TYPE_NORMAL
- en: You can compare `tuple` objects as long as there are equal numbers of items
    and equivalent types. The compiler will refuse to compile comparisons of `tuple`
    objects that have different numbers of items or if the types of the items of one
    `tuple` objects cannot be converted to the types of the other `tuple` object.
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Standard Library containers allow you to group together zero or more items
    of the same type and access them serially through iterators. Every such object
    has a `begin` method that returns an iterator object to the first item and an
    `end` function that returns an iterator object for the item after the last item
    in the container. The iterator objects support pointer-like arithmetic, so that
    `end() - begin()` will give the number of items in the container. All container
    types will implement the `empty` method to indicate if there are no items in the
    container, and (except for `forward_list`) the `size` method is the number of
    items in the container. You are tempted to iterate through a container as if it
    is an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that not all containers allow random access, and if you decide
    it is more efficient to use another container, you''ll have to change how the
    container is accessed. This code also does not work well if you want to write
    generic code using templates. The previous code is better written using iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: All of the containers have a `typedef` member called `iterator` that gives the
    type of the iterator returned from the `begin` method. Iterator objects behave
    like pointers, so you can obtain the item an iterator refers to using the dereference
    operator and move to the next item using the increment operator.
  prefs: []
  type: TYPE_NORMAL
- en: For all containers except for `vector`, there is a guarantee that an iterator
    will remain valid even if other elements are deleted. If you insert items, then
    only `lists`, `forward_lists`, and associated container guarantee that the iterators
    remain valid. Iterators will be covered in more depth later.
  prefs: []
  type: TYPE_NORMAL
- en: All containers have to have an exception safe (nothrow) method called `swap`,
    and (with two exceptions) they must have *transactional* semantics; that is, an
    operation must succeed or fail. If the operation fails, the container is in the
    same state as before the operation is called. For every container, this rule is
    relaxed when it comes to multi-element inserts. If you insert many items at a
    time using an iterator range, for example, and the insert fails for one of the
    items in the range, then the method will not be able to undo the previous inserts.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to point out that objects are copied into containers, so the
    type of the objects that you put into a container must have a copy and copy assignment
    operator. Also, be aware that if you put a derived class object into a container
    that requires a base class object, then the copying will slice the object, meaning
    that anything to do with the derived class is removed (data members and virtual
    method pointers).
  prefs: []
  type: TYPE_NORMAL
- en: Sequence containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sequence containers store a series of items and the order that they are stored
    in, and, when you access them with an iterator, the items are retrieved in the
    order in which they were put into the container. After creating a container, you
    can change the sort order with library functions.
  prefs: []
  type: TYPE_NORMAL
- en: List
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, a `list` object is implemented by a doubly linked list
    in which each item has a link to the next item and the previous one. This means
    that it is quick to insert items (as the example in [Chapter 4](63ba5350-63d3-4dff-9ba2-b330f041d670.xhtml),
    *Working with Memory, Arrays, and Pointers*, showed with a singly linked list),
    but since, in a linked list, an item only has access to the items in front and
    behind it, there is no random access with the `[]` indexoperator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class allows you to provide values through the constructor, or you can
    use member methods. For example, the `assign` method allows you fill the container
    in one action using an initializer list, or, with iterators, to a range in another
    container. You can also insert a single item using the `push_back` or `push_front`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line creates a `list` object that contains `3`, `5`, and `7`, and
    then pushes `11` and `13` to the end (in that order), so that the `list` contains
    `{3,5,7,11,13}`. The code then pushes the numbers `2` and `1` to the front, so
    that the final `list` is `{1,2,3,5,7,11,13}`. In spite of the names, the `pop_front`
    and `pop_back` methods just remove the item at the front or back of the list,
    but will not return the item. If you want to get the item that has been removed,
    you must *first* access the item through the `front` or `back` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clear` method will remove all items in the `list` and the `erase` method
    will delete items. There are two versions: one with an iterator that identifies
    a single item and another that has two iterators that indicate a range. A range
    is indicated by providing the first item in the range and the item *after* the
    range.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a general principle with iterators and the Standard Library containers;
    a range is indicated by iterators by the first item and the item *after* the last
    item. The `remove` method will remove all items with a specified value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a method `remove_if` that takes a predicate and will only remove
    an item if the predicate returns `true`. Similarly, you can insert items into
    a list with an iterator, and the item is inserted before the specified item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can also indicate that the item should be inserted more than once at that
    position (and if so, how many copies) and you can provide several items to be
    inserted at one point. Of course, if the iterator you pass is obtained by calling
    the `begin` method, then the item is inserted at the beginning of the `list`.
    The same can be achieved by calling the `push_front` method. Similarly, if the
    iterator is obtained by calling the `end` method, then the item is inserted at
    the end of the `list`, which is the same as calling `push_back`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you call the `insert` method, you provide an object that will either be
    copied into the `list` or moved into the `list` (through rvalue semantics). The
    class also provides several **emplace** methods (`emplace`, `emplace_front`, and
    `emplace_back`) that will construct a new object based on the data you provide,
    and insert that object in the `list`. For example, if you have a `point` class
    that can be created from two `double` values, you can either `insert` a constructed
    `point` object or `emplace` a `point` object by providing two `double` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Once you have created a `list`, you can manipulate it with member functions.
    The `swap` method takes a suitable `list` object as a parameter, it moves the
    items from the parameter into the current object, and moves the items in the current
    `list` to the parameter. Since the `list` object is implemented using linked lists,
    this operation is quick.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, code `num1` will contain `{3,1,4,5,6,8}` and `num2` will contain
    `{2,7,1,8,2,8}`, as the following illustrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0bf7a5fa-4bd5-47b5-a66f-797feb112b08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A `list` will hold the items in the order that they were inserted into the
    container; however, you can sort them by calling the `sort` method that will,
    by default, order items in ascending order using the `<` operator for the items
    in the `list` container. You can also pass a function object for a comparison
    operation. Once sorted, you can reverse the order of items by calling the `reverse`
    method. Two sorted lists can be merged, which involves taking the items from the
    argument list and inserting them into the calling list, in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Merging two lists may result in duplicates, and these can be removed by calling
    the `unique` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Forward list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, the `forward_list` class is like the `list` class, but
    it only allows items to insert and remove items from the front of the list. It
    also means that the iterators used with the class can only be incremented; the
    compiler will refuse to allow you to decrement such an iterator. The class has
    a subset of the methods of `list`, so it has the `push_front`, `pop_front`, and
    `emplace_front` methods, but not the corresponding `_back` methods. There are
    some other methods that it implements, and, because the list items can only be
    accessed in a forward direction, it means that insertions will occur after an
    existing item, and hence the class implements `insert_after` and `emplace_after`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you can remove items at the beginning of the list (`pop_front`)
    or after a specified item (`erase_after`), or tell the class to iterate in a forward
    direction through the list and remove items with a specific value (`remove` and
    `remove_if`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code `euler` is initialized with the digits of Euler's number
    and a value of `-1` is pushed to the front. Next, an iterator is obtained that
    points to the first value in the container; that is, to the position of the value
    of `-1`. A value of `-2` is inserted after the position of the iterator; that
    is, `-2` is inserted after the value of `-1`. The last two lines show how to remove
    items; `pop_front` removes the item at the front of the container and `remove_if`
    will remove items that satisfy the predicate (in this case when the item is less
    than zero).
  prefs: []
  type: TYPE_NORMAL
- en: Vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `vector` class has the behavior of a dynamic array; that is, there is indexed
    random access to items and the container will grow as more items are inserted
    into it. You can create a `vector` object with an initialization list, and with
    a specified number of copies of an item. You can also base a `vector` on values
    in another container by passing iterators that indicate the range of items in
    that container. You can create a vector with a pre-determined size by providing
    a capacity as the constructor parameter, and the specified number of default items
    will be created in the container. If, at a later stage, you need to specify the
    container size, you can call the `reserve` method to specify the minimum size
    or the `resize` method, which may mean deleting excess items or creating new items
    depending on whether the existing `vector` object is bigger or smaller than the
    requested size.
  prefs: []
  type: TYPE_NORMAL
- en: When you insert items into a `vector` container and there is not enough memory
    allocated, then the container will allocate enough memory. This will involve allocating
    new memory, copying the existing items into the new memory, creating the new item,
    and, finally, destroying the old copy of the items and deallocating the old memory.
    Clearly, if you know the number of items and you know that the `vector` container
    will not be able to contain them without a new allocation, you should indicate
    how much space you need by calling the `reserve` method.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting items other than the constructor is straightforward. You can use `push_back`
    to insert an item at the end (which is a fast action, assuming no allocation is
    needed) and there is also `pop_back` to remove the last item. You can also use
    the `assign` method to clear the entire container and insert the specified items
    (either a multiple of the same item, an initializer list of items, or items in
    another container specified with iterators). As with `list` objects, you can clear
    the entire `vector`, erase items at a position, or insert items at a specified
    position. However, there is no equivalent of the `remove` method to remove items
    with a specific value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main reason to use the `vector` class is to get random access using either
    the `at` method or the `[]` indexing operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates a `vector` with ten items, and then in the loop the C
    runtime function `rand` is called a thousand times each time to get a pseudo random
    number between 0 and 32767\. The modulus operator is used to get, in approximate
    terms, a random number between 0 and 9\. This random number is then used as an
    index for the `distrib` object to select a specified item, which is then incremented.
    Finally, the distribution is printed out and, as you would expect, this gives
    a value of roughly 100 in each item.
  prefs: []
  type: TYPE_NORMAL
- en: This code relies on the fact that the `[]` operator returns a reference to the
    item, which is why the item can be incremented in this manner. The `[]` operator
    can be used to read and write to an item in the container. The container gives
    iterator access through the `begin` and `end` methods, and (since they are needed
    by the container adapters) the `front` and `back` methods.
  prefs: []
  type: TYPE_NORMAL
- en: A `vector` object can hold any type that has a copy constructor and assignment
    operator, which means all the built-in types. As it stands, a `vector` of `bool`
    items would be a waste of memory because a Boolean value can be stored as a single
    bit and the compiler will treat a `bool` as an integer (32 bits). The Standard
    Library has a specialization of the `vector` class for `bool` that stores items
    more efficiently. However, although the class at first sight looks like a good
    idea, the problem is that, since the container holds Boolean values as bits, this
    means that the `[]` operator doesn't return a reference to a `bool` (instead it
    returns an object that behaves like one).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to hold Boolean values and manipulate them then, as long as you
    know at compile time how many items there are, the `bitset` class is probably
    a better choice.
  prefs: []
  type: TYPE_NORMAL
- en: Deque
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The name `deque` means *double-ended queue*, which means that it can grow from
    both ends, and, although you can insert items in the middle, it is more expensive.
    As a queue, it means that the items are ordered, but, because the items can be
    put into the queue from either end, the order is not necessarily the same order
    in which you put items into the container.
  prefs: []
  type: TYPE_NORMAL
- en: The interface of `deque` is similar to a `vector`, so you have iterator access
    as well as random access using the `at` function and the `[]` operator. As with
    a `vector`, you can access items from the end of a `deque` container using the
    `push_back`, `pop_back`, and `back` methods, but, unlike a `vector`, you can also
    access the front of a `deque` container using the `push_front`, `pop_front`, and
    `front` methods. Although the `deque` class has methods to allow you to insert
    and erase items within the container, and to `resize`, these are expensive operations,
    and if you need to use them then you should reconsider using this container type.
    Furthermore, the `deque` class does not have methods to pre-allocate memory, so,
    potentially, when you add an item to this container, it could cause a memory allocation.
  prefs: []
  type: TYPE_NORMAL
- en: Associative containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a C-like `array` or a `vector`, each item is associated with its numeric
    index. Earlier this was exploited in one of the examples in the section on `vector`
    in which the index provided the decile of the distribution and, conveniently,
    the distribution was split in a way that the ten deciles of data are numbered.
  prefs: []
  type: TYPE_NORMAL
- en: An associative container allows you to provide indexes that are not numeric;
    these are the keys, and you can associate values with them. As you insert key-value
    pairs into the container, they will be ordered so that the container can subsequently
    efficiently access the value by its key. Typically, this order should not matter
    to you since you will not use the container to access items sequentially, and
    instead you will access values by their keys. A typical implementation will use
    a binary tree or a hash table, which means that it is a quick operation to find
    an item according to its key.
  prefs: []
  type: TYPE_NORMAL
- en: For ordered containers, such as `map`, there will be comparisons carried out
    between the key and the existing keys in the container using `<` (the less predicate).
    The default predicate means that the keys are compared, and if this is, say, a
    smart pointer, then it will be the smart pointer objects that will be compared
    and used for the ordering, not the object that they wrap. In this case, you will
    want to write your own predicate to perform the appropriate comparison and pass
    it as a template parameter.
  prefs: []
  type: TYPE_NORMAL
- en: This means it is typically expensive to insert or erase items, and the key is
    treated as immutable, so you cannot alter it for an item. For all associative
    containers, there are no remove methods, but there are erase methods. However,
    for those containers that keep items sorted, erasing an item could affect performance.
  prefs: []
  type: TYPE_NORMAL
- en: There are several types of associative containers, and the main difference is
    how they handle duplicate keys and the level of ordering that occurs. The `map`
    class has key-value pairs sorted by unique keys, so duplicate keys are not allowed.
    If you want to allow duplicate keys, then you can use the `multimap` class. The
    `set` class is essentially a map where the key is the same as the value, which,
    again, does not allow duplicates. The `multiset` class does allow duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: It may seem odd to have an associative class where the key is the same as the
    value, but the reason for including the class in this section is because, like
    the `map` class, the `set` class has a similar interface to find a value. Also
    similar to the `map` class, the `set` class is fast at finding an item.
  prefs: []
  type: TYPE_NORMAL
- en: Maps and multimaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `map` container stores two different items, a key and a value, and it maintains
    the items in an sort order according to the key. A sorted `map` means that it
    is quick to locate an item. The class has the same interface as other containers
    to add items: you can put them into the container via the constructor, or you
    can use member methods `insert` and `emplace`. You also have access to items via
    iterators. Of course, an iterator gives access to a single value, so with a map
    this will be to a `pair` object that has both the key and the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The calls to `emplace` puts items into the `map` where the key is a `string`
    (the name of a president) and the value is an `int` (the year the president started
    their term of office). The code then obtains an iterator to the first item in
    the container, and the item is accessed by dereferencing the iterator to give
    a `pair` object. Since the items are stored in the `map` in a sorted order, the
    first item will be set to `"Adams"`. You can also insert items as `pair` objects,
    either as objects or through iterators to `pair` objects in another container
    using the `insert` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the `emplace` and `insert` methods will return a `pair` object of the
    following form, where the `iterator` type is relevant to the `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You use this object to test for two things. First, the `bool` indicates if the
    insertion was successful (it will fail if an item with the same key is already
    in the container). Secondly, the `iterator` part of the `pair` either indicates
    the position of the new item or it indicates the position of the existing item
    that will not be replaced (and will cause the insertion to fail).
  prefs: []
  type: TYPE_NORMAL
- en: The *failure* depends on *equivalence* rather than *equality*. If there is an
    item with a key that is equivalent to the item you are trying to insert, then
    the insertion will fail. The definition of equivalence depends on the comparator
    predicate being used with the `map` object. So, if the `map` uses a predicate
    `comp`, then equivalence between the two items, `a` and `b`, is determined by
    testing `!comp(a,b) && !comp(b,a)`. This is not the same as testing for `(a==b)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming the previous `map` object, you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The second item in the `result` variable is tested to see if the insertion was
    successful, and if not, then the first item is an iterator to a `pair<string,int>`,
    which is the existing item, and the code dereferences the iterator to get the
    `pair` object and then prints out the first item, which is the key (in this case,
    the name of the person).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you know where in the `map` the item should go, then you can call `emplace_hint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we know that `Polk` comes after `Monroe` so we can pass the iterator to
    `Monroe` as the hint. The class gives access to items via iterators, so you can
    use ranged `for` (which is based on iterator access):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, there is access to individual items using the `at` method and
    the `[]` operator. In both cases the class will search for an item with the provided
    key and if the item is found, a reference to the item''s value is returned. The
    `at` method and the `[]` operator behave differently in a situation where there
    is no item with the specified key. If the key does not exist, the `at` method
    will throw an exception; if the `[]` operator cannot find the specified key, it
    will create a new item using the key and calling the default constructor of the
    value type. The `[]` operator will return a reference to the value if the key
    exists, so you can write code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The second line behaves as you expect: there will be no item with a key of
    `Jackson`, so the `map` will create an item with that key, initialize it by calling
    the default constructor of the value type (`int`, so the value is initialized
    to zero), and then it returns a reference to this value, which is assigned a value
    of `1829`. The first line, however, will look up `Adams`, see that there is an
    item, and return a reference to its value, which is then assigned a value of `1825`.
    There is no indication that the value of an item has been changed as opposed to
    a new item being inserted. You may want this behavior in some circumstances, but
    it is not the intention in this code, where, clearly, an associative container
    that allows duplicate keys (such as `multimap`) is needed. Furthermore, in both
    of these cases, there is a search for the key, a reference is returned, and then
    an assignment is performed. Be aware that, although it is valid to insert items
    this way, it is more efficient to emplace a new key-value pair in the container
    because you do not have this extra assignment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have filled the `map` you can search for a value using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `at` method, which is passed a key and returns a reference to the value
    for that key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `[]` operator, which when passed a key returns a reference to the value
    for that key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `find` function, which will use the predicate specified in the template
    (unlike the global `find` function, mentioned later) and it will give you an iterator
    to the entire item as a `pair` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `begin` method will give you an iterator to the first item and the `end`
    method will give you an iterator *after* the last item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `lower_bound` method returns an iterator to the item that has a key *equal**to
    or greater* than the key that you pass as a parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `upper_bound` method returns an iterator of the first item in the map that
    has a key *greater* than the key provided
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `equal_range` method returns both the lower and upper bounds values in a
    `pair` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets and multisets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sets behave as if they are maps, but the key is the same as the value; for
    example, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This will print out *nine* people in alphabetical order because there are two
    items called `Adams`, and the `set` class will reject duplicates. As the items
    are inserted into the set it will be ordered, and in this case the order is determined
    by the lexicon ordering of comparing two `string` objects. If you want to allow
    duplicates, so that ten people will be placed in the container, then you should
    use `multiset` instead.
  prefs: []
  type: TYPE_NORMAL
- en: As with a `map`, you cannot change the key of an item in the container because
    the key is used to determine the ordering. For a `set`, the key is the same as
    the value, so this means that you cannot change the item at all. If the intention
    is to perform lookups, then it may be better to use a sorted `vector` instead.
    A `set` will have more memory allocation overhead than a `vector`. Potentially,
    a lookup on a `set` container will be quicker than on a `vector` container if
    the search is sequential, but if you use a call to `binary_search` (explained
    in the *Sorting items* section, later) it could be faster than the associative
    container.
  prefs: []
  type: TYPE_NORMAL
- en: The interface to the `set` class is a restricted version of the `map` class,
    so you can `insert` and `emplace` items in the container, assign it to values
    in another container, and you have iterator access (`begin` and `end` methods).
  prefs: []
  type: TYPE_NORMAL
- en: Since there is no distinct key, it means that the `find` method looks for a
    value, not a key (and similarly with the bounds methods; for example, `equal_range`).
    There is no `at` method, nor an `[]` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Unordered containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `map` and `set` classes allow you to find objects quickly, and this is
    facilitated by these classes holding the items in a sorted order. If you iterate
    through the items (from `begin` to `end`), then you will get those items in the
    sorted order. If you want a selection of objects within a range of the key values,
    you can make calls to the `lower_bound` and `upper_bound` methods, to get iterators
    to the appropriate ranges of keys. This are two important features of these associative
    containers: lookup and sorting. In some cases the actual order of the values is
    not important, and the behavior you want is efficient lookup. In this case, you
    can use the `unordered_` versions of the `map` and `set` classes. Since the order
    is unimportant, these are implemented using a hash table.'
  prefs: []
  type: TYPE_NORMAL
- en: Special purpose containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The containers described so far are flexible and can be used for all kinds of
    purposes. The Standard Library provides classes that have specific purposes, but,
    because they are implemented by wrapping other classes, they are called **container
    adapters**. For example, a `deque` object can be used as a **first-in first-out**
    (**FIFO**) queue, by pushing objects to the back of the `deque` (with `push_back`)
    and then accessing objects from the front of the queue using the `front` method
    (and removing them with `pop_front`). The Standard Library implements a container
    adapter called `queue` that has this FIFO behavior, and it is based on the `deque`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You `push` items into the queue and remove them with `pop`, and the next item
    is accessed using the `front` method. The Standard Library containers that can
    be wrapped by this adapter must implement the `push_back`, `pop_front`, and `front`
    methods. That is, items are put into the container at one end and accessed (and
    removed) from the other end.
  prefs: []
  type: TYPE_NORMAL
- en: A **last-in first-out** (**LIFO**) container will put in items and access (and
    remove) items from the same end. Again, a `deque` object can be used to implement
    this behavior by pushing items using `push_back`, accessing the items using `front`,
    and removing them with the `pop_back` method. The Standard Library provides an
    adapter class called `stack` to provide this behavior. This has a method called
    `push` to push items into the container, a method called `pop` to remove items,
    but, oddly, you access the next item using the `top` method, even though it is
    implemented using the `back` method of the wrapped container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The adapter class `priority_queue`, in spite of the name, is used like the
    `stack` container; that is, items are accessed using the `top` method. The container
    ensures that when an item is pushed in, the top of the queue will always be the
    item with the highest priority. A predicate (the default is `<`) is used to order
    the items in the queue. For example, we could have an aggregate type that has
    the name of a task and the priority in which you must complete the task compared
    to other tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The aggregate type is straightforward; it has two data members that are initialized
    by the constructor. So that tasks can be ordered, we need to be able to compare
    two task objects. One option (given earlier) is to define a separate predicate
    class. In this example, we use the default predicate, which the documentation
    says will be `less<task>`, and this compares items based on the `<` operator.
    So that we can use the default predicate, we define the `<` operator for the `task`
    class. Now we can add tasks to a `priority_queue` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The queue has ordered the tasks according to the `priority` data item, and the
    combination of `top` and `pop` method calls reads the items in priority order
    and removes them from the queue. Items with the same priority are placed in the
    queue in the order in which they were pushed in.
  prefs: []
  type: TYPE_NORMAL
- en: Using iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, in this chapter we have indicated that containers give access to items
    through iterators. The implication is that iterators are simply pointers, and
    this is deliberate because iterators behave *like* pointers. However, they are
    usually objects of iterator classes (see the `<iterator>` header). All iterators
    have the following behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Behaviors** |'
  prefs: []
  type: TYPE_TB
- en: '| * | Gives access to the element at the current position |'
  prefs: []
  type: TYPE_TB
- en: '| ++ | Moves forward to the next element (usually you will use the prefix operator)(this
    is only if the iterator allows forward movement) |'
  prefs: []
  type: TYPE_TB
- en: '| -- | Moves backward to the previous element (usually you will use the prefix
    operator)(this is only if the iterator allows backward movement) |'
  prefs: []
  type: TYPE_TB
- en: '| `==` and `!=` | Compares if two iterators are in the same position |'
  prefs: []
  type: TYPE_TB
- en: '| = | Assigns an iterator |'
  prefs: []
  type: TYPE_TB
- en: Unlike a C++ pointer, which assumes that data is contiguous in memory, iterators
    can be used for more complex data structures, such as linked lists, where the
    items may not be contiguous. The operators `++` and `--` work as expected, regardless
    of the underlying storage mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: The `<iterator>` header declares the `next` global function that will increment
    an iterator and the `advance` function that will change an iterator by a specified
    number of positions (forward or backward depending on whether the parameter is
    negative and the direction allowed by the iterator). There is also a `prev` function
    to decrement an iterator by one or more positions. The `distance` function can
    be used to determine how many items are between two iterators.
  prefs: []
  type: TYPE_NORMAL
- en: 'All containers have a `begin` method, which returns the iterator for the first
    item, and an `end` method, which returns an iterator *after* the last item. This
    means that you can iterate through all items in the container by calling `begin`
    and then incrementing the iterator until it has the value returned from `end`.
    The `*` operator on an iterator gives access to the element in the container,
    and if the iterator is read-write (as it will be if returned from the begin method)
    it means the item can be changed. Containers also have the `cbegin` and `cend`
    methods that will return a constant iterator that gives just read-only access
    to elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here `const` has no effect because the variable is `auto` and the type is deduced
    from the item used to initialize the variable. The `cbegin` method is defined
    to return a `const` iterator, so you cannot alter the item it refers to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `begin` and `cbegin` methods return **forward iterators** so that the `++`
    operator moves the iterator forward. Containers may also support **reverse iterators**,
    where `rbegin` is the last item in the container (that is, the item *before* the
    position returned by `end`) and `rend` is the position *before* the first item.
    (There are also `crbegin` and `crend`, which return `const` iterators.) It is
    important to realize that the `++` operator for a reverse iterator moves *backwards*,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `++` operator increments the iterator according to the type of the iterator
    that it is applied to. It is important to note that the `!=` operator is used
    here to determine if the looping should end because the `!=` operator will be
    defined on all iterators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The iterator type here is ignored by using the `auto` keyword. In fact, all
    containers will have `typedef` for all the iterator types they use, so in the
    previous case we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Containers that allow forward iteration will have a `typedef` for `iterator`
    and `const_iterator`, and containers that allow reverse iteration will have a
    `typedef` for `reverse_iterator` and `const_reverse_iterator`. To be complete,
    containers will also have `typedef` for `pointer` and `const_pointer` for the
    methods that return pointers to the elements, and `reference` and `const_reference`
    for methods that return references to elements. These type definitions enable
    you to write generic code where you do not know the types in a container, but
    the code will still be able to declare variables of the right type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although they look like they are pointers, iterators are often implemented
    by classes. These types may only allow iteration in one direction: a forward iterator
    will only have the `++` operator, a reverse iterator will have the `-` operator,
    or the type may allow iteration in both directions (bidirectional iterators) and
    so they implement both the `++` and `--` operators. For example, the iterators
    on the `list`, `set`, `multiset`, `map`, and `multimap` classes are bidirectional.
    The `vector`, `deque`, `array`, and `string` class have iterators that allow random
    access, so these iterator types have the same behavior as bidirectional iterators,
    but also have pointers like arithmetic, so they can be changed by more than one
    item position at a time.'
  prefs: []
  type: TYPE_NORMAL
- en: Input and output iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name suggests, an input iterator will only move forward and will have
    read access, and an output iterator will only move forward but will have write
    access. These iterators do not have random access and they do not allow backward
    movement. For example, an output stream may be used with an output iterator: you
    assign the dereferenced iterator with a data item in order to write that data
    item to the stream. Similarly, an input stream could have an input iterator and
    you dereference the iterator to get access to the next item in the stream. This
    behavior means that for an output iterator the only valid use of the dereference
    operator (`*`) is on the left-hand side of an assignment. It makes no sense to
    check the value of an iterator with `!=`, and you cannot check if assigning a
    value through the output iterator is successful.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `transform` function takes three iterators and a function.
    The first two iterators are input iterators and indicate a range of items to be
    transformed by the function. The result will be put in a range of items (the same
    size as the range of the input iterator), the first of which is indicated by the
    third iterator, which is an output iterator. One way to do this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here the `begin` and `end` methods return iterators on the `data` container
    that are safe to be used as input iterators. The `begin` method on the `results`
    container can only be used as an output iterator as long as the container has
    enough allocated items, and this is the case in this code because they have been
    allocated with `resize`. The function will then transform each input item by passing
    it to the lambda function given in the last parameter (which simply returns the
    square of the value). It is important to reassess what is happening here; the
    third parameter of the `transform` function is an output iterator, which means
    that you should expect the function to write values through this iterator.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code works, but it requires the extra step to allocate the space, and
    you have the extra allocations of default objects in the container just so that
    you can overwrite them. It is also important to mention that the output iterator
    does not have to be to another container. It can be to the same container as long
    as it refers to a range that can be written to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `vec` container is resized so that there is space for the results. The range
    of values to transform are from the beginning item to the fifth item (`vec.begin()
    + 5` is the next item), and the place to write the transformed value is the sixth
    to tenth items. If you print out the vector you will get `{1,2,3,4,5,1,4,9,16,25}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another type of output iterator is the inserter. The `back_inserter` is used
    on containers with `push_back`, and `front_inserter` is used on containers with
    `push_front`. As the name suggests, an inserter calls the `insert` method on the
    container. For example, you can use a `back_inserter` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The results of the transformation are inserted into the `results` container
    with the temporary object created from the `back_inserter` class. Using a `back_inserter`
    object ensures that when the `transform` function writes through the iterator
    the item is *inserted* into the wrapped container using `push_back`. Note that
    the results container should be different to the source container.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want the values in reverse order, then if the container supports `push_front`
    (for example, `deque`), then you can use a `front_inserter`. The `vector` class
    does not have a `push_front` method, but it does have reverse iterators, so you
    can use them instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: All you need to do to reverse the order of the results is to change `begin`
    to `rbegin` and `end` to `rend`.
  prefs: []
  type: TYPE_NORMAL
- en: Stream iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are adapter classes in `<iterators>` that can be used to read items from
    an input stream or write items to an output stream. For example, so far, we have
    used iterators via ranged `for` loops to print out the contents of a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, you can create an output stream iterator based on `cout`, so that
    the `int` values will be written to the `cout` stream through this iterator using
    the stream operator `<<`. To print out a container of `int` values, you simply
    copy the container to the output iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter of the `ostream_iterator` class is the output stream it
    will adapt, and the optional second parameter is a delimiter string used between
    each item. The `copy` function (in `<algorithm>`) will copy the items in the range
    indicated by the input iterators, passed as the first two parameters, to the output
    iterator, passed as the last parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, there is an `istream_iterator` class that will wrap an input stream
    object and provide an input iterator. This class will use the stream `>>` operator
    to extract objects of the specified type, which can be read through the stream
    iterator. However, reading data from a stream is more complicated than writing
    to one, since there must be detection of when there is no more data in the input
    stream for the iterator to read (an end of file situation).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `istream_iterator` class has two constructors. One constructor has a single
    parameter that is the input stream to read, and the other constructor, the default
    constructor, has no parameters and is used to create an **end of stream iterator**.
    The end of stream iterator is used to indicate that there is no more data in the
    stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The first call to `copy` provides two input iterators, as the first parameters,
    and an output iterator. The function copies data from the first iterator to the
    output iterator in the last parameter. Since the last parameter is created from
    `back_inserter`, this means that the items are inserted into the `vector` object.
    The input iterators are based on an input stream (`cin`) and thus the `copy` function
    will read `int` values from the console (each one separated by white space) until
    no more are available (for example, if you press *CTRL* + *Z* to end the stream
    or you type a non-numeric item). Since you can initialize a container with a range
    of values given by iterators, you can use `istream_iterator` as constructor parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here the constructor is called using the initializer list syntax; if you use
    parentheses, the compiler will interpret this as the declaration of a function!
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted earlier, the `istream_iterator` will use the stream''s `>>` operator
    to read objects of the specified type from the stream and this operator uses whitespace
    to delimit the items (and hence it just ignores all whitespace). If you read in
    a container of `string` objects, then each word you type on the console will be
    an item in the container. A `string` is a container of characters, and it can
    be also initialized using iterators, so you could try to input data into a `string`
    from the console using an `istream_iterator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In this case the stream is `cin`, but it could easily be an `ifstream` object
    to a file. The problem is that the `cin` object will strip out the white space,
    so the `string` object will contain everything that you type except for white
    space, so there will be no spaces and no newlines.
  prefs: []
  type: TYPE_NORMAL
- en: 'This problem is caused by the `istream_iterator` using the stream''s `>>` operator,
    and can only be avoided by using another class, `istreambuf_iterator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This class reads each character from the stream and copies each one into the
    container without the processing of `>>`.
  prefs: []
  type: TYPE_NORMAL
- en: Using iterators with the C Standard Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C Standard Library will often require pointers to data. For example, when
    a C function requires a string, it will need a `const char*` pointer to the character
    array containing the string. The C++ Standard Library has been designed to allow
    you to use its classes with the C Standard Library; indeed, the C Standard Library
    is part of the C++ Standard Library. In the case of `string` objects, the solution
    is simple: when you need a `const char*` pointer, you simply call the `c_str`
    method on a `string` object.'
  prefs: []
  type: TYPE_NORMAL
- en: The containers that store data in contiguous memory (`array`, `string`, or `data`)
    have a method called `data` that gives access to the container's data as a C array.
    Further, these containers have `[]` operator access to their data, so you can
    also treat the address of the first item as being `&container[0]` (where `container`
    is the container object), just as you do with C arrays. However, if the container
    is empty, this address will be invalid, so before using it you should call the
    `empty` method. The number of items in these containers is returned from the `size`
    method, so for any C function that takes a pointer to the start of a C array and
    its size, you can call it with `&container[0]` and the value from the `size` method.
  prefs: []
  type: TYPE_NORMAL
- en: You may be tempted to get the beginning of the container that has contiguous
    memory by calling its `begin` function, but this will return an iterator (usually
    an object). So, to get a C pointer to the first item, you should call `&*begin`;
    that is, dereference the iterator returned from the `begin` function to get the
    first item and then use the address operator to get its address. To be frank,
    `&container[0]` is simpler and more readable.
  prefs: []
  type: TYPE_NORMAL
- en: If the container does not store its data in contiguous memory (for example,
    `deque` and `list`), then you can obtain a C pointer by simply copying the data
    into a temporary vector.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we have chosen to use a `list` and the routine will manipulate
    the `data` object. Later in the routine, these values will be passed to a C function
    so the `list` is used to initialize a `vector` object, and these values are obtained
    from the `vector`.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Standard Library has an extensive collection of generic functions in the
    `<algorithm>` header file. By generic we mean that they access data via iterators
    without knowing what the iterators refer to and so it means that you can write
    generic code to work for any appropriate container. However, if you know the container
    type and that container has a member method to perform the same action, you should
    use the member.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration of items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many of the routines in `<algorithm>` will take ranges and iterate over those
    ranges performing some action. As the name suggests, the `fill` function will
    fill a container with a value. The function takes two iterators to specify the
    range and a value that will be placed into each position of the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Since the `fill` function will be called for a range, it means that you have
    to pass iterators to a container that already has values, and this is the reason
    why this code calls the `resize` method. This code will put the value of `42`
    into each of the items of the container, so when it has completed the `vector`
    contains `{42,42,42,42,42}`. There is another version of this function called
    `fill_n` that specifies the range by a single iterator to the start of the range
    and a count of the items in the range.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `generate` function is similar, but, rather than a single value, it has
    a function, which can be a function, a function object, or a lambda expression.
    The function is called to provide each item in the container, so it has no parameters
    and returns an object of the type accessed by the iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Again, you have to make sure that the `generate` function is passed a range
    that already exists, and this code does this by passing the initial size as a
    constructor parameter. In this example, the lambda expression has a `static` variable,
    which is incremented with each call, so this means that after the `generate` function
    has completed the `vector` contains `{1,2,3,4,5}`. There is another version of
    this function called `generate_n` that specifies the range by a single iterator
    to the start of the range and a count of the items in the range.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for_each` function will iterate over a range provided by two iterators
    and, for each item in the range, call a specified function. This function must
    have a single parameter that is the same type as the items in the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for_each` function iterates over all the items specified by the iterators
    (in this case the entire range), dereferences the iterator, and passes the item
    to the function, The effect of this code is to print the contents of the container.
    The function can take the item by value (as in this case) or by reference. If
    you pass the item by reference, then the function can change the item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'After calling this code, the items in the `vector` will be replaced with the
    squares of those items. If you use a functor or a lambda expression, you can pass
    a container to capture the result of the function; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here, a container is declared to accept the results of each call to the lambda
    expression, and the variable is passed by reference to the expression by capturing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Recall from [Chapter 5](16029dc8-6d57-416f-ad51-6e991b96a439.xhtml), *Using
    Functions*, that the square brackets contain the names of the captured variables
    declared outside the expression. Once captured, it means that the expression is
    able to access the object.
  prefs: []
  type: TYPE_NORMAL
- en: In this example the result of each iteration (`i*i`) is pushed into the captured
    collection so that the results are stored for later.
  prefs: []
  type: TYPE_NORMAL
- en: The `transform` function has two forms; they both provide a function (a pointer,
    functor, or a lambda expression) and they both have an input range of items in
    a container passed via iterators. In this respect, they are similar to `for_each`.
    The `transform` function also allows you to pass an iterator to a container that
    is used to store the results of the function. The function must have a single
    parameter that is the same type as the type (or a reference) of the type referred
    to the input iterators and it must return the type accessed by the output iterator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other version of `transform` uses a function to combine the values in two
    ranges, so this means that the function must have two parameters (which will be
    the corresponding items in the two iterators) and return the type of the output
    iterator. You only need to give the full range of items in one of the input ranges
    because it is assumed that the other range is at least as large, and hence you
    only have to provide the beginning iterator of the second range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Getting information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have values in a container, you can call functions to get information
    about those items. The `count` function is used to count the number items with
    a specified value in a range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This code will return a value of `3` because there are three copies of `6` in
    the container. The return type of the function is the type specified in the `difference_type``typedef`
    of the container, and in this case it will be `int`. The `count_if` function works
    in a similar way, but you pass a predicate that takes a single parameter (the
    current item in the container) and returns a `bool` specifying if this is the
    value that is being counted.
  prefs: []
  type: TYPE_NORMAL
- en: The `count` functions count the number of occurrences of a specific value. If
    you want to aggregate all the values, then you can use the `accumulate` function
    in `<numeric>`. This will iterate over the range, access each item and keep a
    running sum of all the items. The sum will be carried out using the `+` operator
    of the type, but there is also a version that takes a binary function (two parameters
    of the container type and returns the same type) that specifies what happens when
    you add two such types together.
  prefs: []
  type: TYPE_NORMAL
- en: The `all_of`, `any_of`, and `none_of` functions are passed a predicate with
    a single argument of the same type of the container; there are also given iterators
    indicating a range over which they iterate, testing each item with the predicate.
    The `all_of` function will return `true` only if the predicate is `true` for all
    items, the `any_of` function returns `true` if predicate is `true` for at least
    one of the items, and the `none_of` function will return `true` only if the predicate
    is `false` for all items.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have two containers of data, there are various ways that you can compare
    them. For every container type, there are `<`, `<=`, `==`, `!=`, `>`, and `>=`
    operators defined. The `==` and `!=` operators compare the containers, both in
    terms of how many items they have and the values of those items. So, if the items
    have different numbers of items, different values, or both, then they are not
    equal. The other comparisons prefer values over the number of items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the first comparison, the two vectors have similar items, but `v2` has fewer,
    so `v1` is "greater than" `v2`. In the second case, `v3` has larger values than
    `v1`, but fewer of them, so `v3` is *greater than *`v1`.
  prefs: []
  type: TYPE_NORMAL
- en: You can also compare ranges with the `equal` function. This is passed two ranges
    (which are assumed to be the same size, so only an iterator to the start of the
    second range is needed), and it compares corresponding items in both ranges using
    the `==` operator for the type accessed by the iterator, or a user supplied predicate.
    Only if all such comparisons are `true` will the function return `true`. Similarly,
    the `mismatch` function compares corresponding items in two ranges. However, this
    function returns a `pair` object with iterators in each of the two ranges for
    the first item that is not the same. You can also provide a comparison function.
    The `is_permutation is` similar in that it compares the values in two ranges,
    but it returns `true` if the two ranges have the same values but not necessarily
    in the same order.
  prefs: []
  type: TYPE_NORMAL
- en: Changing Items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **reverse** function acts on a range in a container and reverses the order
    of the items; this means that the iterators must be writeable. The `copy` and
    `copy_n` functions copy every item from one range to another in a forward direction;
    for `copy`, the input range is given by two input iterators, and for `copy_n`,
    the range is an input iterator and a count of items. The `copy_backward` function
    will copy the items, starting at the end of the range, so that the output range
    will have the items in the same order as the original. This means that the output
    iterator will indicate the *end* of the range to copy to. You can also copy items
    only if they satisfy some condition specified by a predicate.
  prefs: []
  type: TYPE_NORMAL
- en: The `reverse_copy` function will create a copy in the reverse order to the input
    range; in effect, the function iterates backward through the original and copies
    items to the output range forward.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In spite of the name, the `move` and `move_backward` functions are semantically
    equivalent to the `copy` and `copy_backward` functions. Thus, in the following,
    the original container will have the same values after the operation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This code will copy four items from the first container to the second container,
    starting at the item in the third position.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `remove_copy` and `remove_copy_if` functions iterate through the source
    range and copy items other than those with the specified value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `planck` object is left the same as before and the `result` object
    will contain `{2,0,7,0,0,4,0}`. The `remove_copy_if` function behaves similarly,
    but is given a predicate rather than an actual value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `remove` and `remove_if` functions don't quite do what their names suggest.
    These functions act on a single range and iterate looking for a specific value
    (`remove`), or pass each item to a predicate that will indicate if the item should
    be removed (`remove_if`). When an item is removed, the items later in the container
    are shifted forward, but the container remains the same size, which means that
    the items at the end remain as they were. The reason the `remove` functions behave
    like this is because they only know about reading and writing items through iterators
    (which is generic for all containers). To erase an item, the function will need
    to have access to the `erase` method of the container, and the `remove` functions
    only have access to iterators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to remove the items at the end, then you must resize the container
    accordingly. Typically, this means calling a suitable `erase` method on the container,
    and this is made possible because the `remove` method returns an iterator to the
    new end position:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `replace` and `replace_if` functions iterate through a single range, and
    if the value is a specified value (`replace`) or returns `true` from a predicate
    (`replace_if`), then the item is replaced with a specified new value. There are
    also two functions, `replace_copy` and `replace_copy_if`, that leave the original
    alone and make the change to another range (similar to `remove_copy` and `remove_copy_if`
    functions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `rotate` functions treat the range as if the end is joined to the beginning,
    and so you can shift items forward so that when an item falls off the end it gets
    put in the first position. If you want to move every item forward four places,
    you can do this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The result of this rotation is `{0,7,0,0,4,0,6,6,2,6}`. The `rotate_copy` function
    does the same thing, but, rather than affecting the original container, it copies
    the items into another container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `unique` function acts on a range and "removes" (in the manner explained
    previous) the items that are duplicates of adjacent items, and you can provide
    a predicate for the function to call to test if two items are the same. This function
    only checks adjacent items, so a duplicate later in the container will remain.
    If you want to remove all duplicates, then you should sort the container first,
    so that similar items are adjacent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `unique_copy` function will copy items from one range to another only if
    they are unique, so one way to remove duplicates is to use this function on a
    temporary container and then assign the original to the temporary:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: After this code, the `planck` container will have `{6,2,6,0,7,0,4,0}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `iter_swap` will swap the items indicated by two iterators, and
    the `swap_ranges` function swaps the items in one range to the other range (the
    second range is indicated by one iterator and it is assumed to refer to a range
    of the same size as the first).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding Items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Standard Library has a wide range of functions to search for items:'
  prefs: []
  type: TYPE_NORMAL
- en: The `min_element` function will return an iterator to the smallest item in a
    range and the `max_element`function will return an iterator to the maximum item.
    These functions are passed iterators for the range of items to check and a predicator
    that returns a `bool` from the comparison of two items. If you don't provide a
    predicator, the `<` operator for the type will be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `imin` and `imax` values are iterators, which is why they are dereferenced
    to get the value. If you want to get the minimum element and the maximum element
    in one go, you can call the `minmax_element`, which will return a `pair` object
    with iterators to these items. As the name suggests, the `adjacent_find` function
    will return the position of the first two items that have the same value (and
    you can provide a predicate to determine what *same value* means). This allows
    you to search for duplicates and get the position of those duplicates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This code has a sequence of numbers in which there are some numbers duplicated
    that are next to each other. In this case there are *three* adjacent duplicates:
    `4` followed by `4`, and the sequence `7,7,7` is `7` followed by `7`, and `7`
    followed by `7`. The `do` loop calls `adjacent_find` repeatedly until it returns
    the `end` iterator, indicating that it has searched all items. When a duplicate
    pair is found, the code prints out the value and then increments the start position
    for the next search.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `find` function searches a container for a single value, and returns an
    iterator to that item or the `end` iterator if the value cannot be found. The
    `find_if` function is passed a predicate and it returns an iterator to the first
    item it finds that satisfies the predicate; similarly, the `find_if_not` function
    finds the first item that does not satisfy the predicate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are several functions that are given two ranges, one is the range to search
    and the other has the values to look for. The different functions will either
    look for one of the items in the search criteria or it will look for all of them.
    These functions use the `==` operator for the type that the container holds or
    a predicate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `find_first_of` function returns the position of the first item that it
    finds in the search list. The `search` function looks for a specific sequence,
    and it returns the *first* position of the whole sequence, whereas the `find_end`
    function returns the *last* position of the entire search sequence. Finally, the
    `search_n` function looks for a sequence that is a value repeated a number of
    times (the value and the repeat are given) in a specified container's range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sequence containers can be sorted, and once you have done this you can use
    methods to search for items, to merge containers, or to get the difference between
    the containers. The `sort` function will order the items in a range according
    to the `<` operator or a predicate that you provide. If there are items that are
    equal in the range, then the order of these items after the sort is not guaranteed;
    if this order is important, you should call the `stable_sort` function instead.
    If you want to preserve the input range and copy the sorted items into another
    range, you use the confusingly named `partial_sort_copy` function. This is not
    a partial sort. This function is passed iterators to the input range and iterators
    for the output range, so you have to ensure that output range has a suitable capacity.
  prefs: []
  type: TYPE_NORMAL
- en: You can check if a range is sorted by calling the `is_sorted` function, and
    this will iterate through all items and return `false` if it finds an item that
    is not in sorted order, in which case you can locate the first item that is out
    of sort order by calling the `is_sorted_until` function.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, the `partial_sort` function does not place every item
    in its exact order relative to every other item. Instead, it will create two groups,
    or partitions, where the first partition will have the smallest items (not necessarily
    in any order) and the other partition will has the biggest items. You are guaranteed
    that the smallest items are in the first partition. To call this function you
    pass three iterators, two of which are the range to sort, and the third is a position
    somewhere between the other two that indicates the boundary before which are the
    smallest values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In this example there is a vector of ten items, so we define the `middle` iterator
    as five items from the beginning (this is just a choice, it could be some other
    value depending on how many items you want to obtain). In this example you can
    see that the five smallest items have been sorted to the first half and the last
    half have the biggest items.
  prefs: []
  type: TYPE_NORMAL
- en: The oddly named `nth_element` function acts like `partial_sort`. You provide
    an iterator to the *nth* element and the function ensures that first *n* items
    in the range are the smallest. The `nth_element` function is faster than `partial_sort`,
    and, although you are guaranteed that the items before the *nth* element are less
    than or equal to the *nth* element, there are no other guarantees of the sort
    order within the partitions.
  prefs: []
  type: TYPE_NORMAL
- en: The `partial_sort` and `nth_element` functions are versions of partitioned sort
    functions. The `partition` function is a more generic version. You pass this function
    a range and a predicate that determines in which of the two partitions an item
    will be placed. The items that meet the predicate will be put in the first partition
    of the range, and the other items will be placed in the range following the first
    partition. The first item of the second partition is called the partition point
    and it is returned from the `partition` function, but you can calculate it later
    by passing iterators to the partitioned range and the predicate to the `partition_point`
    function. The `partition_copy` function will also partition values, but it will
    leave the original range untouched and put the values in a range that has been
    already allocated. These partition functions do not guarantee the order of equivalent
    items, and if this order is important then you should call the `stable_partitian`
    function. Finally, you can determine if a container is partitioned by calling
    the `is_partitioned` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `shuffle` function will rearrange the items in a container into a random
    order. This function needs a uniform random number generator from the `<random>`
    library. For example, the following will fill a container with ten integers and
    then place them in a random order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: A heap is a partially sorted sequence in which the first item is always the
    largest, and items are added and removed from the heap in logarithmic time. Heaps
    are based upon sequence containers and, oddly, rather than the Standard Library
    providing an adapter class, you have to use function calls on an existing container.
    To create a heap from an existing container, you pass the range iterators to the
    `make_heap` function, which will order the container as a heap. You can then add
    new items to the container using its `push_back` method, but each time you do
    this you have to call `push_heap` to re-order the heap. Similarly, to get an item
    from the heap you call the `front` method on the container and then remove the
    item by calling the `pop_heap` function, which ensures that the heap is kept ordered.
    You can test to see if a container is arranged as a heap by calling `is_heap`,
    and if the container is not entirely arranged as a heap you can get an iterator
    to the first item that does not satisfy the heap criteria by calling `is_heap_until`.
    Finally, you can sort a heap into a sorted sequence with `sort_heap`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have sorted a container, there are functions that you can call to
    get information about the sequence. The `lower_bound` and `upper_bound` methods
    have already been described for containers, and the functions behave in the same
    way: `lower_bound` returns the position of the first element that has a value
    greater than or equal to the value provided and `upper_bound` returns the position
    of the next item that that is greater than the value provided. The `includes`
    function tests to see if one sorted range contains the items in a second sorted
    range.'
  prefs: []
  type: TYPE_NORMAL
- en: The functions beginning with `set_` will combine two sorted sequences into a
    third, container. The `set_difference` function will copy the items that are in
    the first sequence but not in the second sequence. This is not a symmetric action
    because it does not include the items that are in the second sequence but not
    in the first. If you want a symmetric difference, then you should call the `set_symmetric_difference`
    function. The `set_intersection` will copy the items that are in both sequences.
    The `set_union` function will combine the two sequences. There is another function
    that will combine two sequences, which is the `merge` function. The difference
    between these two functions is that with the `set_union` function, if an item
    is in both of the sequences, there will only be one copy put in the results container,
    whereas with `merge` there will be two copies in the results container.
  prefs: []
  type: TYPE_NORMAL
- en: If a range is sorted, then you can call the `equal_range` function to obtain
    the range of elements that are equivalent to a value passed to the function or
    a predicate. This function returns a pair of iterators that represent the range
    of values in the container.
  prefs: []
  type: TYPE_NORMAL
- en: The final method that needs a sorted container is `binary_search`. This function
    is used to test if a value is in the container. The function is passed iterators
    indicating the range to test and a value, and it will return `true` if there is
    an item in the range equal to that value (you can provide a predicate to perform
    this equality test).
  prefs: []
  type: TYPE_NORMAL
- en: Using the numeric libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Standard Library has several libraries of classes to perform numeric manipulations.
    In this section we will cover two: compile-time arithmetic, using `<ratio>`, and
    complex numbers, using `<complex>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Compile time arithmetic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fractions are a problem because there are some for which there are not enough
    significant figures to accurately represent them, resulting in losing accuracy
    when you use them in further arithmetic. Furthermore, computers are binary and
    merely converting decimal fractional parts to binary will lose accuracy. The `<ratio>`
    library provides classes that allow you to represent fractional numbers as objects
    that are ratios of integers, and perform fraction calculations as ratios. Only
    once you have performed all the fractional arithmetic will you convert the number
    to decimal, and this means that the potential loss of accuracy is minimized. The
    calculations performed by the classes in the `<ratio>` library are carried out
    at *compile time* so the compiler will catch errors such as divide by zero and
    overflows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the library is simple; you use the `ratio` class, and provide the numerator
    and denominator as template parameters. The numerator and denominator will be
    stored factorized, and you can access these values through the `num` and `den`
    members of the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This will print out `3/4`.
  prefs: []
  type: TYPE_NORMAL
- en: Fractional arithmetic is carried out using templates (these are, in fact, specializations
    of the `ratio` template). At first sight it may appear a little odd, but you soon
    get used to it!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print out `514/187` (you may want to get some paper and do the fractional
    calculations to confirm this). The data members are actually `static` members,
    so it makes little sense to create variables. Furthermore, because arithmetic
    is carried out using *types* rather than *variables*, it is best to access the
    members through those types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: You can now use the sum type as a parameter to any of the other operations that
    you can perform. The four binary arithmetic operations are carried out with `ratio_add`,
    `ratio_subtract`, `ratio_multiply`, and `ratio_divide`. Comparisons are carried
    out through `ratio_equal`, `ratio_not_equal`, `ratio_greater`, `ratio_greater_equal`,
    `ratio_less`, and `ratio_less_equal`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This operation tests to see if the calculation performed before (`514/187`)
    is greater than the fraction `25/19` (it is). The compiler will pick up divide-by-zero
    errors and overflows, so the following will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it is important to point out that the compiler will issue the error
    on the second line, when the denominator is accessed. There are also typedefs
    of ratio for the SI prefixes. This means that you can perform your calculations
    in nanometers, and when you need to present the data in meters you can use the
    `nano` type to obtain the ratio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are doing calculations on a sphere in **nanometers** (**nm**). The
    sphere has a radius of 10 nm, so the first calculation gives the volume as 4188.67
    nm3\. The second calculation converts nanometers into meters; the factor is determined
    from the `nano` ratio (note that for volumes the factor is cubed). You could define
    a class to do such conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The class is defined for a particular type of unit, which will be expressed
    through an instantiation of the `ratio` template. The class has a constructor
    to initialize it for values in those units and a constructor to convert from other
    units, and that simply divides the current units by the units of the other type.
    This class can be used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The first variable is based on `kilo` and hence the units are kilometers. To
    convert this to meters, the second variable type is based on `ratio<1>`, which
    is the same as `ratio<1,1>`. The result is that the values in the `earth_diameter_km`
    are multiplied by 1000 when placed in `in_meters`. The conversion to miles is
    a bit more involved. There are 1609.344 m in a mile. The ratio used for the `in_miles`
    variable is 1609344/1000 or 1609.344\. We are initializing the variable with the
    `earth_diameter_km`, so isn't that value too big by a factor of 1000? No, the
    reason is that the type of `earth_diameter_km` is `dist_units<kilo>`, so the conversion
    between km and miles will include that factor of 1000.
  prefs: []
  type: TYPE_NORMAL
- en: Complex numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Complex numbers are not just of mathematical interest, they are also vital in
    engineering and science, so a `complex` type is an important part of any type
    library. A complex number is made of two parts--the real and imaginary parts.
    As the name suggests, an imaginary number is not real, and cannot be treated as
    real.
  prefs: []
  type: TYPE_NORMAL
- en: In mathematics, complex numbers are usually represented as coordinates in two-dimensional
    space. If a real number can be thought of as being one of an infinite number of
    points on the x axis, an imaginary number can be thought of being one of an infinite
    number of points on the y axis. The only intersection between these two is the
    origin and since zero is zero, is nothing, it can be a zero real number or a zero
    imaginary number. A complex number has both real and imaginary parts, and hence
    this can be visualized as a Cartesian point. Indeed, another way of visualizing
    a complex number is as a polar number where the point is represented as a vector
    of a specified length at a specified angle to the position on the x axis (the
    positive real number axis).
  prefs: []
  type: TYPE_NORMAL
- en: The `complex` class is based on a floating point type, and there are specializations
    for `float`, `double`, and `long double`. The class is simple; it has a constructor
    with two parameters for the real and imaginary parts of the number, and it defines
    operators (member methods and global functions) for assignment, comparisons, `+`,
    `-`, `/`, and `*`, acting on the real and imaginary parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'An operation like `+` is simple for a complex number: you just add the real
    parts together and the imaginary parts together, and these two sums are the real
    and imaginary parts of the result. However, multiplication and division are a
    bit more, umm, complex. In multiplication, you get a quadratic: the aggregation
    of the two real parts multiplied, the two imaginary parts multiplied, the two
    values of the real part of the first multiplied with the imaginary part of the
    second, and the imaginary part of the first multiplied with the real part of the
    second. The complication is that two imaginary numbers multiplied is equivalent
    to the multiplication of two equivalent real numbers multiplied by -1\. Furthermore,
    multiplying a real and an imaginary number results in an imaginary number that
    is equivalent in size to the multiplication of two equivalent real numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also functions to perform trigonometric operations on complex numbers:
    `sin`, `cos`, `tan`, `sinh`, `cosh`, and `tanh`; and basic math operations such
    as `log`, `exp`, `log10`, `pow`, and `sqrt`. You can also call functions to create
    complex numbers and get information about them. So, the `polar` function will
    take two floating-point numbers representing the polar coordinates of the length
    of the vector and the angle. If you have a `complex` number object you can get
    the polar coordinates by calling `abs` (to get the length) and `arg` (to get the
    angle).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The first point to make is that there is an `ostream` insertion operator defined
    for `complex` numbers so you can insert them into the `cout` stream object. The
    output from this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The second line shows the limitations of using just five decimal places for
    the square root of 2 and -1/4 pi, this number is, in fact, the complex number
    `(1, -1)`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Standard Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will develop a simple parser for **Comma Separated Value**
    (**CSV**) files. The rules we will follow are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Each record will occupy one line, and newline indicates a new record
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fields in the record are separated by commas, unless they are within a quoted
    string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings can be quoted using single (`'`) or double quotes (`"`), in which case
    they can contain commas as part of the string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quotes immediately repeated (`''` or `""`) is a literal, and a part of the string
    rather than a delimiter of a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a string is quoted, then spaces outside of the string are ignored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a very basic implementation, and omits the usual requirement that quoted
    strings can contain newlines.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, much of the manipulation will be using `string` objects as
    containers of individual characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a folder for the chapter called `Chapter_08` in the folder
    for this book. In that folder, create a file called `csv_parser.cpp`. Since the
    application will use console output and file input, add the following lines at
    the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The application will also take a command line parameter that is the CSV file
    to parse, so add the following code at the bottom of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The application will read a file line by line into a `vector` of `string` objects,
    so add `<vector>` to the list of include files. To make the coding easier, define
    the following above the `usage` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` function will read the file in line by line and the simplest way
    to do this is to use the `getline` function, so add the `<string>` header file
    to the include file list. Add the following lines to the end of the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The first few lines open the file using an `ifstream` class. If the file cannot
    be found, then the operation to open the file fails and this is tested by calling
    `is_open`. Next a `vector` of `string` objects is declared and filled with lines
    read from the file. The `getline` function has two parameters: the first is the
    open file stream object and the second is a string to contain the character data.
    This function returns the stream object, which has a `bool` conversion operator,
    and hence the `for` statement will loop until this stream object indicates that
    it can read no more data. When the stream gets to the end of the file, an internal
    end-of-file flag is set and this causes the `bool` conversion operator to return
    a value of `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: If the `getline` function reads a blank line, then the `string` will not be
    able to be parsed, so there is a test for this, and such blank lines are not stored.
    Each legitimate line is pushed into the `vector`, but, since this `string` variable
    will not be used after this operation, we can use move semantics and so this is
    made explicit by calling the `move` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code will now compile and run (although it will produce no output). You
    can use it on any CSV file that meets the criteria given previously, but as a
    test file we have used the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: These are US presidents up to 1845; the first string is the name of the president
    and their affiliation, but when the president has no affiliation then it is missed
    out (Washington and Tyler). The names are then followed by the start and end years
    of their terms of office.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to parse the data in the vector and split the items into individual
    fields according to the rules given previously (fields separated by commas, but
    quotation marks are respected). To do this, we will represent each line as a `list`
    of fields, with each field being a `string`. Add an include for `<list>` near
    the top of the file. At the top of the file, where the `using` declarations are
    made, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, at the bottom of the `main` function, add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates the `vector` of `list` objects, and the `for` loop iterates
    through each line calling a function called `parse_line` that parses a string
    and returns a `list` of `string` objects. The return value of the function will
    be a temporary object and hence an rvalue, so this means that the version of `push_back`
    with move semantics will be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Above the usage function, add the start of the `parse_line` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The function will treat the string as a container of characters and hence it
    will iterate through the line parameter with a `const_iterator`. The parsing will
    be carried out in a `do` loop, so add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The Boolean variables will be explained in a moment. The `do` loop increments
    the iterator, and when it reaches the `end` value, the loop finishes. The `item`
    variable will hold the parsed data (at this point it is empty) and the last line
    will put the value into the `list`; this is so that any unsaved data is stored
    in the `list` before the function finishes. Since the item variable is about to
    be destroyed, the call to `move` ensures that its contents are moved into the
    `list` rather than copied. Without this call, the string copy constructor will
    be called when putting the item into the `list`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next you need to do the parsing of the data. To do this, add a switch to test
    for the three cases: a comma (to indicate the end of a field), and a quote or
    a double quote to indicate a quoted string. The idea is to read each field and
    build its value up character by character, using the `item` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The default action is simple: it copies the character into the temporary string.
    If the character is a single quote, we have two options. Either the quote is within
    a string that is double quoted, in which case we want the quote to be stored in
    `item`, or the quote is a delimiter, in which case we store whether it is the
    opening or closing quote by setting the `bQuote` value. For the case of a single
    quote, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'This is simple enough. If this is in a double-quoted string (`bDQuote` is set),
    then we store the quote. If not, then we flip the `bQuote bool` so that if this
    is the first quote, we register that the string is quoted, otherwise we register
    that it is the end of a string. If we are at the start of a quoted string, we
    clear the item variable to ignore any spaces between the previous comma (if there
    is one) and the quote. However, this code does not take into account the use of
    two quote marks next to each other, which means that the quote is a literal and
    part of the string. Change the code to add a check for this situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement checks to make sure that if we increment the iterator, we
    are not at the end of the line (short circuiting will kick in here in this case
    and the rest of the expression will not be evaluated). We can test the next item,
    and we then peek at the next item to see if it is a single quote; if it is, then
    we add it to the `item` variable and increment the iterator so that both quotes
    are consumed in the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the double quote is similar, but switches over the Boolean variables
    and tests for double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need code to test for a comma. Again, we have two situations: either
    this is a comma in a quoted string, in which case we need to store the character,
    or it''s the end of a field, in which case we need to finish the parsing for this
    field. The code is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement tests to see if we are in a quoted string (in which case
    either `bQuote` or `bDQuote` will be true), and if so, the character is stored.
    If this is the end of the field, we push the `string` into the `list`, but we
    use `move` so that the variable data is moved across and the `string` object left
    in an uninitialized state.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code will compile and run. However, there is still no output, so before
    we redress that, review the code that you have written. At the end of the `main`
    function you will have a `vector` in which each item has a `list` object representing
    each row in the CSV file, and each item in the `list` is a field. You have now
    parsed the file and can use this data accordingly. So that you can see that the
    data has been parsed, add the following lines to the bottom of the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: You can now compile the code (use the `/EHsc` switch) and run the application
    passing the name of a CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have seen some of the main classes in the C++ Standard
    Library, and investigated in depth the container and iterator classes. One such
    container is the `string` class; this is such an important class that it will
    be covered in more depth in the next chapter.
  prefs: []
  type: TYPE_NORMAL
