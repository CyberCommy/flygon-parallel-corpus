- en: Zappa with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn about developing a serverless application
    with an AWS Lambda environment or operating system context, instead of your local
    development environment. We will be focusing on the problems that arise in different
    environmental contexts and looking at efficient solutions to these problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that we will cover in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Problem statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API development with a custom tool dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building, testing, and deploying with Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before moving ahead, let''s configure some prerequisites, such as the tools
    and packages that we will require, in order to get the development environment
    set up. Here is a list of the software and packages that you will need:'
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu 16.04/macOS/Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3.6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipenv tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Falcon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Falcon-multipart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gunicorn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: catdoc
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zappa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we've mentioned the operating system along with other required tools and
    packages. Choose any of these operating systems and install Docker as per the
    instructions detailed on its official site ([https://docs.docker.com/](https://docs.docker.com/)).
    We will see detailed information about installing Python-specific packages in
    the upcoming API development section. Let's move to the next section, where we
    will understand the concept of Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Docker** is a platform for developing and deploying applications with containers. Docker
    creates these containers based on Docker images, and a Docker image includes the
    basic and required components similar to Linux. A Docker container is nothing
    more than an instance of a Docker image.'
  prefs: []
  type: TYPE_NORMAL
- en: A Docker container has many features for supporting and running any application.
    A Docker container is lightweight, flexible, portable, scalable, and stackable.
    You can create a container for any service, such as Python or MySQL. Docker enables
    you to share data by networking with the host machine. With the help of Docker
    containers, you can create an isolated environment for your application.
  prefs: []
  type: TYPE_NORMAL
- en: You can create your own Docker image with stacked services and configurations.
    For example, you might use an Ubuntu image-based container and then install the
    MySQL service before configuring the container accordingly. Then we can build
    a new image along with the configured service. Finally, we can push the image
    on a Docker hub repository ([https://hub.docker.com/](https://hub.docker.com/)),
    and it depends on our repository privileges as to whether we keep it private or
    make it public.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more in detail and understand the concept of Docker technology
    at its official site, [https://docs.docker.com/get-started/#docker-concepts](https://docs.docker.com/get-started/#docker-concepts).
    We are going to focus on developing an application with an environment-dependent
    package and deploying over AWS Lambda. Let's move to the next section, where we
    are going to discuss a real situation for maintaining the AWS Lambda environment
    at the development level.
  prefs: []
  type: TYPE_NORMAL
- en: Problem statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though Zappa takes care of your installed Python packages and deploys them on
    your Lambda using precompiled Lambda packages ([https://github.com/Miserlou/lambda-packages](https://github.com/Miserlou/lambda-packages)) and
    wheels from your virtual environment, these packages may differ based on the operating
    system environment. So, there might be a situation where you may require an operating
    system-specific tool or a custom package for implementing a solution. This kind
    of package context may vary based on the operating system environment. Hence,
    it may not work on an AWS Lambda environment.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome the different environmental context issues and maintain installed
    packages based on the AWS Lambda environment, we need to have a similar environment
    context for development. Hence, we need a Docker image that has a similar context
    and environment to AWS Lambda. Finally, **LambCI** ([https://github.com/lambci](https://github.com/lambci)) developed
    a **Docker-Lambda** ([https://github.com/lambci/docker-lambda](https://github.com/lambci/docker-lambda))
    image, which has an identical context to that of AWS Lambda, including system
    libraries, file structure, users and permissions, environment variables, and other
    contextual information.
  prefs: []
  type: TYPE_NORMAL
- en: Proposed solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, this `catdoc` command is installed at the OS level. But in our API, we
    are going execute this command programmatically to parse and fetch the printed
    text data from `stdout`. Our API can be used as a parser service, to fetch the
    text data from the Microsoft Office 2003 format file.
  prefs: []
  type: TYPE_NORMAL
- en: Case study for this solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I chose this problem because there are few Python libraries available for parsing
    files of the Doc format. I was developing an application in my organization where
    I needed to parse all types of text files, such as `.pdf`, `.txt`, `.docx`, and
    `.doc`. So, I was met with this situation where I had to use an OS-dependent command-line
    tool to fetch the text data programmatically. I developed a solution, and it was
    working perfectly on my local Ubuntu machine; but when I then tried to deploy
    the application, `catdoc` was not there in the Lambda environment, and it was
    a huge problem for me.
  prefs: []
  type: TYPE_NORMAL
- en: I spent days and nights trying to resolve this issue, as I was in the situation
    of either having to implement it as per the requirements or give up the serverless
    implementation with Zappa. Giving up on Zappa was not possible for me, as I had
    fallen in love with Zappa and developed many projects using it.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, I was not alone in the Zappa world. I am in touch with the Zappa
    community and met with Mr João Neves—a true gentleman—who helped me to resolve
    the issue, and finally, I resolved it in a very efficient way. It was a big victory
    for Zappa in my organization. I would like a standing ovation to be given for
    the Zappa community, and especially Mr João Neves.
  prefs: []
  type: TYPE_NORMAL
- en: Let's reveal the actual implementation of the API in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: API development with a custom tool dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first aim is to develop an API that supports file upload. This API can simply
    support only a single file upload, with a validation check of the file extension.
    We are going to perform the operation on an MS Office document file with `.doc` only.
    Hence, this API will only allow `.doc` extension files.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in the *Technical requirements* section for this chapter, we need
    to configure `pipenv` with Python version 3.6\. We use the following command to
    initialize the `pipenv` environment with Python 3.6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, install the following packages using the `pipenv install` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`falcon`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flacon-multipart`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gunicorn`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zappa`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we''ve installed these packages, `pipenv` will create a `Pipfile`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: That's it, we are done with the installation! Now we can either enter into the
    shell of the virtual environment using the `pipenv shell` command, or we can run
    any command inside the virtual environment using the `pipenv run `command. Let's
    move ahead to implement the API.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the /doc-parser API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here we created an API resource with only the HTTP `POST` request. This API
    will accept a file attribute as a multipart data. Once the file is uploaded, we
    validate the file type and extension. If the file is `application/msword` and
    the file extension is `".doc"`, then we can proceed; otherwise, we return an error.
  prefs: []
  type: TYPE_NORMAL
- en: If the uploaded file is valid, then we will proceed to parse the text data from
    the file and return the data in JSON format as a response. To parse the file,
    we have written the `doc_to_text` method in `parser.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see here, we are performing two different tasks. Firstly, we are
    storing the uploaded file in `/tmp directory`, and secondly, we are parsing the
    text by running the `catdoc` command programmatically using the `os.popen` command.
    With the help of the `os.popen` command, we read the `stdout of catdoc` command.
    There are many options available with the `catdoc` command. I'm using `catdoc
    -a <doc-file>` to read ASCII characters only. You can explore `catdoc` with the
    help of the `man catdoc` command.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next section, where we are going to execute this API.
  prefs: []
  type: TYPE_NORMAL
- en: Executing in the local environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'API execution requires a file upload process. So, I would recommend using a
    REST API client. In our case, I am using the Advanced REST client. The following
    screenshot is of the API upload process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00110.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: That's it. Our API is working as expected. We now have the text data in JSON
    format, along with the filename. Now let's move to the next section, where we
    are going to explore the build process on AWS Lambda using Zappa. We will also
    explore how the dependency tool raises exceptions, and how the Docker mechanism
    helps to resolve the issue.
  prefs: []
  type: TYPE_NORMAL
- en: Building, testing, and deploying with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's move ahead to make a build using Zappa without considering the Docker
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Building without Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Now that we''ve deployed the application, let''s test the API execution.
    The following is a screenshot of the API execution using the Advanced REST client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00111.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here we tried to upload the same file but didn't get the content. Even the return
    response is OK. Let's figure this out. What is the cause of this problem? You
    can tail the Zappa logs using `zappa logs <stage_name>`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here you can see we got an error, which states that the `catdoc` command cannot
    be found. That's true and as expected, because `catdoc` is not available in the
    AWS Lambda environment, and there is no way to install this dependency on AWS
    Lambda. But why did we not get an exception for it? Well, it's a system-level
    error, as we used the `os.popen` method to execute the `catdoc` command. Hence,
    Python does not catch these errors. That's the reason we didn't get an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Well, what about the problem? We are hopeless, as we can't do anything on AWS
    Lambda, and we cannot change the AWS Lambda environment!
  prefs: []
  type: TYPE_NORMAL
- en: Wait! There is someone who blessed you with a solution—LambCI. LambCI has released
    a Docker image ([https://github.com/lambci/docker-lambda](https://github.com/lambci/docker-lambda))
    that is a mirror image of the AWS Lambda environment. Now you can use this to
    solve the problem. Let's move to the next section, where we are going to configure
    the Docker environment along with the required dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Docker with Zappa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the help of the LambCI Docker image, we will get an AWS Lambda-compatible
    environment. But, still, we are required to have build dependencies related to
    the `catdoc` utility. Now, we can use this Docker image with the `build-python3.6`
    tag to create a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a code snippet showing the creation of a Docker container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`run`:This command is used to create and start the container based on the given
    image tag. In our case, we are using `"lambci/lambda:build-python3.6"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--name`: This option is used to create the Docker container''s name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`-v`**: This option is used to mount the directory from the host machine
    to the Docker container. For multiple directories, we need to repeat this option,
    as we are mounting the current directory as well the AWS CLI directory for AWS
    access credentials.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`-e`**: This option is used to set the environment variable into the Docker
    container. For multiple environment variables, you need to repeat this option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`-p`**: This option is used to expose and map the Docker container port with
    the host machine. We are mapping to port `8000 `so that we can test the application
    on the local environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**-it**`:  This option is used to start the Docker container in interactive
    mode, where we can interact with the Docker container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also the `bash` command to be executed. This command will land us on
    the Docker container's Terminal Bash screen. Once you run the command, it will
    start the Docker container and attach the controller with the Bash screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following log snippet of the options just mentioned, and
    check the mounted files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all files from our current directory have been mounted as per
    the volume mapping. Now this container has a context similar to that of AWS Lambda.
    Hence, we can configure any source code of any library or tool.
  prefs: []
  type: TYPE_NORMAL
- en: We are now going to look at the `catdoc` configuration. As mentioned on the
    catdoc website ([http://www.wagner.pp.ru/~vitus/software/catdoc/](http://www.wagner.pp.ru/~vitus/software/catdoc/)),
    you can download the source code and compile it through your system. We are going
    to download the `catdoc` source code inside the container by using the `wget`
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before that, we need to install the `wget` tool in our container, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve installed the `wget` tool, download the `catdoc` source code inside
    a folder. In our case, we are going to download it inside a `lib` folder. You
    can create the `lib` and `usr` directories as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `lib` and `usr` directories are used by the compiled source code of any
    library,  hence these directories are required to maintain the binaries of compiled
    source code for execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to install the `catdoc` library from its source code. You need
    to follow these steps in order to configure the library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the `catdoc` source code, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now extract the compressed file using the `tar` command-line utility:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, go into the `catdoc` source directory and configure it with a prefix
    to keep the binary at the application level, as shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the `make` and `make install` commands, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you will find that the `catdoc` binary is available at the `/var/task/usr/`
    directory, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the following line in the `parser.py`, where we are just changing the
    command path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: That's it! We've now added the `catdoc` dependency in our application. This
    dependency has been configured in the Docker container, whereas our Docker container
    and the AWS Lambda environment have the same OS context. Hence, the configured
    dependency is going to work on AWS Lambda as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move ahead to deploy the application from the container itself. Before
    initializing the deployment, we need to install all required Python packages using
    `pipenv`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following log snippet shows the `pipenv install` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, activate the virtual environment using the `pipenv shell` command, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Oops! We got an error while activating the virtual environment! Let''s fix
    it and then activate the virtual environment once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We set the `SHELL` environment variable and then re-run the Zappa `shell` command.
    Therefore, a virtual environment has been activated. Now, let's continue.
  prefs: []
  type: TYPE_NORMAL
- en: Zappa requires an enabled virtual environment, as it builds the deployment package
    based on the installed packages in the virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the deployment using either the `zappa deploy` command or the `zappa
    update` command. We''ve already deployed the application, which is why we are
    going to go with `zappa update`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now we are done with deployment. Let's move to the next section and explore
    the API execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Executing the API on AWS Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use any REST client to debug and execute the API. We are going to use
    the Advanced REST client. The following screenshot demonstrates the API execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00112.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see here, we've uploaded the MS Office document file and received
    the response in JSON format with all the text data present in the uploaded file.
    Mission accomplished.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we have implemented the solution for developing an application with
    a custom dependency. With the help of Docker containerization, we have built the
    binary of the required `catdoc` library, which is configured against the Docker
    container, and the results are similar to those we would expect with AWS Lambda,
    thanks to LambCI's Docker image and the `build-Python3.6` tag. This is how we
    resolve the custom dependency problem with AWS Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does a Docker container work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a Docker image and Docker container?**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
