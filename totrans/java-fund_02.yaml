- en: '*Chpater 2*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables, Data Types, and Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this lesson, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Use primitive data types in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use reference types in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement simple arithmetic operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use type-casting methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input and output various data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous lesson, we were introduced to the Java ecosystem and the tools
    that are needed to develop Java programs. In this lesson, we will start our journey
    of the Java language by looking at the fundamental concepts in the language such
    as variables, data types, and operations.
  prefs: []
  type: TYPE_NORMAL
- en: Variables and Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the fundamental concepts in computer programming is memory, used to store
    information in the computer. Computers use bits as the smallest information that
    can be stored. A bit is either a 1 or 0\. We can group 8 bits to get what is called
    a `byte`. Because bits are very small, we usually deal with bytes as the smallest
    unit when programming. When we write programs, what we are essentially doing is
    fetching some bits from a certain memory location, doing some operations on them,
    and writing back the result to a memory location.
  prefs: []
  type: TYPE_NORMAL
- en: We need a way to store different kinds of data in the computer's memory and
    tell the computer what kind of data is stored at what memory location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data types are a way for us to specify what kind of data and the size we need
    to store at a given memory location. An example of a data type is an integer,
    a character, or a string. Broadly, the data types available in Java can be classified
    into the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: Primitive data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Primitive types** are the fundamental types, that is, they cannot be modified.
    They are indivisible and form the basis for forming complex types. There are eight
    primitive data types in Java, which we will cover in depth in the subsequent sections:'
  prefs: []
  type: TYPE_NORMAL
- en: byte
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: short
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: int
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: long
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: char
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: float
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: double
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reference types** are types that refer to data that''s stored in a certain
    memory location. They don''t hold the data themselves, but hold the address of
    the data. Objects, which will be covered later, are examples of reference types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: Representation of reference types](img/C09581_Figure_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Representation of reference types'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'All data types have the following common properties:'
  prefs: []
  type: TYPE_NORMAL
- en: They are associated with a value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They support certain operations on the value they hold.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They occupy a given number of bits in memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, an integer can have a value such as 100, support operations such
    as addition and subtraction, and is represented using 32-bits on the computer's
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whenever we want to deal with a given data type, we have to create a variable
    of that data type. For example, to create an integer that holds your age, you
    would use a line like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are saying the variable is called `age` and is an integer. Integers
    can only hold values in the range -2,147,483,648 to 2,147,483,647\. Trying to
    hold a value outside the range will result in an error. We can then assign a value
    to the `age` variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `age` variable now holds the value 30\. The word `age` is called an **identifier**
    and is used to refer to the memory location where the value 30 is stored. An identifier
    is a human-readable word that is used to refer to the memory address of the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use a word of your choice as an identifier to refer to the same memory
    address. For example, we could have written this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a graphical representation of the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C09581_Figure_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Representation of age in memory address'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As much as we can use any word as an identifier, Java has some rules on what
    makes up a valid identifier. The following are some of the rules to adhere to
    when creating identifier names:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifiers should start with either a letter, `_`, or `$`. They cannot start
    with a number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifiers can only contain valid unicode characters and numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifiers cannot have spaces in between them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifiers can be of any length.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifiers cannot be reserved keywords.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifiers cannot have arithmetic symbols such as + or -.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifiers are case-sensitive, for example, age and Age are not the same identifiers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reserved Keywords
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java also contains inbuilt words that are reserved and cannot be used as identifiers.
    These words have special meanings in the language.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's discuss the primitive data types in Java. As we said before, Java
    has 8 primitive data types, which we will look at in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Integral Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integral types are types that have integer values. These are int, long, short,
    byte, and char.
  prefs: []
  type: TYPE_NORMAL
- en: int Data Type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `int` data type is used to represent integers. Integers are 32-bit numbers
    in the range of -2,147,483,648 to 2,147,483,647\. Example of integers are 0, 1,
    300, 500, 389 230, 1,345,543, -500, -324,145, and others in that range. For example,
    to create an `int` variable to hold a value 5, we write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `num` variable is now an `int` with a value of five. We can also declare
    more than one variable of the same type in one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have created five variables, all of the `int` type, and initialized
    to zero. We can also initialize all of the variables to a specific value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to expressing integers in decimal format, we can also express integers
    in octal, hexadecimal, and binary format:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To express in hexadecimal format, we start the `int` with 0x or 0X, that is,
    a zero followed by x or X. The number has to be at least 2 digits in length. Hexadecimal
    numbers use 16 digits (0-9 and A-F). For example, to express 30 in hexadecimal,
    we would use the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the number will output 30 as expected. To hold an integer with a value
    of 501 in hexadecimal, we would write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To express in octal format, we start the `int` with a zero and must have at
    least 2 digits. Octal numbers have 8 digits. For example, to express 15 in octal,
    we would do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to print the preceding variable will output 15\. To represent 501 in
    octal, we would do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To express in binary format, we start the `int` with 0b or 0B, that is, a zero
    followed by b or B. The case doesn''t matter. For example, to hold the value 100
    in binary, we would do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To hold the number 999 in binary, we would do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As a summary of the aforementioned four formats of representing integers, all
    the following variables hold the same value of 117:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: long Data Type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`long` is a 64 bit equivalent of an int. They hold numbers in the range of
    -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\. Numbers of long type
    are called long literal and are denoted by an L at the end. For example, to declare
    a long of value 200, we would do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To declare a `long` of value 8, we would do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Since integers are 32-bit and hence lie within the range of long, we can convert
    an `int` into a `long`.
  prefs: []
  type: TYPE_NORMAL
- en: Type Casting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To convert an `int` of value of 23 into a long literal, we would need to do
    what is called **type casting**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the second line, we cast the `num_int` of the `int` type to a long literal
    by using the notation `(long)num_int`. This is referred to as `casting`. Casting
    is the process of converting one data type into another. Although we can cast
    a long to an `int`, remember that the number might be outside the `int` range
    and some numbers will be truncated if they can't fit into the int.
  prefs: []
  type: TYPE_NORMAL
- en: 'As is with `int`, `long` can also be in octal, hexadecimal, and binary, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 5: Type Casting'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It''s often important to change one type to another. In this exercise, we will
    convert an integer into a floating point:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `Scanner` and create a public class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Input a number as an integer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Print out the integer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert the integer into a floating point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Print out the floating point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: byte Data Type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `byte` is an 8-bit digit that can hold values in the range of -128 to 127\.
    `byte` is the smallest primitive data type in Java, and can be used to hold binary
    values. To assign a value to a `byte`, it has to be in the range -128 to 127,
    otherwise the compiler will raise an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also cast an `int` to a `byte`, as we did with `long`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to casting, we can assign a `byte` to an `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We, however, cannot directly assign an `int` to a `byte` without casting. The
    following code will raise an error when you try to run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is because an integer can be outside the byte range (-128 to 127) and hence
    some precision will be lost. Java doesn't allow you to assign out of range types
    to lower range types. You have to cast so that the overflow bits will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: short Data Type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`short` is a 16-bit data type that can hold numbers in the range of -32,768
    to 32,767\. To assign a value to a `short` variable, make sure it is in the specified
    range, otherwise an error will be thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can assign a `byte` to a `short` because all the values of a byte fall
    in the short''s range. However, the reverse will throw an error, as explained
    with `byte` and `int`. To convert an `int` into a `short`, you have to cast to
    avoid the compile errors. This also applies to converting a `long` into a `short`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Boolean Data Type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `boolean` is a true or false value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some languages, such as like C and C++, allow Booleans to take a value of 1
    for true and 0 for a false. Java doesn't allow you to assign 1 or 0 to Boolean
    and this will raise a compile-time error.
  prefs: []
  type: TYPE_NORMAL
- en: char Data Type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `char` data type is used to hold a single character. The character is enclosed
    in single quotes. Examples of characters are ''a'', ''b'', ''z'', and ''5''. Char
    types are 16 bit and cannot be negative. Char types are essentially integers from
    0 to 65,535 to represent Unicode characters. Examples of how to declare chars
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that chars are enclosed in single quotes, NOT double quotes. Enclosing
    a `char` in double quotes changes it to a `string`. A `string` is a collection
    of one or more chars. An example of a String is "Hello World":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Enclosing a `char` in double quotes will raise an error because the compiler
    interprets double quotes as a `string`, not a char:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, enclosing more than one character in single quotes raises a compiler
    error because chars should be only one character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to chars being used to hold single characters, they can also be
    used to hold escape characters. Escape characters are special characters that
    have a special use. They consist of a backslash followed by a character and are
    enclosed in single quotes. There are 8 predefined escape characters, as shown
    in the following table, along with their uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.1:  Representation of escape characters and their use](img/C09581_Table_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 2.1: Representation of escape characters and their use'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let''s say you write a line such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `char` holds a newline and if you try printing it to the console, it skips
    to the next line.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you print `''\t''`, a tab is escaped in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: A '`\\`' will print a backslash in the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use escape characters to format a string according to your desired
    output. For example, let''s look at the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is because the escape character '`\n`' introduces a new line between `Hello`
    and `World`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, chars can also be expressed in Unicode using the Unicode escape
    character '`\u`'. Unicode is an international standard of encoding in which a
    character is assigned a numeric value that can be used on any platform. Unicode
    aims to support all the available languages in the world, which is in contrast
    to ASCII.
  prefs: []
  type: TYPE_NORMAL
- en: Floating-Point Data Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Floating-point data types are numbers that have a fractional part in their
    representation. Examples include 3.2, 5.681, and 0.9734\. Java has two data types
    to represent types with fractional parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Floating types are represented using a special standard referred to as the IEEE
    754 Floating-point standard. This standard was set up by the Institute of Electrical
    and Electronic Engineers (IEEE) and is meant to make the representation of floating
    types uniform in the low level parts of the compute. Remember that floating types
    are usually approximations. When we say 5.01, this number has to be represented
    in binary format and the representation is usually an approximation to the real
    number. When working with very high-performance programs where values have to
    be measured to the order of micro numbers, it becomes imperative that you understand
    how floating types are represented at the hardware levels to avoid precision loss.
  prefs: []
  type: TYPE_NORMAL
- en: 'Floating types have two representations: decimal format and scientific notation.'
  prefs: []
  type: TYPE_NORMAL
- en: The decimal format is the normal format we usually use, such as 5.4, 0.0004,
    or 23,423.67.
  prefs: []
  type: TYPE_NORMAL
- en: The scientific notation is the use of the letter e or E to represent a ten raised
    to a value. For example, 0.0004 in scientific notation is 4E-4 or 4e-4, which
    is similar to 4 x 10-4 . The number 23,423.67 in scientific notation would be
    2.342367E4 or 2.342367e4, which is similar to 2.342367 x 104\.
  prefs: []
  type: TYPE_NORMAL
- en: float Data Type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`float` is used to hold 32-bit fractional numbers in the range 1.4 x 10 -45
    and as big as 3.4 x 10 38\. That is, the smallest number a `float` can hold is
    1.4 x 10 -45 and the largest number it can hold is 3.4 x 10 38\. Floats are followed
    by a letter f or F to indicate that they are of `float` type. Examples of floats
    are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Floats can also be represented in scientific notation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Java also has a class called Float that can encapsulate floats and offers some
    useful features. For example, to know the largest `float` number and the smallest
    `float` number available in your environment, you''d call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The Float class also has values to represent positive and negative infinity
    when a division by zero occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Floats support two types of zeros: -0.0f and +0.0f. As we already said, float
    types are represented as approximations in the memory, and so even a zero is not
    an absolute zero. That is why we have two zeros. When a number is divided by positive
    zero, we get `Float.POSITIVE_INFINITY` and when a number is divided by negative
    zero, we get `Float.NEGATIVE_INFINITY`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Float class also has the constant `NaN` to indicate a number that is not
    of a `float` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As with the integral types we have discussed, we can assign an `int`, `byte`,
    `short`, `long`, and char to a float, but cannot do the reverse unless we cast.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Casting an integer to a float and then back to an `int` will not always lead
    to an original number. Be careful when doing casting between `int` and `float`.
  prefs: []
  type: TYPE_NORMAL
- en: double Data Type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`double` holds 64-bit numbers with fractional parts. That is, the range 4.9
    x 10e -324 to 1.7 x 10e 308\. Doubles are used to hold larger numbers than floats.
    They are represented with a d or D at the end. However, by default, in Java, any
    number with a fractional part is a `double`, so there is usually no need to append
    the d or D at the end. Examples of doubles are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Like floats, doubles can also be represented in scientific notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'As you might have already guessed it, Java also provides a class called `Double`
    with some useful constants, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, we can assign the integral types and `float` except the `boolean`
    type to `double` and not the other way round until we cast. The following are
    example operations that are allowed and some that are forbidden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity 4: Inputting Student Information and Outputting an ID'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Storing and outputting variables in foundational in any developing environment.
    In this activity you will be creating a program that will ask a student to input
    their data and then output a simple ID card. The program will use integers and
    strings along with the scanner class in the `java.util` package.
  prefs: []
  type: TYPE_NORMAL
- en: The following activity uses the string variable and the integer variable to
    input information about a student and then print it out.
  prefs: []
  type: TYPE_NORMAL
- en: Import the scanner package and create a new class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the student name as a string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the university name as a string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the student's age as an integer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `System.out.println` to print out the student details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After running the program, the output should be similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 306.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 5: Calculating the Number of Full Fruit Boxes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: John is a peach grower. He picks peaches from his trees, puts them into fruit
    boxes and ships them. He can ship a fruit box if it is full with 20 peaches. If
    he has less than 20 peaches, he has to pick more peaches so he can fill a fruit
    box with 20 peaches and ship it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would like to help John by calculating the number of fruit boxes that he
    can ship and the number of peaches left behind, given the number of peaches he
    was able to pick. To achieve this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class and enter `PeachCalculator` as the class name
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `java.util.Scanner` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main()` use `System.out.print` to ask the user for the `numberOfPeaches`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Calculate the `numberOfFullBoxes` and `numberOfPeachesLeft` values. Hint: use
    integer division.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `System.out.println` to output these two values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the main program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output should be similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 307.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this lesson, we learned about the use of primitive and reference data types,
    along with simple arithmetic operations on data in Java. We learned how to cast
    data types from one type to another. We then saw how we can work with floating-point
    data types.
  prefs: []
  type: TYPE_NORMAL
- en: In the next lesson, we will work with conditional statements and looping structures.
  prefs: []
  type: TYPE_NORMAL
