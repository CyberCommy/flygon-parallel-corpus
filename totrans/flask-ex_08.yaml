- en: Chapter 8. Validating User Input in Our Crime Map Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users will always use your application in ways you didn't intend or expect,
    either out of ignorance or malicious intent. Every bit of input that the user
    has any control over should be validated to make sure it conforms to what is expected.
  prefs: []
  type: TYPE_NORMAL
- en: We'll polish off our second project by making sure that users can't break it
    accidentally or through maliciously crafted input.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing where to validate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying out an XSS example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating and sanitizing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing where to validate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few choices to make when it comes to validating user input and
    displaying feedback that helps them fix any mistakes they make. The major choice
    is *where* to do the validation: in the browser, on the server, or both.'
  prefs: []
  type: TYPE_NORMAL
- en: We could do it in JavaScript in the user's browser. The advantages of this approach
    are that the users will get faster feedback (they don't have to wait to send data
    to our server, have it validated, and have a response sent back), and it also
    lightens the load on our server; if we don't use CPU cycles and network bandwidth
    to validate user data, it means we have lower costs associated with running our
    server. The disadvantage of this approach is that we have no assurance that the
    user will not bypass these checks; if the checks are run in the user's browser,
    then the user has full control over them. This means that data that is validated
    by client-side checks is still not guaranteed to be what we expect.
  prefs: []
  type: TYPE_NORMAL
- en: We could do it on the server after the user submits the data. The advantages
    and disadvantages of this approach are the opposite of those described earlier.
    We use more processing time that we're paying for, but we get extra assurance
    about the integrity of our checks. On the other hand, the user normally has to
    wait longer to get feedback about legitimate (not malicious) errors.
  prefs: []
  type: TYPE_NORMAL
- en: The final option is to do both. This gives us the best of all worlds; we can
    give fast feedback to the user in JavaScript, but then recheck the results on
    the server side to make sure that nothing got past our client-side checks. The
    flipside of this is that we end up wasting time on CPU cycles checking legitimate
    data twice, and we also have to put more effort into development as we have to
    write validation checks in JavaScript and in Python.
  prefs: []
  type: TYPE_NORMAL
- en: In this project, as we will implement our form management from scratch, we'll
    just do some very basic checks on the server side and no checking on the client
    side. In our next project, when we use frameworks to handle user input, we'll
    discuss how to easily use some more sophisticated validation methods.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying inputs that require validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already noted that not all browsers support the HTML5 `"date"` type
    input. This means that, as our site stands, some users will possibly type the
    date of the crime in manually, and this means that we need to be able to deal
    with the user inputting dates in various formats. Our database expects yyyy-mm-dd
    (for example, 2015-10-10 for October 10, 2015), but our users will not necessarily
    conform to this format even if we tell them to. The **Date** field, then, is one
    of the inputs we would want to validate.
  prefs: []
  type: TYPE_NORMAL
- en: Our **Latitude** and **Longitude** fields are also editable by the user, and
    therefore the user could enter text or other invalid coordinates in them. We could
    add validation checks for these, but, as the user should never actually need to
    edit these values, we'll instead consider how to make them *read only*. We'll
    add a validation check to make sure that the user has not left them blank, though.
  prefs: []
  type: TYPE_NORMAL
- en: The **Description** is the most obviously dangerous field. The user can freely
    input text here, and this means that the user has opportunities to *inject* code
    into our app. This means that instead of filling in a text description, as we'd
    probably expect, the user can input JavaScript or HTML code here that interferes
    with the code that we expect to run. Doing so would be an example of a so-called
    XSS or cross-site scripting attack, and we'll look at some malicious inputs that
    a user might use here.
  prefs: []
  type: TYPE_NORMAL
- en: Our last input is the **Category**. This might seem perfectly safe as the user
    has to select it from a drop-down list. However, it's important that the drop-down
    is merely a convenience, and, actually, a user with some very basic knowledge
    can use free-form text here as well. This is because the browser uses the information
    from the form to create a `POST` request, which it sends to our server. As a `POST`
    request is just text that is structured in a certain way and sent over HTTP; there
    is nothing stopping our tech-savvy users from constructing the `POST` request
    without using a web browser (they could use Python or another programming language
    instead or even some more specialized, but freely available software, such as
    BURP Suite).
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, all of our inputs need validation in some form or another. Before
    we take a look at exactly how to go about validating input, let's take a brief
    look at what a malicious user might do if we decided not to implement validation.
  prefs: []
  type: TYPE_NORMAL
- en: Trying out an XSS example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most sought-after attacks by malicious users is a so-called *persistent*
    XSS attack. This means that the attacker not only manages to inject code into
    your web app but this injected code also remains for an extended period of time.
    Most often, this is achieved by tricking the app into storing the malicious, injected
    code in a database and then running the code on a page on subsequent visits.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the following examples, we will *break* our application, specific inputs
    to our form. You will need to log in to the database on VPS afterwards to manually
    clear these inputs that leave our app in a broken state.
  prefs: []
  type: TYPE_NORMAL
- en: 'As our app currently stands, an attacker could carry out a persistent XSS attack
    by filing out the **Category**, **Date**, **Latitude**, and **Longitude** fields
    as usual, and using the following for the **Description** field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This might look a bit strange, but give it a go. You should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Trying out an XSS example](img/B04312_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And after you click **OK** on the popup, you''ll probably notice a strange
    excerpt from JavaScript at the top of our page (your value for `longitude` will
    be different, depending on where you placed the marker):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at what happened here. If we look at the full source code of our
    page, as it got interpreted by our browser, things will make more sense. Right-click
    on the page and click on **View Page Source** or an equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `placecrimes()` call in the `initialize` function of our JavaScript code
    can be seen to now read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If your browser uses any form of code highlighting, it''ll be easier to see
    what''s happening. The opening `<script>` tag near the beginning of our page is
    now closed by the description of our first crime, as our browser knows to interpret
    anything that comes between `<script>` and `</script>` as JavaScript code. As
    we have `</script>` at the beginning of our `"description"`, the browser closes
    this section of JavaScript. Immediately after this, a new JavaScript section is
    opened by `<script>`, which is the next part of our description. Following this,
    we have `alert(1);`, which simply creates the pop-up box with **1** in it that
    we noted earlier. This script section is closed again, and the rest of our page
    is now interpreted as a mess by our browser. We can see the rest of our JSON (`"longitude":
    …` ) until halfway through our `for` loop is displayed to the user, and the "`<`"
    symbol from `i<crimes.length` is now interpreted by the browser as another opening
    tag so that the JavaScript that follows this is hidden again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix our app, wipe all the crime data from your database with the following
    commands (which you should run on VPS):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a message about how many crime records were deleted from the
    `crimes` table, similar to that seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Trying out an XSS example](img/B04312_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The potential of persistent XSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It may seem pretty bad that our web application is broken. Worse still, reloading
    the page is not a solution. As the malicious description is stored in our database,
    the same issue will appear no matter how many times we reload the page. Even worse,
    the "`alert(1);`" example is just this—an example to show that the attacker has
    the freedom to run any code he or she desires. Often, an attacker uses this to
    trick the user into visiting another (malicious) page, banking on the fact that
    the user trusts the original page and will, therefore, be more likely trust the
    content on it. The possibilities are really only limited by our attacker's imagination.
  prefs: []
  type: TYPE_NORMAL
- en: Validating and sanitizing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To prevent the preceding, we've already chosen to inspect the data on the server
    side and make sure it conforms to our expectation. We still have a few more choices
    to make, though.
  prefs: []
  type: TYPE_NORMAL
- en: White and blacklisting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to create some rules to choose between acceptable inputs and unacceptable
    inputs, and there are two main ways of doing this. One way is to *blacklist* inputs
    that look malicious. Using this method, we would create a list of characters that
    might be used maliciously, such as "`<`" and "`>`", and we will reject inputs
    that contain these characters. The alternative is to use a *whitelist* approach.
    This is the opposite of blacklisting, in that, instead of choosing which characters
    we won't allow, we can choose a list of characters that we *will* allow.
  prefs: []
  type: TYPE_NORMAL
- en: It may seem like a nit-picky distinction, but it is important nonetheless. If
    we go with a blacklist approach, we are more likely to be outsmarted by malicious
    users who manage to inject code using only characters that we haven't added to
    our ban list.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, using a whitelist approach, we are more likely to frustrate
    users who want to use characters which we haven't thought to add to the whitelist.
  prefs: []
  type: TYPE_NORMAL
- en: As our app only requires a `"description"` input to be free-text and because
    our app is localized (in the examples we used, the app is specific to Grahamstown,
    South Africa, and therefore we will expect our users to only need normal Latin
    characters and not, for example, Chinese characters), we should be able to employ
    whitelisting without getting in the way of our users.
  prefs: []
  type: TYPE_NORMAL
- en: Validating versus sanitizing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we have to decide what to do with invalid input. Do we reject it completely
    and ask the user to try again, or do we just strip away the invalid parts of the
    user input and keep the rest? Removing or modifying user input (for example, by
    adding escape characters) is referred to as *sanitizing* the input. The advantage
    of this approach is that the user is often oblivious to it; if he or she inadvertently
    includes a special character in the description of the crime and we remove it,
    it's unlikely to make the rest of the description incomprehensible or worthless.
    The disadvantage is that if the user does end up relying on too many characters
    that we have blacklisted, it can corrupt the information to the point of being
    unusable or even misconstruing what the user intended.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With all of the preceding in mind, we want to:'
  prefs: []
  type: TYPE_NORMAL
- en: Check the category that the user submits and make sure it is in the list of
    categories that we expect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the date that the user submits and make sure that we can properly understand
    it as a date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the latitude and longitude that the user submits and make sure that these
    are parsable as floating point numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the description that the user submits and strip out all characters except
    for those that are alphanumeric or part of a preselected list of basic punctuation
    characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although we'll silently edit the `description` to remove non-whitelisted characters,
    we want to reject the entire submission and make the user start again if the other
    fields aren't as we expect. We, therefore, also want to add a way of displaying
    custom error messages to the user after he or she submits the form. Let's add
    a few Python functions to help us with all of this. We'll also restructure some
    of our code to conform to the *Don't repeat yourself(DRY)* principle.
  prefs: []
  type: TYPE_NORMAL
- en: Validating the category
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously, when we created the drop-down list for `categories`, we hardcoded
    the two `categories` we wanted into our template. This is already not ideal as
    it means that we have to write our more boilerplate code (such as HTML tags) if
    we ever want to add or edit the `categories`. Now that we also want access the
    list of `categories` in Python, so that we can validate that the user hasn't sneakily
    used a category that isn't in our list, it makes sense to restructure it a bit
    so that we only define our list of `categories` once.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll define the list in our Python code and then we can pass it to our template
    to construct the drop-down list and use the same list for validation when the
    user submits the form. At the top of `crimemap.py`, along with our other globals,
    add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `return` statement of the `home()` function, pass in this list as a
    named argument. The line should now look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In `home.html`, change the `<select>` block to use a Jinja `for` loop, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With these small modifications, we have a much easier way to maintain our list
    of `categories`. We can now also use the new list to validate. As the category
    is provided by a drop-down list, the average user does not enter an invalid value
    here, so we don't have to worry too much about providing polite feedback. In this
    case, we'll just ignore the submission and return to the home page again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `if` statement directly below where we loaded the category
    data into a variable in the `submitcrime()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If triggered, this `return` would happen before we add anything to the database,
    and our user's attempted input would be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: Validating the location
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As our location data should be populated automatically by the marker that the
    user places on the map, we want to make these fields `readonly`. This means that
    our JavaScript will still be able to modify the values as the marker gets used,
    but the fields will reject input or modification from the user''s keyboard. To
    do this, simply add the `readonly` attribute where we define the form in our `home.html`
    template. The updated `input` definitions should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As with the drop-down list, though, the `readonly` property is only enforced
    at a browser level and is easily bypassed. We, therefore, want to add a server-side
    check as well. To do this, we'll use the Python philosophy of "it is better to
    ask for forgiveness than permission", or, in other words, assume everything will
    be OK and deal with the other cases in an `except` block instead of using too
    many `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we can parse the user''s location data into floating point numbers, it''s
    almost definitely safe as it''s pretty difficult to do things such as modifying
    HTML, JavaScript, or SQL code using only numbers. Add the following code around
    the section of the `submitcrime()` function where we parse the location inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If there's any unexpected text in the `latitude` or `longitude` inputs, `ValueError`
    will be thrown when we attempt to cast to the float type, and, again, we'll return
    to the home page before putting any of the potentially dangerous data into our
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Validating the date
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the `date` input, we could take the same approach as we did for the `category`.
    Most of the time, the user will select the date from a calendar picker and, therefore,
    will be unable to input an invalid date. However, as not all browsers support
    the `date` input type, sometimes, normal users will type out the dates manually,
    and this may lead to accidental error.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in this case, we don't only want to reject invalid input. We want
    to, as far as possible, work out what the user intended, and if we cannot, we
    want to display a message to the user to indicate what needs to be fixed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow for a more flexible input, we''ll use a Python module called `dateparser`.
    This module allows us to take even inconsistently formatted dates and convert
    them into accurate Python `datetime` objects. The first thing we need to do is
    install it through `pip`. Run the following command locally *and* on VPS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you haven''t used it before, you might like to play around a bit with the
    possibilities. The following standalone script demonstrates some of the magic
    that `dateparser` provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: All the preceding strings are correctly parsed into `datetime` objects, except,
    arguably, the last one, as `dateparser` uses the American format and interprets
    it to be March 4, 2015, instead of April 3, 2015.
  prefs: []
  type: TYPE_NORMAL
- en: Some more examples as well as other information about the `dateparser` module
    can be found on PyPI at [https://pypi.python.org/pypi/dateparser](https://pypi.python.org/pypi/dateparser).
  prefs: []
  type: TYPE_NORMAL
- en: Just using this package will solve a lot of our problems as we can now transform
    invalid inputs into valid ones without any help from the user at all. The slight
    inconvenience is that we have already set up our database to accept dates to be
    inserted as strings in the "*yyyy-mm-dd*" format; however, to take advantage of
    our new `dateparser` module, we'll want to convert the user's input to a `datetime`
    object. The slightly counterintuitive workaround is to convert the string input
    we receive from the user to a `datetime` object and then back to a string (which
    will always be in the correct format) before passing it into our database code
    to store in MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, add the following helper function to your `crimemap.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, add the imports for the `datetime` and `dateparser` modules to the top
    of `crimemap.py`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We'll pass the `date` as input by our user (`userdate`) into this function and
    parse this using our `dateparser` module. If the date is completely unparsable
    (for example, "`aaaaa`"), the `dateparser.parse` function will just return nothing
    instead of throwing an error. Therefore, we will put the call to `strftime`, which
    will format the date as a string in the correct format into a `try except` block;
    if our `date` variable is empty, we'll get a `TypeError`, in which case our helper
    function will also return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to decide what to do in case we cannot parse the date. Unlike
    the other validation cases we looked at, in this case, we want to prompt the user
    with a message saying that we were unable to understand his or her input. To achieve
    this, we''ll add an error message parameter to the `home()` function and pass
    in a relevant error message from the `submitcrime()` function. Modify the `home()`
    function to add the parameter and to pass the parameter into our template, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, modify the `submitcrime()` function to add some logic to parsing the
    date input by our user and to pass an error message to our `home()` function if
    we fail to parse the `date`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add a section to our template file to display the error message
    if it exists. We''ll add it to the top of the form where it should catch the user''s
    attention via the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We will add the preceding `if` statement as we''ll otherwise see the word "`None`"
    appear above our form when the `error_message` variable has its default value
    of `None`. Also, note that the message itself appears in a `<div>` tag with an
    ID of error. This allows us to add some CSS to make the error message appear in
    red. Add the following block to your `style.css` file in your static directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it for validating our date. If you have a browser that does not support
    the `date` input, try creating a new crime and inputting a string that even `dateparser`
    cannot interpret as a legitimate date to make sure you see the error as expected.
    It should look something similar to the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating the date](img/B04312_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Flask provides some pretty nifty functionality for message *flashing*—that is,
    to display optional text to the user at a specific position on the page. This
    has some more powerful and flexible functionality than the basic example we discussed,
    and should certainly be considered for similar cases. Information about message
    flashing in Flask can be found at [http://flask.pocoo.org/docs/0.10/patterns/flashing/](http://flask.pocoo.org/docs/0.10/patterns/flashing/).
  prefs: []
  type: TYPE_NORMAL
- en: Validating the description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can assume that a user will be able to convey basic information about a
    crime using only numbers, letters (capital and lowercase), and some basic punctuation
    marks, so let''s create a simple Python function that filters out all characters
    from a string except the ones we have identified as safe. Add the following `sanitize()`
    function to your `crimemap.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the import for string to the imports section of `crimemap.py`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Our `sanitize_string()` function is quite concise, and uses some of Python's
    functional programming potential. The `filter` function applies another function
    repeatedly for each element in a list and builds a new list based on the ones
    that "pass." In this case, the function that we will pass into `filter()` is a
    simple `lambda` function that checks whether or not a letter belongs to our `whitelist`.
    The result of our function is a string similar to the input one, but with all
    the characters that aren't part of our whitelist removed.
  prefs: []
  type: TYPE_NORMAL
- en: Our whitelist is built from all the letters (uppercase and lowercase), the digits
    one to nine, and some basic punctuation marks that people may use while typing
    informal descriptions of events.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use our new function, simply change the line near the end of the `submitcrime()`
    function in `crimemap.py` from the following to the subsequent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that, as our SQL driver mitigates against SQL injection and our `json.dumps()`
    function escapes double quotation marks, we should be largely safe just by blacklisting
    characters such as angle brackets, which we used to demonstrate an XSS attack.
    This would allow more flexibility for our users, but malicious users can be determined
    and creative in crafting input that will bypass the filters we set up. Refer to
    [https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet)
    for some examples. Give the validation changes a go locally first and then, if
    everything looks good by committing to `git`, push the repo to the remote, and
    pull it onto VPS. Restart Apache and visit your IP address. Try submitting a crime
    using `</script>` in the `description`, and you'll notice when you hover the cursor
    over the marker for this crime that all we've stored is "`script`". We will strip
    the slash and the angle brackets, thus ensuring protection against XSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already discussed the pros and cons of blacklisting and whitelisting, but,
    to emphasise that whitelisting is not a perfect approach, take a look at the post
    here about mistakes developers often make when whitelisting an input for users''
    names: [http://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/](http://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/)'
  prefs: []
  type: TYPE_NORMAL
- en: The last change we can make to our `dbhelper.py`, `mockdbhelper.py`, and `crimemap.py`
    files is to remove the functions we no longer need. When we had a basic database
    application that was not specific to crimes, we had the `get_all_inputs()`, `add_input()`,
    and `clear_all()` functions in our `DBHelper` classes and the `add()` and `clear()`
    functions in our `crimemap.py` file. All of these can be removed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have spent a whole chapter looking at validation, but if you look at the
    major companies that have faced information security breaches over the last few
    years, you'll agree that security is worth spending some time on. We looked specifically
    at cross-site scripting or XSS attacks, but we also discussed some more general
    points of input validation. This takes us to the end of our second project.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that is notably missing is to work out who added which crimes. If
    one malicious user adds a bunch of bogus crimes to our database, they could potentially
    mess up our entire dataset!
  prefs: []
  type: TYPE_NORMAL
- en: In our next project, we'll look at authenticating users through a User Account
    Control system, which will give us more control over who we let on our site and
    what they can do.
  prefs: []
  type: TYPE_NORMAL
