- en: Chapter 8. Validating User Input in Our Crime Map Project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users will always use your application in ways you didn't intend or expect,
    either out of ignorance or malicious intent. Every bit of input that the user
    has any control over should be validated to make sure it conforms to what is expected.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We'll polish off our second project by making sure that users can't break it
    accidentally or through maliciously crafted input.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Choosing where to validate
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying out an XSS example
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating and sanitizing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing where to validate
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few choices to make when it comes to validating user input and
    displaying feedback that helps them fix any mistakes they make. The major choice
    is *where* to do the validation: in the browser, on the server, or both.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: We could do it in JavaScript in the user's browser. The advantages of this approach
    are that the users will get faster feedback (they don't have to wait to send data
    to our server, have it validated, and have a response sent back), and it also
    lightens the load on our server; if we don't use CPU cycles and network bandwidth
    to validate user data, it means we have lower costs associated with running our
    server. The disadvantage of this approach is that we have no assurance that the
    user will not bypass these checks; if the checks are run in the user's browser,
    then the user has full control over them. This means that data that is validated
    by client-side checks is still not guaranteed to be what we expect.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: We could do it on the server after the user submits the data. The advantages
    and disadvantages of this approach are the opposite of those described earlier.
    We use more processing time that we're paying for, but we get extra assurance
    about the integrity of our checks. On the other hand, the user normally has to
    wait longer to get feedback about legitimate (not malicious) errors.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The final option is to do both. This gives us the best of all worlds; we can
    give fast feedback to the user in JavaScript, but then recheck the results on
    the server side to make sure that nothing got past our client-side checks. The
    flipside of this is that we end up wasting time on CPU cycles checking legitimate
    data twice, and we also have to put more effort into development as we have to
    write validation checks in JavaScript and in Python.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: In this project, as we will implement our form management from scratch, we'll
    just do some very basic checks on the server side and no checking on the client
    side. In our next project, when we use frameworks to handle user input, we'll
    discuss how to easily use some more sophisticated validation methods.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Identifying inputs that require validation
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already noted that not all browsers support the HTML5 `"date"` type
    input. This means that, as our site stands, some users will possibly type the
    date of the crime in manually, and this means that we need to be able to deal
    with the user inputting dates in various formats. Our database expects yyyy-mm-dd
    (for example, 2015-10-10 for October 10, 2015), but our users will not necessarily
    conform to this format even if we tell them to. The **Date** field, then, is one
    of the inputs we would want to validate.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Our **Latitude** and **Longitude** fields are also editable by the user, and
    therefore the user could enter text or other invalid coordinates in them. We could
    add validation checks for these, but, as the user should never actually need to
    edit these values, we'll instead consider how to make them *read only*. We'll
    add a validation check to make sure that the user has not left them blank, though.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The **Description** is the most obviously dangerous field. The user can freely
    input text here, and this means that the user has opportunities to *inject* code
    into our app. This means that instead of filling in a text description, as we'd
    probably expect, the user can input JavaScript or HTML code here that interferes
    with the code that we expect to run. Doing so would be an example of a so-called
    XSS or cross-site scripting attack, and we'll look at some malicious inputs that
    a user might use here.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Our last input is the **Category**. This might seem perfectly safe as the user
    has to select it from a drop-down list. However, it's important that the drop-down
    is merely a convenience, and, actually, a user with some very basic knowledge
    can use free-form text here as well. This is because the browser uses the information
    from the form to create a `POST` request, which it sends to our server. As a `POST`
    request is just text that is structured in a certain way and sent over HTTP; there
    is nothing stopping our tech-savvy users from constructing the `POST` request
    without using a web browser (they could use Python or another programming language
    instead or even some more specialized, but freely available software, such as
    BURP Suite).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, all of our inputs need validation in some form or another. Before
    we take a look at exactly how to go about validating input, let's take a brief
    look at what a malicious user might do if we decided not to implement validation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Trying out an XSS example
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most sought-after attacks by malicious users is a so-called *persistent*
    XSS attack. This means that the attacker not only manages to inject code into
    your web app but this injected code also remains for an extended period of time.
    Most often, this is achieved by tricking the app into storing the malicious, injected
    code in a database and then running the code on a page on subsequent visits.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the following examples, we will *break* our application, specific inputs
    to our form. You will need to log in to the database on VPS afterwards to manually
    clear these inputs that leave our app in a broken state.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'As our app currently stands, an attacker could carry out a persistent XSS attack
    by filing out the **Category**, **Date**, **Latitude**, and **Longitude** fields
    as usual, and using the following for the **Description** field:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This might look a bit strange, but give it a go. You should see the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![Trying out an XSS example](img/B04312_08_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: 'And after you click **OK** on the popup, you''ll probably notice a strange
    excerpt from JavaScript at the top of our page (your value for `longitude` will
    be different, depending on where you placed the marker):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's look at what happened here. If we look at the full source code of our
    page, as it got interpreted by our browser, things will make more sense. Right-click
    on the page and click on **View Page Source** or an equivalent.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'The `placecrimes()` call in the `initialize` function of our JavaScript code
    can be seen to now read as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If your browser uses any form of code highlighting, it''ll be easier to see
    what''s happening. The opening `<script>` tag near the beginning of our page is
    now closed by the description of our first crime, as our browser knows to interpret
    anything that comes between `<script>` and `</script>` as JavaScript code. As
    we have `</script>` at the beginning of our `"description"`, the browser closes
    this section of JavaScript. Immediately after this, a new JavaScript section is
    opened by `<script>`, which is the next part of our description. Following this,
    we have `alert(1);`, which simply creates the pop-up box with **1** in it that
    we noted earlier. This script section is closed again, and the rest of our page
    is now interpreted as a mess by our browser. We can see the rest of our JSON (`"longitude":
    …` ) until halfway through our `for` loop is displayed to the user, and the "`<`"
    symbol from `i<crimes.length` is now interpreted by the browser as another opening
    tag so that the JavaScript that follows this is hidden again.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix our app, wipe all the crime data from your database with the following
    commands (which you should run on VPS):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should see a message about how many crime records were deleted from the
    `crimes` table, similar to that seen in the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![Trying out an XSS example](img/B04312_08_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: The potential of persistent XSS
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It may seem pretty bad that our web application is broken. Worse still, reloading
    the page is not a solution. As the malicious description is stored in our database,
    the same issue will appear no matter how many times we reload the page. Even worse,
    the "`alert(1);`" example is just this—an example to show that the attacker has
    the freedom to run any code he or she desires. Often, an attacker uses this to
    trick the user into visiting another (malicious) page, banking on the fact that
    the user trusts the original page and will, therefore, be more likely trust the
    content on it. The possibilities are really only limited by our attacker's imagination.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Validating and sanitizing
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To prevent the preceding, we've already chosen to inspect the data on the server
    side and make sure it conforms to our expectation. We still have a few more choices
    to make, though.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: White and blacklisting
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to create some rules to choose between acceptable inputs and unacceptable
    inputs, and there are two main ways of doing this. One way is to *blacklist* inputs
    that look malicious. Using this method, we would create a list of characters that
    might be used maliciously, such as "`<`" and "`>`", and we will reject inputs
    that contain these characters. The alternative is to use a *whitelist* approach.
    This is the opposite of blacklisting, in that, instead of choosing which characters
    we won't allow, we can choose a list of characters that we *will* allow.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: It may seem like a nit-picky distinction, but it is important nonetheless. If
    we go with a blacklist approach, we are more likely to be outsmarted by malicious
    users who manage to inject code using only characters that we haven't added to
    our ban list.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, using a whitelist approach, we are more likely to frustrate
    users who want to use characters which we haven't thought to add to the whitelist.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: As our app only requires a `"description"` input to be free-text and because
    our app is localized (in the examples we used, the app is specific to Grahamstown,
    South Africa, and therefore we will expect our users to only need normal Latin
    characters and not, for example, Chinese characters), we should be able to employ
    whitelisting without getting in the way of our users.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Validating versus sanitizing
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we have to decide what to do with invalid input. Do we reject it completely
    and ask the user to try again, or do we just strip away the invalid parts of the
    user input and keep the rest? Removing or modifying user input (for example, by
    adding escape characters) is referred to as *sanitizing* the input. The advantage
    of this approach is that the user is often oblivious to it; if he or she inadvertently
    includes a special character in the description of the crime and we remove it,
    it's unlikely to make the rest of the description incomprehensible or worthless.
    The disadvantage is that if the user does end up relying on too many characters
    that we have blacklisted, it can corrupt the information to the point of being
    unusable or even misconstruing what the user intended.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须决定如何处理无效输入。我们是完全拒绝它并要求用户重试，还是只剥离用户输入的无效部分并保留其余部分？删除或修改用户输入（例如添加转义字符）被称为*净化*输入。这种方法的优势是用户通常对此毫不知情；如果他或她在犯罪描述中无意中包含特殊字符，而我们将其删除，这不太可能使描述的其余部分变得难以理解或毫无价值。缺点是，如果用户最终依赖我们列入黑名单的太多字符，它可能会使信息损坏到无法使用甚至误解用户的本意。
- en: Implementing validation
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施验证
- en: 'With all of the preceding in mind, we want to:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有前述内容，我们希望：
- en: Check the category that the user submits and make sure it is in the list of
    categories that we expect
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查用户提交的类别，并确保它在我们期望的类别列表中
- en: Check the date that the user submits and make sure that we can properly understand
    it as a date
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查用户提交的日期，并确保我们可以正确理解它作为日期。
- en: Check the latitude and longitude that the user submits and make sure that these
    are parsable as floating point numbers
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查用户提交的纬度和经度，并确保这些可以解析为浮点数
- en: Check the description that the user submits and strip out all characters except
    for those that are alphanumeric or part of a preselected list of basic punctuation
    characters
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查用户提交的描述，并剥离除了字母数字字符或基本标点字符预选列表之外的所有字符
- en: Although we'll silently edit the `description` to remove non-whitelisted characters,
    we want to reject the entire submission and make the user start again if the other
    fields aren't as we expect. We, therefore, also want to add a way of displaying
    custom error messages to the user after he or she submits the form. Let's add
    a few Python functions to help us with all of this. We'll also restructure some
    of our code to conform to the *Don't repeat yourself(DRY)* principle.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们会悄悄编辑“描述”以删除非白名单字符，但如果其他字段不符合我们的预期，我们希望拒绝整个提交并让用户重新开始。因此，我们还希望在用户提交表单后添加一种显示自定义错误消息的方法。让我们添加一些Python函数来帮助我们完成所有这些。我们还将重构一些代码以符合*不要重复自己（DRY）*原则。
- en: Validating the category
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证类别
- en: Previously, when we created the drop-down list for `categories`, we hardcoded
    the two `categories` we wanted into our template. This is already not ideal as
    it means that we have to write our more boilerplate code (such as HTML tags) if
    we ever want to add or edit the `categories`. Now that we also want access the
    list of `categories` in Python, so that we can validate that the user hasn't sneakily
    used a category that isn't in our list, it makes sense to restructure it a bit
    so that we only define our list of `categories` once.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，当我们为“类别”创建下拉列表时，我们在模板中硬编码了我们想要的两个“类别”。这已经不理想，因为这意味着如果我们想要添加或编辑“类别”，我们必须编写更多样板代码（如HTML标记）。现在我们还想在Python中访问“类别”列表，以便我们可以验证用户是否偷偷使用了不在我们列表中的类别，因此重构一下是有道理的，这样我们只定义一次我们的“类别”列表。
- en: 'We''ll define the list in our Python code and then we can pass it to our template
    to construct the drop-down list and use the same list for validation when the
    user submits the form. At the top of `crimemap.py`, along with our other globals,
    add the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Python代码中定义列表，然后我们可以将其传递给模板以构建下拉列表，并在用户提交表单时使用相同的列表进行验证。在`crimemap.py`的顶部，与其他全局变量一起，添加以下内容：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the `return` statement of the `home()` function, pass in this list as a
    named argument. The line should now look similar to this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在`home()`函数的`return`语句中，将此列表作为命名参数传递。该行现在应该类似于这样：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In `home.html`, change the `<select>` block to use a Jinja `for` loop, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在`home.html`中，更改`<select>`块以使用Jinja的`for`循环，如下所示：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With these small modifications, we have a much easier way to maintain our list
    of `categories`. We can now also use the new list to validate. As the category
    is provided by a drop-down list, the average user does not enter an invalid value
    here, so we don't have to worry too much about providing polite feedback. In this
    case, we'll just ignore the submission and return to the home page again.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些小修改，我们有了一种更容易维护我们的“类别”列表的方法。我们现在还可以使用新列表进行验证。由于类别是由下拉列表提供的，普通用户在这里不会输入无效值，因此我们不必太担心提供礼貌的反馈。在这种情况下，我们将忽略提交并再次返回主页。
- en: 'Add the following `if` statement directly below where we loaded the category
    data into a variable in the `submitcrime()` function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在`submitcrime()`函数中加载类别数据到变量中的位置下方直接添加以下`if`语句：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If triggered, this `return` would happen before we add anything to the database,
    and our user's attempted input would be discarded.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果触发了这个“返回”，它会在我们向数据库添加任何内容之前发生，并且我们用户尝试的输入将被丢弃。
- en: Validating the location
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证位置
- en: 'As our location data should be populated automatically by the marker that the
    user places on the map, we want to make these fields `readonly`. This means that
    our JavaScript will still be able to modify the values as the marker gets used,
    but the fields will reject input or modification from the user''s keyboard. To
    do this, simply add the `readonly` attribute where we define the form in our `home.html`
    template. The updated `input` definitions should look as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As with the drop-down list, though, the `readonly` property is only enforced
    at a browser level and is easily bypassed. We, therefore, want to add a server-side
    check as well. To do this, we'll use the Python philosophy of "it is better to
    ask for forgiveness than permission", or, in other words, assume everything will
    be OK and deal with the other cases in an `except` block instead of using too
    many `if` statements.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'If we can parse the user''s location data into floating point numbers, it''s
    almost definitely safe as it''s pretty difficult to do things such as modifying
    HTML, JavaScript, or SQL code using only numbers. Add the following code around
    the section of the `submitcrime()` function where we parse the location inputs:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If there's any unexpected text in the `latitude` or `longitude` inputs, `ValueError`
    will be thrown when we attempt to cast to the float type, and, again, we'll return
    to the home page before putting any of the potentially dangerous data into our
    database.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Validating the date
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the `date` input, we could take the same approach as we did for the `category`.
    Most of the time, the user will select the date from a calendar picker and, therefore,
    will be unable to input an invalid date. However, as not all browsers support
    the `date` input type, sometimes, normal users will type out the dates manually,
    and this may lead to accidental error.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in this case, we don't only want to reject invalid input. We want
    to, as far as possible, work out what the user intended, and if we cannot, we
    want to display a message to the user to indicate what needs to be fixed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow for a more flexible input, we''ll use a Python module called `dateparser`.
    This module allows us to take even inconsistently formatted dates and convert
    them into accurate Python `datetime` objects. The first thing we need to do is
    install it through `pip`. Run the following command locally *and* on VPS:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you haven''t used it before, you might like to play around a bit with the
    possibilities. The following standalone script demonstrates some of the magic
    that `dateparser` provides:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All the preceding strings are correctly parsed into `datetime` objects, except,
    arguably, the last one, as `dateparser` uses the American format and interprets
    it to be March 4, 2015, instead of April 3, 2015.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Some more examples as well as other information about the `dateparser` module
    can be found on PyPI at [https://pypi.python.org/pypi/dateparser](https://pypi.python.org/pypi/dateparser).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Just using this package will solve a lot of our problems as we can now transform
    invalid inputs into valid ones without any help from the user at all. The slight
    inconvenience is that we have already set up our database to accept dates to be
    inserted as strings in the "*yyyy-mm-dd*" format; however, to take advantage of
    our new `dateparser` module, we'll want to convert the user's input to a `datetime`
    object. The slightly counterintuitive workaround is to convert the string input
    we receive from the user to a `datetime` object and then back to a string (which
    will always be in the correct format) before passing it into our database code
    to store in MySQL.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, add the following helper function to your `crimemap.py` file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Also, add the imports for the `datetime` and `dateparser` modules to the top
    of `crimemap.py`, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We'll pass the `date` as input by our user (`userdate`) into this function and
    parse this using our `dateparser` module. If the date is completely unparsable
    (for example, "`aaaaa`"), the `dateparser.parse` function will just return nothing
    instead of throwing an error. Therefore, we will put the call to `strftime`, which
    will format the date as a string in the correct format into a `try except` block;
    if our `date` variable is empty, we'll get a `TypeError`, in which case our helper
    function will also return `None`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to decide what to do in case we cannot parse the date. Unlike
    the other validation cases we looked at, in this case, we want to prompt the user
    with a message saying that we were unable to understand his or her input. To achieve
    this, we''ll add an error message parameter to the `home()` function and pass
    in a relevant error message from the `submitcrime()` function. Modify the `home()`
    function to add the parameter and to pass the parameter into our template, as
    follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, modify the `submitcrime()` function to add some logic to parsing the
    date input by our user and to pass an error message to our `home()` function if
    we fail to parse the `date`, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We also need to add a section to our template file to display the error message
    if it exists. We''ll add it to the top of the form where it should catch the user''s
    attention via the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will add the preceding `if` statement as we''ll otherwise see the word "`None`"
    appear above our form when the `error_message` variable has its default value
    of `None`. Also, note that the message itself appears in a `<div>` tag with an
    ID of error. This allows us to add some CSS to make the error message appear in
    red. Add the following block to your `style.css` file in your static directory:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'That''s it for validating our date. If you have a browser that does not support
    the `date` input, try creating a new crime and inputting a string that even `dateparser`
    cannot interpret as a legitimate date to make sure you see the error as expected.
    It should look something similar to the following image:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating the date](img/B04312_08_03.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Flask provides some pretty nifty functionality for message *flashing*—that is,
    to display optional text to the user at a specific position on the page. This
    has some more powerful and flexible functionality than the basic example we discussed,
    and should certainly be considered for similar cases. Information about message
    flashing in Flask can be found at [http://flask.pocoo.org/docs/0.10/patterns/flashing/](http://flask.pocoo.org/docs/0.10/patterns/flashing/).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Validating the description
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can assume that a user will be able to convey basic information about a
    crime using only numbers, letters (capital and lowercase), and some basic punctuation
    marks, so let''s create a simple Python function that filters out all characters
    from a string except the ones we have identified as safe. Add the following `sanitize()`
    function to your `crimemap.py` file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, add the import for string to the imports section of `crimemap.py`, as
    follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our `sanitize_string()` function is quite concise, and uses some of Python's
    functional programming potential. The `filter` function applies another function
    repeatedly for each element in a list and builds a new list based on the ones
    that "pass." In this case, the function that we will pass into `filter()` is a
    simple `lambda` function that checks whether or not a letter belongs to our `whitelist`.
    The result of our function is a string similar to the input one, but with all
    the characters that aren't part of our whitelist removed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Our whitelist is built from all the letters (uppercase and lowercase), the digits
    one to nine, and some basic punctuation marks that people may use while typing
    informal descriptions of events.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'To use our new function, simply change the line near the end of the `submitcrime()`
    function in `crimemap.py` from the following to the subsequent:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that, as our SQL driver mitigates against SQL injection and our `json.dumps()`
    function escapes double quotation marks, we should be largely safe just by blacklisting
    characters such as angle brackets, which we used to demonstrate an XSS attack.
    This would allow more flexibility for our users, but malicious users can be determined
    and creative in crafting input that will bypass the filters we set up. Refer to
    [https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet)
    for some examples. Give the validation changes a go locally first and then, if
    everything looks good by committing to `git`, push the repo to the remote, and
    pull it onto VPS. Restart Apache and visit your IP address. Try submitting a crime
    using `</script>` in the `description`, and you'll notice when you hover the cursor
    over the marker for this crime that all we've stored is "`script`". We will strip
    the slash and the angle brackets, thus ensuring protection against XSS.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于我们的SQL驱动程序可以减轻SQL注入，而我们的`json.dumps()`函数可以转义双引号，因此我们只需在黑名单中列出一些字符，比如尖括号，我们就可以基本上安全了，我们用它来演示XSS攻击。这将为我们的用户提供更多的灵活性，但是恶意用户可能会决心并且有创造力地制作输入，以绕过我们设置的过滤器。参考[https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet)获取一些例子。首先在本地尝试验证更改，然后，如果一切看起来都很好，就提交到`git`，将存储库推送到远程，并将其拉到VPS上。重新启动Apache并访问您的IP地址。尝试在`description`中提交一个使用`</script>`的犯罪，当您将光标悬停在这个犯罪的标记上时，您会注意到我们存储的只是"`script`"。我们将删除斜杠和尖括号，从而确保防止XSS攻击。
- en: 'We already discussed the pros and cons of blacklisting and whitelisting, but,
    to emphasise that whitelisting is not a perfect approach, take a look at the post
    here about mistakes developers often make when whitelisting an input for users''
    names: [http://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/](http://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了黑名单和白名单的利弊，但是为了强调白名单并不是一个完美的方法，看一下这里关于开发人员在为用户的名称设置白名单时经常犯的错误的帖子：[http://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/](http://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/)
- en: The last change we can make to our `dbhelper.py`, `mockdbhelper.py`, and `crimemap.py`
    files is to remove the functions we no longer need. When we had a basic database
    application that was not specific to crimes, we had the `get_all_inputs()`, `add_input()`,
    and `clear_all()` functions in our `DBHelper` classes and the `add()` and `clear()`
    functions in our `crimemap.py` file. All of these can be removed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对我们的`dbhelper.py`、`mockdbhelper.py`和`crimemap.py`文件进行的最后一个更改是删除我们不再需要的函数。当我们有一个不特定于犯罪的基本数据库应用程序时，我们在我们的`DBHelper`类中有`get_all_inputs()`、`add_input()`和`clear_all()`函数，在我们的`crimemap.py`文件中有`add()`和`clear()`函数。所有这些都可以被移除。
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have spent a whole chapter looking at validation, but if you look at the
    major companies that have faced information security breaches over the last few
    years, you'll agree that security is worth spending some time on. We looked specifically
    at cross-site scripting or XSS attacks, but we also discussed some more general
    points of input validation. This takes us to the end of our second project.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经花了一整章的时间来研究验证，但是如果你看一下过去几年面临信息安全漏洞的主要公司，你会同意安全是值得花一些时间的。我们特别关注了跨站脚本攻击或XSS攻击，但我们也讨论了一些更一般的输入验证要点。这让我们来到了我们第二个项目的结束。
- en: One thing that is notably missing is to work out who added which crimes. If
    one malicious user adds a bunch of bogus crimes to our database, they could potentially
    mess up our entire dataset!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显缺失的事情是弄清楚是谁添加了哪些犯罪。如果一个恶意用户向我们的数据库添加了一堆虚假的犯罪，他们可能会搞乱我们整个数据集！
- en: In our next project, we'll look at authenticating users through a User Account
    Control system, which will give us more control over who we let on our site and
    what they can do.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个项目中，我们将研究通过用户帐户控制系统对用户进行身份验证，这将使我们对我们允许在我们的网站上的用户以及他们可以做什么有更多的控制。
