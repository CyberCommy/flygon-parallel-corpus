- en: Multiplayer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since my earliest gaming adventures, I have found that sharing the experience
    always made it more memorable. Back in those days, the concept of multiplayer
    revolved around playing with friends on the couch or getting together with other
    game fans for an epic **LAN** (**local area network**) party. Things have changed
    dramatically since then, with online, worldwide, shared gaming experiences the
    new norm. In this chapter, we will cover the concept of adding multiplayer support
    to your game project, specifically focusing on networked multiplayer. As I have
    said before, the topic of computer networking is a very large and diverse topic
    and would require more time and space than we have to cover in full. Instead,
    we will focus on the high-level overview and go deep where required. In this chapter,
    we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to multiplayer in games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network design and protocol development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a client/server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to multiplayer in games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To boil it down to its simplest terms, a multiplayer game is a type of video
    game where more than one person can play simultaneously. While single-player video
    games are usually geared around one player competing with AI opponents and achieving
    predefined goals, multiplayer games are designed around interaction with other
    human players. These interactions can be in the form of competition, partnership,
    or simply social engagement. How these multiple player interactions are implemented
    can vary depending on factors such as location and genre, from fighter games with
    same screen multiplayer to online multiplayer role-playing games, with users sharing
    a common environment. In this next section, we will look at some of the various
    ways multiplayer interactions can be included in video games.
  prefs: []
  type: TYPE_NORMAL
- en: Local multiplayer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of multiplayer in games first appeared in the form of local multiplayer.
    Very early on a lot of games had two-player modes. Some games would implement
    a two-player mode known as turn-based multiplayer, where players could take turns
    playing the game. While this but even early on developers saw the benefit of shared
    experiences. Even the earliest games such as *Spacewar!* (1962) and *PONG* (1972)
    pitted players against each other. The rise of the arcade gaming scene helped
    push local multiplayer games, with games such as *Gauntlet* (1985) offering up
    to four player co-operative gaming experience.
  prefs: []
  type: TYPE_NORMAL
- en: Most local multiplayer games can be placed into one of a few categories, turn-based,
    shared single-screen, or split-screen multiplayer.
  prefs: []
  type: TYPE_NORMAL
- en: Turn-based, as its name suggests, is a multiplayer mode where the players take
    turns playing the game using a single screen. A good example of a turn-based multiplayer
    game would be the original *Super Mario Bros*, for **Nintendo Entertainment System**
    (**NES**). In this game, if the two-player mode is selected, the first player
    plays as the Mario character; when the player dies, the second player has their
    turn and plays as the other brother, Luigi.
  prefs: []
  type: TYPE_NORMAL
- en: Shared single-screen multiplayer is a common local multiplayer mode where each
    player's character is on the same screen. Each player has control of their character/avatar
    simultaneously. This mode is very well-suited to versus gameplay such as sports
    and fighter games, as well as co-operative gameplay such as platformers and puzzle
    solvers. This mode continues to be very popular today, with a great example being
    the recently released Cuphead title.
  prefs: []
  type: TYPE_NORMAL
- en: Single-screen multiplayer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Split-screen multiplayer is another popular local multiplayer mode where each
    player has a portion of the entire local screen as their gameplay view. Each player
    controls their character/avatar simultaneously. This mode is very well-suited
    to versus games such as shooter titles. Although most games choosing to implement
    a split-screen mode are two-player games, some titles supported as many as four
    local players, with the local screen being split vertically and horizontally into
    quarters. A great example of a game that implements split-screen multiplayer is
    the first person shooter, *Halo*.
  prefs: []
  type: TYPE_NORMAL
- en: Local area network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the proliferation of personal computers in the early 1990s' the idea of
    connecting computers together to share information soon developed into a core
    need for most computer users. One early way of connecting multiple computers together
    was through a LAN. A LAN allows computers in a limited area, such as a university,
    office, school, or even a personal residence. LAN's are not by default connectable
    unless you are in that limited area in which the LAN is located. While the business
    computing world had already adopted the idea of LAN computing, the gaming industry
    really started using the technology for multiplayer with the release of *DOOM*
    in 1993.
  prefs: []
  type: TYPE_NORMAL
- en: The popularity of LAN-based multiplayer games has weaned since the wide adoption
    of the internet. That being said, LAN is still the way multiplayer games are played
    at competitions such as the e-sport leagues of today. The idea of LAN-based multiplayer
    gaming also spawned a phenomenon known as the **LAN party**. LAN parties are getting
    where players of games come together in the same physical location and connect
    all their computers together in order to play with each other. These events usually
    spanned multiple days, with players traveling large distances to take part. LAN
    parties were a staple of the gaming landscape in the early to late 1990's, for
    any gamer that took part, it was a memorable way to connect with other gamers.
  prefs: []
  type: TYPE_NORMAL
- en: Online multiplayer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The popularity of the internet brought with it the ability for gamers around
    the world to connect and play together in a whole new way. Unlike the LAN parties
    of old, gamers could now play and compete with fellow gamers from all over the
    world without leaving the comfort of their own home. The history of online multiplayer
    can be traced all the way back to the early examples such as **MUD** (**Multi-User
    Dungeon**), where users could play the simple RPGs over the internet. Online multiplayer
    games span almost every genre of games today, from first-person shooters to real-time
    strategy games. Internet-based gameplay also spawned a new genre of games called
    **Massively Multiplayer Online** (**MMO**) games. In MMOs' massive amounts of
    players can all connect and interact in a single instance or world. One of the
    most popular MMO games to date is *World of Warcraft*.
  prefs: []
  type: TYPE_NORMAL
- en: Network design and protocol development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two of the biggest considerations when designing and developing multiplayer
    games is deciding on the network topology and connection protocol to use. Each
    choice has a significant bearing on the implementation and gameplay itself. In
    this next part of the chapter, we will cover the different network topologies
    and protocols in use, and discuss their various effects and considerations.
  prefs: []
  type: TYPE_NORMAL
- en: Network topology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simply put, network topology is the way computers on a network are connected
    to one another. For online gaming, the network topology will determine how the
    computers on the network are organized to allow users to receive updates to the
    game. How the computers are networked will determine many aspects of the overall
    multiplayer design and each type of topology has its own strengths and weakness.
    In this next section, we will cover the two most popular topologies used in game
    development, the client/server, and the peer-to-peer model.
  prefs: []
  type: TYPE_NORMAL
- en: Peer-to-peer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a peer-to-peer network, each individual player is connected to every other
    player in the game instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3d659e4-2a88-41f3-89bb-e8c3d6ec723a.png)'
  prefs: []
  type: TYPE_IMG
- en: A peer-to-peer network is usually implemented in a non-authoritative design.
    This means that no single entity that controls game states, so every player must
    handle its own game state, and communicate any local changes to other players
    connected. This means as a consequence of this topology we have a few issues to
    think about. The first is bandwidth; as you have probably imagined, with this
    design there is a large amount of data that needs to be passed between players.
    In fact, the number of connections can be represented as a quadratic function
    where each player will have O(n-1) connections, which means that there will be
    O(2n) connections in total for this network topology. This network design is also
    symmetric, which means that every player will have to have the same available
    bandwidth for both upload and download streams. The other issue we need to consider
    is the concept of authority.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned here, the most common approach to handling authority in a peer-to-peer
    network is to have all players share updates to every other player on the network.
    As a consequence of handling authority in this manner is that the player sees
    two situations accruing at the same time, the players own input updating the game
    state instantaneously and a simulation of the other player's movements. Since
    the updates from the other players have to traverse the network, the updates are
    not instantaneous. When the local player receives an update, to say move an opponent
    to (x, y, z), the chances of the opponent still being in that location at the
    time of receiving the update are low, that is why the updates from other players
    are simulated. The biggest issue with simulating updates is that as the latency
    increases, the simulation becomes more and more inaccurate. We will discuss techniques
    for handling this issue of update lag and simulation in the next section of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Client/server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a client-server topology, one instance is designated the server, and all
    of the other player instances connect to it. Each of the player instances (the
    client) will only ever communicates with the server. The server, in turn, is responsible
    for communicating all updates of the players to the other clients connected on
    the network. The following image demonstrates this network topology:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15371b3c-817a-4dd0-8f36-3efc7ed10f5d.png)'
  prefs: []
  type: TYPE_IMG
- en: While not the only method, a client-server network commonly implements an authoritative
    design. This means, as a player performs an action, such as moving their character
    to another place, that information is sent in the form of an update to the server.
    The server checks whether the update is considered correct, and if it is, the
    server then relays this update information to the other players connected on the
    network. If there is ever a situation where the client and server disagree on
    the update information, the server is considered the correct version. Just like
    the peer-to-peer topology, there are some things to consider when implementing.
    When it comes to bandwidth, in theory, the bandwidth requirement for each player
    will not change depending on the number of players connected. If we looked at
    this in the form of a quadratic formula, given n players the total of connections
    would be O(2n). However, unlike the peer-to-peer topology, client-server topology
    is asymmetric, meaning the server will have only O(n) connections, or one to one
    per client. This means that as the number of players connected increases, the
    bandwidth required to support the connections will increase linearly. That said,
    in practice, as more players join, more objects need to be simulated, which might
    cause slight increases to bandwidth requirements for both client and server.
  prefs: []
  type: TYPE_NORMAL
- en: An authoritative design is considered more secure against cheating. This is
    because the server fully controls the game states and update. If a suspicious
    update is passed from a player, the server can ignore it and provide the correct
    update information to the other clients instead.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into implementing multiplayer, it is important to understand how
    things are handled under the hood so to speak. One of the most important aspects
    is how the data is being exchanged between two computers. This is where protocols
    come in. Although there are many different ways to exchange data on networks,
    in this section, we are going to look at the **Transmission Control Protocol/Internet
    Protocol** (**TCP/IP**) model with a focus on the host-to-host layer protocols.
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The TCP/IP model is a description of a protocol suite, which is a collection
    of protocols that are designed to work together to transfer data from one computer
    to another. It is named after two of the main protocols (TCP and IP). TCP/IP is
    considered the de-facto standard protocol today and has replaced older protocol
    suites, such as IPX and SPX. The TCP/IP protocol suite can be broken down into
    a 4-layer model shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8101e9f1-4a5d-41d6-b776-6243c8ca3b9d.png)'
  prefs: []
  type: TYPE_IMG
- en: Most modern networking courses teach the 7-layer OSI model. The OSI model is
    an idealized networking model and, as of yet, not a practical implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The four layers are broken down into the application layer, the transport layer,
    the networking layer, and the datalink layer. The application is the layer that
    represents the data to the user and handles the encoding and dialog control. A
    commonly known application layer protocol is the **Hyper Text Transfer Protocol
    (HTTP**), which is the protocol that powers the websites we all use daily. The
    transport layer, also known as the host-to-host layer, is the layer that supports
    the lower level communications between various devices and networks, independent
    of the hardware being used. We will dive deeper into this layer next. The networking
    layer is the layer that determines the best path for the data through the network
    and handles addressing. The most common protocol in this layer is **Internet Protocol**
    (**IP**). There are two versions of IP: the IPv4 standard, and the IPv6 standard.
    The fourth and final layer is the datalink or network access layer. The datalink
    layer specifies the hardware devices and media that make up the network. Common
    datalink protocols are Ethernet and Wi-Fi.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a general understanding of the layers, let''s take a closer
    look at the two most commonly used networking layer protocols in game development:
    TCP and UDP.'
  prefs: []
  type: TYPE_NORMAL
- en: UDP – User Datagram Protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin with, let''s look at the **User Datagram Protocol** (**UDP**). UDP
    is a very lightweight protocol that can be used to pass data from a specified
    port on one host to another specified port on another host. A grouping of data
    being sent in one instance is referred to as a datagram. The datagram consists
    of an 8-byte header followed by the data to be passed, referred to as the payload.
    A UDP header is depicted in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit#** | 0 | 16 |'
  prefs: []
  type: TYPE_TB
- en: '| 0-31 | Source Port | Destination Port |'
  prefs: []
  type: TYPE_TB
- en: '| 32-63 | Length | Checksum |'
  prefs: []
  type: TYPE_TB
- en: UDP header
  prefs: []
  type: TYPE_NORMAL
- en: 'To break it down bits by bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source port**: (16 bits) This identifies the port from which the data being
    passed is originating from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destination port:** (16 bits) This is the target port of the data being passed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Length**: (16 bits) This is the total length of the UDP header and the data
    payload combined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Checksum**: (16 bits, optional) This is a checksum calculated based on the
    UDP header, payload, and certain fields of the IP header. By default, this field
    is set to all zeros.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because UDP is such a simple protocol, it gives up a few features to keep it
    lightweight. One missing feature is a shared state between the two hosts. This
    means that no effort is made to ensure the complete passage of the datagram. There
    is no guarantee that the data will be in the right order when it arrives, if it
    arrives at all. This is very different to the next protocol we will look at, the
    TCP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: TCP – Transmission Control Protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike UDP, where a single datagram is passed, the TCP protocol, as its name
    suggests, creates a constant connection for transmission between two hosts. This
    allows a reliable stream of data to be passed back and forth between the hosts.
    TCP also attempts to ensure all data that is sent is actually received and in
    the proper order. With these added features, comes some added overhead. The header
    of a TCP connection is much larger than that of UDP. A depiction of a TCP header
    in a table format is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/477d5bac-3328-4025-b9d0-fb7219a94faa.png)'
  prefs: []
  type: TYPE_IMG
- en: TCP header
  prefs: []
  type: TYPE_NORMAL
- en: For a TCP connection, a unit of data transmission is referred to as a segment.
    A segment consists of the TCP header and then the data that is being passed in
    that single segment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break it down bit by bit as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source port**: (16 bits) This identifies the port from which the data being
    passed is originating from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destination port**: (16 bits) This is the target port of the data being passed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sequence number**: (32-bits) This is a unique identifier number. Since TCP
    attempts to have the recipient receive the data in the order it was sent, each
    byte transferred through TCP receives a sequence number. These numbers allow the
    recipient and sender to ensure the order by following the sequence of these numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Acknowledgment number**: (32-bits) This is the sequence number of the next
    byte of data that the sender is passing. This, in essence, acts as an acknowledgment
    for all data with sequence numbers lower than this number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data offset**: (4 bits) This specifies the length of the header in 32-bit
    words. It allows the addition of custom header components, if needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Control bits**: (9 bits) This holds metadata about the header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receive window**: (16 bits) This conveys the amount of remaining buffer space
    the sender has for incoming data. This is important when trying to maintaining
    flow control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Urgent pointer**: (16 bits) This is the delta value between the first byte
    of data in this segment and the first byte of urgent data. This is optional and
    only relevant if the `URG` flag is set in the metadata of the header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the OSI model, there are a few different types of sockets that determine
    the structure of the transport layer. The two most common types are stream sockets
    and datagram sockets. In this section, we will briefly cover them and how they
    differ.
  prefs: []
  type: TYPE_NORMAL
- en: Stream sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A stream socket is used for the reliable two-way communication between different
    hosts. You can think of a stream socket as being similar to making a telephone
    call. When one host calls, other's connection is initiated; once the connection
    is made, both parties can communicate back and forth. The connection is constant
    like a stream.
  prefs: []
  type: TYPE_NORMAL
- en: An example of the use of stream sockets can be seen in the Transmission Control
    Protocol, which we discussed earlier in this chapter. Using TCP allows the data
    to be sent in sequences or packets. As mentioned before, TCP maintains state and
    provides a way to ensure that data arrives and that it is in the same order as
    it was sent. This is important for many types of applications including communications
    between web servers, mail servers, and their client applications.
  prefs: []
  type: TYPE_NORMAL
- en: In a later section, we will look at how you can implement your own stream sockets
    using the Transmission Control Protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Datagram sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As opposed to stream sockets, datagram sockets are less like making a phone
    call and more akin to sending a letter in the mail. A datagram socket connection
    is a one-way only and is an unreliable connection. Unreliable in the sense that
    you can not be sure when or even if datagram socket data will arrive at the receiver.
    There is no way to guarantee the order in which the data arrives.
  prefs: []
  type: TYPE_NORMAL
- en: User Datagram Protocol, as described in the previous section, uses datagram
    sockets. Although UDP and datagram sockets are more lightweight, they provide
    a great choice when you just need to send data. The overhead of creating stream
    sockets, establishing and then maintaining that socket connection can overkill
    in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: Datagram sockets and UDP are commonly used in networked games and streaming
    media. UDP is typically a good choice when a client needs to make a short query
    to a server, and it expects to receive a single response. To provide this send
    and receive service, we would need to use the UDP specific function calls, `sendto()`
    and `recvfrom()`, `instead of read()` and `write()` seen in the socket implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple TCP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at the process of implementing a simple TCP server
    example using the sockets technique discussed in the preceding sections. This
    example can then be expanded to support various gameplay needs and features.
  prefs: []
  type: TYPE_NORMAL
- en: Since the process of creating a server is slightly different for each platform,
    I have broken the examples into two different versions.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin with let’s look at how we can use the WinSock libraries on the Windows
    platform to create a simple socket server that will listen for connections and
    print out a simple debug message when a connection is made. For the full implementation,
    check out the `Chapter10` directory of the code repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: First, we have our includes. This gives us access to the libraries that we need
    to create our sockets (this is different for other platforms).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Jumping to the main method, we begin with initializing the underlying libraries.
    In this case, we are using the WinSock libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, we set up our addressing information for the socket.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We then create our socket, passing in the elements we created in the addressing
    stage.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After we create our socket, it is good to setup our socket to be able to reuse
    the address we defined on a closer or reset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now we can bind our address and finally listen for connections.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In our main loop, we check for new connections, on receiving a valid one we
    print a simple debug message to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we have to clean up after ourselves. We close the socket and call the
    `WSACleanup` function to initialize clean up of the WinSock library.
  prefs: []
  type: TYPE_NORMAL
- en: And, that’s it. We now have a simple server that will listen for an incoming
    connection on the port we specified, `44000` in this example.
  prefs: []
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For macOS (and other *nix-based operating systems) the process is very similar
    to the Windows example, however, we need to use different libraries to help support
    us.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, we have the include, here we are using the system sockets, which on *nix
    systems is based on the BSD implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In our main function, we begin by setting the addressing information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We then create our socket, passing in the elements we created in the addressing
    stage.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: After we create our socket, it is good to set up our socket to be able to reuse
    the address we defined on a closer or reset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now we can bind our address and finally listen for connections.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In our main loop, we check for new connections, on receiving a valid one we
    print a simple debug message to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we have to clean up after ourselves. In this case, we just have to
    close the socket.
  prefs: []
  type: TYPE_NORMAL
- en: And, that’s it. We now have a simple server that will listen for an incoming
    connection on the port we specified, `44000` in this example.
  prefs: []
  type: TYPE_NORMAL
- en: To test our example, we can either use an existing program such as **putty**
    to connect to our server. Or we could create a simple client, which I will leave
    to you as a takeaway project. While just a simple server, this creates a starting
    point for building up your own implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took big steps to understand how multiplayer is implemented
    at a lower level. You learned about the TCP/IP stack and the different network
    topologies in use for game development. We looked at using UDP and TCP protocols
    in order to pass data to and from a client-server setup. Finally, we looked at
    some of the issues faced by developers when they start to implement multiplayer
    features. In the next chapter, we will look at how we can take our games to a
    new realm—virtual reality.
  prefs: []
  type: TYPE_NORMAL
