- en: Security Tips and Tricks for the Busy Bee
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this, our final chapter, I'd like to do a round-up of quick tips and tricks
    that don't necessarily fit in with the previous chapters. Think of these tips
    as time savers for the busy administrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Quick ways to audit which system services are running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password-protecting the GRUB2 configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securely configuring and then password-protecting UEFI/BIOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a security checklist when setting up your system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auditing system services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A basic tenet of server administration, regardless of which operating system
    we're talking about, is to never have anything that you don't absolutely need
    installed on a server. You especially don't want any unnecessary network services
    running because that would give the bad guys extra ways to get into your system.
    And, there's always a chance that some evil hacker might have planted something
    that acts as a network service, and you'd definitely want to know about that.
    In this chapter, we'll look at a few different ways to audit your system to ensure
    that no unnecessary network services are running on it.
  prefs: []
  type: TYPE_NORMAL
- en: Auditing system services with systemctl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On Linux systems that come with systemd, the `systemctl` command is pretty
    much a universal command that does many things for you. In addition to controlling
    your system''s services, it can also show you the status of those services. We
    have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the breakdown of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-t service`: We want to view information about the services—or, what used
    to be called **daemons**—on the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--state=active`: This specifies that we want to view information about all
    the system services that are actually running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A partial output of this command looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You generally won't want to see quite this much information, although you might
    at times. This command shows the status of every service that's running on your
    system. What really interests us now is just the network services that can allow
    someone to connect to your system. So, let's look at how to narrow things down
    a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Auditing network services with netstat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are two reasons why you would want to keep track of what network
    services are running on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that no legitimate network services that you don't need are running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To ensure that you don't have any malware that's listening for network connections
    from its master
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `netstat` command is both handy and easy to use for these instances. First,
    let''s say that you want to see a list of network services that are listening,
    waiting for someone to connect to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The breakdown is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-lp`: The `l` means that we want to see which network ports are listening.
    In other words, we want to see which network ports are waiting for someone to
    connect to them. The `p` means that we want to see the name and process ID number
    of the program or service that is listening on each port.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-A inet`: This means that we only want to see information about the network
    protocols that are members of the `inet` family. In other words, we want to see
    information about the `raw`, `tcp`, and `udp` network sockets, but we don''t want
    to see anything about the Unix sockets that only deal with interprocess communications
    within the operating system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since this output is from the OpenSUSE workstation that I just happen to be
    using at the moment, you won''t see any of the usual server-type services here.
    However, you do see a few things that you likely won''t want to see on your servers.
    For example, let''s look at the very first item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Local Address` column specifies the local address and port of this listening
    socket. The asterisk means that this socket is on the local network, and `ideafarm-door`
    is the name of the network port that is listening. (By default, `netstat` will
    show you the names of ports whenever possible, by pulling the port information
    out of the `/etc/services` file.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, because I didn''t know what the `ideafarm-door` service is, I used my
    favorite search engine to find out. By plugging the term `ideafarm-door` into
    DuckDuckGo, I found the answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c01aa891-62dd-4b2c-8758-2883e24819a9.png)'
  prefs: []
  type: TYPE_IMG
- en: The top search result took me to a site named *WhatPortIs*. According to this,
    the `ideafarm-door` is in reality port `902`, which belongs to the VMware Server
    Console. Okay, that makes sense because I do have VMware Player installed on this
    machine. So, that's all good.
  prefs: []
  type: TYPE_NORMAL
- en: You can check out the *WhatPortIs* site here: [http://whatportis.com/](http://whatportis.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next on the list is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This item shows the local address as `localhost` and that the listening port
    is port `40432`.  This time, the `PID/Program Name` column actually tells us what
    this is. *SpiderOak ONE* is a cloud-based backup service that you might or might
    not want to see running on your server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at a few more items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see that Dropbox and SpiderOak ONE are both listed with the asterisk
    for the local address. So, they're both using the local network address. The name
    of the port for Dropbox is `db-lsp`, which stands for *Dropbox LAN Sync Protocol*.
    The SpiderOak ONE port doesn't have an official name, so it's just listed as port
    `37468`. The bottom two lines show that Dropbox also uses the local machine's
    address, on ports `17600` and `17603`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far we''ve looked at nothing but TCP network sockets. Let''s see how they
    differ from UDP sockets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to note is that there's nothing under the `State` column. That's
    because with UDP, there are no states. They actually are listening for data packets
    to come in, and they're ready to send data packets out. But since that's about
    all that UDP sockets can do, there was really no sense in defining different states
    for them.
  prefs: []
  type: TYPE_NORMAL
- en: In the first two lines, we see some strange local addresses. That's because
    I have both VMware Player and VirtualBox installed on this workstation. The local
    addresses of these two sockets are for the VMware and VirtualBox virtual network
    adapters. The last line shows the hostname of my OpenSUSE workstation as the local
    address. In all three cases, the port is the Network Time Protocol port, for time
    synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at one last set of UDP items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see that my Chromium web browser is ready to accept network packets
    on a few different ports. We also see that Dropbox uses UDP to accept discovery
    requests from other local machines that have Dropbox installed. I assume that
    port `21327` performs the same function for SpiderOak ONE.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, since this machine is my workhorse workstation, Dropbox and SpiderOak
    ONE are almost indispensable to me. I installed them myself, so I've always know
    that they were there. However, if you see anything like this on a server, you'll
    want to investigate to see if the server admins know that these programs are installed,
    and then find out why they're installed. It could be that they're performing a
    legitimate function, and it could be that they're not.
  prefs: []
  type: TYPE_NORMAL
- en: A difference between Dropbox and SpiderOak ONE is that with Dropbox, your files
    don't get encrypted until they've been uploaded to the Dropbox servers. So, the
    Dropbox folk have the encryption keys to your files. On the other hand, SpiderOak
    ONE encrypts your files on your local machine, and the encryption keys never leave
    your possession. So, if you really do need a cloud-based backup service and you're
    dealing with sensitive files, something like SpiderOak ONE would definitely be
    better than Dropbox. (And no, the SpiderOak ONE folk aren't paying me to say that.)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see port numbers and IP addresses instead of network names,
    add the `n` option. We have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'All you have to do to view the established TCP connections is to leave out
    the `l` option. On my workstation, this makes for a very long list, so I''ll only
    show a few items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `Foreign Address` column shows the address and port number of the machine
    at the remote end of the connection. The first item shows that the connection
    with a Dropbox server is in a `CLOSE_WAIT` state. This means that the Dropbox
    server has closed the connection, and we're now waiting on the local machine to
    close the socket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the names of those foreign addresses don''t make much sense, let''s
    add the `n` option to see IP addresses instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This time we see something new. The first item shows a `SYN_SENT` state for
    the Firefox connection. This means that the local machine is trying to establish
    a connection to the foreign IP address. Also, under `Local Address`, we see the
    static IP address for my OpenSUSE workstation.
  prefs: []
  type: TYPE_NORMAL
- en: If I had space to display the entire `netstat` output here, you'd see nothing
    but `tcp` under the `Proto` column. That's because the UDP protocol doesn't establish
    connections in the same way that the TCP protocol does.
  prefs: []
  type: TYPE_NORMAL
- en: Something to keep in mind is that rootkits can replace legitimate Linux utilities
    with their own trojaned versions. For example, a rootkit could have its own trojaned
    version of `netstat` that would show all network processes except for those that
    are associated with the rootkit. That's why you want something like Rootkit Hunter
    in your toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: If you need more information about `netstat`, see the `netstat` man page.
  prefs: []
  type: TYPE_NORMAL
- en: Auditing network services with Nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `netstat` tool is very good, and it can give you lots of good information
    about what's going on with your network services. The slight downside is that
    you have to log in to every individual host on your network in order to use it.
  prefs: []
  type: TYPE_NORMAL
- en: If you'd like to remotely audit your network to see what services are running
    on each computer, without having to log in to each and every one, then you need
    a tool like Nmap. It's available for all the major operating systems, so even
    if you're stuck having to use Windows on your workstation, you're in luck. An
    up-to-date version is built into Kali Linux, if that's what you're using. It's
    also in the repositories of every major Linux distro, but the version that's in
    the Linux repositories is usually quite old. So if you're using something other
    than Kali, your best bet is just to download Nmap from its creator's website.
  prefs: []
  type: TYPE_NORMAL
- en: You can download Nmap for all of the major operating systems from [https://nmap.org/download.html.](https://nmap.org/download.html)
  prefs: []
  type: TYPE_NORMAL
- en: In all cases, you'll also find instructions for installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll use Nmap the same way on all operating systems, with only one exception.
    On Linux and Mac machines, you''ll preface certain Nmap commands with sudo, and
    on Windows machines, you won''t. Since I just happen to be working on my trusty
    OpenSUSE workstation, I''ll show you how it works on Linux. Let''s start by doing
    a SYN packet scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-sS`: The lower-case `s` denotes the type of scan that we want to perform.
    The uppercase `S` denotes that we''re doing an SYN packet scan. (More on that
    in a moment.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`192.168.0.37`: In this case, I''m only scanning a single machine. But, I could
    also scan either a group of machines, or an entire network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Not shown:  996 closed ports`: The fact that it''s showing all of these closed
    ports instead of `filtered` ports tells me that there''s no firewall on this machine.
    (Again, more on that in a moment.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we see a list of ports that are open. (And, more on that in a moment.)
  prefs: []
  type: TYPE_NORMAL
- en: The MAC address of this machine indicates that it's an Apple product of some
    sort. In a moment, I'll show you how to get more details about what kind of Apple
    product that it might be.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at this more in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Port states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An Nmap scan will show the target machine''s ports in one of three states:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filtered`: This means that the port is blocked by a firewall'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`open`: This means that the port is not blocked by a firewall and that the
    service that''s associated with that port is running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`closed`: This means that the port is not blocked by a firewall, and that the
    service that''s associated with that port is not running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, in our scan of the Apple machine, we see that the Secure Shell service is
    ready to accept connections on port `22`, that the print service is ready to accept
    connections on ports `515` and `631`, and that the **Virtual Network Computing**
    (**VNC**) service is ready to accept connections on port `5900`. All of these
    ports would be of interest to a security-minded administrator. If Secure Shell
    is running, it would be interesting to know if it's configured securely. The fact
    that the print service is running means that this machine is set up to use the
    **Internet Printing Protocol** (**IPP**). It would be interesting to know why
    we're using IPP instead of just regular network printing, and it would also be
    interesting to know if there are any security concerns with this version of IPP.
    And of course, we already know that VNC isn't a secure protocol, so we would want
    to know why it's even running at all. We also saw that no ports are listed as
    `filtered`, so we would also want to know why there's no firewall on this machine.
  prefs: []
  type: TYPE_NORMAL
- en: One little secret that I'll finally reveal, is that this machine is the same
    one that I used for the OpenVAS scan demos. So, we already have some of the needed
    information. The OpenVAS scan told us that Secure Shell on this machine uses weak
    encryption algorithms and that there's a security vulnerability with the print
    service. In just a bit, I'll show you how to get some of that information with
    Nmap.
  prefs: []
  type: TYPE_NORMAL
- en: Scan types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are lots of different scanning options, each with its own purpose. The
    SYN packet scan that we're using here is considered a stealthy type of scan because
    it generates less network traffic and fewer system log entries than certain other
    types of scans. With this type of scan, Nmap sends a SYN packet to a port on the
    target machine, as if it were trying to create a TCP connection to that machine.
    If the target machine responds with a SYN/ACK packet, it means that the port is
    in an `open` state and ready to create the TCP connection. If the target machine
    responds with an RST packet, it means that the port is in a `closed` state. If
    there's no response at all, it means that the port is `filtered`, blocked by a
    firewall. As a normal Linux administrator, this is one of the types of scans that
    you would do most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-sS` scan shows you the state of TCP ports, but it doesn''t show you the
    state of UDP ports. To see the UDP ports, use the `-sU` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, you see something a bit different. You see two ports listed as `open|filtered`.
    That's because, due to the way that UDP ports respond to Nmap scans, Nmap can't
    always tell whether a UDP port is `open` or `filtered`. In this case, we know
    that these two ports are probably open because we've already seen that their corresponding
    TCP ports are open.
  prefs: []
  type: TYPE_NORMAL
- en: 'ACK packet scans can also be useful, but not to see the state of the target
    machine''s network services. Rather, it''s a good option for when you need to
    see if there might be a firewall blocking the way between you and the target machine.
    An ACK scan command looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You''re not limited to scanning just a single machine at a time. You can scan
    either a group of machines or an entire subnet at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first command scans only the first 128 hosts on this network segment. The
    second command scans all 254 hosts on a subnet that's using a 24 bit netmask.
  prefs: []
  type: TYPE_NORMAL
- en: 'A discovery scan is useful for when you need to just see what devices are on
    the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `-sn` option, Nmap will first detect whether you''re scanning the
    local subnet or a remote subnet. If the subnet is local, Nmap will send out an
    **Address Resolution Protocol** (**ARP**) broadcast that requests the IPv4 addresses
    of every device on the subnet. That''s a reliable way of discovering devices because
    ARP isn''t something that will ever be blocked by a device''s firewall. (I mean,
    without ARP, the network would cease to function.) However, ARP broadcasts can''t
    go across a router, which means that you can''t use ARP to discover hosts on a
    remote subnet. So, if Nmap detects that you''re doing a discovery scan on a remote
    subnet, it will send out ping packets instead of ARP broadcasts. Using ping packets
    for discovery isn''t as reliable as using ARP because some network devices can
    be configured to ignore ping packets. Anyway, here''s an example from my own home
    network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We see four hosts in this snippet, and there are three lines of output for each
    host. The first line shows the IP address, the second shows whether the host is
    up, and the third shows the MAC address of the host's network adapter. The first
    three pairs of characters in each MAC address denote the manufacturer of that
    network adapter. (For the record, that unknown network adapter is on a recent
    model Gigabyte motherboard. I have no idea why it's not in the Nmap database.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The final scan that we''ll look at does four things for us:'
  prefs: []
  type: TYPE_NORMAL
- en: It identifies `open`, `closed`, and `filtered` TCP ports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It identifies the versions of the running services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It runs a set of vulnerability-scanning scripts that come with Nmap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It attempts to identify the operating system of the target host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The scan command that does all of these things looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'I guess that you could think of the `-A` option as the *all* option, since
    it really does do it all. (Well, almost all, since it doesn''t scan UDP ports.)
    Here are the results of the scan that I did against my target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several interesting things here. First, there''s the Secure Shell
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Version 5.1 is a really old version of OpenSSH. (At the time of writing, the
    current version is version 7.6.) What's worse is that this OpenSSH server supports
    version 1 of the Secure Shell protocol. Version 1 is seriously flawed and is easily
    exploitable, so you never want to see this on your network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have amplifying information on the print service vulnerability that
    we found with the OpenVAS scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the `631/tcp` line, we see that the associated service is `ipp`, which stands
    for **Internet Printing Protocol**. This protocol is based on the same **Hypertext
    Transfer Protocol** (**HTTP**) that we use to look at web pages. The two methods
    that HTTP uses to send data from a client to a server are **POST** and **PUT**.
    What we really want is for every HTTP server to use the POST method because the
    PUT method makes it very easy for someone to compromise a server by manipulating
    a URL. So, if you scan a server and find that it allows using the PUT method for
    any kind of HTTP communications, you have a potential problem. In this case, the
    solution would be to update the operating system and hope that the updates fix
    the problem. If this were a web server, you'd want to have a chat with the web
    server administrators to let them know what you found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s see what Nmap found out about the operating system of our target
    machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Wait, what?  Mac OS X 10.4?  Isn't that really, really ancient? Well yeah, it
    is. The secret that I've been guarding for the past couple of chapters is that
    the target machine for my OpenVAS and Nmap scan demos has been my ancient, collectible
    Apple eMac from the year 2003\. I figured that scanning it would give us some
    interesting results to look at, and it would appear that I was right. (And yes,
    that is eMac, not iMac.)
  prefs: []
  type: TYPE_NORMAL
- en: Password-protecting the GRUB 2 bootloader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: People sometimes forget passwords, even if they're administrators. And sometimes,
    people buy used computers but forget to ask the seller what the password is. (Yes,
    I've done that.) That's okay, though, because all of the major operating systems
    have ways to let you either reset or recover a lost administrator password. That's
    handy, except that it does kind of make the whole idea of having login passwords
    a rather moot point when someone has physical access to the machine. Let's say
    that your laptop has just been stolen. If you haven't encrypted the hard drive,
    it would only take a few minutes for the thief to reset the password and to steal
    your data. If you have encrypted the drive, the level of protection would depend
    on which operating system you're running. With standard Windows folder encryption,
    the thief would be able to access the encrypted folders just by resetting the
    password. With LUKS whole-disk encryption on a Linux machine, the thief wouldn't
    be able to get past the point of having to enter the encryption passphrase.
  prefs: []
  type: TYPE_NORMAL
- en: With Linux, we have a way to safeguard against unauthorized password resets,
    even if we're not using whole-disk encryption. All we have to do is to password-protect
    the **Grand Unified Bootloader** (**GRUB**), which would prevent a thief from
    booting into emergency mode to do the password reset.
  prefs: []
  type: TYPE_NORMAL
- en: Whether or not you need the advice in this section depends on your organization's
    physical security setup. That's because booting a Linux machine into emergency
    mode requires physical access to the machine. It's not something that you can
    do remotely. In an organization with proper physical security, servers—especially
    ones that hold sensitive data—are locked away in a room that's locked within another
    room. Only a very few trusted personnel are allowed to enter, and they have to
    present their credentials at both access points. So, setting a password on the
    bootloader of those servers would be rather pointless, unless you're dealing with
    a regulatory agency that dictates otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, password-protecting the bootloaders of workstations and laptops
    that are out in the open could be quite useful. But, that alone won't protect
    your data. Someone could still boot the machine from a live disk or a USB memory
    stick, mount the machine's hard drive, and obtain the sensitive data. That's why
    you also want to encrypt your sensitive data, as I showed you in [Chapter 4](081f4a65-5141-48fb-a865-0c23c96019c3.xhtml),
    *Encrypting and SSH Hardening*.
  prefs: []
  type: TYPE_NORMAL
- en: To reset a password, all you have to do is to interrupt the boot process when
    the boot menu comes up and change a couple of kernel parameters. However, resetting
    passwords isn't the only thing you can do from the boot menu. If your machine
    has multiple operating systems installed—for example, Windows on one partition
    and Linux on another partition—the boot menu allows you to choose which operating
    system to boot up. With the old-style legacy GRUB, you could prevent people from
    editing kernel parameters, but you couldn't prevent them from choosing an alternate
    operating system on multiboot machines. With the new GRUB 2 that's in newer versions
    of Linux, you can choose which users you want to be able to boot from any particular
    operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Now, just so you'll know what I'm talking about when I say that you can edit
    kernel parameters from the GRUB 2 boot menu, let me show you how to perform a
    password reset.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting the password for Red Hat/CentOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the boot menu comes up, interrupt the boot process by hitting the down-arrow
    key once. Then, hit the up-arrow key once to select the default boot option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25af8418-ee03-4da1-a179-07d01dfb4b3c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Hit the *E* key to edit the kernel parameters. When the GRUB 2 configuration
    comes up, cursor down until you see this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eba3931e-5e0d-43b9-b3a0-4abfeeb1a274.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Delete the words `rhgb quiet` from this line and then add `rd.break enforcing=0` to
    the end of the line. Here''s what these two new options do for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rd.break`: This will cause the machine to boot into emergency mode, which
    gives you root user privileges without you having to enter a root user password. 
    Even if the root user password hasn''t been set, this still works.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enforcing=0`: When you do a password reset on an SELinux-enabled system, the
    security context for the `/etc/shadow` file will change to the wrong type. If
    the system is in enforcing mode when you do this, SELinux will prevent you from
    logging in until the `shadow` file gets relabeled. But, relabeling during the
    boot process can take a very long time, especially with a large drive. By setting
    SELinux to permissive mode, you can wait until after you''ve rebooted to restore
    the proper security context on just the `shadow` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you''ve finished editing the kernel parameters, hit *Ctrl* + *X* to continue
    the boot process. This will take you to the emergency mode with the `switch_root` command
    prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b50df375-e63a-45f5-a4ba-8ad2752188ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In emergency mode, the filesystem is mounted as read-only. You''ll need to
    remount it as read-write and enter a `chroot` mode before you reset the password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After you enter these two commands, the command prompt will change to that
    of a normal bash shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d25c842-5b18-4c02-adc8-bc8f080c9539.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that you've reached this stage, you're finally ready to reset the password.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to reset the root user password, or even if you want to create
    a root password where none previously existed, just enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Then, enter the new desired password.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the system has never had a root user password and you still don''t want
    it to have one, you can reset the password for an account that has full sudo privileges.
    For example, on my system, the command would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, remount the filesystem as read-only. Then, enter `exit` twice to resume
    rebooting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing you need to do after rebooting is to restore the proper SELinux
    security context on the `/etc/shadow` file. Then, put SELinux back into enforcing
    mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a before and after screenshot of the context settings for my `shadow`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e161c85f-8bc6-4d57-a845-fc94e93e9825.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that resetting the password changed the type of the file to `unlabeled_t`.
    Running the `restorecon` command changed the type back to `shadow_t`.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting the password for Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The procedure for resetting a password on an Ubuntu system is quite a bit different
    and quite a bit simpler. Start out the same as you did with the CentOS machine,
    by pressing the down-arrow key once to interrupt the boot process. Then, press
    the up-arrow key once to select the default boot option. Hit the *E* key to edit
    the kernel parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a52090c-1f47-44be-9d94-7372ed34d00e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the GRUB 2 configuration comes up, cursor down until you see the `linux`
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d9a3652-b616-489f-b92e-c44db5d8ea70.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Change the `ro` to `rw` and add `init=/bin/bash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2bf6dabd-d488-44fd-a727-d3c76a4a8c38.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Press *Ctrl* + *X* to continue booting. This will take you to a root shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09c55698-6c2d-4062-b025-0d8815aa790f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since Ubuntu doesn''t normally have a password assigned to the root user, you
    would most likely just reset the password of whoever had full sudo privileges.
    See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When you''re in this mode, the normal reboot commands won''t work. So, once
    you''ve finished with the password reset operation, reboot by entering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The machine will now boot up for normal operation.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing kernel parameter edits on Red Hat/CentOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ever since the introduction of Red Hat/CentOS 7.2, setting a GRUB 2 password
    to prevent kernel parameter edits is easy. All you have to do is to run one command
    and choose a password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: That's all there is to it. The password hash will be stored in the `/boot/grub2/user.cfg` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when you reboot the machine and try to do a kernel parameter edit, you''ll
    be prompted to enter a username and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/818bcdff-425e-4676-8e2e-671022bed7b3.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that you'll enter `root` as the username, even if the root user's password
    hasn't been set on the system. The `root` user, in this case, is just the superuser
    for GRUB 2.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing kernel parameter edits on Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ubuntu doesn't have that cool utility that Red Hat and CentOS have, so you'll
    have to set a GRUB 2 password by hand-editing a configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `/etc/grub.d/` directory, you''ll see the files that make up the GRUB
    2 configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The file you want to edit is the `40_custom` file. However, before you edit
    the file, you''ll need to create the password hash. Do that with the `grub-mkpasswd-pbkdf2` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the file `40_custom` file in your favorite editor and add a line that
    defines who the superuser(s) will be. Add another line for the password hash.
    In my case, the file now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The string of text that begins with `password_pbkdf2` is all one line that wraps
    around on the printed page.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you save the file, the last step is to generate a new `grub.cfg` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when I reboot this machine, I have to enter my password before editing
    the kernel parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf540a8a-3608-481f-9b0d-2dcb2f783b2f.png)'
  prefs: []
  type: TYPE_IMG
- en: There's only one problem with this. Not only does this prevent anyone except
    the superuser from editing the kernel parameters, it also prevents anyone except
    for the superuser from booting normally. Yes, that's right. Even for normal booting,
    Ubuntu will now require you to enter the username and password of the authorized
    superuser. The fix is easy, although not at all elegant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fix requires inserting a single word into the `/boot/grub/grub.cfg` file.
    Easy enough, right? But, it''s not an elegant solution because you''re not really
    supposed to hand-edit the `grub.cfg` file. At the top of the file, we see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This means that every time we do something that will update the `grub.cfg` file,
    any hand-edits that we've made to the file will be lost. This includes when we
    do a system update that installs a new kernel, or when we do a `sudo apt autoremove` that
    removes any old kernels that we no longer need. The supreme irony though is that
    the official GRUB 2 documentation tells us to hand-edit the `grub.cfg` file to
    deal with these sorts of problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyway, to fix things so that you no longer need to enter the password to boot
    normally, open the `/boot/grub/grub.cfg` file in your favorite text editor. Look
    for the first line that begins with `menuentry`, which should look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Before the opening curly brace at the end of the line, add the text string,
    `--unrestricted`. The `menuentry` should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and test it by rebooting the machine. You should see that the
    machine now boots up normally on the default boot option. But, you'll also see
    that a password will still be required to access the Advanced options for Ubuntu submenu.
    We'll fix that in just a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Password-protecting boot options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For any given Linux system, you'll have at least two boot options. You'll have
    the option to boot normally and the option to boot into recovery mode. Red Hat-type
    and Ubuntu-type operating systems are unique, in that they don't overwrite the
    old kernel when you do an operating system update. Instead, they install the new
    kernel along with the old one, and all the installed kernels have their own boot
    menu entries. On Red Hat-type systems, you'll never have more than five installed
    kernels because once you have five kernels installed, the oldest kernel will automatically
    get deleted the next time a new kernel is available in a system update. With Ubuntu-type
    systems, you'll need to manually delete the old kernels by running `sudo apt autoremove`.
  prefs: []
  type: TYPE_NORMAL
- en: You might also have a dual-boot or a multiboot configuration, and you might
    want for only certain users to use certain boot options. Let's say that you have
    a system with both Windows and Linux installed, and you want to prevent certain
    users from booting into either one or the other. You can do that by configuring
    GRUB 2, but you probably won't. I mean, a password and user account are required
    for logging in to an operating system anyway, so why bother?
  prefs: []
  type: TYPE_NORMAL
- en: The most realistic scenario I can think of where this would be useful would
    be if you have a computer set up in a publicly accessible kiosk. You would surely
    not want for the general public to boot the machine into recovery mode, and this
    technique would help prevent that.
  prefs: []
  type: TYPE_NORMAL
- en: This technique works mostly the same on both Red Hat-type and Ubuntu-type distros,
    with only a few exceptions. The major one is that we need to disable the submenu
    on the Ubuntu machine.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling the submenu for Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Theoretically, you can disable the Ubuntu submenu by placing `GRUB_DISABLE_SUBMENU=true` into
    the `/etc/default/grub` file and then by running `sudo update-grub`. However,
    I couldn't get that to work, and according to the results of my DuckDuckGo searches,
    neither can anyone else. So, we'll manually edit the `/boot/grub/grub.cfg` file
    to fix that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look for the `submenu` line that appears just after the first `menuentry` item.
    It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Comment out that line to make it look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Scroll down until you see this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Just above this line, you''ll see the closing curly brace for the submenu stanza.
    Comment out that curly brace so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now when you reboot the machine, you'll see the whole list of boot options instead
    of the just the default boot option and a submenu. However, as things now stand,
    only the designated superuser can boot into anything except the default option.
  prefs: []
  type: TYPE_NORMAL
- en: Password-protecting boot option steps for both Ubuntu and Red Hat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From here on out, the steps are the same for both the CentOS and the Ubuntu
    virtual machines, except for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: On your Ubuntu machine, the `grub.cfg` file is in the `/boot/grub/` directory. 
    On your CentOS machine, it's in the `/boot/grub2/` directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Ubuntu, the `/boot/grub/` and `/etc/grub.d/` directories are world-readable.
    So, you can `cd` into them as a normal user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On CentOS, the `/boot/grub2/` and `/etc/grub.d/` directories are restricted
    to the root user. So, to `cd` into them, you'll need to log in to the root user's
    shell. Alternatively, you can list the contents from your normal user shell with
    `sudo ls -l`, and you can edit the files you need to edit with `sudo vim /boot/grub2/grub.cfg` or
    `sudo vim /etc/grub.d/40_custom`. (Substitute your favorite editor for vim.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Ubuntu, the command to create a password hash is `grub-mkpasswd-pbkdf2`.
    On CentOS, the command is `grub2-mkpasswd-pbkdf2`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these slight differences in mind, let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: If you're working with a server that's just running with a text-mode interface,
    you'll definitely want to log in remotely from a workstation that has a GUI-type
    interface. If your workstation is running Windows, you can use Cygwin, as I showed
    you in [Chapter 1](366f0919-598d-4648-8873-b4dbe636d171.xhtml), *Running Linux
    in a Virtual Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is that you'll want a way to copy and paste the password
    hashes into the two files that you need to edit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you''ll do is to create a password hash for your new users:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Ubuntu:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'On CentOS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open the `/etc/grub.d/40_custom` file in your text editor and add a line
    for your new user, along with the password hash that you just created. The line
    should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is all one line that wraps around on the printed page.
  prefs: []
  type: TYPE_NORMAL
- en: What you're supposed to do next is to run a utility that will read all of the
    files in the `/etc/grub.d/` directory along with the `/etc/default/grub` file
    and that will then rebuild the `grub.cfg` file. But, on CentOS, that utility doesn't
    work correctly. On Ubuntu, it does work correctly, but it will overwrite any changes
    that you might have already made to the `grub.cfg` file. So, we're going to cheat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `grub.cfg` file in your text editor:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Ubuntu:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'On CentOS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Scroll down until you see the `### BEGIN /etc/grub.d/40_custom ###` section.
    In this section, copy and paste the line that you just added to the `40_custom` file.
    This section should now look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you're ready to password-protect the individual menu entries. And here,
    I've discovered yet another difference between Ubuntu and CentOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In all of the menu entries for CentOS, you''ll see that the `--unrestricted` option
    is already there for all menu entries. This means that by default, all users are
    allowed to boot every menu option, even if you''ve set a superuser password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: So on CentOS, you don't have to do anything if you want all users to be able
    to use all available boot options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s say that you have a `menuentry` that you want to be accessible
    to everybody. On CentOS, as I just pointed out, you don''t have to do anything.
    On Ubuntu, add `--unrestricted` to the `menuentry`, as you did previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If you want for nobody but the superuser to boot from a particular option, add `--users
    ""`. (On CentOS, be sure to remove the `--unrestricted` option first.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want for only the superuser and some other particular user to boot from
    a certain option, add `--users`, followed by the username. (Again, on CentOS,
    remove the `--unrestricted` option first.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have more than one user that you want to access a boot option, add an
    entry for the new user in the `### BEGIN /etc/grub.d/40_custom ###` section. Then,
    add the new user to the `menuentry` that you want for him or her to access. Separate
    the usernames with a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and reboot to try out the different options.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've gone through all this work, I need to remind you again that any
    manual edits that you've made to the `grub.cfg` file will be lost any time that
    a new `grub.cfg` gets generated. So, any time you do a system update that includes
    either installing or removing a kernel, you'll need to manually edit this file
    again to add back the password protection. (In fact, the only real reason I had
    you add the users and their passwords to the `/etc/grub.d/40_custom` file is so
    that you'll always have that information available to copy and paste into `grub.cfg`.)
    I wish that there were a more elegant way of doing this, but according to the
    official GRUB 2 documentation, there isn't.
  prefs: []
  type: TYPE_NORMAL
- en: You'll find the security section of the official GRUB 2 documentation at [http://www.gnu.org/software/grub/manual/grub/grub.html#Security](http://www.gnu.org/software/grub/manual/grub/grub.html#Security).
  prefs: []
  type: TYPE_NORMAL
- en: Before we leave this topic, I'd like to share my personal thoughts about GRUB
    2.
  prefs: []
  type: TYPE_NORMAL
- en: It was necessary to create a new version of GRUB because the old legacy version
    doesn't work with the new UEFI-based motherboards. However, there are things about
    GRUB 2 that are very disappointing.
  prefs: []
  type: TYPE_NORMAL
- en: In the first place, unlike legacy GRUB, GRUB 2 isn't implemented consistently
    across all Linux distros. In fact, we've just seen in our demos how we have to
    do things differently when we go from CentOS to Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the fact that the GRUB 2 developers gave us some good security options,
    but they haven't given us an elegant way of implementing them. I mean, really.
    The whole idea of telling us to implement security features by hand-editing a
    file that will get overwritten every time we do an operating system update just
    doesn't seem right.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, there's the sad state of GRUB 2 documentation. I don't mean to
    sound like I'm tooting my own horn because I know that that's unbecoming. However,
    I think it's safe to say that this is the only comprehensive write-up you'll find
    anywhere for using the password-protection features of GRUB 2.
  prefs: []
  type: TYPE_NORMAL
- en: Securely configuring BIOS/UEFI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This topic is different from anything we've looked at thus far because it has
    nothing to do with the operating system. Rather, we're now going to talk about
    the computer hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Every computer motherboard has either a BIOS or a UEFI chip, which stores both
    the hardware configuration for the computer, and the bootstrap instructions that
    are needed to start the boot process after the power is turned on. UEFI has replaced
    the old-style BIOS on newer motherboards, and it has more security features than
    what the old BIOS had.
  prefs: []
  type: TYPE_NORMAL
- en: I can't give you any specific information about BIOS/UEFI setup because every
    model of the motherboard has a different way of doing things. What I can give
    you is some more generalized information.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you think about BIOS/UEFI security, you might be thinking about disabling
    the ability to boot from anything other than the normal system drive. In the following
    screenshot, you can see that I''ve disabled all SATA drive ports except for the
    one to which the system drive is connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc13e849-eebf-4750-8694-d50766666987.png)'
  prefs: []
  type: TYPE_IMG
- en: When computers are out in the open where the general public can have easy physical
    access to them, this might be a consideration. For servers that are locked away
    in their own secure room with limited access, there's no real reason to worry
    about it, unless the security requirements of some regulatory body dictate otherwise.
    For machines that are out in the open, having whole disk encryption would prevent
    someone from stealing data after booting from either an optical disk or a USB
    device. However, you might still have other reasons to prevent anyone from booting
    the machine from these alternate boot devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another consideration might be if you work in a secure environment where supersensitive
    data are handled. If you''re worried about unauthorized exfiltration of sensitive
    data, you might consider disabling the ability to write to USB devices. This will
    also prevent people from booting the machine from USB devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c8bdae5-cfa5-4774-9fef-d42a672537e1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, there''s more than just this to BIOS/UEFI security. Today''s modern
    server CPUs come with a variety of security features to help prevent data breaches.
    For example, let''s look at a list of security features that are implemented in
    Intel Xeon CPUs:'
  prefs: []
  type: TYPE_NORMAL
- en: Identity-protection technology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced Encryption Standard New Instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trusted Execution Technology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware-assisted virtualization technology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AMD, that plucky underdog in the CPU market, have their own new security features
    in their new line of EPYC server CPUs. These features are:'
  prefs: []
  type: TYPE_NORMAL
- en: Secure Memory Encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure Encrypted Virtualization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In any case, you would configure these CPU security options in your server's
    UEFI setup utility.
  prefs: []
  type: TYPE_NORMAL
- en: You can read about Intel Xeon security features at: [https://www.intel.com/content/www/us/en/data-security/security-overview-general-technology.html](https://www.intel.com/content/www/us/en/data-security/security-overview-general-technology.html).
  prefs: []
  type: TYPE_NORMAL
- en: And, you can read about AMD EPYC security features at [https://semiaccurate.com/2017/06/22/amds-epyc-major-advance-security/](https://semiaccurate.com/2017/06/22/amds-epyc-major-advance-security/).
  prefs: []
  type: TYPE_NORMAL
- en: 'And of course, for any machines that are out in the open, it''s a good idea
    to password-protect the BIOS or UEFI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f6702b0-cb20-4bf5-9d15-e62a624adaff.png)'
  prefs: []
  type: TYPE_IMG
- en: If for no other reason, do it to keep people from monkeying around with your
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: Using a security checklist for system setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I've previously told you about OpenSCAP, which is a really useful tool to lock
    down your system with just a minimum amount of effort. OpenSCAP comes with various
    profiles that you can apply to help bring your systems into compliance with the
    standards of different regulatory agencies. However, there are certain things
    that OpenSCAP can't do for you. For example, certain regulatory agencies require
    that your server's hard drive be partitioned in a certain way, with certain directories
    separated out into their own partitions. If you've already set up your server
    with everything under one big partition, you can't fix that just by doing a remediation
    procedure with OpenSCAP. The process of locking down your server to ensure that
    it's compliant with any applicable security regulations has to begin before you
    even install the operating system. For this, you need the appropriate checklist.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few different places where you can obtain a generic security checklist
    if that''s all you need. The University of Texas at Austin publishes a generic
    checklist for Red Hat Enterprise 7, which you can adjust if you need to use it
    with CentOS 7, Oracle Linux 7, or Scientific Linux 7\. You might find that some
    checklist items don''t apply to your situation, and you can adjust them as required:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b39cd887-9904-46c2-837e-3112238c1106.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For specific business fields, you''ll need to get a checklist from the applicable
    regulatory body. If you work in the financial sector or with a business that accepts
    credit card payments, you''ll need a checklist from the Payment Card Industry
    Security Standards Council:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a43c0b90-2003-4f78-9896-4ad1c464a50a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And, for healthcare organizations here in the U.S., there''s HIPAA with its
    requirements. For publicly-traded companies here in the U.S., there''s Sarbanes-Oxley
    with its requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: You can get the University of Texas checklist from at: [https://wikis.utexas.edu/display/ISO/Operating+System+Hardening+Checklists](https://wikis.utexas.edu/display/ISO/Operating+System+Hardening+Checklists).
  prefs: []
  type: TYPE_NORMAL
- en: You can get a PCI-DSS checklist at: [https://www.pcisecuritystandards.org/](https://www.pcisecuritystandards.org/).
  prefs: []
  type: TYPE_NORMAL
- en: You can get a HIPAA checklist at: [https://www.hipaainstitute.com/security-checklist.](https://www.hipaainstitute.com/security-checklist)
  prefs: []
  type: TYPE_NORMAL
- en: And, you can get a Sarbanes-Oxley checklist at: [http://www.sarbanes-oxley-101.com/sarbanes-oxley-checklist.htm](http://www.sarbanes-oxley-101.com/sarbanes-oxley-checklist.htm).
  prefs: []
  type: TYPE_NORMAL
- en: Other regulatory bodies may also have their own checklists. If you know that
    you have to deal with any of them, be sure to get the appropriate checklist.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once again, we've come to the conclusion of another chapter, and we covered
    a lot of cool topics. We started by looking at various ways to audit which services
    are running on your systems, and we saw some examples of what you probably don't
    want to see. We then saw how to use the password-protection features of GRUB 2,
    and we saw the little quirks that we have to deal with when using those features.
    Next, we had a change of pace by looking at how to further lock down a system
    by properly setting up a system's BIOS/UEFI. Finally, we looked at why we need
    to properly begin preparations to set up a hardened system by obtaining and following
    the proper checklist.
  prefs: []
  type: TYPE_NORMAL
- en: Not only does this conclude another chapter, it also concludes the book. But,
    it doesn't conclude your journey into the land of *Mastering Linux Security and
    Hardening*. Oh, no. As you continue this journey, you'll find that there's still
    more to learn, and still more that won't fit into the confines of a 300-page book.
    Where you go from here mainly depends on the particular area of IT administration
    in which you work. Different types of Linux servers, whether they be web servers,
    DNS servers, or whatever else, have their own special security requirements, and
    you'll want to follow the learning path that best fits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: I've enjoyed the part of the journey on which I've been able to accompany you.
    I hope that you've enjoyed it as much as I have.
  prefs: []
  type: TYPE_NORMAL
