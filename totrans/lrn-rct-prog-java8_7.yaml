- en: Chapter 7. Testing Your RxJava Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While writing software, especially software which will be used by a lot of users,
    we need to be sure that everything is working correctly. We can write readable,
    well-structured, and modular code, which will make it easier for changing and
    maintaining. We should write tests because, with every feature, there is the danger
    of regression. When we already have tests for the existing code, refactoring it
    won't be as hard, because the tests could be run against the new, changed code.
  prefs: []
  type: TYPE_NORMAL
- en: Almost everything needs to be tested and automated. There are even ideologies
    such as **test-driven development** (**TDD**) and **behavior-driven development**
    (**BDD**). If we don't write automated tests, our ever-changing code tends to
    break over time and becomes even harder to test and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we won't be talking about why we need to test our code. We'll
    accept that this is mandatory and is part of our life as programmers. We'll learn
    how to test the code written using RxJava.
  prefs: []
  type: TYPE_NORMAL
- en: We will see that it is not so hard to write unit tests for it, but that there
    are some hard-to-test cases, such as *asynchronous* `Observable` instances, for
    example. We will learn about some new operators, which will help us in testing
    and a new kind of `Observable` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that said, here is what we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing `Observable` instances via the `BlockingObservable` class and *aggregating*
    operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `TestSubscriber` instance for in-depth testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TestScheduler` class and testing *asynchronous* `Observable` instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing using simple subscription
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can test what we get by simply subscribing to the *source* `Observable` instance
    and collecting all of the incoming notifications. In order to demonstrate that,
    we'll develop a `factory` method for creating a new `Observable` instance and
    will test its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The method will receive a `Comparator` instance and multiple items, and will
    return `Observable` instance, emitting these items as a sorted sequence. The items
    will be sorted according to the `Comparator` instance passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can develop the method using TDD. Let''s first define the test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The examples of this chapter use the **JUnit** framework for testing. You can
    find out more about this at [http://junit.org](http://junit.org).
  prefs: []
  type: TYPE_NORMAL
- en: The test uses two variables to store the predefined reusable state. The first
    one is the `Observable` instance we use as source—tested. In the setup `@Before`
    method, it is assigned to the result of our method `CreateObservable.sorted(Comparator,
    T...)`, which is not implemented yet. We compare a set of `String` instances and
    expect them to be received in the order they are stored in the *expected* variable—the
    second reusable field.
  prefs: []
  type: TYPE_NORMAL
- en: The test itself is quite verbose. It uses an instance of the `TestData` class
    to store the notifications incoming from the *tested* `Observable` instances.
  prefs: []
  type: TYPE_NORMAL
- en: If there is an `OnCompleted` notification, the `data.completed` field is set
    to `True`. We expect this to happen, and that's why we assert it at the end of
    the test method. If there is an `OnError` notification, the `data.error` field
    is set to the error. We don't expect that to happen, so we assert it to be `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Every incoming item emitted by the `Observable` instances is added to the `data.resultList`
    field. At the end, it should be equal to the *expected* `List` variable, and we
    assert that.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for the preceding test can be viewed/downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/test/java/com/packtpub/reactive/chapter07/SortedObservableTest.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/test/java/com/packtpub/reactive/chapter07/SortedObservableTest.java)—this
    is the first test method.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this test fails, of course, because the `CreateObservable.sorted(Comparator,
    T...)` method is not implemented yet. Let''s implement it and run the test again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It's that simple! It just turns the passed `varargs` array into a `List` variable
    and uses its `sort()` method to sort it with the passed `Comparator` instance.
    Then, using the `Observable.from(Iterable)` method, we return the desired `Observable`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The source code for the preceding implementation can be found at: [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/common/CreateObservable.java#L262](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/common/CreateObservable.java#L262).'
  prefs: []
  type: TYPE_NORMAL
- en: If we run the test now, it will pass. This is good! We've got our first test!
    But writing tests similar to this requires a lot of boilerplate code. We always
    need these three state variables and we always need to assert the same things.
    And what about *asynchronous* `Observable` instances, such as the ones created
    by `interval()` and `timer()` methods?
  prefs: []
  type: TYPE_NORMAL
- en: There are some techniques for removing the boilerplate variables, and later,
    we'll look at how to test *asynchronous* behavior as well. For now, we'll introduce
    one new type of observable.
  prefs: []
  type: TYPE_NORMAL
- en: The BlockingObservable class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every `Observable` instance can be turned into a `BlockingObservable` instance
    with the `toBlocking()` method. The `BlockingObservable` instance has multiple
    methods that block the current thread, while everything is emitted by the *source*
    `Observable` instance until an `OnCompleted` or `OnError` notification is sent.
    If there is an `OnError` notification, an exception will be thrown (`RuntimeException`
    exceptions are thrown directly and checked exceptions are wrapped inside the `RuntimeException`
    instances).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `toBlocking()` method doesn''t block by itself, but the methods of the
    `BlockingObservable` instance it returns may block. Let''s look at some of those
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can iterate over all the items in the `BlockingObservable` instance, using
    the `forEach()` method. Here is an example of using this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is also an example of how to make *asynchronous* code behave *synchronously*.
    The `Observable` instance created by the `interval()` method will not execute
    in the background, because the `toBlocking()` method makes the current thread
    wait until it finishes. That's why we use the `take(int)` method here because,
    otherwise, the *main* thread would be blocked forever. The `forEach()` method
    will print the five items using the passed function and only after that will we
    see the `END` output. The `BlockingObservable` class has a `toIterable()` method
    too. The `Iterable` instance returned by it can be used for iterating over the
    sequence emitted by the source as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are *blocking* methods similar to *asynchronous*, such as `first()`,
    `last()`, `firstOrDefault()`, and `lastOrDefault()` methods (we talked about them
    in [Chapter 4](ch04.html "Chapter 4. Transforming, Filtering, and Accumulating
    Your Data"), *Transforming, Filtering, and Accumulating Your Data*). All of them
    block while waiting for the required item. Let''s take a look at the following
    code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will print `'3'` and `'15'`.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting method is the `single()` method; it returns one item only when
    exactly one item is emitted by the *source* and the *source completes*. If there
    is no item emitted, or the *source* emits more than one item, a `NoSuchElementException`
    exception or an `IllegalArgumentException` exception is thrown, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is a `next()` method that doesn''t *block* and instead returns an `Iterable`
    instance. When an `Iterator` instance is retrieved from this `Iterable` instance,
    each of its `next()` methods will *block*, while awaiting the next incoming item.
    This can be used on infinite `Observable` instances because the *current thread*
    will *block* only while waiting for the *next* item and then it will be able to
    continue. (Note that if no one calls the `next()` method in time, source elements
    may be skipped). Here is an example of using this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The *current thread* will *block* three times for 100 milliseconds and `0`,
    `1`, and `2` will be printed after every pause. There is a similar method called
    `latest()`, which returns an `Iterable` instance. The behavior is different because
    the `Iterable` instance produced by the `latest()` method returns the very last
    items emitted by the source or waits for the next ones, if there aren't any.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will print `0` and then `5` and `6`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code demonstrating all the preceding operators as well as the aggregate
    ones can be viewed/downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter07/BlockingObservablesAndOperators.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter07/BlockingObservablesAndOperators.java).
  prefs: []
  type: TYPE_NORMAL
- en: Using the `BlockingObservable` instances can help us collect our test data.
    But there is a set of `Observable` operators called **aggregate operators**, which,
    when combined with the `BlockingObservables` instances, are useful too.
  prefs: []
  type: TYPE_NORMAL
- en: The aggregate operators and the BlockingObservable class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aggregate operators produce the `Observable` instances, which emit only one
    item and complete. This item is composed or is computed using all the items emitted
    by the *source* `Observable` instance. In this section, we'll talk about only
    two of them. For more detailed information, refer to [https://github.com/ReactiveX/RxJava/wiki/Mathematical-and-Aggregate-Operators](https://github.com/ReactiveX/RxJava/wiki/Mathematical-and-Aggregate-Operators).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first of these operators is the `count()` or `countLong()` method. It emits
    the number of the items emitted by the *source* `Observable` instance. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will print `100`.
  prefs: []
  type: TYPE_NORMAL
- en: The other one is the `toList()` or `toSortedList()` method, which emits a `list`
    variable (that can be sorted) containing all of the items emitted by the *source*
    `Observable` instance and completes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'All these methods, combined with the `toBlocking()` method, work well together.
    For example, if we want to retrieve the list of all the items emitted by the *source*
    `Observable` instance, we can do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can use this collection of items however we want: for example, for testing.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The aggregate operators include a `collect()` operator as well, which can be
    used for generating `Observable` instances and emitting arbitrary collections,
    say `Set()` operator, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with the aggregate operators and the BlockingObservable class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the operators and methods learned in the previous two sections, we are
    able to rework the test we''ve written to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There is no boilerplate code here. We retrieve all the items emitted as a list
    and compare them to the expected list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `BlockingObsevables` class and the aggregate operators is pretty
    useful in most cases. While testing *asynchronous* `Observable` instances, which
    emit long, slow sequences, they are not so useful though. It is not good practice
    to block the test cases for a long time: slow tests are bad tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for the preceding test can be found at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/test/java/com/packtpub/reactive/chapter07/SortedObservableTest.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/test/java/com/packtpub/reactive/chapter07/SortedObservableTest.java)—this
    is the second test method.
  prefs: []
  type: TYPE_NORMAL
- en: Another case in which this method of testing is not helpful is when we want
    to inspect the `Notification` objects sent by the *source* or the subscription
    state.
  prefs: []
  type: TYPE_NORMAL
- en: There is one other technique for writing tests that gives us more fine-grained
    control over the *subscription* itself, and this is via a special `Subscriber`—the
    `TestSubscriber`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the TestSubscriber class for in-depth testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `TestSubscriber` instance is a special `Subscriber` instance, which we can
    pass to the `subscribe()` method of any `Observable` instance.
  prefs: []
  type: TYPE_NORMAL
- en: We can retrieve all the received items and notifications from it. We can also
    look at the last `thread` on which the notifications have been received and the
    subscription state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite our test using it, in order to demonstrate its capabilities
    and what it stores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The test is, again, very simple. We create a `TestSubscriber` instance and
    *subscribe* to the *tested* `Observable` instance with it. And we have access
    to the whole state after the `Observable` instance is *completed*. Let''s take
    a look at the following term list:'
  prefs: []
  type: TYPE_NORMAL
- en: With the `getOnNextEvents()` method, we are able to retrieve all the items emitted
    by the `Observable` instance and compare them to the *expected* `List` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the `getOnCompletedEvents()` method, we are able to inspect the *OnCompleted*
    notification and to check if it was sent at all. For example, the `Observable.never()`
    method doesn't send it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the `getOnErrorEvents()` method, we are able to inspect *OnError* notifications
    if there were any. In this case, we *assert* that there were no *errors*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `isUnsubscribed()` method, we can *assert* that, after everything
    *completed*, our `Subscriber` instances were *unsubscribed*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `TestSubscriber` instance has some *assertion* methods too. So, there is
    one more way in which the test could be written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These are almost the same *assertions*, but done with the `TestSubscriber` instance's
    own `assert*` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for the preceding test can be found at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/test/java/com/packtpub/reactive/chapter07/SortedObservableTest.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/test/java/com/packtpub/reactive/chapter07/SortedObservableTest.java)—these
    are the third and the fourth test methods.
  prefs: []
  type: TYPE_NORMAL
- en: With these techniques, we can test different behaviors and states of our `RxJava`
    logic. There is one last thing left to learn in this chapter—testing *asynchronous*
    `Observable` instances, such as the ones created by the `Observable.interval()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Testing asynchronous Observable instances with the help of the TestScheduler
    class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one last type of predefined `scheduler` that we didn't mention in [Chapter
    6](ch06.html "Chapter 6. Using Concurrency and Parallelism with Schedulers"),
    *Using Concurrency and Parallelism with Schedulers*. This is the `TestScheduler`
    scheduler, a `scheduler` designed to be used in unit tests. All the actions scheduled
    on it are wrapped in objects containing the time they should be executed at, and
    won't be executed before the `triggerActions()` method of the `Scheduler` instance
    is called. This method executes all of the actions that are not executed and are
    scheduled to be executed at or before the `Scheduler` instance's present time.
    This time is virtual. This means that it is set by us and we can advance to any
    moment in the future using the special methods of this `scheduler`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to demonstrate it, we'll want to develop another method for creating
    a new type of `observable`. The implementation of the method itself won't be discussed
    in this chapter, but you can find it in the source code accompanying the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method creates an `Observable` instance emitting items at set time intervals.
    But the intervals are not equally spaced, such as with the built-in `interval`
    method. The idea is that we can provide a list of different multiple *intervals*
    and the `Observable` instance will cycle through it infinitely. The signature
    of the method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Its behavior should be the same as that of the `Observable.interval` method
    if we pass a `List` variable containing only one time period value. And here is
    the test for this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following explaination:'
  prefs: []
  type: TYPE_NORMAL
- en: We create the `TestScheduler` instance, using the `Schedulers.test()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our method receives a `Scheduler` instance as its third parameter. It will *emit
    items* on it, so we pass our `TestScheduler` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a `TestSubscriber` instance, we *subscribe* to the `Observable` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Immediately after subscribing, we shouldn't have any notifications, so we check
    that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `TestScheduler` instance has an `advanceTimeBy(long, TimeUnit)` method,
    which controls the time of its `Worker` instances, so we can use it to get 101
    milliseconds into the future. After 101 milliseconds, we expect to have received
    one item—`0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `advanceTimeBy()` method, we advance 101 more milliseconds into the
    future, and we should have received `0` and `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The other important method of the `TestScheduler` instance is the `advanceTimeTo(long,
    TimeUnit)` method. It can be used to advance to a specific time point in the future.
    So we use it to get to the moment when exactly one second from the *subscription*
    has passed. We expect to have received ten notifications by that time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `TestScheduler` instance controls the time using its `advanceTimeBy()`and
    `advanceTimeTo()` methods, so we don't need to *block* the *main* `Thread` instance
    waiting for something to happen. We can just go to the time it has already happened.
    With the `TestScheduler` instance, there is a global order of events. So, if two
    tasks are scheduled for the exact same time, they have an order in which they
    will execute and can cause problems with the test that expect a specific global
    order. If we have such an operator to test, we should avoid this by timing to
    different values—one to 100 ms and the other to 101 ms. Using this technique,
    testing *asynchronous* `Observable` instances is not such a complex task anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The source code for the preceding test can be found at: [https://github.com/meddle0x53/learning-rxjava/blob/master/src/test/java/com/packtpub/reactive/chapter07/CreateObservableIntervalTest.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/test/java/com/packtpub/reactive/chapter07/CreateObservableIntervalTest.java).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this chapter, not only did we find out how to write programs using RxJava,
    but we also saw how to test any aspect of them. We've learned about a few new
    operators and the `BlockingObservables` class too.
  prefs: []
  type: TYPE_NORMAL
- en: The RxJava library has many operators that are not mentioned in this book, but
    we've studied the more important and useful ones. You can always refer to [https://github.com/ReactiveX/RxJava/wiki](https://github.com/ReactiveX/RxJava/wiki)
    for the rest. There is also much more regarding *subscriptions*, *backpressure*,
    and the `Observable` instance *life cycle*, but with your current knowledge, it
    won't be hard to master everything in the library. Remember that this is just
    a library, a tool to write code. The logic is the important thing here. This way
    of programming is somewhat different from the procedural one, but once you get
    into it, it feels natural.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, we will learn how to free resources allocated
    by *subscriptions*, how to prevent memory leaks, and how to create our own operators
    that can be chained in the `RxJava` logic.
  prefs: []
  type: TYPE_NORMAL
