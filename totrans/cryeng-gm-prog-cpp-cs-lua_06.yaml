- en: Chapter 6. Artificial Intelligence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CryENGINE AI system allows the creation of non-player controlled actors
    that roam the game world.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn how the AI system integrates with Lua scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover what goal pipes are, and how to create them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use AI signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register a custom AI `Actor` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use behavior selection trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create our own AI behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Artificial Intelligence (AI) system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CryENGINE AI system was designed to allow easy creation of custom AI actors
    flexible enough to handle a larger set of complex and different worlds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start looking into the native implementation of the AI system, we
    have to mention one very important fact: AI is not the same as an actor, and should
    never be confused as such.'
  prefs: []
  type: TYPE_NORMAL
- en: In CryENGINE, AI still relies on an underlying actor implementation, commonly
    the exact same one as used by players. However, the implementation of the AI itself
    is done separately via the AI system, which in turn sends movemAent input, and
    so on to the actor.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main idea of CryENGINE's AI system is based on lots and lots of scripting.
    Instead of forcing programmers into modifying the complex CryAISystem module,
    it's possible to create new AI behaviors using Lua scripts contained in the `Scripts/AI`
    and `Scripts/Entities/AI` directories.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The AI system is currently largely hardcoded to usage of the `.lua` scripts,
    therefore we will not be able to use C# and C++ to any larger extent for AI development.
  prefs: []
  type: TYPE_NORMAL
- en: AI actors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned previously, actors are separate from the AI itself. Essentially
    what this means is that we'll need to create an `IActor` implementation, and then
    specify which AI behavior the actor should use.
  prefs: []
  type: TYPE_NORMAL
- en: If your AI actors should behave roughly the same as your player, you should
    reuse the actor implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'As covered in the previous chapter, registering an actor can be done with the
    `REGISTER_FACTORY` macro. The only difference for AI actors is that the last parameters
    should be set to true instead of false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once registered, the AI system will search for a Lua script named after your
    entity in `Scripts/Entities/AI`. In the case of the previous snippet, the system
    would attempt to load `Scripts/Entities/AI/MyAIActor.lua`.
  prefs: []
  type: TYPE_NORMAL
- en: This script should contain a table of the same name, and functions the same
    as other Lua entities. For example, to add Editor properties, simply add variables
    inside a Properties subtable.
  prefs: []
  type: TYPE_NORMAL
- en: Goal pipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Goal pipes define a collection of goal operations, allowing a set of goals to
    be triggered at runtime. For example, a goal pipe could entail the AI, increasing
    its movement speed while simultaneously beginning the search of player-controlled
    units.
  prefs: []
  type: TYPE_NORMAL
- en: Goal operations, such as LookAt, Locate, and Hide are created in `CryAISystem.dll`
    and cannot be modified without access to its source.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom pipes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Pipes are initially registered inside the `PipeManager:CreateGoalPipes` function
    in `Scripts/AI/GoalPipes/PipeManager.lua`, using the `AI.LoadGoalPipes` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet will load `Scripts/AI/GoalPipes/MyGoalPipes.xml`, which could
    contain the following goal pipe definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When this pipe is selected, the assigned AI will start locating the player,
    switch to the `Run` movement speed state, and call the `AnalyzeSituation` function
    contained in the currently selected behavior script.
  prefs: []
  type: TYPE_NORMAL
- en: Goal pipes can be very effective for pushing a set of goals easily, as an example
    based on the previous script, we could simply select the `myGoalPipes_findPlayer`
    pipe in order to have the AI run looking for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting pipes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Goal pipes are typically triggered using the entity function `SelectPipe` in
    Lua:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Or can otherwise be triggered via C++, using the `IPipeUser::SelectPipe` function.
  prefs: []
  type: TYPE_NORMAL
- en: Signals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to provide AI entities with an intuitive way of communicating with
    each other, we can use the signal system. Signals are events that can be sent
    to a specific AI unit from either another AI entity, or from another place in
    C++ or Lua code.
  prefs: []
  type: TYPE_NORMAL
- en: Signals can be sent using the `AI.Signal` function in Lua, or `IAISystem::SendSignal`
    in C++.
  prefs: []
  type: TYPE_NORMAL
- en: AI behaviors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Behaviors need to be assigned to each actor, and they define the decision making
    capabilities of the unit. By selecting behaviors at runtime using **behavior selection
    trees**, actors can give the impression of dynamically adjusting to their surroundings.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior selection trees are created using XML files placed in `Scripts/AI/SelectionTrees`.
    Each tree manages a set of **behavior leaves** , each leaf representing a type
    of AI behavior that can be enabled based on conditions.
  prefs: []
  type: TYPE_NORMAL
- en: '![AI behaviors](img/5909_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sample
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For example, see a very basic form of a selection tree XML definition as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To allow for a better understanding of the sample, we''ll break it down a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This first snippet simply defines the name of the selection tree, and will
    be parsed by the AI system during AI initialization. If you want to rename your
    tree, simply change the `name` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Each selection tree can define a set of variables that can be set either based
    on signals (see the next snippet), or inside each behavior script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are simply Boolean conditions that can be queried in order to determine
    which leaf or behavior to select next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Each behavior tree can also listen to signals such as `OnEnemySeen`, in order
    to set the value of variables easily. For example, in the snippet that we just
    saw, the `IsEnemyClose` variable will always be set to true when the enemy has
    been spotted, and then set to false when the target is lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use the variable when querying for new leaves (see the following
    code snippet), allowing the AI to switch to different behavior scripts based on
    simple signal events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: By specifying leaves inside the `Priority` elements, we can enable behaviors
    (leaves) at runtime based on simple conditions.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, the previous snippet will enable the `BehaviorSampleCombat` behavior
    script when an enemy is close, otherwise it will fall back to the `BehaviorSampleIdle`
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The behavior selection tree system will query leaves in order, and fall back
    to the last remaining leaf. In this case, it will query `BehaviorSampleCombat`
    first, and then fall back to `BehaviorSampleIdle` if the `IsEnemyClose` variable
    is set to false.
  prefs: []
  type: TYPE_NORMAL
- en: IAIObject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Entities that have been registered with the AI system can call `IEntity::GetAI`
    to obtain their `IAIObject` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'By accessing the pointer to an entity''s AI object, we can manipulate the AI
    at runtime, for example, to set custom signals that we later intercept in our
    AI behavior scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Creating custom AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of creating custom AI is relatively straightforward, especially
    if you're comfortable with the actor system introduced in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There are two parts of each actor; its `IActor` implementation and the AI entity
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: Registering an AI actor implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AI actors typically use the same `IActor` implementation as the player, or at
    least a shared derivation.
  prefs: []
  type: TYPE_NORMAL
- en: In C#
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Registering an AI actor in C# is very similar to how we did it in [Chapter 5](ch05.html
    "Chapter 5. Creating Custom Actors"), *Creating Custom Actors*. Essentially, all
    we have to do is derive from `CryEngine.AIActor` instead of `CryEngine.Actor`.
  prefs: []
  type: TYPE_NORMAL
- en: The `AIActor` class derives directly from `Actor`, and therefore does not sacrifice
    any of its callbacks and members. However, it has to be explicitly implemented
    in order to make CryENGINE treat this actor as if it is controlled by AI.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now be able to place your entity from the **AI** category in the
    **Entity** browser, within Sandbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![In C#](img/5909_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In C++
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with the C# actor that we just saw, registering an actor with the AI system
    is not much work. Simply derive from the actor implementation we created in the
    previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then open your GameDLL''s `GameFactory.cpp` file and use the same setup for
    registering the actor, except the last parameter should be true to tell CryENGINE
    that this actor type will be controlled by AI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Your actor should now be present in the **AI** entity category in the **Entity**
    browser, following a recompilation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the AI entity definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When our AI actor is spawned, the AI system will search for an AI entity definition.
    The definitions exist to set default properties of an actor, for example, its
    Editor properties.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is open `Scripts/Entities/AI` and create a new
    `.lua` file with the same name as our `Actor` class. In our case, this will be
    `MyAIActor.lua` for the C++ implementation that we just created, and `MyCSharpAIActor.lua`
    for the C# actor.
  prefs: []
  type: TYPE_NORMAL
- en: The script is kept at a bare minimum of code, as we only need to load the base
    AI. The base AI is loaded using the `Script.ReloadScript` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, CryENGINE uses `Scripts/Entities/AI/Shared/BasicAI.lua` as the
    base AI definition. We will use a custom implementation, `Scripts/Entities/AI/AISample_x.lua`
    in order to cut down on unnecessary code that is irrelevant to this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Your AI is now properly registered, and should now be placeable via
    the Editor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the base AI definition, see the *AI base definition
    breakdown* section later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: AI behaviors and characters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we spawn our custom AI actor, four entity properties should appear by default.
    These determine which systems the AI should use for decision making:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AI behaviors and characters](img/5909_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Understanding and using behavior selection trees
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The behavior selection tree is the most important entity property for our AI
    actor, as it determines which behavior selection tree to use for the actor. If
    our project contains multiple behavior selection trees, we can easily spawn multiple
    AI actors that behave very differently due to the separate selection trees. The
    selection tree system exists in order to provide a way to query and select behavior
    scripts at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see which trees are currently available, or to create your own, navigate
    to `Scripts/AI/SelectionTrees`. For our sample, we''ll be using the `FogOfWar`
    selection tree present in `Scripts/AI/SelectionTrees/FogOfWar.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each selection tree exposes a set of variables that can be set at runtime. The
    variables will be queried by leaves in order to determine which behavior to activate.
  prefs: []
  type: TYPE_NORMAL
- en: Signal variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Signal variables provide a simple way to set variables when signals are received.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the previous tree, we can see that `AwareOfPlayer` is dynamically
    set when the `OnEnemySeen` signal is received. The variables are then set to false
    when the AI loses track of the player.
  prefs: []
  type: TYPE_NORMAL
- en: Leaves / behavior queries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The leaves determine which behavior to play, based on a variable condition.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous tree, we can see that the `FogOfWarIdleST` behavior is activated
    by default when all other conditions are set to false. However, say that the `IsFar`
    variable is set to true, the system will automatically switch to the `FogOfWarSeekST`
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Behaviors are loaded from the `Scripts/AI/Behaviors/Personalities/` directory,
    in our case, it'll find reference behaviors inside `Scripts/AI/Behaviors/Personalities/FogOfWarST/`.
  prefs: []
  type: TYPE_NORMAL
- en: Character
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Character` property is used to set the AI character for our actor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our sample, the `Character` property will default to an empty string, as
    the system is considered deprecated since the introduction of behavior selection
    trees (Have a look at the *Understanding and using behavior selection trees* section).
  prefs: []
  type: TYPE_NORMAL
- en: AI characters are contained in `Scripts/AI/Characters/Personalities` as the
    `.lua` scripts. For example, we could open and modify `Scripts/AI/Characters/Personalities/FogOfWar.lua`
    in order to modify our default personality.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create new personalities simply by adding a new file in the `Personalities`
    directory, using `FogOfWar` as a baseline.
  prefs: []
  type: TYPE_NORMAL
- en: The `Character` property defines all applicable behaviors, in our case `FogOfWarAttack`,
    `FogOfWarSeek`, `FogOfWarEscape`, and `FogOfWarIdle`. The actor will be able to
    switch between these behaviors at runtime, based on internal and external conditions.
  prefs: []
  type: TYPE_NORMAL
- en: NavigationType
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `NavigationType` property determines which type of AI navigation to use.
    This allows the system to dynamically determine which paths are viable for the
    type of AI.
  prefs: []
  type: TYPE_NORMAL
- en: This defaults to MediumSizedCharacter in our sample, and can be set to any navigation
    definition contained in `Scripts/AI/Navigation.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom behaviors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're almost done! The only step that remains is understanding how to create
    and modify AI behaviors, activated using the behavior selection tree we described
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: To start, open `Scripts/AI/Behaviors/Personalities/FogOfWarST/FogOfWarIdleST.lua`
    with the text editor of your choice. Due to the behavior tree setup described
    earlier, this is the behavior that will be activated when all other variables
    are set to false.
  prefs: []
  type: TYPE_NORMAL
- en: Behaviors are created by calling the `CreateAIBehavior` function, with the first
    parameter set to the name of the new behavior, and the second containing the behavior
    itself in a table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the bare minimum for a behavior would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet would set `Alertness` of the AI to 0 at all times, and does
    absolutely nothing when the behavior starts (`Constructor`) and ends (`Destructor`).
  prefs: []
  type: TYPE_NORMAL
- en: 'By looking at the `FogOfWarIdleST` behavior definition, we can see what it
    does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When the behavior is activated, we should see `Idling…` in the console, assuming
    that the log verbosity is set high enough (set using `log_verbosity CVar`).
  prefs: []
  type: TYPE_NORMAL
- en: After logging, the behavior will reset the `AwareOfPlayer` variable to false
    via the `AI.SetBehaviorVariable` function. We can use the function at any time
    to change the value of variables, effectively telling the behavior selection tree
    that another behavior should be queried.
  prefs: []
  type: TYPE_NORMAL
- en: After setting the variable to false, the constructor selects the `fow_idle_st`
    goal pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Listening to signals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To listen to signals in behaviors, simply create a new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will then be called when the `OnMySignal` signal is sent, along with the
    associated entity and behavior table.
  prefs: []
  type: TYPE_NORMAL
- en: AI base definition breakdown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously in the chapter, we created our own AI definition that relied on the
    `Scripts/Entities/AI/AISample_x.lua` base definition. This section will describe
    what the base definition does, in order to allow for a better understanding of
    the definition setup.
  prefs: []
  type: TYPE_NORMAL
- en: To start, open the definition with the text editor of your choice, for example,
    Notepad++.
  prefs: []
  type: TYPE_NORMAL
- en: The AISample_x table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first lines of code we'll see when opening `AISample_x.lua` are its table
    definition, which defines each characters' default properties.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each AI definition can override properties set in the base definition.
  prefs: []
  type: TYPE_NORMAL
- en: The Properties table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Properties table works as it does with the standard Lua entities, to define
    properties that appear when the entity is selected in the Editor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default properties in our base AI definition are read from `CryAISystem.dll`.
    Removal of these properties is not supported, and will result in AI initialization
    failure.
  prefs: []
  type: TYPE_NORMAL
- en: The AIMovementAbility table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `AIMovementAbility` subtable defines the movement capabilities of our actor,
    for example, walk and run speed.
  prefs: []
  type: TYPE_NORMAL
- en: The CreateAI function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `CreateAI` function merges the base AI table with that of the specified
    child. This means that any table present in the AI base definition will be present
    in any AI definition that derives from it.
  prefs: []
  type: TYPE_NORMAL
- en: The `CreateAI` function also makes the entity spawnable, and exposes it to the
    network by calling the AI's `Expose()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The RegisterAI function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `RegisterAI` function is called when the actor should be registered with
    the AI system. This is called automatically on entity spawn and on editor property
    change.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the core idea and implementation of the
    AI system and have created a custom AI actor implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Having created our own AI entity definition, and behavior selection trees, you
    should be aware of how AI actors are created in the CryENGINE.
  prefs: []
  type: TYPE_NORMAL
- en: You should now have a good understanding of how to use the AI system to your
    advantage, allowing you to create AI-controlled units that patrol your game world.
  prefs: []
  type: TYPE_NORMAL
- en: If you're not quite done with AI, why not try and use your newly gained knowledge
    to create something a bit more complex of your own choice?
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be covering the process of creating custom user interfaces
    allowing the creation of main menus and **Heads-up Display** (**HUD**).
  prefs: []
  type: TYPE_NORMAL
