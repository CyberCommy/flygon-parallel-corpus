- en: Chapter 3. Using Templates in Our Headlines Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last chapter, we saw one way of combining static HTML with dynamic content
    for creating a web page. But it''s messy, and we don''t want to hack away at Python
    strings for building our web pages. Mixing HTML and Python is not ideal for a
    few reasons: for one, it means if we ever want to change static text, such as
    that which appears in our headings, we have to edit our Python files, which also
    involves reloading these files into Apache. If we hire frontend developers to
    work on HTML, we run the risk of them breaking the unfamiliar Python code by mistake,
    and it''s far more difficult to structure any other frontend code such as JavaScript
    and CSS correctly. Ideally, we should aim for complete segregation between the
    frontend and backend components. We can achieve this to a large extent using Jinja,
    but as with most aspects of life, some compromise will be necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, we''ll have extended our application to display
    more than a single headline for the chosen publication. We''ll display several
    articles for each publication, each one having a link to the original article,
    and our logic and view components will largely be separated. In this chapter,
    we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Jinja
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic use of Jinja templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced use of Jinja templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Jinja
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jinja is a Python template engine. It allows us to easily define dynamic blocks
    of HTML which are populated by Python. HTML templates are useful even for static
    websites which have multiple pages. Usually, there are some common elements, such
    as headers and footers, on every page. Although it is possible to maintain each
    page individually for static websites, this requires that a single change be made
    in multiple places if the change is made to a shared section. Flask was built
    on top of Jinja, so although it is possible to use Jinja without Flask, Jinja
    is still an inherent part of Flask, and Flask provides several methods to work
    directly with Jinja. Generally, Flask assumes nothing about the structure of your
    application except what you tell it, and prefers providing functionality through
    optional plugins. Jinja is somewhat of an exception to this. Flask gives you Jinja
    by default, and assumes that you store all your Jinja templates in a subdirectory
    of your application named `templates`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've created templates, we'll make calls from our Flask app to render
    these templates. Rendering involves parsing the Jinja code, inserting any dynamic
    data, and creating pure HTML to be returned to a user's browser. All of this is
    done behind the scenes though, so it can get a bit confusing as to what is being
    done where. We'll take things one step at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Basic use of Jinja templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step to using Jinja templates is creating a directory in our application
    to contain our template files, so navigate to your `headlines` directory, and
    create a directory called `templates`. Unlike the previous steps, this name is
    expected by other parts of the application and is case sensitive, so take care
    while creating it. At the most basic level, a Jinja template can just be an HTML
    file, and we'll use the `.html` extension for all our Jinja templates. Create
    a new file in the `templates` directory called `home.html`. This will be the page
    that our users see when visiting our application, and will contain all the HTML
    that we previously had in a Python string.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll only be using Jinja to build HTML files in this book, but Jinja is flexible
    enough for use in generating any text-based format. Although we use the `.html`
    extension for our Jinja templates, the files themselves will not always be pure
    HTML.
  prefs: []
  type: TYPE_NORMAL
- en: For now, put the following static HTML code into this file. We'll look at how
    to pass dynamic data between Python and our templates in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in our Python code, instead of building up the string and returning that
    in our routing function, we''ll render this template and return it. In `headlines.py`,
    add an import at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `render_template` function is the magic which takes a Jinja template as
    input and produces pure HTML, capable of being read by any browser, as the output.
    For now, some of the magic is lost, as we'll give it pure HTML as input and view
    the same as output in our browser.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a basic template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In your `get_news()` function, remove the `return` statement, which contains
    our triple-quoted HTML string as well. Leave the previous lines which grab the
    data from `feedparser`, as we'll be using that again soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `return` statement, so that the `get_news()` function now looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Although our current HTML file is pure HTML and not yet using any of the Jinja
    syntax that we'll see later, we're actually already doing quite a bit of magic.
    This call looks in our `templates` directory for a file named `home.html`, reads
    this, parses any Jinja logic, and creates an HTML string to return to the user.
    Once you've made both the preceding changes, run your application again with `python
    headlines.py`, and navigate to `localhost:5000` in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we''ve gone a step backwards in order to advance. If you run the app
    and view the result in your browser now, you should see something similar to our
    original page, except that instead of the real news data, you''ll just see the
    strings **title**, **published**, and **summary** as seen in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering a basic template](img/B04312_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at how to populate these fields inside our `render_template`
    call so that we can see real news content again.
  prefs: []
  type: TYPE_NORMAL
- en: Passing dynamic data to our template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, in our Python file, we''ll pass each of these as named variables. Update
    the `get_news()` function again, and pass all the data that you need to display
    to the user as arguments to `render_template()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `render_template` function takes the filename of the template as its first
    argument, and can then take an arbitrary number of named variables as subsequent
    arguments. The data in each of these variables will be available to the template,
    using the variable name.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying dynamic data in our template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our `home.html` file, we simply need to put two braces on either side of
    our placeholders. Change it to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Double braces, {{ }}, indicate to Jinja that anything inside them should not
    be taken as literal HTML code. Because our *placeholders*, *title*, *published*,
    and *summary*, are the same as our Python variable names passed into the `render_template`
    call, just adding the surrounding braces means that the `render_template` call
    will substitute these for the real data, returning a pure HTML page. Try it out
    to make sure that we can see real news data again, as seen in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying dynamic data in our template](img/B04312_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Advanced use of Jinja templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have perfect separation of our backend and frontend components, but our
    application doesn't do anything more than it did before. Let's take a look at
    how to display multiple news articles from a selected publication. We don't want
    to add three new arguments to our `render_template` call for each article (or
    dozens of additional arguments if we ever decide that we want to display more
    than just the title, date, and summary of an article).
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Jinja can take over some of the logic from Python. This is where
    we have to be careful: we spent all that effort to separate our logic and view
    components, and when we discover how powerful the Jinja language actually is,
    it''s tempting to move a lot of the logic into our template files. This would
    leave us back where we started with code that is difficult to maintain. However,
    in some cases it''s necessary for our frontend code to handle some logic, such
    as now where we don''t want to pollute our backend code with too many repeated
    arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Jinja objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing to learn is how Jinja handles objects. All of the basic Python
    data structures, such as variables, objects, lists, and dictionaries, can be understood
    by Jinja and can be processed in a very similar way to what we are used to in
    Python. For example, instead of passing each of the three components of our article
    separately to our template, we could have passed in the `first_article` object
    and dealt with the separation in Jinja. Let's see how to do that. Change the Python
    code to pass in a single-named argument to `render_template`, that is `first_article`,
    and the frontend code to grab the bits we need from this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `render_template` call should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The template now has a reference called `article`, which we can use to get
    the same result as before. Change the relevant part of the home.html to read as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that accessing items from a dictionary is slightly different in Jinja as
    compared to Python. We use a full stop to access properties, so to access the
    title of the article, we use `{{article.title}}` as in the preceding example,
    instead of the Python equivalent `article["title"]` or `article.get("title")`.
    Our code is again neater, but yet again has no additional functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Adding looping logic to our template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Without much extra effort, we can make the whole list of articles available
    to Jinja. In the Python code, change the `render_template` call to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can remove the line directly above the preceding one in the code which defines
    the `first_article` variable, as we won't need it any more. Our template now has
    access to the full list of articles that we fetch through `feedparser`.
  prefs: []
  type: TYPE_NORMAL
- en: In our Jinja template, we could now `add {{articles}}` or `{{articles[0]}}`
    to see a full dump of all the information we're now passing, or just a dump of
    the first article respectively. You can try this as an intermediate step if you're
    curious, but in our next step we'll be looping through all the articles and displaying
    the information we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'By giving our template more data to work with, we''re passing along some of
    the logic responsibility that should ideally be handled by our Python code, but
    we can also deal with this very cleanly in Jinja. Similar to the way we use double
    braces, `{{` `}}`, to indicate variables, we use the brace and percentage combination,
    `{% %}`, to indicate control logic. This will be clearer by looking at an example.
    Change the `<body>` part of the template code to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the Jinja for loop is similar to Python. It loops through the
    *articles* list that we've passed in from the Python code, and creates a new variable,
    `article`, for each iteration of the loop, each time referring to the next item
    in the list. The `article` variable can then be used like any other Jinja variable
    (using the double braces). Because whitespace in Jinja is irrelevant, unlike Python,
    we must define where our loop ends with the `{% endfor %}` line. Finally, the
    `<hr />` in HTML creates a horizontal line which acts as a separator between each
    article.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application locally with the new template file, and view the results
    in your browser. You should see something similar to the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding looping logic to our template](img/B04312_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding hyperlinks to our template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we want to link each headline to the original article. Our user will probably
    find this useful—if a headline seems interesting, he or she can easily get to
    the full text of the article to read it. The owner of the RSS feed will also often
    require or request that anyone who uses the feed links back to the original articles.
    (Again, check for terms and conditions as published along with most big feeds.)
    Because we're passing the whole `article` object to our template already, we won't
    need to make any further changes to our Python code to achieve this; we simply
    need to make use of the extra data already available to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the template file, search for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Change this line to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re new to HTML, then there''s quite a bit going on here. Let''s pull
    it apart: the `<a>` tag in HTML indicates a hyperlink (usually displayed by default
    as blue and underlined in most browsers), the `href` attribute specifies the destination
    or URL of the link, and the link ends with the `</a>` tag. That is, any text between
    `<a>` and `</a>` will be clickable, and will be displayed differently by our user''s
    browser. Note that we can use the double braces to indicate a variable even within
    the double quotation marks used to define the destination attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: If you refresh the page in your browser, you should now see the headlines as
    bold links, as in the following image, and clicking on one of the links should
    take you to the original article.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding hyperlinks to our template](img/B04312_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pushing our code to the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now is a good time to push the code to our VPS. This is the last time we''ll
    break down the steps of how to do this, but hopefully, you''d be familiar enough
    with Git and Apache by now that there won''t be anything unexpected. On your local
    machine, from the `headlines` directory, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And on your VPS (SSH into it as usual), change to the appropriate directory,
    pull the updates from the Git repository, and restart Apache to reload the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure everything has worked by visiting the IP address of your VPS from
    the web browser on your local machine and checking that you see the same output
    that we saw locally, as seen in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pushing our code to the server](img/B04312_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a basic news summary site! You can display recent news from a number
    of different websites, see the headline, date, and summary for each recent article,
    and can click on any headline to visit the original article. You've only seen
    a tiny sample of the power of the Jinja language though—as we expand this project
    and other projects in future chapters, you'll see how it can be used for inheritance,
    conditional statements, and more.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll add weather and currency information to our application,
    and look at ways to interact with our users.
  prefs: []
  type: TYPE_NORMAL
