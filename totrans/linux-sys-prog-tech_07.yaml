- en: '*Chapter 7*: Using systemd to Handle Your Daemons'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to build our own daemons, it's time to see how we can get
    Linux to handle them using **systemd**. In this chapter, we will learn what systemd
    is, how to start and stop services, what unit files are, and how to create them.
    We will also learn how daemons are logged to systemd and how we read those logs.
  prefs: []
  type: TYPE_NORMAL
- en: We will then learn about different kinds of services and daemons that systemd
    can handle and put the daemon from the previous chapter under systemd control.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know systemd
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a unit file for a daemon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling and disabling a service—and starting and stopping it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a more modern daemon for systemd
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the new daemon a systemd service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the journal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, you'll need a computer with a Linux distribution that uses
    systemd—which, today, is pretty much every distribution, with some rare exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also need the GCC compiler and the Make tool. Installation instructions
    for these tools are covered in [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020),
    *Getting the Necessary Tools and Writing Our First Linux Programs*. You'll also
    need the generic Makefile for this chapter, which is found in this chapter's repository
    on GitHub, along with all the code samples for this chapter. The URL for this
    chapter's repository folder on GitHub is [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch7](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch7).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3cxmXab](https://bit.ly/3cxmXab)'
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know systemd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll explore what systemd is, how it handles the system, and
    all of the system's services.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, Linux has been managed with several smaller pieces. For example,
    `init` was the first process on the system, which started other processes and
    daemons to bring up the system. System daemons were handled by shell scripts,
    also called *init scripts*. Logging was done either by the daemon itself via files
    or `syslog`. Networking was also handled by multiple scripts (and still is in
    some Linux distributions).
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, though, the entire system is handled by systemd. For example, the
    first process on the system is now `systemd` (which we have seen in previous chapters).
    Daemons are handled by something called *unit files*, which create a unified way
    of controlling daemons on the system. Logging is handled by **journald**, systemd's
    logging daemon. But do note that **syslog** is still used by many daemons to do
    extra logging. Later in this chapter, in the *Making the new daemon a systemd
    service* section, we'll re-write the daemon from [*Chapter 6*](B13043_06_Final_SK_ePub.xhtml#_idTextAnchor245),
    *Spawning Processes and Using Job Control*, to log to the journal.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how systemd works will enable you to use it properly when, for example,
    writing unit files for daemons. It will also help you to write daemons in the
    "new" way, to make use of systemd's logging features. You will become a better
    system administrator as well as a better Linux developer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll only need a Linux distribution that uses systemd, which
    most distributions do today.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll take a look at some of the components involved in systemd.
    This will give us a bird''s eyes view of systemd, journald, its commands, and
    **unit files**. All the details will come in later recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by typing `systemctl` in a console window and hit *Enter*. This will show
    you all active *units* on your machine right now. If you skim through the list,
    you'll notice that a unit can be just about anything—hard drives, sound cards,
    mounted network drives, miscellaneous services, timers, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the services we saw in the previous step reside as unit files in `/lib/systemd/system`
    or `/etc/systemd/system`. Navigate to those directories and look around at the
    files. These are all typical unit files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now it's time to take a look at the journal, the log of systemd. We need to
    run this command as `sudo journalctl`, or switch to root first with `su`, and
    then type `journalctl`. This will show you the entire log of systemd and all of
    its services. Hit *Spacebar* several times to scroll down in the log. To go to
    the end of the log, type a capital *G* while the log is displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These three steps give us an overview of systemd. In the coming recipes, we'll
    cover the details in much more depth.
  prefs: []
  type: TYPE_NORMAL
- en: Installed packages place their unit files in `/lib/systemd/system` if it's a
    Debian/Ubuntu system, and in `/usr/lib/systemd/system` if it's a CentOS/Fedora
    system. On CentOS/Fedora, though, `/lib` is a symbolic link to `/usr/lib`, so
    `/lib/systemd/system` is universal.
  prefs: []
  type: TYPE_NORMAL
- en: So-called *local* unit files are placed in `/etc/systemd/system`. Local unit
    files mean unit files specific to this system, for example, modified by the administrator
    or manually added for some program.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There have been other init systems for Linux before systemd. We have already
    mentioned the first one briefly, `init`. That init system, `init`, is often called
    *Sys-V-style init*, from UNIX version five (V).
  prefs: []
  type: TYPE_NORMAL
- en: After the Sys-V-style init came Upstart, a full replacement for `init` developed
    by Ubuntu. Upstart was also used by CentOS 6 and Red Hat Enterprise Linux 6.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, though, most major Linux distributions use systemd. Since systemd
    is a huge part of Linux, this makes all the distributions pretty much alike. Fifteen
    years ago, it wasn't easy to jump from one distribution to another one. Nowadays,
    it's much easier.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are multiple manual pages on the system we can read to understand systemd,
    its commands, and the journal at a deeper level:'
  prefs: []
  type: TYPE_NORMAL
- en: '`man systemd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man systemctl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man journalctl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man systemd.unit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a unit file for a daemon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will take the daemon we wrote in [*Chapter 6*](B13043_06_Final_SK_ePub.xhtml#_idTextAnchor245),
    *Spawning Processes and Using Job Control*, and make it a service under systemd.
    This daemon is what systemd calls a *forking daemon* because it does just that.
    It forks. This is traditionally how daemons have worked, and they are still widely
    used. Later in this chapter, in the *Making the new daemon a systemd service*
    section, we will modify it slightly to log to systemd's journal. But first things
    first, let's make our existing daemon into a service.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you'll need the file `my-daemon-v2.c` that we wrote in [*Chapter
    6*](B13043_06_Final_SK_ePub.xhtml#_idTextAnchor245), *Spawning Processes and Using
    Job Control*. If you don't have that file, there is a copy of it in this chapter's
    directory on GitHub at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch7/my-daemon-v2.c](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch7/my-daemon-v2.c).
  prefs: []
  type: TYPE_NORMAL
- en: Apart from `my-daemon-v2.c`, you'll need the GCC compiler, the Make tool, and
    the generic Makefile covered in the *Technical requirements* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here we will put our daemon under systemd''s control:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t compiled `my-daemon-v2` yet, we''ll need to begin with that.
    Compile it like any other program we have made so far:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For this to be a system daemon, we should place it in one of the directories
    for that purpose. A good place for this is `/usr/local/sbin`. The `/usr/local
    directory` is where we usually want to place things that we have added to the
    system ourselves, that is, third-party stuff. The `sbin` subdirectory is for system
    binaries or super-user binaries (hence the *s* before *bin*). To move our daemon
    here, we need to be root:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now comes the exciting stuff, writing the *unit file* for the daemon. Create
    the file `/etc/systemd/system/my-daemon.service` as root. Use either `sudo` or
    `su` to become root. Write the content shown below in the file and save it. The
    unit file is divided into several sections. In this file, the sections are `[Unit]`,
    `[Service]`, and `[Install]`. The `[Unit]` section contains information about
    the unit, such as the description in our case. The `[Service]` section contains
    information about how this service should work and behave. Here, we have `ExecStart`,
    which contains the path to the daemon. We also have `Restart=on-failure`. This
    tells systemd to restart the daemon if it should crash. Then we have the `Type`
    directive, which in our case is forking. Remember that our daemon creates a fork
    of itself and the parent process exits. This is what the type *forking* means.
    We tell systemd the type so it knows how it should handle the daemon. Then we
    have `PIDFile`, which contains the path to our `WantedBy` set to `multi-user.target`.
    What this means is that this daemon should start when the system enters the multi-user
    stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For our new unit file to be recognized by the system, we need to *reload* the
    systemd daemon itself. This will read in our new file. This must be done as root:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now see if systemd recognizes our new daemon by using the `status` command
    for `systemctl`. Note that we see both the description here from the unit file
    and the actual unit file used. We also see that the daemon is currently *disabled*
    and *inactive*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's not harder than this to create a service for a daemon in systemd. Once
    we have learned systemd and unit files, it's easier than writing *init scripts*
    as we did in the old days. With only nine lines, we have put the daemon under
    the control of systemd.
  prefs: []
  type: TYPE_NORMAL
- en: The unit file is mostly self-explanatory. In our case, with a traditional daemon
    that forks, we set the type to *forking* and specify a PID file. Systemd then
    uses the PID number from the PID file to track the daemon state. This way, systemd
    can restart the daemon if it notices that the PID has disappeared from the system.
  prefs: []
  type: TYPE_NORMAL
- en: In the status message, we saw that the service is *disabled* and *inactive*.
    **Disabled** means that it won't start automatically when the system boots. **Inactive**
    means that it hasn't started yet.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are writing a unit file for a daemon that uses the network, for example,
    an internet daemon, you can explicitly tell systemd to wait with this daemon until
    the network is ready. To achieve this, we add these lines under the `[Unit]` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can, of course, use `After` and `Wants` for other dependencies as well.
    There is also another dependency statement you can use, called `Requires`.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between them is that `After` specifies the order of the units.
    A unit with `After` will wait to start after the unit required is started. `Wants`
    and `Requires`, however, only specify the dependency, not the ordering. With `Wants`,
    a unit will still start even if the other unit required isn't started successfully.
    But with `Requires`, the unit will fail to start if the required unit isn't started.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In `man systemd.unit` is a lot of information about the different sections of
    a unit file and which directives we can use in each section.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling and disabling a service – and starting and stopping it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we added our daemon as a service to systemd with a unit
    file. In this recipe, we'll learn how to enable it, start it, stop it, and disable
    it. There is a difference between enabling and starting and disabling and stopping
    a service.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling a service means that it will start automatically when the system boots.
    Starting a service means that it will start right now, regardless of it being
    enabled or not. And disabling a service means that it will no longer start when
    the system boots. Stopping a service stops it right now, regardless of it being
    enabled or disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to do all of this enables you to control the system's services.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe to work, you'll first need to complete the previous recipe,
    *Writing a unit file for a daemon*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by checking out the daemon status again. It should be both disabled
    and inactive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll *enable* it, meaning it will start automatically on boot (when the
    system enters *multi-user mode*). We must issue this command as root since it''s
    a command that modifies the system. Notice also what''s happening when we enable
    it. There''s no arcane stuff going on; it just creates a symbolic link from our
    unit file to `/etc/systemd/system/multi-user.target.wants/my-daemon.service`.
    Remember that `multi-user.target` was the target we specified in the unit file.
    So when the system reaches the multi-user level, systemd will start all services
    in that directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check out the status of the daemon now that we have enabled it. It should
    now say *enabled* instead of *disabled*. However, it is still *inactive* (not
    started):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to start the daemon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s check out the status one more time. It should be both enabled and
    active (that is, started). This time, we''ll get more information about the daemon
    than before. We''ll see its PID, its status, its memory usage, and so on. We''ll
    also see a snippet from the log at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s verify that systemd restarts the daemon if it crashes or gets killed.
    First, we check out the process with `ps`. Then we kill it with the `KILL` signal,
    so it has no chance of exiting normally. Then we check it out again with `ps`
    and notices that it has a new PID since it''s a new process. The old one got killed,
    and systemd started a new instance of it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also check out the file that the daemon writes to in the `/tmp` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, let''s stop the daemon. We''ll also check its status and check
    that the process is gone with `ps`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To prevent the daemon from starting when the system reboots, we must also *disable*
    the service. Notice what''s happening here. The symbolic link that got created
    when we enabled the service is now removed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we enable or disable a service, systemd creates a symbolic link in the
    *target* directory. In our case, the target was *multi-user*, that is, when the
    system has reached the multi-user level.
  prefs: []
  type: TYPE_NORMAL
- en: In step five, when we started the daemon, we saw the *Main PID* in the status
    output. This PID matches the PID from the `/var/run/my-daemon.pid` file that the
    daemon creates. This is how systemd keeps track of *forking* daemons. In the next
    recipe, we'll see how we can create a daemon for systemd without forking.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a more modern daemon for systemd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Daemons that are handled by systemd don't need to fork or close their file descriptors.
    Instead, it's advised to use standard output and standard error to write the daemon's
    logs to the journal. The journal is systemd's logging facility.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll write a new daemon, one that doesn't fork and leaves `/tmp/my-daemon-is-alive.txt
    file`, as before). This kind of daemon is sometimes referred to as a `my-daemon-v2.c`,
    is referred to as a **SysV-style daemon**. **SysV** was the name of the init system
    before systemd.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll only need what's listed in the *Technical requirements*
    section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll write a **new-style daemon**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This program is a bit long, so I''ve split it up into several steps. Write
    the code in a file and save it as `new-style-daemon.c`. All the code goes into
    a single file, even though there are several steps. We''ll start by writing all
    the `include` statements, the function prototype for the signal handler, and the
    `main()` function body. Notice that we don''t fork here. We also don''t close
    any file descriptors or streams. Instead, we write the "*Daemon alive*" text to
    standard output. Note that we need to *flush* stdout here. Normally, streams are
    line-buffered, meaning they get flushed on each new line. But when stdout is redirected
    to something else, like with systemd, it''s instead fully buffered. To be able
    to see the text as it gets printed, we need to flush it; otherwise, we wouldn''t
    see anything in the log until we stop the daemon or the buffer gets filled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll write the function for the signal handler. Note that we catch both
    `SIGHUP` and `SIGTERM` here. `SIGHUP` is often used to reload any configuration
    files without restarting the entire daemon. `SIGTERM` is caught so that the daemon
    can clean up after itself (close all open file descriptors or streams and remove
    any temporary files). We don''t have any configuration files or temporary files
    here, so we print a message to standard output instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to compile the daemon so we can use it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run it interactively to verify that it''s working:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This daemon works pretty much like any other program we have written. There's
    no need to do any forking, change the working directory, close file descriptors
    or streams, or anything like that. It's just a regular program.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we don't flush the stdout buffer in the signal handler. Every time
    the program receives a signal and prints a message, the program goes back into
    the `for` loop, prints another "*Daemon alive*" message, and then flushes when
    the program reaches `fflush(stdout)` in the `for` loop. If the signal is `SIGTERM`,
    all buffers are flushed on `exit(0)`, so we don't need to flush here either.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we'll make this program a systemd service.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can get much more in-depth information about the `man 7 daemon`.
  prefs: []
  type: TYPE_NORMAL
- en: Making the new daemon a systemd service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've made a **new-style daemon** in the previous recipe, we'll see
    that it's even easier to make a unit file for this daemon.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to write unit files to new-style daemons is important since more
    and more daemons are written this way. When making new daemons for Linux, we should
    make them in this new style.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll need to complete the previous one. It's the daemon from
    that recipe that we'll use here.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will make the **new-style daemon** a systemd service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by moving the daemon to `/usr/local/sbin`, just as we did with
    the traditional daemon. Remember, you''ll need to be root for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll write the new unit file. Create the `/etc/systemd/system/new-style-daemon.service`
    file and give it the following content. Remember, you''ll need to be root to create
    that file. Notice that we don''t need to specify any PID file here. Also, note
    that we have changed `Type=forking` to `Type=simple`. Simple is the default type
    for systemd services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Reload the systemd daemon, so the new unit file gets recognized:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the daemon, and check out its status. Notice that we''ll also see a "*Daemon
    alive*" message here. This is a snippet from the journal. Notice that we don''t
    *enable* the service this time. We don''t need to enable the service unless we
    want it to start automatically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Leave the daemon running, and we'll take a look at the journal in the next recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since this daemon isn't forking, systemd can keep track of it without a PID
    file. For this daemon, we used `Type=simple`, which is the default type in systemd.
  prefs: []
  type: TYPE_NORMAL
- en: When we started the daemon in *Step 4* and checked out the status of it, we
    saw the first line of the "*Daemon alive*" message. We can see a daemon's status
    without using `sudo`, but then we can't see the journal's snippet (since it might
    contain sensitive data).
  prefs: []
  type: TYPE_NORMAL
- en: Since we flush the stdout buffer after each `printf()` in the `for` loop, the
    journal is updated live as each new entry is written to it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we'll take a look at the journal.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the journal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll learn how to read the journal. The journal is systemd's
    logging facility. All messages that a daemon prints to either stdout or stderr
    gets added to the journal. But we can find more than just the system daemons logs
    here. There's also the system's boot messages, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to read the journal enables you to find errors in the system and
    the daemons more easily.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll need to have the `new-style-daemon` service running.
    If you don't have it running on your system, go back to the previous recipe for
    information on how to start it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll explore how to read the journal and what kind of information
    we can find in it. We''ll also learn how to follow a particular service''s log:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by examining the logs from our service, `new-style-daemon`. The
    `-u` option stands for *unit*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The log is probably pretty long by now, so you can scroll down in the log by
    hitting *Spacebar*. To quit the journal, press *Q*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that we implemented a signal handler for `SIGUSR1`? Let''s try sending
    our daemon that signal and then view the log again. But this time, we''ll only
    show the last five lines in the journal with `--lines 5`. Find the PID of the
    process by using `systemctl status`. Notice the "*Hello world*" message (it''s
    highlighted in the following code):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s also possible to *follow* the journal for a service, that is, view it
    "live." Open up a second terminal and run the following command. The `-f` stands
    for *follow*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, in the first terminal, send another `USR1` signal with `sudo kill -USR1
    8421`. You'll see the "*Hello world*" message in the second terminal right away
    without any delay. To quit the follow mode, you just hit *Ctrl* + *C*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `journalctl` command offers a wide range of filtering. For example, it''s
    possible to select only log entries between two dates using `--since` and `--until`.
    It''s also possible to leave out either one of them to view all messages since
    or until a particular date. Here, we show all messages between two dates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: By leaving out the `-u` option and the unit name, we can see all log entries
    from all services. Try it out and scroll through it with *Spacebar*. You can also
    try to only view the last 10 lines as we did before with `--line 10`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now it''s time to stop the `new-style-daemon service`. We''ll also view the
    last five lines from the log after we have stopped the service. Notice the goodbye
    message from the daemon. This is from the signal handler we made for the `SIGTERM`
    signal. When we stop a service in systemd, it sends the service a `SIGTERM` signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the journal takes care of all messages that go to stdout and stderr, we
    don't need to handle logging ourselves. This makes it easier to write daemons
    for Linux that are handled by systemd. As we saw when we viewed the journal, every
    message gets a timestamp. This makes it easy to filter out a specific day or time
    when looking for errors.
  prefs: []
  type: TYPE_NORMAL
- en: Following the log for a specific service with the `-f` option is common when
    experimenting with new or unknown services.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The manual page at `man journalctl` has even more tips and tricks on how to
    filter the journal.
  prefs: []
  type: TYPE_NORMAL
