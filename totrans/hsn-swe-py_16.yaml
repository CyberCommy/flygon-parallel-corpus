- en: The Artisan Gateway Service
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工匠网关服务
- en: In order to implement the end user and Gateway-daemon communications, we need
    to examine and make some decisions on several operational aspects of the daemon –
    how it's going to work, how data gets sent and received, and how that data is
    acted upon. In this chapter, we'll examine that in detail, and write code to implement
    processes based on those decisions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现最终用户和网关守护程序之间的通信，我们需要详细研究并就守护程序的几个运行方面进行一些决策-它将如何工作，数据如何发送和接收，以及如何对这些数据进行操作。在本章中，我们将对此进行详细研究，并编写代码来实现基于这些决策的过程。
- en: 'The chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Defining what the data structure (messages) being sent back and forth looks
    like, and what it needs to provide, including a signed-message implementation
    that should work no matter what mechanism is used to send the data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义来回发送的数据结构（消息）的样子，以及它需要提供的内容，包括一个签名消息实现，无论使用何种机制发送数据，都应该起作用
- en: 'Examining two fundamental options for sending and receiving data: message queues
    and web services'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查发送和接收数据的两个基本选项：消息队列和Web服务
- en: How messages will be handled, independently of the transmission mechanism
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息将如何处理，独立于传输机制
- en: The basic structures needed to implement a message-queue-based transmission
    mechanism
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现基于消息队列的传输机制所需的基本结构
- en: What variations would be encountered (and how to deal with them) in a web-service-based
    approach
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基于Web服务的方法中会遇到什么变化（以及如何处理）
- en: What the traffic to and from the Artisan Gateway will look like
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工匠网关的进出流量将是什么样子
- en: A minimal integration of those traffic patterns into existing data objects'
    current processes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这些流量模式最小集成到现有数据对象的当前流程中
- en: Overview and goal
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述和目标
- en: 'In the context of the `hms_sys` system, the Artisan Gateway has been only loosely
    defined thus far – it''s been described as acting as a central contact point for
    communication between Artisans and the Central Office, especially with respect
    to the `Product` and `Order` objects – what its role is, in effect. The specifics
    of how it works, and when, haven''t really been touched upon, though at least
    some of the latter are probably very obvious, following a simple rule that might
    be stated as changes made (by whomever) need to propagate to all relevant parties
    as soon as is feasible. Those changes are largely dependent on who is making them.
    At a minimum, the following processes feel likely:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在“hms_sys”系统的背景下，工匠网关迄今为止只是宽泛地定义了它的作用-它被描述为在工匠和中央办公室之间的通信的中央联系点，特别是关于“产品”和“订单”对象的-它的作用是什么。它的工作方式和何时工作的具体细节还没有被触及，尽管至少后者可能是非常明显的，遵循一个简单的规则，即所做的更改（由谁）需要尽快传播到所有相关方。这些更改在很大程度上取决于谁在进行更改。至少，以下过程可能会出现：
- en: Artisans can create new `Product` data
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工匠可以创建新的“产品”数据
- en: Artisans can update current `Product` data
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工匠可以更新当前的“产品”数据
- en: Artisans can delete a `Product` outright
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工匠可以直接删除“产品”
- en: Central Office staff can mark a `Product` as available – which is just a specialized
    variant of a `Product` update process
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中央办公室工作人员可以标记“产品”为可用-这只是“产品”更新过程的一个专门变体
- en: Central Office staff can also make content changes to Products – also an update
    variant – with some constraints on what can be altered
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中央办公室工作人员也可以对产品进行内容更改-这也是一种更新变体-对可以更改的内容有一些限制
- en: Customer end users can indirectly create `Order` objects, which need to propagate
    out to Artisans in some fashion
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终用户可以间接创建“订单”对象，需要以某种方式传播给工匠
- en: Artisans can update Orders as part of the process of fulfilling them
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工匠可以在履行过程中更新订单
- en: All of these processes are variants of CRUD operations on the `Product` and/or
    `Order` objects, and will probably not need much more functionality than is already
    provided by the `_create` or `_update` methods of the related classes within each
    subsystem. They should cover most, perhaps all, of how the data changes are actually
    stored.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些过程都是对“产品”和/或“订单”对象的CRUD操作的变体，可能不需要比每个子系统中相关类的_create或_update方法提供的功能更多。它们应该涵盖实际存储数据更改的大部分，也许全部。
- en: 'The transmission of those data changes, no matter what the timing or protocol
    ends up looking like, has some common factors as well, with a process that will
    need to handle the role-specific variations of the following steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据更改的传输，无论最终的时间或协议是什么样子，都有一些共同因素，需要处理以下步骤的特定变体：
- en: A data change (create, update, or delete) is made locally, in one of the user-level
    applications
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地进行数据更改（创建、更新或删除）
- en: The data change is validated, to assure that the data is well formed and conforms
    to data-structure requirements
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证数据更改，以确保数据格式良好并符合数据结构要求
- en: The data change is stored locally (if applicable)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据更改在本地存储（如果适用）
- en: The data change is serialized and transmitted to the Artisan Gateway service,
    where whatever actions need to be undertaken are executed
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据更改被序列化并传输到工匠网关服务，执行需要进行的任何操作
- en: These steps do not address the possibility of conflicting changes, such as an
    Artisan and someone in the Central Office making different changes to the same
    data in the same data-change timeframe. A strategy for dealing with that possibility
    may not even be necessary, depending on the specific data-change business rules
    in play, but will have to be examined as well.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤并未解决冲突更改的可能性，例如工匠和中央办公室的某人在相同的数据更改时间段内对相同数据进行不同更改的可能性。处理这种可能性的策略可能甚至不是必要的，取决于正在进行的具体数据更改业务规则，但也必须进行检查。
- en: That leaves only the decision about the transmission method itself to be made.
    Since the individual users that will be making changes to data are not expected
    to be in the same physical location, we need a network-transmission protocol of
    some sort – a web service or message-queue-based process, as discussed in [Chapter
    15](26ce9de7-eb44-4e33-afa2-fccb17e75aa8.xhtml), *Anatomy of a Service*. A web
    service, if it were written from scratch, would probably be a significantly larger
    undertaking, potentially requiring code to handle authentication, authorization,
    and processes for handling specific HTTP methods and tying them to specific CRUD
    operations against individual data object types. There's enough complexity between
    those alone to warrant looking at an existing service-capable framework, such
    as Flask or Django, rather than writing (and having to test) all of the relevant
    code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这只留下了关于传输方法本身的决定。由于预计进行数据更改的个别用户不会在同一物理位置，我们需要某种网络传输协议 - 一种Web服务或基于消息队列的过程，如[第15章](26ce9de7-eb44-4e33-afa2-fccb17e75aa8.xhtml)中讨论的那样，*服务的解剖*。如果从头开始编写Web服务，可能需要进行大量工作，可能需要编写处理身份验证、授权和处理特定HTTP方法并将它们与特定CRUD操作绑定到个别数据对象类型的代码。这些单独之间的复杂性足以值得查看现有的服务框架，如Flask或Django，而不是编写（并且必须测试）所有相关代码。
- en: 'Given that the system only needs to be concerned with the seven actions identified
    earlier (Artisan: create, update, or delete Products, and so on), it feels simpler
    to write those seven functions, and allow messages in a queue-based protocol to
    simply call them when necessary. The potential concerns around authentication
    and authorization can be mitigated significantly by assigning each Artisan its
    own distinct queue, and perhaps signing each message originating with an Artisan.
    Between those two approaches, an Artisan''s identity can be determined simply
    by the fact that a message is coming in from a given queue that''s associated
    with them. Coupling that with a signature on each message, as long as it can be
    generated by the Artisan''s application and verified by the Artisan Gateway service
    without transmitting any secret data with the message, provides a reasonably robust
    authentication mechanism. Authorization concerns in this context are nearly trivial –
    any given channel, given that it can be associated with a user type, or even a
    specific user, can simply be allowed access to (and thus execution of) the operations
    that are relevant to that user or type only.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到系统只需要关注之前确定的七个操作（工匠：创建、更新或删除产品等），编写这七个函数并允许队列协议中的消息在必要时调用它们会更简单。通过为每个工匠分配一个独特的队列，并可能为每个工匠发出的每条消息签名，可以显著减轻围绕身份验证和授权的潜在问题。通过这两种方法，可以简单地通过来自与他们相关联的特定队列的消息来确定工匠的身份。再加上每条消息上的签名，只要它可以由工匠的应用程序生成并由工匠网关服务验证，而不会在消息中传输任何秘密数据，就提供了一个相当健壮的身份验证机制。在这种情况下，授权问题几乎微不足道
    - 任何给定的通道，只要它可以与用户类型或甚至特定用户关联，就可以简单地允许访问（从而执行）与该用户或类型相关的操作。
- en: 'At a high level, the data flows for Artisan/Product operations, no matter which
    transmission mechanism is selected, would look like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，无论选择哪种传输机制，工匠/产品操作的数据流都会如下所示：
- en: '![](assets/34162167-3cac-4fc6-8676-1552cfd5f1bf.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/34162167-3cac-4fc6-8676-1552cfd5f1bf.png)'
- en: 'Where:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在哪里：
- en: The various messages (**Create Product**, **Update Product**, and **Delete Product**)
    with their respective **{payload}** data (or a **{product_id}** for deletion operations)
    are created by the local **Artisan Application**, transmitted to the **Artisan
    Gateway** service
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种消息（**创建产品**、**更新产品**和**删除产品**）及其各自的**{payload}**数据（或删除操作的**{product_id}**）由本地**工匠应用程序**创建，并传输到**工匠网关**服务
- en: Those messages are read, validated, and used to determine which service method
    (`artisan_create_product`, and so on) should be called
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些消息被读取、验证，并用于确定应调用哪个服务方法（`artisan_create_product`等）
- en: The relevant method deals with whatever data storage is needed in the **Artisan
    Gateway Datastore** during execution
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关方法处理执行期间**工匠网关数据存储**中所需的任何数据存储
- en: Similar data flows would exist for all of the operations that Central Office
    users could execute against `Product` objects, and for `Artisan` and `Order` object
    interactions, at a minimum. In addition, there may well be related operations
    that need to be made available for more specific data-object operations in more
    specific Central Office roles. The Central Office staff will need to be able to
    manage `Artisan` objects, at a minimum, and maybe `Order` objects as well.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的数据流也将存在于中央办公室用户可以对`产品`对象执行的所有操作，以及`工匠`和`订单`对象的交互，至少是这样。此外，可能还需要为更具体的中央办公室角色中更具体的数据对象操作提供相关操作。中央办公室工作人员将需要能够管理`工匠`对象，至少可能还有`订单`对象。
- en: Iteration stories
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代故事
- en: 'Although there are at least *some* aspects of many of these stories that rely
    on some UI implementation that hasn''t been examined yet, there are non-UI functional
    aspects to each of them that can be usefully examined and worked. With that in
    mind, the stories relevant for this iteration, at least initially, are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多这些故事的*某些*方面依赖于尚未被检查的一些UI实现，但每个故事都有一些非UI功能方面可以被有用地检查和处理。考虑到这一点，至少在最初，本次迭代相关的故事如下：
- en: As an Artisan, I need to be able to send data changes to the Artisan Gateway
    so that those changes can be propagated and acted upon as needed
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一名工匠，我需要能够将数据更改发送到工匠网关，以便这些更改可以根据需要传播和执行
- en: As a Central Office user, I need to be able to send data changes to the Artisan
    Gateway so that those changes can be propagated and acted upon as needed
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为中央办公室用户，我需要能够将数据更改发送到工匠网关，以便这些更改可以根据需要传播和执行
- en: As an Artisan Manager, I need to be able to create `Artisan` objects so that
    I can manage Artisans
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Artisan经理，我需要能够创建“Artisan”对象，以便我可以管理Artisans
- en: As an Artisan Manager, I need to be able to delete `Artisan` objects so that
    I can manage Artisans
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Artisan经理，我需要能够删除“Artisan”对象，以便我可以管理Artisans
- en: As an Artisan Manager, I need to be able to update `Artisan` objects so that
    I can manage Artisans
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Artisan经理，我需要能够更新“Artisan”对象，以便我可以管理Artisans
- en: As an Artisan, I need to be able to create `Product` objects so that I can manage
    my Product offerings
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Artisan，我需要能够创建“产品”对象，以便我可以管理我的产品供应
- en: As an Artisan, I need to be able to delete `Product` objects so that I can manage
    my Product offerings
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Artisan，我需要能够删除“产品”对象，以便我可以管理我的产品供应
- en: As an Artisan, I need to be able to update `Order` objects so that I can indicate
    to the Central Office when my part of an Order is fulfilled
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Artisan，我需要能够更新“订单”对象，以便我可以指示中央办公室何时完成订单的我的部分
- en: As an Artisan, I need to be able to update `Product` objects so that I can manage
    my Product offerings
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Artisan，我需要能够更新“产品”对象，以便我可以管理我的产品供应
- en: As an Artisan, I need to be able to update my own `Artisan` object so that I
    can manage my information at HMS Central Office
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Artisan，我需要能够更新自己的“Artisan”对象，以便我可以在HMS中央办公室管理我的信息
- en: As a Product Manager, I need to be able to activate `Product` objects so that
    I can manage Product availability
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为产品经理，我需要能够激活“产品”对象，以便我可以管理产品的可用性
- en: As a Product Manager, I need to be able to deactivate `Product` objects so that
    I can manage Product availability
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为产品经理，我需要能够停用“产品”对象，以便我可以管理产品的可用性
- en: As a Product Manager, I need to be able to update `Product` objects so that
    I can manage Product information that an Artisan can't
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为产品经理，我需要能够更新“产品”对象，以便我可以管理Artisan无法管理的产品信息
- en: As any user sending messages across, to, or from the Artisan Gateway service,
    I need those messages to be signed so that they can be validated before being
    acted upon
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为向Artisan Gateway服务发送消息的任何用户，我需要这些消息被签名，以便在执行之前可以验证
- en: 'With the exception of the last item, these have been grouped more or less in
    the order that they would need to be executed in a real use case: Central Office
    users (acting as Artisan Managers) would need to create objects representing Artisans
    before those Artisans could be expected to do anything, and Artisans have to be
    able to create `Product` objects before Central Office users (acting as Product
    Managers) could be expected to do anything with those objects.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最后一项之外，这些项或多或少地按照在实际用例中需要执行的顺序进行了分组：中央办公室用户（充当Artisan经理）需要创建代表Artisans的对象，然后才能期望Artisans做任何事情，Artisans必须能够创建“产品”对象，然后才能期望中央办公室用户（充当产品经理）对这些对象做任何事情。
- en: Messages
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息
- en: 'Before taking a serious look at the transmission-mechanism options, it would
    be beneficial to have a solid definition of what, exactly, constitutes a message
    being transmitted. At a minimum, given what the data flows coming into the Artisan
    Gateway service look like, and with some idea of what the actual data for a typical
    data object being transmitted entails, it''s apparent that a message needs to
    be able to handle structured data. Internally, that''s probably best represented
    by a `dict`, if only because they are easy to serialize and un-serialize into
    at least two different formats that are easily transmissible: JSON and YAML. We''ve
    already established data dictionary structures for the objects whose state data
    can be stored. A `Product`, for example, from an Artisan''s perspective, whose
    data dictionary has been rendered into JSON looks like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在认真考虑传输机制选项之前，有必要明确定义传输的消息是什么。至少，考虑到Artisan Gateway服务中的数据流的情况，以及典型数据对象的实际数据是什么，显然消息需要能够处理结构化数据。在内部，这可能最好由“dict”表示，因为它们易于序列化和反序列化为至少两种易于传输的不同格式：JSON和YAML。我们已经为可以存储状态数据的对象建立了数据字典结构。例如，从Artisan的角度来看，已经将数据字典渲染为JSON的“产品”看起来是这样的：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This provides all of the data needed for any create or update operation of a
    `Product` initiated by an Artisan, but doesn't specify what operation needs to
    be performed with the data. It also doesn't have any signature data associated
    with it, which we'll want to provide to complete the last of the iteration stories
    noted earlier. Both of those items, operation and signature, need to be added
    to the message, but not to the message data, so that creating an instance of the
    `Product` object on the receiving end doesn't have to deal with removing non-product
    data from the incoming data structure.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了由Artisan发起的任何创建或更新“产品”的操作所需的所有数据，但没有指定需要对数据执行什么操作。它也没有与之关联的签名数据，我们希望提供以完成前面提到的迭代故事的最后一部分。这两个项目，操作和签名，都需要添加到消息中，但不需要添加到消息数据中，这样在接收端创建“产品”对象的实例就不必处理从传入数据结构中删除非产品数据。
- en: 'In the context of a message, they are both metadata: data about the data, in
    this case describing what is to be done with the real data, and what signature
    should be used to verify the integrity of the message. A more complete message,
    intended to update an existing product (providing a description and summary, and
    making the item available) would look something like this (assuming that all product-data
    is transmitted during an update operation):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在消息的上下文中，它们都是元数据：关于数据的数据，本例中描述了对真实数据的操作以及应该使用什么签名来验证消息的完整性。一个更完整的消息，旨在更新现有产品（提供描述和摘要，并使该项目可用），看起来可能是这样的（假设在更新操作期间传输了所有产品数据）：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That data structure as an output goal gives us enough information to implement
    a `DaemonMessage` class to represent any message going to or coming from the Artisan
    Gateway service. `DaemonMessage` is a concrete class, and lives in the `hms_core.daemons`
    module. It starts with a typical class declaration, and has a class constant defined
    that will be used later for encoding string values into byte values, in both instance
    and class methods:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输出目标的数据结构为我们提供了足够的信息来实现一个`DaemonMessage`类，以表示发送到或从Artisan Gateway服务接收的任何消息。`DaemonMessage`是一个具体的类，位于`hms_core.daemons`模块中。它以典型的类声明开始，并定义了一个类常量，稍后将用于将字符串值编码为字节值，无论是在实例方法还是类方法中：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Most of the properties of `DaemonMessage` follow the standard getter, setter,
    and deleter method/property-declaration pattern we''ve been using so far. One
    of them, the `signature` property, needs to return a calculated value every time
    it''s called, and simply has a getter method definition – `_get_signature`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`DaemonMessage`的大多数属性遵循我们迄今为止一直在使用的标准getter、setter和deleter方法/属性声明模式。其中一个属性`signature`需要在每次调用时返回一个计算出的值，并且只有一个getter方法定义
    - `_get_signature`：'
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `_get_signature` method has several noteworthy aspects in its implementation.
    First, since a signature should only be available if there is data to sign, and
    a signing key value to sign the data with, it actively checks for those values,
    raising `RuntimeError` if either is not set. Secondly, its return value has to
    ensure that hashes of the data structure will always be the same for the same
    data structure. Python's `dict` data structures do not guarantee the same sequence
    of keys across multiple `dict` values, even if the same keys exist across them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`_get_signature`方法在其实现中有几个值得注意的方面。首先，由于只有在有数据要签名和有签名密钥值要对数据进行签名时，签名才应该可用，因此它积极地检查这些值，如果没有设置任何一个，则引发`RuntimeError`。其次，其返回值必须确保数据结构的哈希始终对于相同的数据结构而言是相同的。Python的`dict`数据结构不能保证在多个`dict`值之间具有相同的键序列，即使它们之间存在相同的键。'
- en: Since the hashing mechanism requires a `bytes` value, and rendering a `dict`
    into `bytes` (using a `str()` conversion as an intermediate translation mechanism)
    will not always return the same `bytes` sequence to be hashed, some mechanism
    for ensuring the instance's `data dict` is always rendered into a consistent `str`/`bytes` sequence
    is needed. Since the value going into the hashing process for generating the signature
    could start as a string, and since `json.dumps` provides a mechanism for recursively
    sorting the output's keys, that was a quick and simple solution.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于哈希机制需要一个`bytes`值，并且将`dict`渲染为`bytes`（使用`str()`转换作为中间转换机制）不会始终返回相同的`bytes`序列进行哈希处理，因此需要一些机制来确保实例的`data
    dict`始终被渲染为一致的`str`/`bytes`序列。由于用于生成签名的哈希处理的值可能以字符串形式开始，并且`json.dumps`提供了递归排序输出键的机制，这是一个快速简单的解决方案。
- en: The selection of `json.dumps` was made based on simplicity and convenience.
    It might be better in the long run to create an `OrderedDict` instance (from the
    `collections` module), add each element, in order, to the new instance, then hash
    the string value of that instead. If nothing else, that would alleviate any potential
    concerns with data structures to be hashed containing values that cannot be serialized
    into JSON. Another option would be to hash a YAML value instead, since it deals
    with data types that aren't directly serialize-able in a cleaner fashion.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`json.dumps`是基于简单性和便利性。从长远来看，创建一个`OrderedDict`实例（来自`collections`模块），按顺序将每个元素添加到新实例中，然后对其字符串值进行哈希处理可能更好。如果没有其他选择，这将消除任何可能存在的数据结构问题，这些数据结构包含无法序列化为JSON的值。另一个选择是对YAML值进行哈希处理，因为它以更清晰的方式处理无法直接序列化的数据类型。
- en: The property setter and deleter methods are typical-enough implementations that
    they don't warrant much in the way of explanation, though the setter method corresponding
    to the operation property (`_set_operation`) checks the incoming value against
    a limited set of options.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 属性setter和deleter方法的实现都很典型，不需要太多解释，尽管与operation属性对应的setter方法（`_set_operation`）会检查传入的值是否在有限的选项集合中。
- en: 'One significant deviation from the typical properties pattern we''ve used so
    far is that `DaemonMessage` exposes most of its properties as settable and deletable.
    The rationale behind that decision is that it seems likely that the `data`, `operation`,
    and `signing_key` values of a message may not all be known when the message first
    needs to be created, or they may even need to be altered before the message is
    being sent by some other process. Allowing them to be set or deleted on the fly
    alleviates any such concerns in later implementations that use instances of `DaemonMessage`.
    In combination with the on-the-fly, calculated-value implementation of signature
    (and its checking for required property-values before returning), this allows
    as much flexibility as we should need later, while still preserving the type-
    and value-checking of those properties:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，与我们迄今为止使用的典型属性模式相比，`DaemonMessage`的一个重要偏差是，它将大部分属性公开为可设置和可删除的。这一决定背后的理由是，当消息首次需要创建时，可能并不知道`data`、`operation`和`signing_key`的所有值，甚至在消息被其他进程发送之前可能需要对它们进行修改。允许在运行时设置或删除它们可以减轻后续使用`DaemonMessage`实例的任何此类问题。结合在运行时计算值的签名实现（并在返回之前检查所需的属性值），这样可以在以后提供我们所需的灵活性，同时仍保留这些属性的类型和值检查：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Accordingly, the initialization of a `DaemonMessage` doesn''t require any of
    those properties to be supplied to construct an instance, but it allows all of
    them:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`DaemonMessage`的初始化不需要提供这些属性中的任何一个来构造实例，但允许提供所有属性：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Since the purpose of the `DaemonMessage` class is to provide a simple, consistent
    way to generate messages serialized into JSON, and that requires a `dict` value
    to serialize from, we provide methods to do both:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`DaemonMessage`类的目的是提供一种简单、一致的方式来生成序列化为JSON的消息，并且这需要从`dict`值进行序列化，因此我们提供了相应的方法：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Similarly, we''ll need a way to unserialize messages from JSON, with an intermediate
    from dictionary method. These are implemented as class methods, allowing a message
    instance to be created and validated with a signing key. The critical aspects
    of that functionality all reside in the `from_message_dict` class method:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们需要一种方法来从JSON中反序列化消息，使用中间的从字典方法。这些都是作为类方法实现的，允许创建消息实例并使用签名密钥进行验证。该功能的关键方面都驻留在`from_message_dict`类方法中：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Typical type- and value-checking is performed against the incoming arguments
    first:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先对传入的参数执行典型的类型和值检查：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A new `DaemonMessage` instance is created from the data and operation values
    of the incoming `message_dict`, and from the `signing_key` argument after ensuring
    that all data is present and well formed:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从传入的`message_dict`的数据和操作值以及`signing_key`参数创建一个新的`DaemonMessage`实例，确保所有数据都存在且格式良好：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once the new `DaemonMessage` instance exists, provided that its data has the
    same keys and values, and that the local `signing_key` used to generate the signature
    is the same as the `signing_key` that was used to create the original message
    before it was transmitted, the signature values of both messages should be identical.
    If they aren''t, then there is something suspect with the message. There are not
    many possible causes for a signature failure:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦存在新的`DaemonMessage`实例，只要其数据具有相同的键和值，并且用于生成签名的本地`signing_key`与用于在传输之前创建原始消息的`signing_key`相同，则两条消息的签名值应该是相同的。如果不是，则消息存在可疑情况。签名失败的可能原因并不多：
- en: The `data` in the message has gotten corrupted/altered in some fashion
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息中的数据以某种方式损坏/更改
- en: The local and remote `signing_key` values are different
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地和远程的`signing_key`值不同
- en: 'In either case, no action should be taken – either the data itself is suspect,
    or the authenticity of the message cannot be verified. In any signature-failure
    condition, we raise a custom error, `InvalidMessageError`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，都不应采取任何行动 - 要么数据本身存在可疑情况，要么无法验证消息的真实性。在任何签名失败的情况下，我们会引发一个自定义错误，`InvalidMessageError`：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The conversion from a JSON-serialized message to a `DaemonMessage` instance
    simply decodes the incoming JSON, then feeds the resultant `dict` data structure
    into `from_message_dict`, returning the resultant object:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将JSON序列化消息转换为`DaemonMessage`实例的过程只是解码传入的JSON，然后将结果`dict`数据结构输入到`from_message_dict`中，返回结果对象：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Serializing messages to and from JSON doesn't impact our options for how the
    Artisan Gateway service actually transmits those messages. Both of the options
    mentioned, web service and message queue approaches, can handle JSON message formats –
    so this message strategy is *very* portable in that respect.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将消息序列化为JSON格式并不影响Artisan Gateway服务实际传输这些消息的选项。提到的两种选项，即Web服务和消息队列方法，都可以处理JSON消息格式
    - 因此在这方面，这种消息策略非常便携。
- en: The signing process of `DaemonMessage` relies heavily on the idea of creating
    and managing signing keys for messages – messages cannot be sent or read without
    them – and there are some significant considerations that should be discussed
    before moving on.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`DaemonMessage`的签名过程严重依赖于创建和管理消息的签名密钥的想法 - 没有它们，消息无法发送或读取 - 在继续之前应该讨论一些重要的考虑因素。'
- en: 'Like any cryptographic process, hash-based signatures rely on a secret value
    (`signing_key`, in this case) that has to be created and secured. With respect
    to creating a `signing_key`, there are several factors to bear in mind, but the
    two most significant areas follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何加密过程一样，基于哈希的签名依赖于必须创建和保护的秘密值（在本例中为`signing_key`）。在创建`signing_key`方面，有几个因素需要牢记，但最重要的两个领域如下：
- en: The longer the value is, the harder it will be to crack
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值越长，破解的难度就越大
- en: The more varied the characters in it are, the harder it will be to crack
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含的字符越多，破解的难度就越大
- en: 'The math underlying these is fairly straightforward: it takes less time to
    iterate over 10 values than it does over 100, so the more variations that are
    possible in a secret value of any kind, the longer it will take to iterate over
    them all. The number of possible values can be expressed mathematically as (the
    number of values per character)^((the number of characters in the string)), so
    a 128-character `signature_key`, with 255 possible characters would entail 255^(128)
    possible values, or about 1.09 × 10^(308) combinations that would have to be checked
    to guarantee the calculation of a `signature_key` of that size and scope. At one
    billion such calculations per second, or about 3.15 × 10^(16) calculations per
    year, it''s still technically/mathematically possible to crack such a `signing_key`,
    but assuming that the hashing algorithm doesn''t have any significant flaws that
    can be exploited, it''s impractical, at best.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些底层的数学原理相当简单：迭代10个值所需的时间比迭代100个值所需的时间少，因此任何类型的秘密值中可能的变化越多，迭代所有这些值所需的时间就越长。可能值的数量可以用数学方式表示为（每个字符的值的数量）^（字符串中的字符数量），因此一个具有255个可能字符的128字符`signature_key`将涉及255^(128)个可能值，或大约1.09
    × 10^(308)个组合，必须检查以保证计算出这样大小和范围的`signature_key`。每秒进行十亿次这样的计算，或者每年进行约3.15 × 10^(16)次计算，从技术上/数学上讲，仍然可能破解这样的`signing_key`，但假设哈希算法没有任何可以利用的重大缺陷，这在实际上是不切实际的。
- en: 'The creation of a `signature_key` of whatever length is desired is fairly straightforward.
    Python''s `os` module provides a function, `urandom`, that returns a character
    sequence (as a `bytes` object) suitable for cryptographic use, and of whatever
    length is desired, so generation of even a very long key is as simple as calling
    the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 创建所需长度的`signature_key`相当简单。Python的`os`模块提供了一个名为`urandom`的函数，返回一个适用于加密使用的字符序列（作为`bytes`对象），并且可以是任意长度，因此生成一个非常长的密钥就像调用以下内容一样简单：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The results can be converted to a hexadecimal string value for storage, if
    needed, and converted back from that hexadecimal string with `bytes.fromhex()`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Securing secret values is usually concerned with some combination of the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Assuring that they are encrypted at rest, so that even if the data store that
    secrets reside in is compromised, the secrets themselves cannot be easily used
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assuring that they are encrypted in motion, to prevent man-in-the-middle exploits
    from being able to access easily usable keys
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing (rotating) them on a reasonably frequent basis, to reduce the likelihood
    that a captured secret can be compromised before it's no longer useful
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The creation and management of `signing_key` values for Artisans (and perhaps
    for Central Office-to-Artisan communications as well), and the possibility of
    implementing some sort of key-rotation process will be examined in more detail
    in [Chapter 17](b21d33e8-90c4-4a67-af0e-9fc0211d8e3a.xhtml), *Handling Service
    Transactions*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring that they are encrypted in motion could be a significant factor in
    deciding how messages will be transmitted, though. In-flight encryption will require
    the creation of an encryption certificate for either a web-service or locally
    hosted message-queue implementation. A message-queue approach may allow a private
    certificate to be used, while a web service might require a certificate from a
    public Certificate Authority.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Encryption in motion should always be implemented when transmitting any secret
    information, and a `signing_key` definitely falls into that category!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Encryption at rest feels like it might be overkill for a system of this scope,
    though it could be implemented in code with libraries such as PyCrypto, and/or
    by configuring the MongoDB engine to use its Encrypted Storage Engine (available
    in MongoDB Enterprise). It would also add more complexity to the system than seems
    warranted at this point, including (again) key-creation and management.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Deciding on a message-transmission mechanism
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the structure of the messages being passed now resolved, it''s a good
    time to take a deeper look at the options for how those messages could be transmitted.
    Ultimately, a decision needs to be made regarding how to implement a process to
    deal with the stories:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: As an Artisan, I need to be able to send Product and Order data changes to the
    Artisan Gateway so that those changes can be propagated and acted upon as needed
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a Central Office user, I need to be able to send Artisan and Product data
    changes to the Artisan Gateway so that those changes can be propagated and acted
    upon as needed
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of the two options discussed earlier (web service or message-queue-based implementations),
    using message queues feels like a better fit:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the limited number of operations expected, a queue-based approach would
    involve less development effort, and probably less complexity than a web-service
    implementation:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's no need to handle any of the protocol-level details (HTTP methods, variations
    of data-payload structures, and so on) that would have to be dealt with in implementing
    a web service
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's no need to write a full-blown HTTP server (either from the ground up,
    or using one of the server classes provided by the `http.server` package), or
    to integrate functionality/code with any of several web-framework options (Flask,
    or the Django REST Framework, for example)
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Messages can be sent and will simply wait in their queues until they are retrieved
    and acted upon, so:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All end users can continue to use their applications without interruption so
    long as the queue server is accessible
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Artisan Gateway itself could be taken down (for maintenance, updating, or
    even to be moved to a different server) at any point
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are some caveats/trade-offs to this approach, though:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Messages that contain conflicting data changes, though they will still be retrieved
    and processed, could require additional manual attention to reconcile those changes.
    The same thing could happen in a web-service context, but it's at least somewhat
    more likely with message queues.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message-retrieval, as an active process over a network, could take somewhat
    longer than simply reading an incoming request made directly to the Artisan Gateway.
    As a result, service throughput may be impacted, but even if a complete message-operation
    cycle took 10 seconds, that would allow for 360 operations per hour (over 8,600
    operations per day, or 3,1000,000 over the course of a year), assuming they were
    not performed in parallel.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the message-queue provider goes down, preventing messages from being delivered
    in the first place, that could interrupt end user application usage.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Allocation of message queues will have to be given some consideration:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If each Artisan has their own queues, into and out of the Artisan Gateway, at
    least some data about those queues has to be stored and managed, and each Artisan-to-Gateway
    queue will have to be checked individually
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If all Artisans share one inbound queue to the Artisan Gateway, identification
    of which Artisan a given message originated with will have to be implemented for
    each operation
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since there is no implicit response requirement in the message protocol to indicate
    that it has been acted upon (or couldn't be because of an error), any response
    to a message that needs to be sent to a user will have to be actively/independently
    sent.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an Artisan, I need a message queue created for and assigned to me so that
    I can send my data changes to the Artisan Gateway.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message-queue implementation with RabbitMQ
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `hms_sys` projects will use RabbitMQ as its message-queue provider. RabbitMQ
    is actively maintained, and is a zero-cost solution, with paid support and consultation
    options, making it a good low-budget choice. Additionally, there is a ready-to-roll
    Python library, `pika` (installed with `pip install pika`) that provides all the
    critical functionality needed to send and receive messages from a RabbitMQ server,
    without having to get too far into the weeds implementing a solution from scratch.
    The makers of RabbitMQ, Pivotal Software, also offer a commercial version that
    includes additional management features along with support agreements.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: There are other options available for message-queue implementations, including
    cloud-based solutions from Amazon (SQS), Microsoft (Azure Service Bus), and Google
    (Cloud Pub/Sub), all of which have corresponding Python libraries available for
    use. Locally installable options include Apache Kafka and ActiveMQ, and Kestrel.
    There is also a general-purpose AMQP library available (`amqp`) that should allow
    connection to and interaction with any message queue service that uses at least
    a basic AMQP protocol.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Sending a message to a RabbitMQ instance with `pika` is fairly straightforward.
    Here''s a simple example, using the `DaemonMessage` class to generate and sign
    messages:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Since we''re transmitting a `DaemonMessage`, we need to generate a signing
    key and message data:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then we create the message:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we establish a connection to the RabbitMQ server:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then the message is sent, and the connection is closed:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Executing this script doesn''t generate any output, but verification that the
    message has been sent can be performed with the `rabbitmqctl` command-line tool:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c817168b-6d30-4c6e-ae3e-b6afc0782782.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: 'Running the script a second time, and then the `rabbitmqctl list_queues` tool,
    shows another message ready and waiting in the queue:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1cea8516-8d32-4bfe-bf16-3e6b40d4d652.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: 'RabbitMQ requires the provision of a channel (or perhaps queue name is as good
    a description) that provides organizational grouping for messages on the server,
    and that we''ll consider using to segregate messages by specific Artisans later
    on. Consider the following queue-name declarations:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, the preceding queue-name declarations are changed to the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When we review the queues and message counts with `rabbitmqctl list_queues`,
    we see that a new queue (`queue_name`) has appeared, with one message in it:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0c45be17-bafa-44ee-904b-0353ab8c6c29.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: 'Reading messages from a queue is a bit more complex, but not significantly
    so. An example script to read the messages sent to our queue by the previous runs
    of the `rabbitmq-sender.py` script starts much the same way:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We need to use the same signing-key value, otherwise the messages being retrieved
    won''t be allowed to be read:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Message-handling is dealt with by providing a callback function that accepts
    all of the message properties that are returned by the process of fetching a message
    from the queue:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It''s important that we wrap functionality for message-handling in a `try` ... `except`
    block, so that if something does go awry during the message-handling process,
    it doesn''t kill the main message-polling loop that we''ll set up later. In this
    case, at least one error could be raised: the `InvalidMessageError` error we defined
    earlier—it gets thrown if a `DaemonMessage` cannot be created because of an invalid
    signature:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The processes for creating a connection, and associating a channel or queue
    name to it, are the same:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this case, though, we''re consuming messages, rather than sending them,
    so we need to set that up:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we can start listening for messages:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'On execution, this script sets up its own event loop, listening for messages
    on the queue/channel specified. This is approximately equivalent to the event
    loop that `BaseDaemon.main` requires of derived daemon classes, though an actual
    daemon implementation might not use it. As soon as this script is run, it reads
    and outputs the content of the two messages sent earlier by the first script:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aee59828-f4b3-49d9-a3b2-341dd020bd5c.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: This also allows us to verify that the signatures of the two messages, with
    identical content and using the same signing key, are identical. This is expected
    behavior, given that message data and the signing key input did not change between
    sending the two messages.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine we change the signing key:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then rerun the same script; we get different results from our message listener:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/018a6a4a-3292-475b-8a5a-c12c3829351f.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: This serves as additional verification that the message-signing process will
    work as expected: Not allowing messages with invalid signatures to be created,
    and thus not being acted upon.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'That message-handling functionality, with one minor change, can serve as the
    basis for the `main` loop of the main class for the Artisan Gateway:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We still need a message-handling function, but now it''s defined as a method
    of the service class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `main` loop of the `ArtisanGatewayDaemon` class can start as a simple re-casting
    of the original functionality from the receiver script:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Initially, just to establish that the functionality needed is viable, we''ll
    use the same `signing_key`, `connection`, and `channel` values established earlier.
    Eventually, these will depend on configuration values – specifying the signing
    key, or at least where or how to get it – and depending on whether the final implementation
    goes down the path of having individual Artisan queues, there might be several
    queue-names/channels, or just the one. For now, having just the one that was used
    in the earlier script allows us to establish basic queue-reading functionality:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The base structure of the loop that `main` executes is similar to the structure
    of the main loop from the `testdaemon` of [Chapter 15](26ce9de7-eb44-4e33-afa2-fccb17e75aa8.xhtml), *Anatomy
    of a Service* – so long as the class' internal `_running` flag is `True`, the
    loop continues, performing the queue check and processing incoming messages. Once
    the loop is terminated, whether by the `stop` method of the class or by one of
    the signals that was registered during the execution of `BaseDaemon.__init__`
    by `ArtisanGatewayDaemon.__init__`, control exits and the `cleanup` method of
    the class is called before it terminates completely.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary difference, as should be expected, is what actually happens during
    each iteration through the loop. In this case, the `channel` is polled for the
    next available message, and if one is detected, it''s read, converted to a `DaemonMessage`,
    acknowledged, and handed off to the message-handler method defined earlier. It
    requires the same sort of `connection` and `channel`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once those are established, the `main` loop is very straightforward:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In order to test this, a quick, basic configuration file was assembled, mostly
    for logging information, and an instance of the new class was created with that
    configuration and started. The log output from startup to shutdown, including
    sending a good message, a bad message, then another good message, shows that everything
    operates as expected:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/47cc5788-d105-4bb8-94a2-f2549d060e10.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: 'The quick, basic configuration for this daemon instance is very simple:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The queue parameters should reside in the configuration file as well, and be
    acquired by the daemon instance. The additional configuration values end up looking
    like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The process for loading those values involves the addition of some instance
    properties that mostly follow the normal pattern in use thus far:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '`connection_params`: A dict value whose values are retrieved from the connection
    section of the config file that is used to create the RabbitMQ connection'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`queue_name`: A string, it is the queue-name/channel that the instance will
    listen to'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`signing_key`: A `bytes` or `str` value, it is the signing key that the instance
    will use to create `DaemonMessage` instances sent on or received from its queue'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Actually getting and storing those values involves nothing more than adding
    to the `_on_configuration_loaded` method of the class. Originally, all it did
    was call the same method of the `BaseDaemon` parent class in order to set up logging
    capabilities, and that remains the same:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Queue-specific items are retrieved next. Although there''s no expectation at
    this point that other queue systems will be needed, we can''t rule out that possibility
    in the future, so the code starts with the assumption that we''ll want to allow
    for that in the future:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The signing key is also in the configuration file, so acquiring and storing
    it comes next:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: At least for the time being, that takes care of all of the configuration needed
    to remove the hardcoded values that were in use in main, while keeping the class
    functional. Execution of a variant of the original message-sending script (in
    `scratch-space/rabbitmq-sender-daemon-queue.py` of the chapter code) showed that
    the daemon still functioned as expected with these changes – listening for and
    acting upon valid messages.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Handling messages
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to actually do something with the data of a message, we''ll need to
    define what a well-formed command message actually looks like, implement methods
    to execute the commands that are allowed, and implement functionality that knows
    how to call those methods, given a well-formed and verified message to do so.
    The first item from that list is quite simple, but could have a lot of different
    valid implementation patterns. Consider that, at this point, we''re allowed to
    transmit four different operation actions by `DaemonMessage`: `''create''`, `''update''`,
    `''delete''`, and `''response''`. These operation actions correspond directly
    to standard CRUD operations, except for the `''response''` value, though even
    that is, perhaps, roughly equivalent to a `read` operation. For any given data
    object type, those operations would, respectively, need to execute the same processes:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Create a new instance of the relevant class, populated with state data from
    the message, using the `from_data_dict` class method (or a new equivalent class
    method, perhaps), and `save` the new instance
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve an existing instance of the relevant class, using the `get` class method,
    update any of that instance's state data with new values from the message (which
    would probably benefit from having a new method created, perhaps `update_from_message`),
    and `save` the instance
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find and delete the instance specified by the message data with the `delete`
    class method
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve and return the data dict representation of the instance specified by
    the message data, using the `get` class method to perform the retrieval, and the
    `to_data_dict` method of the found instance to generate the data structure of
    the message
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The daemon, then, needs to have as many as 16 `{action}_{object}` methods,
    one for each action/object combination, just to ensure that all of the combinations
    are accounted for. For each object type (Artisans, Customers, Orders, and Products),
    the set of methods would look something like this (the method names are self-explanatory):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '`create_artisan`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update_artisan`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete_artisan`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`response_artisan`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The one critical piece of data that isn''t yet accounted for, and is needed
    to determine which of those methods to execute on receipt of a command message,
    is the object type. The `DaemonMessage` class doesn''t have a specific property
    for object types, because the initial thought was that doing so could needlessly
    limit future uses of it to messages that have both an `operation` and an object
    type. Revising `DaemonMessage` to allow an object-type specification wouldn''t
    be difficult. It would involve little more than adding an optional property, allowing
    another optional argument in the `__init__` method, and any other methods that
    call it, and accounting for it in the dictionary output methods. Going to those
    lengths, though, seems unnecessary: the messages themselves, as structured data,
    can just as easily contain the necessary data. As an example, consider a "create
    Artisan" message that looks like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If any command message has an operation and indicates in its data an object
    type (the `target` value) with the properties to be used in the operation as a
    standard structure, that would work just as well. Similar data structures will
    also work for update operations:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For delete operations:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As well as for response operations:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Determining which method to call based on the message''s operation and `data.target`
    values is simply a long chain of `if…elif…else` decisions:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Since we''ll need the target (for decision-making later) and the properties
    (to pass as arguments to the method), get those first:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Each combination of `operation` and `target` looks very much like the others.
    Starting with `create` operations:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If the target is one of the known, allowed types, then we can just call the
    appropriate method:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If the `target` is not known, we want to throw an error:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The other operations work much the same way – `update` operations, for example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `delete` and `response` operations are similar enough that there''s little
    point in reproducing them here, but they are present in the code. Finally, we
    also capture cases where the operation isn''t recognized, and raise an error in
    those cases as well:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The actual operation methods are, as a result of the data object design/structure
    and the structure of the incoming messages, relatively simple. Creation of an
    `Artisan`, for example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Update of an `Artisan`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Deletion of an `Artisan`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`Artisan` response:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Queues and related Artisan properties
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Artisans will communicate with the Gateway over specific queues, and those
    queues have to be identified and consistently associated with their respective
    Artisans, we'll need to have mechanisms in the various code bases to store queue
    identifiers, and to associate them with their Artisan owners.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'The queue specifications themselves can be implemented simply by adding a property
    (`queue_id`) to the `Artisan` objects'' classes. Since the Artisan objects at
    both the Gateway service and Artisan application will make use of `queue_id`,
    it makes sense to implement that in the `hms_core.business_objects.BaseArtisan`
    class, where it will be inherited everywhere it''s needed. The property getter
    and deleter methods are typical implementations, as is the `property` declaration,
    though it follows a read-only property pattern. The setter method is pretty typical
    also:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Artisans will also need to keep track of a signing key property that is unique
    to each Artisan, but exists in both the local `Artisan` objects at the Artisan
    Application side of the message-transmission process and at the Artisan Gateway
    side. Signing keys, as `bytes` values, may not be easily stored in their native
    value types, though: `bytes` values are not natively JSON-serializable, which
    is problematic for the local Artisan data storage already implemented, and could
    be problematic for the MongoDB storage in use elsewhere.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the `bytes` type provides instance and class methods to serialize
    and unserialize values to and from hexadecimal string values. Serializing a byte''s
    value is as simple as calling the `hex()` method of the value, and creating a
    bytes value from a hex string is accomplished by calling `bytes.fromhex(hex_string)`.
    A simple example of a complete serialization/unserialization of a bytes value
    using `hex()`/`fromhex()` shows that the value is preserved as needed:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output of this code will look like the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6e5794ea-6adf-401d-91a9-7782d7c5fd24.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
- en: 'The corresponding property of the Artisan classes (`signing_key`) follows the
    typical read-only property structure too, and apart from its setter method, is
    nothing unusual. The setter method has to allow both raw `bytes` values and hex
    string representations of `bytes` values, and *stores* a `bytes` value:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If it''s passed a string, it tries to convert that using `bytes.fromhex()`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'It also enforces a minimum length of the signing key, arbitrarily set to `64`
    bytes (512 bits):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The corresponding final `Artisan` objects have to account for these new properties
    in their `to_data_dict` methods and `__init__` methods. The `to_data_dict` changes
    look the same – using `hms_core.co_objects.Artisan` as an example, and showing
    the new properties added to the end of the dict result returned, they end up looking
    like this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The changes to the `__init__` methods vary somewhat: since the new `queue_id`
    and `signing_key` properties are assigned as `BaseArtisan.__init__` executes,
    that method has to actually call the deleter and setter methods:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Since `queue_id` and `signing_key` are technically required properties, if time
    allowed, moving them into the required-arguments portion of the `__init__` signature,
    between `address` and `company_name`, would be the right thing to do. In this
    case, it's more a matter of space constraints than time, so they're being added
    into the signature at an easy location to deal with instead, rather than having
    to review, modify, and reshow all of the various `BaseArtisan.__init__` calls
    that already exist in the code. They'll still work as required properties, though,
    since the setter methods won't accept the default `None` values, and they're being
    called without the sort of checking that `company_name` and `website` use.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__init__` methods of `co_objects.Artisan` and `artisan_objects.Artisan`
    only have to be updated to include the new arguments in their signatures and pass
    those along to their `BaseArtisan.__init__` calls. The revisions to `co_objects.Artisan.__init__`
    look like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Requirements for a web-service-based daemon
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we were to pursue a web-service-based implementation for the Artisan Gateway
    instead, there are several common factors, and a few hurdles that would have to
    be overcome. Arguably the most significant hurdle would be in implementing the
    full set of `HTTP` methods – `POST`, `GET`, `PUT`, and `DELETE` – the official
    and standards-compliant methods that correspond to the `Create`, `Read`, `Update`,
    and `Delete` CRUD operations we're expecting to use.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'If the medium that commands are transmitted in is to remain the serialized
    and signature-bearing message output of the `DaemonMessage` class, we''d need
    to be able to pass a complete, signed message in at least two different ways:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'In a query string format for the `GET` and `DELETE` operations: GET isn''t
    intended to support the same sort of payload capabilities that `POST` and `PUT`
    methods allow, and though there doesn''t seem to be any official stance as to
    whether `DELETE` should or should not support it, it''s probably safest to assume
    that it won''t, and write code accordingly.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In as many as two different payload formats for POST and PUT operations. Thus
    far, we haven''t addressed any of the Product data in any detail; even if there
    is no requirement to support the transmission of product images, it''s just a
    matter of time until one would surface. The `HTTP POST` and `PUT` operations allow
    a payload to be sent in the request body, and allow that payload to be sent in
    two different formats (encodings) in a standard web form request context:'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a key-value string list that looks very much like the equivalent in a `GET`
    request
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a more detailed encoding, where each field in the request has the same name
    and data as the key-value list, but also allows fields to specify that they contain
    specific data types – Files, for example, with other data, such as the filename
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The latter encoding is seen in web pages that allow file uploads as an `enctype="multipart/form-data"`
    attribute in the relevant `<form>` tag. Submitting such a form, with two files
    included in the payload, will generate an `HTTP` request that might look something
    like this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0cb06097-c8d9-4427-a023-f4fdc885b6b5.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
- en: 'In this example:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '`{field-separator}` is a random string that uniquely identifies the beginning
    of each field''s dataset'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{content-length}` is the total size of the payload'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{field-name}` is the name of the field whose data is wrapped in the section'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{field-value}` is text data from a field that is not a file-upload field'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{file-name}` is the name of the file being uploaded, as it existed on the
    client machine'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{MIME-type}` is an indicator of the type of file being transmitted, for example
    `image/png`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{file-data}` is the data of the file corresponding to the field'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to support a payload with just these three chunks of data, we'd have
    to find or create code that can reliably parse out each data section and handle
    each data chunk that gets spat back out. While there is at least one such library,
    `requests-toolbelt`, there are known issues with it in certain core Python versions
    (3.3.0 and 3.3.1), so it may or may not be a viable option depending on what Python
    version is in play. Writing (and testing) code from scratch to deal with `multipart/form-data`
    payloads would be a time-consuming process at best.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that all of that is dealt with, although it's not difficult to write
    network listeners that would be able to capture and handle an incoming request,
    that too could involve a fair chunk of time, particularly on the testing side
    of things, just to be able to reliably (and provably) handle incoming requests.
    In a web service scenario, it would almost certainly be a better option to start
    with one of the well-established web application packages that already deals with
    all of those needs and requirements, and write code that simply maps incoming
    requests to the handler methods, in much the same way that the message-queue implementation
    does. On the plus side, the signed messages should be usable in that context,
    and the underlying operation methods would likely not have to be modified to any
    significant degree.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Traffic to and from the service
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The message-receiving aspect of the communication chain by the service is already
    in place, in the `main` method of `ArtisanGateway`, but no message-sending functionality
    has been implemented yet, apart from the bits and pieces focused around message
    generation. Each data object type, when modified, created, or deleted, is going
    to need to send a relevant command message to its counterpart subsystem. For example,
    if an Artisan creates a new Product, the act of creating that `Product` object
    needs to send a "create product" message to the Gateway service. Likewise, if
    a change is made to a Product by Central Office staff, the Gateway service needs
    to send an "update product" message to the appropriate Artisan Application instance.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Artisan Application side of those scenarios, all of the queue parameters
    needed to send any message are going to be constant. They will always send messages
    to the same queue server, on the same port, using the same connection and channel.
    Rather than requiring all of the message-queue settings to be passed to all of
    the various data objects during initialization, which could complicate them significantly,
    and make the code difficult to deal with if a different message-transport mechanism
    were needed later on, we can create another class that contains all of those and
    provides a method for sending arbitrary messages to the queue server: `RabbitMQSender`.
    In the process of defining that class, we can also leverage certain aspects of
    Python class/instance relationships to make the creation of sender instances considerably
    easier:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: An instance of a Python class that has defined class attributes also has instance
    attributes with the same name and value. That is, if `RabbitMQSender` has a class
    attribute named `_host`, with a value of localhost, all instances of `RabbitMQSender`
    will, when created, have a `_host` attribute with the same localhost value.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing an instance attribute's value will have no effect on the class attribute's
    value.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing a class attribute's value will also change the corresponding instance
    values, provided that they haven't been explicitly set in those instances. So,
    if an instance of `RabbitMQSender` is created, then `RabbitMQSender._host` is
    changed, and the `_host` value of the instance will be updated accordingly.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taken together, and with some caution in design when applied, these allow `RabbitMQSender`
    to be defined so that the *class* can be configured, allowing a usable instance
    of the class to be created with nothing more than the most basic of calls, along
    the lines of `my_sender = RabbitMQSender()`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: If a different message-transport mechanism were to be needed later, it would
    probably be a good idea to introduce a layer of abstraction that `RabbitMQSender`
    would derive from – `BaseMessageSender`, perhaps – that would require the message-sending
    method and all of the relevant transport-mechanism properties. That would provide
    a common interface for all transport mechanisms, and make it a lot easier to switch
    between them if/as needed.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '`RabbitMQSender`, then, starts as a typical class-definition, with the various
    connection properties and any other message-transmission constants defined as
    protected class attributes:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The properties that correspond to those have only getter methods, so that they
    cannot be easily/accidentally altered:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'They are associated with property names in a typical read-only property structure:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `connection` and `channel` properties follow a typical lazy-instantiation
    pattern, being created on the first request for either of them, and are also exposed
    as read-only properties:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'There are no property-setter or -deleter methods needed, nor is there any functionality
    needed in `__init__` for the class. All of an instance''s properties will effectively
    refer back to the class attribute values, which can be set with a single class
    method call:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In the context of an Artisan Application, all that needs to be done to preconfigure all
    instances of `RabbitMQSender` is to call `RabbitMQSender.configure` with the appropriate
    settings, probably taken from the configuration file of the Artisan Application
    instance:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Finally, the process of sending messages is provided by a single method:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: On the Artisan Application side of the message-transfer processes, the creation
    of a `RabbitMQSender` instance and calling its `send_message` method should take
    care of the actual message transmission we'll need. On the Artisan Gateway side,
    when sending messages to Artisan Application instances, the process will be similar –
    simplified in some ways, possibly not needing the `RabbitMQSender` (or an equivalent)
    class, or perhaps needing a similar variant in order to better handle multiple
    outgoing queues. We'll integrate the Artisan-side processes and examine the Gateway
    needs in more detail in [Chapter 17](b21d33e8-90c4-4a67-af0e-9fc0211d8e3a.xhtml), *Handling
    Service Transactions*.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Impacts on testing and deployment
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point in the iteration, apart from standard unit-testing for various
    properties and methods that aren't involved in any message transmission, there's
    not much that can be done from a testing standpoint. We have yet to integrate
    messaging with data changes, which we'll examine in [Chapter 17](b21d33e8-90c4-4a67-af0e-9fc0211d8e3a.xhtml), *Handling
    Service Transactions*, and without a complete send-and-receive process available,
    in either direction, there's not much that can be done, even from a manual-testing
    perspective, that hasn't already been explored.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: It also feels premature to work out any deployment details for the Artisan Gateway
    daemon just yet, for similar reasons, though at this point, it feels like a very
    basic `setup.py/Makefile` arrangement will probably handle everything we'll need.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although we now have all the foundations needed to work through and close the
    14 stories that the iteration stated with, only three are even potentially closed:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: As an Artisan, I need to be able to send data changes to the Artisan Gateway
    so that those changes can be propagated and acted upon as needed
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a Central Office user, I need to be able to send data changes to the Artisan
    Gateway so that those changes can be propagated and acted upon as needed
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As any user sending messages across to or from the Artisan Gateway service,
    I need those messages to be signed so that they can be validated before being
    acted upon
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those foundations include, however, a functional (if untested) Artisan Gateway
    daemon/service, a mechanism for generating command messages that can be acted
    upon by that service and the remote applications, and the basic processes for
    actually transmitting those command messages. Between those accomplishments, the
    odds are good that we've actually closed these three stories, but until they are
    tested, we cannot prove that they can be.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: The requisite testing to prove closure, and the balance of the stories still
    to be implemented, all rely on integrating the various CRUD operations at the
    data-object level in the Artisan and Central Office applications with the requisite
    messaging to propagate those data changes to the Artisan Gateway, and (where needed)
    from the Gateway to the remote Artisan and Central Office applications, which
    we'll address in the next chapter.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
