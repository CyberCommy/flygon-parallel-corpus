- en: Building and Deploying Go Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have come up with a method to write performant Go code, we need to ship
    it, validate it, and continue iterating it. The first step of this process is
    to deploy the new Go code. Go's code is compiled into binaries, which allows for
    the modular deployment of new Go code as we iterate through code development.
    We can push this out to one or multiple places in order to test against different
    environments. Doing this will allow us to optimize our code to fully utilize the
    throughput that will be available to us in our system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn all about the Go build process. We''ll look
    at how the Go compiler builds binaries, and we''ll use this knowledge to build
    right-sized, optimized binaries for the platform at hand. We will cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building Go binaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `go clean` to remove object files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `go get` to download and install dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `go mod` for dependency management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `go list` to list packages and modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `go run` to execute programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `go install` to install packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These topics will help us build efficient Go binaries from our source code.
  prefs: []
  type: TYPE_NORMAL
- en: Building Go binaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 10](6a020af6-5b7c-48af-95a7-cf52014ae1ca.xhtml), *Compile Time Evaluations
    in Go*, we discussed some Go build optimizations that can potentially help optimize
    our build strategy. Go's build system has quite a few options that can help the
    system operator add additional parameterization to their build strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go tool has many different methodologies for building our source code.
    Let''s investigate top-level understandings of each, and then we will discuss
    each package in more depth. Knowing the key differences between these commands
    may help you to understand how they interplay with one another and choose the
    right tool for the job. Let''s have a look at them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`go build`: Builds a binary for your project, compiling packages and dependencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go clean`: Removes object and cached files from package source directories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go get`: Downloads and installs packages and their dependencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go mod`: Go''s (relatively new) built-in dependency module system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go list`: Lists named packages and modules and can display important build
    information about files, imports, and dependencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go run`: Runs and compiles a named Go program'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go install`: Builds the binary for your project, moves the binary to `$GOPATH/bin`,
    and caches all non-main packages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we are going to investigate these different pieces of the Go
    build system. As we learn more about how these programs interoperate with one
    another, we will be able to see how to use them to our advantage to build slim,
    feature-filled binaries that will work as we expect them to on the supported architectures
    and operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we shall see through `go build`.
  prefs: []
  type: TYPE_NORMAL
- en: Go build – building your Go code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The invocation stanza for go build is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Defining an output with `-o` compiles a binary using a specifically named file.
    This is helpful when you have a particular naming convention that you want to
    keep for your file, or if you want to name binaries based on different build parameters
    (platform/OS/git SHA and others).
  prefs: []
  type: TYPE_NORMAL
- en: Packages can be defined as a list of go source files or they can be omitted.
    If a list of go source files is specified, the build program will use the list
    of files that were passed as a group that specifies a single package. If no packages
    are defined, the build program will validate that the packages within the directory
    can be built, but it will discard the results of the build.
  prefs: []
  type: TYPE_NORMAL
- en: Build flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go''s build flags are all shared by the `build`, `clean`, `install`, `list`,
    `run`, and `test` commands. A table stating the build flags and their usage descriptions
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Build flag** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `-a` | Forces packages to be rebuilt. This can be especially handy if you''d
    like to make sure that all of your dependencies are up to date. |'
  prefs: []
  type: TYPE_TB
- en: '| `-n` | Prints the commands that the compiler utilizes but doesn''t run the
    commands (akin to a dry run in other languages). This is useful to see how a package
    gets compiled. |'
  prefs: []
  type: TYPE_TB
- en: '| `-p n` | Parallelizes your build commands. By default, this value is set
    to the number of CPUs that are available to the build system. |'
  prefs: []
  type: TYPE_TB
- en: '| `-race` | Enables race detection. Only certain architectures have the ability
    to detect race detections:'
  prefs: []
  type: TYPE_NORMAL
- en: linux/amd64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: freebsd/amd64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: darwin/amd64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: windows/amd64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `-msan` | Detects uninitialized memory reads in C. This is only supported
    on Linux with amd64 or arm64 architectures, and it is necessary to use a clang/LLVM
    compiler for the host. This can be called with `CC=clang go build -msan example.go`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-v` | As the program is compiled, the names of the packages that are built
    are listed to stdout. This can help verify which packages are used for the build.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-work` | Prints the value of the temporary work directory Go uses in order
    to build the binary. This is usually stored in `/tmp/` by default. |'
  prefs: []
  type: TYPE_TB
- en: '| `-x` | Shows all of the commands that were used during the build process.
    This can be helpful to determine how a package is built. See the *Build information*
    section for more information. |'
  prefs: []
  type: TYPE_TB
- en: '| `-asmflags ''[pattern=]arg list''` | A list of arguments to pass when `go
    tool asm` is invoked. |'
  prefs: []
  type: TYPE_TB
- en: '| `-buildmode=type` | This tells the build command which type of object file
    we''d like to build. There are currently a couple of type options for `buildmode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`archive`: Builds non-main packages into `.a` files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c-archive`: Builds the main package and all of its imports into a C archive
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c-shared`: Builds the main package and its imports into a C shared library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default`: A list of main packages is created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shared`: Combines all non-main packages into a single shared library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exe`: Builds main packages and their imports into executables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pie`: Builds main packages and their imports into **position-independent executables** (**PIE**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`plugin`: Builds main packages and their imports into a Go plugin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `-compiler name` | Determines which compiler to use. Common uses are `gccgo`
    and `gc`. |'
  prefs: []
  type: TYPE_TB
- en: '| `-gccgoflags` | `gccgo` compiler and linker invocation flags. |'
  prefs: []
  type: TYPE_TB
- en: '| `-gcflags` | `gc` compiler and linker invocation flags. See the *Compiler
    and linker* section for more details. |'
  prefs: []
  type: TYPE_TB
- en: '| `-installsuffix suffix` | Adds a suffix to the name of the package installation
    directory. This is used in order to keep the output separate from default builds.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-ldflags ''[pattern=]arg list'' ` | Go tool link invocation arguments. See
    the *Compiler and linker* section for more details. |'
  prefs: []
  type: TYPE_TB
- en: '| `-linkshared` | After a `-buildmode=shared` invocation occurs, this flag
    links against the newly created shared libraries. |'
  prefs: []
  type: TYPE_TB
- en: '| `-mod` | Determines which module download mode to use. At the time of writing,
    there are two options: `- readonly` or `vendor`. |'
  prefs: []
  type: TYPE_TB
- en: '| `-pkgdir dir` | Utilize the `dir` defined to install and load all packages.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-tags tag,list` | A list of build tags that are to be satisfied during the
    build. This list is passed as a comma-separated list. |'
  prefs: []
  type: TYPE_TB
- en: '| `-trimpath` | The resulting built executable will use a different naming
    scheme for filesystem paths during an executable build. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Go (for the standard library)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: path @version (for go modules)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: plain import path (while using `GOPATH`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `-toolexec ''cmd args''` | Invokes toolchain programs, such as debuggers
    or other interactive programs. This is used for programs such as vet and asm. 
    |'
  prefs: []
  type: TYPE_TB
- en: With all of this information, you'll be able to build correct linker flags impactfully.
  prefs: []
  type: TYPE_NORMAL
- en: Build information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To garner some understanding of the build process, let's take a look at some
    build examples so we can gain some insight into how the build tooling works together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to build a simple HTTP server that has a Prometheus exporter.
    We can create an exporter like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have our package ready, we can build our package with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As we build this binary, we will see a couple of things coming back to stdout
    (since we passed the `-x` flag to see the commands that were used during the process).
    Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to truncate the output so that the results are easier to read.
    If you test this out yourself, you''ll see a much larger build output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This sets a temporary working directory for the build. As we mentioned previously,
    this usually lives in the `/tmp/` directory unless otherwise specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A sub-working directory is also created by the compiler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A linking configuration is created and added. This adds all sorts of different
    arguments to the linking configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The package for command-line arguments is referenced from the cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`fmt` is the printing package we use to display `fmt.Println("Prometheus Handler
    listening on port ", port)`. This is referenced like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The compiler also adds the package for the Prometheus HTTP client library. After
    this, there are many other references that are added to the build. This has been
    truncated for brevity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The end of the file is signified with `EOF`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An executable directory is created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler then builds the binary using the `importcfg` that was created
    earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A `buildid` is then added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the binary is renamed to the filename we had for our exporter example
    (since we did not specify a different binary name with `-o`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the work directory is removed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The output of the work from this program is a Go binary. In the next section,
    we'll talk about compiler and linker flags.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler and linker flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While building a Go binary, the `-gcflags` flag lets you pass optional compiler
    arguments, while the `-ldflags` flag lets you pass optional linker arguments.
    A full list of compiler and linker flags can be found by invoking the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at an example of utilizing compiler and linker flags. We can build
    a simple program that returns the value of an uninitialized string variable. The
    following program seems innocuous enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we build this with some of the common compiler and linker flags, we will
    see some helpful output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/035f3d29-623d-495c-85a2-11918dda45ca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The compiler flags that we passed here achieve the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"-m -m"`: Prints information about the compiler''s optimization decisions.
    This is the output that we can see in the preceding screenshot after the build
    command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"-N"`: Disables optimizations within the Go binary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"-l"`: Disables inlining.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The linker flags that we passed do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"-X main.linkerFlag=Hi_Gophers"`: Sets a value for the `linkerFlag` variable
    in `main`. Being able to add a variable during build time is important as many
    developers want to add some sort of build parameter to their code during compilation
    time. We can pass a build date using ``date -u +.%Y%m%d%.H%M%S`` or a git commit
    version using `git rev-list -1 HEAD`. These values can be helpful later for referencing
    the state of the build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"-s"`: Disables the symbol table, a data structure that stores each identifier
    in the source code alongside declaration information. This is often not needed
    for production binaries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"-w"`: Disables DWARF generation. The dwarf table often doesn''t need to be
    saved since the Go binary includes basic type information, PC-to-line data, and
    a symbol table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we build the binary using a standard method followed by using some of the
    compiler and linker flags we have available, we will be able to see a difference
    in binary size:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Non-optimized build:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Optimized build:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the `Optimized` binary is 28.78% smaller than the `nonOptimized`
    binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96137129-bf02-41ac-a309-f719fda97509.png)'
  prefs: []
  type: TYPE_IMG
- en: Both of these binaries will perform the same function for the end user, so consider
    removing some of the build optimizations using compiler and linker flags in order
    to reduce the end resulting binary size. This can be beneficial during the storage
    and deployment of said binaries.
  prefs: []
  type: TYPE_NORMAL
- en: Build constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you'd like to add a build constraint to your Go build, you can add a comment
    line at the beginning of the file that's only preceded by blank lines and other
    comments. The form of this comment is `// +build darwin,amd64,!cgo, android,386,cgo`.
  prefs: []
  type: TYPE_NORMAL
- en: This corresponds to a boolean output of `darwin AND amd64 AND (NOT cgo)) OR
    (android AND 386 AND cgo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This needs to proceed with the package declaration with a newline between the
    build constraint and the package initialization. This takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete list of build constraints can be found at [https://golang.org/pkg/go/build/#hdr-Build_Constraints](https://golang.org/pkg/go/build/#hdr-Build_Constraints).
    This list includes the following build constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GOOS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GOARCH`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiler type (`gc` or `gccgo`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cgo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the 1.x Go versions (no build tags for beta or minor releases)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional words that are listed in `ctxt.BuildTags`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you have a file in your library that you''d like to exclude from your build,
    you can also add a comment in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Inversely, you can restrict file builds to specific `GOOS`, `GOARCH`, and `cgo`
    bits using a comment in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will only build a file when you're using `cgo` and building on a 386 processor
    in a Windows operating system. This is a powerful construct in the Go language
    because you have the ability to build packages based on the necessary build parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Filename conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a file matches the `GOOS` and `GOARCH` patterns after stripping any extensions
    and the `_test` suffix (for test cases), the file will be built for that particular
    `GOOS` or `GOARCH` pattern. Patterns like so are often referenced as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*_GOOS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*_GOARCH`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*_GOOS_GOARCH`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, if you have a file that's named `example_linux_arm.go`, it will
    only be built as part of the Linux arm builds.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore the `go clean` command.
  prefs: []
  type: TYPE_NORMAL
- en: Go clean – cleaning your build directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go command builds binaries in a temporary directory. The go clean command
    was created in order to remove extraneous object files that are created by other
    tools or when go build is manually invoked. Go clean has a usage stanza of `go
    clean [clean flags] [build flags] [packages]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following flags are available for the clean command:'
  prefs: []
  type: TYPE_NORMAL
- en: The `-cache` flag removes the entire go build cache. This can be helpful if
    you're trying to compare a fresh build across multiple systems or if you'd like
    to see the amount of time a fresh build takes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-i` flag removes the archive or binary that go install creates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-n` flag is a noop; printing the result removes commands but doesn't execute
    them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-r` flag applies logic recursively to all the dependencies of the import
    path's packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-x` flag prints and executes the remove commands that were generated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-cache` flag removes the whole go build cache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-testcache` flag removes the test results in the build cache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-modcache` flag removes the module download cache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we want to attempt a clean build with no existing dependencies, we can use
    a command to remove items from many of the important caches in the go build system.
    Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will build our `prometheusExporterExample` in order to validate the size
    of the build cache changing. We can find our build cache location using the go
    environment `GOCACHE` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/02570ce5-f34e-400f-a39f-184fec134edb.png)'
  prefs: []
  type: TYPE_IMG
- en: For our validation, we'll use a couple of commands in a row. First, we'll remove
    our entire cache directory with `rm -rf ~/.cache/go-build/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we can build our Go binary by running the `go build prometheusExporterExample.go` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we can validate that the cache has grown significantly in size by checking
    its size with `du -sh ~/.cache/go-build/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can clean the caches using the go clean program, that is, `go clean
    -cache -modcache -i -r 2&>/dev/null`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's important to note that some of the cache information is stored in main
    libraries, so that can't be removed by a normal user. We can get around this if
    needed by running the clean command as a superuser, but this isn't often recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can validate that the cache has shrunk in size. If we look into the
    cache directory after the clean, we''ll see that we only have three items left
    in the cache directory:'
  prefs: []
  type: TYPE_NORMAL
- en: A `README` file explaining the directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `log.txt` file that tells us about cache information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `trim.txt` file, which tells us the time of the last completed cache trim.
    In the following screenshot, we can see a cleaned build cache:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/bd4592fa-bed5-483e-b348-d476141c9533.png)'
  prefs: []
  type: TYPE_IMG
- en: Validating that you're caching the correct things as part of the build will
    speed up the build process and make for a less toilsome development experience.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll look at the `go get` and `go mod` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving package dependencies with go get and go mod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you construct Go programs, you'll likely run into places where you'd like
    to add dependencies. `go get` downloads and installs packages and their dependencies.
    The invocation stanza for `go get` is `go get [-d] [-f] [-t] [-u] [-v] [-fix]
    [-insecure] [build flags] [packages]`.
  prefs: []
  type: TYPE_NORMAL
- en: Go 1.11 added preliminary support for Go modules. We learned how to utilize
    Go modules in [Chapter 6](3ce4cee8-eaaa-4a6d-b817-4fdd3899f973.xhtml), *Composing
    Readable Go Code*, under the *Go modules* section.
  prefs: []
  type: TYPE_NORMAL
- en: A Go mod vendor is often included as part of the Go build system since we can
    use vendored dependencies in our Go programs. There are positives and negatives
    to vendoring dependencies in your code base. Having all of the required dependencies
    available locally during build time can make the build faster. If the upstream
    repository that you're using for your build dependencies changes or is removed,
    you'll have a build failure. This is because your program won't be able to satisfy
    its upstream dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The negatives to having vendored dependencies include the fact that vendoring
    dependencies puts the onus of keeping the packages up to date on the programmer
    – updates from the upstream such as security updates, performance improvements,
    and stability enhancements could be lost if a dependency is vendored and not updated.
  prefs: []
  type: TYPE_NORMAL
- en: Many enterprises take the vendored approach as they feel the safety of storing
    all of the required dependencies outweighs the need to update the vendored directory
    with newer packages from upstream as they become available.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we initialize our go module, we vendor our dependencies and build them
    using our vendored modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/afb44250-21d2-4722-b549-e2200876aef3.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding output, we have vendored dependencies (from [https://github.com/](https://github.com/)
    and [https://golang.org/](https://golang.org/)) that are needed to satisfy our
    build constraints in our project. We can use `go mod tidy` in our builds to validate
    that `go.mod` contains all of the necessary elements for the repository.
  prefs: []
  type: TYPE_NORMAL
- en: '`go mod tidy` adds missing modules and removes unused modules in order to validate
    our source code with the directory''s `go.mod` matches.'
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will learn about the `go list` command.
  prefs: []
  type: TYPE_NORMAL
- en: Go list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`go list` performs the action of listing named packages and modules, as well
    as displaying important build information about files, imports, and dependencies.
    The invocation stanza for go list is `usage: go list [-f format] [-json] [-m]
    [list flags] [build flags] [packages]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having access to the data structures that are the main pieces of the build
    process is powerful. We can use `go list` to find out a lot about the programs
    that we are building. For example, take the following simple program, which prints
    a message and computes a square root for the end user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If we want to find out about all the dependencies that we have for our particular
    project, we can invoke the `go list -f '{{.Deps}}'` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result will be a slice of all of the dependencies that our repository contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f971b2e1-767a-4219-a5a0-4e9adb984b7c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `go list` data structure can be found here: [https://golang.org/cmd/go/#hdr-List_packages_or_modules](https://golang.org/cmd/go/#hdr-List_packages_or_modules).
    It has many different parameters. One of the other popular outputs from the go
    list program is the JSON formatted output. In the following screenshot, you can
    see the output from executing `go list -json` for our `listExample.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2057923f-07ed-46e1-8575-eda631d7289c.png)'
  prefs: []
  type: TYPE_IMG
- en: '`go list -m -u all` will also show you the dependencies that you have. The
    resulting output will also have a second version listed in brackets, if they have
    available upgrades. This can be helpful if we want to closely monitor our dependencies
    and their upgrades using the `go mod` package.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use our Prometheus exporter example, we can see whether or not our packages
    have dependencies that need upgrading:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d12a5df1-df63-46d7-892f-46950cec2002.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we can see that there are a couple of packages that have available
    upgrades. If we invoke go get for one of these dependencies, we'll be able to
    upgrade them effectively. We can upgrade the errors package listed in the preceding
    screenshot from v0.8.0 to v0.8.1 using `go get github.com/pkg/errors@v0.8.1`.
  prefs: []
  type: TYPE_NORMAL
- en: After we complete this upgrade, we can validate that the dependency has been
    upgraded by running `go list -m -u github.com/pkg/errors`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this output in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67ab2f1e-f1ae-4815-81af-79a0079e09d2.png)'
  prefs: []
  type: TYPE_IMG
- en: In our preceding output, we can see that the errors package that's being referenced
    is now v0.8.1, rather than v0.8.0, which was shown in our previous output.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's take a look at what `go run` is.
  prefs: []
  type: TYPE_NORMAL
- en: Go run – executing your packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`go run` runs and compiles a named Go program. The invocation stanza for `go
    run` is `go run [build flags] [-exec xprog] package [arguments...]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Go run allows a developer to quickly compile and run a go binary in one operation.
    During this process, `go run` builds the executable file, runs it, and then deletes
    the executable file. This is particularly helpful in a development environment.
    As you rapidly iterate on your Go program, `go run` can be used as a shortcut
    to validate that the code you are changing will result in a build artifact that
    you deem acceptable for use. As we learned earlier in this chapter, the build
    flags for many of these tools are consistent.
  prefs: []
  type: TYPE_NORMAL
- en: '`goRun.go` is one of the simplest possible go programs. It has no arguments,
    just an empty `main()` function invocation. We are using this as an example to
    show this process with no additional dependencies or overhead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We can see the work output associated with a `go run` invocation by executing
    the `go run -x goRun.go` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we perform this action, we will be able to see the build parameters that
    are being called as part of the `go run` program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d4b103a-02c9-44da-aeeb-7bc01600dfff.png)'
  prefs: []
  type: TYPE_IMG
- en: This should seem eerily familiar as the output closely resembles the output
    we saw in our go build example. Then, we can see our package being invoked.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to perform this same action with our Prometheus HTTP server, we would
    see that our Prometheus HTTP server is started and run as the result of executing
    the `go run` program. After we kill our process during this go run invocation,
    we'll notice that we don't have any binaries stored in our local directory. The
    `go run` invocation doesn't save these outputs by default.
  prefs: []
  type: TYPE_NORMAL
- en: The Go command in the next section (`go install`) is the last one for this chapter.
    Let's see what it is all about.
  prefs: []
  type: TYPE_NORMAL
- en: Go install – installing your binaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`go install` compiles and installs a named Go program. The invocation stanza
    for go run is `go install [-i] [build flags] [packages]`'
  prefs: []
  type: TYPE_NORMAL
- en: These are imported to `$GOPATH/pkg`. Cached items will be used on the next compilation
    if they haven't been modified. The resulting output from go install is an executable
    file that is the same as the one that gets compiled with a go build command, installed
    on the `$GOBIN` path on the system. For example, if we wanted to install our Prometheus
    HTTP server on our host, we could invoke a go install command, that is, `GOBIN=~/prod-binaries/
    go install -i prometheusExporterExample.go`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting our `GOBIN` variable tells the compiler where to install the compiled
    binary after compilation is complete. The go install program allows us to install
    the binary to our `GOBIN` location. The `-i` flag installs the dependencies of
    the named packages. We can see this in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a01089af-4fdb-4474-8777-e0b192bc60dd.png)'
  prefs: []
  type: TYPE_IMG
- en: After this is completed, we can see that we have a `prometheusExporterExample`
    binary available in the `GOBIN` location that we defined in our example.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming and the last section of this chapter, we shall see how to build
    Go binaries with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Building Go binaries with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on your target architecture, you may wish to build your Go binaries
    with Docker to maintain a reproducible build, limit your build size, and minimize
    the attack vectors for your service. Using multistage Docker builds can help us
    to accomplish this task.
  prefs: []
  type: TYPE_NORMAL
- en: To perform these actions, you must have a recent version of Docker installed.
    The multistage builds feature that we are going to use requires Docker version 17.05
    or higher in both the daemon and the client. You can find the most recent version
    of Docker for your OS, as well as instructions on how to install it, at [https://docs.docker.com/install/](https://docs.docker.com/install/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following simple package that logs a debug message to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to build this and execute it within a Docker container while minimizing
    dependencies, we can use a multistage Docker build. To do so, we can perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the current directory as the root of a module by executing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `vendor` repositories by executing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have all of the required vendor packages (in our case, the Zap logger)
    available in our repository.  This can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ecffe0fa-4cd9-49b5-9571-2a7bf865bcc8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Build our `zapLoggerExample` Docker container.  We can build our container
    using the following Dockerfile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Please note that we use the `golang:alpine` image for building the Go binary,
    as it's one of the simplest Docker images that contains the necessary elements
    to successfully build our Go binary. We use the `alpine:latest` image for executing
    the Go binary, as it's one of the simplest Docker images that contains the necessary
    elements to successfully run our Go binary.
  prefs: []
  type: TYPE_NORMAL
- en: In this Dockerfile example, we are using a multistage Docker build to build
    and execute our binary. In stage 1 of 2 (the builder stage), we use a golang alpine
    image as a base.  We copy all of our files from our current directory into the `/src/` directory
    on the Docker container, we make `/src/` our working directory, and we build our
    Go binary.  Disabling cgo, building for our Linux architecture, and adding the
    vendor directory we created in *step 1* can all help minimize build size and time.
  prefs: []
  type: TYPE_NORMAL
- en: In stage 2 of 2 (the executor stage), we use a basic alpine Docker image, make `/src/` our
    working directory, and copy the binary we built in the first stage to this Docker
    container. We then execute our logger as the final command within this Docker
    build.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have our necessary dependencies together, we can build our Docker
    container. We do this by performing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have our Docker container built, we can execute it by performing the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, you can see our build and execution steps being
    completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0fd4e02-76bb-4058-8114-b3679888ca84.png)'
  prefs: []
  type: TYPE_IMG
- en: Building our Go programs in multistage Docker containers can be helpful in creating
    reproducible builds, limiting binary size, and minimizing the attack vectors for
    our services by using only the bits and pieces we need.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to build Go binaries. We learned how to do
    this effectively and permanently. We also learned how to understand and manage
    dependencies, test go code with `go run`, and install go binaries to a specific
    location using go install. Understanding how these binaries work will help you
    iterate more effectively on your code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be looking at how to profile Go code to find functional
    bottlenecks.
  prefs: []
  type: TYPE_NORMAL
