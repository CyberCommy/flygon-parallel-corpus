- en: Building and Deploying Go Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have come up with a method to write performant Go code, we need to ship
    it, validate it, and continue iterating it. The first step of this process is
    to deploy the new Go code. Go's code is compiled into binaries, which allows for
    the modular deployment of new Go code as we iterate through code development.
    We can push this out to one or multiple places in order to test against different
    environments. Doing this will allow us to optimize our code to fully utilize the
    throughput that will be available to us in our system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn all about the Go build process. We''ll look
    at how the Go compiler builds binaries, and we''ll use this knowledge to build
    right-sized, optimized binaries for the platform at hand. We will cover the following
    topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Building Go binaries
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `go clean` to remove object files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `go get` to download and install dependencies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `go mod` for dependency management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `go list` to list packages and modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `go run` to execute programs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `go install` to install packages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These topics will help us build efficient Go binaries from our source code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Building Go binaries
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 10](6a020af6-5b7c-48af-95a7-cf52014ae1ca.xhtml), *Compile Time Evaluations
    in Go*, we discussed some Go build optimizations that can potentially help optimize
    our build strategy. Go's build system has quite a few options that can help the
    system operator add additional parameterization to their build strategy.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go tool has many different methodologies for building our source code.
    Let''s investigate top-level understandings of each, and then we will discuss
    each package in more depth. Knowing the key differences between these commands
    may help you to understand how they interplay with one another and choose the
    right tool for the job. Let''s have a look at them:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '`go build`: Builds a binary for your project, compiling packages and dependencies'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go clean`: Removes object and cached files from package source directories'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go get`: Downloads and installs packages and their dependencies'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go mod`: Go''s (relatively new) built-in dependency module system'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go list`: Lists named packages and modules and can display important build
    information about files, imports, and dependencies'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go run`: Runs and compiles a named Go program'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go install`: Builds the binary for your project, moves the binary to `$GOPATH/bin`,
    and caches all non-main packages'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we are going to investigate these different pieces of the Go
    build system. As we learn more about how these programs interoperate with one
    another, we will be able to see how to use them to our advantage to build slim,
    feature-filled binaries that will work as we expect them to on the supported architectures
    and operating systems.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we shall see through `go build`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Go build – building your Go code
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The invocation stanza for go build is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Defining an output with `-o` compiles a binary using a specifically named file.
    This is helpful when you have a particular naming convention that you want to
    keep for your file, or if you want to name binaries based on different build parameters
    (platform/OS/git SHA and others).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Packages can be defined as a list of go source files or they can be omitted.
    If a list of go source files is specified, the build program will use the list
    of files that were passed as a group that specifies a single package. If no packages
    are defined, the build program will validate that the packages within the directory
    can be built, but it will discard the results of the build.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Build flags
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go''s build flags are all shared by the `build`, `clean`, `install`, `list`,
    `run`, and `test` commands. A table stating the build flags and their usage descriptions
    is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '| **Build flag** | **Description** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
- en: '| `-a` | Forces packages to be rebuilt. This can be especially handy if you''d
    like to make sure that all of your dependencies are up to date. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
- en: '| `-n` | Prints the commands that the compiler utilizes but doesn''t run the
    commands (akin to a dry run in other languages). This is useful to see how a package
    gets compiled. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: '| `-p n` | Parallelizes your build commands. By default, this value is set
    to the number of CPUs that are available to the build system. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| `-race` | Enables race detection. Only certain architectures have the ability
    to detect race detections:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: linux/amd64
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: freebsd/amd64
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: darwin/amd64
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: windows/amd64
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '| `-msan` | Detects uninitialized memory reads in C. This is only supported
    on Linux with amd64 or arm64 architectures, and it is necessary to use a clang/LLVM
    compiler for the host. This can be called with `CC=clang go build -msan example.go`.
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| `-v` | As the program is compiled, the names of the packages that are built
    are listed to stdout. This can help verify which packages are used for the build.
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '| `-work` | Prints the value of the temporary work directory Go uses in order
    to build the binary. This is usually stored in `/tmp/` by default. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| `-x` | Shows all of the commands that were used during the build process.
    This can be helpful to determine how a package is built. See the *Build information*
    section for more information. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| `-asmflags ''[pattern=]arg list''` | A list of arguments to pass when `go
    tool asm` is invoked. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: '| `-buildmode=type` | This tells the build command which type of object file
    we''d like to build. There are currently a couple of type options for `buildmode`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '`archive`: Builds non-main packages into `.a` files.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c-archive`: Builds the main package and all of its imports into a C archive
    file.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c-shared`: Builds the main package and its imports into a C shared library.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default`: A list of main packages is created.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shared`: Combines all non-main packages into a single shared library.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exe`: Builds main packages and their imports into executables.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pie`: Builds main packages and their imports into **position-independent executables** (**PIE**).'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`plugin`: Builds main packages and their imports into a Go plugin.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '| `-compiler name` | Determines which compiler to use. Common uses are `gccgo`
    and `gc`. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '| `-gccgoflags` | `gccgo` compiler and linker invocation flags. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: '| `-gcflags` | `gc` compiler and linker invocation flags. See the *Compiler
    and linker* section for more details. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '| `-installsuffix suffix` | Adds a suffix to the name of the package installation
    directory. This is used in order to keep the output separate from default builds.
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '| `-ldflags ''[pattern=]arg list'' ` | Go tool link invocation arguments. See
    the *Compiler and linker* section for more details. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| `-linkshared` | After a `-buildmode=shared` invocation occurs, this flag
    links against the newly created shared libraries. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| `-mod` | Determines which module download mode to use. At the time of writing,
    there are two options: `- readonly` or `vendor`. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '| `-pkgdir dir` | Utilize the `dir` defined to install and load all packages.
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| `-tags tag,list` | A list of build tags that are to be satisfied during the
    build. This list is passed as a comma-separated list. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| `-trimpath` | The resulting built executable will use a different naming
    scheme for filesystem paths during an executable build. These are as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Go (for the standard library)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: path @version (for go modules)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: plain import path (while using `GOPATH`)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '| `-toolexec ''cmd args''` | Invokes toolchain programs, such as debuggers
    or other interactive programs. This is used for programs such as vet and asm. 
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: With all of this information, you'll be able to build correct linker flags impactfully.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Build information
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To garner some understanding of the build process, let's take a look at some
    build examples so we can gain some insight into how the build tooling works together.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to build a simple HTTP server that has a Prometheus exporter.
    We can create an exporter like so:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After we have our package ready, we can build our package with the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As we build this binary, we will see a couple of things coming back to stdout
    (since we passed the `-x` flag to see the commands that were used during the process).
    Let''s take a look:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to truncate the output so that the results are easier to read.
    If you test this out yourself, you''ll see a much larger build output:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This sets a temporary working directory for the build. As we mentioned previously,
    this usually lives in the `/tmp/` directory unless otherwise specified:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A sub-working directory is also created by the compiler:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A linking configuration is created and added. This adds all sorts of different
    arguments to the linking configuration:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The package for command-line arguments is referenced from the cache:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`fmt` is the printing package we use to display `fmt.Println("Prometheus Handler
    listening on port ", port)`. This is referenced like so:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The compiler also adds the package for the Prometheus HTTP client library. After
    this, there are many other references that are added to the build. This has been
    truncated for brevity.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The end of the file is signified with `EOF`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'An executable directory is created:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The compiler then builds the binary using the `importcfg` that was created
    earlier:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A `buildid` is then added:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, the binary is renamed to the filename we had for our exporter example
    (since we did not specify a different binary name with `-o`):'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, the work directory is removed:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The output of the work from this program is a Go binary. In the next section,
    we'll talk about compiler and linker flags.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Compiler and linker flags
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While building a Go binary, the `-gcflags` flag lets you pass optional compiler
    arguments, while the `-ldflags` flag lets you pass optional linker arguments.
    A full list of compiler and linker flags can be found by invoking the following
    commands:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s look at an example of utilizing compiler and linker flags. We can build
    a simple program that returns the value of an uninitialized string variable. The
    following program seems innocuous enough:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we build this with some of the common compiler and linker flags, we will
    see some helpful output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/035f3d29-623d-495c-85a2-11918dda45ca.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: 'The compiler flags that we passed here achieve the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '`"-m -m"`: Prints information about the compiler''s optimization decisions.
    This is the output that we can see in the preceding screenshot after the build
    command.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"-N"`: Disables optimizations within the Go binary.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"-l"`: Disables inlining.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The linker flags that we passed do the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '`"-X main.linkerFlag=Hi_Gophers"`: Sets a value for the `linkerFlag` variable
    in `main`. Being able to add a variable during build time is important as many
    developers want to add some sort of build parameter to their code during compilation
    time. We can pass a build date using ``date -u +.%Y%m%d%.H%M%S`` or a git commit
    version using `git rev-list -1 HEAD`. These values can be helpful later for referencing
    the state of the build.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"-s"`: Disables the symbol table, a data structure that stores each identifier
    in the source code alongside declaration information. This is often not needed
    for production binaries.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"-w"`: Disables DWARF generation. The dwarf table often doesn''t need to be
    saved since the Go binary includes basic type information, PC-to-line data, and
    a symbol table.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we build the binary using a standard method followed by using some of the
    compiler and linker flags we have available, we will be able to see a difference
    in binary size:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Non-optimized build:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Optimized build:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As we can see, the `Optimized` binary is 28.78% smaller than the `nonOptimized`
    binary:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96137129-bf02-41ac-a309-f719fda97509.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: Both of these binaries will perform the same function for the end user, so consider
    removing some of the build optimizations using compiler and linker flags in order
    to reduce the end resulting binary size. This can be beneficial during the storage
    and deployment of said binaries.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Build constraints
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you'd like to add a build constraint to your Go build, you can add a comment
    line at the beginning of the file that's only preceded by blank lines and other
    comments. The form of this comment is `// +build darwin,amd64,!cgo, android,386,cgo`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: This corresponds to a boolean output of `darwin AND amd64 AND (NOT cgo)) OR
    (android AND 386 AND cgo`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'This needs to proceed with the package declaration with a newline between the
    build constraint and the package initialization. This takes the following form:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The complete list of build constraints can be found at [https://golang.org/pkg/go/build/#hdr-Build_Constraints](https://golang.org/pkg/go/build/#hdr-Build_Constraints).
    This list includes the following build constraints:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '`GOOS`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GOARCH`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiler type (`gc` or `gccgo`)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cgo`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the 1.x Go versions (no build tags for beta or minor releases)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional words that are listed in `ctxt.BuildTags`
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you have a file in your library that you''d like to exclude from your build,
    you can also add a comment in the following form:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Inversely, you can restrict file builds to specific `GOOS`, `GOARCH`, and `cgo`
    bits using a comment in the following form:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will only build a file when you're using `cgo` and building on a 386 processor
    in a Windows operating system. This is a powerful construct in the Go language
    because you have the ability to build packages based on the necessary build parameters.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Filename conventions
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a file matches the `GOOS` and `GOARCH` patterns after stripping any extensions
    and the `_test` suffix (for test cases), the file will be built for that particular
    `GOOS` or `GOARCH` pattern. Patterns like so are often referenced as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '`*_GOOS`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*_GOARCH`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*_GOOS_GOARCH`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, if you have a file that's named `example_linux_arm.go`, it will
    only be built as part of the Linux arm builds.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore the `go clean` command.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Go clean – cleaning your build directory
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go command builds binaries in a temporary directory. The go clean command
    was created in order to remove extraneous object files that are created by other
    tools or when go build is manually invoked. Go clean has a usage stanza of `go
    clean [clean flags] [build flags] [packages]`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'The following flags are available for the clean command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The `-cache` flag removes the entire go build cache. This can be helpful if
    you're trying to compare a fresh build across multiple systems or if you'd like
    to see the amount of time a fresh build takes.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-i` flag removes the archive or binary that go install creates.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-n` flag is a noop; printing the result removes commands but doesn't execute
    them.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-r` flag applies logic recursively to all the dependencies of the import
    path's packages.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-x` flag prints and executes the remove commands that were generated.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-cache` flag removes the whole go build cache.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-testcache` flag removes the test results in the build cache.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-modcache` flag removes the module download cache.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we want to attempt a clean build with no existing dependencies, we can use
    a command to remove items from many of the important caches in the go build system.
    Let''s take a look:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'We will build our `prometheusExporterExample` in order to validate the size
    of the build cache changing. We can find our build cache location using the go
    environment `GOCACHE` variable:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/02570ce5-f34e-400f-a39f-184fec134edb.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: For our validation, we'll use a couple of commands in a row. First, we'll remove
    our entire cache directory with `rm -rf ~/.cache/go-build/`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we can build our Go binary by running the `go build prometheusExporterExample.go` command.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we can validate that the cache has grown significantly in size by checking
    its size with `du -sh ~/.cache/go-build/`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can clean the caches using the go clean program, that is, `go clean
    -cache -modcache -i -r 2&>/dev/null`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's important to note that some of the cache information is stored in main
    libraries, so that can't be removed by a normal user. We can get around this if
    needed by running the clean command as a superuser, but this isn't often recommended.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can validate that the cache has shrunk in size. If we look into the
    cache directory after the clean, we''ll see that we only have three items left
    in the cache directory:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: A `README` file explaining the directory.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `log.txt` file that tells us about cache information.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `trim.txt` file, which tells us the time of the last completed cache trim.
    In the following screenshot, we can see a cleaned build cache:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/bd4592fa-bed5-483e-b348-d476141c9533.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: Validating that you're caching the correct things as part of the build will
    speed up the build process and make for a less toilsome development experience.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll look at the `go get` and `go mod` commands.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving package dependencies with go get and go mod
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you construct Go programs, you'll likely run into places where you'd like
    to add dependencies. `go get` downloads and installs packages and their dependencies.
    The invocation stanza for `go get` is `go get [-d] [-f] [-t] [-u] [-v] [-fix]
    [-insecure] [build flags] [packages]`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Go 1.11 added preliminary support for Go modules. We learned how to utilize
    Go modules in [Chapter 6](3ce4cee8-eaaa-4a6d-b817-4fdd3899f973.xhtml), *Composing
    Readable Go Code*, under the *Go modules* section.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: A Go mod vendor is often included as part of the Go build system since we can
    use vendored dependencies in our Go programs. There are positives and negatives
    to vendoring dependencies in your code base. Having all of the required dependencies
    available locally during build time can make the build faster. If the upstream
    repository that you're using for your build dependencies changes or is removed,
    you'll have a build failure. This is because your program won't be able to satisfy
    its upstream dependencies.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The negatives to having vendored dependencies include the fact that vendoring
    dependencies puts the onus of keeping the packages up to date on the programmer
    – updates from the upstream such as security updates, performance improvements,
    and stability enhancements could be lost if a dependency is vendored and not updated.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Many enterprises take the vendored approach as they feel the safety of storing
    all of the required dependencies outweighs the need to update the vendored directory
    with newer packages from upstream as they become available.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'After we initialize our go module, we vendor our dependencies and build them
    using our vendored modules:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/afb44250-21d2-4722-b549-e2200876aef3.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding output, we have vendored dependencies (from [https://github.com/](https://github.com/)
    and [https://golang.org/](https://golang.org/)) that are needed to satisfy our
    build constraints in our project. We can use `go mod tidy` in our builds to validate
    that `go.mod` contains all of the necessary elements for the repository.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '`go mod tidy` adds missing modules and removes unused modules in order to validate
    our source code with the directory''s `go.mod` matches.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will learn about the `go list` command.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Go list
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`go list` performs the action of listing named packages and modules, as well
    as displaying important build information about files, imports, and dependencies.
    The invocation stanza for go list is `usage: go list [-f format] [-json] [-m]
    [list flags] [build flags] [packages]`.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Having access to the data structures that are the main pieces of the build
    process is powerful. We can use `go list` to find out a lot about the programs
    that we are building. For example, take the following simple program, which prints
    a message and computes a square root for the end user:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If we want to find out about all the dependencies that we have for our particular
    project, we can invoke the `go list -f '{{.Deps}}'` command.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'The result will be a slice of all of the dependencies that our repository contains:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f971b2e1-767a-4219-a5a0-4e9adb984b7c.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: 'The `go list` data structure can be found here: [https://golang.org/cmd/go/#hdr-List_packages_or_modules](https://golang.org/cmd/go/#hdr-List_packages_or_modules).
    It has many different parameters. One of the other popular outputs from the go
    list program is the JSON formatted output. In the following screenshot, you can
    see the output from executing `go list -json` for our `listExample.go`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2057923f-07ed-46e1-8575-eda631d7289c.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: '`go list -m -u all` will also show you the dependencies that you have. The
    resulting output will also have a second version listed in brackets, if they have
    available upgrades. This can be helpful if we want to closely monitor our dependencies
    and their upgrades using the `go mod` package.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use our Prometheus exporter example, we can see whether or not our packages
    have dependencies that need upgrading:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d12a5df1-df63-46d7-892f-46950cec2002.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: In this example, we can see that there are a couple of packages that have available
    upgrades. If we invoke go get for one of these dependencies, we'll be able to
    upgrade them effectively. We can upgrade the errors package listed in the preceding
    screenshot from v0.8.0 to v0.8.1 using `go get github.com/pkg/errors@v0.8.1`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: After we complete this upgrade, we can validate that the dependency has been
    upgraded by running `go list -m -u github.com/pkg/errors`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this output in the following screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67ab2f1e-f1ae-4815-81af-79a0079e09d2.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: In our preceding output, we can see that the errors package that's being referenced
    is now v0.8.1, rather than v0.8.0, which was shown in our previous output.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's take a look at what `go run` is.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Go run – executing your packages
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`go run` runs and compiles a named Go program. The invocation stanza for `go
    run` is `go run [build flags] [-exec xprog] package [arguments...]`.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Go run allows a developer to quickly compile and run a go binary in one operation.
    During this process, `go run` builds the executable file, runs it, and then deletes
    the executable file. This is particularly helpful in a development environment.
    As you rapidly iterate on your Go program, `go run` can be used as a shortcut
    to validate that the code you are changing will result in a build artifact that
    you deem acceptable for use. As we learned earlier in this chapter, the build
    flags for many of these tools are consistent.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '`goRun.go` is one of the simplest possible go programs. It has no arguments,
    just an empty `main()` function invocation. We are using this as an example to
    show this process with no additional dependencies or overhead:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can see the work output associated with a `go run` invocation by executing
    the `go run -x goRun.go` command.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'When we perform this action, we will be able to see the build parameters that
    are being called as part of the `go run` program:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d4b103a-02c9-44da-aeeb-7bc01600dfff.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: This should seem eerily familiar as the output closely resembles the output
    we saw in our go build example. Then, we can see our package being invoked.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: If we were to perform this same action with our Prometheus HTTP server, we would
    see that our Prometheus HTTP server is started and run as the result of executing
    the `go run` program. After we kill our process during this go run invocation,
    we'll notice that we don't have any binaries stored in our local directory. The
    `go run` invocation doesn't save these outputs by default.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: The Go command in the next section (`go install`) is the last one for this chapter.
    Let's see what it is all about.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Go install – installing your binaries
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`go install` compiles and installs a named Go program. The invocation stanza
    for go run is `go install [-i] [build flags] [packages]`'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: These are imported to `$GOPATH/pkg`. Cached items will be used on the next compilation
    if they haven't been modified. The resulting output from go install is an executable
    file that is the same as the one that gets compiled with a go build command, installed
    on the `$GOBIN` path on the system. For example, if we wanted to install our Prometheus
    HTTP server on our host, we could invoke a go install command, that is, `GOBIN=~/prod-binaries/
    go install -i prometheusExporterExample.go`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting our `GOBIN` variable tells the compiler where to install the compiled
    binary after compilation is complete. The go install program allows us to install
    the binary to our `GOBIN` location. The `-i` flag installs the dependencies of
    the named packages. We can see this in the following screenshot:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a01089af-4fdb-4474-8777-e0b192bc60dd.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: After this is completed, we can see that we have a `prometheusExporterExample`
    binary available in the `GOBIN` location that we defined in our example.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming and the last section of this chapter, we shall see how to build
    Go binaries with Docker.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Building Go binaries with Docker
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on your target architecture, you may wish to build your Go binaries
    with Docker to maintain a reproducible build, limit your build size, and minimize
    the attack vectors for your service. Using multistage Docker builds can help us
    to accomplish this task.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: To perform these actions, you must have a recent version of Docker installed.
    The multistage builds feature that we are going to use requires Docker version 17.05
    or higher in both the daemon and the client. You can find the most recent version
    of Docker for your OS, as well as instructions on how to install it, at [https://docs.docker.com/install/](https://docs.docker.com/install/).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following simple package that logs a debug message to the screen:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we want to build this and execute it within a Docker container while minimizing
    dependencies, we can use a multistage Docker build. To do so, we can perform the
    following steps:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the current directory as the root of a module by executing the following:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the `vendor` repositories by executing the following:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We now have all of the required vendor packages (in our case, the Zap logger)
    available in our repository.  This can be seen in the following screenshot:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ecffe0fa-4cd9-49b5-9571-2a7bf865bcc8.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: 'Build our `zapLoggerExample` Docker container.  We can build our container
    using the following Dockerfile:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Please note that we use the `golang:alpine` image for building the Go binary,
    as it's one of the simplest Docker images that contains the necessary elements
    to successfully build our Go binary. We use the `alpine:latest` image for executing
    the Go binary, as it's one of the simplest Docker images that contains the necessary
    elements to successfully run our Go binary.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: In this Dockerfile example, we are using a multistage Docker build to build
    and execute our binary. In stage 1 of 2 (the builder stage), we use a golang alpine
    image as a base.  We copy all of our files from our current directory into the `/src/` directory
    on the Docker container, we make `/src/` our working directory, and we build our
    Go binary.  Disabling cgo, building for our Linux architecture, and adding the
    vendor directory we created in *step 1* can all help minimize build size and time.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: In stage 2 of 2 (the executor stage), we use a basic alpine Docker image, make `/src/` our
    working directory, and copy the binary we built in the first stage to this Docker
    container. We then execute our logger as the final command within this Docker
    build.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have our necessary dependencies together, we can build our Docker
    container. We do this by performing the following command:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once we have our Docker container built, we can execute it by performing the
    following command:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the following screenshot, you can see our build and execution steps being
    completed:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0fd4e02-76bb-4058-8114-b3679888ca84.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: Building our Go programs in multistage Docker containers can be helpful in creating
    reproducible builds, limiting binary size, and minimizing the attack vectors for
    our services by using only the bits and pieces we need.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在多阶段Docker容器中构建我们的Go程序可以帮助我们创建可重复的构建，限制二进制文件大小，并通过仅使用我们需要的部分来最小化我们服务的攻击向量。
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how to build Go binaries. We learned how to do
    this effectively and permanently. We also learned how to understand and manage
    dependencies, test go code with `go run`, and install go binaries to a specific
    location using go install. Understanding how these binaries work will help you
    iterate more effectively on your code.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何构建Go二进制文件。我们学会了如何有效和永久地做到这一点。我们还学会了如何理解和管理依赖关系，使用`go run`测试go代码，并使用go
    install将go二进制文件安装到特定位置。了解这些二进制文件的工作原理将帮助您更有效地迭代您的代码。
- en: In the next chapter, we'll be looking at how to profile Go code to find functional
    bottlenecks.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何分析Go代码以找到功能瓶颈。
