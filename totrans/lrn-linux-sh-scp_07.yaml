- en: Hello World!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will finally start writing shell scripts. After writing
    and running our very own `Hello World!` script, we will look at some best practices
    for all future scripts. We will use many techniques to increase the readability
    of our scripts, and we will follow the KISS principle (Keep It Simple, Stupid)
    where possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands will be introduced in this chapter: `head`, `tail`,
    and `wget`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: First steps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KISS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create our shell scripts directly on our virtual machine; we will not
    be using Atom/Notepad++ just yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'All scripts for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter07](https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter07).'
  prefs: []
  type: TYPE_NORMAL
- en: First steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After getting some background information on Linux, preparing our system, and
    getting an overview of important concepts for scripting in Linux, we have finally
    arrived at the point where we will be writing actual shell scripts!
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, a shell script is nothing more than multiple Bash commands in sequence.
    Scripts are often used to automate repetitive tasks. They can be run interactively
    or non-interactively (meaning with or without user input) and can be shared with
    others. Let''s create our `Hello World` script! We''ll create a folder in our
    `home` directory where we will store all scripts, sorted by each chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the `vim` screen, enter the following text (note how we use an empty
    line *between* the two lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As we explained before, the `echo` command prints text to the Terminal. Let''s
    run the scripts using the `bash` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations, you are now a shell scripter! Perhaps not a very good or well-rounded
    one *yet*, but a shell scripter nonetheless.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, if `vim` is not doing the trick for you yet, you can always fall back
    to `nano`. Or, even better, run `vimtutor` again and refresh those `vim` actions!
  prefs: []
  type: TYPE_NORMAL
- en: The shebang
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You are probably wondering about that first line. The second (or third, if
    you count the empty line) should be clear, but that first one is new. It is called
    the **shebang**, but is sometimes also referred to as a *sha-bang*, *hashbang*,
    *pound-bang*, and/or *hash-pling*. Its function is pretty simple: it tells the
    system which binary to use to execute the script. It is always in the format of
    `#!<binary path>`. For our purposes, we will always use the `#!/bin/bash` shebang,
    but for Perl or Python scripts it would be `#!/usr/bin/perl` and `#!/usr/bin/python3` respectively.
    It might seem unnecessary at first sight. We create the script named `hello-world.sh`,
    whereas a Perl or Python script would use `hello-world.pl` and `hello-world.py`.
    Why, then, do we need the shebang?'
  prefs: []
  type: TYPE_NORMAL
- en: For Python, it allows us to easily distinguish between Python 2 and Python 3\.
    You would normally expect people to switch to a newer version of a programming
    language as soon as it's there, but for Python this seems to require a lot more
    effort, which is why you see both Python 2 and Python 3 in use today.
  prefs: []
  type: TYPE_NORMAL
- en: Bash scripts do not end in `.bash`, but in `.sh`, the general acronym for *shell*.
    So, unless we specify the shebang for Bash, we will end up in a *normal* shell
    execution. While this is fine for some scripts (the `hello-world.sh` script would
    work fine), when we use the advanced functions of Bash, we will run into issues.
  prefs: []
  type: TYPE_NORMAL
- en: Running scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you were really paying attention, you will have noticed we executed a script
    that was not executable, using the `bash` command. Why would we need the shebang,
    if we specify how to run it anyway? In this case, we would not need the shebang.
    However, we would need to know exactly which kind of script it is and find the
    correct binary on the system to run it, which can be kind of a hassle, especially
    once you have many scripts. Thankfully, there is a better way for us to run these
    scripts: using the executable permission. Let''s see how we can run our `hello-world.sh`
    script by setting the executable permission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can execute a script (or any file, really, if it makes sense for the file
    to be executed) by either running it *fully qualified* or using `./` in the same
    directory, as long as it has the executable permission set. We need the prefix `./`
    because of security: normally when we execute a command the `PATH` variable is
    explored for that name. Now imagine someone putting a malicious binary called
    `ls` in your home directory. If `./` rule wasn''t in place, running the `ls` command
    would result in the binary being run, instead of `/bin/ls` (which is on your `PATH`).'
  prefs: []
  type: TYPE_NORMAL
- en: Because we are running a script by just using `./hello-world.sh`, we now need
    the shebang again. Otherwise, Linux would default to using `/bin/sh`, which is
    not what we want in a **Bash** scripting book, right?
  prefs: []
  type: TYPE_NORMAL
- en: Readability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing shell scripts, you should always aim to make sure the code is as
    readable as possible. When you're in the process of creating a script, all the
    logic, commands, and flow of the script will be obvious to you, but if you look
    at the script after putting it down for a little while, this isn't a given anymore.
    Even worse, you'll most likely work together with other people on scripts; these
    people have never had the same considerations you had when writing the script
    (and the same goes for the other way around). How can we promote better readability
    in our scripts? Comments and verbosity are two ways in which we can achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As any good software engineer could tell you, placing relevant comments in
    your code increases the quality of the code. A comment is nothing more than a
    bit of text explaining what you''re doing, prefixed by a special character that
    ensures the language you''re coding in does not interpret the text. For Bash,
    this character is the *number sign* `#` (currently more famous for its use in
    #HashTags). When you''re reading other sources, it may also be referred to as
    the *pound sign* or the *hash*. Other examples of comment characters are `//`
    (Java, C++), `--` (SQL), and `<!-- comment here -->` (HTML, XML). The `#` character
    is also used as a comment for Python and Perl.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A comment can either be used at the beginning of a line, which ensures the
    entire line does not get interpreted, or further in a line. In that case, everything
    up until `#` will be processed. Let''s look at an example of both of these in
    a revised `Hello World` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, we prefer putting comments on their own line directly above the
    command. However, once we introduce loops, redirection, and other advanced constructs,
    an *inline comment* can ensure better readability than an entire line. The most
    important thing to remember, though, is: **any relevant comment is always better
    than no comment, whether full line or inline**. By convention, we always prefer
    to keep comments either really short (one to three words) or use a full sentence
    with proper punctuation. In cases where a full sentence would be overkill, use
    a few keywords; otherwise, opt for the full sentence. We guarantee it will make
    your scripts look much more professional.'
  prefs: []
  type: TYPE_NORMAL
- en: Script header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our scripting endeavors, we always include a *header* at the beginning of
    the script. While this is not necessary for the functioning of the script, it
    can help greatly when other people are working with your scripts (or, again, when
    you''re working with other people''s scripts). A header can include any information
    you think is needed, but in general we always start with the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: Author
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By implementing a simple header using comments, we can give someone who stumbles
    upon the script an idea of when it was written and by whom (should they have questions).
    Furthermore, a simple description gives a goal to the script, and usage information
    ensures there is no trial and error when using a script for the first time. Let''s
    create a copy of our `hello-world.sh` script, call it `hello-world-improved.sh`,
    and implement both a header and a comment for the functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure the script looks like the following, but be sure to enter the *current
    date* and *your own name*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, doesn't that look nice? The only thing that might stick out is that we
    now have a script of 12 lines, where only a single line contains any functionality.
    In this case, indeed, it seems a bit much. However, we're trying to learn good
    practices. As soon as scripts become more complicated, these 10 lines we're using
    for the shebang and the header will not make a difference, but the usability increases
    notably. While we're at it, we're introducing a new `head` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `head` command is like `cat`, but it does not print the whole file; by default,
    it only prints the first 10 lines. Which, not entirely coincidentally, is exactly
    as long as we created our header to be. So, anybody that wants to use your script
    (and, let's be honest, **you** after 6 months are also *anybody*) can just use
    `head` to print the header and get all the information needed to start using the
    script.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we''re introducing `head`, we would be negligent if we did not introduce
    `tail` as well. As the name might imply, while `head` prints the top of the file,
    `tail` prints the end of the file. While this does not help us with our script
    headers, it is very useful when looking at log files for errors or warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Verbosity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back to how we can improve the readability of our scripts. While commenting
    is a great way to improve our understanding of a script, if the commands in the
    script use many obscure flags and options, we need many words in our comments
    to explain everything. And, as you might expect, if we need five lines of comments
    to explain our commands, the readability becomes lower instead of higher! Verbosity
    is the balancing act between not too much but also not too little explanation.
    For example, you will probably not have to explain to anyone if and why you are
    using an `ls` command, since that is very basic. However, the `tar` command can
    be quite complex so it might be worthwhile to give a short comment about what
    you're trying to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this context, there are three types of verbosity we want to discuss. These
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Verbosity in comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verbosity of commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verbosity of command output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verbosity in comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The issue with verbosity is that it's hard to give definitive rules. Almost
    always it's very dependent on the context. So, while we can say that, indeed,
    we do not have to comment on `echo` or `ls`, this might not always be the case.
    Let's say we use the output of the `ls` command to iterate over some files; perhaps
    we want to mention this in a comment? Or perhaps even this situation is so clear
    for our perceived readers that a short comment on the entire loop would suffice?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is, very unsatisfactorily, *it depends*. If you''re unsure, it''s
    often a good idea to include the comment anyway, but you might want to keep it
    more sparse. Instead of *This instance of ls lists all the files, which we can
    then use to iterate over for the rest of the scripts,* you might choose *Builds
    list for iteration with ls.* instead. This is mostly a practiced skill, so be
    sure to at least start practicing it: you will most certainly get better as you
    shell-script more.'
  prefs: []
  type: TYPE_NORMAL
- en: Verbosity of commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Command verbosity is an interesting one. In the previous chapters you were
    introduced to a lot of commands, sometimes with accompanying flags and options
    that alter the functioning of that command. Most options have both a short and
    long syntax that accomplishes the same thing. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We use `ls` to recursively print the files in our home directory. We first
    use the shorthand option `-R`, and right after the long `--recursive` variant.
    As you can see from the output, the command is exactly the same, even `-R` is
    much shorter and faster to type. However, the `--recursive` option is more verbose,
    since it gives us a much better hint about what we''re doing than just `-R`. So,
    when do you use which? The short answer: **use shorthand options in your daily
    work, but use long options when scripting**. While this works great for most situations,
    it isn''t a foolproof rule. Some shorthand commands are so prevalent that using
    the long option might be more confusing for the reader, as counterintuitive as
    it sounds. For example, when working with SELinux or AppArmor, the `-Z` command
    for `ls` prints the security context. The long option for this is `--context`,
    but this is not as well known as the `-Z` option (in our experience). In this
    case, using shorthand would be better.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, however, a command we have already seen that is complicated, but
    a lot more readable when we use long options: `tar`. Let''s look at two ways of
    creating an archive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The first command, `tar czvf`, uses only shorthand. A command like this would
    be great for either a full-line comment or inline comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you could use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `tar --create --gzip --verbose --file` command, however, is verbose enough
    *in itself* and would not warrant a comment, because an appropriate comment would
    literally say the same as what the long options are saying!
  prefs: []
  type: TYPE_NORMAL
- en: Shorthand is used to save time. For daily tasks, this is a great way to interact
    with your system. However, when shell scripting, it's much more important to be
    clear and verbose. Using long options is a better idea, since you can prevent
    the need for extra comments when using these options. However, some commands are
    used so often that the longer flag can actually be more confusing; use your best
    judgement here and learn from experience.
  prefs: []
  type: TYPE_NORMAL
- en: Verbosity of command output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lastly, when running a shell script, you will see output from the commands
    in the script (unless you want to remove that output with *redirection*, which
    will be explained in [Chapter 12](15141e02-be0c-4709-90f4-a172809217c4.xhtml), *Using
    Pipes and Redirection in Scripts*). Some commands are verbose by default. Good
    examples of these are the `ls` and `echo` commands: their entire function is to
    print something on screen.'
  prefs: []
  type: TYPE_NORMAL
- en: If we circle back to the `tar` command, we can ask ourselves if we need to see
    all the files that are being archived. If the logic in our script is correct,
    we can assume the correct files are being archived and a list of these files will
    only clutter up the rest of the output from the script. By default, `tar` does
    not print anything; we have used the `-v`/`--verbose` option for this up until
    now. But, for a script, this is often not desirable behavior, so we can safely
    omit this option (unless we have a good reason not to).
  prefs: []
  type: TYPE_NORMAL
- en: 'Most commands have appropriate verbosity by default. The output of `ls` is
    printed, but `tar` is hidden by default. For most commands, it is possible to
    reverse the verbosity by using either a `--verbose` or `--quiet` option (or the
    corresponding shorthands, often `-v` or `-q`). A good example of this is `wget`:
    this command is used to grab a file from the internet. By default, it gives a
    lot of output about the connection, hostname resolution, download progress, and
    download destination. Many times, however, all these things are not interesting
    at all! In this case, we use the `--quiet` option for `wget`, because for that
    situation that is the **appropriate verbosity** of the command.'
  prefs: []
  type: TYPE_NORMAL
- en: When shell scripting, always consider the verbosity of the commands you are
    using. If it is not enough, check the man page for a way to increase the verbosity.
    If it is too much, check that same man page for a quieter option. Most commands
    we have encountered have either or both options present, sometimes in different
    levels (`-q` and `-qq` for even quieter operation!).
  prefs: []
  type: TYPE_NORMAL
- en: Keep It Simple, Stupid (KISS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The KISS principle is a great way to approach shell scripting. While it might
    come across as a bit harsh, the spirit in which it is given is important: it should
    only be considered great advice. Further advice is given in the *Zen of Python*,
    the design principles on which Python rests:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple is better than complex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex is better than complicated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readability counts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are about 17 more aspects in the *Zen of Python*, but these three are
    the most relevant for Bash scripting as well. The last one, '*Readability counts'*,
    should be obvious by now. However, the first two, '*Simple is better than complex'*
    and '*Complex is better than complicated'* are closely related to the KISS principle.
    Keeping things simple is a great goal, but if that is not possible, a complex
    solution is always better than a complicated one (no one likes complicated scripts!).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few things you can keep in mind when writing scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the solution you''re cooking up seems to get very complicated, do either
    of the following things:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Research your problem; perhaps there is another tool you can use instead of
    what you are using now.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See whether you can split things into discrete steps, so it gets more complex
    but less complicated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ask yourself if you need everything on a single line, or if it is perhaps possible
    to split the command over multiple lines to increase readability. When using pipes
    or other forms of redirection, as explained in greater detail in [Chapter 12](15141e02-be0c-4709-90f4-a172809217c4.xhtml),
    *Using Pipes and Redirection in Scripts*, this becomes something to keep in mind.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it works, it's *probably* not a bad solution. However, make sure that the
    solution is not *too* simple, since edge cases might cause trouble later on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We started this chapter off by creating and running our very first shell script.
    As is almost mandatory when learning a new software language, we printed Hello
    World! onto our Terminal. Continuing, we explained the shebang: the first line
    of a script, it is an instruction to the Linux system about the interpreter it
    should use when running the script. For a Bash script, the convention is to have
    the file name end in .sh, with a shebang of #!/bin/bash.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We explained that there are multiple ways in which we can run a script. We
    can start with the interpreter and pass the script name as the argument (for example:
    `bash hello-world.sh`). In this case, the shebang is not needed because we''re
    specifying the interpreter on the command line. However, normally, we run the
    file by setting the executable permission and calling it directly; in this case,
    the shebang is used to determine which interpreter to use. Because you cannot
    be sure about how a user will run your script, including a shebang should be considered
    mandatory.'
  prefs: []
  type: TYPE_NORMAL
- en: To increase the quality of our scripts, we described how to increase the readability
    of our shell scripts. We explained how and when to use comments in our scripts,
    and how we can use comments to create a script header that we can easily view
    by using the `head` command. The `tail` command, which is closely related to `head`,
    was briefly introduced. Besides comments, we also explained the concept of **verbosity**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verbosity can be found in multiple levels: verbosity in comments, verbosity
    in commands, and verbosity in command output. We argued that using long options
    for commands in scripts is almost always a better idea than shorthand, as it increases
    readability and can prevent the need for extra comments, even though we established
    that too many comments are almost always better than no comments.'
  prefs: []
  type: TYPE_NORMAL
- en: We ended the chapter with a short description of the KISS principle, which we
    linked to some design principles in Python. The reader should realize that, if
    there is a simple solution to a problem, it will most often be the best one. If
    a simple solution isn't an option, a complex solution should be preferred over
    a complicated one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands were introduced in this chapter: `head`, `tail`, and `wget`.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What do we, by convention, do as the first thing when we learn a new programming
    or scripting language?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the shebang for Bash?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the shebang needed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In what three ways can we run a script?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we place such emphasis on readability when creating shell scripts?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we use comments?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we recommend including a script header for all shell scripts you write?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which three types of verbosity have we discussed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the KISS principle?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources might be interesting if you''d like to go deeper into
    the subjects of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hello World (long tutorial)**: [https://bash.cyberciti.biz/guide/Hello,_World!_Tutorial](https://bash.cyberciti.biz/guide/Hello,_World!_Tutorial)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bash coding style guide**: [https://bluepenguinlist.com/2016/11/04/bash-scripting-tutorial/](https://bluepenguinlist.com/2016/11/04/bash-scripting-tutorial/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KISS**: [https://people.apache.org/%7Efhanik/kiss.html](https://people.apache.org/%7Efhanik/kiss.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
