- en: '*Chapter 3*: Control Statements and Exceptions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed data types and operators in C#. In this
    chapter, we will explore control statements in C#. Control statements allow us
    to implement conditional execution paths in our code. We will also learn how to
    implement exception handling, which will help us to handle errors that might occur
    while executing our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Control statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have seen how to implement these statements
    and clauses practically. Let's look at each of these topics in detail using examples.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding control statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Control statements allow us to control the flow of execution of a program.
    They also allow us to execute a particular block of code based on a certain condition.
    C# defines three categories of control statements, as mentioned here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if` and `switch`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for`, `while`, `do-while`, and `foreach`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`break`, `continue`, `goto`, `return`, and `yield`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will explore each of these statements in detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Selection statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Selection statements allow us to change the execution flow based on whether
    a condition is true or not. C# provides us with two types of selection statements:
    `if` and `switch`.'
  prefs: []
  type: TYPE_NORMAL
- en: The if statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following snippet shows the syntax of an `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If `condition1` evaluates to `true`, then `statement1` will be executed. Else,
    if `condition2` evaluates to `true`, then `statement2` will be executed. Otherwise,
    `statement3` will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: The `else-if` and `else` clauses are *optional* and either of them, or both,
    can be *omitted*. On the other hand, you can have as many `else-if` clauses as
    you'd like.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we have only one statement to be executed for both the `if`
    and `else` clauses. If we have to execute a series of statements, we need to add
    curly braces (`{}`) to make it a block. This is optional for single statements,
    although it is often a good way to make the code clearer or less prone to errors.
    In this case, the syntax will change as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If `condition` evaluates to `true`, then both `statement1` and `statement2`
    will be executed. Otherwise, `statement3` and `statement4` will be executed. Let''s
    try to understand the `if-else` statement with the help of the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding program checks if a positive integer is even or odd. We are reading
    an integer from the console as input. As the value entered on the console is considered
    a string, we need to convert it to an integer. We will then find the remainder
    of division by `2` by applying the modulus (`%`) operator. If the remainder is
    `0` then the number is *even*, if not, the number is *odd*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `if` statements can be nested. We can put an `if` statement inside another
    `if` or an `else` statement. The following syntax shows an example of nested `if`
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, if `condition1` evaluates to `true`, then the control will
    enter into the `if` block and execute the statement based on the evaluation of
    the nested `if` statements. If `condition1` is `false`, then the nested `if` statements
    inside the `else` clauses will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nested `if` statement, each `else` clause belongs to the last `if` statement
    that doesn''t have a corresponding `else` statement. To avoid confusion and errors,
    it is recommended that you use curly braces when nesting `if` statements to pair
    `if` and `else` clauses correctly. Take, for instance, the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example is not the same as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, the `else` clause belonged to the second, inner `if` clause.
    On the other hand, in the second example, the `else` clause belonged to the first,
    outer `if` clause.
  prefs: []
  type: TYPE_NORMAL
- en: The switch statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `switch` statement provides us with a way to execute a set of instructions
    from several available alternatives. It will match the value of an expression
    against a list of available values. If a match is found, the code associated with
    that value is executed.
  prefs: []
  type: TYPE_NORMAL
- en: The `switch` statement is an alternative to the cascading `if-else-if` statements.
    If there is a small number of matches, an `if` statement may be preferred. However,
    if the number of matching conditions is larger, a `switch` statement is preferred
    to an `if` statement for its better readability and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of a `switch` statement is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A `switch` statement contains one or more sections and each section has one
    or more `case` labels. Each `case` label can have one or more statements. Each
    `case` label specifies a value that will be matched with the `switch` expression.
    If a match is found, the control will be transferred to the matching `case` label.
  prefs: []
  type: TYPE_NORMAL
- en: The statements present in the `case` label will be executed until a `break`
    statement is encountered. If no match is found, the control will go to the `default`
    case. After the execution of a particular `case` label, the control will exit
    the switch. The `default` case is optional. If no `default` case is present and
    no match is found for any case labels, the control will fall outside of the `switch`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have not used curly braces `({})` inside the case labels. The `default`
    case can appear anywhere on the list. It is always evaluated last after all the
    `case` labels have been evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: You can place multiple case labels in the same switch section; in this case,
    the matching of any of the case labels will trigger the execution of the switch
    section. In a `switch` statement, only one switch section may execute. It is not
    possible to fall through from one section to another. Each `switch` statement
    must be followed by a `break`, `goto`, or `return` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a `switch` statement with multiple switch sections,
    some of them with multiple `case` labels. The `default` case is placed at the
    end, as you would usually do. Each section is exited with a `break` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `switch` statement supports various forms of pattern matching. However,
    this is a more advanced topic that will be detailed in [*Chapter 8*](B12346_08_Final_JC_ePub.xhtml#_idTextAnchor154),
    *Advanced Topics*, and in [*Chapter 15*](B12346_15_Final_JC_ePub.xhtml#_idTextAnchor271),
    *New Features of C# 8*.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Iteration statements allow us to execute a set of code in a loop as long as
    a certain condition is satisfied. C# provides us with four different kinds of
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '`for`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do-while`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foreach`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's explore them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The for loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `for` loop allows us to execute a code block as long as a Boolean expression
    evaluates to `true`. The following snippet shows the general syntax of a `for`
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `initializer` section consists of one or more initialization statements
    intended to initialize the counter to control the loop. This will be executed
    only once before entering the loop for the first time. If there are multiple statements
    in the `initializer` section, they must be separated by a comma. However, the
    `initializer` section is *optional and can be left empty*.
  prefs: []
  type: TYPE_NORMAL
- en: The loop controlling counter is also known as the loop control variable. This
    variable is local to the loop and cannot be accessed outside the scope of the
    `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '`condition` is a Boolean expression that will determine if the loop will execute
    or not. It will be evaluated for every iteration of the loop. If it evaluates
    to `true`, the loop will be executed. Once the Boolean condition evaluates to
    `false`, the loop will terminate, and the program control will fall out of the
    loop. This statement is optional and can be left empty.'
  prefs: []
  type: TYPE_NORMAL
- en: '`iterator` is an expression to change (increment/decrement) the loop control
    variable after each iteration of the loop. It can have multiple statements separated
    by a comma. This statement is also *optional and can be left empty*. In fact,
    all three of these statements (`initializer`, `condition`, and `iterator`) can
    be omitted, in which case we have an infinite loop, as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `for` loop is an entry controlled loop, which means the Boolean condition
    will be evaluated before entering into the loop. If the condition evaluates to
    `false` in the first iteration, then the code block inside the loop will not be
    executed at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the `for` loop with the help of the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are running a `for` loop to check which integers between `0` and `10`
    are even or odd. When you execute this code, you will see the following output
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – A screenshot of the console showing the output of the preceding
    snippet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.1_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – A screenshot of the console showing the output of the preceding
    snippet
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also put a `for` loop inside another `for` loop. In this case, the inner
    loop will execute completely for each iteration of the outer loop. Look at the
    following code snippet. Here, all of the values of the `j` variable (that is,
    `1` and `2`) will be printed against each value of the `i` variable (that is,
    `1`, `2`, `3`, and `4`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon execution, you can see the following output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – The console output from the execution of the preceding snippet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.2_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – The console output from the execution of the preceding snippet
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical example of nested `for` loops is multi-dimensional array traversal.
    In the following example, we have an array of integers with three rows and two
    columns initialized during its declaration. The nested `for` loops are used to
    print the value of its elements to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we used the `GetUpperBound()` method to retrieve the index of the
    last element of the specified dimension to avoid hard-coded values for the size
    of the array.
  prefs: []
  type: TYPE_NORMAL
- en: You can exit a loop iteration while the condition is still `true` using a `break`,
    `goto`, `return`, or `throw` statement. You can skip the execution of the loop
    block for the current iteration with a `continue` statement. This is also true
    for the other loops—`while`, `do`, and `foreach`. The `jump` statements will be
    explored in detail later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop
  prefs: []
  type: TYPE_NORMAL
- en: 'The `while` loop is an *entry controlled loop*. It executes a block of statements
    as long as a specified Boolean expression evaluates to `true`. The syntax of a
    `while` loop is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, `condition` is a Boolean expression and it controls the loop. The code
    block inside the loop will be executed while `condition` evaluates to `true`.
    When `condition` becomes `false`, the program control will fall outside of the
    loop. Because `condition` is evaluated first, the `while` loop may not execute
    at all if `condition` is initially `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `while` loop is very similar to a `for` loop. In fact, you can rewrite any
    `while` loop as a `for` loop and vice versa. You can see in the following snippet
    how we can re-rewrite the syntax of a `for` loop using a `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code snippet, we have rewritten the example from the previous
    session that prints even and odd numbers to the console with the help of a `while`
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The result of the execution of the program is unchanged. In fact, there is yet
    another way to achieve the same result, and that is through using a `do` statement.
  prefs: []
  type: TYPE_NORMAL
- en: The do-while loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `do-while` loop is an *exit-controlled loop*. This means the Boolean condition
    will be checked at the end of the loop. This ensures that the `do-while` loop
    will always be executed at least once, even if the condition evaluates to `false`
    in the first iteration. That is the key difference between a `while` and a `do-while`
    loop; the former may not execute at all, but the latter is always executed at
    least once.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of a `do-while` loop is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code snippet, we are printing all the numbers between `0`
    and `10` using a `do-while` loop, specifying which is odd and which is even. This
    code will have the same output as the example shown for the `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The loops we have learned about so far allow us to execute one or more statements
    repeatedly, such as iterating through the elements of a collection based on an
    index. Another sort of loop statement, such as `foreach`, simplifies this iterating
    in all cases where we are interested in the element but not the index. Let's take
    a look at `foreach` next.
  prefs: []
  type: TYPE_NORMAL
- en: The foreach loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `foreach` loop allows us to iterate through the items of a collection that
    implements the `System.Collections.IEnumerable` or `System.Collections.Generic.IEnumerable<T>`
    interface. Collections are discussed in detail in [*Chapter 7*](B12346_07_Final_JC_ePub.xhtml#_idTextAnchor134),
    *Collections*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the `foreach` loop is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, `datatype` denotes a valid type in C# and it must be the same data type
    as the collection, or a type for which an implicit conversion exists. You can
    also use `var` instead of an actual type name, in which case the compiler will
    infer the type of the `iterator` variable from the type of the collection elements.
  prefs: []
  type: TYPE_NORMAL
- en: The `iterator` variable is a loop iteration variable. The loop iteration variable
    in a `foreach` loop is read-only. This means we cannot change its value inside
    the body of the loop. In each iteration of the loop, the iterator is assigned
    a value from the collection. When all of the elements of the collection have been
    iterated, the loop exits. Exiting the loop can also be done with a `break`, `goto`,
    `return`, or `throw` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `foreach` loop with the help of the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have defined a string array that contains a list of programming
    languages. We are using a `foreach` loop to iterate through it and print each
    element of the array on the console. The output for this code is as in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – The output of printing to the console the content of an array
    of strings using a foreach statement'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.3_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – The output of printing to the console the content of an array of
    strings using a foreach statement
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding `foreach` statement is semantically equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The collection type may not necessarily implement the `IEnumerable` or `IEnumerable<T>`
    interfaces, but it must have a public method called `GetEnumerator()`, that takes
    no parameters and returns a class, struct, or interface, and has a return type
    that contains a public property called `Current` and a public parameterless method
    called `MoveNext()` that returns `bool`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `Current` property of the enumerator type returns a reference return
    value (which is made possible with C# 7.3), then you can declare the iteration
    variable with the `ref` or `ref only` modifier. An example of this is shown in
    this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `arr` variable is `System.Span<int>`. The return type of its `GetEnumerator()`
    method, which is `Span<T>.Enumerator`, satisfies the condition mentioned earlier.
    The first `foreach` loop iterates through the elements of the array (a `stackalloc`
    array is allocated on the stack and disposed of as the function call returns)
    and doubles the initial value of each element. The second `foreach` loop iterates
    again through the elements but in a read-only fashion. An attempt to change the
    value of the iterator variable in a read-only loop would result in a compiler
    error.
  prefs: []
  type: TYPE_NORMAL
- en: The jump statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Jump statements allow us to immediately transfer the control from one point
    in the application to another. C# provides us with five different jump statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`break`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`continue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`goto`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yield`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will explore them in detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The break statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We already saw how to use `break` to exit out of a `switch` case. We can also
    terminate the execution of a loop using the `break` statement. Once the program
    control encounters a `break` statement inside a loop, the loop terminates immediately,
    and the control falls out of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are iterating from `0` to `10` and writing the current value to the
    console. If the value of the loop control variable becomes `5`, the loop will
    break, and no further element will be printed to the console. Although the loop
    is expected to run 10 times, the `break` statement makes it terminate immediately
    as the value of the iterator becomes `5`. Upon execution, you can see the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – A screenshot of the console showing the output of the preceding
    snippet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.4_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – A screenshot of the console showing the output of the preceding
    snippet
  prefs: []
  type: TYPE_NORMAL
- en: The `break` statement is not the only statement that can control the execution
    of a loop. Another one is `continue`, which we will look at in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The continue statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `continue` statement passes control to the next iteration of an enclosing
    loop, be it `for`, `while`, `do`, or `foreach`. It is used to terminate the execution
    of the loop body in the current iteration and skip to the next one. The `continue`
    statement does not determine the return from the loop statement, but only aborts
    the execution of the current iteration and moves the control to the evaluation
    of the loop condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we iterate from `0` to `10`; if the value is an even number,
    then we skip the current iteration loop and continue to the next one. This code
    will print only the odd numbers between `0` and `10`. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – The output of the previous snippet that prints to the console
    the odd numbers smaller than 10'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.5_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – The output of the previous snippet that prints to the console the
    odd numbers smaller than 10
  prefs: []
  type: TYPE_NORMAL
- en: The `break` and `continue` statements control the execution of loops. The next
    statement is used to end the execution of functions.
  prefs: []
  type: TYPE_NORMAL
- en: The return statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `return` statement terminates the current execution flow and returns the
    control to the calling method. Optionally, we can also return a value to the calling
    method. If the method has a return type defined, we need to return a value. Otherwise,
    when the return type is void, we can return without specifying any value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a possible implementation of a function that returns
    the nth Fibonacci number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `return` statement triggers the stopping of the current function execution
    and the return of the control to the calling function.
  prefs: []
  type: TYPE_NORMAL
- en: The goto statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `goto` statement is an unconditional jump statement. When the program control
    encounters a `goto` statement, it will jump to the location specified by it. The
    target for `goto` is specified using a *label*, which is an identifier followed
    by a colon (`:`). We can also use `goto` to exit from a loop. In this case, it
    will behave similarly to a `break` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are iterating from `0` to `10`. If the value of the iterator
    becomes `5`, we will use a `goto` statement to jump out of the loop. The output
    for this code snippet is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – The console output from the preceding code snippet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.6_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – The console output from the preceding code snippet
  prefs: []
  type: TYPE_NORMAL
- en: The use of a `goto` statement is generally avoided as a good programming practice
    because it can lead to code that is unstructured and hard to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: The yield statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`yield` is a contextual keyword (that is, a word that provides a specific meaning
    in code without being a reserved word). It indicates that the method, operator,
    or `get` accessor, where it appears preceding a `return` or `break` statement,
    is an iterator. The sequence returned from an iterator method can be consumed
    using a `foreach` statement. The `yield` statement makes it possible to return
    values as they are produced and consume them as they are available, which is especially
    useful in an asynchronous context.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand the use of `yield`, let''s consider the following example.
    We have a function, let''s call it `GetNumbers()`, that returns a collection with
    all the numbers from `1` to `100`. A possible implementation is shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The problem with this implementation is that we cannot consume the numbers before
    all of them are produced. On one hand, in a real example, this could be time consuming
    and we might want to consume the numbers as they are produced. On the other hand,
    we might be only interested in some of the numbers, but not all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this implementation, we have to first produce all of them before using
    those that we need. In the following example, we only print the first five numbers
    to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: A `yield return` statement returns an item as soon as it is available. It is
    shorthand for creating an iterator, something that would make the code more laborious.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of `GetNumbers()` would change to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We return each number as it is available and do this only as long as we iterated
    through the enumerator, such as with a `foreach` statement. The preceding example,
    which prints the first five numbers to the console, remains unchanged. However,
    the execution is different because only five iterations in the `for` loop will
    be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this better, let''s change the example a bit so that a message
    is displayed to the console before every item is produced and consumed respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'A call to `Thread.Sleep()` is used to simulate a one-second delay in producing
    the next number. The result of the execution of this code is shown in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – The result of the execution of the preceding code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.7_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – The result of the execution of the preceding code
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen how we can return from the normal execution of the code,
    let's take a quick look at how we can handle abnormal situations when unexpected
    errors occur during the execution of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are scenarios where our code produces an error. The error might occur
    because of a logical issue in the code, such as trying to divide by zero or access
    an element in an array beyond the bounds of the array. For example, trying to
    access the fourth element in an array of size three. Errors can also occur because
    of external factors, such as trying to read a file that does not exist on a disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'C# provides us with a built-in exception-handling mechanism to handle these
    types of errors at the code level. The syntax for exception handling is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `try` block can contain one or more statements. The `catch` block contains
    the error handling code. The `finally` block contains the code that will execute
    after the `try` section. This happens regardless of whether the execution resumed
    normally, or the control left the `try` block because of a `break`, `continue`,
    `goto`, or `return` statement.
  prefs: []
  type: TYPE_NORMAL
- en: If an exception occurred and a `catch` block exists, the `finally` block is
    also guaranteed to execute. If the exception is unhandled, the execution of the
    `finally` block depends on how the exception unwind operation is triggered, which
    depends on how the running machine is set up. The `finally` block is optional.
  prefs: []
  type: TYPE_NORMAL
- en: Upon execution, the program control will execute the code inside the `try` block.
    If no error occurs in the `try` block, the execution continues normally and control
    transfers to the `finally` block, if it exists. When an exception occurs inside
    the `try` block, program control will transfer to a `catch` block, if one exists.
    After the execution of a `catch` block, the program control will transfer to the
    `finally` block, if it exists.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple `catch` clauses may exist for the same `try` block. The order they
    are listed in is important because they are evaluated in that given order. This
    means more specific exceptions should be caught before more general ones. It is
    possible to specify a `catch` clause without an exception type in order to catch
    all exceptions. However, this is considered rather a bad practice because you
    should only catch exceptions that you know how to handle and recover from.
  prefs: []
  type: TYPE_NORMAL
- en: When an exception occurs, the `catch` block to handle it in the method that
    is currently executing. If one does not exist, it looks in the method that called
    the current method, and so on up the call stack. If no matching `catch` block
    is found, an unhandled exception message is displayed, and the execution of the
    program is aborted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to understand exception handling with the help of the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are trying to simulate a *division by zero error*. When an error occurs
    inside the `try` block, it will create an instance of the `Exception` class and
    throw the exception. In the `catch` block, we are specifying an argument of the
    `Exception` type. The exception provides us with an error message but also with
    information about where the error occurred (filename and path) as well as the
    call stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we only want the message associated with the exception, we can use the `Message`
    property of the `Exception` class. The output of this code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – The console showing the message of a division by zero exception'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.8_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – The console showing the message of a division by zero exception
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions are thrown with the `throw` statement. You must specify an instance
    of the `System.Exception` class or a class derived from it. Classes will be discussed
    in *Chapter 4*, *Understanding the Various User-Defined Types*, and inheritance
    in [*Chapter 5*](B12346_05_Final_JC_ePub.xhtml#_idTextAnchor103), *Object-Oriented
    Programming in C#*, but for the time being keep in mind that there are many exception
    types and they are all based on `System.Exception`. The `throw` statement can
    be used in a `catch` block without any argument to re-throw the exception, preserving
    the call stack. This is useful when you want to do something in the case of an
    exception, such as logging, but also want to pass the exception forward to be
    fully handled in a different place.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, a function called `FunctionThatThrows()` does something,
    but not before checking its input argument. If the `object` argument is `null`,
    it throws an exception of the `ArgumentNullException` type. However, if the argument
    is not null but of a type other than `string`, it throws an exception of the `ArgumentException`
    type. This is the base class for `ArgumentNullException`. When invoking the method,
    we catch multiple exception types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ArgumentNullException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ArgumentException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exception`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The order is important because it starts with the most-derived class and ends
    with the base class of all exceptions. A `finally` block is used to display a
    message at the end of the execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the execution of this program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – The console output from the execution of the previous snippet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.9_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – The console output from the execution of the previous snippet
  prefs: []
  type: TYPE_NORMAL
- en: The topic of exception handling will be discussed in greater detail in [*Chapter
    14*](B12346_14_Final_JC_ePub.xhtml#_idTextAnchor253), *Error Handling*. If you
    want to learn more about exceptions at this point, you can go ahead and read this
    chapter before continuing with the next one.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored control statements in C#. We learned how the different
    types of loops and jump statements work with the help of examples. We also looked
    briefly at how to throw and catch exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at user-defined types and explore what fields,
    properties, methods, indexers, and constructors are in a class.
  prefs: []
  type: TYPE_NORMAL
- en: Test what you learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the selection statements available in the C# language?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where can the default case of a `switch` statement appear and when it is evaluated?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a `for` and a `foreach` statement?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a `while` and a `do-while` statement?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What statements can you use to return from a function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where can you use a `break` statement and how does it work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `yield` statement do and in which scenarios is it used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you catch all the exceptions from a function call?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `finally` block do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the base class for all exceptions in .NET?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
