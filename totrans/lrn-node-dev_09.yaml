- en: Deploying Applications to Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll worry about adding version control and deploying our
    applications because when it comes to creating real-world Node apps, deploying
    your app to the Web is obviously a pretty big part of that. Now in the real world,
    every single company uses some form of version control. It is essential to the
    software development process, and most of them aren't using Git. Git has become
    really popular, dominating the market share for version control. Git is also free
    and open source, and there is a ton of great educational material. They have a
    book on how to learn Git. It's free and Stack Overflow is filled with Git-specific
    questions and answers.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be using Git to save our project. We'll also be using it to back up our
    work to a service called GitHub, and finally we'll be using Git to deploy our
    project live to the Web. So we'll be able to take our web server and deploy it
    for anybody to visit. It won't just be available on localhost.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we''ll look into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up and using Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up GitHub and SSH keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying Node app to the web
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The workflow of the entire development life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding version control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll learn how to set up and use Git, which is a version control
    system. Git will let us keep track of the changes to our project over time. This
    is really useful when something goes wrong and we need to revert to a previous
    state in the project where things were working. It's also super useful for backing
    up our work.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started, we will need to install Git on the computer, but luckily for
    us it is a really simple installation process. It's one of those installers where
    we just click on the Next button through a few steps. So let's go ahead and do
    that.
  prefs: []
  type: TYPE_NORMAL
- en: We can grab the installer by heading over to the browser and going to [git-scm.com](http://git-scm.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we go ahead and install it, I want to show you the link to the book called
    Pro Git ([https://git-scm.com/book/en/v2](https://git-scm.com/book/en/v2)). It
    is a free book and also available for online reading. It covers everything that
    Git has to offer. We'll be looking at some of the more basic features in this
    chapter, but we could easily create an entire course on Git. There actually are
    Udemy courses just on Git and GitHub, so if you want to learn more than what we
    cover in this book, I'd recommend reading this book or checking out a course,
    whatever your preferred learning method is.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the download button present on the right-hand side of the home page,
    for all the operating systems, whether it's Windows, Linux, or macOS. This should
    take us to the installer page and we should be able to get the installer downloading
    automatically. If you see any problem with [SourceForge.net](http://SourceForge.net),
    then we may have to actually click on it to download manually in order to start
    the download.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the installer is downloaded, we can simply run it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, move through the installer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f28f15a4-51a0-4b2c-833e-2db4f5206597.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Continue and install the package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c69a0917-3956-4c99-8cd1-213499b6467d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once it''s done, we can go ahead and actually test that things installed successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7ee9bd39-d428-431b-b851-b425179cb950.png)'
  prefs: []
  type: TYPE_IMG
- en: Git on macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''re on macOS, you''ll need to launch the package installer and you might
    get the following message box saying that it''s from an unidentified developer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b642c42a-6ab9-40cf-974d-20ce383b5c53.png)'
  prefs: []
  type: TYPE_IMG
- en: This is because it is distributed via a third party as opposed to being in the
    macOS App Store. We can go ahead and right-click on the package, then click on
    the Open button and confirm that we do indeed want to open it.
  prefs: []
  type: TYPE_NORMAL
- en: Once you're at the installer, the process is going to be pretty simple. You
    can essentially click on Continue and Next throughout every step.
  prefs: []
  type: TYPE_NORMAL
- en: Git on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''re on Windows though, there is an important distinction. Inside the
    installer you''re going to see a screen just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4550bcdb-51c6-4bb5-a53c-0948d0946423.png)'
  prefs: []
  type: TYPE_IMG
- en: It is really important that you also install Git Bash as shown in the screenshot.
    Git Bash is a program that simulates a Linux-type Terminal, and it's going to
    be really essential when we create our SSH keys in the next section to uniquely
    identify our machine.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s move in to the Terminal to test the installation. From the Terminal
    we can go ahead and run `git --version`. This is going to print a new version
    of Git we have installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following screenshot, we can see we have git version 2.14.3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e395129-2b63-495b-89ff-d32c34d8d6a3.png)'
  prefs: []
  type: TYPE_IMG
- en: Now if you have your Terminal still open and you're getting an error like git
    command not found, I'd recommend trying to restart your Terminal. Sometimes that
    is required when you're installing new commands such as the `git` command, which
    we just installed.
  prefs: []
  type: TYPE_NORMAL
- en: Turning the node-web-server directory into a Git repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With successful installation of Git, we are now ready to turn our `node-web-server`
    directory into a Git repository. In order to do this, we''ll the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `git init` command needs to get executed from the root of our project,
    the folder that has everything that we want to keep track of. In our case, `node-web-server`
    is that folder. It has our `server.js` file, our `package.json` file, and all
    of our directories. So, from the server folder, we''ll run `git init`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf1cdef2-0067-47d4-a89d-b857ffd358e7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This creates a `.git` directory inside that folder. We can prove that by running
    the `ls -a` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following screenshot, we get all of the directories including
    the hidden ones and right here I do indeed have .git:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/025bc4ba-5321-442b-809f-a2f09d977e8e.png)'
  prefs: []
  type: TYPE_IMG
- en: For Windows, go ahead and run these commands from the Git Bash.
  prefs: []
  type: TYPE_NORMAL
- en: Now this directory is not something we should be manually updating. We'll be
    using commands from the Terminal in order to make changes to the Git folder.
  prefs: []
  type: TYPE_NORMAL
- en: You don't want to be going in there manually messing around with things because
    there's a pretty good chance you're going to corrupt the Git repository and all
    of your hard work is going to become useless. Now obviously if it's backed up,
    it's not a big deal, but there really is no reason to go into that Git folder.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use the `clear` command to clear the Terminal output, and now we can start
    looking at exactly how Git works.
  prefs: []
  type: TYPE_NORMAL
- en: Using Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, Git is responsible for keeping track of the changes to
    our project, but by default it doesn''t actually track any of our files. We have
    to tell Git exactly which files we want it to keep track of and there''s a good
    reason for this. There are files in every project that we''re most likely not
    going to want to add to our Git repo, and we''ll talk about which ones and why
    later. For now let''s go ahead and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now all these commands need to get executed from inside of the root of the project.
    If you try to run this outside a repository, you'll get an error like git repository
    not found. What that means is that Git cannot find that `.git` directory in order
    to actually get the status of your repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this command, we''ll get some output that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf2f92bd-950c-4cce-8b8c-49efff90be6c.png)'
  prefs: []
  type: TYPE_IMG
- en: The important pieces for now is the Untracked files header and all of the files
    underneath it. These are all of the files and folders that Git seized, but it's
    currently not tracking. Git doesn't know if you want to keep track of the changes
    to these files or if you want to ignore them from your repository.
  prefs: []
  type: TYPE_NORMAL
- en: Now the `views` folder, for example, is something we definitely want to keep
    track of. This is going to be essential to the project and we want to make sure
    that whenever someone downloads the repository, they get the `views` folder. The
    log file on the other hand doesn't really need to be included in Git. In general
    our log files are not going to be committed, since they usually contain information
    specific to a point in time when the server was running.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding code output, we have `server.js`, our public folder,
    and `package.json`. These are all essential to the process of executing the app.
    These are definitely going to be added to our Git repository, and the first one
    above we have is the `node_modules` folder. The `node_modules` folder is what's
    called a generated folder.
  prefs: []
  type: TYPE_NORMAL
- en: Generated folders are easily generated by running a command. In our case, we
    can regenerate this entire directory using `npm install`. We're not going to want
    to add Node modules to our Git repository because its contents differ depending
    on the version of npm you have installed and depending on the operating system
    you're using. It's best to leave off Node modules and let every person who uses
    your repository manually install the modules on the machine they're actually going
    to be running the app.
  prefs: []
  type: TYPE_NORMAL
- en: Adding untracked files to commit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have these six folders and files listed, so let''s go ahead and add
    the four folders and files we want to keep. To get started, we''ll use any `git
    add` command. The `git add` command lets us tell the Git we want to keep track
    of a certain file. Let''s type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After we do this, we can run it `git status` again, and this time we get something
    very different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6768c7e0-bc2a-4124-98be-a0504a0df1d4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we have an Initial commit header. This is new, and we have our old Untracked
    files header. Notice under Untracked files, we don''t have `package.json` anymore.
    That is moved up to the Initial commit header. These are all of the files that
    are going to be saved, also known as committed, when we make our first commit.
    Now we can move on adding the 3 others. We''ll use a `git add` command again to
    tell Git we want to track the public directory. We can run a `git status` command
    to confirm it was added as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12564fb0-5e07-4cd3-9e23-983de41d424d.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, we can see the public/help.html file is
    now going to be committed to Git once we run a commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up we can add `server.js` with `git add server.js`, and we can add the
    `views` directory using `git add views`, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll run a `git status` command to confirm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5000133-53cd-4855-80f3-755e0b800deb.png)'
  prefs: []
  type: TYPE_IMG
- en: Everything looks good. Now the Untracked files are going to sit around here
    until we do one of two things—we either add them to the Git repository or ignore
    them using a custom file that we're going to create inside Atom.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside Atom, we''d like to make a new file called `.gitignore`, in our root
    of our project. The `gitignore` file is going to be part of our Git repository
    and it tells get which folders and files you want to ignore. In this case we can
    go ahead and ignore `node_modules`, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28a9f78a-7f62-42f9-b13e-6a8501af7dcf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we save the `gitignore` file and rerun `git status` from the Terminal,
    we''ll now get a really different result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba523296-dcee-4f98-9716-1671a425921f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown, we can see we have a new untracked file—`.gitignore`—but the `node_modules`
    directory is nowhere in sight, and that''s exactly what we want. We want to remove
    this completely, making sure that it never ever gets added to the Git repo. Next
    up, we can go ahead and ignore that `server.log` file by typing its name, `server.log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll save `gitignore`, run `git status` from the Terminal one more time,
    and make sure everything looks great:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa3d0f70-2563-406d-8cce-3b760f5b5c4a.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown, we have a `gitignore` file as our only untracked file. The `server.log`
    file and `node_modules` are nowhere in sight.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have `gitignore`, we are going to be adding it to Git using `git
    add .gitignore` and when we run `git status`, we should be able to see that all
    the files that show up are under the initial commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/58456adc-9681-47bd-8016-f76be91ff32f.png)'
  prefs: []
  type: TYPE_IMG
- en: So now it's time to make a commit. A commit really only requires two things.
    It requires some change in the repository. In this case, we're teaching Git how
    to track a ton of new files, so we are indeed changing something, and it requires
    a message. We've already handled the file part of things. We've told Git what
    we want to save, we just haven't actually saved it yet.
  prefs: []
  type: TYPE_NORMAL
- en: Making a commit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to make our first commit and save our first thing into the Git repository,
    we''ll run `git commit` and provide one flag, the `m` flag, which is short message.
    After that inside quotes, we can specify the message that we want to use for this
    commit. It''s really important to use these messages so when someone''s digging
    through the commit history, the list of all the changes to the project can be
    seen, which are actually useful. In this case, `Initial commit` is always a good
    message for your first commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ll go ahead and hit *enter* and as shown in the following screenshot, we
    see all of the changes that happened to the repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8bee6774-3f98-4d2d-b49b-ffaa394bf715.png)'
  prefs: []
  type: TYPE_IMG
- en: We have created a bunch of new files inside of the Git repository. These are
    all of the files that we told Git we want to keep track of and this is fantastic.
  prefs: []
  type: TYPE_NORMAL
- en: We now have our very first commit, which essentially means that we've saved
    the project at its current state. If we make a big change to `server.js`, messing
    stuff up to not be able figure out how to get it back to the way it was, we can
    always get it back because we made a Git commit. Now we'll explore some more fancy
    Git things in the later sections. We'll be talking about how to do most of the
    things you want to do with Git, including deploying to Heroku and pushing to GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up GitHub and SSH keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a local Git repository, we'll look at how we can take that
    code and push it up to a third-party service called GitHub. GitHub is going to
    let us host our Git repositories remotely, so if our machine ever crashes we can
    get our code back, and it also has great collaboration tools, so we can open-source
    a project, letting others use our code, or we can keep it private so only people
    we choose to collaborate with can see the source code.
  prefs: []
  type: TYPE_NORMAL
- en: Now in order to actually communicate between our machine and GitHub, we'll have
    to create something called an SSH key. SSH keys were designed to securely communicate
    between two computers. In this case, it will be our machine and the GitHub server.
    This will let us confirm that GitHub is who they say they are and it will let
    GitHub confirm that we indeed have access to the code we're trying to alter. This
    will all be done with SSH keys and we'll create them first, then we'll configure
    them, and finally we'll push our code up to GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up SSH keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of setting up SSH keys can be a real burden. This is one of those
    topics where there's really small room for error. If you type any of the commands
    wrong, things are just not going to work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Now if you're on Windows, you'll need to do everything in this section from
    a Git Bash as opposed to the regular Command Prompt because we'll be using some
    commands that just are not available on Windows. They are, however, available
    on Linux and macOS. So if you're using either of those operating systems, you
    can continue using the Terminal you've been using throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: SSH keys documentations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we dive into the commands, I want to show you a quick guide that exists
    online in case you get stuck or you have any questions. You can Google GitHub
    SSH keys, and this is going to link you to an article called generating an SSH
    key: [https://help.github.com/articles/connecting-to-github-with-ssh/](https://help.github.com/articles/connecting-to-github-with-ssh/).
    Once you''re here, you''ll be able to click on the SSH breadcrumb, and this is
    going to bring you back to all of their articles on SSH keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/435bd81e-9ce8-4538-96fe-64cbca643e25.png)'
  prefs: []
  type: TYPE_IMG
- en: Out of these articles, the nested four are the ones we'll be focusing on checking
    if we have a key, generating a new key, adding the key to GitHub, and finally
    testing that everything worked as expected. If you run into any problems along
    any of these steps, you can always click on the guide for that step and you can
    pick the operating system you're using so you can see the appropriate commands
    for that OS. Now that you know this exists, let's go ahead and do it together.
  prefs: []
  type: TYPE_NORMAL
- en: Working on commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first command we''ll run from the Terminal is going to check if we have
    an existing SSH key. Now if you don''t, that''s fine. We''ll go ahead and create
    one. If you do or you''re not sure you do, you can run the following command to
    confirm whether or not you have one: `ls` with the `al` flag. This is going to
    print all the files in a given directory, and the directory where SSH keys are
    stored by default on your machine is going to be at the user directory, which
    you can use (`~`) as a shortcut for `/.ssh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the command, you''ll see all of the contents inside of that SSH
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b6e13c4-95a4-44bb-88bc-cb7c5aef7415.png)'
  prefs: []
  type: TYPE_IMG
- en: In this case I've deleted all of my SSH keys so I have nothing inside my directory.
    I just have paths for the current directory and the previous one. Now that we
    have this in place and we've confirmed we don't have a key, we can go ahead and
    generate one. If you do already have a key, a file like `id_rsa`, you can go ahead
    and skip the process of generating the key.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make a key we''ll use the `ssh-keygen` command. Now the `ssh-keygen` takes
    three arguments. We''ll pass in `t` setting it equal to `rsa`. We''ll pass in
    `b` which is for bytes, setting that equal to `4096`. Make sure to match these
    arguments exactly, and we''ll be setting a capital `C` flag which will get set
    equal to your email:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now the scope of what's actually happening behind the scenes is not part of
    this book. SSH keys and setting up security, that could be an entire course in
    and of itself. We'll be using this command to simplify the entire process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can go ahead and hit *enter*, which will generate two new files in our
    `.ssh` folder. When you run this command, you''ll get greeted with a few steps.
    I want you to use the default for all of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88530059-be3b-483f-b0b5-8940e302fdfe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here they want to ask you if you want to customize the file name. I do not
    recommend doing that. You can just hit *enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2ee020a-0ca3-49e8-8542-95d2a061ae15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next up they ask you for a passphrase, which we''ll not use. I''ll hit *enter*
    for no passphrase, then I need to confirm the passphrase, so I''ll just hit *enter*
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d7558f9-87a6-4555-9c1c-b5f36368cb54.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown, we get a little message that our SSH key was properly created and
    that it was indeed saved in our folder.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, I can now cycle back through my previous commands running
    the `ls` command, and what do I get?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c4674f8-fa15-4d8d-b4e8-de584d2f7536.png)'
  prefs: []
  type: TYPE_IMG
- en: We get `id_rsa` and I get the `id_rsa.pub` file. The `id_rsa` file contains
    the private key. This is the key you should never give to anyone. It lives on
    your machine and your machine only. The `.pub` file, which is the public file.
    This one is the one you'll give to third-party services such as GitHub or Heroku,
    which we'll be doing in the next several sections.
  prefs: []
  type: TYPE_NORMAL
- en: Starting up the SSH agent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that our keys are generated, the last thing we need to do is start up the
    SSH agent and add this key so it knows that it exists. We''ll do this by running
    two commands. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`eval`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssh-add`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First up we''ll run `eval`, and then we''ll open some quotes and inside the
    quotes, we''ll use the dollar sign and open and close some parentheses just like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside our parentheses we''ll type `ssh-agent` with the `s` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start up the SSH agent program and it will also print the process
    ID to confirm it is indeed running, and as shown, we get Agent pid 1116:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ceb07845-3dee-4a7c-afad-5a8c6633857f.png)'
  prefs: []
  type: TYPE_IMG
- en: The process ID is obviously going to be different for everyone. As long as you
    get something back like this you are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up we have to tell the SSH agent where this file lives. We''ll do that
    using `ssh-add`. This takes the path to our private key file which we have in
    the user directory `/.ssh/id_rsa`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When I run this, I should get a message like identity added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aafd390a-9a20-42b4-8bf4-fea82ce82d75.png)'
  prefs: []
  type: TYPE_IMG
- en: This means that the local machine now knows about this public/private key pair
    and it'll try to use these credentials when it communicates with a third-party
    service such as GitHub. Now that we have this in place, we are ready to configure
    GitHub. We'll make an account, set it up, and then we'll come back and test that
    things are working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To configure GitHub, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First head into the browser and go to [github.com](https://github.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here log into your existing account or create a new one. If you need a new one,
    sign up for GitHub. If you have an existing one, go ahead and sign into it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once signed in, you should see the following screen. This is your GitHub dashboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8febedc9-307f-45a4-9a4f-7568c1be71a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From here, navigate to Settings, present at the top-left hand side, by the
    profile picture. Go to Settings | SSH and GPG keys | SSH keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4009ef30-e031-423f-a85b-b1e064d34d49.png)'
  prefs: []
  type: TYPE_IMG
- en: From here we can add the public key, letting GitHub know that we want to communicate
    using SSH.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the new SSH key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2d79ceaf-0649-4806-9ca6-e09327a7516a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, you need to do two things: give it a name, and add the key.'
  prefs: []
  type: TYPE_NORMAL
- en: First add the name. The name can be anything you like. For example, I usually
    use one that uniquely identifies my computer since I have a couple. I'll use `MacBook
    Pro`, just like this.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3bf11c47-360e-4ed1-a677-62e46f6361f9.png)'
  prefs: []
  type: TYPE_IMG
- en: Next up, add the key.
  prefs: []
  type: TYPE_NORMAL
- en: To add the key, we need to grab the contents of the `id_rsa.pub` file, we generated
    in the previous sub-section. That file contains the information that GitHub needs
    in order to securely communicate between our machine and their machines. There
    are different methods to grab the key. In the browser, we have the Adding a new
    SSH key to your GitHub account article for our reference.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0581d38-6875-4aa3-9164-0021295dcf7b.png)'
  prefs: []
  type: TYPE_IMG
- en: This contains a command you can use to copy the contents of that file to your
    clipboard from right inside the Terminal. Now obviously it is different for the
    operating systems, macOS, Windows, and Linux, so run the command for your operating
    system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `pbcopy` command which is available for macOS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, move into the Terminal and run it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This copies the contents of the file to the clipboard. You can also open the
    command up with a regular text editor and copy the contents of the file. We can
    use any method to copy the file. It doesn't matter how you do it. All that matters
    is you do.
  prefs: []
  type: TYPE_NORMAL
- en: Now move back into GitHub, click on the text area and paste it in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/47824d09-e80c-418d-a5db-e8674a55dc52.png)'
  prefs: []
  type: TYPE_IMG
- en: The contents of `id_rsa.pub` should start with `ssh-rsa` and it should end with
    that email you used.
  prefs: []
  type: TYPE_NORMAL
- en: Once you're done, go ahead and click on Add SSH key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c6dc5fb0-fbee-49b3-b111-947fd8ce6da7.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we can go ahead and test that things are working by running one command
    from the Terminal. Once again this command can be executed from anywhere on your
    machine. You don't need to be in your project folder to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test the working of our GitHub configuration, we''ll use `ssh`, which tries
    to make a connection. We''ll use the `T` flag, followed by the URL we want to
    connect to you get at `git@github.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is going to test our connection. It will make sure that the SSH keys are
    properly set up and we can securely communicate with GitHub. When I run the command
    I get a message saying that The authenticity of host 'github.com (192.30.253.113)'
    can't be established.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/812f487e-a33e-405b-adc1-fd223a4fa200.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We know that we want to communicate with [github.com](http://www.github.com).
    We''re expecting that communication to happen, so we can go ahead and enter `yes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76f3a5f0-7184-4e53-9afa-214333fb2514.png)'
  prefs: []
  type: TYPE_IMG
- en: From here, we get a message from the GitHub servers as shown in the preceding
    screenshot. If you are seeing this message with your username then you are done.
    You're ready to create your first repository and push your code up.
  prefs: []
  type: TYPE_NORMAL
- en: Now if you don't see this message, something went wrong along the way. Maybe
    the SSH key wasn't generated correctly or it's not getting recognized by GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll move into GitHub, go back to the home page, and create a new repository.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a new repository, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the GitHub home page, in the right-hand side corner, navigate to the New
    repository button, which should look like this (click on Start New Project if
    it''s a new one):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/90b7620e-c249-4e79-a8d9-c938466f49d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will lead us to the new repository page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0488724-e8fe-4236-a050-8e537fcf4b92.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, all we need to do is give it a name. I''m going to call this one `node-course-2-web-server`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4714c8c1-9b5c-4f49-aafa-094d37a0655f.png)'
  prefs: []
  type: TYPE_IMG
- en: Once you have a name, you could give it an optional description and you can
    pick whether you want to go with a public or private repository.
  prefs: []
  type: TYPE_NORMAL
- en: Now private repositories do put you on a $7 plan. I do recommend that if you're
    creating projects with other companies.
  prefs: []
  type: TYPE_NORMAL
- en: In this case though, we're creating pretty simple projects and it doesn't really
    matter if someone else finds the code, so go ahead and use a public repository
    by clicking that option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c74b276d-3e8f-4cfd-805b-00fb8ebd3879.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have those two things filled out, click on the Create repository button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/becc7ab1-c7f4-4ea0-b896-3bd5e139ece7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is going to get brought to your repository page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6dead70-af67-4194-a4f1-c2fbe4b76e79.png)'
  prefs: []
  type: TYPE_IMG
- en: It will give you a little setup because currently there is no code to view,
    so it will give you a few instructions depending on which situation you're in.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, out of the preceding three setup instructions, we don't need the one for
    creating a new repository. We are not going to use the one for importing our code
    from some other URL. What we have is an existing repository and we want to push
    it from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8204b97-d77b-4c95-b35e-91ecf2a17931.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll run these two commands from inside our project:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one adds a new remote to our Git repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second command is going to push it up to GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remotes let Git know which third-party URLs you want to sync up with. Maybe
    I want to push my code to GitHub to communicate with my co-workers. Maybe I also
    want to be able to push up to Heroku to deploy my app. That means you would want
    two remotes. In our case, we''ll just add one, so I''ll copy this URL, move into
    the Terminal, paste it, and hit *enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our `git remote` added, we can go ahead and run that second
    command. We''ll use the second command extensively throughout the book. In the
    Terminal, we can copy and paste the code for second command, and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/c83f9342-1742-464d-ab08-8fa0a5612345.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding screenshot, we can see everything went great. We
    were able to successfully write all of our data up to GitHub, and if we go back
    into the browser and refresh the page, we''re no longer going to see those setup
    instructions. Instead, we''re going to see our repository, kind of like a tree
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fccc9e1b-31ab-493b-9752-9a30649564e1.png)'
  prefs: []
  type: TYPE_IMG
- en: Here we can see we have our `server.js` file, which is great. We don't see the
    log file or `node_module` file, which is good, because we ignored that. I have
    my public directory. Everything works really really well. We also have issues
    tracking, Pull requests. You can create a Wiki page which lets you set up instructions
    for your repository. There's a lot of really great features that GitHub has to
    offer. We'll be using just the very basic features.
  prefs: []
  type: TYPE_NORMAL
- en: 'On our repository, we can see we have one commit and if we click on that one
    commit button, you can actually go to the commits page and here we see the initial
    commit message that we typed. We made that commit in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ebb35b17-82b5-4d6e-aef1-1d0cce8dc53d.png)'
  prefs: []
  type: TYPE_IMG
- en: This is going to let us keep track of all our code, revert if we make unwanted
    changes, and manage our repository. Now that we have our code pushed up, we are
    done.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the node app to the Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll deploy your Node app live to the Web using Heroku. By
    the end of the section, you'll have the URL you can give anybody and they'll be
    able to go to that URL in their browser to view the application. We'll do this
    via Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: Heroku is a website. It's a web app for managing web applications that are hosted
    in the cloud. It's a really great service. They make it almost effortless to create
    new apps, deploy your apps, update apps, and add cool add-on-things such as logging
    and error tracking, all of that is built in. Now Heroku, like GitHub, does not
    require a credit card to sign up and there is a free tier, which we'll use. They
    have paid plans for just about everything, but we can get away with the free tier
    for everything we'll do in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Heroku command-line tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To kick things off, we''ll open up the browser and go to [heroku.com](https://www.heroku.com/).
    Here we can go ahead and sign up for a new account. Take a quick moment to either
    log in to your existing one or sign up for a new one. Once log in, it''ll show
    you the dashboard. Now your dashboard will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87c811c3-1195-476c-abc7-5007a55e5608.png)'
  prefs: []
  type: TYPE_IMG
- en: Although there might be a greeting telling you to create a new application,
    which you can ignore. I have a bunch of apps. You might not have these. That is
    perfectly fine.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we'll do is install the Heroku command-line tools. This will
    let us create apps, deploy apps, open apps, and do all sorts of really cool stuff
    from the Terminal, without having to come into the web app. That will save us
    time and make development a lot easier. We can grab the download by going to [toolbelt.heroku.com](https://devcenter.heroku.com/articles/heroku-cli).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d50fe3e5-ab59-4355-aa29-c8d5a32fa200.png)'
  prefs: []
  type: TYPE_IMG
- en: Here we're able to grab the installer for whatever operating system, you happen
    to be running on. So, let's start the download. It's a really small download so
    it should happen pretty quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it''s done, we can go ahead and run through the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff34b500-7688-4a9c-bd58-394173e8f79e.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a simple installer where you just click on Install. There is no need
    to customize anything. You don't have to enter any specific information about
    your Heroku account. Let's go ahead and complete the installer.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e96706f0-735c-483d-b391-77c533ded72b.png)'
  prefs: []
  type: TYPE_IMG
- en: This will give us a new command from the Terminal that we can execute. Before
    we can do that, we do have to log in locally in the Terminal and that's exactly
    what we'll do next.
  prefs: []
  type: TYPE_NORMAL
- en: Log in to Heroku account locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we will start off the Terminal. If you already have it running, you might
    need to restart it in order for your operating system to recognize the new command.
    You can test that it got installed properly by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this command, you''ll see that it''s installing the CLI for the
    first time and then we''ll get all the help information. This will tell us what
    commands we have access to and exactly how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df251077-46ab-48ec-848f-9c501116a932.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we will need to log in to the Heroku account locally. This process is pretty
    simple. In the preceding code output, we have all of the commands available and
    one of them happens to be login. We can run `heroku login` just like this to start
    the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ll run the `login` command and now we just use the email and password that
    we had set up before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d1db6e9-234f-4622-b73e-ff0a59a8d0ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I''ll type in my email and password. Typing for Password is hidden because
    it''s secure. And when I do that you see Logged in as garyngreig@gmail.com shows
    up and this is fantastic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98bda0a2-43c2-455e-a716-b413419aafc0.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we're logged in and we're able to successfully communicate between our machine's
    command line and the Heroku servers. This means we can get started creating and
    deploying applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting SSH key to Heroku
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now before going ahead, we''ll use the `clear` command to clear the Terminal
    output and get our SSH key on Heroku, kind of like what we did with GitHub, only
    this time we can do it via the command line. So it''s going to be a lot easier.
    In order to add our local keys to Heroku, we''ll run the `heroku keys:add` command.
    This will scan our SSH directory and add the key up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here you can see it found a key the `id_rsa.pub` file: Would you like to upload
    it to Heroku?.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc07ba5a-58fb-4d94-8add-6f48a20f0abe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Type `Yes` and hit *enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8557ad60-5ff6-47f9-b610-2af46bc03f0f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we have our key uploaded. That is all it took. Much easier than it was
    to configure with GitHub. From here, we can use the `heroku keys` command to print
    all the keys currently on our account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/5f26c53d-81eb-455c-8a04-6c36a39ac379.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We could always remove them using `heroku keys:remove` command followed by
    the email related to that key. In this case, we''ll keep the Heroku key that we
    have. Next up, we can test our connection using SSH with the `v` flag and `git@heroku.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will communicate with the Heroku servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8663a61d-95a4-452e-9a8e-5c7ebd46d3f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown, we can see it''s asking that same question: The authenticity of the
    host ''heroku.com'' can''t be established, Are you sure you want to continue connecting?
    Type `Yes`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1b7981c-4ee5-4b44-bb73-694e952531d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Now when you run that command, you'll get a lot of cryptic output. What you're
    looking for is authentication succeeded and then public key in parentheses. If
    things did not go well, you'll see the permission denied message with public key
    in parentheses. In this case, the authentication was successful, which means we
    are good to go. I'll run clear again, clearing the Terminal output.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up in the application code for Heroku
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we can turn our attention towards the application code because before we
    can deploy to Heroku, we will need to make two changes to the code. These are
    things that Heroku expects your app to have in place in order to run properly
    because Heroku does a lot of things automatically, which means you have to have
    some basic stuff set up for Heroku to work. It's not too complex—some really simple
    changes, a couple one-liners.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in the server.js file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First up in the `server.js` file down at the very bottom of the file, we have
    the port and our `app.listen` statically coded inside `server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We need to make this port dynamic, which means we want to use a variable. We'll
    be using an environment variable that Heroku is going to set. Heroku will tell
    your app which port to use because that port will change as you deploy your app,
    which means that we'll be using that environment variable so we don't have to
    swap out our code every time we want to deploy.
  prefs: []
  type: TYPE_NORMAL
- en: With environment variables, Heroku can set a variable on the operating system.
    Your Node app can read that variable and it can use it as the port. Now all machines
    have environment variables. You can actually view the ones on your machine by
    running the `env` command on Linux or macOS or the `set` command on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'What you''ll get when you do that is a really long list of key-value pairs,
    and this is all environment variables are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a25bfd6-231b-4e72-a147-c99bec678e14.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we have a LOGNAME environment variable set to Andrew. I have a HOME environment
    variable set to my home directory, all sorts of environment variables throughout
    my operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of these that Heroku is going to set is called `PORT`, which means we need
    to go ahead and grab that `port` variable and use it in `server.js` instead of
    3000\. Up at the very top of the `server.js` file, we''d to make a constant called
    `port`, and this will store the port that we''ll use for the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the first thing we''ll do is grab a port from `process.env`. The `process.env`
    is an object that stores all our environment variables as key-value pairs. We''re
    looking for one that Heroku is going to set called `PORT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is going to work great for Heroku, but when we run the app locally, the
    `PORT` environment variable is not going to exist, so we''ll set a default using
    the OR (`||`) operator in this statement. If `process.env.port` does not exist,
    we''ll set port equal to `3000` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have an app that''s configured to work with Heroku and to still run
    locally, just like it did before. All we have to do is take the `PORT` variable
    and use that in `app.listen` instead of `3000`. As shown, I''m going to reference
    `port` and inside our message, I''ll swap it out for template strings and now
    I can replace `3000` with the injected port variable, which will change over time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we have now fixed the first problem with our app. I''ll
    now run `node server.js` from the Terminal, like we did in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We still get the exact same message: Server is up on port 3000, so your app
    will still works locally as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74024ce3-1f81-4925-8a6a-b45c66f20a81.png)'
  prefs: []
  type: TYPE_IMG
- en: Changes in the package.json file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next up, we have to specify a script in `package.json`. Inside `package.json`,
    you might have noticed we have a `scripts` object, and in there we have a `test`
    script.
  prefs: []
  type: TYPE_NORMAL
- en: 'This gets set by default for npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1ceea77-ec80-431a-b609-5934b8e619c4.png)'
  prefs: []
  type: TYPE_IMG
- en: We can create all sorts of scripts inside the `scripts` object that do whatever
    we like. A script is nothing more than a command that we run from the Terminal,
    so we could take this command, `node server.js`, and turn it into a script instead,
    and that's exactly what we're going to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `scripts` object, we''ll add a new script. The script needs to be
    called `start`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b838a47f-aff9-48e1-a2a9-2ea8270104de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a very specific, built-in script and we''ll set it equal to the command
    that starts our app. In this case, it will be `node server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is necessary because when Heroku tries to start our app, it will not run
    Node with your file name because it doesn't know what your file name is called.
    Instead, it will run the start script and the start script will be responsible
    for doing the proper thing; in this case, booting up that server file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can run our app using that `start` script from the Terminal by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When I do that, we get a little output related to npm and then we get Server
    is up on port 3000, and if we visit the app in the browser, everything works exactly
    as it did in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20eb655f-3457-44f5-a41b-7ec954e7ce69.png)![](img/12aa3060-6ae5-4fd9-92ca-da30a03042bd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The big difference is that we are now ready for Heroku. We could also run the
    test script using from the Terminal `npm test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have no tests specified and that is expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/504c1768-8ee0-44d9-aba9-cbf61852fef3.png)'
  prefs: []
  type: TYPE_IMG
- en: Making a commit in Heroku
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step in the process will be to make the commit and then we can finally
    start getting it up on the Web. From the Terminal, we''ll use some of the Git
    commands we explored earlier in this chapter. First up, `git status`. When we
    run `git status`, we have something a little new:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63fd7620-9bac-46ac-bf81-1809739a6d38.png)'
  prefs: []
  type: TYPE_IMG
- en: Instead of new files, we have modified files here as shown in the code output
    here. We have a modified `package.json` file and we have a modified `server.js`
    file. These are not going to be committed if we were to run a `git commit` just
    yet; we still have to use `git add`. What we'll do is run `git add` with the dot
    as the next argument. Dot is going to add every single thing showing up and get
    status to the next commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now I only recommend using the syntax of everything you have listed in the
    `Changes not staged for commit` header. These are the things you actually want
    to commit, and in our case, that is indeed what we want. If I run `git add` and
    then a rerun `git status`, we can now see what is going to be committed next,
    under the Changes to be committed header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40663077-fbf3-49af-b2a6-b10557614460.png)'
  prefs: []
  type: TYPE_IMG
- en: Here we have our `package.json` file and the `server.js` file. Now we can go
    ahead and make that commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll run a `git commit` command with the `m` flag so we can specify our message,
    and a good message for this commit would be something like `Setup start script
    and heroku port`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now we can go ahead and run that command, which will make the commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can go ahead and push that up to GitHub using the `git push` command,
    and we can leave off the `origin` remote because the origin is the default remote.
    I''ll go ahead and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This will push it up to GitHub, and now we are ready to actually create the
    app, push our code up, and view it over in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11cc1707-de4f-48ff-9f19-e019aa29aceb.png)'
  prefs: []
  type: TYPE_IMG
- en: Running the Heroku create command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step in the process will be to run a command called `heroku create`
    from the Terminal. `heroku create` needs to get executed from inside your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like we run our Git commands, when I run `heroku create`, a couple things
    are going to happen:'
  prefs: []
  type: TYPE_NORMAL
- en: First up, it's going to make a real new application over in the Heroku web app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's also going to add a new remote to your Git repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now remember we have an origin remote, which points to our GitHub repository.
    We''ll have a Heroku remote, which points to our Heroku Git repository. When we
    deploy to the Heroku Git repository, Heroku is going to see that. It will take
    the changes and it will deploy them to the Web. When we run Heroku create, all
    of that happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ad124db-be01-4728-bdc8-0c3db0ef11b5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we do still have to push up to this URL in order to actually do the deploying
    process, and we can do that using `git push` followed by `heroku`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The brand new remote was just added because we ran `heroku create`. Now pushing
    it this time around will go through the normal process. You'll then start seeing
    some logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are logs coming back from Heroku letting you know how your app is deploying.
    It''s going through the entire process, showing you what happens along the way.
    This will take about 10 seconds and at the very end we have a success message—Verifying
    deploy... done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1e756eb-5400-47c9-b211-2796c92b01b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It also verified that the app was deployed successfully and that did indeed
    pass. From here we actually have a URL we can visit ([https://sleepy-retreat-32096.herokuapp.com/](https://sleepy-retreat-32096.herokuapp.com/)).
    We can take it, copy it, and paste it in the browser. What I''ll do instead is
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `heroku open` will open up the Heroku app in the default browser. When
    I run this, it will switch over to Chrome and we get our application showing up
    just as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16c3c634-0e1b-4641-9328-a913db1d08a0.png)'
  prefs: []
  type: TYPE_IMG
- en: We can switch between pages and everything works just like it did locally. Now
    we have a URL and this URL was given to us by Heroku. This is the default way
    Heroku generates app URLs. If you have your own domain registration company, you
    can go ahead and configure its DNS to point to this application. This will let
    you use a custom URL for your Heroku app. You'll have to refer to the specific
    instructions for your domain registrar in order to do that, but it can indeed
    be done.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have this in place, we have successfully deployed our Node applications
    live to Heroku, and this is just fantastic. In order to do this, all we had to
    do is make a commit to change our code and push it up to a new Git remote. It
    could not be easier to deploy our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also manage your application by going back over to the Heroku dashboard.
    If you give it a refresh, you should see that brand new URL somewhere on the dashboard.
    Remember mine was sleepy retreat. Yours is going to be something else. If I click
    on the sleepy retreat, I can view the app page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db13379f-d9eb-44f0-9b39-6dd4bc8c2f3b.png)'
  prefs: []
  type: TYPE_IMG
- en: Here we can do a lot of configuration. We can manage Activity and Access so
    we can collaborate with others. We have metrics, we have Resources, all sorts
    of really cool stuff. With this in place, we are now done with our basic deploying
    section.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, your challenge will be to go through that process again.
    You'll add some changes to the Node app. You'll commit them, deploy them, and
    view them live in the Web. We'll get started by creating the local changes. That
    means I'll register a new URL right here using `app.get`.
  prefs: []
  type: TYPE_NORMAL
- en: We'll create a new page/projects, which is why I have that as the route for
    my HTTP get handler. Inside the second argument, we can specify our `callback`
    function, which will get called with request and response, and like we do for
    the other routes above, the root route and our about route, we'll be calling `response.render`
    to render our template. Inside the render arguments list, we'll provide two.
  prefs: []
  type: TYPE_NORMAL
- en: The first one will be the file name. The file doesn't exist, but we can still
    go ahead and call `render`. I'll call it `projects.hbs`, then we can specify the
    options we want to pass to the template. In this case, we'll set page title, setting
    it equal to `Projects` with a capital P. Excellent! Now with this in place, the
    server file is all done. There are no more changes there.
  prefs: []
  type: TYPE_NORMAL
- en: What I'll do is go ahead and go to the `views` directory, creating a new file
    called `projects.hbs`. In here, we'll be able to configure our template. To kick
    things off, I'm going to copy the template from the about page. Since it's really
    similar, I'll copy it. Close about, paste it into projects, and I'm just going
    to change this text to project page text would go here. Then we can save the file
    and make our last change.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we want to do is update the header. We now have a brand new projects
    page that lives at `/projects`. So we'll want to go ahead and add that to the
    header links list. Right here, I'll create a new paragraph tag and then I'll make
    an anchor tag. The text for the link will be `Projects` with a capital P and the
    `href`, which is the URL to visit when that link is clicked. We'll set that equal
    to `/projects`, just like we did for about, where we set it equal to `/about`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have this in place, all our changes are done and we are ready to
    test things out locally. I'll fire up the app locally using Node with `server.js`
    as the file. To start, we're up on localhost 3000\. So over in the browser, I
    can move to the localhost tab, as opposed to the Heroku app tab, and click on
    Refresh. Right here we have Home, which goes to home, we have About which goes
    to about, and we have Projects which does indeed go to `/projects`, rendering
    the projects page. Project page text would go here. With this in place we're now
    done locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the changes, we''ve tested them, now it''s time to go ahead and make
    that commit. That will happen over inside the Terminal. I''ll shut down the server
    and run Git status. This will show me all the changes to my repository as of the
    last commit. I have two modified files: the server file and the header file, and
    I have my brand new projects file. All of this looks great. I want to add all
    of this to the next commit, so I can use a Git add with the `.` to do just that.'
  prefs: []
  type: TYPE_NORMAL
- en: Now before I actually make the commit, I do like to test that the proper things
    got added by running Git status. Right here I can see my changes to be committed
    are showing up in green. Everything looks great. Next up, we'll run a Git commit
    to actually make the commit. This is going to save all of the changes into the
    Git repository. A message for this one would be something like adding a project
    page.
  prefs: []
  type: TYPE_NORMAL
- en: With a commit made, the next thing you needed to do was push it up to GitHub.
    This will back our code up and let others collaborate on it. I'll use Git push
    to do just that. Remember we can leave off the origin remote as origin is the
    default remote, so if you leave off a remote it'll just use that anyway.
  prefs: []
  type: TYPE_NORMAL
- en: With our GitHub repository updated, the last thing to do is deploy to Heroku
    and we do that by pushing up the Git repository, using Git push, to the Heroku
    remote. When we do this, we get our long list of logs as the Heroku server goes
    through the process of installing our npm modules, building the app, and actually
    deploying it. Once it's done, we'll get brought back to the Terminal like we are
    here, and then we can open up the URL in the browser. Now I can copy it from here
    or run Heroku open. Since I already have a tab open with the URL in place, I'll
    simply give it a refresh. Now you might have a little delay as you refresh your
    app. Sometimes starting up the app right after a new app was deployed can take
    about 10 to 15 seconds. That will only happen as you first visit it. Other times
    where you click on the Refresh button, it should reload instantly.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have the projects page and if I visit it, everything looks awesome. The
    navbar is working great and the projects page is indeed rendering at `/projects`.
    With this in place, we are now done. We've gone through the process of adding
    a new feature, testing it locally, making a Git commit, pushing it up to GitHub,
    and deploying it to Heroku. We now have a workflow for building real-world web
    applications using Node.js. This also brings a close to this section.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You also learned about Git, GitHub, and Heroku. These are the tools I prefer
    to use when I'm creating applications. I like to use Git because it's super popular.
    It's basically the only choice these days. I like to use GitHub because it has
    a great user interface. It has a ton of awesome features and pretty much everyone
    else is using it too. There's a great community. And I like to use Heroku because
    it is just dead simple to deploy new versions of your application. You can swap
    out any of these tools with any other tools. You can use services such Amazon
    Web Services to host. You could use Bitbucket as your GitHub alternative. These
    are perfectly fine solutions. All that really matters is you have some tools that
    are working for you, you have a Git repository backed up somewhere, whether it's
    GitHub or Bitbucket, and you have an easy way to deploy so you can make changes
    quickly and get them out to your users fast.
  prefs: []
  type: TYPE_NORMAL
- en: In different sections, we looked at how to add files to Git and how to make
    that first commit. Next, we set up both GitHub and Heroku, then we looked at how
    to push our code and deploy it. Then, we looked at how we can communicate with
    Heroku to deploy our code. Then after that, we looked at some real-world workflows
    for creating new commits, pushing to GitHub, and deploying to Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look into testing our applications.
  prefs: []
  type: TYPE_NORMAL
