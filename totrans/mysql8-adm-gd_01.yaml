- en: An Introduction to MYSQL 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL is a well-known open source structured database because of its performance,
    easiness to use, and reliability. This is the most common choice of web applications
    for a relational database. In the current market, thousands of web-based applications
    rely on MySQL including giant industries such as Facebook, Twitter, and Wikipedia.
    It has also proven to be the database choice for **Software as a Service** (**SaaS**)
    based applications such as Twitter, YouTube, SugarCRM, Supply Dynamics, Workday,
    RightNow, Omniture, Zimbra, and many more. We will discuss this in detail in the
    *use cases of MySQL* section later in the chapter. MySQL was developed by MySQL
    AB, a Swedish company, and now it is distributed and supported by Oracle Corporation.
    MySQL carries a valuable history with it.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL has continued to improve in order to become an enterprise-level database
    management system. MySQL 8 is expected to be a game-changer as today we are in
    the age of digitization. MySQL 8 is all tuned to serve many new use cases that
    in prior versions were difficult to achieve. Some of the use cases an enormous
    amount of data is produced are social networking, e-commerce, bank/credit card
    transactions, emails, data stored on the cloud, and so on. Analysis of all such
    structured, unstructured, or semi-structured ubiquitous data helps to discover
    hidden patterns, market trends, correlations, personal preferences.
  prefs: []
  type: TYPE_NORMAL
- en: '"There is so much for each of us"'
  prefs: []
  type: TYPE_NORMAL
- en: '- James Truslow Adams'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take an in-depth look at MySQL 8 new features, benefits, use cases along
    with a few limitations of MySQL 8 after we have an overview of MySQL. This is
    going to be exciting, let's get prepared.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of MySQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Structured Query Language** (**SQL**) is used to manipulate, retrieve, insert,
    update, and delete data in **relational database management system** (**RDBMS**).
    To make it simpler, SQL tells the database what to do and exactly what it needs.
    SQL is a standard language that all RDBMS systems such as MySQL, MS Access, MS
    SQL, Oracle, Postgres, and others use.'
  prefs: []
  type: TYPE_NORMAL
- en: RDBMS is the basis for SQL and for all modern database systems such as MS SQL
    Server, IBM DB2, Oracle, MySQL, and Microsoft Access.
  prefs: []
  type: TYPE_NORMAL
- en: SQL allows users to access data from MySQL and define and manipulate the data.
    To embed within other languages, you can leverage SQL modules, libraries, and
    precompilers, which can help you create/drop databases and tables, allow users
    to create the view, and stored procedures, functions, and so on, in a database.
    It can do various other operations such as allowing users to set permissions on
    tables, procedures, and views.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL as a relational database management system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data in a relational database is stored in an organized format so that information
    can be retrieved easily. Data will be stored in different tables made up of rows
    and columns. However, the relationship can also be built between different tables
    that efficiently store huge data and effectively retrieve the selected data. This
    provides database operations with tremendous speed and flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: As a relational database, MySQL has capabilities to establish relationships
    with different tables such as one to many, many to one, and one to one by providing
    primary keys, foreign keys, and indexes. It can also perform joins between tables
    to retrieve exact information such as inner joins and outer joins.
  prefs: []
  type: TYPE_NORMAL
- en: SQL is used as an interface to interact with the relational data in MySQL. SQL
    is an **American National Standard Institute** (**ANSI**) standard language which
    we can operate with data such as creation, deletion, updating, and retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: License requirements of MySQL8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many industries prefer open source technology because of the technology's flexibility
    and cost-saving features, while MySQL has put its footprint in the market by becoming
    the most popular relational database for web applications. Open source means that
    you can view the source of MySQL and customize it based on your needs without
    any cost. You can download the source or binary files from its site and use them
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL server is covered under the **General Public License** (**GNU**),
    which means that we can freely use it for web applications, study its source code,
    and modify it to suit our needs. It also has the Enterprise Edition as well with
    advanced features included. Many enterprises still purchase the support contract
    from MySQL to get assistance on various issues.
  prefs: []
  type: TYPE_NORMAL
- en: Reliability and scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL has great reliability to perform well without requiring extensive troubleshooting
    due to bottlenecks or other slowdowns. It also incorporates a number of performance
    enhanced mechanisms such as index support, load utilities, and memory caches.
    MySQL uses InnoDB as a storage engine, which provides highly efficient ACID compliant
    transactional capabilities that assure high performance and scalability. To handle
    the rapidly growing database, MySQL Replication and cluster help scale out the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Platform compatibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL has great cross-platform availability that makes it more popular. It is
    flexible to run on major platforms such as RedHat, Fedora, Ubuntu, Debian, Solaris,
    Microsoft Windows, and Apple macOS. It also provides **Application Programming
    Interface** (**APIs**) to interconnect with various programming languages such
    as C, C++, C#, PHP, Java, Ruby, Python, and Perl.
  prefs: []
  type: TYPE_NORMAL
- en: Releases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a list of major releases of MySQL so far:'
  prefs: []
  type: TYPE_NORMAL
- en: Version 5.0 GA was released on 19th October, 2005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version 5.1 GA was released on 14th November, 2008
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version 5.5 GA was released on 3rd December, 2010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version 5.6 GA was released on 5th February, 2013
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version 5.7 GA was released on 21st October, 2015
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now it's time for the major version release--MySQL 8--which was announced on
    12th September, 2016 and is still in the development milestone mode.
  prefs: []
  type: TYPE_NORMAL
- en: Core features in MySQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look back and quickly glance through some of the core features in MySQL.
    We will be discussing various features throughout the book in detail as we progress.
  prefs: []
  type: TYPE_NORMAL
- en: Structured database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structured databases are traditional databases that have been used by many enterprises
    for more than 40 years. However, in the modern world, data volume is becoming
    bigger and bigger and a common need has taken its place--data analytics. Analytics
    is becoming difficult with structured databases as the volume and velocity of
    digital data grow faster by the day; we need to find a way to achieve such needs
    in an effective and efficient way. The most common database that is used as a
    structured database in the open source world is MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Many organizations use a structured database to store their data in an organized
    way with the formatted repository. Basically, data in a structured database has
    a fixed field, a predefined data length, and defines what kind of data is to be
    stored such as numbers, dates, time, addresses, currencies, and so on. In short, the
    structure is already defined before data gets inserted, which gives a clearer
    idea of what data can reside there. The key advantage of using a structured database
    is  that data being easily stored, queried, and analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: An unstructured database is the opposite of this; it has no identifiable internal
    structure. It can have a massive unorganized agglomerate or various objects. Mainly,
    the source of structured data is machine-generated, which means information is
    generated from the machine and without human intervention, whereas unstructured
    data is human-generated data. Organizations use structured databases for data
    such as ATM transactions, airline reservations, inventory systems, and so on.
    In the same way, some organizations use unstructured data such as emails, multimedia
    content, word processing documents, web pages, business documents, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Database storage engines and types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now look at an overview of different MySQL storage engines. This is
    an important section that gives a brief of different database storage engines;
    we will be discussing this in detail in [Chapter 6](16211f16-1fc2-419a-a040-46f7970fc4cc.xhtml),
    *MySQL 8 Storage Engines*. MySQL stores data in the database as a subdirectory.
    In each database, data is stored as tables. When you create a table, MySQL stores
    the table definition in `.frm` with the same name as the table name*.* You can
    use the `SHOW TABLE STATUS` command to show information about your table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This command shows that this is an `InnoDB` table with the column name `Engine`.
    There is additional information that you can refer to for other purposes such
    as the number of rows, index length, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The storage engine is the way to handle SQL operations for different table types.
    Each storage engine has its own advantages and disadvantages. It is important
    to understand each storage engine's features and choose the most appropriate one
    for your tables to maximize the performance of the database. `InnoDB` is the default
    storage engine when we create a new table in MySQL 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MySQL server uses a plug-and-play storage engine architecture. You can
    load the required storage engine and unload unnecessary storage engines from the
    MySQL server with the help of the `SHOW ENGINES` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Overview of InnoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`InnoDB` is the default storage engine broadly used out of all other available
    storage engines. It was released with MySQL 5.1 as a plugin in 2008\. MySQL 5.5
    and later has `InnoDB` as a default storage engine. It has been taken over by
    Oracle Corporation in October 2005, from the Innobase Oy, which is a Finland-based
    company.'
  prefs: []
  type: TYPE_NORMAL
- en: InnoDB tables support ACID-compliant commits, rollback, and crash recovery capabilities
    to protect user data. It also supports row-level locking, which helps with better
    concurrency and performance. It stores data in clustered indexes to reduce I/O
    operations for all SQL select queries based on the primary key. It also supports
    `FOREIGN KEY` constraints that allow better data integrity for the database. The
    maximum size of an InnoDB table can scale up to 64 TB, which should be good enough
    to serve many real-world use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of MyISAM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`MyISAM` was the default storage engine for MySQL prior to 5.5 1\. `MyISAM`
    storage engine tables do not support ACID-compliant as opposed to `InnoDB`. `MyISAM`
    tables support table-level locking only, so `MyISAM` tables are not transaction-safe;
    however, they are optimized for compression and speed. It is generally used when
    you need to have primarily read operations with minimal transaction data. The
    maximum size of a `MyISAM` table can grow up to 256 TB, which helps in use cases
    such as data analytics. `MyISAM` supports full-text indexing, which can help in
    complex search operations. Using full-text indexes, we can index data stored in
    `BLOB` and `TEXT` data types.'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A memory storage engine is generally known as a heap storage engine. It is used
    to access data extremely quickly. This storage engine stores data in the RAM so
    it wouldn't need I/O operation. As it stores data in the RAM, all data is lost
    upon server restart. This table is basically used for temporary tables or the
    lookup table. This engine supports table-level locking, which limits high write
    concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important notes about memory tables are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Because memory table stores data in the RAM, which has a very limited storage
    capacity; if you try to write too much data into the memory table, it will start
    swapping data into the disk and then you lose the benefits of the memory storage
    engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These tables don't support `TEXT` and `BLOB` data types, and it is not even
    required as it has limited storage capacity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This storage engine can be used to cache the results; lookup tables, for example,
    or postal codes and the names of states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory tables support B-tree indexes and Hash indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of archive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This storage engine is used to store large amounts of historical data without
    any indexes. Archive tables do not have any storage limitations. The archive storage
    engine is optimized for high insert operations and also supports row-level locking.
    These tables store data in a compressed and small format. The archive engine does
    not support `DELETE` or `UPDATE` operations; it only allows `INSERT`, `REPLACE`,
    and `SELECT` operations.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of BLACKHOLE as a storage engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This storage engine accepts data but does not store it. It discards data after
    every `INSERT` instead of storing it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what is the use of this storage engine; why would anybody use it? Why would
    we run an `INSERT` query that doesn't insert anything into the table?
  prefs: []
  type: TYPE_NORMAL
- en: This engine is useful for replication with large number of servers. A `BLACKHOLE`
    storage engine acts as a filter server between the master and slave server, which
    do not store any data, but only apply `replicate-do-*` and `replicate-ignore-*`
    rules and write a `binlogs`. These `binlogs` are used to perform replication in
    slave servers. We will discuss this in detail in [Chapter 8](03c98d39-8cb9-4171-beb1-0bd9dcaac81a.xhtml), *Replication
    in MySQL 8*.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of CSV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **comma separated values** (**CSV**) engine stores data in the `.csv` file
    type using the comma-separated values format. This engine extracts data from the
    database and copies it to `.csv` out of the database. If you create a CSV file
    from the spreadsheet and copy it into the MYSQL data folder server, it can read
    the data using the select query. Similarly, if you write data in the table, an
    external program can read it from the CSV file. This storage engine is used for
    the exchange of data between software or applications. A CSV table does not support
    indexing and partitioning. All columns in the CSV storage engine need to be defined
    with the `NOT NULL` attribute to avoid errors during table creation.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of merge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This storage engine is also known as an `MRG_MyISAM` storage engine. This storage
    engine merges a `MyISAM` table and creates it to be referred to a single view.
    For a merge table, all columns are listed in the same order. These tables are
    good for data warehousing environments.
  prefs: []
  type: TYPE_NORMAL
- en: The table is used to manage log-related tables, generally. You can create different
    months of logs in separate `MyISAM` tables and merge these tables using the merge
    storage engine.
  prefs: []
  type: TYPE_NORMAL
- en: '`MyISAM` tables have storage limit for the operating system, but a collection
    of `MyISAM` (merge) tables do not have storage limits. So using a merge table
    would allow you to split data into multiple `MyISAM` tables, which can help in
    overcoming storage limits.'
  prefs: []
  type: TYPE_NORMAL
- en: Merge tables do not support partitioning. Also, you cannot partition a merge
    table or any of a merge table's underlying `MyISAM` tables in a different partition.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of federated
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This storage engine allows you to create a single database on a multiple physical
    server. It opens a client connection to another server and executes queries against
    a table there, retrieving and sending rows as needed. It was originally marketed
    as a competitive feature that supported many enterprise-grade proprietary database
    servers, such as Microsoft SQL Server and Oracle, but that was always a stretch,
    to say the least. Although it seemed to enable a lot of flexibility and neat tricks,
    it has proven to be a source of many problems and is disabled by default. This
    storage engine is disabled by default in MySQL; to enable it, you need to start
    the MySQL server binary using the federated option.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the NDB cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NDB cluster (also known as **NDB**) is an in-memory storage engine offering
    high availability and data persistence features.
  prefs: []
  type: TYPE_NORMAL
- en: The NDB cluster storage engine can be configured with a range of failover and
    load balancing options, but it is easiest to start with the storage engine at
    the cluster level. NDB cluster uses the NDB storage engine that contains a complete
    set of data, which is dependent only on other datasets available within the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The cluster portion of the NDB cluster is configured independently of the MySQL
    servers. In an NDB cluster, each part of the cluster is considered to be a node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each storage engine has its own advantage and usability, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Search Engine**: NDBCluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transactions** **data**: `InnoDB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session data**: `MyISAM` or NDBCluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Localized calculations**: Memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dictionary**: `MyISAM`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram will help you understand which store engine you need
    to use for your requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/adca82d9-44e8-425d-81a1-c475634b7355.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now you have a better idea about various storage engines along with different
    use cases, which will help you to make a decision based on your needs.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to move on to our next topic where we will look at delightful new
    features available in MySQL 8.
  prefs: []
  type: TYPE_NORMAL
- en: Improved features in MySQL 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MySQL database development team has recently announced its major release
    as MySQL 8 **Development Milestone Release** (**DMR**). It contains significant
    updates and fixes for problems that were much needed.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why it's 8 after 5.7! Were the intermediate versions,
    that is, 6 and 7, miss out? Of course not! Actually, 6.0 was preserved as part
    of the changeover to a more frequent and timely release, while 7.0 for the clustering
    version of MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see some exciting features that have been introduced in this latest
    version, as depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9b442dc-1adf-41ba-b221-7816d29a0309.png)'
  prefs: []
  type: TYPE_IMG
- en: It's time to look at MySQL 8 features in detail, which makes us excited and
    convinced about the reasons for a major version upgrade of MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Transactional data dictionary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until the previous version, the MySQL data dictionary was stored in different
    metadata files and non-transactional tables, but from this version onwards, it
    will have a transactional data dictionary to store the information about the database.
    No more `.frm`, `.trg`, or `.par` files. All information will be stored in the
    database, which removes the cost of performing heavy file operations. There were
    numerous issues with filesystem metadata storage such as the vulnerability of
    the filesystem, exorbitant file operations, difficult to handle crash recovery
    failures, or replication; it was also difficult to add new feature-related metadata.
    Now this upgrade has made it simple by storing information in a centralized manner,
    and will have improved performance as this data dictionary object can be cached
    in memory, similar to other database objects.
  prefs: []
  type: TYPE_NORMAL
- en: This data dictionary will have data that is needed for SQL query execution such
    as catalog information, character sets, collations, column types, indexes, database
    information, tables, stored procedures, functions and triggers, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In MySQL 8, the privileges module has been improved by introducing roles, which
    means a collection of permissions. Now we can create roles with a number of privileges
    and assign them to multiple users.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with the previous version was that we were not able to define generic
    permissions for a group of users and each user has individual privileges. Suppose
    if there are 1,000 users already existing that have common privileges, and you
    want to remove the write permissions for these 1,000 users, what would you have
    done in the previous version? You would have had to take the time-consuming approach
    of updating each user, right? Arrgh! That's a long, long task.
  prefs: []
  type: TYPE_NORMAL
- en: Now with MySQL 8, it is easy to update any change in privileges. Roles will
    define all the required privileges and this role will be assigned to those 1,000
    users. We just need to make any privilege changes in the role and all users will
    automatically inherit the respective privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Roles can be created, deleted, grant or revoke permission, grant or revoke from
    the user account, and can specify the default role within the current session.
  prefs: []
  type: TYPE_NORMAL
- en: InnoDB auto increment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL 8 has changed the auto-increment counter value store mechanism. Previously,
    it was stored in the memory, which was quite difficult to manage during server
    restarts or server crashes. However, now the auto-increment counter value is written
    into the redo log whenever the value gets changed and, on each checkpoint, it
    will be saved in the system table, which makes it persistent across the server
    restart.
  prefs: []
  type: TYPE_NORMAL
- en: With the previous version, update of the auto-increment value may have caused
    duplicate entry errors. Suppose if you updated the value of auto-increment in
    the middle of the sequence with a larger than the current maximum value, but then
    subsequent insert operations could not identify the unused values, which could
    cause a duplicate entry issue. This has been prevented by persisting the auto-increment
    value, hence subsequent insert operations can get the new value and allocate it
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: If server restart happened, the auto-increment value was lost with the previous
    version as it was stored in memory and `InnoDB` needed to execute a query to find
    out the maximum used value. This has been changed, as the newer version has the
    capability to persist its value across the server restart. During the server restart,
    `InnoDB` initializes the counter value in memory using the maximum value stored
    in the data dictionary table. In case of server crashes, `InnoDB` initializes
    the auto-increment counter value that is bigger than the data dictionary table
    and the redo log.
  prefs: []
  type: TYPE_NORMAL
- en: Invisible indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL 8 provides you with a feature to make indexes invisible. These kinds of
    indexes cannot be used by the optimizer. In case you want to test the query performance
    without indexes, using this feature you can do so by making them invisible rather
    than dropping and re-adding an index. This is a handy feature when indexing is
    supposed to be dropped and recreated on huge datasets.
  prefs: []
  type: TYPE_NORMAL
- en: 'All indexes are visible by default. To make them invisible or visible, `INVISIBLE`
    and `VISIBLE` keywords are used respectively, as described in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Improving descending indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Descending indexes existed in version 5.7 too, but they were scanned in reverse
    order, which caused performance barriers. To improve performance, MySQL 8 has
    optimized this and scanned descending indexes in forward order, which has drastically
    improved performance. It also brings multiple column indexes for the optimizer
    when the most efficient scan order has ascending order for some columns, and descending
    order for other columns.
  prefs: []
  type: TYPE_NORMAL
- en: The SET PERSIST variant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Server variables can be configured globally and dynamically while the server
    is running. There are numerous system variables that we can set using `SET GLOBAL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, such settings will be lost after server restart. To avoid this, MySQL
    8 has introduced the `SET PERSIST` variant, which preserves variables across a
    server restart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Expanded GIS support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until the previous version, it supported only one coordinate system, a unitless
    2D place that was not referenced to a position on earth. Now MySQL 8 has added
    support for a **Spatial Reference System** (**SRS**) with geo-referenced ellipsoids
    and 2D projections. SRS helps assign coordinates to a location and establishes
    relationships between sets of such coordinates. This spatial data can be managed
    in data dictionary storage as the `ST_SPATIAL_REFERENCE_SYSTEMS` table.
  prefs: []
  type: TYPE_NORMAL
- en: Default character set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default character set has been changed from `latin1` to `UTF8`. `UTF8` is
    the dominating character set, though it hadn't been a default one in previous
    versions of MySQL. Along with the character set default, collation has been changed
    from `latin1_swedish_ci` to `utf8mb4_800_ci_ai`. With these changes globally accepted,
    character sets and collations are now based on `UTF8`; one of the common reasons
    is because there are around 21 different languages supported by `UTF8`, which
    makes systems provide multilingual support.
  prefs: []
  type: TYPE_NORMAL
- en: Extended bit-wise operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In MySQL 5.7, bit-wise operations and functions were working for `BIGINT` (64-bit
    integer) data types only. We needed to pass `BIGINT` as an argument and it would
    return the result as `BIGINT`. In short, it had maximum range up to 64 bits to
    perform operations. A user needs to do conversion to the `BIGINT` data type in
    case they want to perform it on other data types. This typecasting was not feasible
    for data types larger than 64 bits as it would truncate the actual value, which
    resulted in inaccuracy.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL 8 has improved bit-wise operations by enabling support for other binary
    data types such as `Binary`, `VarBinary`, and `BLOB`. This makes it possible to
    perform bit-wise operations on larger than 64-bit data. No more typecasting needed!
    This allows the taking of arguments and returning results larger than 64 bits.
  prefs: []
  type: TYPE_NORMAL
- en: InnoDB Memcached
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multiple get operations are now possible with the `InnoDB` memcached plugin,
    which will really help in improving the read performance. Now, multiple key value
    pairs can be fetched in a single memcached query. Frequent communication traffic
    has also been minimized as we can get multiple data in a single shot.
  prefs: []
  type: TYPE_NORMAL
- en: Range queries are also supported by the `InnoDB` Memcached plugin. It simplifies
    range searches by specifying a particular range and retrieves values within this
    range.
  prefs: []
  type: TYPE_NORMAL
- en: NOWAIT and SKIP LOCKED
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When rows are locked by other transactions that you are trying to access, then
    you need to wait for that transaction to release the lock on the same row so that
    you can access it accordingly. To avoid waiting for the other transaction, `InnoDB`
    has added support of the `NOWAIT` and `SKIP LOCKED` options. `NOWAIT` will return
    immediately with an error in case the requested row is locked rather than going
    into the waiting mode, and `SKIP LOCKED` will skip the locked row and never wait
    to acquire the row lock. Hence, `SKIP LOCKED` will not consider the locked row
    in the resulting set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSON support had been implemented in MySQL 5.7; it was well-acknowledged feature.
    In MySQL 8 it has added various functions that would allow us to get dataset results
    in JSON data format, virtual columns, and tentatively 15 SQL functions that allow
    you to search and use JSON data on server side. In MySQL8 there are additional
    aggregation functions added that can be used in JSON objects/arrays to represent
    loaded data in a further optimized way. The following are the two JSON aggregation
    functions that were introduced in MySQL8:'
  prefs: []
  type: TYPE_NORMAL
- en: '`JSON_OBJECTAGG()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JSON_ARRAYAGG()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In MySQL 8 a new option is introduced `innodb_dedicated_server`, which would
    be helpful for vertical scaling of the servers. It actually automatically detects
    the memory allocated to the virtual server and appropriately set MySQL 8 without
    any need to change configuration files. These would be very handy features considering
    the adoption of virtualization and cloud is there. In fact with this configuration,
    you might not even need to get shell access of server to edit the configuration
    files. You can do this with the new `SET PERSIST` feature that can set relevant
    configuration from the MySQL command line itself, which can enhance security further
    as you almost wouldn't need shell access of the server.
  prefs: []
  type: TYPE_NORMAL
- en: Resource management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL 8 has come up with a wonderful resource management feature that will allow
    you to allocate resource to threads running on a server, which would be executed
    based on the resources configured for the group. Currently, CPU time is a resource
    that can be configured for a group. With this, you can tweak your workloads with
    virtual resource management within MySQL itself. MySQL will identify on startup
    numbers of virtual CPUs available and after that users with appropriate privileges
    can map the virtual CPUs with resource group and align thread management to these
    groups.
  prefs: []
  type: TYPE_NORMAL
- en: We expect to see more features by the time MySQL 8 is available for general
    use. Let us now look at benefits of using MySQL 8.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of using MySQL 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether you are a developer or an enterprise, you would obviously choose one
    that provides good benefits and results when compared to other related products.
    MySQL provides numerous advantages as the first choice in this competitive market.
    It has various powerful features available that make it a more comprehensive database.
    Let's now go through some benefits of using MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing that comes to mind is securing data because nowadays data has
    become precious and can impact business continuity if legal obligations are not
    met; in fact, it can be so bad that it can close down your business in no time.
    MySQL is the most secure and reliable database management system used by many
    well-known enterprises such as Facebook, Twitter, and Wikipedia. It really provides
    a good security layer that protects sensitive information from intruders. MySQL
    gives access control management so that granting and revoking required access
    from the user is easy. Roles can also be defined with a list of permissions that
    can be granted or revoked for the user. All user passwords are stored in an encrypted
    format using plugin-specific algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Day by day, the mountain of data is growing because of extensive use of technology
    in numerous ways. Because of this, load average is going through the roof. In
    some cases, it is unpredictable that data cannot exceed up to some limit or number
    of users will not go out of bounds. Scalable databases would be a preferable solution
    so that, at any point, we can meet unexpected demands to scale. MySQL is a rewarding
    database system for its scalability, which can scale horizontally and vertically;
    in terms of data, spreading database and load of application queries across multiple
    MySQL servers is quite feasible. It is pretty easy to add horsepower to the MySQL
    cluster to handle the load.
  prefs: []
  type: TYPE_NORMAL
- en: An open source relational database management system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL is an open source database management system that makes debugging, upgrading,
    and enhancing the functionality fast and easy. You can view the source and make
    the changes accordingly and use it in your own way. You can also distribute an
    extended version of MySQL, but you will need to have a license for this.
  prefs: []
  type: TYPE_NORMAL
- en: High performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL gives high-speed transaction processing with optimal speed. It can cache
    the results, which boosts read performance. Replication and clustering make the
    system scalable for more concurrency and manages the heavy workload. Database
    indexes also accelerate the performance of `SELECT` query statements for substantial
    amount of data. To enhance performance, MySQL 8 has included indexes in performance
    schema to speed up data retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: High availability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, in the world of competitive marketing, an organization's key point is
    to have their system up and running. Any failure or downtime directly impacts
    business and revenue; hence, high availability is a factor that cannot be overlooked.
    MySQL is quite reliable and has constant availability using cluster and replication
    configurations. Cluster servers instantly handle failures and manage the failover
    part to keep your system available almost all the time. If one server gets down,
    it will redirect the user's request to another node and perform the requested
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL provides cross-platform flexibility that can run on various platforms
    such as Windows, Linux, Solaris, OS2, and so on. It has great API support for
    the all major languages, which makes it very easy to integrate with languages
    such as PHP, C++, Perl, Python, Java, and so on. It is also part of the **Linux
    Apache MySQL PHP** (**LAMP**) server that is used worldwide for web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s now time to get our hands dirty and look at MySQL 8; let''s start with
    the installation of MySQL 8 on a Linux platform in our case. We prefer MySQL 8
    on a Linux operating system as that has been a common use case across many organizations.
    We will be discussing more installation in [Chapter 2](69eaf074-9446-4da9-918c-765f7e001f8c.xhtml),
    *Installing and Upgrading MySQL 8*. You can use it on other platforms that MySQL
    supports, such as Windows, Solaris, HP-UNIX, and so on. Linux provides various
    ways to install the MySQL server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RPM` package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`YUM` repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APT` repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SLES` repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Debian` package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TAR` package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling and installing from the source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limitations of MySQL 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A coin has two sides; similarly, benefits of also using MySQL 8 would come along
    with a few limitations. Let us walk through a few areas of MySQL 8 now.
  prefs: []
  type: TYPE_NORMAL
- en: Number of tables or databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The number of databases or tables are not a limitation for MySQL 8; however,
    the operating system file limit can be a limitation for MySQL 8\. Storage Engine
    `InnoDB` is allowed to scale up to four billion tables as its peak number.
  prefs: []
  type: TYPE_NORMAL
- en: Table size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may hit maximum table size limit, which is not restricted from MySQL 8;
    however, it may be because of operating system filesystem limits.
  prefs: []
  type: TYPE_NORMAL
- en: Joins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a single join, one can use 61 tables, which can be referred. It is also applicable
    to the tables that are referenced in view definition. Joins that are part of subqueries
    and views are also considered to be part of the limitation.
  prefs: []
  type: TYPE_NORMAL
- en: Windows platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are few limitations when you have MySQL 8 used on the Windows platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory**: 32-bit architecture has limitation to use only 2 GB of RAM for
    a process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ports**: In case you have a high number of concurrency you might come across
    Windows platform limitation of having 4000 ports available for client connections
    in total.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Case-insensitivity**: The Windows platform doesn''t have case sensitivity,
    which is why tables and databases need to be deliberately managed for case-insensitivity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pipes**: `|`, generally referred as pipe signs, they are not fully supported
    in Windows. You might come across them in a few scenarios while doing database
    administration activities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pathname separator**: MySQL 8 escape character is `\`, which is the pathname
    separator for Windows. Hence while using path separator you can double slash as
    "\\" as an alternative for a pathname separator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table column count
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The table column for each table in MySQL 8 has a limit of 4096 columns. It might
    vary based on a few other factors for columns count limit, as stated in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Row size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL tables have a limit of 65,535 bytes for a row, although storage engines
    such as `InnoDB` are capable of supporting larger chunks.
  prefs: []
  type: TYPE_NORMAL
- en: InnoDB storage engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Limitations on `InnoDB` storage engine are what we will talk about a bit more
    specifically as `InnoDB` now with MySQL 8 will play a prominent role.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of InnoDB storage engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will have a quick glance at a few of the limitations of `InnoDB` storage
    engine:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of indexes supported can be maximum 64 for a table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For tables that use compressed or dynamic row format; 3072 is the index key
    prefix length limit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For tables that use compact or redundant row format; 767 is the index key prefix
    length limit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Total columns in a table, which includes virtual generated columns, are limited
    to a maximum of 1,017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16 columns is the maximum permitted for multi-column indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The combined `InnoDB` log file size cannot exceed 512 GB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum table size supported by `InnoDB` is 256 TB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AdminAPI is not supported while using unix socket connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-byte characters might give you unreliable aligned columns while formatting
    of results in `InnoDB` clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restrictions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now have a quick glance at a few of the restrictions of the `InnoDB`
    storage engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Delete from tablename`: It doesn''t actually delete the complete table, instead
    it deletes each row of the table one after another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Show table status`: It wouldn''t provide you accurate data all the time; it
    provides estimates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When counting rows, the number of rows provided by `count(*)` is not accurate
    because of concurrency; it would count only those counts visible to transactions
    currently available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is multiple `analyze table` queries executed, later one will be blocked
    until the first one gets completed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InnoDB` keeps an exclusive lock on the index at the end associated with the `auto_increment`
    column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a case the `auto_increment` integer runs out of the value; the following
    insert operations would show us duplicate-key errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foreign keys that are cascaded cannot activate triggers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a few column names reserved by MySQL that `InnoDB` uses for internal
    purposes. The following are a few such column names:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DB_ROW_ID`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DB_TRX_ID`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DB_ROLL_PTR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DB_MIX_ID`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We might come across output shown in the following example in case of such
    reserved column names used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`InnoDB` locks are released immediately after the transaction is aborted or
    committed, which is held by a transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The addition of table locks are not supported, as locks are implicit to `commit`
    and `unlock tables`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data dictionary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us have a look at a few known limitations of data dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: Individual `MyISAM` tables for backup and restore are not supported by merely
    copying the files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually created directories for databases are not supported by MySQL 8\. For
    instance, using `mkdir` would have no impact on MySQL server data dictionary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DDL` operations would take more time than expected because such operations
    are written to storage, undo logs and redo instead of `.frm` files as what we
    would have seen in prior versions of MySQL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limitations of group replication in MySQL8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s now time to discuss a few limitations of group replication in MySQL 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Large transactions**: Transactions that result to GTID contents cannot be
    replicated between the rest of the members of the group if they''re too large.
    It is suggested to use smaller chunks of data that cannot be replicated in around
    five seconds to group members to avoid failures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cluster from a group**: If you try to create clusters from an existing group
    replication setup it will result in an error as the instance would already be
    part of a replication group. This is noticed currently only in MySQL''s wizard
    mode only; an alternative solution for the issue is to disable wizard mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serializable isolation level**: Serializable isolation level is not supported
    when multi-primary groups are used, which is the default configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DDL and DML operations**: If there is concurrent DDL and DML operations executed
    against the same data object but on different servers is not supported when multi-primary
    group mode is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replication checksum**: Currently MySQL design limitations create restrictions
    of having replication event checksums.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limitations of partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be discussing limitations of partitioning in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Constructs prohibition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the constructs that are not allowed in expressions of partitions:'
  prefs: []
  type: TYPE_NORMAL
- en: Declared variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stored procedures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stored functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UDFs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few operators that are not permitted in partition expressions such
    as `<<` , `>>` , `|` , `&` , `~` and `^` . Results for arithmetic operators such
    as `+`, `-`, and `*` must have an integer value or `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: Tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are a few specific areas that show us limitations of partitioning
    on tables:'
  prefs: []
  type: TYPE_NORMAL
- en: The maximum number of partitions supported by MySQL 8 for a table is 8192\.
    This limit also considers sub-partitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fulltext index and search is not supported on partitioned tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tables that are temporary cannot be partitioned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log tables can't be partitioned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foreign keys are not supported on partitioned `InnoDB` storage engine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data type of partition keys should be an integer column or can be an expression
    to an integer. Expression or column values may be `NULL`; however, expressions
    that include `ENUM` are not supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrading partitioned tables that have been partitioned by `KEY` would have
    to be reloaded, which stands true other than the `InnoDB` storage engine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have so far discussed overview, features, benefits, and a few limitations of
    MySQL. Let us now walk through the wonderful use cases of MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases of MySQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL has many advantages because it has its foot in many industries and various
    use cases across the globe. The importance of MySQL doesn't depend only on how
    much data you have, it's rather what you are going to do with the data. Data can
    be sourced and analyzed from unpredictable sources and can be used to address
    many things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at use cases with real-life importance made on renowned scenarios
    with the help of MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66efe8d9-16a4-4651-9cee-d785fc5530da.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding figure helps us understand where MySQL is serving various industries.
    Though it's not an extensive list of industries where MySQL has been playing a
    prominent role in business decisions, let's now discuss a few of the industries.
  prefs: []
  type: TYPE_NORMAL
- en: Social media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Social media content is information, and so are engagements such as views, likes,
    demographics, shares, follows, unique visitors, comments, and downloads. At the
    end of the day, what matters is how your social media-related efforts contribute
    to the business.
  prefs: []
  type: TYPE_NORMAL
- en: One notable example is Facebook, where MySQL had been used extensively. On top
    of MySQL where petabytes of data was used to serve likes, shares, and comments.
    Facebook has developed the `RocksDB` storage engine on top of the MySQL `InnoDB`
    storage engine, which leverages many advantages of InnoDB storage engine as Facebook
    wanted to primarily focus on storage optimization. Though currently MySQL is still
    used largely for other common applications.
  prefs: []
  type: TYPE_NORMAL
- en: Government
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The era of MySQL has been playing a significant role in government too; government
    bodies have been using MySQL extensively because of splendid return on investments
    and promoting open source. In fact, the government sector is carrying out a huge
    number of implementations of MySQL worldwide.
  prefs: []
  type: TYPE_NORMAL
- en: This may come as a surprise to you; US Navy uses MySQL for its critical flight
    planning activities. There are various activities such as weather conditions,
    flight plans, fuel efficiency, maintenance of flights, and many more that are
    being tracked with the help of MySQL as the database. It's a no-brainer that it
    needs to run 24x7 with full redundancy; MySQL was able to achieve this serving
    US Navy aircraft across the globe.
  prefs: []
  type: TYPE_NORMAL
- en: Media and entertainment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: YouTube is also one of the prominent users of MySQL. Anytime you watch a video
    on YouTube it gets data from a relational database or a blob store using MySQL.
    YouTube also uses Vitess; a project that was released by YouTube to frontend MySQL.
    Vitess helps to do lots of optimization and acts as a proxy to serve each database
    request using MySQL. MySQL replicas are heavily used in YouTube's implementation;
    leveraging MySQL caching was one of the other prominent factors for YouTube.
  prefs: []
  type: TYPE_NORMAL
- en: Fraud detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to security, fraud detection, or compliance, and precisely if
    your solution helps you in identifying and preventing issues before they strike,
    then it becomes a sweet spot for business. Most of the time, fraud detection takes
    place a long time after the fraud has occurred, when you might have already suffered
    loss. The next steps would be obviously to minimize the impact of fraud and improve
    areas that could help you prevent this from being repeated.
  prefs: []
  type: TYPE_NORMAL
- en: Many companies who are into any type of transaction processing or claims use
    fraud detection techniques extensively. MySQL helps to analyze transactions, claims,
    and so on in real time, along with trends or anomalous behavior to prevent fraudulent
    activities.
  prefs: []
  type: TYPE_NORMAL
- en: PayPal is one of such use cases that has built fraud detection system using
    MySQL. PayPal has more than 100 million active users, which is distributed to
    US, Japanese, and European data centers. High-availability for such use cases
    is a key criteria along with performance, which MySQL has been able to deliver
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Business mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Netflix has millions of subscribers; it uses MySQL for running its billing systems.
    The core billing system of Netflix on MySQL is a prominent backbone for any business.
    Netflix has billions of rows of data concurrently updated and of consisting data
    since its inception two decades ago. Compliance was one of the key factors along
    with migration from Oracle with minimal downtime; both of these were achieved
    with MySQL and has been expanding tremendously every other day.
  prefs: []
  type: TYPE_NORMAL
- en: E-commerce
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Uber is one of the other well-known customers of MySQL. Uber had been growing
    enormously worldwide, and scalability, high-availability, and return on investments
    were a few of the important criteria to be worked upon. Uber uses MySQL as its
    primary database for its known private car transportation service. Uber heavily
    uses schema less database architecture as its backend as a layer on MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: There are many real-world MySQL use cases that have changed humanity, technology,
    predictions, health, science and research, law and order, sports, e-commerce,
    power and energy, financial trading, robotics, and many more. MySQL is an integral
    part of our daily routine, which is not evident all the time, but yes, it plays
    a significant role in what we do in many ways.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started with an overview of MySQL along with major features
    of the MySQL database and explored the newly added features in MySQL 8\. After
    this, we took a deep dive into exciting new features of MySQL 8 along with benefits
    of using MySQL for your business applications. We understood MySQL 8's current
    limitations and restrictions, which is important for us when performing the implementations.
    Finally, we glanced through a few impressive use cases from the real world that
    play prominent roles in our daily routine, and they all use MySQL as their database.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn detailed steps for installing MySQL 8 on
    different platforms. The chapter also covers methods to upgrade or downgrade from
    MySQL 8, and they will all be discussed in detail.
  prefs: []
  type: TYPE_NORMAL
