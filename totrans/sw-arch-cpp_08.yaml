- en: Design Patterns and C++
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式和C++
- en: C++ is not just an object-oriented language, and it doesn't just offer dynamic
    polymorphism, so design in C++ is not just about the Gang of Four patterns. In
    this chapter, you will learn about the commonly used C++ idioms and design patterns
    and where to use them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C++不仅仅是一种面向对象的语言，它不仅仅提供动态多态性，因此在C++中设计不仅仅是关于四人帮的模式。在本章中，你将学习关于常用的C++习语和设计模式以及它们的使用场景。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Writing idiomatic C++
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写习惯用法的C++
- en: Curiously recurring template pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奇异递归模板模式
- en: Creating objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建对象
- en: Tracking state and visiting objects in C++
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪状态和访问对象在C++中
- en: Dealing with memory efficiently
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效处理内存
- en: That's quite a list! Let's not waste time and jump right in.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当长的列表！让我们不浪费时间，直接开始吧。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code from this chapter requires the following tools to build and run:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码需要以下工具来构建和运行：
- en: A compiler supporting C++20
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持C++20的编译器
- en: CMake 3.15+
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 3.15+
- en: The source code snippets from the chapter can be found at [https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter06](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter06).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码片段可以在[https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter06](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter06)找到。
- en: Writing idiomatic C++
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写习惯用法的C++
- en: If you're familiar with object-oriented programming languages, you must have
    heard of the Gang of Four's design patterns. While they can be implemented in
    C++ (and often are), this multi-paradigm language often takes a different approach
    for achieving the same goals. If you want to beat the performance of the so-called
    coffee-based languages such as Java or C#, sometimes paying the cost of virtual
    dispatch is too much. In many cases, you'll know upfront what types you'll deal
    with. If that happens, you can often write more performant code using the tools
    available both in the language and in the standard library. Out of many, there's
    a group that we will start this chapter with – the language idioms. Let's start
    our journey by looking at a few of them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉面向对象的编程语言，你一定听说过四人帮的设计模式。虽然它们可以在C++中实现（而且经常被实现），但这种多范式语言通常采用不同的方法来实现相同的目标。如果你想要超越Java或C#等所谓的基于咖啡的语言的性能，有时付出虚拟调度的代价太大了。在许多情况下，你会提前知道你将处理的类型。如果发生这种情况，你通常可以使用语言和标准库中提供的工具编写更高性能的代码。其中有一个我们将从本章开始的一组
    - 语言习语。让我们通过查看其中一些来开始我们的旅程。
- en: By definition, an idiom is a construct that recurs in a given language, an expression
    that's specific to the language. "Native speakers" of C++ should know its idioms
    by intuition. We already mentioned smart pointers, which are one of the most common
    ones. Let's now discuss a similar one.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，习语是在特定语言中反复出现的构造，是特定于该语言的表达。C++的“母语者”应该凭直觉知道它的习语。我们已经提到智能指针，这是最常见的之一。现在让我们讨论一个类似的。
- en: Automating scope exit actions using RAII guards
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用RAII保护自动化作用域退出操作
- en: One of the most powerful expressions in C++ is the brace closing a scope. This
    is the place where destructors get called and the RAII magic happens. To tame
    this spell, you don't need to use smart pointers. All you need is an RAII guard
    – an object that, when constructed, will remember what it needs to do when destroyed.
    This way, regardless of whether the scope exits normally or by an exception, the
    work will happen automatically.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: C++中最强大的表达之一是用于关闭作用域的大括号。这是析构函数被调用和RAII魔术发生的地方。为了驯服这个咒语，你不需要使用智能指针。你只需要一个RAII保护
    - 一个对象，当构造时，将记住它在销毁时需要做什么。这样，无论作用域是正常退出还是由异常退出，工作都会自动发生。
- en: 'The best part – you don''t even need to write an RAII guard from scratch. Well-tested
    implementation already exists in various libraries. If you''re using GSL, which
    we mentioned in the previous chapter, you can use `gsl::finally()`. Consider the
    following example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的部分 - 你甚至不需要从头开始编写一个RAII保护。经过充分测试的实现已经存在于各种库中。如果你使用我们在上一章中提到的GSL，你可以使用`gsl::finally()`。考虑以下例子：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we take a timestamp at the start of the function and another one at the
    end. Try running this example and see how uncommenting the `throw` statement affects
    the execution. In both cases, our RAII guard will properly print the execution
    time (assuming the exception is caught somewhere).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在函数开始时取一个时间戳，然后在结束时再取一个。尝试运行这个例子，看看取消注释`throw`语句如何影响执行。在这两种情况下，我们的RAII保护将正确打印执行时间（假设异常在某处被捕获）。
- en: Let's now discuss a few more popular C++ idioms.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论一些更流行的C++习语。
- en: Managing copyability and movability
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理可复制性和可移动性
- en: When designing a new type in C++, it's important to decide whether it should
    be copyable and movable. Even more important is implementing those semantics for
    a class correctly. Let's discuss those issues now.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中设计新类型时，重要的是决定它是否可以复制和移动。更重要的是正确实现类的语义。现在让我们讨论这些问题。
- en: Implementing non-copyable types
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现不可复制类型
- en: 'There are cases when you don''t want your class to be copied. Classes that
    are very expensive to copy are one example. Another would be those subject to
    error due to slicing. In the past, a common way to prevent such objects from copying
    was by using the non-copyable idiom:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，你不希望你的类被复制。非常昂贵的复制类是一个例子。另一个例子是由于切片而导致错误的类。过去，防止这些对象复制的常见方法是使用不可复制的习语：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note, however, that such a class is also not movable, although it''s easy to
    not notice it when reading the class definition. A better approach would be to
    just add the two missing members (the move constructor and move assignment operator)
    explicitly. As a rule of thumb, when declaring such special member functions,
    always declare all of them. This means that from C++11 onward, the preferred way
    would be to write the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，这样的类也是不可移动的，尽管在阅读类定义时很容易忽略这一点。更好的方法是明确地添加两个缺失的成员（移动构造函数和移动赋值运算符）。作为一个经验法则，当声明这样的特殊成员函数时，总是声明所有这些函数。这意味着从C++11开始，首选的方法是编写以下内容：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This time, the members were defined directly in the target type without the
    helper `NonCopyable` type.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，成员是直接在目标类型中定义的，而没有辅助的`NonCopyable`类型。
- en: Adhering to the rules of three and five
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遵循三和五法则
- en: 'There''s one more thing to mention when discussing special member functions:
    if you don''t delete them and are providing your own implementations, most probably
    you need to define all of them, including the destructor, too. This was called
    the rule of three in C++98 (due to the need to define three functions: the copy
    constructor, the copy assignment operator, and the destructor) and since C++11''s
    move operations, it is now replaced by the rule of five (the two additional ones
    being the move constructor and the move assignment operator). Applying these rules
    can help you avoid resource management issues.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论特殊成员函数时，还有一件事需要提到：如果您不删除它们并提供自己的实现，很可能需要定义所有这些函数，包括析构函数。在C++98中，这被称为三法则（由于需要定义三个函数：复制构造函数、复制赋值运算符和析构函数），自C++11的移动操作以来，它现在被五法则取代（另外两个是移动构造函数和移动赋值运算符）。应用这些规则可以帮助您避免资源管理问题。
- en: Adhering to the rule of zero
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遵循零法则
- en: 'If, on the other hand, you''re good to go with just the default implementations
    of all special member functions, then just don''t declare them at all. This is
    a clear sign that you want the default behavior. It''s also the least confusing.
    Consider the following type:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您只使用所有特殊成员函数的默认实现，那么根本不要声明它们。这清楚地表明您想要默认行为。这也是最不令人困惑的。考虑以下类型：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Even though we defaulted all the members, the class is still non-copyable.
    That''s because it has a `unique_ptr` member that is non-copyable itself. Fortunately,
    Clang will warn you about this, but GCC does not by default. A better approach
    would be to apply the rule of zero and instead write the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们默认了所有成员，但这个类仍然是不可复制的。这是因为它有一个`unique_ptr`成员，它本身是不可复制的。幸运的是，Clang会警告您，但GCC默认情况下不会。更好的方法是应用零规则，而不是写以下内容：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now we have less boilerplate code and by looking at the members, it's easier
    to notice that it does not support copying.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了更少的样板代码，并且通过查看成员，更容易注意到它不支持复制。
- en: There's one more important idiom to know about when it comes to copying that
    you'll get to know in a minute. Before that happens, we shall touch on yet another
    idiom, which can (and should) be used to implement the first one.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论复制时，还有一个重要的习惯用法需要了解，您将在一分钟内了解到。在此之前，我们将涉及另一个习惯用法，可以（并且应该）用于实现第一个习惯用法。
- en: Using hidden friends
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用隐藏友元
- en: In essence, hidden friends are non-member functions defined in the body of the
    type that declares them as a friend. This makes such functions impossible to call
    in ways other than by using **Argument-Dependent Lookup** (**ADL**), effectively
    making them hidden. Because they reduce the number of overloads a compiler considers,
    they also speed up compilation. A bonus of this is that they provide shorter error
    messages than their alternatives. Their last interesting property is that they
    cannot be called if an implicit conversion should happen first. This can help
    you avoid such accidental conversions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，隐藏的友元是在声明它们为友元的类型的主体中定义的非成员函数。这使得这样的函数无法通过其他方式调用，而只能通过**参数相关查找**（**ADL**）来调用，有效地使它们隐藏起来。因为它们减少了编译器考虑的重载数量，它们也加快了编译速度。这样做的额外好处是，它们提供比其替代品更短的错误消息。它们的最后一个有趣的特性是，如果应该首先发生隐式转换，它们就不能被调用。这可以帮助您避免这种意外转换。
- en: Although friends in C++ are generally not recommended, things look differently
    for hidden friends; if the advantages from the previous paragraph don't convince
    you, you should also know that they should be the preferred way of implementing
    customization points. Now, you're probably wondering what those customization
    points are. Briefly speaking, they are callables used by the library code that
    the user can specialize in for their types. The standard library reserves quite
    a lot of names for those, such as `begin`, `end`, and their reverse and `const`
    variations, `swap`, `(s)size`, `(c)data`, and many operators, among others. If
    you decide to provide your own implementation for any of those customization points,
    it had better behave as the standard library expects.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在C++中通常不建议使用友元，但对于隐藏的友元，情况看起来不同；如果前面段落中的优势不能说服您，您还应该知道，它们应该是实现定制点的首选方式。现在，您可能想知道这些定制点是什么。简而言之，它们是库代码使用的可调用对象，用户可以为其类型进行专门化。标准库为这些保留了相当多的名称，例如`begin`、`end`及其反向和`const`变体，`swap`、`(s)size`、`(c)data`和许多运算符，等等。如果您决定为任何这些定制点提供自己的实现，最好是符合标准库的期望。
- en: 'Okay, enough theory for now. Let''s see how to provide a customization point
    specialization using a hidden friend in practice. For example, let''s create an
    oversimplified class to manage arrays of types:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在理论够了。让我们看看如何在实践中使用隐藏的友元来提供定制点专门化。例如，让我们创建一个过于简化的类来管理类型的数组：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we defined a destructor, which means we should provide other
    special member functions too. We implement them in the next section, using our
    hidden friend `swap`. Note that despite being declared in the body of our `Array`
    class, this `swap` function is still a non-member function. It accepts two `Array`
    instances and doesn't have access to this.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们定义了一个析构函数，这意味着我们还应该提供其他特殊成员函数。我们将在下一节中使用我们隐藏的友元“swap”来实现它们。请注意，尽管在我们的“Array”类的主体中声明，但这个“swap”函数仍然是一个非成员函数。它接受两个“Array”实例，并且没有访问权限。
- en: Using the `std::swap` line makes the compiler first look for `swap` functions
    in the namespaces of the swapped members. If not found, it will fall back to `std::swap`.
    This is called the *two-step ADL and fallback idiom*, or *two-step* for short,
    because we first make `std::swap` visible, and then call `swap`. The `noexcept`
    keyword tells the compiler that our `swap` function does not throw, which allows
    it to generate faster code in certain situations. Aside from `swap`, always mark
    your default and move constructors with this keyword too for the same reason.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“std::swap”行使编译器首先在交换成员的命名空间中查找“swap”函数。如果找不到，它将退回到“std::swap”。这被称为“两步ADL和回退惯用语”，或简称为“两步”，因为我们首先使“std::swap”可见，然后调用“swap”。“noexcept”关键字告诉编译器我们的“swap”函数不会抛出异常，这允许它在某些情况下生成更快的代码。除了“swap”，出于同样的原因，始终使用这个关键字标记默认和移动构造函数。
- en: Now that we have a `swap` function, let's use it to apply another idiom to our
    `Array` class.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们有一个“swap”函数，让我们使用它来应用另一个惯用语到我们的“Array”类。
- en: Providing exception safety using the copy-and-swap idiom
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用复制和交换惯用语提供异常安全性
- en: As we mentioned in the previous section, because our `Array` class defines a
    destructor, according to the rule of five, it should also define other special
    member functions. In this section, you'll learn about an idiom that lets us do
    this without boilerplate, while also adding strong exception safety as a bonus.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中提到的，因为我们的“Array”类定义了一个析构函数，根据五法则，它还应该定义其他特殊成员函数。在本节中，您将了解一种惯用语，让我们可以在没有样板文件的情况下做到这一点，同时还额外提供强异常安全性。
- en: 'If you''re not familiar with the exception safety levels, here''s a quick recap
    of the levels your functions and types can offer:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉异常安全级别，这里是您的函数和类型可以提供的级别的快速回顾：
- en: '**No guarantee**: This is the most basic level. No guarantees are made about
    the state of your object after an exception is thrown while it''s being used.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无保证**：这是最基本的级别。在对象在使用时抛出异常后，不对其状态做任何保证。'
- en: '**Basic exception safety**: Side effects are possible, but your object won''t
    leak any resources, will be in a valid state, and will contain valid data (not
    necessarily the same as before the operation). Your types should always offer
    at least this level.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本异常安全性**：可能会有副作用，但您的对象不会泄漏任何资源，将处于有效状态，并且将包含有效数据（不一定与操作之前相同）。您的类型应该至少提供这个级别。'
- en: '**Strong exception safety**: No side effects will happen. The object''s state
    will be the same as before the operation.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强异常安全性**：不会发生任何副作用。对象的状态将与操作之前相同。'
- en: '**No-throw guarantee**: Operations will always succeed. If an exception is
    thrown during the operation, it will be caught and handled internally so the operation
    does not throw exceptions outside. Such operations can be marked as `noexcept`.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无抛出保证**：操作将始终成功。如果在操作期间抛出异常，它将被内部捕获和处理，因此操作不会在外部抛出异常。此类操作可以标记为“noexcept”。'
- en: 'So, how can we kill these two birds with one stone and write no-boilerplate
    special members while also providing strong exception safety? It''s pretty easy,
    actually. As we have our `swap` function, let''s use it to implement the assignment
    operators:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何一举两得地写出无样板文件的特殊成员，并提供强异常安全性呢？实际上很容易。由于我们有我们的“swap”函数，让我们使用它来实现赋值运算符：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In our case, a single operator suffices for both the copy and move assignments.
    In the copy case, we take the parameter by value, so this is where a temporary
    copy is being made. Then, all we need to do is swap the members. We have not only
    achieved strong exception safety but were also able to not throw from the assignment
    operator's body. However, an exception can still be thrown right before the function
    gets called, when the copy happens. In the case of the move assignment, no copy
    is made as taking by value will just take the moved object.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，一个运算符就足够了，既适用于复制赋值，也适用于移动赋值。在复制的情况下，我们通过值来获取参数，因此这是临时复制正在进行的地方。然后，我们所需要做的就是交换成员。我们不仅实现了强异常安全性，而且还能够在赋值运算符的主体中不抛出异常。然而，在函数被调用之前，当复制发生时，仍然可能抛出异常。在移动赋值的情况下，不会进行复制，因为通过值获取将只获取移动的对象。
- en: 'Now, let''s define the copy constructor:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义复制构造函数：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This guy can throw depending on `T` and because it allocates memory. Now, let''s
    define the move constructor too:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以根据“T”和分配内存而抛出异常。现在，让我们也定义移动构造函数：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we use `std::exchange` so that our members get initialized and `other`'s
    members get cleaned up, all on the initialization list. The constructor is declared
    `noexcept` for performance reasons. For instance, `std::vector` can move their
    elements when they grow only if they're `noexcept` move-constructible, and will
    copy otherwise.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用“std::exchange”来初始化我们的成员，并在初始化列表上清理“other”的成员。构造函数声明为“noexcept”是出于性能原因。例如，如果“std::vector”只在移动构造时是“noexcept”可移动的，否则将进行复制。
- en: That's it. We've created an `array` class providing strong exception safety
    with little effort and no code duplication.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们创建了一个提供强异常安全性的“array”类，而且几乎没有代码重复。
- en: Let's now tackle yet another C++ idiom, which can be spotted in a few places
    in the standard library.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来解决另一个C++惯用语，它可以在标准库的几个地方找到。
- en: Writing niebloids
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写niebloids
- en: Niebloids, named after Eric Niebler, are a type of function object that the
    standard uses for customization points from C++17 onward. With the introduction
    of standard ranges described in [Chapter 5](315eea2a-c029-4bc3-a159-4f897d393639.xhtml)*,
    Leveraging C++ Language Features*, their popularity started to grow, but they
    were first proposed by Niebler back in 2014\. **Their purpose is to disable ADL
    where it's not wanted so overloads from other namespaces are not considered by
    the compiler**. Remember the *two-step idiom* from the previous sections? Because
    it's inconvenient and easy to forget, the notion of *customization point objects*
    was introduced. In essence, these are function objects performing the *two-step*
    for you.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Niebloids，以Eric Niebler的名字命名，是C++17及以后标准使用的一种函数对象类型，用于定制点。随着标准范围的引入，它们的流行度开始增长，但它们最早是在2014年由Niebler提出的。它们的目的是在不需要时禁用ADL，因此编译器不会考虑来自其他命名空间的重载。还记得前面章节中的*两步法*吗？由于它不方便且容易忘记，所以引入了*定制点对象*的概念。本质上，这些是为您执行*两步法*的函数对象。
- en: If your libraries should provide customization points, it's probably a good
    idea to implement them using niebloids. All the customization points in the standard
    library introduced in C++17 and later are implemented this way for a reason. Even
    if you just need to create a function object, still consider using niebloids.
    They offer all the good parts of ADL while reducing the drawbacks. They allow
    specialization and together with concepts they give you a way to customize the
    overload set of your callables. They also allow better customization of algorithms,
    all at the slight cost of writing a bit more verbose code than usual.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的库应该提供定制点，最好使用niebloids来实现它们。C++17及以后引入的标准库中的所有定制点都是出于某种原因以这种方式实现的。即使您只需要创建一个函数对象，仍然要考虑使用niebloids。它们提供了ADL的所有优点，同时减少了缺点。它们允许特化，并且与概念一起，它们为您提供了一种定制可调用函数重载集合的方法。它们还允许更好地定制算法，只是写的代码比通常多一点。
- en: 'In this section, we''ll create a simple range algorithm that we''ll implement
    as a niebloid. Let''s call it `contains` as it will simply return a Boolean value
    denoting whether a given element is found in the range or not. First, let''s create
    the function object itself, starting with the declaration of its iterator-based
    call operator:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将创建一个简单的范围算法，我们将其实现为niebloid。让我们称之为`contains`，因为它将简单地返回一个布尔值，表示范围中是否找到了给定的元素。首先，让我们创建函数对象本身，从其基于迭代器的调用操作符的声明开始：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It looks verbose, but all this code has a purpose. We make our struct `final`
    to aid the compiler in generating more efficient code. If you look at the template
    parameters, you'll see an iterator and a sentinel – the basic building blocks
    of each standard range. The sentinel is often an iterator, but it can be any semiregular
    type that can be compared with the iterator (a semiregular type is copyable and
    default-initializable). Next, `T` is the type of element to search for, while
    `Proj` denotes a projection – an operation to apply to each range element before
    comparison (the default of `std::identity` simply passes its input as output).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '看起来冗长，但所有这些代码都有其目的。我们使我们的结构`final`以帮助编译器生成更高效的代码。如果您查看模板参数，您会看到迭代器和哨兵 - 每个标准范围的基本构建块。哨兵通常是一个迭代器，但它可以是任何可以与迭代器比较的半正则类型（半正则类型是可复制和默认可初始化的）。接下来，`T`是要搜索的元素类型，而`Proj`表示投影
    - 在比较之前对每个范围元素应用的操作（`std::identity`的默认值只是将其输入作为输出传递）。 '
- en: After the template parameters, there come the requirements for them; the operator
    requires that we can compare the projected value and the searched-for value for
    equality. After those constraints, we simply specify the function parameters.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板参数之后，有它们的要求；操作符要求我们可以比较投影值和搜索值是否相等。在这些约束之后，我们只需指定函数参数。
- en: 'Let''s now see how it''s implemented:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看它是如何实现的：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we simply iterate over the elements, invoking the projection on each element
    and comparing it with the searched-for value. We return `true` if found and `false`
    otherwise (when `first == last`).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是遍历元素，对每个元素调用投影并将其与搜索值进行比较。如果找到则返回`true`，否则返回`false`（当`first == last`时）。
- en: 'The preceding function would work even if we didn''t use standard ranges; we
    also need an overload for ranges. Its declaration can be as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们没有使用标准范围，前面的函数也可以工作；我们还需要为范围重载。它的声明可以如下所示：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This time, we take a type satisfying the `input_range` concept, the element
    value, and the type of projection as template parameters. We require that the
    range's iterator after calling the projection can be compared for equality with
    objects of type `T`, similarly as before. Finally, we use the range, the value,
    and the projection as our overload's parameters.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们使用满足`input_range`概念的类型，元素值和投影类型作为模板参数。我们要求在调用投影后，范围的迭代器可以与类型为`T`的对象进行比较，与之前类似。最后，我们使用范围、值和投影作为我们重载的参数。
- en: 'The body of this operator will be pretty straightforward, too:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作符的主体也会非常简单：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We simply call the previous overload using an iterator and sentinel from the
    given range, while passing the value and our projection unchanged. Now, for the
    last part, we need to provide a `contains` niebloid instead of just the `contains_fn`
    callable:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需使用给定范围的迭代器和哨兵调用先前的重载，同时传递值和我们的投影不变。现在，对于最后一部分，我们需要提供一个`contains` niebloid，而不仅仅是`contains_fn`可调用：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'By declaring an inline variable named `contains` of type `contains_fn`, we
    allow anyone to call our niebloid using the variable name. Now, let''s call it
    ourselves to see whether it works:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过声明一个名为`contains`的内联变量，类型为`contains_fn`，我们允许任何人使用变量名调用我们的niebloid。现在，让我们自己调用它看看它是否有效：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And that's it. Our ADL-inhibiting functor works as intended.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们的抑制ADL的函数符合预期工作。
- en: If you think all of this is a tad too verbose, then you might be interested
    in `tag_invoke`, which might become part of the standard at some point in the
    future. Refer to the *Further reading* section for a paper on this topic and a
    YouTube video that explains ADL, niebloids, hidden friends, and `tag_invoke` nicely.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为所有这些都有点啰嗦，那么你可能会对`tag_invoke`感兴趣，它可能会在将来的某个时候成为标准的一部分。请参考*进一步阅读*部分，了解有关这个主题的论文和YouTube视频，其中详细解释了ADL、niebloids、隐藏的友元和`tag_invoke`。
- en: Let's now move on to yet another useful C++ idiom.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向另一个有用的C++习惯用法。
- en: Policy-based design idiom
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于策略的设计模式
- en: Policy-based design was first introduced by Andrei Alexandrescu in his excellent
    *Modern C++ Design* book. Although published in 2001, many ideas showed in it
    are still used today. We recommend reading it; you can find it linked in the *Further
    reading* section at the end of this chapter. The policy idiom is basically a compile-time
    equivalent of the Gang of Four's Strategy pattern. If you need to write a class
    with customizable behavior, you can make it a template with the appropriate policies
    as template parameters. A real-world example of this could be standard allocators,
    passed as a policy to many C++ containers as the last template parameter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 基于策略的设计最初是由Andrei Alexandrescu在他出色的*现代C++设计*书中引入的。尽管该书于2001年出版，但其中许多想法今天仍在使用。我们建议阅读它；你可以在本章末尾的*进一步阅读*部分找到它的链接。策略习惯用法基本上是Gang
    of Four的策略模式的编译时等价物。如果您需要编写一个具有可定制行为的类，您可以将其作为模板与适当的策略作为模板参数。这在实际中的一个例子可能是标准分配器，作为最后一个模板参数传递给许多C++容器作为策略。
- en: 'Let''s return to our `Array` class and add a policy for debug printing:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`Array`类，并为调试打印添加一个策略：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see, we can use a default policy that won''t print anything. `NullPrintingPolicy`
    can be implemented as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们可以使用一个不会打印任何东西的默认策略。`NullPrintingPolicy`可以实现如下：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, regardless of the arguments given, it won't do anything. The
    compiler will completely optimize it out, so no overhead will be paid when the
    debug printing feature is not used.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，无论给定什么参数，它都不会做任何事情。编译器会完全优化它，因此在不使用调试打印功能时不会产生任何开销。
- en: 'If we want our class to be a bit more verbose, we can use a different policy:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望我们的类更加冗长，我们可以使用不同的策略：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This time, we''ll simply print the text passed to the policy to `cout`. We
    also need to modify our class to actually use our policy:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们只需将传递给策略的文本打印到`cout`。我们还需要修改我们的类来实际使用我们的策略：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We simply call the policy's `operator()`, passing the text to be printed. Since
    our policies are stateless, we can instantiate it each time we need to use it
    without extra cost. An alternative could also be to just call a static function
    from it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需调用策略的`operator()`，将要打印的文本传递进去。由于我们的策略是无状态的，我们可以在需要使用它时每次实例化它，而不会产生额外的成本。另一种选择也可以是直接从中调用静态函数。
- en: 'Now, all we need to do is to instantiate our `Array` class with the desired
    policy and use it:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要用所需的策略实例化我们的`Array`类并使用它：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: One drawback of using compile-timed policies is that the template instantiations
    using different policies are of different types. This means more work is required
    to, for instance, assign from a regular `Array` class to one with `CoutPrintingPolicy`.
    To do so, you would need to implement assignment operators as template functions
    with the policy as the template parameter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用编译时策略的一个缺点是使用不同策略的模板实例化是不同类型的。这意味着需要更多的工作，例如从常规的`Array`类分配到具有`CoutPrintingPolicy`的类。为此，您需要将策略作为模板参数实现赋值运算符作为模板函数。
- en: Sometimes an alternative to using policies is to use traits. As an example,
    take `std::iterator_traits`, which can be used to use various information about
    iterators when writing algorithms that use them. An example could be `std::iterator_traits<T>::value_type`,
    which can work for both custom iterators defining a `value_type` member, and simple
    ones such as pointers (in which case `value_type` would refer to the pointed-to
    type).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，使用特征作为使用策略的替代方案。例如，`std::iterator_traits`可以用于在编写使用迭代器的算法时使用有关迭代器的各种信息。例如，`std::iterator_traits<T>::value_type`可以适用于定义了`value_type`成员的自定义迭代器，以及简单的迭代器，比如指针（在这种情况下，`value_type`将指向被指向的类型）。
- en: Enough about policy-based design. Next on our list is a powerful idiom that
    can be applied in multiple scenarios.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 关于基于策略的设计就说这么多。接下来我们要讨论的是一个可以应用于多种情景的强大习惯用法。
- en: Curiously recurring template pattern
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奇异递归模板模式
- en: Despite having *pattern* in its name, the **Curiously Recurring Template Pattern**
    (**CRTP**) is an idiom in C++. It can be used to implement other idioms and design
    patterns and to apply static polymorphism, to name a few areas. Let's start with
    this last one as we'll cover the others later on.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它的名字中有*模式*一词，**奇异递归模板模式**（**CRTP**）是C++中的一种习惯用法。它可以用于实现其他习惯用法和设计模式，并应用静态多态性，等等。让我们从最后一个开始，因为我们稍后会涵盖其他内容。
- en: Knowing when to use dynamic versus static polymorphism
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解何时使用动态多态性与静态多态性
- en: When mentioning polymorphism, many programmers will think of dynamic polymorphism,
    where the information needed to perform a function call is gathered at runtime.
    In contrast to this, static polymorphism is about determining the calls at compile
    time. An advantage of the former is that you can modify the list of types at runtime,
    allowing extending your class hierarchies through plugins and libraries. The big
    advantage of the second is that it can get better performance if you know the
    types upfront. Sure, in the first case you can sometimes expect your compiler
    to devirtualize your calls, but you cannot always count on it doing so. However,
    in the second case, you can get longer compilation times.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在提到多态性时，许多程序员会想到动态多态性，其中执行函数调用所需的信息在运行时收集。与此相反，静态多态性是关于在编译时确定调用的。前者的优势在于你可以在运行时修改类型列表，允许通过插件和库扩展你的类层次结构。后者的优势在于，如果你提前知道类型，它可以获得更好的性能。当然，在第一种情况下，你有时可以期望编译器去虚拟化你的调用，但你不能总是指望它这样做。然而，在第二种情况下，你可以获得更长的编译时间。
- en: Looks like you cannot win in all cases. Still, choosing the right type of polymorphism
    for your types can go a long way. If performance is at stake, we strongly suggest
    you consider static polymorphism. CRTP is an idiom that can be used to apply it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来你不能在所有情况下都赢。不过，为你的类型选择正确的多态类型可以走很远。如果性能受到影响，我们强烈建议你考虑静态多态性。CRTP是一种可以用来应用它的习惯用法。
- en: Many design patterns can be implemented in one way or another. As the cost of
    dynamic polymorphism is not always worth it, the Gang of Four design patterns
    are often not the best solution in C++. If your type hierarchy should be extended
    at runtime, or compile times are a much bigger issue than performance for you
    (and you don't plan on using modules any time soon), then the classical implementations
    of the Gang of Four patterns may be a good fit. Otherwise, you can try to implement
    them using static polymorphism or by applying simpler C++-focused solutions, some
    of which we describe in this chapter. It's all about choosing the best tool for
    the job.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 许多设计模式可以以一种或另一种方式实现。由于动态多态性的成本并不总是值得的，四人帮设计模式在C++中通常不是最好的解决方案。如果你的类型层次结构应该在运行时扩展，或者编译时间对你来说比性能更重要（而且你不打算很快使用模块），那么四人帮模式的经典实现可能是一个很好的选择。否则，你可以尝试使用静态多态性来实现它们，或者通过应用更简单的面向C++的解决方案，其中我们在本章中描述了一些。关键是选择最适合工作的工具。
- en: Implementing static polymorphism
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现静态多态性
- en: 'Let''s now implement our statically polymorphic class hierarchy. We''ll need
    a base template class:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现我们的静态多态类层次结构。我们需要一个基本模板类：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The template parameter for the base class is the derived class. This may seem
    odd at first, but it allows us to `static_cast` to the correct type in our interface
    function, in this case, named `appear_in_full_glory`. We then call the implementation
    of this function in a derived class. Derived classes could be implemented like
    so:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 基类的模板参数是派生类。这一开始可能看起来很奇怪，但它允许我们在我们的接口函数中`static_cast`到正确的类型，这种情况下，命名为`appear_in_full_glory`。然后我们在派生类中调用这个函数的实现。派生类可以这样实现：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Each of these classes derives from our `GlamorousItem` base class using itself
    as the template argument. Each also implements the required function.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类中的每一个都使用自身作为模板参数从我们的`GlamorousItem`基类派生。每个也实现了所需的函数。
- en: 'Note that, as opposed to dynamic polymorphism, the base class in CRTP is a
    template, so you''ll get a different base type for each of your derived classes.
    This means you can''t easily create a container of your `GlamorousItem` base class.
    What you can do, however, is several things:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与动态多态性相反，CRTP中的基类是一个模板，因此你将为你的派生类得到不同的基本类型。这意味着你不能轻松地创建一个`GlamorousItem`基类的容器。然而，你可以做一些事情：
- en: Store them in a tuple.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将它们存储在一个元组中。
- en: Create a `std::variant` of your derived classes.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的派生类的`std::variant`。
- en: Add one common class to wrap all instantiations of `Base`. You can use a variant
    for this one as well.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个通用类来包装所有`Base`的实例化。你也可以为这个使用一个变体。
- en: 'In the first case, we could use the class as follows. First, create the tuple
    of instances of `base`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们可以按照以下方式使用该类。首先，创建`base`实例的元组：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Our type-aliased tuple will be able to store any glamorous items. Now, all
    we need to do is to call the interesting function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类型别名元组将能够存储任何迷人的物品。现在，我们需要做的就是调用有趣的函数：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Because we're trying to iterate a tuple, the easiest way to do so is to call
    `std::apply`, which invokes the given callable on all the elements of the given
    tuple. In our case, the callable is a lambda that accepts only `GlamorousItem`
    base class. We use fold expressions, introduced in C++17, to ensure our function
    will be called for all elements.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们试图迭代一个元组，最简单的方法是调用`std::apply`，它在给定元组的所有元素上调用给定的可调用对象。在我们的情况下，可调用对象是一个只接受`GlamorousItem`基类的lambda。我们使用C++17引入的折叠表达式来确保我们的函数将被所有元素调用。
- en: 'If we were to use a variant instead of a tuple, we''d need to use `std::visit`,
    like so:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要使用变体而不是元组，我们需要使用`std::visit`，就像这样：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `std::visit` function basically takes the variant and calls the passed lambda
    on the object stored in it. Here, we create an array of our glamorous variants,
    so we can just iterate over it like over any other container, visiting each variant
    with the appropriate lambda.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::visit`函数基本上接受变体并在其中存储的对象上调用传递的lambda。在这里，我们创建了一个我们迷人变体的数组，所以我们可以像对待任何其他容器一样迭代它，用适当的lambda访问每个变体。'
- en: 'If you find it not intuitive to write from the interface user''s perspective,
    consider this next approach, which wraps the variant into yet another class, in
    our case called `CommonGlamorousItem`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得从接口用户的角度来写不直观，考虑下一种方法，将变体包装到另一个类中，我们这里称为`CommonGlamorousItem`：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To construct our wrapper, we use a forwarding constructor (`templated T&&` being
    its parameter). We then forward instead of moving to create the `item_` wrapped
    variant, as this way we only move r-value inputs. We also constrain the template
    parameters, so on one hand, we only wrap the `GlamorousItem` base class and on
    the other, our template is not used as a move or copy constructor.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构造我们的包装器，我们使用了一个转发构造函数（`templated T&&`是它的参数）。然后我们转发而不是移动来创建`item_`包装变体，因为这样我们只移动了右值输入。我们还约束了模板参数，因此一方面，我们只包装`GlamorousItem`基类，另一方面，我们的模板不会被用作移动或复制构造函数。
- en: 'We also need to wrap our member function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要包装我们的成员函数：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This time, the `std::visit` call is an implementation detail. The user can
    use this wrapper class in the following way:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`std::visit`调用是一个实现细节。用户可以以以下方式使用这个包装器类：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This approach lets the user of the class write easy-to-understand code, but
    still keep the performance of static polymorphism.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法让类的使用者编写易于理解的代码，但仍然保持了静态多态性的性能。
- en: To offer a similar user experience, albeit with worse performance, you can also
    use a technique called type erasure, which we'll discuss next.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供类似的用户体验，尽管性能较差，您也可以使用一种称为类型擦除的技术，我们将在下面讨论。
- en: Interlude – using type erasure
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插曲-使用类型擦除
- en: Although type erasure isn't related to CRTP, it fits in nicely with our current
    example, which is why we're showing it here.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管类型擦除与CRTP无关，但它与我们当前的示例非常契合，这就是为什么我们在这里展示它的原因。
- en: The type erasure idiom is about hiding the concrete type under a polymorphic
    interface. A great example of this approach can be found in Sean Parent's talk
    *Inheritance Is The Base Class of Evil* from the *GoingNative 2013* conference.
    We highly recommend you watch it in your spare time; you can find a link to it
    in the *Further reading* section. In the standard library, you can find it in
    `std::function`, `std::shared_ptr's deleter`, or `std::any`, among others.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 类型擦除习惯是关于在多态接口下隐藏具体类型。这种方法的一个很好的例子可以在Sean Parent的演讲*Inheritance Is The Base
    Class of Evil*中找到，这是*GoingNative 2013*会议上的一个很好的例子。我们强烈建议您在空闲时间观看它；您可以在*进一步阅读*部分找到它的链接。在标准库中，您可以在`std::function`、`std::shared_ptr`的删除器或`std::any`等中找到它。
- en: The convenience of use and flexibility comes at a price – this idiom needs to
    use pointers and virtual dispatch, which makes the mentioned utilities from the
    standard library bad to use in performance-oriented use cases. Beware.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方便和灵活性是有代价的-这种习惯用法需要使用指针和虚拟分发，这使得标准库中提到的实用程序在性能导向的用例中使用起来不好。小心。
- en: 'To introduce type erasure to our example, we no longer need CRTP. This time,
    our `GlamorousItem` class will wrap dynamically polymorphic objects in a smart
    pointer:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将类型擦除引入我们的示例中，我们不再需要CRTP。这次，我们的`GlamorousItem`类将使用智能指针来包装动态多态对象。
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This time, we store a pointer to base (`TypeErasedItemBase`), which will point
    to derived wrappers for our items (`TypeErasedItem<T>s`). The base class can be
    defined as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们存储了一个指向基类（`TypeErasedItemBase`）的指针，它将指向我们项目的派生包装器（`TypeErasedItem<T>`）。基类可以定义如下：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Each derived wrapper needs to implement this interface, too:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 每个派生的包装器也需要实现这个接口：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The base class's interface is implemented by calling the function from the wrapped
    object. Note that the idiom is called "type erasure" because the `GlamorousItem`
    class doesn't know what `T` it is actually wrapping. The `information` type gets
    erased when the item gets constructed, but it all works because `T` implements
    the required methods.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用包装对象的函数来实现基类的接口。请注意，这种习惯用法被称为“类型擦除”，因为`GlamorousItem`类不知道它实际包装的是什么`T`。当项目被构造时，`information`类型被擦除了，但这一切都能正常工作，因为`T`实现了所需的方法。
- en: 'The concrete items can be implemented in a simpler manner, as shown next:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 具体的项目可以以更简单的方式实现，如下所示：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This time, they don't need to inherit from any base. All we need is duck typing
    – if it quacks like a duck, it's probably a duck. And if it can appear in full
    glory, it's probably glamorous.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，它们不需要继承任何基类。我们只需要鸭子类型-如果它像鸭子一样嘎嘎叫，那么它可能是一只鸭子。如果它可以以全荣耀出现，那么它可能是迷人的。
- en: 'Our type-erased API can be used as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类型擦除API可以如下使用：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We just create an array of our wrappers and iterate over it, all using simple,
    value-based semantics. We find it the most pleasant to use, as the polymorphism
    is hidden from the caller as an implementation detail.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需创建一个包装器数组，并对其进行迭代，所有这些都使用简单的基于值的语义。我们发现这是最愉快的使用方式，因为多态性对调用者来说是作为实现细节隐藏的。
- en: However, a big drawback of this approach is, as we mentioned before, poor performance.
    Type erasure comes at a price, so it should be used sparingly and definitely not
    in the hot path.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法的一个很大的缺点是，正如我们之前提到的，性能较差。类型擦除是有代价的，因此应该谨慎使用，绝对不要在热路径中使用。
- en: Now that we've described how to wrap and erase types, let's switch to discussing
    how to create them.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经描述了如何包装和擦除类型，让我们转而讨论如何创建它们。
- en: Creating objects
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建对象
- en: In this section, we'll discuss common solutions to problems related to object
    creation. We'll discuss various types of object factories, go through builders,
    and touch on composites and prototypes. However, we'll take a slightly different
    approach than the Gang of Four when describing their solutions. They proposed
    complex, dynamically polymorphic class hierarchies as proper implementations of
    their patterns. In the C++ world, many patterns can be applied to real-world problems
    without introducing as many classes and the overhead of dynamic dispatch. That's
    why in our case, the implementations will be different and in many cases simpler
    or more performant (although more specialized and less "generic" in the Gang of
    Four sense). Let's dive right in.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Using factories
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first type of creational patterns we'll discuss here are factories. They're
    useful when the object construction can be done in a single step (a pattern useful
    if it cannot be covered right after factories), but when the constructor just
    isn't good enough on its own. There are three types of factories – factory methods,
    factory functions, and factory classes. Let's introduce them one by one.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Using factory methods
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Factory methods, also called the *named constructor idiom*, are basically member
    functions that call a private constructor for you. When do we use them? Here are
    a few scenarios:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '**When there are many different ways to construct an object, which would make
    errors likely**. For example, imagine constructing a class for storing different
    color channels for a given pixel; each channel is represented by a one-byte value.
    Using just a constructor would make it too easy to pass the wrong order of channels,
    or values meant for a different color palette entirely. Also, switching the pixel''s
    internal representation of colors would get tricky pretty fast. You could argue
    that we should have different types representing colors in those different formats,
    but often, using a factory method is a valid approach as well.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When you want to force the object to be created on the heap or in another
    specific memory area**. If your object takes up loads of space on the stack and
    you''re afraid you''ll run out of stack memory, using a factory method is a solution.
    The same if you require all instances to be created in some area of memory on
    a device, for instance.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When constructing your object can fail, but you cannot throw exceptions**.
    You should use exceptions instead of other methods of error handling. When used
    properly, they can yield cleaner and better-performing code. However, some projects
    or environments require that exceptions are disabled. In such cases, using a factory
    method will allow you to report errors happening during construction.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A factory method for the first case we described could look as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This class has two factory methods (actually, the C++ standard doesn''t recognize
    the term *method*, calling them *member functions* instead): `fromRgba` and `fromBgra`.
    Now it''s harder to make a mistake and initialize the channels in the wrong order.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Note that having a private constructor effectively inhibits any class from inheriting
    from your type, as without access to its constructor, no instances can be created.
    If that's your goal and not a side effect, however, you should prefer to just
    mark your class as final.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Using factory functions
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As opposed to using factory member functions, we can also implement them using
    non-member ones. This way, we can provide better encapsulation, as described by
    Scott Meyers in his article linked in the *Further reading* section.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of our `Pixel`, we could also create a free function to fabricate
    its instances. This way, our type could have simpler code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Using this approach makes our design conform to the open-closed principle described
    in [Chapter 1](475bdf95-9ad0-4bdc-9e5d-5083405fe48a.xhtml)*, Importance of Software
    Architecture and Principles of Great Design*. It's easy to add more factory functions
    for other color palettes without the need to modify the `Pixel` struct itself.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'This implementation of `Pixel` allows the user to initialize it by hand instead
    of using one of our provided functions. If we want, we can inhibit this behavior
    by changing the class declaration. Here''s how it could look after the fix:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This time, our factory functions are friends of our class. However, the type
    is no longer an aggregate, so we can no longer use aggregate initialization (`Pixel{}`),
    including designated initializers. Also, we gave up on the open-closed principle.
    The two approaches offer different trade-offs, so choose wisely.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the return type of a factory
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yet another thing you should choose when implementing an object factory is the
    actual type it should return. Let's discuss the various approaches.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `Pixel`, which is a value type and not a polymorphic one, the
    simplest approach works the best – we simply return by value. If you produce a
    polymorphic type, return it by a smart pointer (**never** use a naked pointer
    for this as this will yield memory leaks at some point). If the caller should
    own the created object, usually returning it in `unique_ptr` to the base class
    is the best approach. In the not-so-common cases where your factory and the caller
    must both own the object, use `shared_ptr` or another reference-counted alternative.
    Sometimes it's enough that the factory keeps track of the object but doesn't store
    it. In such cases, store `weak_ptr` inside the factory and return `shared_ptr`
    outside.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Some C++ programmers would argue that you should return specific types using
    an out parameter, but that's not the best approach in most cases. In the case
    of performance, returning by value is usually the best choice, as compilers will
    not make extra copies of your object. If the issue is with the type being non-copyable,
    from C++17 onward, the standard specifies where copy elision is mandatory, so
    returning such types by value is usually not an issue. If your function returns
    multiple objects, use a pair, tuple, struct, or container.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'If something goes wrong during construction, you have several choices:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Return `std::optional` of your type if there's no need to provide error messages
    to the caller.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throw an exception if errors during construction are rare and should be propagated.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return `absl::StatusOr` of your type if errors during construction are common
    (see Abseil's documentation for this template in the *Further reading* section).
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you know what to return, let's discuss our last type of factories.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Using factory classes
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Factory classes are types that can fabricate objects for us. They can help
    decouple polymorphic object types from their callers. They can allow for using
    object pools (in which reusable objects are kept so that you don''t need to constantly
    allocate and free them) or other allocation schemes. Those are just a few examples
    of how they can be useful. Let''s take a closer look at yet another one. Imagine
    you need to create different polymorphic types based on input parameters. In some
    cases, a polymorphic factory function such as the one shown next is not enough:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'What if we wanted to open other kinds of documents as well, such as OpenDocument
    text files? It may be ironic to discover that the preceding open factory is not
    open for extension. It might not be a big issue if we own the codebase, but if
    the consumers of our library need to register their own types, this can be an
    issue. To solve it, let''s use a factory class that will allow registering functions
    to open different kinds of documents, as shown next:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The class doesn''t do much yet, but it has a map from extensions to functions
    that should be called to open files of given types. Now we''ll add two public
    member functions. The first one will register new file types:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now we have a way of filling the map. The second new public function will open
    the documents using an appropriate opener:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Basically, we extract the extension from the file path, throw an exception if
    it's empty, and if not, we look for an opener in our map. If found, we use it
    to open the given file, and if not, the map will throw another exception for us.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can instantiate our factory and register custom file types such as the
    OpenDocument text format:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Notice that we're registering a lambda because it can be converted to our `ConcreteOpener`
    type, which is a function pointer. However, if our lambda had state, this wouldn't
    be the case. In such a situation, we would need to use something to wrap us up.
    One such thing could be `std::function`, but the drawback of this would be the
    need to pay the cost of type erasure each time we would want to run the function.
    In the case of opening files, that's probably okay. If you need better performance,
    however, consider using a type such as `function_ref`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: An example implementation of this utility proposed to the C++ standard (not
    yet accepted) can be found on Sy Brand's GitHub repo referred to in the *Further
    reading* section.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, now that we have our opener registered in the factory, let''s use it
    to open a file and extract some text out of it:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: And that's all! If you want to provide the consumers of your library with a
    way to register their own types, they must have access to your map at runtime.
    You can either provide them with an API to reach it or make the factory static
    and allow them to register from anywhere in the code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: That does it for factories and building objects in a single step. Let's discuss
    another popular pattern to be used if factorys aren't a good fit.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Using builders
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Builders are similar to factories, a creational pattern coming from the Gang
    of Four. Unlike factories, they can help you build more complex objects: those
    that cannot be built in a single step, such as types assembled from many separate
    parts. They also provide you with a way to customize the construction of objects.
    In our case, we''ll skip designing complex hierarchies of builders. Instead, we''ll
    show how a builder can help. We''ll leave implementing hierarchies to you, as
    an exercise.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Builders are needed when an object cannot be produced in a single step, but
    having a fluent interface can just make them pleasant to use if the single step
    is not trivial. Let's demonstrate creating fluent builder hierarchies using CRTP.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we'll create a CRTP, `GenericItemBuilder`, that we'll use as our
    base builder, and `FetchingItemBuilder`, which will be a more specialized one
    that can fetches data using a remote address if that's a supported feature. Such
    specializations can even live in different libraries, for instance, consuming
    different APIs that may or may not be available at build time.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'For demo purposes, we''ll build instances of our `Item` struct from [Chapter
    5](315eea2a-c029-4bc3-a159-4f897d393639.xhtml)*, Leveraging C++ Language Features*:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you want, you can enforce that `Item` instances are built using a builder
    by making the default constructor private and making the builders friends:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Our builder''s implementation can be started as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Although it's generally not recommended to create protected members, we want
    our descendant builders to be able to reach our item. An alternative would be
    to use just the public methods of our base builder in derived ones.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'We take the name in the builder''s constructor, as it''s a single input coming
    from the user that needs to be set when we create our item. This way, we make
    sure that it will be set. An alternative would be to check whether it''s okay
    at the final stage of building, when the object is being released to the user.
    In our case, the build step can be implemented as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We enforce that the builder is "consumed" when this method is called; it must
    be an r-value. This means we can either use the builder in one line or move it
    in the last step to mark its end of work. We then set the creation time for our
    item and move it outside of the builder.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Our builder''s API could offer functions such as the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Each of them returns the concrete (derived) builder object as an r-value reference.
    Perhaps counterintuitively, this time such a return type should be preferred to
    returning by value. This is to avoid unnecessary copies of `item_` when building.
    On the other hand, returning by an l-value reference could lead to dangling references
    and would make calling `build()` harder because the returned l-value reference
    wouldn't match the expected r-value one.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'The final builder type could look as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'It''s just a class that reuses the constructors from our generic builder. It
    can be used as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see, the final interface can be called using function chaining and
    the method names make the whole invocation fluent to read, hence the name *fluent
    interfaces*.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we were to not load each item directly, but rather use a more specialized
    builder that could load parts of the data from a remote endpoint? We could define
    it as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We also use CRTP to inherit from our generic builder and also enforce giving
    us a name. This time, however, we extend the base builder with our own function
    to fetch the contents and put them in the item we''re building. Thanks to CRTP,
    when we call a function from our base builder, we''ll get the derived one returned,
    which makes the interface much easier to use. It can be called in the following
    manner:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: All nice and dandy!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Builders can also come in handy if you need to always create immutable objects.
    As the builder has access to private members of the class, it can modify them,
    even if the class doesn't provide any setters for them. That's of course not the
    only case when you can benefit from using them.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Building with composites and prototypes
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A case where you would need to use a builder is when creating a composite. A
    composite is a design pattern in which a group of objects is treated as one, all
    sharing the same interface (or the same base type). An example would be a graph,
    which you could compose out of subgraphs, or a document, which could nest other
    documents. When you would call `print()` on such an object, all its sub-objects
    would get their `print()` functions called in order to print the whole composite.
    The builder pattern can be useful for creating each sub-object and composing them
    all together.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Prototype is yet another pattern that can be used for object construction.
    If your type is very costly to create anew, or you just want to have a base object
    to build upon, you might want to use this pattern. It boils down to providing
    a way to clone your object, which you could later either use on its own or modify
    so it becomes what it should be. In the case of a polymorphic hierarchy, just
    add `clone()` like so:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Our `MapWithPointsOfInterests` object could clone the points too, so we don't
    need to re-add each of them manually. This way, we can have some default provided
    to the end user when they create their own map. Note also that in some cases,
    instead of using a prototype, a simple copy constructor would suffice.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: We have now covered object creation. We touched on variants along the way, so
    why not revisit them (pun intended) to see how else they can help us?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Tracking state and visiting objects in C++
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: State is a design pattern meant to help change the behavior of an object when
    its internal state changes. The behavior for different states should be independent
    of each other so that adding new states doesn't affect the current ones. The simple
    approach of implementing all the behavior in the stateful object doesn't scale
    and is not open for extension. Using the state pattern, new behavior can be added
    by introducing new state classes and defining the transitions between them. In
    this section, we'll show a way to implement states and a state machine leveraging
    `std::variant` and statically polymorphic double dispatch. In other words, we'll
    build a finite state machine by joining the state and visitor patterns in a C++
    way.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s define our states. In our example, let''s model the states of
    a product in a store. They can be as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Our states can have properties of their own, such as the count of items left.
    Also, as opposed to dynamically polymorphic ones, they don''t need to inherit
    from a common base. Instead, they are all stored in one variant, as shown next:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Aside from states, we also need events for state transitions. Check the following
    code:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As you can see, our events can also have properties and don''t inherit from
    a common base. Now, we need to implement the transitions between the states. This
    can be done as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If a purchase is made, the state can change, but it can also stay the same.
    We can also use templates to handle several states at once:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If an item gets discontinued, it doesn''t matter what state it was in. Okay,
    let''s now implement the last supported transition:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The next piece of the puzzle we need is a way to define multiple call operators
    in one object generically so that the best matching overload can be called. We''ll
    use it later to call the transitions we just defined. Our helper can look as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We create an `overload` struct that will provide all the call operators passed
    to it during construction, using variable templates, a fold expression, and a
    class template argument deduction guide. For a more in-depth explanation of this,
    along with an alternative way of implementing visitation, refer to Bartłomiej
    Filipek's blog post in the *Further reading* section.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now start implementing the state machine itself:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Our `process_event` function will accept any of our defined events. It will
    call an appropriate `on_event` function using the current state and the passed
    event and switch to the new state. If an `on_event` overload is found for the
    given state and event, the first lambda will get called. Otherwise, the constraint
    won't be satisfied and the second, more generic overload will get called. This
    means if there's an unsupported state transition, we'll just throw an exception.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s provide a way to report the current state:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, we use our overload to pass three lambdas, each returning a report string
    generated by visiting our state object.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now call our solution:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Upon running, this will yield the following output:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: That is, unless you uncomment the last line with the unsupported transition,
    in which case an exception will be thrown at the end.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Our solution is much more performant than dynamic polymorphism-based ones, although
    the list of supported states and events is constrained to those provided at compile
    time. For more information on states, variants, and the various ways of visitations,
    see Mateusz Pusz's talk from CppCon 2018, also listed in the *Further reading*
    section.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Before we close this chapter, one last thing we'd like for you to learn about
    is handling memory. Let's begin our last section.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with memory efficiently
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if you don't have very limited memory, it's a good idea to look at how
    you use it. Usually, memory throughput is the performance bottleneck of modern-day
    systems, so it's always important to make good use of it. Performing too many
    dynamic allocations can slow down your program and lead to memory fragmentation.
    Let's learn a few ways to mitigate those issues.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Reducing dynamic allocations using SSO/SOO
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dynamic allocations can sometimes cause you other trouble than just throwing
    when you construct objects despite not having enough memory. They often cost you
    CPU cycles and can cause memory fragmentation. Fortunately, there is a way to
    protect against it. If you''ve ever used `std::string` (post GCC 5.0), you most
    probably used an optimization called **Small String Optimization** (**SSO**).
    This is one example of a more general optimization named **Small Object Optimization**
    (**SSO**), which can be spotted in types such as Abseil''s InlinedVector. The
    main idea is pretty straightforward: if the dynamically allocated object is small
    enough, it should be stored inside the class that owns it instead of being dynamically
    allocated. In `std::string`''s case, usually, there''s a capacity, length, and
    the actual string to store. If the string is short enough (in GCC''s case, on
    64-bit platforms, it''s 15 bytes), it will be stored in some of those members.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Storing objects in place instead of allocating them somewhere else and storing
    just the pointer has one more benefit: less pointer chasing. Each time you need
    to reach to data stored behind a pointer, you increase the pressure on the CPU
    caches and risk needing to fetch data from the main memory. If this is a common
    pattern, it can influence the overall performance of your app, especially if the
    pointed-to addresses aren''t guessed by the CPU''s prefetcher. Using techniques
    such as SSO and SOO are invaluable in reducing those issues.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Saving memory by herding COWs
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you used GCC's `std::string` before GCC 5.0, you might have used a different
    optimization called **Copy-On-Write** (**COW**). The COW string implementation,
    when it had multiple instances created with the same underlying character array,
    was actually sharing the same memory address for it. When the string was written
    to, the underlying storage was copied — hence the name.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: This technique helped save memory and keep the caches hot, and often offered
    solid performance on a single thread. Beware of using it in multi-threaded contexts,
    though. The need for using locks can be a real performance killer. As with any
    performance-related topic, it's best to just measure whether in your case it's
    the best tool for the job.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Let's now discuss a feature of C++17 that can help you achieve good performance
    with dynamic allocations.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging polymorphic allocators
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The feature we're talking about is polymorphic allocators. To be specific, the
    `std::pmr::polymorphic_allocator` and the polymorphic `std::pmr::memory_resource`
    class that the allocator uses to allocate memory.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'In essence, it allows you to easily chain memory resources to make the best
    use of your memory. Chains can be as simple as one resource that reserves a big
    chunk and distributes it, falling back to another that simply calls `new` and
    `delete` if it depletes memory. They can also be much more complex: you can build
    a long chain of memory resources that handle pools of different sizes, offer thread-safety
    only when needed, bypass the heap and go for the system''s memory directly, return
    you the last freed chunk of memory to provide cache hotness, and do other fancy
    stuff. Not all of these capabilities are offered by the standard polymorphic memory
    resources, but thanks to their design, it''s easy to extend them.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Let's first tackle the topic of memory arenas.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Using memory arenas
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A memory arena, also called a region, is just a large chunk of memory that exists
    for a limited time. You can use it to allocate smaller objects that you use for
    the lifetime of the arena. Objects in the arena can be either deallocated as usual
    or erased all at once in a process called *winking out*. We'll describe it later
    on.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Arenas have several great advantages over the usual allocations and deallocations
    – they increase performance because they limit the memory allocations that need
    to grab upstream resources. They also reduce fragmentation of memory, because
    any fragmentation that would happen will happen inside the arena. Once an arena's
    memory is released, the fragmentation is no more as well. A great idea is to create
    separate arenas per thread. If only a single thread uses an arena, it doesn't
    need to use any locking or other thread-safety mechanisms, reducing thread contention
    and giving you a nice boost in performance.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'If your program is single-threaded, a low-cost solution to increase its performance
    could be as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The default resource if you won't set any explicitly will be `new_delete_resource`,
    which calls `new` and `delete` each time just like regular `std::allocator` does,
    and with all the thread-safety it provides (and costs).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use the preceding code snippet, all the allocations done using `pmr`
    allocators would be done with no locks. You still need to actually use the `pmr`
    types, though. To do so with standard containers, for instance, you need to simply
    pass `std::pmr::polymorphic_allocator<T>` as the allocator template parameter.
    Many standard containers have `pmr`-enabled type aliases. The two variables created
    next are of the same type and both will use the default memory resource:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The first one gets the resource passed explicitly, though. Let's now go through
    the resources available in `pmr`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Using the monotonic memory resource
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first one we'll discuss is `std::pmr::monotonic_buffer_resource`. It's a
    resource that only allocates memory and doesn't do anything on deallocation. It
    will only deallocate memory when the resource is destructed or on an explicit
    call to `release()`. This, connected with no thread safety, makes this type extremely
    performant. If your application occasionally needs to perform a task that does
    lots of allocations on a given thread, then releases all the objects used at once
    afterward, using monotonic resources will yield great gains. It's also a great
    base building block for chains of resources.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Using pool resources
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common combo of two resources is to use a pool resource on top of a monotonic
    buffer resource. The standard pool resources create pools of different-sized chunks.
    There are two types in `std::pmr`, `unsynchronized_pool_resource` for use when
    only one thread allocates and deallocates from it and `synchronized_pool_resource`
    for multi-threaded use. Both should provide you with much better performance compared
    to the global allocator, especially when using the monotonic buffer as their upstream
    resource. If you wonder how to chain them, here''s how:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We create a 1 MB buffer for the arena to reuse. We pass it to a monotonic resource,
    which is then passed to an unsynchronized pool resource, creating a simple yet
    efficient chain of allocators that won't call new until all the initial buffer
    is used up.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: You can pass a `std::pmr::pool_options` object to both the pool types to limit
    the max count of blocks of a given size (`max_blocks_per_chunk`) or the size of
    the largest block (`largest_required_pool_block`). Passing 0 causes the implementation's
    default to be used. In the case of GCC's library, the actual blocks per chunk
    differ depending on the block size. If the max size is exceeded, the pool resource
    will allocate directly from its upstream resource. It also goes to the upstream
    resource if the initial memory was depleted. In this case, it allocates geometrically
    growing chunks of memory.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Writing your own memory resource
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the standard memory resources don't suit all your needs, you can always create
    a custom one quite simply. For instance, a good optimization that not all standard
    library implementations offer is to keep track of the last chunks of a given size
    that were released and return them back on the next allocations of given sizes.
    This `Most Recently Used` cache can help you increase the hotness of data caches,
    which should help your app's performance. You can think of it as a set of LIFO
    queues for chunks.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you might also want to debug allocations and deallocations. In the
    following snippet, I have written a simple resource that can help you with this
    task:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Our verbose resource inherits from the polymorphic base resource. It also accepts
    an upstream resource, which it will use for actual allocations. It has to implement
    three private functions – one for allocating, one for deallocating, and one for
    comparing instances of the resource itself. Here''s the first one:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'All it does is print the allocation size on the standard output and then use
    the upstream resource to allocate memory. The next one will be similar:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We log how much memory we deallocate and use the upstream to perform the task.
    Now the last required function is stated next:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We simply compare the addresses of the instances to know whether they're equal.
    The `[[nodiscard]]` attribute helps us be sure that the caller actually consumes
    the returned value, which can help us avoid accidental misuse of our function.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: That's it. For a powerful feature such as the `pmr` allocators, the API isn't
    that complex now, isn't it?
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Aside from tracking allocations, we can also use `pmr` to guard us against allocating
    when we shouldn't.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring there are no unexpected allocations
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The special `std::pmr::null_memory_resource()` will throw an exception when
    anyone tries to allocate memory using it. You can safeguard from performing any
    allocations using `pmr` by setting it as the default resource as shown next:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You can also use it to limit allocation from the upstream when it shouldn''t
    happen. Check the following code:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If anybody tries to allocate more than the buffer size we set, `std::bad_alloc`
    would be thrown.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to our last item in this chapter.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Winking out memory
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes not having to deallocate the memory, as the monotonic buffer resource
    does, is still not enough for performance. A special technique called *winking*
    out can help here. Winking out objects means that they're not only not deallocated
    one by one, but their constructors aren't called too. The objects simply evaporate,
    saving time that would normally be spent calling destructors for each object and
    their members (and their members...) in the arena.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'NOTE: This is an advanced topic. Be careful when using this technique, and
    only use it if the possible gain is worth it.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: This technique can save your precious CPU cycles, but it's not always possible
    to use it. Avoid winking out memory if your objects handle resources other than
    memory. Otherwise, you will get resource leaks. The same goes if you depend on
    any side effects the destructors of your objects would have.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see winking out in action:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Here, we created a polymorphic allocator by hand that'll use our default resource
    – a monotonic one that logs each time it reaches upstream. To create objects,
    we'll use a C++20 addition to `pmr`, the `new_object` function. We create a vector
    of strings. We can pass the first one using `push_back`, because it's small enough
    to fit into the small-string buffer we have thanks to SSO. The second string would
    need to allocate a string using the default resource and only then pass it to
    our vector if we used `push_back`. Emplacing it causes the string to be constructed
    inside the vector's functions (not before the call), so it will use the vector's
    allocator. Finally, we don't call the destructors of allocated objects anywhere,
    and just deallocate everything at once, when we exit the scope. This should give
    us hard-to-beat performance.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: That was the last item on our list for this chapter. Let's summarize what we've
    learned.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through various idioms and patterns used in the C++
    world. You should now be able to write fluent, idiomatic C++. We've demystified
    how to perform automatic cleanup. You can now write safer types that properly
    move, copy, and swap. You learned how to use ADL to your advantage both with compilation
    times and writing customization points. We discussed how to choose between static
    and dynamic polymorphism. We also learned how to introduce policies to your types,
    when to use type erasure, and when not.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: What's more, we discussed how to create objects using factories and fluent builders.
    Moreover, using memory arenas for this is also no longer arcane magic. So is writing
    state machines using tools such as variants.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: We did all that as well as touching on extra topics down the road. Phew! The
    next stop on our journey will be about building your software and packaging it.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the rules of three, five, and zero?
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When do we use niebloids versus hidden friends?
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can arrays interfaces be improved to be more production-ready?
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are fold expressions?
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When shouldn't you use static polymorphism?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we save on one more allocation in the winking out example?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*tag_invoke: A general pattern for supporting customisable functions*, Lewis
    Baker, Eric Niebler, Kirk Shoop, ISO C++ proposal, [https://wg21.link/p1895](https://wg21.link/p1895)'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*tag_invoke :: niebloids evolved*, Gašper Ažman for the Core C++ Conference,
    YouTube video, [https://www.youtube.com/watch?v=oQ26YL0J6DU](https://www.youtube.com/watch?v=oQ26YL0J6DU)'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Inheritance Is The Base Class of Evil*, Sean Parent for the GoingNative 2013
    Conference, Channel9 video, [https://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil](https://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil)'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Modern C++ Design*, Andrei Alexandrescu, Addison-Wesley, 2001'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*How Non-Member Functions Improve Encapsulation*, Scott Meyers, Dr. Dobbs article,
    [https://www.drdobbs.com/cpp/how-non-member-functions-improve-encapsu/184401197](https://www.drdobbs.com/cpp/how-non-member-functions-improve-encapsu/184401197)'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Returning a Status or a Value*, Status User Guide, Abseil documentation, [https://abseil.io/docs/cpp/guides/status#returning-a-status-or-a-value](https://abseil.io/docs/cpp/guides/status#returning-a-status-or-a-value)'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`function_ref`, GitHub repository, [https://github.com/TartanLlama/function_ref](https://github.com/TartanLlama/function_ref)'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*How To Use std::visit With Multiple Variants*, Bartłomiej Filipek, post on
    Bartek''s coding blog, [https://www.bfilipek.com/2018/09/visit-variants.html](https://www.bfilipek.com/2018/09/visit-variants.html)'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'CppCon 2018: Mateusz Pusz, *Effective replacement of dynamic polymorphism with
    std::variant*, YouTube video, [https://www.youtube.com/watch?v=gKbORJtnVu8](https://www.youtube.com/watch?v=gKbORJtnVu8)'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
