- en: Chapter 6. Infiltrating Sessions via Cross-Site Scripting
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章。通过跨站脚本攻击渗透会话
- en: Web application hacking is in a class of its own. While network- and system-related
    hacking focuses on gaining persistent presence on those systems or otherwise modifying
    their state, web pen testing is focused on fooling the server, client, or both
    into doing the attacker's bidding. Sure, you can try to *pawn* those servers or
    compromise the client or browser, but if you can get all you want from the exchange
    without establishing a permanent residence, why not? Injection attacks, which
    make a lot of web developers very nervous, are like a Jedi Mind Trick for web
    applications. With a wave of your hand (not literally, it is really just some
    effort on a keyboard), you can convince the server, client, or both to act in
    a way they would not otherwise. This may be done to give up data (as is believed
    to have happened in the Impact Team's Ashley Madison hack) or to poison one or
    both sides with malicious scripts that defy the trust between client and server.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序的黑客攻击是一种独特的类别。虽然与网络和系统相关的黑客攻击侧重于在这些系统上获得持久存在或以其他方式修改它们的状态，但Web渗透测试侧重于愚弄服务器、客户端或两者以执行攻击者的命令。当然，你可以尝试攻击这些服务器或者妥协客户端或浏览器，但如果你可以在不建立永久住所的情况下从交换中得到你想要的一切，为什么不呢？注入攻击让许多Web开发人员非常紧张，就像对Web应用程序的绝地心灵攻击一样。通过挥动你的手（不是字面上的，实际上只是键盘上的一些努力），你可以说服服务器、客户端或两者以一种它们本来不会的方式行动。这可能是为了放弃数据（正如人们相信在Impact
    Team的Ashley Madison黑客攻击中发生的那样）或者用恶意脚本毒害一方或双方，违背客户端和服务器之间的信任。
- en: '**Cross-site scripting** (it can be abbreviated **CSS** or **XSS**, but we''ll
    use the latter to avoid confusing this attack with **Cascading Style Sheets**)
    is something many of you have probably worked through in practice or tested for
    through automated tools, but it is a very deep topic that could justify its own
    book. As a subset of the broader term injection attacks, XSS focuses on using
    JavaScript where it shouldn''t be. Rather than broadly manipulating the hijacked
    requests and responses, XSS finds daylight in them to insert covert scripts that
    would otherwise be unable to land and execute. These scripts now appear trustworthy
    to our targets and their users because of the trust they have for each other,
    and we''ll use this trusted relationship against them.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站脚本**（它可以缩写为**CSS**或**XSS**，但我们将使用后者以避免将此攻击与**层叠样式表**混淆）是你们许多人可能在实践中或通过自动化工具进行测试的一个非常深入的主题，但它是一个非常深入的主题，可能需要一本专门的书来证明。作为更广泛的注入攻击的子集，XSS侧重于在不应该出现的地方使用JavaScript。与广泛操纵劫持的请求和响应不同，XSS在其中找到了插入秘密脚本的空间，否则这些脚本将无法着陆和执行。这些脚本现在对我们的目标和他们的用户来说是可信的，因为他们对彼此的信任，我们将利用这种信任关系来对付他们。'
- en: The purpose of these scripts can vary greatly, but the many uses can include
    exposing cookies and session information, allowing for redirection and MITM attacks,
    hijacking one or both endpoints for other attacks, and even facilitating exfiltration
    of sensitive data. These traits make them extremely dangerous, and despite their
    high ranking in the OWASP Top 10 for the last few cycles, they continue to be
    a major issue.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些脚本的目的可以大不相同，但许多用途包括暴露cookie和会话信息，允许重定向和中间人攻击，劫持一个或两个端点进行其他攻击，甚至促进敏感数据的外泄。这些特征使它们极为危险，尽管它们在过去几个周期的OWASP十大中排名很高，但它们仍然是一个主要问题。
- en: XSS has many applications but in this chapter, we'll differentiate the types
    of XSS and provide some options onÂ how to best unleash them in your testing.
    While Burp and ZAP can provide some XSS exploits, it is helpful to understand
    how to craft our own and use other tools available in Kali to help deliver them.
    This chapter will discuss various forms of XSS and show other ways we can use
    this powerful attack form to compromise our targets.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: XSS有许多应用，但在本章中，我们将区分XSS的类型，并提供一些关于如何在测试中最好地释放它们的选项。虽然Burp和ZAP可以提供一些XSS攻击，但了解如何制作我们自己的攻击并使用Kali中其他可用的工具来帮助传递它们是有帮助的。本章将讨论各种形式的XSS，并展示我们可以使用这种强大的攻击形式来妥协我们的目标的其他方法。
- en: 'In this chapter, you will learn the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学到以下内容：
- en: Discussing various forms of XSS, how to detect vulnerabilities in them and exploit
    them
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论各种形式的XSS，如何检测它们的漏洞并利用它们
- en: Exploring how **stored** (also known asÂ **persistent**) XSS attacks work and
    how to take advantage of them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索**存储**（也称为**持久性**）XSS攻击的工作原理以及如何利用它们
- en: Understanding and testing for **reflected** XSS using social engineering techniques
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用社会工程技术理解和测试**反射**XSS
- en: Discussing the capabilities of additional tools such as BeEF, XSSer, Websploit,
    and Metasploit and their ability to handle each form of XSS attack
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论其他工具的功能，如BeEF、XSSer、Websploit和Metasploit，以及它们处理每种XSS攻击的能力
- en: The low-down on XSSÂ types
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XSS类型的详细信息
- en: '* * *'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'XSS attacks are both common and dire; in the right places, they can be used
    to deliver malicious scripts, funnel traffic to an alternative redirect, or implant
    faulty data. Efforts to categorize them have added to the confusion for some of
    us. The earliest categorization focused on its persistence (or lack thereof),
    but over time, the industry has focused on the affected host: a web server or
    browsing client. OWASP has done a great job of redefining these types to help
    us (pen testers) choose the best detection methods and exploitation tools for
    each. The common thread that ties them together is that they all involve user
    input being relayed by a server without proper validation, and these attacks always
    execute in the browser, regardless of the delivery method. Let''s review the latest
    categorization, so we''re ready to use them effectively.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Should XSS stay or should it go?
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'XSS attacks, regardless of where they take place, can be either stored or reflective.
    Both can range from annoying to gravely serious, depending on the intent and the
    impacted session''s context:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Stored XSS attacks (persistent) are quite common where data from an attacker
    masquerading as a legitimate user is not properly screened before being presented
    to other users. This code will persist, continuing to impact users until it is
    detected, the data purged, or precautions implemented on the web service to ensure
    that responses containing the code are properly validated. In effect, the code
    is stored in the server itself, as shownÂ here:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B03918_06_01-1.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: Stored XSS will attack any client viewing the requested page.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Reflective XSS attacks (also called non-persisentent) are more varied, in that
    they can be initiated through phishing campaigns, social engineering, MITM attacks,
    or some other diversion. Unwitting users initiate the attack by clicking on a
    malicious link with the script in it. The attacker crafts their scripts such that
    they are returned or reflected within the error or search response of the web
    server under attack. Because the attacker convinced a user to click on a link
    that embedded a script, they knewÂ it would be reflected in a response; the poor
    client browser will now trust that script as if it originated at the server itself.
    In actuality, the victim''s browser originated the request, as seen in the following
    screenshot:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B03918_06_02-1.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: Reflective, or Non-Persistent XSS tends to be more focused on a group of users.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Location, location, and location!
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second means by which we can differentiate XSS types is by the location.
    The detection methods and defensive countermeasures can vary greatly based on
    which end of the connection was attacked: the client or server:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Server XSS attacks can happen when a server is guilty of delivering malicious
    content as a part of its responses to client requests, because it was not adequately
    filtered or validated when it was originally input by another client, usually
    the attacking host. These attacks can be difficult for the client because the
    server bundles the attack with its HTML, and the client's browser is unable to
    differentiate the modified behavior of the server and therefore renders it faithfully,
    trusting both the intended and the plantedÂ nefarious code.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client XSS attacks, on the other hand, focus on the malicious code or modification
    being delivered inside the client's own facilities. The most popular form of these
    by far is the DOM-based XSS, which targets the page's state machine in the browser.
    Most of the time, when we talk about client-side XSS, we are referring to **DOM-based
    XSS**. DOM-based XSS attacks are a subset of the client XSS, and they take advantage
    of dynamic web application design. In most modern web applications, a browser,
    upon visiting a site, will build a **Document Object Model** (**DOM**) that can
    parse the HTML into objects in a tree. This parsing allows a scripting language
    (most of the time, we talk about JavaScript here, but other web content such as
    HTML, ActiveX, and Flash applies) to modify the contents of the HTML representing
    the tree dynamically. DOM-based XSS attacks are especially troubling in that the
    server may never see anything overtly bad in the script. Instead, the server unwittingly
    aids the attacker by referring to a variable local to the victim, not having the
    slightest clue that the variable is something bad (like a redirect, hook file,
    and so on).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It should be noted that both server and client-side XSS attacks can be either
    Stored or Reflective attacks. Most of the tools worth carrying in your bag, as
    they say, should be able to assist with scanning and exploiting most varieties.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: XSS targeting and the delivery
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As dire a threat as XSS presents to a web application and its users, it is shockingly
    easy to implement. Delivered in most cases through a browser or e-mail, all the
    attacker needs is a working knowledge of HTML and JavaScript and a target web
    server susceptible to this form of attack. Using these skills, the hacker can
    choose how big a net they are willing to cast. We must be wary of all forms of
    injection attacks, XSS included, as they can all wreak havoc on an application
    long before incident response can begin to remediate these issues.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: With stored XSS, hackers cast a big net and impact a large number of users with
    their malicious script.Â  This is wonderful if the potential users of the application
    are predominantly in scope, and the attack is more straightforward becauseÂ no
    social engineering is required to seed the script. That being said, it is for
    these reasons that stored XSS must be used sparingly. There is no choice about
    which victims will report in, and thus more overhead is required on the attacker's
    part to discriminate between in- and out-of-scope victims. The wider potential
    audience also calls into question the fit for an ethical hack, as the potential
    for capturing data from collaterally damaged hosts is extremely high, and the
    customer will likely have concerns that need to be addressed. This makes the stored
    or persistent XSS attack very harmful to many people.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Reflective XSS is well worth the effort upfront, as the phishing campaign, tainted
    link, or other means of delivery is more precise, and thus limits collateral damage.Â 
    This also enables the hacker or tester to focus on the impacted set of targets
    and virtually guarantees that the collected data is collected from users of interest.
    While the potential damage to a victim is commensurate with the stored XSS attack,
    the victim or victims are intended, so this makes it safer and worth the effort.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Seeing is believing
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: When reporting to a customer on the presence of a web application's vulnerabilities,
    most test reports will show scans that identify just theÂ possibility a vulnerability
    exists (identification) but also go a step further and actually demonstrate that
    an exploit of the vulnerability was successful (confirmation). Arachni, ZAP, Burp
    Suite, and other vulnerability assessment tools can help with the identification
    effort. Some of these tools can assist with confirmation, but most testers will
    confirm using independent XSS-focused tools or methods to mimic the behavior of
    the exploit when employed by hackers. A quick search of your favorite search engine
    will see that there are some leading candidates, but we'll talk about the most
    popularly discussed ones, and then look at how the stalwarts can enable us to
    put our targets through their paces.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Don't run with XSSer(s)!
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the quickest and to-the-point tools available in Kali for XSS testing
    isÂ **XSSer** (sometimes pronounced *scissor*). As a tool, XSSer serves one function,
    which is to test for the presence of potential XSS vulnerabilities on a web application
    and offer up quick, non-controversial validation URL strings to run a check against
    them. XSSer is one of those rare tools that can give you awesome capability with
    minimal know-how; but with an experienced hand, it can be tailored with surgical
    precision.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use XSSer either as a CLI tool or with its GUI wrapper, which is a
    fine way to build CLI queries with the help of a more intuitive wrapper. To use
    XSSer in the GUI mode, you can simply type the following in a terminal session:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: XSSer is a fine tool for running mundane alert-based test scripts against websites
    to determine their susceptibility. That being said, I find that XSSer suffers
    from neglect since its last published version was posted in 2013, four years prior
    to the writing of this text and a few revisions of Metasploit past.Â  In fact,
    the latest version was more applicable to Backtrack, but still provides a useful
    wizard and some educational value. Against specific targets, however, I find that
    it is both buggy and limited in application when compared to more current tools.
    It is worth a look, but I would recommend concentrating on some more fully-featured
    tools, such as BeEF and Metasploit.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Stored XSS with BeEF
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Browser Exploitation Framework** (**BeEF**, available at [http://beefproject.com](http://beefproject.com/))
    is a tool we took a look at in *Penetration Testing with the Raspberry Pi, Second
    EditionÂ *([https://www.packtpub.com/networking-and-servers/penetration-testing-raspberry-pi-second-edition](https://www.packtpub.com/networking-and-servers/penetration-testing-raspberry-pi-second-edition))*,Â *where
    we discussed its general use as a honeypot or malicious web server. These same
    capabilities make BeEF a fantastic tool for the delivery and subsequent management
    of a variety of XSS attacks. What makes BeEF powerful is that it leverages a single
    hook script in internet browsers for its attack, and because of the XSS vulnerability
    in the web server, it can evade most controls employed by more paranoid or better
    trained victims. Short of blocking various HTML data types completely, a perfectly
    configured client can still be run because of the trusted relationship exploited
    by the attacker.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: BeEF, after hooking the victim, is capable of assessing the inherent vulnerabilities
    of the browser and operating system combination. Based on these findings, BeEF
    offers a range of command modules that can be launched, such as taking screenshots,
    scraping credentials or exfiltrating cookies, or even triggering a beep sound.
    Hooked systems can only be accessed while they are online. However, once hooked,
    BeEF can track when a system establishes internet connectivity to continue launching
    commands against that system. Pretty slick, and very scary!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'To show this in action and help understand the power of a Stored XSS attack,
    we''ll use the BeEF hook script and point the client to our Kali machine''s BeEF
    instance. The following screenshot shows our test scenario, where the following
    are configured:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '**Attacker''s machine**: Kali VM is running a BeEF server, listening on all
    interfaces (172.16.30.128 is the external IP address)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web Server/Application**: OWASP BWA VM, specifically the Mutillidae web application'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**:Â Windows 7 VM running Internet Explorer 10 (evaluation copy)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The attacker can remotely execute command modules from the Kali/BeEF control
    headend while the hooked victim continues to use the internet, typically oblivious
    to the compromise. In an actual attack or a black-box attack as seen in the following
    screenshot, the hacker will more often than not deploy a cloud or otherwise temporary
    instance of Kali or a similar machine and masquerade it behind several layers
    of obfuscation (VPN, TOR, proxy, and so on) to act as the attacking machine and
    make attribution or detection harder on the target server. Regardless of the attacking
    machine's location, in a stored XSS, the vulnerable server will continue to help
    us hook our prey.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_03-1.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: Our Stored XSS scenario with BeEF
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'We can first launch BeEF-XSS from the GUI applications menu, the **`Favorites`**Â bar,
    or from the CLI by navigating to the BeEF directory (`cd /usr/share/beef-xss`)
    and then running the `beef` script using `./beef`. As it starts up, the **`Terminal`**
    session will show us the general URL for the user interface (`UI URL`Â in red)
    and the script we''ll want to use to hook our prey (`Hook`, in blue), as seen
    here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_04-1.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: BeEF's Startup process tells us how to manage the instance and how to hook the
    browser.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'BeEF will automatically launch a browser session that you can log in to using
    the username and password of *beef*. When it is first fired up, the online and
    offline Browsers lists will be empty. We''ll open a new tab and visit the *Mutillidae
    Web Application* as a visiting attacker, where we can enter our hook script in
    a field sure to be seen by the poor victims (**`OWASP 2013`**Â |Â **`A3 - Cross
    Site Scripting (XSS)`**Â |Â **`Persistent (Second Order)`**Â |Â **`Add to your
    blog`**), as seenÂ here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_05-1.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: Mutillidae offers some mock-forms we can use for Stored XSS.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be presented with a blog entry form, in which we can drop our hook script
    (`<script src="img/hook.js"></script>`), and then click the **`Save Blog Entry`**
    button (as shown in the following screenshot):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_06.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: Planting our hook script on the web app's blog feature.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Okay, let's switch hats and open up our poor, unsuspecting Windows 7 VM running
    IE 10! On the windows VM, we'll visit the blog as an observer â�� nothing crazy
    here. Just follow the path of **`OWASP 2013`**Â |Â **`A3 - Cross Site Scripting
    (XSS)`**Â |Â **`Persistent (Second Order)`**Â |Â **`View someone's blog`**Â as
    we see in the figure following, we'll want to see the inputs of all users. The
    page will show us all of the entries, including our anonymous user's input containing
    the script. We know that the blog pages are vulnerable because we saw it identifiedÂ inÂ [Chapter
    5](000.html#), *Proxy Operations with OWASP ZAP and Burp Suite*,Â testing as potentially
    possessing an XSS script vulnerability (as shown in figure following). Here we
    know that the server is not validating the contents of these entries before parroting
    them back in responses from subsequent victims.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_07.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: Browsing to the affected blog from the victim site.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Once we've navigated to the blog view (as shown in figure following), we'll
    see a blank space where the anonymous user apparently entered nothing. At this
    point, they have no reason to believe they have been hacked or were exposed to
    a malicious XSS attack.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_08-1.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: All that wasted potential (script hidden) in an otherwise awesome blog.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Our Kali box knows otherwise; looking at the control UI for our BeEF-XSS framework,
    we can see that the Windows 7 box running IE 10 has checked in and is reporting
    for duty. Because browsers are so helpful in announcing what they can and cannot
    support, BeEF has a pretty good idea as to what hacks and tricks we can accomplish
    with the victim we've just hooked, and in following screenshot, we see that I
    have searched for *cookie*-related commands, selected **`Get Cookie`**Â from the
    **`Browser`**Â | **`Hooked Domain`** part of the **`Module Tree`**, and run it
    to obtain a session cookie being used between the victim's browser and the Mutillidae
    web server. Other useful attacks that we can use, outside just proving that an
    XSS vulnerability exists, are those that can help us grab social media login statuses,
    installed software, browsing history, and anything else that can help us better
    characterize the target environment.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_09.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: Almost 200 Modules come with BeEF to help us turn browsers into extensions of
    us!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind, we came here to pen-test the web application, not the users and
    the entire environment.Â  Unless you also have a red team sort of charter, steer
    clear of pulling anything outside any web-application-specific data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Here, phishy phishy!
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A reflected XSS attack follows a similar story, except that the user is employed
    to help hack themselves by tricking them to pass along the script. The phishing
    or link placement by the attacker replaces the form-based exploit and does require
    some work. **Phishing** involves sending a *lure*Â e-mail or web page to potential
    targets in the hope that they will believe their intent and click on one of the
    malicious links embedded within it. Phishing can often be used in other attacks
    (a simple redirect to a phishing site is still quite popular), but combining the
    targeted spamming with a redirect using a legitimate site, but a malicious script,
    can be downright nasty. That being said, let's discuss some of what attackers
    and we pen testers need to consider.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Building a target list can be labor-intensive; in fact, target lists are a popular
    service offering on dark-web hacking sites. In pen testing, OSINT and social engineering
    using tools such as your browser, Maltego, or social media can save the day, allowing
    us to leverage the information gathered to help us assess who it is we are after.
    In our testing, IT personnel, so called *C-suite* executives (especially the **Chief
    Information Officer** (**CIO**), **Chief Information Security Officer** (**CISO**),
    and any other technology-related positions), and any other people associated with
    security, operations, architecture, or application development at the site should
    be considered.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Large-scale hacks like that conducted by Russian hackers against [https://in.yahoo.com/?p=us](https://in.yahoo.com/?p=us)Â in
    2014 ([https://www.justice.gov/opa/press-release/file/948201/download](https://www.justice.gov/opa/press-release/file/948201/download))
    often begin with a smaller-focus phishing campaign against known employees and
    a credible reason for them receiving the e-mail. In this case, the information
    was used to help forge cookies and steal access to over 500 million accounts.Â 
    This was no fun for many of us.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Attackers will then need a willing mail relay or server to allow a mass mailing
    of the lure to their intended targets. There are services for hire that the bad
    guys will use (for example, notorious spam houses such as Send-Safe), or they
    may instead choose to deploy spambots on legitimate infrastructure or, worse yet,
    compromise a web server, and turn it into a PHP-based e-mail server or gateway.
    This last method is especially nefarious, because if they are able to compromise
    the target corporation's webmail service, they can operate as if they were completely
    legitimate.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just need the bait! A phishing-based delivery of the link helps limit
    unwanted target acquisition and is easier to pass off without attribution and
    collateral damage than other methods of enticing Reflected XSS, such as honeypot
    sites and MITM (with tools such as SET, covered in [Chapter 3](000.html#)*, Stalking
    Prey Through Target Recon).* An example is shown in following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_10.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: Sample phishing lure, used to test employees. Every link in here is potentially
    tainted.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hyperlinks, graphics, anything interactive in the page or the e-mail can be
    a useful lure, and when attacking a specific person or team, your efforts on social
    media will have a huge impact on your success rate here.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Let's go Metasploiting
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A lot of the tools we've used in this book so far are focused on web applications
    and have proven quite handy in assessing the vulnerabilities that may exist in
    a website. One of the more general tools in use across all pen testing domains,
    Metasploit ([https://www.metasploit.com](https://www.metasploit.com)), actually
    offers some great value in testing against many of the top web app vulns, XSS
    included. Metasploit likely needs no introduction; chances are you are using it
    as a significant part of your workflow or methodology. That being said, it is
    a framework that incorporates a wide variety of extensible recon and scanning
    modules to populate a database of hosts and corresponding vulns. This database
    allows Metasploit to then pivot into the exploitation phase, where exploits can
    be launched actively or in some cases are bundled into a payload for file-based
    delivery. The community surrounding Metasploit is very active, and literally hundreds
    of plugins and modules have been crafted to make Metasploit everyone's favorite
    foundational pen test tool.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Building your own payload
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Working with BeEF or even within a standard web server facility on your device,
    you can use Metasploit's **meterpreter** capabilities to help you gain shell access
    to affected hosts. Meterpreter is a payload Metasploit can deliver into clients
    that work within the **Dynamically Linked Libraries** (**DLLs**) to establish
    a secure, covert channel for communications between the hacker and the target;
    it gives the hacker a Ruby-based shell to the target that can then be used to
    do the hacker's bidding. Why do we want this? In attacking web applications, lateral
    movement through their environment of clients can really help us gain a foothold,
    compromise trusted hosts, and find adjacent servers we can use to run complementary
    tasks, such as mail servers, domain controllers, and so on. A reflective XSS attack
    is a great way to deliver this script. Users are pretty wary of attachments these
    days (sure took them long enough!) ,so slipstreaming our hook files and payloads
    into an invisible script gives us a great means of gaining access to well-trained
    victim computers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we will create a payload, encode it so that it bypasses traditional
    security defenses, host it on a server under our control, and then craft a script
    around it for the XSS as seen in following screenshot. The same social engineering
    approaches will hold true here, but this gives us another means by which we can
    compromise the host. Browser control is nice, but shell access is even better!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_11-1.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: We can use Metasploit as our C2 head-end, even crafting custom payloads.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'We first start up the Metasploit Framework''s **msfconsole** and select our
    payload of choice, which in this case is the Meterpreter Reverse TCP payload.
    We can do this by entering the `use payload/windows/shell/reverse_tcp` command
    in the `msf` prompt. A **`quick show`** options will help us see what we can configure,
    as seen in the following screenshot.Â As with general exploits, we can see the
    payload''s options in following screenshot using `show options` and see the commands
    with `-h`Â to guide ourselves through the entire operation:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_12.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: Initial stages of payload creation â�� setting up options..
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 创建有效载荷的初始阶段-设置选项..
- en: 'Metasploit can produce different file formats for an exploit. It can also ensure
    certain bytes are not used (`x00` is a universally unacceptable one, so we''ll
    pull that out). The payload tool can also do the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit可以为攻击生成不同的文件格式。它还可以确保某些字节不被使用（`x00`是一个普遍不可接受的字节，所以我们会将其去掉）。有效载荷工具还可以执行以下操作：
- en: It can pad or append additional bytes (`-s` to add a NOP slide)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以填充或附加额外的字节（`-s`添加NOP滑块）
- en: It can use a different programming language other than the default Ruby (for
    exampleÂ `-t java` or `â��t c`)
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以使用除默认的Ruby之外的其他编程语言（例如`-t java`或`-t c`）
- en: It can apply encoders (show encoders to see them, `-e <encoder>` to change encoders)
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以应用编码器（显示编码器以查看它们，`-e <编码器>`更改编码器）
- en: It can iterate and encode over multiple passes (`-I <number of iterations>`)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以迭代并编码多次（`-I <迭代次数>`）
- en: All of these help Metasploit to hide and obscure the payload to evade typical
    signature-based, anti-virus programs with stunning success. Seeing how easy this
    is, one can understand why traditional antivirus products are unable to defend
    against these new, morphing threats.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都帮助Metasploit隐藏和模糊有效载荷，以成功逃避典型基于签名的反病毒程序。看到这是多么容易，人们就能理解为什么传统的防病毒产品无法抵御这些新的、变形的威胁。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Signature detection looks for specific characteristics in an attack. If you
    find your attack isn't working, attempt to encode it another way, and send it
    again. In many cases, adding enough padding, tweaks, or other manipulation will
    bypass detection, because now it looks like a new file. Other techniques include
    breaking up the file into smaller files or encryption.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 签名检测寻找攻击中的特定特征。如果发现您的攻击不起作用，请尝试以另一种方式对其进行编码，然后再次发送。在许多情况下，添加足够的填充、调整或其他操作将绕过检测，因为现在它看起来像一个新文件。其他技术包括将文件分成较小的文件或加密。
- en: There are a ton of options for us to modify and custom-craft our own payloads.
    For now, let's omit the `x00` byte, iterate 3 times, and export it into an executable
    file for our use as seen in the following screenshot.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多选项可以修改和定制我们自己的有效载荷。现在，让我们省略`x00`字节，迭代3次，并将其导出为一个可执行文件供我们使用，如下图所示。
- en: '![](img/B03918_06_13.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B03918_06_13.png)'
- en: Metasploit payload generation can customize code that will bypass anything with
    practice.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit有效载荷生成可以定制代码，可以练习绕过任何东西。
- en: On our desktop, we now have a shiny new **.exe** that will land on a Windows
    platform and execute. Now this is where social engineering comes into play, meaning
    we can name this executable file something the user expects to install and include
    it with a social engineering campaign. If we can convince a Windows user to install
    it, we will be granted a backdoor with root access to that system, assuming everything
    functions as expected. This concept can be useful for other attack examples presented
    later in this chapter, where our custom malware payload can strike.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的桌面上，现在有一个闪亮的新**.exe**，它将在Windows平台上运行并执行。现在社会工程学就派上用场了，这意味着我们可以将这个可执行文件命名为用户期望安装的内容，并将其包含在社会工程活动中。如果我们能说服Windows用户安装它，我们将获得对该系统的具有根访问权限的后门，假设一切都按预期运行。这个概念对于本章后面呈现的其他攻击示例可能会有用，我们的自定义恶意软件有效载荷可以发挥作用。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Our choice of delivery was purposely bland, depending on the restrictions in
    place on your intended targets, you may have to forgo the tidy executable approach
    and go for a more covert path, such as a Java or Python script that somehow avoids
    kicking off Windows **User Access Controls** (**UAC**) or other watchdogs that
    may be in place. I also made this all happen within the msfconsole view, which
    is where I tend to spend more time.Â  If you are finding that you fire up Metasploit
    purposely for the creation of the payload, you can opt to use **msfvenom**.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择交付方式故意平淡，取决于您打算的目标上的限制，您可能不得不放弃整洁的可执行方法，而选择更隐秘的路径，比如一个Java或Python脚本，以某种方式避免触发Windows**用户访问控制**（**UAC**）或其他可能存在的看门狗。我也在msfconsole视图中完成了所有这些操作，因为我倾向于在那里花更多的时间。如果您发现自己启动Metasploit是为了创建有效载荷，您可以选择使用**msfvenom**。
- en: Every good payload needs a handler
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 每个良好的有效载荷都需要一个处理程序
- en: 'Our payload, upon executing, needs to have something to talk to, in case it
    gets lonely or unruly. In Metasploit, that function is provided by a **handler**.
    We can simply create a handler for the type of payload we deliver, and in doing
    so, ensure that when we gain access to a system, we are there and able to take
    advantage of it when it happens. Handlers act as our **command and control** (**C2**
    or **C&C**) connection to the target, and present us with the shell environment
    that we can use to manipulate the target with impunity (as shown in following
    screenshot):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的有效载荷在执行时需要有东西可以交流，以防它感到孤独或难以控制。在Metasploit中，这个功能由**处理程序**提供。我们可以简单地为我们传递的有效载荷类型创建一个处理程序，这样做可以确保当我们访问系统时，我们在那里并且能够利用它。处理程序充当我们与目标的**命令和控制**（**C2**或**C&C**）连接，并为我们提供一个可以无限制地操纵目标的shell环境（如下图所示）：
- en: '![](img/B03918_06_14-1.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B03918_06_14-1.png)'
- en: Setting up the handler for our payload.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的有效载荷设置处理程序。
- en: With a quick `exploit` command, we are now running and ready to accept incoming
    traffic from our fresh victims. Now, the handler is ready and your target identified;
    these two kids should meet! Now, if only I had some way to get the user to trust
    my file.Â  Hmmmâ�¦
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过快速的`exploit`命令，我们现在正在运行并准备接受来自我们新受害者的流量。现在，处理程序已经准备好，您的目标已经确定；这两个孩子应该见面了！现在，如果我有办法让用户相信我的文件就好了。嗯...
- en: Seal the deal â�� Delivering shell access
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 敲定交易-提供shell访问
- en: Let's place our executable in a quick-and-dirty Apache web server's default
    folder on the Kali VM, and craft a script to send along to prospective targets
    to deliver a reflected XSS JavaScript that now points the victim's browser to
    download the executable.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将可执行文件放在Kali VM上一个快速而简单的Apache web服务器的默认文件夹中，并制作一个脚本发送给潜在目标，以传递一个反射的XSS JavaScript，现在将受害者的浏览器指向下载可执行文件。
- en: 'This is what it looks like:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When we drop this into a quick and dirty e-mail (to my Windows 7 VM with IE
    9), we can assume a better than 50% chance that the user will see the `updater.exe`
    filename, associate it with my trusted web application, and it will execute. Watching
    this unfold on our Kali terminal session, we get the wonderful news that they
    have met and are now in touch! Meterpreter now acts as a prompt for us, and a
    quick `dir` command shows us the contents of the running directory (as shown in
    following screenshot).Â  It is plain to see we're in a Windows machine's head
    now; but what can we do from here?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_15-1.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: Congratulations, we now have remote shell access!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Meterpreter is pretty powerful stuff; with this access, you can now manage
    this victim''s computer without their knowledge.Â  Here are just some of the things
    that can be useful in our web app pen test:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Dump hashes and manipulate or steal cookies
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Covertly or overtly use system webcams and microphones
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conduct keylogging
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upload, download, edit, delete, create, move, and search for files and directories
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kill or spawn processes, modify the registry, or shutdown/restart/hibernate
    the machine
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See network and proxy configurations and configure port forwarding
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View system and user info and escalate privileges
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All in all, this is some scary stuff, and it should be clearly recognized that
    web applications have a responsibility to ensure they do not put their users in
    this situation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Were we to run into newer browsers or more heavily defended hosts, this simple
    exe-based exploit would not likely go far. With some practiced use of the more
    advanced Metasploit capabilities, creative payloads, or even file-free exploits,
    these defensive measures can, and often are, circumvented.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Metasploit's web-focused cousin â�� Websploit
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Â Metasploit's scope for scanning and exploiting capabilities is staggering,
    and with the open extensions through plugins and modules, it's obtained a well-earned
    reputation for versatility and power. Sometimes, however, you are looking for
    a web application focus, and this is where a similar open-source framework called
    **Websploit** ([https://sourceforge.net/p/websploit/wiki/Home/](https://sourceforge.net/p/websploit/wiki/Home/))
    comes into play. Just like Metasploit, it offers a command-line focused approach
    to calling and loading modules. It also shares the extensibility through plugins
    and modules that has helped Metasploit stay at the forefront of pen testing tools,
    but instead of being an all-inclusive suite, it focuses on many of the vulnerabilities
    specific to our role as web penetration testers and ethical hackers.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of modules and plugins from their Wiki is a big giveaway as to its
    purpose:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '**Autopwn**: This is borrowed from Metasploit to scan and exploit target services/servers'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**wmap**: This can scan or crawl targets borrowed from Metasploit `wmap` plugin'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Format infector**: This injects reverse and BIND payloads into the file format'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phpmyadmin**: This searches the target `phpmyadmin` login page'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lfi**: This can scan and bypass local file inclusion vulns and bypass some
    WAFs'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apache users: This can search a server username directory (when used with Apache
    web servers)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dir Bruter**: Brute force target directory with wordlist'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Admin finder**: Search admin and login page of target'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MLITM attack**: Man left in the Middle, XSS phishing attacks'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MITM**: Man in the Middle attack'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java applet attack**: Java signed applet attack'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MFOD attack vector**: Middle Finger of Doom attack vector'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**USB infection attack**: Create executable backdoor for infecting USB for
    Windows'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ARP DOS**: ARP cache Denial of Service attack with random MAC'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web killer attack**: Down your website on network (TCPKILL)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fake update attack**: This canÂ create a fake update page for target OS'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fake access point attack**: This canÂ create fake AP and sniff victims''
    information'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As this chapter is all about XSS, the DOM-based **Man Left in the Middle** (**MLITM**)
    attack is the tool we are after, so let's take a look at how we leverage the module.
    You'll want to download the latest version, extract it from the tarball, and then
    use the install script.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Once we've got it installed, we can simply invoke the `websploit` command from
    a terminal session, and it'll start up Websploit. From here, we'll want to use
    network/mlitm. As modules go, you don't get simpler than the MLITMÂ tool.Â  There
    are no options to consider, as basically this module consists of a listening web
    server (similar to a handler) and a Python module (`thebiz.py`) that acts as a
    default payload.Â  You can certainly craft other payloads; but much like any XSS
    attack, our goal is to place a script in the user's path that they trust, and
    then use it to redirect their browser to our attacking server, where this payload
    can be installed from and information or action can be orchestrated.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: The script I used in this attack was pretty simple; we want to introduce the
    victim browser to our C2 server/attack box and allow the webserver, Websploit,
    which is running on a default port of `8000` for this purpose, to deliver the
    payload and establish our channel:Â
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We place this on the same blog entry field we''ve used before, and before you
    know it, we have an unlucky victim come along and use that link (as shown in the
    following screenshot):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_16-1.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: Script entry and appearance to victims â�� simple but effective.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: On our Kali box, we can see that we are delivering the payload and seeing the
    user's traffic through the referring link, as we are beginning to see in following
    screenshot. From here, you can feel free to experiment with payload alterations
    and achieving some of the control we've seen in other tools.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_17-1.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: Websploit offers a no-frills listening and payload delivery service.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Websploit is a strong tool in other areas of the attack chain, and it does well
    with blended attack modules such as AutoPwn, DoS, and its WiFi-focused attacks.
    For XSS, I find that Metasploit offers more versatility in managing payloads and
    offering shell options. In addition to Meterpreter, there are more than a dozen
    other shell options depending on what your targets can get away with and what
    mix of stealth and functionality is desired.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: XSS attacks have been a thorn in the side of security professionals and millions
    of victims since the explosion in dynamic content brought JavaScript into the
    forefront of web development. Coupled with an antiquated means of establishing
    trust (entity-based with no validation of input), this has made XSS an OWASP Top
    10 vulnerability for over 10 years. It is clear that something should be done
    to bring more attention to it, and it is the increased use of pen testing that
    can make the difference.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: The tools for XSS are many, and while we covered some of the more accessible
    tools Kali included here, it became obvious to me in preparing to write this chapter
    that the toolsets experienced some ebb and flow; some tools have fallen out of
    favor over time while others seem to keep on fighting.Â  Some of this might be
    attributed to corporate sponsorship â�� Rapid7 is a key player in maintaining
    and sponsoring Metasploit, while XSSer and Websploit have both been sporadically
    supported. I would encourage delving into each of these tools and others as much
    as you can to get a good feel for which ones should be in your tool chest.Â  It
    would be wise to have at least two tools for every role with different strengths
    and overlapping capabilities to help better cover-corner case scenarios.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered the types of XSS, their potential to do harm or
    help us in our pursuit of *pwnershipÂ *(hacker-speak for being able to compromise
    a site or target at will)*,*Â and some great ways to use them to gain visibility
    into clients and their relationships with their server. XSS, as we also saw, can
    provide real black-hat attackers with a sinister foothold that allows them to
    manipulate system resources and spy on their victims. Where XSS focuses on exploiting
    the client-server trusted relationship to compromise the client, our next chapter
    will discuss both client-side attacks as well as how we can take advantage of
    that same trusted relationship to either control or coerce the server itself.Â 
    These attacks are known broadly as injection attacks, and encompass some hot topics
    in the land of web application security such as HTML, SQL, XML, and even the oft-overlooked
    LDAP. At the conclusion of the next chapter, you will have a solid foundation
    of attacks to help find critical data leakage and host control vulns in the majority
    of applications and their clients. I'm glad you've stuck around this far, let'sÂ see
    what further damage we can cause or prevent!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
