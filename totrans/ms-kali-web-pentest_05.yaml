- en: Chapter 6. Infiltrating Sessions via Cross-Site Scripting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Web application hacking is in a class of its own. While network- and system-related
    hacking focuses on gaining persistent presence on those systems or otherwise modifying
    their state, web pen testing is focused on fooling the server, client, or both
    into doing the attacker's bidding. Sure, you can try to *pawn* those servers or
    compromise the client or browser, but if you can get all you want from the exchange
    without establishing a permanent residence, why not? Injection attacks, which
    make a lot of web developers very nervous, are like a Jedi Mind Trick for web
    applications. With a wave of your hand (not literally, it is really just some
    effort on a keyboard), you can convince the server, client, or both to act in
    a way they would not otherwise. This may be done to give up data (as is believed
    to have happened in the Impact Team's Ashley Madison hack) or to poison one or
    both sides with malicious scripts that defy the trust between client and server.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cross-site scripting** (it can be abbreviated **CSS** or **XSS**, but we''ll
    use the latter to avoid confusing this attack with **Cascading Style Sheets**)
    is something many of you have probably worked through in practice or tested for
    through automated tools, but it is a very deep topic that could justify its own
    book. As a subset of the broader term injection attacks, XSS focuses on using
    JavaScript where it shouldn''t be. Rather than broadly manipulating the hijacked
    requests and responses, XSS finds daylight in them to insert covert scripts that
    would otherwise be unable to land and execute. These scripts now appear trustworthy
    to our targets and their users because of the trust they have for each other,
    and we''ll use this trusted relationship against them.'
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of these scripts can vary greatly, but the many uses can include
    exposing cookies and session information, allowing for redirection and MITM attacks,
    hijacking one or both endpoints for other attacks, and even facilitating exfiltration
    of sensitive data. These traits make them extremely dangerous, and despite their
    high ranking in the OWASP Top 10 for the last few cycles, they continue to be
    a major issue.
  prefs: []
  type: TYPE_NORMAL
- en: XSS has many applications but in this chapter, we'll differentiate the types
    of XSS and provide some options onÂ how to best unleash them in your testing.
    While Burp and ZAP can provide some XSS exploits, it is helpful to understand
    how to craft our own and use other tools available in Kali to help deliver them.
    This chapter will discuss various forms of XSS and show other ways we can use
    this powerful attack form to compromise our targets.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Discussing various forms of XSS, how to detect vulnerabilities in them and exploit
    them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring how **stored** (also known asÂ **persistent**) XSS attacks work and
    how to take advantage of them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and testing for **reflected** XSS using social engineering techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing the capabilities of additional tools such as BeEF, XSSer, Websploit,
    and Metasploit and their ability to handle each form of XSS attack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The low-down on XSSÂ types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'XSS attacks are both common and dire; in the right places, they can be used
    to deliver malicious scripts, funnel traffic to an alternative redirect, or implant
    faulty data. Efforts to categorize them have added to the confusion for some of
    us. The earliest categorization focused on its persistence (or lack thereof),
    but over time, the industry has focused on the affected host: a web server or
    browsing client. OWASP has done a great job of redefining these types to help
    us (pen testers) choose the best detection methods and exploitation tools for
    each. The common thread that ties them together is that they all involve user
    input being relayed by a server without proper validation, and these attacks always
    execute in the browser, regardless of the delivery method. Let''s review the latest
    categorization, so we''re ready to use them effectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Should XSS stay or should it go?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'XSS attacks, regardless of where they take place, can be either stored or reflective.
    Both can range from annoying to gravely serious, depending on the intent and the
    impacted session''s context:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Stored XSS attacks (persistent) are quite common where data from an attacker
    masquerading as a legitimate user is not properly screened before being presented
    to other users. This code will persist, continuing to impact users until it is
    detected, the data purged, or precautions implemented on the web service to ensure
    that responses containing the code are properly validated. In effect, the code
    is stored in the server itself, as shownÂ here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B03918_06_01-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Stored XSS will attack any client viewing the requested page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reflective XSS attacks (also called non-persisentent) are more varied, in that
    they can be initiated through phishing campaigns, social engineering, MITM attacks,
    or some other diversion. Unwitting users initiate the attack by clicking on a
    malicious link with the script in it. The attacker crafts their scripts such that
    they are returned or reflected within the error or search response of the web
    server under attack. Because the attacker convinced a user to click on a link
    that embedded a script, they knewÂ it would be reflected in a response; the poor
    client browser will now trust that script as if it originated at the server itself.
    In actuality, the victim''s browser originated the request, as seen in the following
    screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B03918_06_02-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Reflective, or Non-Persistent XSS tends to be more focused on a group of users.
  prefs: []
  type: TYPE_NORMAL
- en: Location, location, and location!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second means by which we can differentiate XSS types is by the location.
    The detection methods and defensive countermeasures can vary greatly based on
    which end of the connection was attacked: the client or server:'
  prefs: []
  type: TYPE_NORMAL
- en: Server XSS attacks can happen when a server is guilty of delivering malicious
    content as a part of its responses to client requests, because it was not adequately
    filtered or validated when it was originally input by another client, usually
    the attacking host. These attacks can be difficult for the client because the
    server bundles the attack with its HTML, and the client's browser is unable to
    differentiate the modified behavior of the server and therefore renders it faithfully,
    trusting both the intended and the plantedÂ nefarious code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client XSS attacks, on the other hand, focus on the malicious code or modification
    being delivered inside the client's own facilities. The most popular form of these
    by far is the DOM-based XSS, which targets the page's state machine in the browser.
    Most of the time, when we talk about client-side XSS, we are referring to **DOM-based
    XSS**. DOM-based XSS attacks are a subset of the client XSS, and they take advantage
    of dynamic web application design. In most modern web applications, a browser,
    upon visiting a site, will build a **Document Object Model** (**DOM**) that can
    parse the HTML into objects in a tree. This parsing allows a scripting language
    (most of the time, we talk about JavaScript here, but other web content such as
    HTML, ActiveX, and Flash applies) to modify the contents of the HTML representing
    the tree dynamically. DOM-based XSS attacks are especially troubling in that the
    server may never see anything overtly bad in the script. Instead, the server unwittingly
    aids the attacker by referring to a variable local to the victim, not having the
    slightest clue that the variable is something bad (like a redirect, hook file,
    and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It should be noted that both server and client-side XSS attacks can be either
    Stored or Reflective attacks. Most of the tools worth carrying in your bag, as
    they say, should be able to assist with scanning and exploiting most varieties.
  prefs: []
  type: TYPE_NORMAL
- en: XSS targeting and the delivery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As dire a threat as XSS presents to a web application and its users, it is shockingly
    easy to implement. Delivered in most cases through a browser or e-mail, all the
    attacker needs is a working knowledge of HTML and JavaScript and a target web
    server susceptible to this form of attack. Using these skills, the hacker can
    choose how big a net they are willing to cast. We must be wary of all forms of
    injection attacks, XSS included, as they can all wreak havoc on an application
    long before incident response can begin to remediate these issues.
  prefs: []
  type: TYPE_NORMAL
- en: With stored XSS, hackers cast a big net and impact a large number of users with
    their malicious script.Â  This is wonderful if the potential users of the application
    are predominantly in scope, and the attack is more straightforward becauseÂ no
    social engineering is required to seed the script. That being said, it is for
    these reasons that stored XSS must be used sparingly. There is no choice about
    which victims will report in, and thus more overhead is required on the attacker's
    part to discriminate between in- and out-of-scope victims. The wider potential
    audience also calls into question the fit for an ethical hack, as the potential
    for capturing data from collaterally damaged hosts is extremely high, and the
    customer will likely have concerns that need to be addressed. This makes the stored
    or persistent XSS attack very harmful to many people.
  prefs: []
  type: TYPE_NORMAL
- en: Reflective XSS is well worth the effort upfront, as the phishing campaign, tainted
    link, or other means of delivery is more precise, and thus limits collateral damage.Â 
    This also enables the hacker or tester to focus on the impacted set of targets
    and virtually guarantees that the collected data is collected from users of interest.
    While the potential damage to a victim is commensurate with the stored XSS attack,
    the victim or victims are intended, so this makes it safer and worth the effort.
  prefs: []
  type: TYPE_NORMAL
- en: Seeing is believing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: When reporting to a customer on the presence of a web application's vulnerabilities,
    most test reports will show scans that identify just theÂ possibility a vulnerability
    exists (identification) but also go a step further and actually demonstrate that
    an exploit of the vulnerability was successful (confirmation). Arachni, ZAP, Burp
    Suite, and other vulnerability assessment tools can help with the identification
    effort. Some of these tools can assist with confirmation, but most testers will
    confirm using independent XSS-focused tools or methods to mimic the behavior of
    the exploit when employed by hackers. A quick search of your favorite search engine
    will see that there are some leading candidates, but we'll talk about the most
    popularly discussed ones, and then look at how the stalwarts can enable us to
    put our targets through their paces.
  prefs: []
  type: TYPE_NORMAL
- en: Don't run with XSSer(s)!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the quickest and to-the-point tools available in Kali for XSS testing
    isÂ **XSSer** (sometimes pronounced *scissor*). As a tool, XSSer serves one function,
    which is to test for the presence of potential XSS vulnerabilities on a web application
    and offer up quick, non-controversial validation URL strings to run a check against
    them. XSSer is one of those rare tools that can give you awesome capability with
    minimal know-how; but with an experienced hand, it can be tailored with surgical
    precision.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use XSSer either as a CLI tool or with its GUI wrapper, which is a
    fine way to build CLI queries with the help of a more intuitive wrapper. To use
    XSSer in the GUI mode, you can simply type the following in a terminal session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: XSSer is a fine tool for running mundane alert-based test scripts against websites
    to determine their susceptibility. That being said, I find that XSSer suffers
    from neglect since its last published version was posted in 2013, four years prior
    to the writing of this text and a few revisions of Metasploit past.Â  In fact,
    the latest version was more applicable to Backtrack, but still provides a useful
    wizard and some educational value. Against specific targets, however, I find that
    it is both buggy and limited in application when compared to more current tools.
    It is worth a look, but I would recommend concentrating on some more fully-featured
    tools, such as BeEF and Metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: Stored XSS with BeEF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Browser Exploitation Framework** (**BeEF**, available at [http://beefproject.com](http://beefproject.com/))
    is a tool we took a look at in *Penetration Testing with the Raspberry Pi, Second
    EditionÂ *([https://www.packtpub.com/networking-and-servers/penetration-testing-raspberry-pi-second-edition](https://www.packtpub.com/networking-and-servers/penetration-testing-raspberry-pi-second-edition))*,Â *where
    we discussed its general use as a honeypot or malicious web server. These same
    capabilities make BeEF a fantastic tool for the delivery and subsequent management
    of a variety of XSS attacks. What makes BeEF powerful is that it leverages a single
    hook script in internet browsers for its attack, and because of the XSS vulnerability
    in the web server, it can evade most controls employed by more paranoid or better
    trained victims. Short of blocking various HTML data types completely, a perfectly
    configured client can still be run because of the trusted relationship exploited
    by the attacker.
  prefs: []
  type: TYPE_NORMAL
- en: BeEF, after hooking the victim, is capable of assessing the inherent vulnerabilities
    of the browser and operating system combination. Based on these findings, BeEF
    offers a range of command modules that can be launched, such as taking screenshots,
    scraping credentials or exfiltrating cookies, or even triggering a beep sound.
    Hooked systems can only be accessed while they are online. However, once hooked,
    BeEF can track when a system establishes internet connectivity to continue launching
    commands against that system. Pretty slick, and very scary!
  prefs: []
  type: TYPE_NORMAL
- en: 'To show this in action and help understand the power of a Stored XSS attack,
    we''ll use the BeEF hook script and point the client to our Kali machine''s BeEF
    instance. The following screenshot shows our test scenario, where the following
    are configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attacker''s machine**: Kali VM is running a BeEF server, listening on all
    interfaces (172.16.30.128 is the external IP address)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web Server/Application**: OWASP BWA VM, specifically the Mutillidae web application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**:Â Windows 7 VM running Internet Explorer 10 (evaluation copy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The attacker can remotely execute command modules from the Kali/BeEF control
    headend while the hooked victim continues to use the internet, typically oblivious
    to the compromise. In an actual attack or a black-box attack as seen in the following
    screenshot, the hacker will more often than not deploy a cloud or otherwise temporary
    instance of Kali or a similar machine and masquerade it behind several layers
    of obfuscation (VPN, TOR, proxy, and so on) to act as the attacking machine and
    make attribution or detection harder on the target server. Regardless of the attacking
    machine's location, in a stored XSS, the vulnerable server will continue to help
    us hook our prey.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_03-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Our Stored XSS scenario with BeEF
  prefs: []
  type: TYPE_NORMAL
- en: 'We can first launch BeEF-XSS from the GUI applications menu, the **`Favorites`**Â bar,
    or from the CLI by navigating to the BeEF directory (`cd /usr/share/beef-xss`)
    and then running the `beef` script using `./beef`. As it starts up, the **`Terminal`**
    session will show us the general URL for the user interface (`UI URL`Â in red)
    and the script we''ll want to use to hook our prey (`Hook`, in blue), as seen
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_04-1.png)'
  prefs: []
  type: TYPE_IMG
- en: BeEF's Startup process tells us how to manage the instance and how to hook the
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'BeEF will automatically launch a browser session that you can log in to using
    the username and password of *beef*. When it is first fired up, the online and
    offline Browsers lists will be empty. We''ll open a new tab and visit the *Mutillidae
    Web Application* as a visiting attacker, where we can enter our hook script in
    a field sure to be seen by the poor victims (**`OWASP 2013`**Â |Â **`A3 - Cross
    Site Scripting (XSS)`**Â |Â **`Persistent (Second Order)`**Â |Â **`Add to your
    blog`**), as seenÂ here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_05-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Mutillidae offers some mock-forms we can use for Stored XSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be presented with a blog entry form, in which we can drop our hook script
    (`<script src="img/hook.js"></script>`), and then click the **`Save Blog Entry`**
    button (as shown in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_06.png)'
  prefs: []
  type: TYPE_IMG
- en: Planting our hook script on the web app's blog feature.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, let's switch hats and open up our poor, unsuspecting Windows 7 VM running
    IE 10! On the windows VM, we'll visit the blog as an observer â�� nothing crazy
    here. Just follow the path of **`OWASP 2013`**Â |Â **`A3 - Cross Site Scripting
    (XSS)`**Â |Â **`Persistent (Second Order)`**Â |Â **`View someone's blog`**Â as
    we see in the figure following, we'll want to see the inputs of all users. The
    page will show us all of the entries, including our anonymous user's input containing
    the script. We know that the blog pages are vulnerable because we saw it identifiedÂ inÂ [Chapter
    5](000.html#), *Proxy Operations with OWASP ZAP and Burp Suite*,Â testing as potentially
    possessing an XSS script vulnerability (as shown in figure following). Here we
    know that the server is not validating the contents of these entries before parroting
    them back in responses from subsequent victims.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_07.png)'
  prefs: []
  type: TYPE_IMG
- en: Browsing to the affected blog from the victim site.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've navigated to the blog view (as shown in figure following), we'll
    see a blank space where the anonymous user apparently entered nothing. At this
    point, they have no reason to believe they have been hacked or were exposed to
    a malicious XSS attack.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_08-1.png)'
  prefs: []
  type: TYPE_IMG
- en: All that wasted potential (script hidden) in an otherwise awesome blog.
  prefs: []
  type: TYPE_NORMAL
- en: Our Kali box knows otherwise; looking at the control UI for our BeEF-XSS framework,
    we can see that the Windows 7 box running IE 10 has checked in and is reporting
    for duty. Because browsers are so helpful in announcing what they can and cannot
    support, BeEF has a pretty good idea as to what hacks and tricks we can accomplish
    with the victim we've just hooked, and in following screenshot, we see that I
    have searched for *cookie*-related commands, selected **`Get Cookie`**Â from the
    **`Browser`**Â | **`Hooked Domain`** part of the **`Module Tree`**, and run it
    to obtain a session cookie being used between the victim's browser and the Mutillidae
    web server. Other useful attacks that we can use, outside just proving that an
    XSS vulnerability exists, are those that can help us grab social media login statuses,
    installed software, browsing history, and anything else that can help us better
    characterize the target environment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_09.png)'
  prefs: []
  type: TYPE_IMG
- en: Almost 200 Modules come with BeEF to help us turn browsers into extensions of
    us!
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind, we came here to pen-test the web application, not the users and
    the entire environment.Â  Unless you also have a red team sort of charter, steer
    clear of pulling anything outside any web-application-specific data.
  prefs: []
  type: TYPE_NORMAL
- en: Here, phishy phishy!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A reflected XSS attack follows a similar story, except that the user is employed
    to help hack themselves by tricking them to pass along the script. The phishing
    or link placement by the attacker replaces the form-based exploit and does require
    some work. **Phishing** involves sending a *lure*Â e-mail or web page to potential
    targets in the hope that they will believe their intent and click on one of the
    malicious links embedded within it. Phishing can often be used in other attacks
    (a simple redirect to a phishing site is still quite popular), but combining the
    targeted spamming with a redirect using a legitimate site, but a malicious script,
    can be downright nasty. That being said, let's discuss some of what attackers
    and we pen testers need to consider.
  prefs: []
  type: TYPE_NORMAL
- en: Building a target list can be labor-intensive; in fact, target lists are a popular
    service offering on dark-web hacking sites. In pen testing, OSINT and social engineering
    using tools such as your browser, Maltego, or social media can save the day, allowing
    us to leverage the information gathered to help us assess who it is we are after.
    In our testing, IT personnel, so called *C-suite* executives (especially the **Chief
    Information Officer** (**CIO**), **Chief Information Security Officer** (**CISO**),
    and any other technology-related positions), and any other people associated with
    security, operations, architecture, or application development at the site should
    be considered.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Large-scale hacks like that conducted by Russian hackers against [https://in.yahoo.com/?p=us](https://in.yahoo.com/?p=us)Â in
    2014 ([https://www.justice.gov/opa/press-release/file/948201/download](https://www.justice.gov/opa/press-release/file/948201/download))
    often begin with a smaller-focus phishing campaign against known employees and
    a credible reason for them receiving the e-mail. In this case, the information
    was used to help forge cookies and steal access to over 500 million accounts.Â 
    This was no fun for many of us.
  prefs: []
  type: TYPE_NORMAL
- en: Attackers will then need a willing mail relay or server to allow a mass mailing
    of the lure to their intended targets. There are services for hire that the bad
    guys will use (for example, notorious spam houses such as Send-Safe), or they
    may instead choose to deploy spambots on legitimate infrastructure or, worse yet,
    compromise a web server, and turn it into a PHP-based e-mail server or gateway.
    This last method is especially nefarious, because if they are able to compromise
    the target corporation's webmail service, they can operate as if they were completely
    legitimate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just need the bait! A phishing-based delivery of the link helps limit
    unwanted target acquisition and is easier to pass off without attribution and
    collateral damage than other methods of enticing Reflected XSS, such as honeypot
    sites and MITM (with tools such as SET, covered in [Chapter 3](000.html#)*, Stalking
    Prey Through Target Recon).* An example is shown in following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_10.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample phishing lure, used to test employees. Every link in here is potentially
    tainted.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hyperlinks, graphics, anything interactive in the page or the e-mail can be
    a useful lure, and when attacking a specific person or team, your efforts on social
    media will have a huge impact on your success rate here.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go Metasploiting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A lot of the tools we've used in this book so far are focused on web applications
    and have proven quite handy in assessing the vulnerabilities that may exist in
    a website. One of the more general tools in use across all pen testing domains,
    Metasploit ([https://www.metasploit.com](https://www.metasploit.com)), actually
    offers some great value in testing against many of the top web app vulns, XSS
    included. Metasploit likely needs no introduction; chances are you are using it
    as a significant part of your workflow or methodology. That being said, it is
    a framework that incorporates a wide variety of extensible recon and scanning
    modules to populate a database of hosts and corresponding vulns. This database
    allows Metasploit to then pivot into the exploitation phase, where exploits can
    be launched actively or in some cases are bundled into a payload for file-based
    delivery. The community surrounding Metasploit is very active, and literally hundreds
    of plugins and modules have been crafted to make Metasploit everyone's favorite
    foundational pen test tool.
  prefs: []
  type: TYPE_NORMAL
- en: Building your own payload
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Working with BeEF or even within a standard web server facility on your device,
    you can use Metasploit's **meterpreter** capabilities to help you gain shell access
    to affected hosts. Meterpreter is a payload Metasploit can deliver into clients
    that work within the **Dynamically Linked Libraries** (**DLLs**) to establish
    a secure, covert channel for communications between the hacker and the target;
    it gives the hacker a Ruby-based shell to the target that can then be used to
    do the hacker's bidding. Why do we want this? In attacking web applications, lateral
    movement through their environment of clients can really help us gain a foothold,
    compromise trusted hosts, and find adjacent servers we can use to run complementary
    tasks, such as mail servers, domain controllers, and so on. A reflective XSS attack
    is a great way to deliver this script. Users are pretty wary of attachments these
    days (sure took them long enough!) ,so slipstreaming our hook files and payloads
    into an invisible script gives us a great means of gaining access to well-trained
    victim computers.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we will create a payload, encode it so that it bypasses traditional
    security defenses, host it on a server under our control, and then craft a script
    around it for the XSS as seen in following screenshot. The same social engineering
    approaches will hold true here, but this gives us another means by which we can
    compromise the host. Browser control is nice, but shell access is even better!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_11-1.png)'
  prefs: []
  type: TYPE_IMG
- en: We can use Metasploit as our C2 head-end, even crafting custom payloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first start up the Metasploit Framework''s **msfconsole** and select our
    payload of choice, which in this case is the Meterpreter Reverse TCP payload.
    We can do this by entering the `use payload/windows/shell/reverse_tcp` command
    in the `msf` prompt. A **`quick show`** options will help us see what we can configure,
    as seen in the following screenshot.Â As with general exploits, we can see the
    payload''s options in following screenshot using `show options` and see the commands
    with `-h`Â to guide ourselves through the entire operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_12.png)'
  prefs: []
  type: TYPE_IMG
- en: Initial stages of payload creation â�� setting up options..
  prefs: []
  type: TYPE_NORMAL
- en: 'Metasploit can produce different file formats for an exploit. It can also ensure
    certain bytes are not used (`x00` is a universally unacceptable one, so we''ll
    pull that out). The payload tool can also do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It can pad or append additional bytes (`-s` to add a NOP slide)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can use a different programming language other than the default Ruby (for
    exampleÂ `-t java` or `â��t c`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can apply encoders (show encoders to see them, `-e <encoder>` to change encoders)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can iterate and encode over multiple passes (`-I <number of iterations>`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these help Metasploit to hide and obscure the payload to evade typical
    signature-based, anti-virus programs with stunning success. Seeing how easy this
    is, one can understand why traditional antivirus products are unable to defend
    against these new, morphing threats.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Signature detection looks for specific characteristics in an attack. If you
    find your attack isn't working, attempt to encode it another way, and send it
    again. In many cases, adding enough padding, tweaks, or other manipulation will
    bypass detection, because now it looks like a new file. Other techniques include
    breaking up the file into smaller files or encryption.
  prefs: []
  type: TYPE_NORMAL
- en: There are a ton of options for us to modify and custom-craft our own payloads.
    For now, let's omit the `x00` byte, iterate 3 times, and export it into an executable
    file for our use as seen in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_13.png)'
  prefs: []
  type: TYPE_IMG
- en: Metasploit payload generation can customize code that will bypass anything with
    practice.
  prefs: []
  type: TYPE_NORMAL
- en: On our desktop, we now have a shiny new **.exe** that will land on a Windows
    platform and execute. Now this is where social engineering comes into play, meaning
    we can name this executable file something the user expects to install and include
    it with a social engineering campaign. If we can convince a Windows user to install
    it, we will be granted a backdoor with root access to that system, assuming everything
    functions as expected. This concept can be useful for other attack examples presented
    later in this chapter, where our custom malware payload can strike.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our choice of delivery was purposely bland, depending on the restrictions in
    place on your intended targets, you may have to forgo the tidy executable approach
    and go for a more covert path, such as a Java or Python script that somehow avoids
    kicking off Windows **User Access Controls** (**UAC**) or other watchdogs that
    may be in place. I also made this all happen within the msfconsole view, which
    is where I tend to spend more time.Â  If you are finding that you fire up Metasploit
    purposely for the creation of the payload, you can opt to use **msfvenom**.
  prefs: []
  type: TYPE_NORMAL
- en: Every good payload needs a handler
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our payload, upon executing, needs to have something to talk to, in case it
    gets lonely or unruly. In Metasploit, that function is provided by a **handler**.
    We can simply create a handler for the type of payload we deliver, and in doing
    so, ensure that when we gain access to a system, we are there and able to take
    advantage of it when it happens. Handlers act as our **command and control** (**C2**
    or **C&C**) connection to the target, and present us with the shell environment
    that we can use to manipulate the target with impunity (as shown in following
    screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_14-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting up the handler for our payload.
  prefs: []
  type: TYPE_NORMAL
- en: With a quick `exploit` command, we are now running and ready to accept incoming
    traffic from our fresh victims. Now, the handler is ready and your target identified;
    these two kids should meet! Now, if only I had some way to get the user to trust
    my file.Â  Hmmmâ�¦
  prefs: []
  type: TYPE_NORMAL
- en: Seal the deal â�� Delivering shell access
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's place our executable in a quick-and-dirty Apache web server's default
    folder on the Kali VM, and craft a script to send along to prospective targets
    to deliver a reflected XSS JavaScript that now points the victim's browser to
    download the executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When we drop this into a quick and dirty e-mail (to my Windows 7 VM with IE
    9), we can assume a better than 50% chance that the user will see the `updater.exe`
    filename, associate it with my trusted web application, and it will execute. Watching
    this unfold on our Kali terminal session, we get the wonderful news that they
    have met and are now in touch! Meterpreter now acts as a prompt for us, and a
    quick `dir` command shows us the contents of the running directory (as shown in
    following screenshot).Â  It is plain to see we're in a Windows machine's head
    now; but what can we do from here?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_15-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations, we now have remote shell access!
  prefs: []
  type: TYPE_NORMAL
- en: 'Meterpreter is pretty powerful stuff; with this access, you can now manage
    this victim''s computer without their knowledge.Â  Here are just some of the things
    that can be useful in our web app pen test:'
  prefs: []
  type: TYPE_NORMAL
- en: Dump hashes and manipulate or steal cookies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Covertly or overtly use system webcams and microphones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conduct keylogging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upload, download, edit, delete, create, move, and search for files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kill or spawn processes, modify the registry, or shutdown/restart/hibernate
    the machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See network and proxy configurations and configure port forwarding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View system and user info and escalate privileges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All in all, this is some scary stuff, and it should be clearly recognized that
    web applications have a responsibility to ensure they do not put their users in
    this situation.
  prefs: []
  type: TYPE_NORMAL
- en: Were we to run into newer browsers or more heavily defended hosts, this simple
    exe-based exploit would not likely go far. With some practiced use of the more
    advanced Metasploit capabilities, creative payloads, or even file-free exploits,
    these defensive measures can, and often are, circumvented.
  prefs: []
  type: TYPE_NORMAL
- en: Metasploit's web-focused cousin â�� Websploit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Â Metasploit's scope for scanning and exploiting capabilities is staggering,
    and with the open extensions through plugins and modules, it's obtained a well-earned
    reputation for versatility and power. Sometimes, however, you are looking for
    a web application focus, and this is where a similar open-source framework called
    **Websploit** ([https://sourceforge.net/p/websploit/wiki/Home/](https://sourceforge.net/p/websploit/wiki/Home/))
    comes into play. Just like Metasploit, it offers a command-line focused approach
    to calling and loading modules. It also shares the extensibility through plugins
    and modules that has helped Metasploit stay at the forefront of pen testing tools,
    but instead of being an all-inclusive suite, it focuses on many of the vulnerabilities
    specific to our role as web penetration testers and ethical hackers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of modules and plugins from their Wiki is a big giveaway as to its
    purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Autopwn**: This is borrowed from Metasploit to scan and exploit target services/servers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**wmap**: This can scan or crawl targets borrowed from Metasploit `wmap` plugin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Format infector**: This injects reverse and BIND payloads into the file format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phpmyadmin**: This searches the target `phpmyadmin` login page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lfi**: This can scan and bypass local file inclusion vulns and bypass some
    WAFs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apache users: This can search a server username directory (when used with Apache
    web servers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dir Bruter**: Brute force target directory with wordlist'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Admin finder**: Search admin and login page of target'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MLITM attack**: Man left in the Middle, XSS phishing attacks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MITM**: Man in the Middle attack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java applet attack**: Java signed applet attack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MFOD attack vector**: Middle Finger of Doom attack vector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**USB infection attack**: Create executable backdoor for infecting USB for
    Windows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ARP DOS**: ARP cache Denial of Service attack with random MAC'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web killer attack**: Down your website on network (TCPKILL)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fake update attack**: This canÂ create a fake update page for target OS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fake access point attack**: This canÂ create fake AP and sniff victims''
    information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As this chapter is all about XSS, the DOM-based **Man Left in the Middle** (**MLITM**)
    attack is the tool we are after, so let's take a look at how we leverage the module.
    You'll want to download the latest version, extract it from the tarball, and then
    use the install script.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've got it installed, we can simply invoke the `websploit` command from
    a terminal session, and it'll start up Websploit. From here, we'll want to use
    network/mlitm. As modules go, you don't get simpler than the MLITMÂ tool.Â  There
    are no options to consider, as basically this module consists of a listening web
    server (similar to a handler) and a Python module (`thebiz.py`) that acts as a
    default payload.Â  You can certainly craft other payloads; but much like any XSS
    attack, our goal is to place a script in the user's path that they trust, and
    then use it to redirect their browser to our attacking server, where this payload
    can be installed from and information or action can be orchestrated.
  prefs: []
  type: TYPE_NORMAL
- en: The script I used in this attack was pretty simple; we want to introduce the
    victim browser to our C2 server/attack box and allow the webserver, Websploit,
    which is running on a default port of `8000` for this purpose, to deliver the
    payload and establish our channel:Â
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We place this on the same blog entry field we''ve used before, and before you
    know it, we have an unlucky victim come along and use that link (as shown in the
    following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_16-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Script entry and appearance to victims â�� simple but effective.
  prefs: []
  type: TYPE_NORMAL
- en: On our Kali box, we can see that we are delivering the payload and seeing the
    user's traffic through the referring link, as we are beginning to see in following
    screenshot. From here, you can feel free to experiment with payload alterations
    and achieving some of the control we've seen in other tools.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_06_17-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Websploit offers a no-frills listening and payload delivery service.
  prefs: []
  type: TYPE_NORMAL
- en: Websploit is a strong tool in other areas of the attack chain, and it does well
    with blended attack modules such as AutoPwn, DoS, and its WiFi-focused attacks.
    For XSS, I find that Metasploit offers more versatility in managing payloads and
    offering shell options. In addition to Meterpreter, there are more than a dozen
    other shell options depending on what your targets can get away with and what
    mix of stealth and functionality is desired.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: XSS attacks have been a thorn in the side of security professionals and millions
    of victims since the explosion in dynamic content brought JavaScript into the
    forefront of web development. Coupled with an antiquated means of establishing
    trust (entity-based with no validation of input), this has made XSS an OWASP Top
    10 vulnerability for over 10 years. It is clear that something should be done
    to bring more attention to it, and it is the increased use of pen testing that
    can make the difference.
  prefs: []
  type: TYPE_NORMAL
- en: The tools for XSS are many, and while we covered some of the more accessible
    tools Kali included here, it became obvious to me in preparing to write this chapter
    that the toolsets experienced some ebb and flow; some tools have fallen out of
    favor over time while others seem to keep on fighting.Â  Some of this might be
    attributed to corporate sponsorship â�� Rapid7 is a key player in maintaining
    and sponsoring Metasploit, while XSSer and Websploit have both been sporadically
    supported. I would encourage delving into each of these tools and others as much
    as you can to get a good feel for which ones should be in your tool chest.Â  It
    would be wise to have at least two tools for every role with different strengths
    and overlapping capabilities to help better cover-corner case scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered the types of XSS, their potential to do harm or
    help us in our pursuit of *pwnershipÂ *(hacker-speak for being able to compromise
    a site or target at will)*,*Â and some great ways to use them to gain visibility
    into clients and their relationships with their server. XSS, as we also saw, can
    provide real black-hat attackers with a sinister foothold that allows them to
    manipulate system resources and spy on their victims. Where XSS focuses on exploiting
    the client-server trusted relationship to compromise the client, our next chapter
    will discuss both client-side attacks as well as how we can take advantage of
    that same trusted relationship to either control or coerce the server itself.Â 
    These attacks are known broadly as injection attacks, and encompass some hot topics
    in the land of web application security such as HTML, SQL, XML, and even the oft-overlooked
    LDAP. At the conclusion of the next chapter, you will have a solid foundation
    of attacks to help find critical data leakage and host control vulns in the majority
    of applications and their clients. I'm glad you've stuck around this far, let'sÂ see
    what further damage we can cause or prevent!
  prefs: []
  type: TYPE_NORMAL
