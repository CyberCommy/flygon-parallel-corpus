- en: Chapter 11. Testing the User Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 10](part0068.xhtml#aid-20R681 "Chapter 10. Adding Real-time Chat"),
    *Adding Real-time Chat*, we extended our social network by adding a real-time
    chat function. We used WebSockets and Socket.IO in particular to implement the
    communication between the users in our system. The last chapter of this book is
    dedicated to user interface testing. We will explore two popular tools to run
    headless browser testing. This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the basic testing toolset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing our project to run tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running our tests with PhantomJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the user's registration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with DalekJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the basic testing toolset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before writing the tests, we will spend some time talking about the testing
    toolset. We need some instruments to define and run our tests.
  prefs: []
  type: TYPE_NORMAL
- en: The testing framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the context of JavaScript, the testing framework is a set of functions that
    help you organize the tests into logical groups. There are framework functions
    such as `suite`, `describe`, `test`, or `it` that define the structure of our
    suite. Here is a short example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We used the `describe` function to wrap the more detailed tests (`it`) into
    a group. Organizing the group in such a way helps us keep focus and at the same
    time, it is quite informative.
  prefs: []
  type: TYPE_NORMAL
- en: Some popular testing frameworks in the JavaScript community are **QUnit**, **Jasmine**,
    and **Mocha**.
  prefs: []
  type: TYPE_NORMAL
- en: The assertion library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we usually do while testing is run an assertion. We very often compare
    the values of variables to check whether they match with what we expected when
    we originally wrote the program's logic. Some testing frameworks come with their
    own assertion library, some don't.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line shows a simple usage of such a library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is important to mention that the APIs are designed like this so that we understand
    the context by reading the test.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js even has its own built-in library called `assert`. Some of the other
    options are **Chai**, **Expect**, and **Should.js**.
  prefs: []
  type: TYPE_NORMAL
- en: Runner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The runner is a tool that we use to execute the test in a specific context,
    which is very often a specific browser, but it may also be a different operating
    system or customized environment. We may or may not need a runner. In this particular
    chapter, we will use DalekJS as the test runner.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing our project to run tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we know what tools we need to run our tests. The next step is to prepare
    our project to place such tests. Normally during development, we test our application
    by visiting the pages and interacting with them. We know the result of these actions
    and we verify if everything is okay. We want to do the same thing with automated
    tests. However, instead of us repeating the same steps again and again, there
    will be a script.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make these scripts work, we have to put them in the right context.
    In other words, they should be executed in the context of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we mentioned Chai (an assertion library) and Mocha
    (a testing framework). They play well together. So, we will add them to our list
    of dependencies, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A quick run of `npm install` will set up the modules in the `node_modules` directory.
    Chai and Mocha are distributed as Node.js modules, but we may use them in the
    browser environment, too. The newly created folders in `node_modules` contain
    compiled versions. For example, to run Mocha in the browser, we have to include
    `node_modules/mocha/mocha.js` in our page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our social network is a single-page application. We have a main HTML template
    that is served by the backend, which is located in `backend/tpl/page.html`. The
    Node.js server reads this file and sends it to the browser. The rest is handled
    by the JavaScript code. Here is how `page.html` looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The file contains all the external resources needed to run the application.
    However, now we need to add a few more tags; some of them are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `/node_modules/mocha/mocha.css` file contains styles for the proper display
    of the results of the tests. This is a part of Mocha's reporters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/node_modules/mocha/mocha.js` file is the testing framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/node_modules/chai/chai.js` file is the assertion library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/tests/spec.js` is a file that contains the actual test. It still does
    not exist. We will create a `tests` directory and a `spec.js` file inside it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An empty `div` tag acts as a placeholder for the test results and a few lines
    of JavaScript bootstrap the Mocha framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can''t add all these new elements in the current `page.html` file, because
    the users of the system will see them. We will place them in another file and
    tweak the backend so that it serves it under specific conditions. Let''s create
    `backend/tpl/pageTest.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once `mocha.js` and `chai.js` are injected in the page, we will configure the
    framework. Our user interface will follow behavior-driven development and the
    reporter will be `html`. Mocha has several types of reporters, and since we wanted
    to display the results in a browser, we used this one. We defined an `expect`
    global object that played the role of an assertion tool.
  prefs: []
  type: TYPE_NORMAL
- en: The lines after that will come in handy in the next section where we will run
    our test with PhantomJS. These lines will basically check whether there is a `window.mochaPhantomJS`
    object, and if there is, it will be used instead of the default `mocha`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, so good. We have instruments that will help us to run and write our
    test and a page that contains the necessary code. The next step is to tweak the
    backend so that it uses the new `pageTest.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The file that we have to change is `Default.js`. That's the handler of the `Default.js`
    file's route in our application. The newly added `htmlWithTests` variable contains
    the new HTML markup. We use the `url` module to find out the `GET` variables that
    come from the client. If there is a `test` parameter, then we will load the page
    containing the layout and the test. Otherwise, it is the original HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the last change, we can run the server and open `http://localhost:9000/register?test=1`.
    However, we will get a bunch of error messages complaining that there are some
    missing files. This happens because the `server.js` file does not recognize URLs
    that start with `node_modules` or `tests`. The files that exist in these directories
    are static resources. So, we can use the already defined `Assets` module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, there is a file left that we have to create—`tests/spec.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This code is the simplest structure of a test. We have a group and a test inside.
    The key moment here is to run `done()` towards the end of the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that this test passes. The result in the browser looks like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing our project to run tests](img/image00191.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It is worth mentioning that the loaded page is still the same except for the
    elements in the top-right corner and below the footer. These new tags are generated
    by the Mocha framework. This is how the `html` reporter displays the results of
    our test.
  prefs: []
  type: TYPE_NORMAL
- en: Running our test with PhantomJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The result of the preceding sections is an automated test that runs in the browser.
    However, this is very often not enough. We may need to integrate the testing in
    our deployment processes, and using the browser is not always an option. Thankfully,
    there is a type of browser called a **headless browser**. It is a functional browser
    without a user interface. We still can visit a page, click links, or fill forms,
    but all of these actions are controlled by code. This is perfect for us and for
    automated testing.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of popular headless browsers. Selenium ([https://github.com/seleniumhq/selenium](https://github.com/seleniumhq/selenium))
    is one of them. It is well documented and has a big community. Another one is
    PhantomJS. It plays well with Node.js. So we are going to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have several components added to the test environment. To use PhantomJS
    directly, some supplementary configuration is needed. In order to avoid additional
    complexity, we will install the `mocha-phantomjs` module. Its purpose is to simplify
    the usage of the headless browser, especially in a combination of the Mocha framework.
    The following command will set `mocha-phantomjs` as a global command in our terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since version 3.4, the `mocha-phantomjs` module uses PhantomJS as a peer dependency,
    which means that we do not have to install the browser manually.
  prefs: []
  type: TYPE_NORMAL
- en: After successful installation, we are ready to run our test. The command that
    we have to type in our console is `mocha-phantomjs http://localhost:9000\?test=1`.
    There are back slashes because otherwise, if this wasn't the case, the terminal
    may not have interpreted the line correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running our test with PhantomJS](img/image00192.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is pretty much the same result that we got in the browser. The good thing
    is that the process now happens in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Testing user registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use the setup built in the previous sections and write an actual test.
    Let''s say that we want to make sure that our registering page works. The following
    are the two processes that we want to capture with our test:'
  prefs: []
  type: TYPE_NORMAL
- en: Filling the form with wrong data and making sure that the application shows
    an error message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filling the form with correct data and seeing a successful message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to use PhantomJS as our headless (virtual) browser. So, all we
    have to do is load our registration page and simulate user interactions, such
    as typing in the fields and pressing the buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating user interaction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a couple of issues that we are going to resolve. The first one is
    the actual simulation of user actions. From a JavaScript point of view, these
    actions are translated to events dispatched by some particular DOM elements. The
    following helper method will become a part of the `tests/spec.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `trigger` function accepts an element, the name of an event, an event group,
    and a key code. The first two arguments are mandatory. The third one has a default
    value of `MouseEvents` and the last one is optional. We are going to use the method
    to trigger the `change` and `click` events.
  prefs: []
  type: TYPE_NORMAL
- en: Filling and submitting the registration form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by filling the input fields of our registration form. It is worth
    mentioning that the code that we are going to write runs in a browser so that
    we have access to `document.querySelector`, for example. The following lines type
    a string in the first name field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Sending a string to the `firstName` element updates the user interface. However
    Ractive.js, our client-side framework, does not know about this change. The dispatching
    of the `change` event solves this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the same pattern to add values to the last name, e-mail, and password
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of the e-mail''s input field is invalid. This is done on purpose.
    We want to capture the case where the backend returns an error. To finish the
    operation, we have to click on the **register** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the test now, we will see the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Filling and submitting the registration form](img/image00193.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The test basically fails with a timeout. This is because we didn't call the
    `done` function. However, even then, we do not have any assertions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, things get interesting. The processes that occur in the browser are asynchronous.
    This means that we cannot simply run our assertion after we click the button.
    We should wait for a while. The usage of `setTimeout` is not acceptable in these
    cases. The right approach here is to tweak the code of the application so that
    it notifies the outside world that a particular job is done. In our case, this
    is the submission of the registration form. To be more precise, we have to update
    `s/controllers/Register.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The addition is `self.fire('form-submitted')`. Once the model returns the response
    and we process it, we dispatch an event. For the users who visit the site, this
    line does nothing. However, for our test suite, this is a way to find out when
    the backend responds and the user interface is updated. This is when we have to
    make our assertions.
  prefs: []
  type: TYPE_NORMAL
- en: Tweaking the code's execution order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The dispatching of the event is nice, but it does not solve the problem entirely.
    We need to reach the `Register` controller and subscribe to the `form-submitted`
    message. In our test, we have access to the global scope (the `window` object).
    Let''s use it as a bridge and provide a shortcut to the currently used controller,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the `app.js` file, we switched the pages of our application. This is the
    perfect place for our tweak because at this point, we know which controller is
    rendered.
  prefs: []
  type: TYPE_NORMAL
- en: One last thing that you should do before continuing with the actual test is
    to make sure that your social network is fully initialized and there is a view
    that is being rendered. This again needs access to the global `window` object.
    Our test will store a function in the `window.onAppReady` property, and the application
    will run it when PhantomJS opens the page. Note that attaching objects or variables
    to the global scope is not considered a good practice. However, in order to make
    our test work, we need such little tricks. We can always skip this while compiling
    a file for production release.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `backend/tpl/pageTest.html`, we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we continue using these lines, our test will fail because no UI is rendered
    when our assertions are executed. Instead, we should use the new `onAppReady`
    property to delay the calling of the `run` method in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Thus, we included Mocha and Chai. We configured the testing framework, added
    a function that will be executed when `onAppReady` is called, and then we ran
    the actual application.
  prefs: []
  type: TYPE_NORMAL
- en: Listening to the form-submitted event
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The very last code that we have to write is to subscribe for the `form-submitted`
    event, which is dispatched by our controller when the form is submitted and the
    result of the backend is processed. Our API should first respond with an error
    because we set a wrong e-mail value (`email.value = ''wrong email''`). Here is
    how we capture the error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `!!error` item cast the error variable to a Boolean. We will check for
    the existence of the error element. If it is there, then the test passes. The
    result in the console is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listening to the form-submitted event](img/image00194.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We verified the error reporting. Let''s close the cycle by making sure that
    the successful message appears when all the fields are filled properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `form-submitted` event will be dispatched twice. So, we will use an additional
    `submitted` variable to distinguish between both the calls. In the first case,
    we will check for `.error`, while in the second one, we will check for `.success`.
    After running the `mocha-phantomjs` command, we will get the same result as before,
    but this time, we are sure that the entire registration process works. Note that
    we attach a dynamically generated timestamp so that we get different e-mails every
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with DalekJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DalekJS is an open source UI testing tool that is written entirely in JavaScript.
    It acts as a test runner. It has its own API to perform user interface interactions.
    A very interesting feature of DalekJS is that it works with different browsers.
    It is capable of running tests in PhantomJS and popular browsers such as Chrome,
    Safari, Firefox, and Internet Explorer. It uses a **WebDriver JSON-Wire** protocol
    to communicate with these browsers and basically control what goes on in them.
  prefs: []
  type: TYPE_NORMAL
- en: Installing DalekJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to install DalekJS''s command-line tool. It is distributed as
    a Node.js package. So, the following command will download the necessary files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When the process finishes, we can run the `dalek` command in our terminal.
    The next step is to add the `dalekjs` module in our dependencies. This is the
    package that summons the tool''s API. So, two more lines are needed in the `package.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We mentioned that DalekJS works with real browsers such as Chrome, Safari, and
    Firefox. There are dedicated packages that deal with all of these browsers. For
    example, if we want to test in the Chrome browser, we have to install `dalek-browser-chrome`
    as the dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Using the DalekJS API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'DalekJS works in a similar way to the `mocha-phantomjs` module. We write our
    test in a file and simply pass that file to a command in our terminal. Let''s
    create a new file called `tests/dalekjs.spec.js` and put the following code inside
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The tool requires that we export an object, the keys of which are our test cases.
    We have only one case called `Testing registration`. We pass a function that receives
    a `test` argument, which gives us access to the DalekJS API.
  prefs: []
  type: TYPE_NORMAL
- en: The API of the module is designed in such a way that it is quite easy to understand
    what is going on. We open a specific URL and set values to the input fields. Like
    in the previous test, we will type in a wrong e-mail value and press the **Submit**
    button. The .`waitForElement` method is handy here because the operation is asynchronous.
    Once we detect the existence of the `.error` element, we will continue by writing
    the correct e-mail value and submitting the form again.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the test, we have to type `dalek ./tests/dalekjs.spec.js -b chrome`
    in the console. DalekJS will open a real Chrome window, which will execute the
    test and report the following in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the DalekJS API](img/image00195.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With DalekJS, we did not have to tweak our application's code. There is no additional
    assertion library or testing framework. All this is wrapped in a single module
    that is easy to use and install.
  prefs: []
  type: TYPE_NORMAL
- en: From another point of view, DalekJS may not be useful to every project. For
    example, it may not be useful when we need to interact with the code of the application
    or if we need something that is not listed in the provided API.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to test our user interface. We successfully solved
    a couple of issues and used tools such as Mocha, Chai, and DalekJS. Testing our
    code is important, but it is often not enough. Tests that simulate user interaction
    and prove that our software works properly should exist.
  prefs: []
  type: TYPE_NORMAL
