- en: Deploying Applications Using ECS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to configure and deploy ECS clusters
    in AWS using EC2 Auto Scaling groups, and the goal of this chapter is to deploy
    ECS applications to your newly built ECS cluster using CloudFormation.
  prefs: []
  type: TYPE_NORMAL
- en: You will first get started learning how to define and deploy the various supporting
    resources that are typically required for ECS applications in a production-grade
    environment. These resources include creating an application database to store
    data for your application, deploying application load balancers to service and
    load balance requests to your application, and configuring other resources, such
    as IAM roles and security groups, that control access to and from your application.
  prefs: []
  type: TYPE_NORMAL
- en: With these supporting resources in place, you will proceed to create ECS task
    definitions that define the run-time configuration of your containers and then
    configure ECS services that deploy your ECS task definitions to your ECS clusters,
    and also integrate with your application load balancers to manage features, such
    as rolling deployments. Finally, you will learn how to create CloudFormation custom
    resources to perform custom provisioning tasks, such as running database migrations,
    providing you with a complete application deployment framework based upon AWS
    CloudFormation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application database using RDS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Application Load Balancers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating ECS task definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying ECS services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECS rolling deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a CloudFormation custom resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following lists the technical requirements to complete this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Administrator access to an AWS account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local AWS profile configured as per instructions in Chapter 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter continues on from Chapter 7 so requires you have successfully completed
    all configuration tasks defined there
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following GitHub URL contains the code samples used in this chapter: [https://github.com/docker-in-aws/docker-in-aws/tree/master/ch8](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch8)[.](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch4)
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2Mx8wHX](http://bit.ly/2Mx8wHX)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application database using RDS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sample todobackend application includes a MySQL database that is used to
    persist todo items that are created through the application API. When you first
    set up and ran the sample application back in Chapter 1, you used a Docker container
    to provide the application database, however, in production-grade environments,
    it is generally considered best practice to run databases, and other services
    that provide persistent storage, on dedicated machines optimized specifically
    for database and data access operations. One such service in AWS is the relational
    database services (RDS), which provides dedicated managed instances optimized
    for providing popular relational database engines, including MySQL, Postgres,
    SQL Server, and Oracle. RDS is a very mature and robust service, and is very commonly
    used to support database requirements for both ECS and other applications that
    are run in AWS.
  prefs: []
  type: TYPE_NORMAL
- en: 'RDS instances can be configured using CloudFormation. To get started, let''s
    define a new resource in your todobackend CloudFormation template called `ApplicationDatabase`,
    with an `AWS::RDS::DBInstance` resource type, as demonstrated in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Creating RDS resources
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration in the preceding example is considered a minimal configuration
    for defining RDS instances, as described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Engine` and `EngineVersion`: The database engine, which in this case is MySQL,
    along with the major or minor version to deploy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DBInstanceClass`: The RDS instance type to run the database on. To ensure
    you qualify for free-tier access, you hardcode this to `db.t2.micro`, although
    you would typically parameterize this property to use larger instance sizes for
    your production environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AllocatedStorage` and `StorageType`: Defines the amount of storage in GB and
    the storage type. In the first example, the storage type is set to 10 GB of SSD-based
    gp2 (general purpose 2) storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MasterUsername` and `MasterUserPassword`: Specifies the master username and
    password configured for the RDS instance. The `MasterUserPassword` property references
    an input parameter called `DatabasePassword`, which includes a property called
    `NoEcho` that ensures CloudFormation will not print the value of this parameter
    in any logs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DBName`: Specifies the name of the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VPCSecurityGroups`: List of security groups to apply to network communications
    ingress and egress from the RDS instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DBSubnetGroupName`: References a resource of the `AWS::RDS::DBSubnetGroup` type,
    which defines the subnets that the RDS instance can be deployed to. Note that
    even if you only configure a single-availability-zone RDS instance, you still
    need to reference a least two subnets in the database subnet group resource you
    create. In the preceding example, you reference a resource called `ApplicationDatabaseSubnetGroup`,
    which you''ll create shortly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MultiAZ`: Defines whether or not to deploy the RDS instance in a highly available
    multi-availability-zone configuration. For the purposes of the demonstration application,
    this setting can be configured as `false`, however in a real-world application,
    you would typically configure this setting as `true`, at least for your production
    environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AvailabilityZone`: Defines the availability zone that the RDS instance will
    be deployed to. This setting is only applicable for single-availability-zone instances
    (that is, an instance with `MultiAZ` set to false). In the preceding example,
    you use the `AWS::Region` pseudo-parameter to reference availability zone `a` in
    your local region.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring supporting RDS resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Referring back to the preceding example, it is clear that you need to configure
    at least two additional supporting resources for the RDS instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ApplicationDatabaseSecurityGroup`: A security group resource that defines
    the ingress and egress security rules applied to the RDS instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ApplicationDatabaseSubnetGroup`: A list of subnets that the RDS instance can
    be deployed to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to these resources, the following example demonstrates we also
    need to add a few more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Creating supporting RDS resources
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, you first create the database subnet group resource,
    with the SubnetIds property referencing the same `ApplicationSubnets` list parameter
    you created in Chapter 7, meaning your database instance will be installed in
    the same subnets as your application ECS cluster and EC2 Auto Scaling group instances.
    In a production application, you would typically run your RDS instances on a separate
    dedicated subnet, ideally with no route to the internet for security purposes,
    however in the interests of keeping our example simple, we will just leverage
    the same subnet as the application ECS cluster.
  prefs: []
  type: TYPE_NORMAL
- en: You next create a security group resource called `ApplicationDatabaseSecurityGroup`,
    and notice that this only contains a single egress rule, which somewhat curiously
    permits ICMP access to the IP address `192.0.2.0/32`. This IP address is a special
    address that is part of the "TEST-NET" IP address range, which is an invalid IP
    address on the internet and is intended for use in example code and documentation.
    The reason for including this as an egress rule is that, by default, AWS automatically
    applys an allow any rule on egress unless you explicitly override these rules,
    so by adding a single rule that permits access to an unroutable IP address, you
    are effectively blocking any outbound communications from being initiated by the
    RDS instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, notice that you create two security-group-related resources, `ApplicationToApplicationDatabaseIngress`
    and `ApplicationToApplicationDatabaseEgress`, that respectively have resource
    types of `AWS::EC2::SecurityGroupIngress` and `AWS::EC2::SecurityGroupEgress`.
    These special resources avoid an issue known as circular dependencies in CloudFormation,
    where you create a circular dependency between two resources that need to reference
    each other for some reason. In our specific scenario, we want to allow members
    of the `ApplicationAutoscalingSecurityGroup` access to members of the `ApplicationDatabaseSecurityGroup`,
    with appropriate security rules applied ingress to the application database, and
    also applied egress from application instances. If you try to configure these
    rules as demonstrated in the following diagram, CloudFormation will throw an error
    and detect a circular dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0139e646-f450-4086-99aa-09fc2e454a4a.png)CloudFormation circular
    dependencies'
  prefs: []
  type: TYPE_NORMAL
- en: To address this, the following diagram demonstrates an alternative approach
    using the resources you created in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ApplicationToApplicationDatabaseIngress` resource will dynamically create
    an ingress rule in `ApplicationDatabaseSecurityGroup` (as specified by the `GroupId`
    property), which permits access to the MySQL port (TCP/3306) from `ApplicationAutoscalingSecurityGroup`
    (as specified by the `SourceSecurityGroupId` property). Similarly, the `ApplicationToApplicationDatabaseEgress` resource
    will dynamically create an egress rule in `ApplicationAutoscalingSecurityGroup` (as
    specified by the `GroupId` property), which permits access to the MySQL port (TCP/3306)
    associated with instances that belong to `ApplicationDatabaseSecurityGroup` (as
    specified by the `DestinationSecurityGroupId` property). This ultimately achieves
    the intention of the configuration illustrated in the preceding diagram, but without
    causing any circular dependency errors in CloudFormation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4abce996-823e-4813-a977-7975e8894666.png)Solving CloudFormation
    circular dependencies'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying RDS resources using CloudFormation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the configuration of the previous examples in place, you can now actually
    update your CloudFormation stack, which will add in the RDS instance and other
    supporting resources. Before you can do this, you need to update the `dev.cfg`
    file you created in Chapter 7, which provides environment specific values for
    the input parameters you need to provide to your CloudFormation stack. Specifically,
    you need to specify a value for the `MasterPassword` parameter, as demonstrated
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Adding a database password to the dev.cfg file
  prefs: []
  type: TYPE_NORMAL
- en: Now at this point, if you are alarmed that you are providing a password in clear
    text that will eventually be committed to source code, then well done, you are
    absolutely 100% correct to be very concerned about this approach. In the next
    chapter, we will deal specifically with managing credentials securely, but for
    now we won't address this, so bear in mind the approach demonstrated in the preceding
    example is not considered best practice and we will only leave this in place temporarily
    to get your application database instance up and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the configuration of the preceding example in place, you can now proceed
    to deploy your updated stack using the `aws cloudformation deploy` command you
    previously used in Chapter 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Updating a CloudFormation stack with RDS resources
  prefs: []
  type: TYPE_NORMAL
- en: The deployment will take some time (typically 15-20 minutes) to complete, and
    once the deployment has completed, notice that you can use the `aws cloudformation
    describe-stack-resource` command to obtain further information about the `ApplicationDatabase`
    resource, including the `PhysicalResourceId` property, which specifies the RDS
    instance identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Application Load Balancers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have established an ECS cluster and created an application database to store
    application data, and we next need to create the frontend infrastructure that
    will service connections from the outside world to our Docker applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'A popular approach within AWS to provide such infrastructure is to leverage
    the Elastic Load Balancing service, which provides a number of different options
    for load balancing connections to your applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Classic Elastic Load Balancers**: The original AWS load balancer that supports
    Layer 4 (TCP) load balancing. In general, you should use either the newer Application
    Load Balancer or the network load balancer, which collectively provide all of
    the existing functionality of classic load balancers and much more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application Load Balancers**: An HTTP-aware load balancer that specifically
    targets web-based applications and APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network Load Balancers**: A high performance Layer 4 (TCP) load-balancing
    service, typically used for non-HTTP TCP-based applications, or applications that
    require very high performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our purposes, we will leverage the Application Load Balancer (ALB), which
    is a modern Layer 7 load balancer that can perform advanced actions based upon
    HTTP protocol information, such as host-header and path-based routing. For example,
    an ALB can route requests for a given HTTP host header to a given set of targets,
    and can also route requests for the some.domain/foo path to one group of targets,
    and requests for the some.domain/bar path to a different set of targets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The AWS ALB integrates with the Elastic Container Service, supporting a number
    of key integration features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rolling updates**: ECS services can be deployed in a rolling fashion, with
    ECS leveraging the load balancer connection draining to take old versions of your
    applications out of service gracefully, terminate and replace each application
    container with a new version, and then add your new containers to the load balancer,
    ensuring updates are performed with no end user outages or impact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic port mapping**: This feature allows you to map your container port
    to a dynamic port on the ECS container instance, with ECS taking care of ensuring
    the dynamic port mapping is correctly registered with the Application Load Balancer.
    The primary benefit of dynamic port mapping is that it allows multiple instances
    of the same application container to run on a single ECS container instance, providing
    much greater flexibility around dimensioning and scaling your ECS clusters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Health checks**: ECS using Application Load Balancer health checks to determine
    the health of your Docker applications, automatically terminating and replacing
    any containers that may become unhealthy and fail load balancer health checks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application Load Balancer architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are familiar with the older classic Elastic Load Balancers, you will
    find that the architecture of the newer Application Load Balancers is more complex,
    given the nature of the advanced Layer 7/HTTP capabilities the ALBs support.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the various components that comprise an Application
    Load Balancer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7797ed7f-45ba-49b0-aca7-5116fd62bb32.png)Application Load Balancer
    components'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following describes each of the components illustrated in the preceding
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application Load Balancer**: The Application Load Balancer is a physical
    resource that defines physical characteristics of the load balancer, such as the
    subnets the load balancer should run in and security groups that permit or deny
    network traffic to or from the load balancer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Listener**: A listener defines a network port that end users and devices
    attach to. You can think of the listener as the frontend component of the load
    balancer, servicing incoming connections that ultimately will be routed to target
    groups that host your applications. Each Application Load Balancer can include
    multiple listeners—a common example of this might be a listener configuration
    that services both port `80` and port `443` network traffic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Listener rule**: A listener rule optionally routes HTTP traffic received
    by a listener to different target groups, based upon the value of the received
    host header and/or request path. For example, as demonstrated in the preceding
    diagram, you might route all traffic sent to the `/foo/*` request path to one
    target group, whilst all traffic sent to `/bar/*` might be routed to the another
    target group. Note that every listener must define a default target group, where
    all traffic that does not route a listener rule will be routed to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target group**: A target group defines one or more targets that incoming
    connections should be routed to. You can think of the target group as the backend
    component of the load balancer, responsible for load-balancing-received connections
    to members within the target group. When integrating application load balancers
    with ECS, the target group is linked to an ECS service, with each instance of
    the ECS service (that is, container) considered a single target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring an Application Load Balancer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you understand the basic architecture of application load balancers,
    let's define the various Application Load Balancer components in your CloudFormation
    template and proceed to deploy the new resources to your CloudFormation stack.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Application Load Balancer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example demonstrates adding a resource called `ApplicationLoadBalancer`,
    which, as the name suggests, configures the base Application Load Balancer resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Creating an Application Load Balancer
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, the following properties are configured for the Application
    Load Balancer resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Scheme`: Defines whether the load balancer has public IP addressing (as specified
    by a value of `internet-facing`) or only has private IP addressing (as specified
    by a value of `internal`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Subnets`: Defines the subnets that the Application Load Balancer endpoints
    will be deployed to. In the preceding example, you reference the `ApplicationSubnets`
    input parameter, which you have previously used for the EC2 Auto Scaling group
    and RDS database instance resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SecurityGroups`: Specifies a list of security groups to apply to the load
    balancer, which restricts ingress and egress network traffic. You reference a
    single security group called `ApplicationLoadBalancerSecurityGroup`, which you
    will create shortly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoadBalancerAttributes`: Configures various attributes of the Application
    Load Balancer in a key/value format. You can find a list of supported attributes
    at [https://docs.aws.amazon.com/elasticloadbalancing/latest/application/application-load-balancers.html#load-balancer-attributes](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/application-load-balancers.html#load-balancer-attributes),
    and in the preceding example, you configure a single attribute that reduces the
    idle connection timeout from the default value of `60` seconds to `30` seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A feature of CloudFormation is the ability to define your own *outputs*, which
    can be used to provide information about resources in your stack.  One useful
    output that you can configure for your stack is the value of the public DNS name
    of the application load balancer endpoint, as this is where any applications served
    by the load balancer will be published:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Configuring a CloudFormation Output
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, notice that the `ApplicationLoadBalancer` resource
    outputs a property called `DNSName`, which returns the public DNS name of the
    `ApplicationLoadBalancer` resource.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Application Load Balancer security groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding example, you referenced a resource called `ApplicationLoadBalancerSecurityGroup`,
    which defines ingress and egress network access to and from your Application Load
    Balancer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this resource, you also need to create `AWS::EC2::SecurityGroupIngress`
    and `AWS::EC2::SecurityGroupEgress` resources in a similar manner earlier example,
    which ensure the Application Load Balancer can communicate with your ECS service
    application instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Configuring Application Load Balancer security group resources
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, you first create the `ApplicationLoadBalancerSecurityGroup`
    resource, permitting ingress access to port 80 from the Internet. The `ApplicationLoadBalancerToApplicationIngress`
    and `ApplicationLoadBalancerToApplicationEgress` resources add security rules
    to the `ApplicationLoadBalancerSecurityGroup` and `ApplicationAutoscalingSecurityGroup`
    resources without creating circular dependencies (refer back to the previous diagram
    and the associated description), and notice that these rules reference the ephemeral
    port range of `32768` to `60999` on the application Auto Scaling group, given
    we will be configuring dynamic port mapping for your ECS services.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a listener
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have established the base Application Load Balancer and related
    security group resources, you can configure a listener for the Application Load
    Balancer. For the purposes of this book, you only need to configure a single listener
    that will service HTTP connections, however in any real-world production use case,
    you would typically configure an HTTPS listener with associated certificates,
    especially for any internet-facing service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates configuring a single listener that supports
    access to the Application Load Balancer using port `80` (HTTP):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Creating an Application Load Balancer listener
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the listener is bound to the `ApplicationLoadBalancer`
    resource via the `LoadBalancerArn` property, with the `Protocol` and `Port` properties
    configuring the listener to expect incoming HTTP connections on port `80`. Notice
    that you must define the `DefaultActions` property, which defines the default
    target group that incoming connections will be forwarded to.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a target group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final configuration task related to configuring an Application Load Balancer
    is to configure a target group, which will be used to forward incoming requests
    received by the listener resource to your application instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates configuring a target group resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Creating a target group
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, the following configuration is defined for the target
    group:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Protocol`: Defines the protocol of connections that will be forwarded to the
    target group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Port`: Specifies the container port your application will run on. By default,
    the todobackend sample application runs on port `8000`, so you can configure this
    value for the port. Note that ECS will dynamically reconfigure this port when
    dynamic port mapping is configured.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VpcId`: Configures the VPC ID where your targets are located.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TargetGroupAttributes`: Defines the configuration attributes ([https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-target-groups.html#target-group-attributes](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-target-groups.html#target-group-attributes))
    for the target group. In the preceding example, the `deregistration_delay.timeout_seconds`
    attribute configures the time to wait before deregistering a target, which takes
    place when draining connections during a rolling deployment of your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying an Application Load Balancer using CloudFormation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that all of your Application Load Balancer components have been defined
    in your CloudFormation template, you can deploy these components to AWS using
    the `aws cloudformation deploy` command.
  prefs: []
  type: TYPE_NORMAL
- en: Once your stack deployment is complete, if you open the AWS console and navigate
    to the EC2 dashboard, under the **Load Balancing** section you should be able
    to see your new Application Load Balancer resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot demonstrates viewing the Application Load Balancer
    resource that was created as part of your deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b91dab42-c34b-47da-a94f-69a7c62d23e7.png)Viewing an Application
    Load Balancer'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see the Application Load Balancer resource
    has a DNS name, which is the name of the endpoint your end users and devices need
    to connect to when accessing the applications behind the load balancer. You will
    use this name later on, once you have fully deployed all resources in your stack,
    but for now because your target group is empty, this URL will just return a 503
    error, as demonstrated in the following example. Note that you can view your listener
    resources by clicking on the **Listeners** tab in the preceding screenshot, and
    your associated target group resources can be viewed by clicking the **Target
    Groups** link on the left-hand menu.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that the DNS name of the Application Load Balancer is not a
    particularly friendly name that your end users will be able to recognize or remember.
    In a real-world application, you would typically create a CNAME or ALIAS DNS record,
    which configures a friendly canonical name, such as example.com, that points to
    your load balancer DNS name. See [https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-to-elb-load-balancer.html](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-to-elb-load-balancer.html)
    for more details on how to do this, and note that you can and should create CNAME
    and ALIAS records using CloudFormation ([https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-route53.html#scenario-recordsetgroup-zoneapex](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-route53.html#scenario-recordsetgroup-zoneapex)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Testing an Application Load Balancer endpoint
  prefs: []
  type: TYPE_NORMAL
- en: Notice in the preceding example that you can use the AWS CLI to query the outputs
    of your CloudFormation stack and obtain the public DNS name of your application
    load balancer.  You can also view the outputs of your stack by clicking on the
    Outputs tab after selecting your stack in the CloudFormation dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Creating ECS task definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have now reached the point where you have defined an ECS cluster using CloudFormation
    and created a number of supporting resources, including an RDS instance for your
    application database and an Application Load Balancer to service connections to
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, you are ready to create the ECS resources that will represent
    your application, which include ECS task definitions and ECS services.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will get started by defining an ECS task definition in your CloudFormation
    template, as demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Defining an ECS task definition using CloudFormation
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding example, configuring a task definition requires
    a reasonable amount of configuration, and requires a detailed understanding of
    the runtime configuration of the container application your task definition represents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in Chapter 1, when you created the sample application and ran it locally,
    you had to perform a similar exercise using Docker Compose. The following example
    shows the relevant snippet from the Docker Compose file in the todobackend repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Todobackend application Docker Compose configuration
  prefs: []
  type: TYPE_NORMAL
- en: If you compare the configurations of both of the previous examples, you can
    see that you can use your local Docker Compose configuration to determine the
    configuration required for your ECS task definition.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now examine each of the various ECS task definition configuration properties
    in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring ECS task definition families
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first property you define in the task definition is the **Family** property,
    which establishes the ECS task definition family name, and affects the way CloudFormation
    will create new instances of your task definition resources whenever you make
    changes to your task definition.
  prefs: []
  type: TYPE_NORMAL
- en: Recall in Chapter 4, that ECS task definitions support the concept of revisions,
    which you can think of as a specific version or configuration of your ECS task
    definition, and whenever you need to modify your task definition (for example,
    to modify the image tag), you can create a new revision of your ECS task definition.
  prefs: []
  type: TYPE_NORMAL
- en: So if your ECS task definition family name is **todobackend**, the first revision
    of your task definition will be **todobackend:1**, and any subsequent changes
    to the task definition will result in the creation of a new revision—for example, **todobackend:2**,
    **todobackend:3**, and so on. Configuring the **Family** property in your ECS
    task definition resource ensures CloudFormation will adopt this behavior of creating
    new revisions, whenever your ECS task definition resource is modified.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you did not configure the **Family** property as per the previous
    example, CloudFormation would generate a random name for the family with a revision
    of 1, and any subsequent changes to the task definition would result in a *new*
    family being created with a random name, again with a revision of 1.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring ECS task definition volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Referring back to the `ApplicationTaskDefinition` resource in earlier example,
    the `Volumes` property defines local Docker volumes that will be created whenever
    an instance of the ECS task definition is deployed to an ECS container instance.
    Referring to the local Docker Compose configuration in the previous example, you
    can see that a volume called **public** is configured, which is then referenced
    as a mount point in the **app** service definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'This volume is used to store static web files, which are generated by running
    the `python3 manage.py collectstatic --no-input` command in the local Makefile
    workflow, and must be available to the main application container, hence a volume
    is required to ensure the files generated by running this command are available to
    the application container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Todobackend Makefile
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in our ECS task definition, we are also required to specify a host
    source path of `/data/public`, which we created in the previous chapter as part
    of our ECS cluster auto scaling group CloudFormation init configuration.  This
    folder has the correct permissions on the underlying ECS container instance, which
    ensures our application will be able to read and write to the public volume.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring ECS task definition containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ECS task definition configured earlier includes a `ContainerDefinitions`
    property, which defines a list of one or more containers associated with the task
    definition. You can see that there are two containers defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '`todobackend` container: This is the main application container definition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collectstatic` container: This container is a short lived container that runs
    the `python3 manage.py collectstatic` command to generate local static web files.
    An important configuration parameter associated with this container is the `Essential`
    property, which defines whether or not ECS should attempt to restart the container
    if it should fail or exit (in fact, ECS will attempt to restart all containers
    in the task definition, causing the main application container to be unnecessarily
    stopped and restarted). Given the `collectstatic` container is only intended to
    run as a short-lived task, you must set this property to false to ensure ECS does
    not attempt to restart your ECS task definition containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many ways you could tackle the requirement to run the collect static
    process to generate static web files. For example, you could define a startup
    script that first runs collect static and then starts the application container,
    or you may wish to publish your static files to an S3 bucket, meaning you would
    run the collect static process quite differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from the Essential property, the configuration properties of the `todobackend`
    and `collectstatic` container definitions are very similar, so we will just discuss
    the properties of the main `todobackend` container definition here and discuss
    any differences to the `collectstatic` container definition where appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Image`: This property defines the URI of the Docker image the container is
    based from. Notice that we publish the URI of the ECR repository you created in
    Chapter 5, for the todobackend application, and reference a stack parameter called
    `ApplicationImageTag`, which allows you to provide an appropriate version of your
    Docker Image when deploying the stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cpu` and `MemoryReservation`: These properties allocate CPU and memory resources
    to your containers. We will discuss these resources in more detail in the coming
    chapters, but for now understand that these values reserve the configured amount
    of CPU shares and memory, yet allow your containers to use more CPU and memory
    (that is,"burst") if it is available. Notice that you allocate a minimal amount
    of CPU and memory to the `collectstatic` container, given it only needs to run
    for a short period of time and in all likelihood the ECS container instance will
    have spare CPU and memory capacity available to service the actual resource requirements
    of the container. This avoids reserving large amounts of CPU and memory for a
    container that only is active a fraction of the time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MountPoints`: Defines the Docker volumes that will be mounted to the container.
    Each container has a single mount point that mounts the **public** volume to the `/public` container
    path for hosting static web files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Environment`: Defines the environment variables that will be available to
    the container. Referring to the local Docker Compose configuration in the preceding
    example, you can see that the release service, which is a base service definition
    that the app service inherits from, indicates the container requires the `DJANGO_SETTINGS_MODULE`
    variable to be set to `todobackend.settings_release`, and requires a number of
    database-related environment variables to be defined that define connectivity
    to the application database. One other environment variable that is required is
    the `SECRET_KEY` variable, which is used for various cryptographic functions in
    the Django framework that powers the todobackend application, and should be configured
    with a secret, random value. As you can see, for now we have set a somewhat non-random
    plaintext value, in the next chapter, you will learn how you can inject this value
    as an encrypted secret'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Command`: Defines the command that should be executed when starting the container.
    You can see the `todobackend` container definition uses the same `uwsgi` command
    that the local Docker Compose workflow uses to start the `uwsgi` application server,
    whilst the collectstatic container uses the `python3 manage.py collectstatic`
    command to generate static web files to be served from the main application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PortMappings`: Specifies port mappings that should be exposed from the container.
    The todobackend container definition has a single port mapping, which specifies
    the default application port of `8000` for the container port, and specifies a
    host port value of `0`, meaning dynamic port mapping will be used (note that you
    can also omit the HostPort parameter when using dynamic port mapping).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LogConfiguration`: Configures the logging configuration for the container.
    In the previous example, you configure CloudWatch logs as the log driver by using
    the awslogs driver, and then configure options specific to this driver. The awslogs-group
    option specifies the log group that logs will be output to, and this references
    the name of a log group that is defined in the `ApplicationLogGroup` resource,
    just below the `ApplicationTaskDefinition` resource. The awslogs-stream-prefix
    is quite important, as it modifies the default log stream naming convention of
    container ID to the `<prefix-name>/<container-name>/<ecs-task-id>` format, with
    the key piece of information here being the ECS task ID, which is the primary
    task identifier you work with when using ECS rather than container IDs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Chapter 7, you granted your ECS container instances the ability to publish
    to any log group prefixed with the name of your CloudFormation stack. As long
    as your ECS task definitions and associated log groups follow this naming convention,
    the Docker Engine will be able to publish logs for your ECS tasks and containers
    to CloudWatch logs.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying ECS task definitions using CloudFormation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have defined your ECS task definition, you can deploy it using
    the now-familiar `aws cloudformation deploy` command. Once your stack has been
    updated, a new task definition with a family name to todobackend should be created,
    which you can view using the AWS CLI, as demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Verifying the todobackend task definition
  prefs: []
  type: TYPE_NORMAL
- en: Deploying ECS services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With your ECS cluster, ECS task definition, and various supporting resources
    in place, you can now define an ECS service that will deploy your container application
    as defined in the ECS task definition to your ECS cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates adding an ECS service resource to your CloudFormation
    template, which has a resource type of `AWS::ECS::Service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Creating an ECS service
  prefs: []
  type: TYPE_NORMAL
- en: One interesting aspect of the configuration in the preceding example is the
    `DependsOn` parameter, which defines other resources in the stack that must be
    created or updated before the ECS service resource can be created or updated.
    Although CloudFormation automatically creates dependencies when a resource directly
    references another resource, a resource may have dependencies on other resources
    that don't have a direct relationship to that resource. The ECS service resource
    is a good example of this—the service can't operate without a functional ECS cluster
    and associated ECS container instances (this is represented by the `ApplicationAutoscaling`
    resource) and can't write logs without the `ApplicationLogGroup` resource. A more
    subtle dependency is the `ApplicationLoadBalancerHttpListener` resource, which
    must be functional before the target group associated with the ECS service will
    register targets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The various properties that are configured for the ECS service are described
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TaskDefinition`, `DesiredCount`, and `Cluster`: Defines the ECS task definition,
    number of ECS tasks, and the target ECS cluster that the service will deploy to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoadBalancers`: Configures a load balancer resource that the ECS service should
    be integrated with. You must specify the container name, container port, and target
    group ARN that the ECS service will be registered with. Notice that you reference
    the `ApplicationServiceTargetGroup` resource you created earlier in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Role`: This property is only required if you are integrating your ECS service
    with a load balancer and specifies an IAM role that grants permissions for the
    ECS service to manage the configured load balancer. In the preceding example,
    you reference the ARN of a special IAM role known as a service role ([https://docs.aws.amazon.com/IAM/latest/UserGuide/using-service-linked-roles.html](https://docs.aws.amazon.com/IAM/latest/UserGuide/using-service-linked-roles.html)),
    which is automatically created by AWS whenever you create ECS resources. The `AWSServiceRoleForECS`
    service role grants a number of permissions typically required for ECS, including
    managing and integrating with application load balancers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeploymentConfiguration`: Configures settings related to rolling deployments
    of new versions of your ECS task definitions. During a deployment, ECS will stop
    existing containers and deploy new containers based on the new version of your
    ECS task definition, and the `MinimumHealthyPercent` setting defines minimum allowable
    percentage of containers in relation to the `DesiredCount` property that must
    be in service during a deployment. Similarly, the `MaximumPercent` setting defines
    the maximum allowable percentage of containers that can be deployed in relation
    to the `DesiredCount` property during a deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying an ECS service using CloudFormation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With your ECS service configuration in place, it''s time to deploy the changes
    to your stack using the `aws cloudformation deploy` command. Once deployment is
    complete, you ECS service should register with the target group you created earlier
    in this chapter, and if you browse to the URL of your Application Load Balancer,
    you should see that the root URL of the sample application is loading correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/68a5cac1-2c9c-4711-bb88-70eb0ee1e14e.png)Testing the todobackend
    application'
  prefs: []
  type: TYPE_NORMAL
- en: 'If, however, you click on the **todos** link shown in the preceding screenshot,
    you will receive an error, as demonstrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b1ba0115-82ab-40ff-9473-2f5887ed15b7.png)todobackend application
    error'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem in the preceding screenshot is that the database tables expected
    in the application database have not been created, as we have not yet run database
    migrations against the application database. We will learn how to address this
    issue shortly, but before we do this, we have one more topic to discuss related
    to deploying ECS services: rolling deployments.'
  prefs: []
  type: TYPE_NORMAL
- en: ECS rolling deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A key feature of ECS is rolling deployments, where ECS will automatically deploy
    new versions of your application in a rolling fashion, orchestrating the various
    operations in conjunction with your configured load balancers to ensure your application
    is successfully deployed with no down time and no impact to end users. The process
    of how ECS manages rolling deployments is actually quite detailed, and following
    diagram attempts to describe the process at a high level in a single diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9486bf16-31d9-4726-a3fb-d06d0fd92aeb.png)ECS rolling deployments'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, the following events take place during a rolling
    deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: A configuration change is made to the `ApplicationTaskDefinition` ECS task definition
    linked to the ECS service, which generally will be a change in the image tag for
    new versions of an application, but could be any change made to the task definition.
    This results in a new revision of the task definition being created (revision
    2 in this example).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ECS service is configured to use the new task definition revision, which
    happens automatically when using CloudFormation to manage your ECS resources.
    The deployment configuration of the ECS service determines how ECS manages the
    rolling deployment - in the preceding diagram, ECS must ensure that a minimum
    of 100% of the configured desired task count is maintained during the deployment,
    and can temporarily increase the task count up to 200% during a deployment. Assuming
    the desired task count is one, this means ECS can deploy a new ECS task based
    on the new task definition revision and satisfy the deployment configuration.
    Note that your ECS cluster must have enough resources available to accommodate
    these deployments and you are responsible for managing ECS cluster capacity (that
    is, ECS will not increase ECS cluster capacity temporarily to accommodate deployments).
    You will learn how to dynamically manage ECS cluster capacity in later chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the new ECS task starts successfully, ECS registers the new task with the
    configure load balancer (in the case of an Application Load Balancer, the task
    will be registered with a target group resource). The load balancer will perform
    health checks to determine the health of the new task, and once confirmed healthy,
    the new ECS task will be registered in the load balancer and able to accept incoming
    connections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ECS now instructs the load balancer to drain the existing ECS task. The load
    balancer will take the existing ECS task out of service (that is, it won't forward
    any new connections to the task), however will wait for a configurable period
    of time for existing connections to "drain" or close. During this time, any new
    connections to the load balancer will be forwarded to the new ECS task that was
    registered with the load balancer in Step 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the draining process is complete, the load balancer removes the old ECS
    task completely from the target group, and ECS can now terminate the existing
    ECS task. Once this is complete, the deployment of the new application task definition
    is complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see from this description, the deployment process is quite involved.
    The great news is that all of this comes out of the box with ECS - all that you
    need to understand is that any changes to your task definitions will trigger a
    new deployment, and that your deployment configuration, as determined by the `DeploymentConfiguration`
    property, gives you some control over the rolling deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Executing a rolling deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you understand how rolling deployments work, let's see the process
    in action by making a change to your ECS task definitions and deploying the change
    via CloudFormation, which will trigger a rolling deployment of your ECS service.
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, your CloudFormation configuration is not specifying the `ApplicationImageTag`
    parameter, meaning your ECS task definitions are using the default value of `latest`.
    Back in Chapter 5, when you published your Docker image to ECR, you actually pushed
    two tags—the `latest` tag and also the commit hash of the todobackend repository.
    This provides us with a good opportunity to further improve our CloudFormation
    template—by referencing the commit hash, rather than the `latest` tag, we will
    always be able to trigger a configuration change to your ECS task definitions
    whenever you have a new version of your application to deploy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates adding the `ApplicationImageTag` parameter
    to the `dev.cfg` file in the todobackend-aws repository, referencing the commit
    hash of the currently published image in ECR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Adding ApplicationImageTag to the dev.cfg file
  prefs: []
  type: TYPE_NORMAL
- en: If you now deploy your changes using the `aws cloudformation deploy` command, although the
    image you have now referenced is identical to the current latest tagged image,
    CloudFormation will detect this as a configuration change, create a new revision
    of your ECS task definitions, and update the `ApplicationService` ECS service
    resource, triggering a rolling deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the deployment is running, if you browse to your ECS service in the ECS
    dashboard and select the Deployments tab, as demonstrated in the following screenshot,
    you will see two deployments—the ACTIVE deployment refers to the existing ECS
    tasks, while the PRIMARY deployment refers to the new ECS tasks that are being
    deployed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/44aab8c6-3a36-47ec-b224-74861afc4181.png)ECS service rolling deployment'
  prefs: []
  type: TYPE_NORMAL
- en: 'Eventually, the ACTIVE deployment will disappear once the rolling deployment
    process is complete, and if you click on the Events tab, you will see the various
    events that took place during the deployment, which correspond to the earlier
    description:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/adc2feb0-c12b-4822-b81d-0acf52cefc78.png)ECS service rolling deployment
    events'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CloudFormation custom resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although our application has been deployed and is running, we clearly have a
    problem in that we haven't run database migrations, which is a required deployment
    task. We already have dealt with running another deployment task, which is to
    collect static files, however database migrations should only be run as a *single*
    deployment task per deployment. For example, if you are deploying multiple instances
    of your service, you don't want to run migrations for each instance you deploy,
    you just want to run migrations once per deployment, regardless of the number
    of instances that are in service.
  prefs: []
  type: TYPE_NORMAL
- en: One obvious solution is to manually run migrations after each deployment, however
    ideally you want to fully automate your deployments and ensure you have a mechanism
    to automatically run migrations. CloudFormation does not provide a resource that
    allows you run one-off ECS tasks, however an extremely powerful feature of CloudFormation
    is the ability to create your own custom resources, which allow you to perform
    custom provisioning tasks. A benefit of creating custom resources is that you
    can incorporate custom provisioning tasks into the workflow of deploying various
    AWS services and resources, using the CloudFormation framework to manage this
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now learn how you can create a simple ECS task runner custom resource
    that will run the migrate task as part of creating and updating your application
    environment via CloudFormation.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CloudFormation custom resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you get started configuring CloudFormation custom resources, it is worthwhile
    to discuss how they actually work and describe the key components that compose
    a custom resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates how CloudFormation custom resources work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a8738f96-3ab5-46a3-95dc-d5d9216a7f06.png)CloudFormation custom resources'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, the following steps take place when you use custom
    resources in your CloudFormation templates:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to define custom resources in your CloudFormation templates. A custom
    resource has the `AWS::CloudFormation::CustomResource` resource type, or alternatively
    `Custom::<resource-name>`. When CloudFormation encounters a custom resource, it
    looks for a specific property called `ServiceToken`, which provides the ARN of
    a Lambda function that should provision the custom resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CloudFormation invokes the Lambda function, and passes a custom resource request
    to the function in the form of a JSON object. The event has a request type, which
    defines whether the request is to either create, update, or delete the resource,
    and includes request properties, which are custom properties you can define in
    your custom resource definition that will be passed to the Lambda function. Another
    important property of the request is the response URL, which provides a pre-signed
    S3 URL where the Lambda function should post a response once provisioning is complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Lambda function processes the custom resource request and performs appropriate
    provisioning of the resource, based upon the request type and request properties.
    Once provisioning is complete, the function posts a success or failure response
    to the response URL received in the custom resource request, and includes a resource
    identifier in the event a resource has been created or updated.  Assuming the
    response signals success, the response may include a `Data` property, which can
    include useful information about the provisioned custom resource that can be referenced
    elsewhere in the CloudFormation stack using the standard `!Sub ${<resource-name>.<data-property>}`
    syntax, where `<data-property>` is a property included in the `Data` property
    of the response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CloudFormation service polls the response URL for a response. Once a response
    is received, CloudFormation parses the response and continues stack provisioning
    (or rolls back the stack in the event the response indicates a failure).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a custom resource Lambda function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in the previous section, a custom resource requires you to create
    a Lambda function that processes an incoming event sent by CloudFormation, performs
    custom provisioning actions, and then responds to CloudFormation using a pre-signed
    S3 URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sounds reasonably complicated, however there are a number of tools available
    that make this possible to achieve in a relatively straightforward manner for
    simple use cases, as demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Creating an inline Lambda function using CloudFormation
  prefs: []
  type: TYPE_NORMAL
- en: The most important aspect of the preceding example to initially focus on is
    the `Code.ZipFile` property within the `EcsTaskRunner` resource, which defines
    an inline Python script that performs the custom provisioning actions of your
    custom resource. Note this approach of defining code inline is generally not recommended
    for real world use cases, and in later chapters we will create a more complex
    custom resource complete with its own source code repository for the Lambda function
    code, but for the purposes of keeping this example simple and introducing the
    core concepts of custom resources, I am using an inline approach for now.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the custom resource function code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's focus on discussing the custom resource function code, which I have isolated
    in the earlier example and added comments to describe what various statements
    are doing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Creating an inline Lambda function using CloudFormation
  prefs: []
  type: TYPE_NORMAL
- en: At a high level, the custom resource function receives CloudFormation custom
    resource event and calls the `run_task` method for the ECS service from the AWS
    Python SDK, passing in the ECS cluster, ECS task definition, and optional overrides
    to execute. The function then waits for the task to complete, inspects the result
    of the ECS task to determine whether the associated container completed successfully
    and then responds with either success or failure to CloudFormation.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the function imports a module called `cfnresponse`, which is a module
    included in the AWS Lambda Python runtime environment that provides a simple high-level
    mechanism for responding to CloudFormation custom resource requests. The function
    also imports a module called `boto3`, which provides the AWS Python SDK and is
    used to create a `client` object that interacts specifically with the ECS service.
    The Lambda function then defines a single function called `handler`, which is
    the entry point for new events passed to the Lambda function, and notice that
    the `handler` function must accept both an `event` object that contains the CloudFormation
    custom resource event, and a `context` object that provides runtime information
    about the Lambda environment. Note that the function should only attempt to run
    a task for CloudFormation create and update requests, and can simply return success
    when a request to delete the custom resource is received, given tasks are short-lived
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: The code in the preceding example is by no means production-level code and has
    been simplified for demonstration purposes to only handle two primary scenarios
    related to success and failure.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the custom resource Lambda function resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you understand how the Lambda function code actually works, let's focus
    on the remainder of the configuration you added in earlier example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EcsTaskRunner` resource defines the Lambda function, with key configuration
    properties described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FunctionName`: The name of the function. An important aspect to understand
    with function naming is that the associated CloudWatch logs group that is used
    to store function logs must follow a naming convention of `/aws/lambda/<function-name>`,
    and you see that the `FunctionName` property matches the `LogGroupName` property
    of the `EcsTaskRunnerLogGroup` resource. Notice that the `EcsTaskRunner` must
    also declare a dependency on the `EcsTaskRunnerLogGroup` resource, as per the
    configuration of the `DependsOn` setting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Handler`: Specifies the entry point for the Lambda function in the `<module>.<function>` format.
    Note that when using the inline code mechanism of the module created for your
    Lambda function will always be called `index`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Timeout`: It is important to understand that, at the time of writing, Lambda
    has a maximum five-minute (300 seconds) timeout, meaning your functions must complete
    within five minutes or they will be terminated. The default timeout for a Lambda
    function is 3 seconds, and because it does take time to deploy a new ECS task,
    run the ECS task and wait for the task to complete, this timeout has been increased
    to maximum timeout of 300 seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Role`: Defines the IAM role to assign to the Lambda function. Note that the
    referenced `EcsTaskRunnerRole` resource must trust the lambda.amazonaws.com and
    at a minimum, every Lambda function must have permissions to write to the associated
    CloudWatch logs group if you want to capture any logs. The ECS task runner function
    requires permissions to run and describe ECS tasks, and the use of conditions
    is configured to only grant these permissions to the ECS cluster defined in the
    stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that your custom resource Lambda function and associated supporting resources
    are in place, you can define the actual custom resource object. For our use case,
    we need to define a custom resource that will run the `python3 manage.py migrate`
    command inside our application container, and given the migrate task interacts
    with the application database, the task must be configured with the various database
    environment variables that define connectivity to the application database resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'One approach would be to leverage the `ApplicationTaskDefinition` resource
    you created earlier and specify a command override, however one issue is that
    the `ApplicationTaskDefinition` includes the `collectstatic` container, which
    we don''t really want to run whenever you run migrations. To overcome this, you
    need to create a separate task definition called `MigrateTaskDefinition`, which
    only includes a single container definition that specifically runs database migrations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Creating a migrate task definition
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, notice that the `MigrateTaskDefinition` resource requires
    database-related environment variables to be configured, however does not require
    the volume mappings or port mappings you configured previously in the `ApplicationTaskDefinition`
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this task definition in place, you can now create your custom resource,
    as demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Creating a migrate task custom resource
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, notice that your custom resource is created with the `AWS::CloudFormation::CustomResource` type,
    and every custom resource you create must include the `ServiceToken` property,
    which references the ARN of the associated custom resource Lambda function. The
    remainder of the properties are specific to your custom resource function, which
    in our case must specify, at a minimum, the target ECS cluster and ECS task definition
    of the task that needs to be executed. Notice that the custom resource includes
    dependencies to ensure it is only run once the `ApplicationAutoscaling` and `ApplicationDatabase`
    resources have been created, and you also need to add a dependency on the `ApplicationService`
    resource you created earlier in this chapter, so that this resource is not created
    or updated until the `MigrateTask` custom resource has completed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying custom resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are now ready to deploy your changes using the `aws cloudformation deploy`
    command. While the CloudFormation stack changes are deploying, once CloudFormation
    initiates creation of the custom resource and invokes your Lambda function, you
    can navigate to AWS Lambda console to view your Lambda function and also check
    function logs.
  prefs: []
  type: TYPE_NORMAL
- en: CloudFormation custom resources can be time-consuming to initially get working,
    particularly if your code throws exceptions and you don't have appropriate code
    to catch these exceptions and send failure responses. It is possible for you to
    end up waiting several hours for a custom resource action to timeout, because
    your custom resource threw an exception and did not return an appropriate failure
    response to CloudFormation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot demonstrates viewing the `todobackend-ecsTasks` Lambda
    function that is created from your CloudFormation stack in the AWS Lambda console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/eb137671-2741-4ba2-8634-1079e75d3526.png)Viewing Lambda functions
    in the AWS console'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, the **Configuration** tab provides configuration
    details about your function, and even includes an inline code editor where you
    can review, test, and debug your code. The **Monitoring** tab provides access
    to various metrics for your function, and includes a useful **Jump to Logs** link
    that takes you straight to the logs for your function in CloudWatch logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6adc9b11-80cc-4199-b42f-94ef997e1f74.png)Viewing Lambda function
    logs in the AWS console'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, the START message indicates when the function was
    invoked, and you can see a response body with a status of SUCCESS was generated,
    which is published to the CloudFormation custom resource response URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now is also a good time to review the CloudWatch logs for your ECS tasks—shows
    the **/todobackend/ecs/todobackend** log group, which is the log group configured
    in your CloudFormation stack that collects all ECS task logs for the application.
    Notice that there are several log streams - one for the **collectstatic** container
    that generated static tasks, one for the **migrate** container that ran migrations,
    and a log stream for the main todobackend application. Notice that each log stream
    includes the ECS task ID at the end of the log stream name - these correlate directly
    to the ECS task IDs that you interact with using the ECS console or AWS CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/03520e7d-967e-43de-a3cd-855c822ebe16.png)ECS log groups in CloudWatch
    logs'
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a final check, the sample application should now be fully functional - for
    example, the todos link that failed earlier in should now work, as demonstrated
    in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can interact with the API to add or remove todo items, and all of your
    todo items will now be persisted in the application database defined in your stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/98dcd51c-619f-4fde-bab1-95f5526d88bb.png)Working todobackend application'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you successfully deployed the sample Docker application to
    AWS using ECS. You learned how to define key supporting application and infrastructure
    resources, including how to create an application database using the AWS RDS service,
    and how to integrate your ECS applications with application load balancers provided
    by the AWS Elastic Load Balancing service.
  prefs: []
  type: TYPE_NORMAL
- en: With these supporting resources in place, you learned how to create ECS task
    definitions that control the runtime configuration of your containers, and then
    deployed instances of your ECS task definitions to your ECS cluster by creating
    an ECS service for the sample application. You learned how an ECS task definition
    can define volumes and multiple container definitions, and you used this capability
    to create a separate non-essential container definition that always runs whenever
    your ECS task definition is deployed and generates static web files for the sample
    application. You also integrated the ECS service for the sample application with
    the various Application Load Balancer resources in your stack, ensuring connections
    to your application can be load balanced across multiple instances of your ECS
    service in a highly available manner.
  prefs: []
  type: TYPE_NORMAL
- en: Although you were able to successfully deploy your application as an ECS service,
    you discovered that your application was not fully functional, because the database
    migrations that establish the schema and tables for your application database
    had not been run. You addressed this issue by creating an ECS task runner CloudFormation
    custom resource, which allowed you to run migrations as a single-shot task per
    application deployment. The custom resource is defined as a simple Lambda function
    written in Python, which first runs a task for a given ECS task definition on
    a given ECS cluster, waits for the task to complete, and then reports the success
    or failure of the task based upon the exit code of the container associated with
    the task.
  prefs: []
  type: TYPE_NORMAL
- en: With this custom resource in place, your sample application is now fully functional,
    although it still has some deficiencies. In the next chapter, we will address
    one of those deficiencies—secrets management and ensuring passwords remain confidential—which
    is critical in secure, production-grade Docker applications.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'True/False: An RDS instance requires you to create a DB subnet group with at
    least two subnets.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When configuring an Application Load Balancer, which component services frontend
    connections from end users?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/False: A target group can accept registrations from targets before the
    Application Load Balancer listener is created.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When configuring security group rules permitting access between an application
    database and ECS container instances, you receive a CloudFormation error about
    circular dependencies. What type of resources can you use to overcome this issue?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You configure an ECS task definition that includes two container definitions.
    One of the container definition performs a short provisioning task and then exits.
    You discover that ECS is continuously restarting ECS services based on this task
    definition. How can you resolve this issue?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which CloudFormation parameter can you configure to define explicit dependencies
    on other resources?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/False: CloudFormation custom resources use AWS Lambda functions to perform
    custom provisioning tasks.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three types of events you need to handle when receiving CloudFormation
    custom resource events?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You create a Lambda function with an inline Python function that performs custom
    provisioning tasks, however when attempting to view logs for this function nothing
    is being written to CloudWatch logs. You confirm that the log group name is configured
    correctly for the function. What is the most likely reason for the issue?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can check the following links for more information about the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: CloudFormation RDS Instance Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudFormation Application Load Balancer Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-loadbalancer.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-loadbalancer.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudFormation Application Load Balancer Listener Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-listener.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-listener.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudFormation Application Load Balancer Target Group Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-targetgroup.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-targetgroup.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudFormation ECS Task Definition Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-taskdefinition.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-taskdefinition.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudFormation ECS Service Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-service.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-service.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudFormation Lambda Function Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudFormation Lambda Function Code: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-code.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-code.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudFormation Custom Resource Documentation: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-custom-resources.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-custom-resources.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudFormation Custom Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/crpg-ref.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/crpg-ref.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
