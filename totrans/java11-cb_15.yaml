- en: The New Way of Coding with Java 10 and Java 11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using local-variable type inference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using local-variable syntax for lambda parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter gives you a quick introduction to new features that affect your
    coding. Many other languages, including JavaScript, have this feature—the ability
    to declare a variable using a `var` keyword (in Java, it is actually a **reserved
    type name**, not a keyword). It has many advantages but is not without controversy.
    If used excessively, especially with short non-descriptive identifiers, it can
    make the code less readable and the added value may be drowned out by the increased
    code obscurity.
  prefs: []
  type: TYPE_NORMAL
- en: That is why in the following recipe, we explain the reasons the reserved `var` type
    was introduced. Try to avoid using `var` in the other cases.
  prefs: []
  type: TYPE_NORMAL
- en: Using local-variable type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn about local-variable type inference, which was
    introduced in Java 10, where it can be used, and its limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A local-variable type inference is the ability of a compiler to identify the
    type of the local variable using the correct side of an expression. In Java, a
    local variable with an inferred type is declared using the `var` identifier. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The type of each of the preceding variables is clearly identifiable. We captured
    their types in comments.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `var` is not a keyword, but an identifier, with a special meaning
    as the type of a local variable declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'It definitely saves typing and makes the code less cluttered with repeated
    code. Let''s look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'That was the only way to implement such a loop. But since Java 10, it can be
    written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the code becomes clearer, but using more descriptive variable
    names (such as `idToNames` and `names`) is helpful. Well, it is helpful anyway.
    But if you do not pay attention to the variable names,it is easy to make the code
    not easy to understand. For example, look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the preceding line, you have no idea what type the `names` variable
    is. Changing it to `idToNames` makes it easier to guess. Nevertheless, many programmers
    do not do it. They prefer short variable names and figure out the type of each
    variable using the IDE context support (adding a dot after the variable name).
    But at the end of the day, it's just a matter of style and personal preferences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another potential problem comes from the fact that the new style may violate
    encapsulation and coding to an interface principle if no extra care is taken.
    For example, consider this interface and its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `AImpl` class has more public methods than the interface it implements.
    The traditional style of creating the `AImpl` object would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, we expose only the methods present in the interface, while the new
    style allows access to all the methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To limit the reference to the methods of the interface only, one needs to add
    the typecasting as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: So, like many powerful tools, the new style can make your code easier to write
    and much more readable or, if special care is not taken, less readable and more
    difficult to debug.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use a local variable type in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With a right-hand initializer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following declarations and assignments are illegal and will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'By extension, with an initializer in the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And we have talked already about this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As an anonymous class reference:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As an identifier:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As a method name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: But `var` cannot be used as a class or an interface name.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a package name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using local-variable syntax for lambda parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the local-variable syntax (discussed
    in the previous recipe) for lambda parameters and the motivation for introducing
    this feature. It was introduced in Java 11.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until the release of Java 11, there were two ways to declare parameter types—explicit
    and implicit. Here is an explicit version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following is an implicit parameter type definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the compiler figures the type of the parameters by the
    interface definition.
  prefs: []
  type: TYPE_NORMAL
- en: With Java 11, another way of parameter type declaration was introduced—using
    the  `var` identifier.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following parameter declaration is exactly the same as the implicit one
    before Java 11:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The new local variable style syntax allows us to add annotations without defining
    the parameter type explicitly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The annotations tell the tools that process the code (the IDE, for example)
    about the programmer''s intent, so they can warn the programmer during compilation
    or execution in case the declared intent is violated. For example, we have tried
    to run the following code inside IntelliJ IDEA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It failed with `NullPointerException` at runtime. Then we have run the following
    code (with annotations):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The result was the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The lambda expression was not even executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of local-variable syntax in the case of lambda parameters becomes
    clear if we need to use annotations when the parameters are the objects of a class
    with a really long name. Before Java 11, the code may look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We had to declare the type of the variable explicitly because we wanted to
    add annotations and the following implicit version would not even compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With Java 11, the new syntax allows us to use the implicit parameter type inference
    using the `var` identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: That is the advantage of and the motivation behind introducing a local-variable
    syntax for the lambda parameter's declaration.
  prefs: []
  type: TYPE_NORMAL
