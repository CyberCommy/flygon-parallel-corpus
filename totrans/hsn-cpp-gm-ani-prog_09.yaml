- en: '*Chapter 9*: Implementing Animation Clips'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An animation clip is a collection of the `TransformTrack` objects. An animation
    clip animates a collection of transforms over time and the collection of transforms
    that is animated is called a pose. Think of a pose as the skeleton of an animated
    character at a specific point in time. A pose is a hierarchy of transforms. The
    value of each transform affects all of its children.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s walk through what it takes to generate the pose for one frame of a game''s
    character animation. When an animation clip is sampled, the result is a pose.
    An animation clip is made up of animation tracks and each animation track is made
    up of one or more frames. This relationship looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: The dependencies of generating a pose.](img/Figure_9.1_B16191.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: The dependencies of generating a pose'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to load animation clips from
    glTF files and sample those clips into a pose.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing poses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To store a parent-child hierarchy between transforms, you need to maintain two
    parallel vectors—one filled with transforms and one filled with integers. The
    integer array contains the index of the parent transform for each joint. Not all
    joints have parents; if a joint doesn't have a parent, its parent value is negative.
  prefs: []
  type: TYPE_NORMAL
- en: 'When thinking about a skeleton or pose, it''s easy to think of a hierarchy
    that has one root node and many nodes that branch off it. In practice, it''s not
    uncommon to have two or three root nodes. Sometimes, file formats store models
    in a way that the first node of the skeleton is a root node, but there is also
    a root node that all the skinned meshes are children of. These hierarchies tend
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: Multiple root nodes in one file](img/Figure_9.2_B16191.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Multiple root nodes in one file'
  prefs: []
  type: TYPE_NORMAL
- en: There are three common poses for an animated character—the current pose, the
    bind pose, and the rest pose. The rest pose is the default configuration of all
    the bones. The animation describes the transformation of each bone over time.
    Sampling an animation in time results in the current pose that is used to skin
    a character. The bind pose is covered in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all animations affect every bone or joint of a character; this means that
    some animations might not change the value of a joint. Remember, in this context
    a joint is expressed as a `Transform` object. What happens if animation `1` but
    animation **B** doesn''t? The following list shows you the result:'
  prefs: []
  type: TYPE_NORMAL
- en: If you only play **A** or **B**, everything is fine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you play **B** and then **A**, everything is fine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you play **A** and then **B**, things get a bit wonky.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the last example, where you play animation `1` maintains its last modified
    transform from animation `Pose` class.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the Pose class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Pose` class needs to keep track of the transformation of every joint in
    the skeleton of the character that you are animating. It also needs to keep track
    of the parent joint of every joint. This data is kept in two parallel vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before a new animation clip is sampled, the pose of the current character needs
    to be reset to the rest pose. The `Pose` class implements a copy constructor and
    assignment operator to make copying poses as fast as possible. Follow these steps
    to declare the `Pose` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new header file, `Pose.h`. Add the definition of the `Pose` class
    to this file, starting with the parallel vectors for joint transforms and their
    parents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a default constructor and a copy constructor and overload the assignment
    operator. The `Pose` class also has a convenience constructor that takes the number
    of joints the pose will have as arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a getter and setter function for the number of joints in the pose. When
    the setter function is used, both the `mJoints` and `mParents` vectors need to
    be resized:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add getter and setter functions for the parent of a joint. Both of these functions
    need to take the index of the joint as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Pose` class needs to provide a way to get and set the local transform
    of a joint, as well as to retrieve the global transform of a joint. Overload `[]
    operator` to return the global transform of a joint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For a `Pose` class to be passed to OpenGL, it needs to be converted into a
    linear array of matrices. The `GetMatrixPalette` function carries out this conversion.
    The function takes a reference to a vector of matrices and fills it out with the
    global transform matrix of each joint in the pose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finish setting up the `Pose` class by overloading the equality and inequality
    operators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `Pose` class is used to hold the transformation of every bone in an animated
    hierarchy. Think of it as a frame in an animation; the `Pose` class represents
    the state of an animation at a given time. In the following section, you will
    implement the `Pose` class.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Pose class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file, `Pose.cpp`. You will implement the `Pose` class in this
    file. Take the following steps to implement the `Pose` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The default constructor doesn''t have to do anything. The copy constructor
    calls the assignment operator. The convenience constructor calls the `Resize`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The assignment operator needs to copy the pose as fast as possible. You need
    to make sure the pose isn''t assigned to itself. Next, make sure that the pose
    has the correct number of joints and parents. Then, carry out a mem-copy to fast-copy
    all of the parent and pose data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the parent and joint vectors are parallel, the `Resize` function needs
    to set the size of both. The `size` getter function can return the size of either
    vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The getter and setter methods for the local transforms are simple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting from the current transform, the `GetGlobalTransform` method needs
    to combine all the transforms up the parent chain until it reaches the root bone.
    Remember, transform concatenation is carried out from right to left. The overloaded
    `[] operator` should be treated as an alias for `GetGlobalTransform`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert a `Pose` class into a vector of matrices, loop through every transform
    in the pose. For every transform, find the global transform, convert it into a
    matrix, and store the result in the vector of matrices. This function isn''t optimized
    yet; you will optimize it in a later chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The getter and setter methods for the parent joint indices are simple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When comparing two poses, you need to make sure that all of the joint transforms
    and parent indices are identical in both poses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It's not uncommon for one animated character to have multiple active poses.
    Consider a case where a character runs and shoots a gun at the same time. Two
    animations will likely play—one that affects the lower body, the **run** animation,
    and one that affects the upper body, the **shoot** animation. These poses blend
    together into a final pose that is used to display the animated character. This
    type of animation blending is covered in [*Chapter 12*](B16191_12_Final_JC_ePub.xhtml#_idTextAnchor204),
    *Blending between Animations*.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you will implement animation clips. An animation clip
    contains the animation for all the animated joints in a pose over time. The `Clip`
    class is used to sample animations and generate poses to display.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing clips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An animation clip is a collection of animation tracks; each track describes
    the motion of one joint over time and all of the tracks combined describe the
    motion of the animated model over time. If you sample an animation clip, you get
    a pose that describes the configuration of each joint in the animation clip at
    the specified time.
  prefs: []
  type: TYPE_NORMAL
- en: For a basic clip class, all you need is a vector of `Clip` class should also
    keep track of metadata, such as the name of the clip, whether the clip is looping,
    and information about the time or duration of the clip.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the Clip class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Clip` class needs to maintain a vector of transform tracks. This is the
    most important data that the clip contains. Other than the tracks, a clip has
    a name, a start time, and an end time, and the clip should know whether it's looping
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The looping attribute of the `Clip` class could be offloaded to a construct
    that''s further down the pipeline (such as an animation component or something
    similar). However, when implementing a bare-bones animation system, this is a
    good place to put the looping property:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `Clip.h`, and start the declaration of the `Clip` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Clips are sampled in the same way that tracks are sampled. The provided sample
    time might be outside the range of the clip. To deal with this, you need to implement
    a helper function that adjusts the provided sample time so that it is within the
    range of the current animation clip:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Clip` class needs a default constructor to assign default values to some
    of its members. The compiler-generated destructor, the copy constructor, and the
    assignment operator should be fine here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Clip` class should provide a way to get the number of joints a clip contains,
    as well as the joint ID for a specific track index. You also need to have a joint
    ID setter that''s based on the index of the joint in the clip:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieving data from a clip can be done in one of two ways. The `[] operator`
    returns a transform track for the specified joint. If no track exists for the
    specified joint, one is created and returned. The `Sample` function takes a `Pose`reference
    and a time and returns a `float` value that is also a time. This function samples
    the animation clip at the provided time into the `Pose` reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We need a public helper function to figure out the start and end times of the
    animation clip. The `RecalculateDuration` function loops through all the `TransformTrack`
    objects and sets the start/end time of the animation clip based on the tracks
    that make up the clip. This function is intended to be called by the code that
    loads the animation clip from a file format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `Clip` class takes simple getter and setter functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `Clip` class implemented here can be used to animate anything; don't feel
    like you are limited to humans and humanoid animations. In the following section,
    you will implement the `Clip` class.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Clip class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file, `Clip.cpp`. You will implement the `Clip` class in this
    new file. Follow these steps to implement the `Clip` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The default constructor needs to assign some default values to the members
    of the `Clip` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the `Sample` function, make sure the clip is valid and that the
    time is in the range of the clip. Then, loop through all of the tracks. Get the
    joint ID of the track, sample the track, and assign the sampled value back to
    the `Pose` reference. If a component of a transform isn''t animated, the reference
    components are used to provide default values. The function then returns the adjusted
    time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AdjustTimeToFitRange` function that should loop has the same logic as
    the `AdjustTimeToFitTrack` function you implemented for the templated `Track`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RecalculateDuration` function sets `mStartTime` and `mEndTime` to default
    values of `0`. Next, these functions loop through every `TransformTrack` object
    in the animation clip. If the track is valid, the start and end times of the track
    are retrieved. The smallest start time and the largest end time are stored. The
    start time of a clip might not be `0`; it''s possible to have a clip that starts
    at an arbitrary point in time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`[] operator` is meant to retrieve the `TransformTrack` object for a specific
    joint in the clip. This function is mainly used by whatever code loads the animation
    clip from a file. The function performs a linear search through all of the tracks
    to see whether any of them targets the specified joint. If a qualifying track
    is found, a reference to it is returned. If no qualifying track is found, a new
    one is created and returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The remaining getter functions of the `Clip` class are simple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the remaining setter functions of the `Clip` class are simple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: An animation clip always modifies the same joints. There is no need to re-set
    the pose that is sampled into so that it is the bind pose every frame. However,
    when switching animations, there is no guarantee that two clips will animate the
    same tracks. It's a good idea to reset the pose that is sampled into so that it
    is the bind pose whenever we switch animation clips!
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you will learn how to load the rest pose of a character
    from a glTF file. The rest pose is important; it's the pose that a character is
    in when it's not animated.
  prefs: []
  type: TYPE_NORMAL
- en: glTF – loading the rest pose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we will assume that a glTF file only contains one animated character.
    It's safe to assume that the entire hierarchy of the glTF file can be treated
    as the skeleton of the model. This makes loading the rest pose easy as the rest
    pose becomes the hierarchy in its initial configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Before loading the rest pose, you need to create several helper functions. These
    functions are internal to the glTF loader and should not be exposed in the header
    file. Create a new namespace in `GLTFLoader.cpp` and call it `GLTFHelpers`. All
    the helper functions are created in this namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the helper functions that are needed to load
    the rest pose from a glTF file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, implement a helper function to get the local transform of `cgltf_node`.
    A node can store its transform either as a matrix or as a separate position, rotation,
    and scale components. If the node stores its transformation as a matrix, use the
    `mat4ToTransform` decomposition function; otherwise, create the components as
    needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, implement a helper function to get the index of `cgltf_node` from an
    array. The `GLTFNodeIndex` function can perform a simple linear lookup by looping
    through all the nodes in a `.gltf` file and returning the index of the node that
    you are searching for. If the index is not found, return `-1` to signal an invalid
    index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'With these helper functions, loading the rest pose takes very little work.
    Loop through all the nodes in the current glTF file. For each node, assign the
    local transform to the pose that will be returned. You can find the parent of
    a node using the `GetNodeIndex` helper function, which returns `-1` if a node
    has no parent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the following section, you will learn how to load joint names from a glTF
    file. These joint names appear in the same order as the rest pose joints. Knowing
    the joint names can be helpful to debug what a skeleton looks like. Joint names
    can also be used to retrieve a joint by something other than an index. The animation
    system you will build in this book does not support joint lookup by name, only
    index.
  prefs: []
  type: TYPE_NORMAL
- en: glTF – loading joint names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point, you might want to know the name assigned to each joint that is
    loaded. This can help make debugging or building tools easier. To load the names
    of every joint in the same order that you loaded the joints for the rest pose
    in, loop through the joints and use the name accessor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `LoadJointNames` function in `GLTFLoader.cpp`. Don''t forget
    to add the function declaration to `GLTFLoader.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Joint names are extremely useful for debugging. They let you associate the index
    of a joint with a name, so you know what the data represents. In the following
    section, you will learn how to load animation clips from glTF files.
  prefs: []
  type: TYPE_NORMAL
- en: glTF – loading animation clips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To generate pose data at runtime, you need to be able to load animation clips.
    As with the rest pose, this requires a few helper functions.
  prefs: []
  type: TYPE_NORMAL
- en: The first helper function you need to implement, `GetScalarValues`, reads the
    floating-point values of a `gltf` accessor. This can be done with the `cgltf_accessor_read_float`
    helper function.
  prefs: []
  type: TYPE_NORMAL
- en: The next helper function, `TrackFromChannel`, does most of the heavy lifting.
    It converts a glTF animation channel into a `VectorTrack` or a `QuaternionTrack`.
    glTF animation channels are documented at [https://github.com/KhronosGroup/glTF-Tutorials/blob/master/gltfTutorial/gltfTutorial_007_Animations.md](https://github.com/KhronosGroup/glTF-Tutorials/blob/master/gltfTutorial/gltfTutorial_007_Animations.md).
  prefs: []
  type: TYPE_NORMAL
- en: The `LoadAnimationClips` function should return a vector of clips objects. This
    isn't optimal; it's done to make the loading API easier to use. If performance
    is a concern, consider passing the result vector as a reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to load animations from a glTF file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `GetScalarValues` helper function in `GLTFLoader.cpp` in the
    `GLTFHelpers` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `TrackFromChannel` helper function in `GLTFLoader.cpp`. Start
    the function implementation by setting the `Track` interpolation. To do this,
    make sure the `Interpolation` type of the track matches the `cgltf_interpolation_type`
    type of the sampler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The sampler input is an accessor to the animation timeline. The sampler output
    is an accessor to the animation values. Use `GetScalarValues` to convert these
    accessors into linear arrays of floating-point numbers. The number of frames the
    number of elements in the sampler input. The number of components per frame (`vec3`
    or `quat`) is the number of value elements divided by the number of timeline elements.
    Resize the track to have enough room to store all the frames:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To parse the `time` and `value` arrays into frame structures, loop through
    every frame in the sampler. For each frame, set the time, then read the input
    tangent, the value, then the output tangent. Input and output tangents are only
    available if the sampler is cubic; if it is not, these should default to `0`.
    A local `offset` variable needs to be used to deal with cubic tracks since the
    input and output tangents are as large as the number of components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `LoadAnimationClips` function in `GLTFLoader.cpp`; don''t forget
    to add the declaration of the function to `GLTFLoader.h`. Loop through all the
    clips in the provided `gltf_data`. For every clip, set its name. Loop through
    all of the channels in the clip and find the index of the node that the current
    channel affects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Each channel of a glTF file is an animation track. Some nodes might only animate
    their position, while others might animate the position, rotation, and scale.
    Check the type of channel that is parsed and call the `TrackFromChannel` helper
    function to convert it into an animation track. The `[] operator` of the `Track`
    class either retrieves the current track or creates a new one. This means the
    `TransformTrack` function for the node that you are parsing is always valid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After all the tracks in a clip have been populated, call the `ReclaculateDuration`
    function of the clip. This ensures that the playback happens in the proper time
    range:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Being able to load animation clips and sample them into poses is about half
    of the work involved in animation programming. You can load an animation clip,
    sample it as the application updates, and use debug lines to draw the pose. The
    result is an animated skeleton. In the next chapter, you will learn how to use
    this animated skeleton to deform a mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you implemented the `Pose` and `Clip` classes. You learned
    how to load the rest pose out of a glTF file, as well as how to load animation
    clips. You also learned how to sample an animation clip to produce a pose.
  prefs: []
  type: TYPE_NORMAL
- en: The downloadable content for this book can be found on GitHub at [https://github.com/PacktPublishing/Game-Animation-Programming](https://github.com/PacktPublishing/Game-Animation-Programming).
    The sample in `Chapter09/Sample01` loads a glTF file and uses the `DebugDraw`
    functions to draw both the rest pose and the currently animated pose. To draw
    a bone using debug lines, draw a line from the position of the joint to the position
    of its parent.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that not all clips animate every joint of a pose. Any time the
    animation clip that you are sampling changes, the post it is sampled into needs
    to be reset. Resetting a pose is easy—assign to it the value of the rest pose.
    This is demonstrated in the code samples for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to skin an animated mesh. Once you know
    how to skin a mesh, you will be able to display an animated model.
  prefs: []
  type: TYPE_NORMAL
