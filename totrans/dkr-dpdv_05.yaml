- en: '4: The big picture'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea of this chapter is to paint a quick big-picture of what Docker is all
    about before we dive in deeper in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll break this chapter into two:'
  prefs: []
  type: TYPE_NORMAL
- en: The Ops perspective
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Dev perspective
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Ops Perspective section, we’ll download an image, start a new container,
    log in to the new container, run a command inside of it, and then destroy it.
  prefs: []
  type: TYPE_NORMAL
- en: In the Dev Perspective section, we’ll focus more on the app. We’ll pull some
    app-code from GitHub, inspect a Dockerfile, containerize the app, run it as a
    container.
  prefs: []
  type: TYPE_NORMAL
- en: These two sections will give you a good idea of what Docker is all about and
    how some of the major components fit together. **It is recommended that you read
    both sections to get the *dev* and the *ops* perspectives.** DevOps anyone?
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry if some of the stuff we do here is totally new to you. We’re not
    trying to make you an expert by the end of this chapter. This is about giving
    you a *feel* of things — setting you up so that when we get into the details in
    later chapters, you have an idea of how the pieces fit together.
  prefs: []
  type: TYPE_NORMAL
- en: All you need, to follow along, is a single Docker host with an internet connection.
    This can be Linux or Windows, and it doesn’t matter if it’s a VM on your laptop,
    an instance in the public cloud, or a bare metal server in your data center. All
    it needs, is to be running Docker with a connection to the internet. We’ll be
    showing examples using Linux and Windows!
  prefs: []
  type: TYPE_NORMAL
- en: Another great way to get Docker, and get it fast, is Play With Docker (PWD).
    Play With Docker is a web-based Docker playground that you can use for free. Just
    point your web browser to https://play-with-docker.com/ and you’re ready to go
    (you may need a Docker Hub account to be able to login). It’s my favourite way
    of spinning up temporary Docker environment!
  prefs: []
  type: TYPE_NORMAL
- en: The Ops Perspective
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you install Docker, you get two major components:'
  prefs: []
  type: TYPE_NORMAL
- en: the Docker client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the Docker daemon (sometimes called “server” or “engine”)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The daemon implements the [Docker Engine API](https://docs.docker.com/engine/api/v1.35/).
  prefs: []
  type: TYPE_NORMAL
- en: In a default Linux installation, the client talks to the daemon via a local
    IPC/Unix socket at `/var/run/docker.sock`. On Windows this happens via a named
    pipe at `npipe:////./pipe/docker_engine`. You can use the `docker version` command
    to test that the client and daemon (server) are running and talking to each other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`If you get a response back from the `Client` **and** `Server`, you’re good
    to go. If you are using Linux and get an error response from the Server component,
    try the command again with `sudo` in front of it: `sudo docker version`. If it
    works with `sudo` you will need to add your user account to the local `docker`
    group, or prefix the remainder of the commands in the book with `sudo`.'
  prefs: []
  type: TYPE_NORMAL
- en: Images
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s useful to think of a Docker image as an object that contains an OS filesystem
    and an application. If you work in operations, it’s like a virtual machine template.
    A virtual machine template is essentially a stopped virtual machine. In the Docker
    world, an image is effectively a stopped container. If you’re a developer, you
    can think of an image as a *class*.
  prefs: []
  type: TYPE_NORMAL
- en: Run the `docker image ls` command on your Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`If you are working from a freshly installed Docker host, or Play With Docker,
    you will have no images and will look like the output above.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting images onto your Docker host is called “pulling”. If you are following
    along with Linux, pull the `ubuntu:latest` image. If you are following along on
    Windows, pull the `microsoft/powershell:nanoserver` image.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`Run the `docker image ls` command again to see the image you just pulled.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`We’ll get into the details of where the image is stored and what’s inside
    of it in later chapters. For now, it’s enough to know that an image contains enough
    of an operating system (OS), as well as all the code and dependencies to run whatever
    application it’s designed for. The `ubuntu` image that we’ve pulled has a stripped-down
    version of the Ubuntu Linux filesystem, including a few of the common Ubuntu utilities.
    The `microsoft/powershell` image, pulled in the Windows example, contains a Windows
    Nano Server OS with PowerShell.'
  prefs: []
  type: TYPE_NORMAL
- en: If you pull an application container such as `nginx` or `microsoft/iis`, you
    will get an image that contains some OS, as well as the code to run either `NGINX`
    or `IIS`.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also worth noting that each image gets its own unique ID. When working
    with images, you can refer to them using either `IDs` or names. If you’re working
    with image ID’s, it’s usually enough just to type the first few characters of
    the ID — as long as it’s unique, Docker will know which image you mean.
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we have an image pulled locally, we can use the `docker container run`
    command to launch a container from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`For Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`Look closely at the output from the previous commands. You should notice that
    the shell prompt has changed in each instance. This is because the `-it` flags
    switch your shell into the terminal of the container — you are literally inside
    of the new container!'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine that `docker container run` command. `docker container run` tells
    the Docker daemon to start a new container. The `-it` flags tell Docker to make
    the container interactive and to attach our current shell to the container’s terminal
    (we’ll get more specific about this in the chapter on containers). Next, the command
    tells Docker that we want the container to be based on the `ubuntu:latest` image
    (or the `microsoft/powershell:nanoserver` image if you’re following along with
    Windows). Finally, we tell Docker which process we want to run inside of the container.
    For the Linux example we’re running a Bash shell, for the Windows container were
    running PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: Run a `ps` command from inside of the container to list all running processes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`**Windows example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`The Linux container only has two processes:'
  prefs: []
  type: TYPE_NORMAL
- en: PID 1\. This is the `/bin/bash` process that we told the container to run with
    the `docker container run` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PID 9\. This is the `ps -elf` command/process that we ran to list the running
    processes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The presence of the `ps -elf` process in the Linux output can be a bit misleading,
    as it is a short-lived process that dies as soon as the `ps` command exits. This
    means the only long-running process inside of the container is the `/bin/bash`
    process.
  prefs: []
  type: TYPE_NORMAL
- en: The Windows container has a lot more going on. This is an artefact of the way
    the Windows Operating System works. However, even though the Windows container
    has a lot more processes than the Linux container, it is still a lot less than
    a regular Windows **Server**.
  prefs: []
  type: TYPE_NORMAL
- en: Press `Ctrl-PQ` to exit the container without terminating it. This will land
    your shell back at the terminal of your Docker host. You can verify this by looking
    at your shell prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are back at the shell prompt of your Docker host, run the `ps`
    command again.
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`**Windows example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`Notice how many more processes are running on your Docker host compared to
    their respective containers. Windows containers run far fewer processes than Windows
    hosts, and Linux containers run far less than Linux hosts.'
  prefs: []
  type: TYPE_NORMAL
- en: In a previous step, you pressed `Ctrl-PQ` to exit from the container. Doing
    this from inside of a container will exit you from the container without killing
    it. You can see all running containers on your system using the `docker container
    ls` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`The output above shows a single running container. This is the container that
    you created earlier. The presence of the container in this output proves that
    it’s still running. You can also see that it was created 7 minutes ago and has
    been running for 7 minutes.'
  prefs: []
  type: TYPE_NORMAL
- en: Attaching to running containers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can attach your shell to the terminal of a running container with the `docker
    container exec` command. As the container from the previous steps is still running,
    let’s make a new connection to it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux example:**'
  prefs: []
  type: TYPE_NORMAL
- en: This example references a container called “vigilant_borg”. The name of your
    container will be different, so remember to substitute “vigilant_borg” with the
    name or ID of the container running on your Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`**Windows example:**'
  prefs: []
  type: TYPE_NORMAL
- en: This example references a container called “pensive_hamilton”. The name of your
    container will be different, so remember to substitute “pensive_hamilton” with
    the name or ID of the container running on your Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`Notice that your shell prompt has changed again. You are logged in to the
    container again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The format of the `docker container exec` command is: `docker container exec
    <options> <container-name or container-id> <command/app>`. In our example, we
    used the `-it` options to attach our shell to the container’s shell. We referenced
    the container by name, and told it to run the bash shell (PowerShell in the Windows
    example). We could easily have referenced the container by its hex ID.'
  prefs: []
  type: TYPE_NORMAL
- en: Exit the container again by pressing `Ctrl-PQ`.
  prefs: []
  type: TYPE_NORMAL
- en: Your shell prompt should be back to your Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: Run the `docker container ls` command again to verify that your container is
    still running.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`Stop the container and kill it using the `docker container stop` and `docker
    container rm` commands. Remember to substitute the names/IDs of your own containers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`Verify that the container was successfully deleted by running the `docker
    container ls` command with the `-a` flag. Adding `-a` tells Docker to list all
    containers, even those in the stopped state.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`### The Dev Perspective'
  prefs: []
  type: TYPE_NORMAL
- en: Containers are all about the apps!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll clone an app from a Git repo, inspect its Dockerfile,
    containerize it, and run it as a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Linux app can be cloned from: https://github.com/nigelpoulton/psweb.git'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Windows app can be cloned from: https://github.com/nigelpoulton/dotnet-docker-samples.git'
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this section will walk you through the Linux example. However, both
    examples are containerizing simple web apps, so the process is the same. Where
    there are differences in the Windows example we will highlight them to help you
    follow along.
  prefs: []
  type: TYPE_NORMAL
- en: Run all of the following commands from a terminal on your Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: Clone the repo locally. This will pull the application code to your local Docker
    host ready for you to containerize it.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to substitute the following repo with the Windows repo if you are following
    along with the Windows example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`Change directory into the cloned repo’s directory and list its contents.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`For the Windows example you should `cd` into the `dotnet-docker-samples\aspnetapp`
    directory.'
  prefs: []
  type: TYPE_NORMAL
- en: The Linux example is a simple nodejs web app. The Windows example is a simple
    ASP.NET Core web app.
  prefs: []
  type: TYPE_NORMAL
- en: Both Git repos contain a file called `Dockerfile`. A Dockerfile is a plain-text
    document describing how to build an app into a Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: List the contents of the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`The contents of the Dockerfile in the Windows example are different. However,
    this isn’t important at this stage. We’ll cover Dockerfiles in more detail later
    in the book. For now, it’s enough to understand that each line represents an instruction
    that is used to build an image.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point we have pulled some application code from a remote Git repo. We
    also have a Dockerfile containing instructions on how to build the app into a
    Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `docker image build` command to create a new image using the instructions
    in the Dockerfile. This example creates a new Docker image called `test:latest`.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to perform this command from within the directory containing the app
    code and Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`> **Note:** It may take a long time for the build to finish in the Windows
    example. This is because of the size and complexity of the image being pulled.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the build is complete, check to make sure that the new `test:latest` image
    exists on your host.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`You now have a newly-built Docker image with the app inside.'
  prefs: []
  type: TYPE_NORMAL
- en: Run a container from the image and test the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`Open a web browser and navigate to the DNS name or IP address of the Docker
    host that you are running the container from, and point it to port 8080\. You
    will see the following web page.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are following along with Docker for Windows or Docker for Mac, you will
    be able to use `localhost:8080` or `127.0.0.1:8080`. If you’re following along
    on Play with Docker, you will be able to click the `8080` hyperlink above the
    terminal screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1](images/figure4-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`Open a web browser and navigate to the DNS name or IP address of the Docker
    host that you are running the container from, and point it to port 8080\. You
    will see the following web page.'
  prefs: []
  type: TYPE_NORMAL
- en: The same rules apply if you’re following along with Docker for Windows or Play
    with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2](images/figure4-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2
  prefs: []
  type: TYPE_NORMAL
- en: Well done. You’ve taken some application code from a remote Git repo and built
    it into a Docker image. You then ran a container from it. We call this “containerizing
    an app”.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the Op section of the chapter you; downloaded a Docker image, launched a
    container from it, logged into the container, executed a command inside of it,
    and then stopped and deleted the container.
  prefs: []
  type: TYPE_NORMAL
- en: In the Dev section, you containerized a simple application by pulling some source
    code from GitHub and building it into an image using instructions in a Dockerfile.
    You then ran the containerized app.
  prefs: []
  type: TYPE_NORMAL
- en: This *big picture* view should help you with the up-coming chapters where we
    will dig deeper into images and containers.[PRE23]
  prefs: []
  type: TYPE_NORMAL
