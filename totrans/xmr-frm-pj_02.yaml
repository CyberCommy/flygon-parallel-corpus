- en: Building Our First Xamarin.Forms App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create a to-do list app and, in doing so, we'll explore
    all the bits and pieces of what makes an app. We will look at creating pages,
    adding content to those pages, navigating between them, and creating a stunning
    layout. Well, *stunning* might be a bit of a stretch, but we will be sure to design
    the app so that you can tweak it to your needs once it is complete!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting data locally on a device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the repository pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What MVVM is and why it's a great fit for Xamarin.Forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Xamarin.Forms pages (as Views) and navigating between them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Xamarin.Forms Control in XAML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using data binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using styling in Xamarin.Forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to complete this project, we need to have Visual Studio for Mac or
    PC installed, as well as the Xamarin components. See [Chapter 1](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml), *Introduction
    to Xamarin,* for more details on how to set up your environment.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everyone needs a way of keeping track of things. To kick-start our Xamarin.Forms
    development learning curve, we've decided that a to-do list app is the best way
    to get started and also to help you keep track of things. A simple, classic, win-win
    scenario.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by creating the project and defining a repository in which to
    store the items of a to-do list. We will render these items in list form and allow
    the user to edit them using a detailed user interface. We will also look at how
    to store the to-do list items locally on the device through **SQLite-net** so
    they don't get lost when we exit the app.
  prefs: []
  type: TYPE_NORMAL
- en: The build time for this project is about two hours.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to start coding! Before moving on, however, make sure you have your
    development environment set up as described in [Chapter 1](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml), *Introduction
    to Xamarin*.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will be a classic File | New Project chapter, guiding you step-by-step
    through the process of creating your first to-do list app. There will be no downloads
    required whatsoever.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Xamarin app can essentially be created using one of two code-sharing strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: As a shared project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a .NET Standard library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first choice, a **shared project**, will create a project type that is essentially
    a linked copy of each file in it. The file exists in one common place and is linked
    in at build time. This means that we cannot determine the runtime when writing
    the code and we are only allowed to access the APIs that are available on each
    target platform. It does allow us to use conditional compilations, which can be
    useful in certain circumstances but can also be confusing for someone who reads
    the code later on. Going for the shared project option may also be a bad choice
    as it locks down our code to specific platforms.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the second choice, a .**NET Standard library**. This is, of course,
    a matter of choice and both ways will still work. With a little imagination, you
    can still follow this chapter, even if you select a shared project.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the new project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step is to create a new Xamarin.Forms project. Open up Visual Studio
    2017 and click on File | New| Project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0968d7e6-303e-4f48-886e-6bdac6b71cbd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will open the New Project dialog box. Expand the Visual C# node and click
    on Cross-Platform. Select the Mobile App (Xamarin.Forms) item in the list. Complete
    the form by naming your project and click OK**.** Make sure to name the project `DoToo`
    to avoid namespace issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd6167ef-879a-4903-99a3-52c864466596.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to select a project template and a Code Sharing Strategy to
    use. Select Blank App to create a bare Xamarin.Forms app and change the Code Sharing
    Strategy to .NET Standard. Finalize the setup by clicking OK and wait for Visual
    Studio to create the necessary projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/831eed3d-b0da-47d5-b6ba-bb04056ab66f.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations, we've just created our first Xamarin.Forms app!
  prefs: []
  type: TYPE_NORMAL
- en: Examining the files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The template selected has now created four projects:'
  prefs: []
  type: TYPE_NORMAL
- en: DoToo:This is a .NET Standard library targeting .NET Standard 2.0. It can be
    imported by any runtime that supports this version of .NET Standard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DoToo.Android:This is an Android app for bootstrapping Xamarin.Forms on Android.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DoToo.iOS:This is an iOS app for bootstrapping Xamarin.Forms on iOS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DoToo.UWP:This is a **Universal Windows Platform** (**UWP**) app for bootstrapping
    Xamarin.Forms on UWP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The three platform-specific libraries reference the .NET Standard library. Most
    of our code will be written in the .NET Standard library and only a small portion
    of platform-specific code will be added to each target platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project should now look like as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76f6af76-cc51-4298-961f-31dbfd108828.png)'
  prefs: []
  type: TYPE_IMG
- en: We will highlight a few important files in each project so that we can have
    a basic understanding of what they each are. We'll go through these project by
    project.
  prefs: []
  type: TYPE_NORMAL
- en: DoToo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the .NET Standard library that all the platform-specific projects reference
    and the location to which most of our code will be added. The following screenshot
    displays the structure of the .NET Standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/337ef0a9-629d-4ec7-a6a8-ecbcc20f73f8.png)'
  prefs: []
  type: TYPE_IMG
- en: Under Dependencies, we will find references to external dependencies such as
    Xamarin.Forms. We will update the Xamarin.Forms package version in the *Updating
    Xamarin.Forms packages*section. We will add more dependencies as we progress throughout
    the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `App.xaml` file is a XAML file that represents the app. This is a good place
    to put application-wide resources, which we will do later on. We can also see
    the `App.xaml.cs` file, which contains the startup code and some lifetime events
    to which we can add custom code, such as `OnStart` or `OnSleep`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open up `App.xaml.cs`, we can see the starting point for our Xamarin.Forms
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The assignment of a page to the `MainPage`property is particularly important,
    as this is what determines which page will be displayed to the user first. In
    the template, this is the `DoToo.MainPage()` class.
  prefs: []
  type: TYPE_NORMAL
- en: The last two files are the `MainPage.xaml` file, which contains the first page
    of the application and the code-behind file, which is called `MainPage.xaml.cs`.
    These files will be removed in order to comply with the **Model–View–ViewModel** (**MVVM**)
    naming standards.
  prefs: []
  type: TYPE_NORMAL
- en: DoToo.Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the Android app. It only has one file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e61e5203-3712-4ef3-9b7b-62f81f601a4e.png)'
  prefs: []
  type: TYPE_IMG
- en: The important file here is `MainActivity.cs`. This contains the entry point
    for our application if we run the app on an Android device. The entry point method
    for an Android app is `OnCreate(...)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open the `MainActivity.cs` and examine the `OnCreate(...)` method, it
    should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines assign resources for the `Tabbar` and the `Toolbar`. We
    then call the base method, followed by the mandatory initialization of Xamarin.Forms.
    Finally, we have the call to load the Xamarin.Forms application that we have defined
    in the .NET Standard library.
  prefs: []
  type: TYPE_NORMAL
- en: We don't need to understand these files in detail, just remember that they are
    important for the initialization of our app.
  prefs: []
  type: TYPE_NORMAL
- en: DoToo.iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the iOS app. It contains a few more files than its Android counterpart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64c398b1-b14b-4851-b11e-4e2342e5152b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `AppDelegate.cs` file is the entry point for an iOS app. This file contains
    a method called `FinishedLaunching(...)`, which is where we start writing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The code starts off by initializing Xamarin.Forms and then loads the application
    from the .NET Standard library. After that, it returns the control to iOS. It
    must do this within 17 seconds, or the app will be terminated by the OS.
  prefs: []
  type: TYPE_NORMAL
- en: The `info.plist` file is an iOS-specific file that contains information about
    the app, such as the bundle ID and its provisioning profiles. It has a graphical
    editor, but can also be edited in any text editor, since it's a standard XML file.
  prefs: []
  type: TYPE_NORMAL
- en: The `Entitlements.plist` file is also an iOS-specific file that configures the
    entitlements that we want our app to take advantage of, such as **in-app purchases** or **push
    notifications**.
  prefs: []
  type: TYPE_NORMAL
- en: As with the Android app's startup code, we don't need to understand what is
    going on here in detail, other than that it's important for the initialization
    of our app.
  prefs: []
  type: TYPE_NORMAL
- en: DoToo.UWP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last project to examine is the UWP app. The file structure of the project
    looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a326f5d0-d1d7-40e4-8a1d-946afe2be4f9.png)'
  prefs: []
  type: TYPE_IMG
- en: It has an `App.xaml` file, which is similar to the one in the .NET Standard
    library, but specific to the UWP app. It also has a related file called `App.xaml.cs`.
    This contains a method called `OnLaunched(...)`, which is the entry point for
    a UWP app. This file is quite large, so we won't be printing it out here, but
    do open it up and see if we can locate the Xamarin.Forms initialization code in
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Xamarin.Forms packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After creating the project, we should always update our Xamarin.Forms packages
    to the latest version. To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on our Solution in the Solution Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on Manage NuGet Packages for Solution...:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b16aacf6-cee3-4980-9ac8-cf1940d124bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This brings up the NuGet Package Manager in Visual Studio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/add08ce1-c4cd-4a91-b7a6-b1678169e278.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To update Xamarin.Forms to the latest version, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the Updates tab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check Xamarin.Forms and click Update
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept any license agreements
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep an eye on the output pane and wait for all the packages to be updated.
    However, ensure that you don't update any Android packages manually, as this might
    break your application.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the MainPage file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Xamarin.Forms, we have the concept of pages. This is not the case, however,
    for the MVVM architectural pattern, which instead uses the concept of views. Views
    are the same thing as pages but they are not suffixed with -Page, so we will delete
    the `MainPage` generated by the template. We will go into more detail on MVVM
    shortly, but for the time being, we will remove the `MainPage.cs` class from the
    solution. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `MainPage.xaml` file in the `DoToo` project (the .NET Standard
    library)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Delete and confirm the delete action
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a repository and a TodoItem model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any good architecture always involves abstraction. In this app, we need something
    to store and retrieve the items of our to-do list. These will later be stored
    in an SQLite database, but adding a reference to the database directly from the
    code that is responsible for the GUI is generally a bad idea.
  prefs: []
  type: TYPE_NORMAL
- en: What we need instead is something to abstract our database from the GUI. For
    this app, we've chosen to use a simple repository pattern. This repository is
    simply a class that sits in between the SQLite database and our upcoming `ViewModels`.
    This is the class that handles the interaction with the view, which in turn handles
    the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: The repository will expose methods for getting items, adding items, and updating
    items, as well as events that allow other parts of the app to react to changes
    in the repository. It will be hidden behind an interface so that we can replace
    the entire implementation later on, without modifying anything but a line of code
    in the initialization of the app. This is made possible by **Autofac**.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a to-do list item
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start off by creating a `TodoItem` class, which will represent a single
    item in the list. This will be a simple **Plain Old CLR Object** (**POCO**) class,
    where **CLR** stands from **Common Language Runtime**. In other words, this will
    be a .NET class without any dependencies on third-party assemblies. To create
    the class, follow the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the .NET Standard library project, create a folder called `Models`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a class called `TodoItem.cs` in that folder and enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The code is pretty self-explanatory; it's a simple **Plain Old CLR Object** (**POCO**)
    class that only contains properties and no logic. We have a `Title` that describes
    what we want to be done, a flag (`Completed`) that determines if the to-do list
    item is done, a `Due` date when we expect it to be done, and a unique `id` that
    we need later on for the database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a repository and its interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the `TodoItem` class, let''s define an interface that describes
    a repository to store our to-do list items:'
  prefs: []
  type: TYPE_NORMAL
- en: In the .NET Standard library project, create a folder called `Repositories`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an interface called `ITodoItemRepository.cs` in the `Repositories` folder
    and write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The eagle-eyed among you might notice that we are not defining a `Delete` method
    in this interface. This is definitely something that should be there in a real-world
    app. While the app that we are creating in this chapter will not support the deleting
    of items, we are quite sure that you could add this yourself if you want to!
  prefs: []
  type: TYPE_NORMAL
- en: This interface defines everything we need for our app. It is there to create
    logical insulation between your implementation of a repository and the user of
    that repository. If any other part of your application wants an instance of `TodoItemRepository`,
    we can pass it any object that implements `ITodoItemRepository`, regardless of
    how it's implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having that said, let''s implement `ITodoItemRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class called `TodoItemRepository.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code is the bare-bones implementation of the interface, except for the
    `AddOrUpdate(...)` method. This handles a small piece of logic that states that
    if the ID of an item is `0`, it's a new item. Any item with an ID larger than
    `0` is stored in the database. This is because the database assigns a value larger
    than zero when we create rows in a table.
  prefs: []
  type: TYPE_NORMAL
- en: There are also two events defined in the preceding code. These will be used
    for notifying any subscriber that items have been updated or added.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting SQLite to persist data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have an interface and a skeleton to implement that interface. The last
    thing we need to do to finish this section is to connect SQLite inside the implementation
    of the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the SQLite NuGet package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To access SQLite in this project, we need to add a NuGet package called sqlite-net-pcl
    to the .NET Standard library project. To do this, right-click on the Dependencies
    item under the DoToo project node of the Solution and click Manage NuGet Packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9325577f-3323-4e97-b089-91787f868c17.png)'
  prefs: []
  type: TYPE_IMG
- en: You might notice that the NuGet package is suffixed with -pcl. This is an example
    of what happens when naming conventions go wrong. This package actually supports
    .NET Standard 1.0, even though the name says **Portable Class Library** (**PCL**),
    which was the predecessor to .NET Standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings up the NuGet Package Manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bb454fb-b159-4236-8fb3-6d5dc3500318.png)'
  prefs: []
  type: TYPE_IMG
- en: Click Browse and enter sqlite-net-pcl in the search box
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the package by Frank A. Krueger and click Install
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the installation to complete. We'll then add some code to the `TodoItem`
    class and the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the TodoItem class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since SQLite is a relational database, it needs to know some basic information
    about how to create the tables that will store our objects. This is done using
    attributes, which are defined in the SQLite namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up the `Models/TodoItem`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `using SQLite` statement at the start of the file right below the existing `using`
    statements, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `PrimaryKey` and `AutoIncrement` attributes right before the ID property,
    as demonstrated in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `PrimaryKey` attribute instructs SQLite that the `Id` property is the primary
    key of the table. The `AutoIncrement` attribute will make sure that the value
    of `Id` will be increased by one for each new `TodoItem` class that is added to
    the table.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a connection to the SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now add all the code needed to communicate with the database. The first
    thing we need to do is to define a connection field that will hold the connection
    to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up the `Repositories/TodoItemRepository` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a** `using SQLite` **statement at the start of the file right below the
    existing `using` statements, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following field right below the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The connection needs to be initialized. Once it is initialized, it can be reused
    throughout the lifespan of the repository. Since the method is asynchronous, it
    cannot be called from the constructor without introducing a locking strategy.
    To keep things simple, we will simply call it from each of the methods that are
    defined by the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the following code to the `TodoItemRepository` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `using System.IO` statement at the start of the file so that we can use
    `Path.Combine(...)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The method begins by checking whether we already have a connection. If we do,
    we can simply return. If we don't have a connection set up, we define a path on
    the disk to indicate where we want the database file to be located. In this case,
    we will choose the `MyDocuments` folder. Xamarin will find the closest match to
    this on each platform that we target.
  prefs: []
  type: TYPE_NORMAL
- en: We then create the connection and store the reference to that connection in
    the `connection` field. We need to make sure that SQLite has created a table that
    mirrors the schema of the `TodoItem` table. To make the development of the app
    easier, we add a default to-do list item if the `TodoItem` table is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Get, Add, and Update methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The only thing left to do in the repository is to implement the methods for
    getting, adding, and updating items:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate the `GetItems()` method in the `TodoItemRepository` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `GetItems()` method with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To ensure that the connection to the database is valid, we call the `CreateConnection()`
    method we created in the previous section. When this method returns, we can make
    sure that it is initialized and that the `TodoItem` table has been created.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the connection to access the `TodoItem` table and return a `List<TodoItem>`
    that contains all the to-do list items in the database.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite supports querying data using **Language Integrated Query** (**LINQ**).
    You could play around with this after the project is complete to get a better
    understanding of how to work with databases inside your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for adding items is even simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate the `AddItem()` method in the `TodoItemRepository` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `AddItem()` method with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The call to `CreateConnection()` makes sure that we have a connection in the
    same way as we did for the `GetItems()` method. After this, we perform the actual
    insertion into the database using the `InsertAsync(...)` method on the connection
    object. After an item has been inserted into the table, we invoke the `OnItemAdded`
    event to notify any subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to update an item is basically the same as the `AddItem()` method,
    but also includes calls to `UpdateAsync` and `OnItemUpdated`. Let''s finish up
    by updating the `UpdateItem()` method with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate the `UpdateItem()` method in the `TodoItemRepository` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `UpdateItem()` method with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we'll get started with MVVM. Grab a cup of coffee and let's
    get started.
  prefs: []
  type: TYPE_NORMAL
- en: Using MVVM – creating Views and ViewModels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MVVM is all about the separation of concerns. Each part has a specific meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**:This relates to anything that represents data and that can be referenced
    by the `ViewModel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**:This is the visual component. In Xamarin.Forms, this is represented
    by a page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ViewModel**:This is a class that acts as the glue between the Model and the
    View'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our app, we could say that the Model is the repository and the to-do list
    items it returns. The `ViewModel` has a reference to this repository and exposes
    properties that the View can bind to. The ground rule is that any logic should
    reside in the ViewModel and no logic should be in the View. The View should know
    how to present data, such as converting a Boolean value to *Yes* or *No*.
  prefs: []
  type: TYPE_NORMAL
- en: MVVM can be implemented in many ways and there are quite a few frameworks that
    we could use. In this chapter, we have chosen to keep things simple and implement
    MVVM in a vanilla way, without any framework at all.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a ViewModel base class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `ViewModel` is the mediator between the View and the Model. We can benefit
    greatly by creating a common base class for all our `ViewModels` to inherit from.
    To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder called `ViewModels` in the `DoToo` .NET Standard project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class called `ViewModel` in the `ViewModels` folder .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Resolve references to `System.ComponentModel` and Xamarin.Forms and add the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ViewModel` class is a base class for all `ViewModels`. This is not meant
    to be instantiated on its own, so we mark it as abstract. It implements `INotifyPropertyChanged`, which
    is an interface defined in `System.ComponentModel` in the .NET base class libraries.
    This interface only defines one thing: the `PropertyChanged` event. Our `ViewModel`
    must raise this event whenever we want the GUI to be aware of any changes to a
    property. This can be done manually, by adding code to a setter in a property,
    or by using an **i****ntermediate language** (**IL**) weaver such as `PropertyChanged.Fody`.
    We will talk about this in detail in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: We are also taking a little shortcut here by adding an `INavigation` property
    in the `ViewModel`. This will help us with navigation later on. This is also something
    that can (and should) be abstracted, since we don't want the `ViewModel` to be
    dependent on Xamarin.Forms, in order to be able to reuse the `ViewModels` on any
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing PropertyChanged.Fody
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The traditional way of implementing a `ViewModel` is to inherit from a base
    class (such as the `ViewModel` that we defined previously) and then add code that
    might look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Each property that we want to add to a `ViewModel` yields six lines of code.
    Not too bad, you might think. However, considering that a `ViewModel` could potentially contain
    10 to 20 properties, this rapidly turns into a lot of code. We can do better than
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In just a few simple steps, we can use a tool called `PropertyChanged.Fody`
    to automatically inject almost all the code during the build process:'
  prefs: []
  type: TYPE_NORMAL
- en: In the .NET Standard library, install the `PropertyChanged.Fody` NuGet package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `FodyWeavers.xml` and add the following XML to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`PropertyChanged.Fody` will scan the assembly for any class that implements
    the `INotifyPropertyChanged` interface and adds the code needed to raise the `PropertyChanged`
    event. It will also take care of dependencies between properties, meaning that
    if you have a property that returns values based on two other properties, it will
    be raised if either of those two values changes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is that the test class we had previously is reduced to a single
    line of code per property. This makes the code base more readable because everything
    happens behind the scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It is worth noting that there are a lot of different plugins that can be used
    to make Fody automate tasks, such as logging or method decoration. Check out [https://github.com/Fody/Fody](https://github.com/Fody/Fody)
    for more info.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the MainViewModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up to this point, we have mainly been preparing to write the code that will
    make up the app itself. The `MainViewModel` is the `ViewModel` for the first view
    that will be displayed to the user. It will be responsible for providing data
    and logic to a list of to-do list items. We will create the bare-bones `ViewModels`
    and add code to them as we move through the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class called `MainViewModel` inside the `ViewModels` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following template code and resolve the references:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The structure in this class is something that we will reuse for all the `ViewModels`
    to come.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s summarize the important features we want the `ViewModel` to have:'
  prefs: []
  type: TYPE_NORMAL
- en: We inherit from the `ViewModel` to gain access to shared logic, such as the `INotifyPropertyChanged` interface
    and common navigation code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All dependencies to other classes, such as repositories and services, are passed
    through the constructor of the `ViewModel`. This will be handled by the **d****ependency
    injection** pattern and, more specifically for our case, by Autofac, which is
    the implementation of dependency injection we are using.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use an asynchronous call to `LoadData()` as an entry point to initialize
    the `ViewModel`. Different MVVM libraries might do this in different ways, but
    the basic functionally is the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the TodoItemViewModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `TodoItemViewModel` is the `ViewModel` that represents each item in the
    to-do list on the `MainView`. It will not have an entire view of its own (although
    it could have), but instead will be rendered by a template in the `ListView`.
    We will get back to this when we create the controls for the `MainView`.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing here is that this `ViewModel` will represent a single item,
    regardless of where we choose to render it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `TodoItemViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class called `TodoItemViewModel` inside the `ViewModels` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following template code and resolve the references:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As with any other `ViewModel`, we inherit the `TodoItemViewModel` from `ViewModel`.
    We conform to the pattern of injecting all dependencies in the constructor. In
    this case, we pass an instance of the `TodoItem` class in the constructor that
    the `ViewModel` will use to expose to the view.
  prefs: []
  type: TYPE_NORMAL
- en: The `ItemStatusChanged` event handler will be used later when we want to signal
    to the view that the state of the `TodoItem` has changed. The `Item` property
    allows us to access the item that we passed in.
  prefs: []
  type: TYPE_NORMAL
- en: The `StatusText` property is used for making the status of the to-do item human
    readable in the view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ItemViewModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ItemViewModel` represents the to-do list item in a view that can be used
    to create new items and to edit existing items:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `ViewModels` folder, create a class called `ItemViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the code as following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The pattern is the same as for the previous two `ViewModels`:'
  prefs: []
  type: TYPE_NORMAL
- en: We use dependency injection to pass the `TodoItemRepository` into the `ViewModel`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use inheritance from the `ViewModel` base class to add the common features
    defined by the base class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the MainView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we are done with the `ViewModels`, let''s create the skeleton code
    and the XAML needed for the views. The first view that we are going to create
    is the `MainView`, which is the view that will be loaded first:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder named `Views` in the .NET Standard library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the `Views` folder, select Add, and then click New Item....
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Xamarin.Forms under the Visual C# Items node on the left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SelectContent Page and name it `MainView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click Add to create the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/675b96dd-3e2c-4935-afe2-cda0047cfcf9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s add some content to the newly created view:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `MainView.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove all the template code below the `ContentPage` root node and add the
    XAML code marked in bold in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To be able to access custom converters, we need to add a reference to a local
    namespace. The line  `defines this namespace for us. We will not be using it directly
    in this case, but it's a good idea to have a local namespace defined. If we create
    custom controls, we can then access these by writing something like `<local:MyControl
    />`.`
  prefs: []
  type: TYPE_NORMAL
- en: The `Title` property on the `ContentPage` gives the page a title. Depending
    on the platform we are running on, the title is displayed differently. If we are
    using a standard navigation bar, it will be displayed at the top in both iOS and
    Android, for example. A page should always have a title.
  prefs: []
  type: TYPE_NORMAL
- en: The `ContentPage.Toolbar` node defines a toolbar item for adding new to-do items.
    It will also be rendered differently based on the platform, but it will always
    follow the platform-specific UI guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: A page in Xamarin.Forms (and also an XML document in general) can only have
    one root node. The root node in a Xamarin.Forms page will populate the `Content`
    property of the page itself. Since we want our `MainView` to contain a list of
    items and a button at the top to toggle a filter (to switch between all items
    and only active items), we need to add a `Layout` control to position them on
    the page. The `Grid` is a control that allows you to partition the available space
    based on rows and columns.
  prefs: []
  type: TYPE_NORMAL
- en: For our `MainView`, we want to add two rows. The first row is a space calculated
    by the height of the button (`Height="auto"`) and the second row takes up all
    of the remaining available space for the `Listview` (`Height="*"`). Elements,
    like the `ListView`, are positioned in the grid using the `Grid.Row` and `Grid.Column`
    attributes. Both of these properties default to `0` if they are not specified, just
    like the `Button`.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in how the `Grid` works, you should search for more information
    about Xamarin.Forms `Grid` on the internet or study the official documentation
    at [https://docs.microsoft.com/en-us/xamarin/xamarin-forms/user-interface/layouts/grid](https://docs.microsoft.com/en-us/xamarin/xamarin-forms/user-interface/layouts/grid).
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to wire up the `ViewModel` to the view. This can be done by passing
    the `ViewModel` in the constructor of the view:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up the code-behind file of the `MainView` by expanding the `MainView.xaml`
    file in the Solution Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a <q>using </q>`DoToo.ViewModels` statement at the top of the following
    file the existing `using` statements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the constructor of the class to look like the following code by adding
    the code marked in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We follow the same pattern as we did with the `ViewModels` by passing any dependencies
    through the constructor. A view is always dependent on a `ViewModel`. To simplify
    the project, we also assign the `Navigation` property of the page directly to
    the `Navigation` property defined in the `ViewModel` base class. In a larger project,
    we might want to abstract this property as well, to make sure that we separate
    the `ViewModels` completely from Xamarin.Forms. For the sake of this app, however,
    it is OK to reference it directly.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we assign the `ViewModel` to the `BindingContext` of the page. This
    tells the Xamarin.Forms binding engine to use our `ViewModel` for the bindings
    that we will create later on.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ItemView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next up is the second view. We will use this for adding and editing to-do list
    items:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Content Page (the same way as we created the `MainView`) and name
    it `ItemView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the XAML and make it look like the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As with the `MainView`, we need a title. We will give it a default title of `"New
    todo item"` for now, but we will change this to `"Edit todo item"` when we reuse
    this view for editing later on. The user must be able to save a new or edited
    item, so we have added a toolbar save button. The content of the page uses a `StackLayout`
    to structure the controls. A `StackLayout` adds an element vertically (the default
    option) or horizontally based on the space it calculates that the element takes
    up. This is a CPU-intensive process, so we should only use it on small portions
    of our layout. In the `StackLayout`, we add a `Label` that will be a line of text
    over the `Entry` control that comes underneath it. The `Entry` control is a text
    input control that will contain the name of the to-do list item. We then have
    a section for a `DatePicker`, where the user can select a due date for the to-do
    list item. The final control is a `Switch` control, which renders a toggle button
    to control when an item is completed, and a heading next to that. Since we want
    these to be displayed next to each other horizontally, we use a horizontal `StackLayout`
    to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step for the views is to wire up the `ItemViewModel` to the `ItemView`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up the code-behind file of the `ItemView` by expanding the `ItemView.xaml` file
    in the Solution Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the constructor of the class to look like the following code. Add the
    code that is marked in bold.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a using `DoToo.ViewModels` statement at the top of the following file the
    existing `using` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This code is identical to the code that we added for `MainView`, except for
    the type of the `ViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up a dependency injection through Autofac
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier, we discussed the dependency injection pattern, which states that all
    dependencies, such as the repositories and view models, must be passed through
    the constructor of the class. This has several benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: It increases the readability of the code, since we can quickly determine all
    external dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes dependency injection possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes unit testing possible by mocking classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can control the lifetime of an object by specifying whether it should be
    a singleton or a new instance for each resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection is a pattern that lets us determine at runtime which instance
    of an object should be passed to a constructor when an object is created. We do
    this by defining a container where we register all the types of a class. We let
    the framework that we are using resolve any dependencies between them. Let's say
    that we ask the container for a `MainView`. The container takes care of resolving
    the `MainViewModel` and any dependencies that the class has.
  prefs: []
  type: TYPE_NORMAL
- en: To set this up, we need to reference a library called Autofac. There are other
    options out there, so feel free to switch to one that better fits your needs.
    We also need an entry point to resolve the types into instances. To do this, we
    will define a bare-bones `Resolver` class. To wrap it all up, we need a bootstrapper
    that we will call to initialize the dependency injection configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a reference to Autofac
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need a reference to Autofac to get started. We will use NuGet to install
    the packages needed:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up the NuGet-manager by right-clicking on the Solution node and clicking
    on Manage NuGet packages for solution....
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Browse and type `autofac` in the search box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Tick all checkboxes under Project, scroll down, and click Install:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2454a7ee-4123-4a08-8ddf-e7dcc11be688.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating the resolver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The resolver will be responsible for creating our objects for us based on the
    type that we request. Let''s create the resolver:'
  prefs: []
  type: TYPE_NORMAL
- en: In the root of the .NET Standard library project, create a new file called `Resolver.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `container` property of the `IContainer` type is defined in `Autofac` and
    represents a container that holds the configuration on how to resolve types. The
    `Initialize` method takes an instance of an object that implements the `IContainer` interface
    and assigns it to the `container` property. The `Resolve` method uses the `container`
    to resolve a type to an instance of an object. While it might seem strange to
    use this at first, it will become much easier with experience.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the bootstrapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The bootstrapper''s responsibility is to initialize Autofac. It will be called
    at the startup of the application. We can create it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the root of the .NET Standard library project, create a new file called `Bootstrapper.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `Bootstrapper` will be inherited by each platform since this is where the
    execution of the app begins. This will also give us the option to add platform-specific
    configurations. To ensure that we inherit from the class, we define it as abstract.
  prefs: []
  type: TYPE_NORMAL
- en: The `ContainerBuilder` is a class defined in `Autofac` that takes care of creating
    the `container` for us after we are finished with the configuration. The building
    of the `container` happens in the `FinishInitialization` method defined at the
    end and is called by the constructor right after we call the virtual `Initialize`
    method. We can override the `Initialize` method to add custom registrations on
    each platform.
  prefs: []
  type: TYPE_NORMAL
- en: The `Initialize` method scans the assembly for any types that inherit from the `Page`
    or `ViewModel` and adds them to the `container`. It also adds the `TodoItemRepository`
    as a singleton to the `container`. This means that each time we ask for a `TodoItemRepository`,
    we will get the same instance. The default behavior for Autofac (this may vary
    between libraries) is that we get a new instance for each resolution.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a bootstrapper on iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Bootstrapper` for iOS is a simple wrapper for the common bootstrapper
    defined in the .NET Standard library, but with the addition of an `Init` method
    that will be called at startup:'
  prefs: []
  type: TYPE_NORMAL
- en: In the root of the iOS project, create a new class called `Bootstrapper.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `Init` method may look strange since we don't retain a reference to the
    instance we create. Keep in mind, however, that we do keep a reference to a `Resolver`
    instance inside the `Resolver` class, which is itself a singleton.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step for iOS is to call this `Init` method in the right place:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up `AppDelegate.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the `FinishedLaunching` method and add the code in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Adding a bootstrapper in Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like for iOS, the `Bootstrapper` for Android is a simple wrapper for the
    common bootstrapper defined in the .NET Standard library, but with the addition
    of an `Init` method that will be called at startup:'
  prefs: []
  type: TYPE_NORMAL
- en: In the root of the Android project, create a new class called `Bootstrapper.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to call this `Init` method. A good place to do this is right before
    the `LoadApplication` call in `OnCreate`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up `MainActivity.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the `OnCreate` method and add the code in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Adding a bootstrapper in UWP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The bootstrapper for UWP is identical to the other platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: In the root of the UWP project, create a new class called `Bootstrapper.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And as with the other platforms, we need to call the `Init` method in a good
    place:'
  prefs: []
  type: TYPE_NORMAL
- en: In the UWP project, open up the `App.xaml.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the call to the `Xamarin.Forms.Forms.Init()`method and add the code
    in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Making the app run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can start the app for the first time as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up `App.xaml.cs` by expanding the `App.xaml` node in the .NET Standard
    library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `using` statement for `DoToo.Views` and add the following code line in
    bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The line added resolves the `MainView` (and all dependencies, including `MainViewModel`
    and the `TodoItemRepository`) and wraps it into a `NavigationPage`. The `NavigationPage`
    is a page defined in Xamarin.Forms that adds a navigation bar and enables the
    user to navigate to other views.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it! At this point, your project should start. Depending on the platform
    you are using, it might look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4adb68f9-ea33-467f-96c3-1a0bc8c7c3f7.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding data bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data binding is the heart and soul of MVVM. This is the way that the `Views` and
    the `ViewModel` communicate with each other. In Xamarin.Forms, we need two things
    to make data binding happen:'
  prefs: []
  type: TYPE_NORMAL
- en: We need an object to implement `INotifyPropertyChanged`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to set the `BindingContext` of the page to that object. We already do
    this on both the `ItemView` and the `MainView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A really useful feature of data binding is that it allows us to use two-way
    communication. For example, when data binding text to an `Entry` control, the
    property on the data-bound object will be updated directly. Consider the following
    XAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: To make this work, we need a property named `Title` on the object that is a
    string. We have to look at the documentation, define an object, and let **Intellisense**
    provide us with a hint to find out what type our property should be.
  prefs: []
  type: TYPE_NORMAL
- en: Controls that perform some kind of action, like a `Button`, usually expose a
    property called `Command`. This property is of the `ICommand` type and we can
    either return a `Xamarin.Forms.Command` or an implementation of our own. The `Command`
    property is explained in the next section, where we will use it to navigate to
    the `ItemView`.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating from the MainView to the ItemView to add a new item
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have an Addtoolbar button in the `MainView`. When the user taps this button,
    we want to navigate to the `ItemView`. The MVVM way to do this is to define a
    command and then bind that command to the button. Let''s add the code:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `ViewModels/MainViewModel.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `using` statements for `System.Windows.Input`, `DoToo.Views`,and `Xamarin.Forms`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following property to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: All commands should be exposed as a generic `ICommand`. This abstracts the actual
    command implementation, which is a good general practice to follow. The command
    must be a property; in our case, we are creating a new `Command` object that we
    assign to this property. The property is read-only, which is usually fine for
    a `Command`. The action of the command (the code that we want to run when the
    command is executed) is passed to the constructor of the `Command` object.
  prefs: []
  type: TYPE_NORMAL
- en: The action of the command creates a new `ItemView` through the `Resolver` and
    Autofac builds the necessary dependencies. Once the new `ItemView` has been created,
    we simply tell the `Navigation` service to push it onto the stack for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we just have to wire up the `AddItem`command from the `ViewModel`
    to the add button in the view:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Views/MainView.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `Command` attribute to the `ToolbarItem`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Run the app and tap the Add button to navigate to the new item view. Notice
    that the back button appears automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new items to the list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have now finished adding the navigation to a new item. Let''s now add the
    code needed to create a new item and save it to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up `ViewModels/ItemViewModel.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following code in bold.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Resolve the reference to `System.Windows.Input`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `Item` property holds a reference to the current item that we want to add
    or edit. A new item is created in the constructor and when we want to edit an
    item, we can simply assign our own item to this property. The new item is not
    added to the database unless we execute the `Save` command defined at the end.
    After the item is added or updated, we remove the view from the navigation stack
    and return to the `MainView` again.
  prefs: []
  type: TYPE_NORMAL
- en: Since the navigation keeps pages in a stack, the framework declares methods
    that reflect operations that you can perform on a stack. The operation of removing
    the topmost item in a stack is known as **popping the stack**, so instead of `RemoveAsync()`,
    we have `PopAsync()`. To add a page to the navigation stack, we push it, so that
    method is called `PushAsync()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have extended the `ItemViewModel` with the necessary commands and
    properties, it''s time to data-bind them in the XAML:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `ViewModels/ItemView.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the code marked in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The binding to the `ToolbarItems` command attribute triggers the `Save` command
    exposed by the `ItemViewModel` when a user taps the `Save` link. It's worth nothing
    again that any attribute called `Command` indicates that an action will take place
    and that we must bind it to an instance of an object implementing the `ICommand`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: The `Entry` control that represents the title is data-bound to the `Item.Title`
    property of the `ItemViewModel`, and the `Datepicker` and `Switch` control bind
    in a similar way to their respective properties.
  prefs: []
  type: TYPE_NORMAL
- en: We could have exposed  `Title`, `Due`, and `Complete` as properties directly
    on the `ItemViewModel`, but chose to reuse the already existing `TodoItem` as
    a reference. This is fine, as long as the properties of the `TodoItem` object
    implement the `INotifyPropertyChange` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Binding the ListView in the MainView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A to-do list is not much use without a list of items. Let''s extend the `MainViewModel`
    with a list of items:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `ViewModels/MainViewModel.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `using` statements for `System.Collections.ObjectModel` and `System.Linq`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a property for the to-do list items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: An `ObservableCollection` is like an ordinary collection, but it has a useful
    superpower. It can notify listeners about changes in the list, such as when `items`
    are added or deleted. The `Listview` will listen to changes in the list and update
    itself automatically based on these.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need some data:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `ViewModels/MainViewModel.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace (or complete) the `LoadData` method and create the `CreateTodoItemViewModel`
    and `ItemStatusChanged` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Resolve the reference to `DoToo.Models` by adding a `using` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `LoadData` method calls the repository to fetch all items. We then wrap
    each to-do list item in the `TodoItemViewModel`. This will contain more information
    that is specific to the view and that we don't want to add to the `TodoItem` class.
    It is a good practice to wrap plain objects in a `ViewModel`; this makes it simpler
    to add actions or extra properties to it. The `ItemStatusChanged` is a stub that
    will be called when we change the status of the to-do list item from *active*
    to *completed* and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to hook up some events from the repository to know when data changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `ViewModels/MainViewModel.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When an item is added to the repository, no matter who added it, the `MainView`
    will add it to the items list. Since the items collection is an observable collection,
    the list will update. If an item gets updated, we simply reload the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s data-bind our items to the `ListView`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up `MainView.xaml` and locate the `ListView` element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify it to reflect the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `ItemsSource` binding tells the `ListView` where to find the collection
    to iterate over and is local to the `ViewModel`. Any bindings inside the `ViewCell`
    node, however, are local to each item that we iterate in the list. In this case,
    we are binding to the `TodoItemViewModel`, which contains a property named `Item`.
    This, in turn, has properties such as `Title`, `Due`, and `Completed`. We can
    navigate down the hierarchy of objects without any problem when defining a binding.
  prefs: []
  type: TYPE_NORMAL
- en: The `DataTemplate` defined what each row will look like. We use a grid to partition
    the space just like we did earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a ValueConverter for the item status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we want to bind to objects that are a representation of the original
    value. This could be a piece of text that is based on a Boolean value. Instead
    of *true* and *false*, for example, we might want to write *Yes* and *No*, or
    return a color. This is where `ValueConverter` comes in handy. It can be used
    to convert a value to and from another value. We are going to write a `ValueConverter`
    that converts the status of a to-do list item to a color:'
  prefs: []
  type: TYPE_NORMAL
- en: In the root of the .NET Standard library project, create a folder called `Converters`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a class called `StatusColorConverter.cs` and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: A `ValueConverter` is a class that implements `IValueConverter`. This, in turn, only
    has two methods defined. The `Convert` method is called when the view reads data
    from the `ViewModel`, and the `ConvertBack` method is used when the `ViewModel`
    gets data from the view. The `ConvertBack` method is only used for controls that
    return data from plain text, such as the `Entry` control.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the implementation of the `Convert` method, we notice that any
    value passed into the method is of the object type. This is because we don''t
    know what type the user has bound to the property to which we are adding this
    `ValueConverter`. We may also notice that we fetch colors from a resource file.
    We could have defined the colors in the code, but this is not recommended, so
    instead, we went the extra mile and added them as a global resource in the `App.xaml`
    file. Resources are a good thing to take another look at once we''ve finished
    with the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `App.xaml` in the .NET Standard library project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `ResourceDictionary`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: A `ResourceDictionary` can define a wide range of different objects. We settle
    for the two colors that we want to access from the `ValueConverter`. Notice that
    these are accessible by the key given to them and they can also be accessed from
    any other XAML file using a static resource binding. The `ValueConverter` itself
    will be referenced as a static resource, but from a local scope.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ValueConverter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to use our brand new `StatusColorConverter` in the `MainView`. Unfortunately,
    we have to jump through some hoops to make this happen. We need to do three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a namespace in XAML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a local resource that represents an instance of the converter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare in the binding that we want to use that converter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with the namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Views/MainView.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following namespace to the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `Resource` node to the `MainView.xaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Views/MainView.Xaml.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `ResourceDictionary`, shown in bold under the root element
    of the XAML file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This has the same form as the global resource dictionary, but since this one
    is defined in the `MainView`, it will only be accessible from there. We could
    have defined this in the global resource dictionary, but it's usually best to
    define objects that you only consume in one place as close to that place as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to add the converter:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate the `BoxView` node in the XAML.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `BackgroundColor` XAML, which is marked in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: What we have done here is bound a Boolean value to a property that takes a `Color`
    object. Right before the data binding takes place, however, the `ValueConverter`
    converts the Boolean value to a color. This is just one of the many cases where
    a `ValueConverter` comes in handy. Keep this in mind when you are defining the
    GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating to an item using a command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to be able to see the details for a selected to-do list item. When we
    tap a row, we should navigate to the item in that row.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `ViewModels/MainViewModel.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `SelectedItem` property and the `NavigateToItem`method to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `SelectedItem` property is a property that we will data-bind to the `ListView`.
    When we select a row in the `ListView`, this property will be set to the `TodoItemViewModel`
    that represents that row. Since we can't really use Fody here to carry out its
    `PropertyChanged` magic, because of the need to do a method call in the setter,
    we need to go old-school and manually add a getter and a setter.
  prefs: []
  type: TYPE_NORMAL
- en: The setter then calls `NavigateToItem`, which creates a new `ItemView` using
    the `Resolver`. We extract the `ViewModel` from the newly created `ItemView` and
    assign the current `TodoItem` that the `TodoItemViewModel` contains. Confused?
    Remember that the `TodoItemViewModel` actually wraps a `TodoItem` and it is that
    item that we want to pass to the `ItemView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not done yet. We now need to data-bind the new `SelectedItem` property
    to the right place in the view:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Views/MainView.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the `ListView` and add the attributes in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `SelectedItem` attribute binds the, `SelectedItem` property `ListView` to
    the `ViewModel` property. When the selection of an item in the `ListView` changes,
    the `ViewModels` `SelectedItem` property will be called and we will navigate to
    the new and exciting views.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `x:Name` attribute is for naming the `ListView`, because we do need to
    make a small and ugly hack to make this work. The `ListView` will actually stay
    selected after the navigation is done. When we navigate back, it cannot be selected
    again until we select another row. To mitigate this, we need to hook up to the
    `ItemSelected` event of `ListView` and reset the selected item directly on the
    `ListView`. This is not recommended, because we shouldn''t really have any logic
    in our `Views`, but sometimes we have no other choice:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Views/MainView.xaml.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We should now be able to navigate to an item in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Marking an item as complete using a command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to add a functionality that allows us to toggle the items between *complete*
    and *active*. It is possible to navigate to the detailed view of the to-do list
    item, but this is too much work for a user. Instead, we''ll add a `ContextAction`
    to the `ListView`. In iOS, for example, this will be accessed by swiping left
    on a row:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `ViewModel/TodoItemViewModel.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `using` statement for `System.Windows.Input` and `Xamarin.Forms`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a command to toggle the status of the item and a piece of text that describes
    the status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have added a command for toggling the state of an item. When executed,
    it inverses the current state and raises the `ItemStatusChanged` event so that
    subscribers are notified. To change the text of the context action button depending
    on the status, we added a `StatusText` property. This is not a recommended practice,
    because we are adding code that only exists because of a specific UI case into
    the `ViewModel`. Ideally, this would be handled by the view, perhaps by using
    a `ValueConverter`. To save us having to implement these steps, however, we have
    left it as a string property:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Views/MainView.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the `ListView.ItemTemplate` node and add the following `ViewCell.ContextActions`
    node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Creating the filter toggle function using a command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to be able to toggle between viewing only active items and all items.
    We will create a simple mechanism to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hook up the changes in the `MainViewModel` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `ViewModels/MainViewModel.cs` and locate the `ItemStatusChangeMethod`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the implementation to the `ItemStatusChanged` method and a property called
    `ShowAll` to control the filtering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `ItemStatusChanged` event handler is triggered when we use the context action
    from the last section. Since the sender is always an object, we try to cast it
    to a `TodoItemViewModel`. If this is successful, we check whether we can remove
    it from the list if `ShowAll` is not true. This is a small optimization; we could
    have called `LoadData` and reloaded the entire list, but since the Items list
    is an `ObservableCollection`, it communicates to the `ListView` that one item
    has been removed from the list. We also call the repository to update the item
    to persist the change of status.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ShowAll` property is what controls which state our filter is in. We need
    to adjust the `LoadData` method to reflect this:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate the Load method in the `MainViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the lines of code marked in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: If `ShowAll` is false, we limit the content of the list to the items that have
    not been completed. We could do this either by having two methods, `GetAllItems()`
    and `GetActiveItems()`, or by using a filter argument that could be passed to
    `GetItems()`. Take a minute to think about how we would have implemented this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the code that toggles the filter:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `ViewModels/MainViewModel.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `FilterText` and `ToggleFilter` properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `FilterText` property is a read-only property used to display the status
    as a string in human-readable form. We could have used a `ValueConverter` for
    this, but to save some time, we simply expose it as a property. The logic for
    the `ToggleFilter` command is a simple inversion of the state and then a call
    to `LoadData`. This, in turn, causes a reload of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can filter the items, we need to hook up the filter button:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Views/MainView.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the `Button` that controls the filter (the only button in the file).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Adjust the code to reflect the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The app is now complete with regard to this feature! But it isn't very attractive;
    we'll deal with this in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Laying out contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This last section is about making the app look a bit nicer. We are just going
    to scratch the surface of the possibilities here, but this should give you some
    ideas about how styling works.
  prefs: []
  type: TYPE_NORMAL
- en: Setting an application-wide background color
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Styles are a great way to apply styling to elements. They can be applied either
    to all elements of a type or to the elements referenced by a key, if you add an `x:Key`
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `App.xaml` in the .NET Standard project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following XAML, which is in bold, to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The first style we are going to apply is a new background color and text color
    in the navigation bar. The second style will be applied to the filter button.
    We can define a style by setting the `TargetType` that instructs Xamarin.Forms
    which type of object this style can be applied to. We can then add one or more
    properties that we want to set. The result is the same as if we had added these
    properties directly to the element in the XAML code.
  prefs: []
  type: TYPE_NORMAL
- en: Styles that lack the `x:Key` attribute will be applied to all instances of the
    type defined in `TargetType`. The styles that have a key must be explicitly assigned
    in the XAML of the user interface. We will see examples of this when we define
    the filter button in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Laying out the MainView and ListView items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll be improving the appearance of the `MainView` and the
    `ListView`. Open up `Views/MainView.xaml` and apply the changes in bold in the
    XAML code for each section following.
  prefs: []
  type: TYPE_NORMAL
- en: The filter button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The filter button allows us to toggle the state of the list to show only active
    to-do items and all to-do items. Let''s style it to make it stand out a bit in
    the layout:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the filter button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the following changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The style is applied using a `StaticResource`. Anything defined in a resource
    dictionary, either in the `App.xaml` file or in the local XAML file, is accessible
    through it. We then set the `BackgroundColor`, based on the `ShowAll` property
    of the `MainViewModel`, and the `TextColor` to `Black`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Button.Triggers` node is a useful feature. We can define a number of types
    of triggers that fire when a certain criteria is met. In this case, we use a data
    trigger that checks whether the value of `ShowAll` changes to true. If it does,
    we set the `TextColor` to white. The coolest part is that when `ShowAll` becomes
    false again, it switches back to whichever color it was before.
  prefs: []
  type: TYPE_NORMAL
- en: Touching up the ListView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ListView` could use a couple of minor changes. The first change is formatting
    the due-date string to a more human, readable format, and the second is to change
    the color of the completed label to a nice green tint:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up `Views/MainView.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the labels that bind `Item.Due` and `Item.Completed` in the `ListView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We added a string formatting in the binding to format the date using a specific
    format. In this case, the `0:MMMM d, yyyy` format that will display the date as
    a string in the format of May 5, 2019.
  prefs: []
  type: TYPE_NORMAL
- en: We also added a text color to the `Completed` label that is only visible if
    an item is completed. We do this by referencing our dictionary in `App.xaml`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We should now have a good grasp of all the steps involved in creating a Xamarin.Forms
    application from scratch. We have learned about the project structure and the
    important files in a newly created project. We talked about dependency injection,
    using Autofac, and learned the basics of MVVM by creating all the `Views` and
    `ViewModels` needed. We also covered data storage in SQLite, to be able to persist
    data on the device in a fast and secure way. Using the knowledge gained from this
    chapter, you should now be able to create the backbone of any app you like.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will focus on creating a richer user experience by creating
    a match-making application that displays images that you can pan around the screen.
    We will take a closer look at XAML and how to create custom controls.
  prefs: []
  type: TYPE_NORMAL
