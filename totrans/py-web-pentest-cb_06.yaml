- en: Chapter 6. Image Analysis and Manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Hiding a message by using LSB steganography
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting message hidden in LSB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hiding text in image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting text from images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command and control by using steganography
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Steganography is the art of hiding data in plain sight. This can be useful if
    you want to mask your tracks. We can use steganography to evade detection by firewalls
    and IDS. In this chapter, we are going to look at some of the ways in which Python
    can help us to hide data within images. We will go through some basic image steganography
    using the **least significant bit** (**LSB**) to hide our data, and then we will
    create a custom steganography function. The culmination of this chapter will be
    creating a command and control system that uses our specially crafted images to
    communicate data between a server and client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image is an example of an image that has another hidden within
    it. You can see (or perhaps not see) that it''s impossible for the human eye to
    detect anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/B04044_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hiding a message using LSB steganography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to create an image that hides another, using LSB
    steganography methods. This is one of the most common forms of steganography.
    As it's no good just having a means to hide the data, we will also be writing
    a script to extract the hidden data too.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All of the image work we will encounter in the chapter will make use of the
    **Python Image Library** (**PIL**). To install the Python image libraries by using
    `PIP` on Linux, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you are installing it on Windows, you may have to use the installers that
    is available at [http://www.pythonware.com/products/pil/](http://www.pythonware.com/products/pil/).
  prefs: []
  type: TYPE_NORMAL
- en: Just make sure that you get the right installer for your Python version.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that PIL has been superseded with a newer version PILLOW.
    But for our needs, PIL will be fine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Images are created up by pixels, each of those pixels is made up of red, green,
    and blue (RGB) values (for color images anyway). These values range from 0 to
    255, and the reason for this is that each value is 8 bits long. A pure black pixel
    would be represented by a tuple of (R(0), G(0), B(0)), and a pure white pixel
    would be represented by (R(255), G(255), B(255)). We will be focusing on the binary
    representation of the `R` value for the first recipe. We will be taking the 8-bit
    values and altering the right-most bit. The reason we can get away with doing
    this is that a change to this bit will equate to a change of less than 0.4 percent
    of the red value of pixel. This is way below what the human eye can detect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the script now, then we will go through how it works later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we import the `Image` module from `PIL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create our `Hide_message` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes three parameters, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`carrier`: This is the filename of the image that we are using to hide our
    other image in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message`: This is the filename of the image that we are going to hide'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outfile`: This is the name of the new file that will be generated by our function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we open the carrier and message images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We then manipulate the image that we are going to hide so that it''s the same
    size (width and height) as our carrier image. We also convert the image that we
    are going to hide into pure black and white. This is done by setting the image''s
    mode to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a new image and we set the image mode to be RGB and the size
    to be that of the carrier image. We create two variables to hold the values of
    the carrier images width and height and we setup an array; this array will hold
    our new pixel values that we will eventually save into the new image, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Next comes the main part of our function. We need to get the value of the pixel
    we want to hide. If it's a black pixel, then we will set the LSB of the carriers
    red pixel to `0`, if it's white then we need to set it to `1`. We can easily do
    this by using bitwise operations that uses a mask. If we want to set the LSB to
    `0` we can `AND` the value with `254`, or if we want to set the value to `1` we
    can `OR` the value with `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We loop through all the pixels in the image, and once we have our `newred`
    values, we append these along with the original green and blue values into our
    `new_array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: At the end of the function, we use the `putdata` method to add our array of
    new pixel values into the new image and then save the file using the filename
    specified by `outfile`.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that you must save the image as a PNG file. This is an important
    step as PNG is a lossless algorithm. If you were to save the image as a JPEG for
    instance, the LSB values won't be maintained as the compression algorithm that
    JPEG uses will change the values we specified.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have used the Red values LSB for hiding our image in this recipe; however,
    you could have used any of the RGB values, or even all three. Some methods of
    steganography will split 8 bits across multiple pixels so that each bit will be
    split across RGBRGBRG, and so on. Naturally, if you want to use this method, your
    carrier image will need to be considerably larger than the message you want to
    hide.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, we now have a way of hiding our image. In the following recipe, we will
    look at extracting that message.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting messages hidden in LSB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will allow us to extract messages hidden in images by using the
    LSB technique from the preceding recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As seen in the previous recipe, we used the LSB of the `Red` value of an RGB
    pixel to hide a black or white pixel from an image that we wanted to hide. This
    recipe will reverse that process to pull the hidden black and white image out
    of the carrier image. Let''s take a look at the function that will do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we import the `Image` module from the Python image library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set up the function that we will use to extract the messages. The
    function takes in two parameters: the `carrier` image file name and the filename
    that we want to create with the extracted image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create an `Image` object from the `carrier` image. We also create
    a new image for the extracted data; the mode for this image is set to `L` because
    we are creating a grayscale image. We create two variables that will hold the
    width and height of the carrier image. Finally, we set up an array that will hold
    our extracted data values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, onto the main part of the function: the extraction. We create our `for`
    loops to iterate over the pixels of the carrier. We use the `Image` objects and
    `getpixel` function to return the RGB values of the pixels. To extract the LSB
    from the Red value of a pixel, we use a bitwise mask. If we use a bitwise `AND`
    with the Red value using a mask of `1,` we will get a `0` returned if the LSB
    was `0,` and `1` returned if it was `1`. So, we can put that into an `if` statement
    to create the values for our new array. As we are creating a grayscale image,
    the pixel values range from `0` to `255`, so, if we know the LSB is a `1,` we
    convert it to `255`. That''s pretty much all there is to it. All that''s left
    to do is to use our new images `putdata` method to create the image from the array
    and then save.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we've looked at hiding one image within another, but there are many
    other ways of hiding different data within other carriers. With this extraction
    function and the previous recipe to hide an image, we are getting closer to having
    something we can use to send and receive commands through messages, but we are
    going to have to find a better way of sending actual commands. The next recipe
    will focus on hiding actual text within an image.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding text in images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, we've looked at hiding images within another. This
    is all well and good, but our main aim of this chapter is to pass text that we
    can use in a command and control style format. The aim of this recipe is to hide
    some text within an image.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we've looked at focusing on the RGB values of a pixel. In PNGs, we can
    access another value, the `A` value. The `A` value of `RGBA` is the transparency
    level of that pixel. In this recipe, we are going to work with this mode, as it
    will allow us to store 8 bits in the LSBs of each value across two pixels. This
    means that we can hide a single `char` value across two pixels, so we will need
    an image that has a pixel count of at least twice the number of characters we
    are trying to hide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we import the `Image` module from `PIL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we set up a helper function that will assist in setting the LSB of the
    value we pass in based on the binary to be hidden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We are using a bitmask to set the LSB-based on whether the binary value we pass
    in is either a `1` or `0`. If it's a `0,` we use the bitwise `AND` with a mask
    of `254` (11111110), and if it's a `1,` we bitwise `OR` with a mask of `1` (00000001).
    The resulting value is returned from our function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we create our main `Hide_message` method that takes three parameters:
    the filename for our carrier image, a string for the message we want to hide,
    and finally, the filename of the image we will create for the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The next line of code adds the value of `0x00` to the end of our string. This
    will be important in the extraction function as it will let us know that we''ve
    reached the end of the hidden text. We use the `chr()` function to convert `0x00`
    to a string-friendly representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following section of the code creates two image objects: one of our carrier
    and one for the output image. For our carrier image, we change the mode to `RGBA`
    to make sure we have the four values per pixel. We then create a few arrays: `pixel_list`
    is all the pixel data from our carrier image and `new_array` will hold all the
    new pixel values for our combined `carrier` and `message` image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we loop over each character in our message in a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by converting the character to an `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We then convert that `int` to a binary string, we `zfill` the string to ensure
    that it''s `8` character long. This will make it easier later on. When you use
    `bin(),` it will prefix the string with 0 bits, so the `[2:]` just strips that
    out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create two pixel variables and populate them. We use the current messages
    character index `*2` for the first of the pixels and the (current messages character
    index `*2`) and `1` for the second. This is because we are using two pixels per
    character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create two arrays that will hold the values of the hidden data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that everything is set up, we can start to change the values of the pixel
    data we iterate `4` times (for the `RGBA` values) and call our helper method to
    set the LSB. The `newpix1` function will contain the first 4 bits of our 8-bit
    character; `newpix2` will have the last `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Once we have our new values, we will convert them to tuples and append them
    to the `new_array:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an image that describes what we will achieve:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04044_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'All that''s left to do is extend the `new_array` method with the remaining
    pixels from our carrier image and then save it using the `filename` parameter
    that was passed in to our `Hide_message` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As stated at the start of this recipe, we need to make sure that the carrier
    images pixel count is twice the size of our message that we want to hide. We could
    add in a check for this, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: That's pretty much it for this recipe; we can now hide text in an image, and
    also with the previous recipes, we can hide images too. In the next recipe, we
    will extract the text data out.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting text from images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw how to hide text in the `RGBA` values of an image.
    This recipe will let us extract that data out.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We saw in the previous recipe that we split up a characters byte into 8 bits
    and spread them over the LSBs of two pixels. Here''s that diagram again as a refresher:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04044_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the script that will do the extraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we import the `Image` module from `PIL`; we also import the `izip` module
    from `itertools`. The `izip` module will be used to return pairs of pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create two helper functions. The `get_pixel_pairs` function takes
    in our pixel list and returns the pairs back; as each message character was split
    over two pixels, this makes extraction easier. The other helper function `get_LSB`
    will take in an `R`, `G`, `B`, or `A` value and use a bit mask to get the LSB
    value and return it in a string format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have our main `extract_message` function. This takes in the filename
    of our carrier image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create an image object from the filename passed in and then create
    an array of pixels from the image data. We also create an empty string called
    `message`; this will hold our extracted text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Next, we create a `for` loop that will iterate over all of the pixel pairs returned
    using our helper function `get_pixel_pairs;` we set the returned pairs to `pix1`
    and `pix2:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part of code that we will create is a string variable that will hold
    our binary string. Python knows that it''ll be the binary representation of a
    string by the `0b` prefix. We then iterate over the `RGBA` values in each pixel
    (`pix1` and `pix2`) and pass that value to our helper function, `get_LSB`, the
    value that''s returned is appended onto our binary string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When the preceding code runs, we will get a string representation of the binary
    for the character that was hidden. The string will look like this `0b01100111`,
    we placed a stop character at the end of the message that was hidden that will
    be `0x00`, when this is outputted by the extraction part we need to break out
    of the `for` loop as we know we have hit the end of the hidden text. The next
    part does that check for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If it''s not our stop byte, then we can convert the byte to its original character
    and append it onto the end of our message string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: All that's left to do is return the complete message string back from the function.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our hide and extract functions, we can put them together into
    a class that we will use for the next recipe. We will add a check to test if the
    class has been used by another or if it is being run on its own. The whole script
    looks like the following. The `hide` and `extract` functions have been modified
    slightly to accept an image URL; this script will be used in the C2 example in
    [Chapter 8](ch08.html "Chapter 8. Payloads and Shells"), *Payloads and Shells*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Enabling command and control using steganography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show how steganography can be used to control another machine.
    This can be handy if you are trying to evade **Intrusion Detection System** (**IDS**)/firewalls.
    The only traffic that would be seen in this scenario is HTTPS traffic to and from
    the client machine. This recipe will show a basic server and client setup.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will use the image sharing website Imgur to host our images.
    The reason for this is simply that the Python API for Imgur is easy to install
    and simple to use. You could choose to work with another, though. However, you
    will need to create an account with Imgur if you wish to use this script and also
    register an application to get the API Key and Secret. Once this is done, you
    can install the `imgur` Python libraries by using `pip:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You can register for an account at [http://www.imgur.com](http://www.imgur.com).
  prefs: []
  type: TYPE_NORMAL
- en: Once signed up for an account, you can register an app to obtain an API Key
    and Secret from [https://api.imgur.com/oauth2/addclient](https://api.imgur.com/oauth2/addclient).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have your imgur account, you'll need to create an album and upload
    an image to it.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will also import the full stego text script from the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The way this recipe works is split into two parts. We will have one script
    that will run and act as a server, and another script that will run and act as
    the client. The basic steps that our scripts will follow is detailed in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The server script is run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server waits for the client to announce it's ready.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client script is run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client informs the server that it's ready.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server shows that the client is waiting and prompts user for command to
    send over to client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server sends a command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server waits for a response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client receives command and runs it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client sends output from command back to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server receives output from the client and displays it to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The steps 5 to 10 are repeated until a `quit` command is sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With these steps in mind, let''s take a look first at the server script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the script for our client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firstly, we create an `imgur` client object; the authenticate function handles
    getting the `imgur` client authenticated with our account and app. When you run
    the script, it will output a URL to visit to get a pin code to enter. It then
    gets a list of albums for our imgur username. If you haven't created an album
    yet, the script will fail, so make sure you've got an album ready. We will take
    the first album in the list and get a further list of all images contained in
    that album.
  prefs: []
  type: TYPE_NORMAL
- en: 'The image list is ordered by putting the earliest uploaded image first; for
    our script to work, we need to know the timestamp of the latest uploaded image,
    so we use the `[-1]` index to get it and store it in a variable. When this is
    done, the server will wait for the client to connect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Once the server is awaiting a client connection, we can run the client script.
    The initial start of the client script creates an `imgur` client object, just
    like the server, instead of waiting; however, it generates a message and hides
    it in a random image. This message contains the `os` type the client is running
    on (this will make it easier for the server user to know what commands to run),
    a `ready` status, and also an identifier for the client (if you wanted to expand
    on the script to allow multiple clients to connect to the server).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the image has been uploaded, the `last_message_datetime` function is set
    to the new timestamp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The server will wait until it sees the message; it does this by using a `while`
    loop and checks for an image datetime later than the one it saved when we fired
    it up. Once it sees there is a new image, it will download it and extract the
    message. It then checks the message to see if it''s the client ready message;
    if it is, then it displays the `uuid` client and `os` type, and it then prompts
    the user for input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'After the user inputs a command, it''s encoded up by using base32 in order
    to avoid breaking our message string. It''s then hidden in a random image and
    uploaded to imgur. The client is sat in a while loop awaiting this message. The
    start of this loop checks the datetime in the same way our server did; if it sees
    a new image, it checks to see if it''s addressed to this machine using `uuid`,
    and if it is, it will extract the message, convert it into a friendly format that
    `Popen` will accept using `shlex,` and then run the command using `Popen`. It
    then waits for the output from the command before hiding it in a random image
    and uploading it to imgur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: All that's left for the server to do is get the new image, extract the hidden
    output, and display it to the user. It then gives a new prompt and awaits the
    next command. That's it; it is a very simple way of passing command and control
    data over steganography.
  prefs: []
  type: TYPE_NORMAL
