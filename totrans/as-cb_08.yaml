- en: Chapter 8. Improving Quality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have just finished coding your app. Now what? Get it onto the Play Store
    as quickly as possible!
  prefs: []
  type: TYPE_NORMAL
- en: No wait, you are not done yet! Did you test your app properly? Will it work
    on any Android version? On any device? In all circumstances?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on:'
  prefs: []
  type: TYPE_NORMAL
- en: Patterns and support annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing using Robolectrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some common pitfalls to avoid and some patterns that you may want
    to apply in order to improve the quality of your app. You have seen some of them
    in the previous chapters already. Also, there are some interesting tools that
    can be used to test and analyze your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following road map, you will notice that there are different stages
    that you need to complete before you can go live with your app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/B04299_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The structure of your code, robustness, maintainability, and how well it complies
    with the functional requirements are key elements.
  prefs: []
  type: TYPE_NORMAL
- en: Functional quality is measured through software testing, for which we need to
    distribute our app to our beta testers. We will discuss this in [Chapter 10](ch10.html
    "Chapter 10. Beta Testing Your Apps"), *Beta Testing Your Apps*.
  prefs: []
  type: TYPE_NORMAL
- en: Structural quality is evaluated by running unit tests and code inspections manually
    (peer review) or using tools such as Android Lint, which you will learn more about
    in the final recipe within this chapter. Now the question is how well does the
    architecture of the code meet the demands of good software engineering?
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, there are some interesting principles that will help you to improve
    the quality of your code. Some of them are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn the activity lifecycle and use fragments in the right way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't allocate memory if it can be avoided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid fragments and activities that are too heavy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider a **Model View Controller** (**MVC**) approach. Apply the correct patterns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solve a problem once at a single spot. **Do not Repeat Yourself** (**DRY**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Don''t do work that you do not need to do (yet). Also known as: **You Aren''t**
    **Gonna Need It** (**YAGNI**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next recipe will give you an idea of what patterns are and why you would
    want to apply them.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns and support annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quality is a serious business so we will combine it with some fun. We will be
    creating a quiz app in the upcoming recipe. We will use Google Play services for
    this, and we will have a look at patterns that we can apply to our app, in particular
    the MVC and **Model View Presenter** (**MVP**) approach.
  prefs: []
  type: TYPE_NORMAL
- en: So what actually is a design pattern? A design pattern is a solution for a common
    problem. We can reuse such a pattern anywhere. There is no need to reinvent the
    wheel (unless you can think of a better one of course) and there is no need to
    repeat ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns are best practices that we can trust on. They can help us to speed
    up the development process, including testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the patterns are:'
  prefs: []
  type: TYPE_NORMAL
- en: MVC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MVP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Play services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MVC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MVC is most suitable for larger projects. The benefit of this pattern is the
    separation of concerns. We can separate our UI code from the business logic. A
    controller will be responsible for which view is being displayed. It will get
    data from another layer, a repository-a-like class that will get its data from
    somewhere, and pass that data through a model (or list of models) to the UI. The
    controller has no clue where the data is coming from and how it is being displayed.
    These are tasks of the repository class and the UI, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: MVP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MVP is a more suitable pattern to use with Android app development in most cases
    because of the nature of activities and fragments. With MVP patterns, a presenter
    contains the UI logic for a view. All invocations from the view are delegated
    directly to it. The presenter will communicate with the view through an interface,
    allowing us to create unit tests with mocked data later.
  prefs: []
  type: TYPE_NORMAL
- en: The observer pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw this pattern in [Chapter 7](ch07.html "Chapter 7. Content Providers and
    Observers"), *Content Providers and Observers*, already. An observer observes
    changes in another object.
  prefs: []
  type: TYPE_NORMAL
- en: The factory pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This pattern helps to create an object. The bitmap factory that we have been
    using for previous recipes (and that we will use again in this recipe) is a great
    example of the factory pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The singleton pattern will prevent us from having multiple instances of an object.
    Typically, it is a (class) method that returns an instance. It will be created
    if it does not exist or else it will just return the previously created instance.
    The application class is an example of the singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Support annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Support annotations can help us to provide hints to code inspection tools, such
    as lint. They can help you detect problems such as null pointer exceptions and
    resource type conflicts just by adding metadata tags and running code inspections.
    The support library itself has been annotated with these annotations. Yes, they
    eat their own dog food, which proves that using annotations is the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are basically three types of annotations that we can use: Nullness annotations,
    resource type annotations, and IntDef \ StringDef annotations. For example, we
    can use the `@NonNull` annotation to indicate that a given parameter cannot be
    null, or we can use the `@Nullable` annotation to indicate that a return value
    can be null.'
  prefs: []
  type: TYPE_NORMAL
- en: Google Play services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Play Games SDK provides cross-platform Google Play game services that let
    you easily integrate popular gaming features, such as achievements, leader boards,
    saved games, and real-time multiplayer (on Android) options in your tablet and
    mobile games.
  prefs: []
  type: TYPE_NORMAL
- en: That is enough theory for now! Let's create our Quiz app and apply some of the
    theory that we have discussed here.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you need to have the latest version of Android Studio and a
    real device on which Google Play services have been installed, which will be the
    case for most devices. Alternatively, you can install them on a virtual Genymotion
    device, but that will require some additional preparations.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you need to have (or to create) a Google developer account.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'And off we go. Start Android Studio and perform the following steps as we are
    going to build something great:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project in Android Studio. Name it `GetItRight` and click on the
    **Next** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the **Phone and tablet** option and click on the **Next** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Add an activity to mobile** view, choose **Google Play Service** and
    click on the **Next** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept the **activity name** and **title** fields and click on the **Finish**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Point your web browser at the Google Developer console and log in or register
    if you do not have an account yet. You can find it at: [https://console.developers.google.com](https://console.developers.google.com).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the developer console, click on the game tab (game icon on the left-hand
    side of the webpage).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept the terms of service if asked to do so.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Setup up Google Play Services** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the name of the app `Get It Right Sample`, and pick a category: **Trivia**,
    and click on the **Continue** button.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the game details view, enter a description and click on the **Save** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you need to generate an Oauth2 client ID. To do so, click on the **Linked
    app** link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick **Android** as your OS, enter `packt.com.getitright` as the **package name**,
    leave the other settings unchanged, and click on the **Save and continue** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Authorize your app now** button in step 2\. In the **Branding
    information** popup dialog, click on the **Continue** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Client ID** dialog appears. Enter `packt.com.getitright` as the package
    name. To get the signing certificate fingerprint, open **Terminal app** (for Windows:
    Command Prompt) and type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If asked for the `keystore` password, the default password for the debug keystore
    is `android`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy and paste the fingerprint (SHA1) and click on the **Create Client** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Back to the list** button, and after that click on the **Continue
    to next step** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Android app details** view, you will see the **Application ID** (if
    you scroll down a little) that we are going to need later. Copy its value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leaderboards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Follow the given steps for adding leader boards to your app:'
  prefs: []
  type: TYPE_NORMAL
- en: On the left-hand side of the webpage, choose **LEADERBOARDS** and click on the
    **Add new leaderboard** button. Name your new leaderboard `GetItRight Leaderboard`
    and click on the **Save** button. Note the leader board **ID**. We will be using
    it later:![Leaderboards](img/B04299_08_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `build.gradle` file inside the `app` directory of your project and
    add a dependency for Google Play services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Sync your project. In case it fails to resolve Google Play services, an error
    will be generated including a link that reads **Install Repository and sync project**.
    Click on this link to do so.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `AndroidManifest.xml` file and add a metadata tag to the application
    tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, add `app_id` to the `strings.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Add a breakpoint on the first line of the `onConnected` method of the `GooglePlayServicesActivity`
    class. Do the same thing for the first line of the `onConnectionFailed` method.
    Using the Google Play service template and the provided app ID, you should be
    able to connect to Google Play Services already. Run the app (in debug mode) to
    find out if it does.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Android Resource directory and choose **layout** as the Resource
    type; create a new layout resource file within that directory and name it `activity_google_play_services.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add some new strings to the `strings.xml` resource file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a layout for the `activity_google_play_service` resource file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `GooglePlayServicesActivity` file. In the `onCreate` method, load
    the layout and set the on click listeners for all buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `onClickListener` method for the `GooglePlayServicesActivity`
    file. Android Studio will suggest an implementation and you can accept this suggestion
    or add the implementation yourself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add two private members, one for our leaderboard request and one that will
    hold your leaderboard ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the implementation for the `onClick` method. We are preparing the situation
    where the user clicks on any of the multiple choice options. For the **leaderboard**
    (test) button, we can add the implementation right away:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new package and name it `models`. Create the `Answer`, `Question`,
    and `Quiz` classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To add the `Answer` class, you need the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To add the `Question` class, use the given code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To add the `Quiz` class, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new package and name it `repositories`. Create a new class and name
    it `QuizRepository`. Add some questions to the quiz. You can use the questions
    from the following example, but you can create some questions yourself as well
    if you would like to do so. In a real app, the questions and answers, of course,
    would not be hardcoded but retrieved from a database or from a backend (note that
    we can always change this behavior later without the need to modify anything but
    this class):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `GamePlayServicesActivity` class, add these three private members:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the implementation for the `newGame` method. We will get the `Quiz` object
    by asking the repository for it. After resetting the score and the question index,
    we call the `displayQuestion` method, which implements the UI logic by actually
    displaying the question, the possible answers, and a nice image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Let the game begin!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following steps can be used to add methods to a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the `onCreate` method, we will call the `newGame` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `onClick` method, so we can respond when a user clicks on any of
    the buttons. If any of the multiple choice buttons are being clicked on, we will
    call the `checkAnswer` method. Is it the correct answer we have chosen? How exciting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `checkAnswer` method. We will compare the given answer against the
    correct answer for the question, and depending on the result, we will call the
    `onGoodAnswer` or `onWrongAnswer` methods. Depending on the answer, your progress
    gets decided: if the answer is wrong, the game is over and we display the leader
    board.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If there are no more questions, we will submit the users score and display
    the leader board as well. The leader board itself will take care of all the logic
    for it. Was the submitted score high enough to make your name appear on top of
    the list? Check it with the help of the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To be prepared for unit testing and code inspection let''s add annotation support.
    Open the `build.gradle` file in the `app` folder and add the dependency. Click
    on the **Sync now** link that appears after modifying the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If an error appears that reads `Failed to resolve support-annotations`, then
    click on the **Install Repository and Sync Project** link that appears.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If all goes well, then we can add annotations, for example, to the parameter
    of the `CheckAnswer` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Question` class, we could add a `@Nullable` annotation to the `getPossibleAnswers`
    method, which could be the case if we did not provide any multiple choice option
    for a question:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Later, if we do some analysis, this will result in a warning for `GooglePlayServiceActivity`,
    where we will be calling this method. We will have a closer look at that in the
    *code analysis* recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can play the game if you like and add some more annotations. Just don't
    play too long with them. Let's play the game instead!
  prefs: []
  type: TYPE_NORMAL
- en: Run your app and become number one on the leader board. Since currently you
    are the only test player, that cannot be too hard I guess.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have just created your own quiz app, which you can extend with some other
    challenging questions if you like, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Let the game begin!](img/B04299_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have investigated Google Play services and we have been using a MVC approach
    for our app. Also, we had a look at how to use annotations, which could help us
    to improve code after doing some code analysis.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We had only a sneak peek at patterns and how to apply them. Check out the Internet
    or get some great books to learn more about patterns. Also, refer to [https://www.google.com/design/spec/patterns/app-structure.html](https://www.google.com/design/spec/patterns/app-structure.html).
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you read the docs about support annotations as well. There are so
    many more possibilities using them. Check the docs out at [http://tools.android.com/tech-docs/support-annotations](http://tools.android.com/tech-docs/support-annotations).
  prefs: []
  type: TYPE_NORMAL
- en: Also, we have been using Google Play services for only a fraction. We just know
    how to sign in and how to use a leader board. If you want, you can check out the
    other options. For that, refer to [https://developers.google.com/games/services/android/quickstart](https://developers.google.com/games/services/android/quickstart).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to [Chapter 7](ch07.html "Chapter 7. Content Providers and Observers"),
    *Content Providers and Observers*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing using Robolectric
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing is a testing method where individual units of code are tested.
    A view or repository can be tested, for example, to check whether it meets the
    demands. Unlike most other tests, these kinds of tests typically are developed
    and run by a software developer.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, a test case is completely independent from other cases and other units.
    Since classes often depend on others substitutes such as mock objects needs to
    be used. In the previous recipe, the `QuizRepository` class provides hardcoded
    quiz data (stubbed or mocked data), but as suggested, the intention is that the
    quiz data should be retrieved from a backend.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to prepare the app we created in the previous recipe for unit testing,
    and we will create some tests ourselves. **Robolectric** is going to help us with
    that. Although since the 1.2 release of Android Studio unit testing (based on
    JUnit) has become much easier to set up, it still is not as powerful as Robolectric.
  prefs: []
  type: TYPE_NORMAL
- en: Robolectric does not need additional mock frameworks and it can be run outside
    the emulator as well, allowing us to combine unit testing with a continuous integration
    environment, as we are going to do in [Chapter 10](ch10.html "Chapter 10. Beta
    Testing Your Apps"), *Beta Testing Your Apps*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, it would be most ideal to have the previous recipe successfully
    completed. In case you prefer to skip that part of this chapter, you can, of course,
    open your own project and set up unit testing in more or less the same way. That
    is up to you.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So what do we have to do to create and run some unit tests? Let''s find out:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project that we created in the previous recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `build.gradle` file within the `app` folder and add a dependency for
    Robolectric:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Rename the `androidTest` folder in the `src` folder to `test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Run** menu choose the **Edit configurations** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the left-hand side of Run\Debug Configuration window, choose **Defaults**
    and **JUnit**. On the right-hand side change the content for **Working directory**
    to `$MODULE_DIR$` and click on the **OK** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the **ApplicationTest** class to `QuizRepositoryTest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add some tests to the **QuizRepositoryTest** class. We will be using Robolectric
    for this. As you can notice, we will be using annotations here as well just like
    we did in the previous recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another test class so we can test the activity. Name the new class `GooglePlayServicesActivityTest`.
    Within this test, we could perform some layout tests as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Open the `build variants` pane and choose `Unit tests` instead of `Instrumentation
    tests`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Everything under the `test` package will be highlighted in green now (you may
    need to do a rebuild first). If you right-click on the package name `packt.com.getitright`
    or on any of the test classes you created, you will find an option in the context
    menu **Run tests in packt.com.getright** or **Run QuizRepositoryTest**. For example,
    choose to run `QuizRepositoryTest`.If you choose this option, Gradle starts thinking
    for a bit. After a while, the results are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Only the tests that fail are shown by default. To see the tests that did succeed
    as well, click on the **Hide passed** button (the button above the test tree shown
    on the left-hand side).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see that the **quizHasQuestions** test has passed. However, the **quizHasSufficientQuestions**
    test has failed. This makes sense, as our test requires our quiz to have at least
    10 questions while we added only three to the quiz, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04299_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Add seven more questions to `Quiz` in `QuizRepository` to get it right. Well,
    you can cheat, of course, by modifying the test, but let's just say it is a business
    requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Rerun the test. Every unit test succeeded. Hurrah! Create a few more unit tests
    that you can think of.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is a very interesting option because we can use it for continuous
    integration purposes as well. Think of a scenario where we run the unit tests
    each time you commit (and push) your source to a central repository such as GitHub
    or BitBucket. If the compilation and all unit tests succeed, we can create a new
    (ad hoc) release automatically or be notified whether the compilation or any of
    the tests failed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are plenty of other tools and approaches available for mobile testing
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to unit testing, we want to test the **User Interface** (**UI**)
    as well, for example, by using Espresso.
  prefs: []
  type: TYPE_NORMAL
- en: Espresso
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Espresso is suitable for writing concise and reliable Android UI tests. A test
    typically contains clicks, text input, and checks. It is actually pretty simple
    to write tests. The following is an example of a test using Espresso:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To quote the website:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Espresso tests state expectations, interactions, and assertions clearly without
    the distraction of boilerplate content, custom infrastructure, or messy implementation
    details getting in the way".*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For more information, refer to [https://code.google.com/p/android-test-kit/wiki/Espresso](https://code.google.com/p/android-test-kit/wiki/Espresso).
  prefs: []
  type: TYPE_NORMAL
- en: Approaches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When it comes to testing, there are different approaches you can think of. One
    of these approaches is **Test-driven Development** (**TDD**). If the functionality
    and all requirements are known, we can define our tests before developing our
    app. Of course, all tests will fail initially, but that is actually a good thing.
    It will set an outline of what needs to be done and create focus to get things
    right. If you start developing more and more, tests will succeed, remaining the
    amount of work.
  prefs: []
  type: TYPE_NORMAL
- en: Another and more recent approach is **Behavior-driven Development** (**BDD**).
    This testing approach is based around features, where a feature is a collection
    of stories expressed from a particular point of view.
  prefs: []
  type: TYPE_NORMAL
- en: 'BDD tools come as a unit testing flavor such as `Rspec` for example and as
    a higher level acceptance testing flavor: `Cucumber`.'
  prefs: []
  type: TYPE_NORMAL
- en: Cucumber, Gherkin, and Calabash
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No, this is not a greengrocer advertisement that suddenly has popped up here.
    **Cucumber** is a tool that runs automated acceptance tests written in a BDD style.
    It allows the execution of a feature documentation written in a business-facing
    text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a feature file using **Gherkin**. It serves two purposes:
    documentation and automated tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`Gherkin` is a business-readable, domain-specific language that lets you describe
    a software''s behavior without detailing on how that behavior is implemented.
    Therefore, these tests can also be written by the nondeveloping members of your
    team.'
  prefs: []
  type: TYPE_NORMAL
- en: There is some glue code required to make things happen. In Cucumber, this process
    is defined in step definitions. Cucumber typically lets you write these step definitions
    in the Ruby language.
  prefs: []
  type: TYPE_NORMAL
- en: Through the Calabash framework, you can use Cucumber to create tests for both
    Android and iOS. It enables you to define and execute automated acceptance tests.
    Another great thing about Calabash is that it allows you to run automated tests
    on the cloud, for example, using the services of TestDroid.
  prefs: []
  type: TYPE_NORMAL
- en: First things first!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about Cucumber, visit [https://cucumber.io](https://cucumber.io).
  prefs: []
  type: TYPE_NORMAL
- en: You will find the Calabash framework at [http://calaba.sh](http://calaba.sh).
  prefs: []
  type: TYPE_NORMAL
- en: Also, check out [www.testdroid.com](http://www.testdroid.com) for more information
    about testing on as many devices as possible using TestDroid a cloud based test
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, find a good balance between time, quality, and money. The approach
    to test your app depends on how valuable you (or your company or your customer)
    think each of these elements are. Create at least unit and UI tests. Also, let's
    not forget about performance testing, but that a topic that will be discussed
    in the next chapter!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to [Chapter 9](ch09.html "Chapter 9. Improving Performance"), *Improving
    Performance*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to [Chapter 10](ch10.html "Chapter 10. Beta Testing Your Apps"), *Beta
    Testing Your Apps*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code analysis tools, such as Android Lint, can help you detect potential bugs
    and how your app can be optimized for security, usability, and performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android Lint comes with Android Studio, but there are also other tools available
    such as: Check Style, **Project** **Mess Detector** (**PMD**), and Find Bugs.
    In this recipe, we will only have a look at Android Lint.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most ideally, you would have completed the first two recipes of this chapter,
    so we will now examine the results of the app. However, you can use `Android Lint`
    (or another tool) on any project to see where things can be improved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The support annotations of the first recipe influence the results being displayed.
    Yes, that is right, we cause these warnings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is nothing that we need to install in order to get an Android Lint report,
    as it is already in there with Android Studio. Just follow the next steps to make
    use of it:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project you have created in the previous recipes. Or, alternatively,
    open your own project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Analyze** menu, choose **Code inspection**. The inspection scope
    is the whole project. Click on the **OK** button to proceed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The results for inspection will be presented as a tree view. Expand and select
    items to see what each item is about, as shown in the following snapshot:![How
    to do it...](img/B04299_08_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Things look pretty serious here but actually, it is not all that bad. There
    are some issues that are no show stoppers at all, but fixing them could greatly
    improve your code, which is what we are aiming at for now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, check out the **Declaration redundancy** | **Declaration access
    can be weaker** | **Can be private** issue. Navigate to it. Double-click on it
    to jump to the code where the issue appears. Right-click on it. The context menu
    provides a solution for this right away. Choose the **Make field private** option
    to apply the correct solution. If you do so, this item will be marked as done
    (strike-through).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now have a look at **Hardcoded texts**. If you double-click on any of the items
    that are related to this issue, you will see what the problem is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For our convenience, we did put a temporary text (such as `Question` in `Text
    View`). If this was for real, we should be using a string resource instead. Here,
    we can safely remove the text. If you rerun the code inspection, the issue will
    disappear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, have a look at **Constant conditions & exceptions** under **Probable
    bugs**. For the `GooglePlayServicesActivity` file, it says:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you double-click on this message, you will find what the issue is about:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This line may produce `Null Pointer Exception` Why is that? If you go to the
    declaration of the `getPossibleAnswers` method by selecting it and pressing *Cmd*
    + *B* (for Windows: *Ctrl* + *B*) you will find out why:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Ah right! We added this annotation ourselves in the first recipe to remind our
    later selves (or fellow developer) that the answers that are returned might be
    null. There are a couple of ways to fix this.
  prefs: []
  type: TYPE_NORMAL
- en: We could remove the `@Nullable` annotation here, but that would be bad since
    the answers actually could be null. We also could choose to suppress the warning.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The best solution is to actually test the outcome of the `getAnswers` method
    before doing anything with it. Just like that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Expand **Declaration redundancy** | **Method can be void** | **Question**.
    It says:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Double-click on the issue to jump the code. Well, that warning is correct but
    suppose I do want to return the answer any way because I am pretty sure (how sure
    can you be?) I will be consuming it later. In that case, you could right-click
    on the issue and choose the **Suppress for Member** option. You will not be bothered
    by this issue again because it will add the `SuppressWarnings` annotation to your
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Finally, have a look at **Spelling warnings**. Expand **Spelling** and the underlying
    **Typo** and **app** items. There it is. A `Typo`!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We didn''t get **getitright** right now did we? Since it is the name of our
    app and because it is part of the package name, I am pretty sure we can safely
    ignore this warning. This time, we right-click on the type and choose the **Save
    to dictionary** option:'
  prefs: []
  type: TYPE_NORMAL
- en: The list of warnings seems to be endless, but how severe are all these items?
    On the left-hand side of Android Studio, you will find a button with the **Group
    by Severity** tooltip. Click on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the tree view contains an error node (if you have any), a warning node,
    and a typo node. If you just concentrate on the errors and warnings and see what
    each item is about, then you will improve your code and actually learn quite a
    lot, as each issue comes with a description of the problem and a suggestion on
    how to fix it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Great, you learned some cool stuff today! And wrote better code by applying
    patterns, running unit tests, and by fixing issues reported by `Android Lint`.
  prefs: []
  type: TYPE_NORMAL
- en: We now know that our app does what it should do and that it is well structured
    after some refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing to wonder about is what would happen if the images we are loading
    from the Internet are 10 times the size they are now? What if we have 1000 questions?
    Unreal? Perhaps.
  prefs: []
  type: TYPE_NORMAL
- en: How will our Quiz app perform on a low-end device? In the next chapter, we will
    go after the answers to these and other questions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to [Chapter 9](ch09.html "Chapter 9. Improving Performance"), *Performance*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to [Chapter 10](ch10.html "Chapter 10. Beta Testing Your Apps"), *Beta
    Testing Your App*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
