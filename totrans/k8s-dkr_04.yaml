- en: '*Chapter 3*: Understanding Docker Networking'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have focused on how to access a container when we are local on the
    host system. There are use cases where local container access is all that may
    be required, but often, you will want to expose your containers to external users
    or systems. Exposing your containers to external users is not always as simple
    as just running a container. You will need to consider various options that Docker
    offers to connect your containers to the network. To avoid frustration, you should
    also understand how systems communicate using IP, including any limitations in
    regard to exposing IP ports.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Docker networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating user-defined bridge networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter does not have any technical requirements.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to create networks using the examples in this chapter, you can use
    the Docker host that we created in [*Chapter 1*](B15514_01_Final_ASB_ePub.xhtml#_idTextAnchor018),
    *Docker and Container Essentials*. The networks that we'll be using for the examples
    in this chapter are not required for future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access the code to create a Docker host from [*Chapter 1*](B15514_01_Final_ASB_ePub.xhtml#_idTextAnchor018),
    *Docker and Containers Essentials* by going to the following GitHub repository:
    [https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide).'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Docker networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss the networking options that are available in
    Docker and how you can use them to expose your containers to external users and
    systems. Docker includes various networking options to connect containers to your
    network, and if none of the included networking options fit your requirements,
    you can select from a number of third-party networking add-ons that offer features
    that may not be included in the base networking stack. By default, Docker networking
    focuses on a single host, but for more complex use cases, it includes networking
    features to facilitate cross-host networking by using Docker Swarm. Since the
    industry has moved away from using Docker Swarm to other offerings such as Kubernetes,
    this chapter will focus on single-host networking.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid potential frustration when you expose containers, you should have a
    good understanding of how IP uses ports for communication. Many of you may know
    IP well, but we thought it would be beneficial to provide a short refresher on
    how TCP/IP uses ports to communicate.
  prefs: []
  type: TYPE_NORMAL
- en: A quick TCP/IP port refresher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We do assume that you have a working knowledge of TCP/IP, but for those of you
    who are new to this, it's important to highlight some networking topics that will
    be referenced in this chapter. Understanding ports is a vital concept to fully
    understand the limitations of exposing services in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: As you may know, when you configure IP on a system, you assign a unique IP address
    to each network adapter in the system. When an incoming or outgoing connection
    is made, the request includes the IP address and a port between **1** and **65535**.
    You may not always see the port in the request since many applications will automatically
    include it in the default request, based on the protocol being used. When you
    are in a browser and enter a URL, you usually just enter the URL using the protocol
    and hostname. As an example, let's say you want to open the main Kubernetes page,
    so you enter [http://kubernetes.io](http://kubernetes.io) in your browser. What
    is not shown or required is the port. HTTP has a default port of 80, and all browsers
    will default the request to use port **80** – behind the scenes, the browser is
    requesting [http://kubernetes.io:80](http://kubernetes.io:80).
  prefs: []
  type: TYPE_NORMAL
- en: 'This combination of the IP address and the port is called a socket, represented
    as **<IP address>:<port>** (that is, **192.168.1.1:443**). A socket is required
    for communication that occurs in both directions. When you request a web page,
    your computer will make an outgoing request using a port that is randomly selected
    from between **49152** and **65535**. This can be a little confusing if you are
    new to IP, so the following is an example of a connection from a workstation to
    two different web servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Socket example'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.1_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Socket example
  prefs: []
  type: TYPE_NORMAL
- en: In *step 1*, a request is sent to a web server running on **192.168.100.10**
    from a workstation. The workstation uses a randomly generated port to initiate
    the outgoing request to the web server on port **80**. Next, in *step 2*, the
    web server replies to the client using the client IP **of 192.168.100.150** on
    port **49160**.
  prefs: []
  type: TYPE_NORMAL
- en: We added *step 3* to show that a simultaneous connection to another web server
    will generate a different outgoing port, targeting a second web server on port
    80.
  prefs: []
  type: TYPE_NORMAL
- en: Binding a port to a service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the server side, where you may be running a server such as NGINX to host
    a website, you must bind a socket to the web server process. The bound IP address
    can be a single IP, or it can be bound to all the IP addresses by using an address
    of 0.0.0.0, which binds the port to all the available IP addresses on the server.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we will use a host with a single network card and a single IP
    address. When you want to bind a port to a process, you configure the process
    so that it uses the IP of the server and an assign a port of **80**. We want to
    highlight a key word in the last sentence, *bind* – by definition, to bind something
    is to tie or fasten tightly. When you bind a port to an IP address, it is exclusively
    bound and cannot be bound to any other running process using that IP address.
    In other words, since the socket has been tied, it cannot be tied to any other
    process on the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to configure a process on a port that has been bound, you will receive
    an error similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bind for 192.168.1.1:443 failed: port is already allocated'
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted to run another process on the host, you only need to specify a
    unique port. On the same server running NGINX, you could run a MySQL server running
    on port **3306**. Since the port is different from the web server running on port
    **80**, it creates a unique socket.
  prefs: []
  type: TYPE_NORMAL
- en: How you expose a container using ports differs based on the Docker networking
    driver you are using for the container. In this chapter, we will explain the common
    networking options and how to configure and use each of them on your host. Once
    you understand these options, we will finish this chapter by looking at how to
    expose your containers to users outside the local host system using port assignments.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, let's start by discussing the various network drivers that Docker
    includes.
  prefs: []
  type: TYPE_NORMAL
- en: Docker networking drivers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The networking system for Docker is modular. A base Docker installation includes
    a few network drivers and if you require a specialized networking driver, there
    are options available from other vendors. For the purpose of this book, we will
    only use the included networking drivers for our networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, you have the option of using five networking options. In reality,
    you have four options with a fifth option of none; that is, to disable networking.
    The options that are included with Docker are detailed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Docker networking drivers'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.1a_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Docker networking drivers
  prefs: []
  type: TYPE_NORMAL
- en: 'A default Docker installation will include a few preconfigured networks:'
  prefs: []
  type: TYPE_NORMAL
- en: A default bridge network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A default host network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most Docker users simply use the default bridge network, which will work for
    most use cases, but it does have some limitations that need to be considered.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will go over the default bridge network, a custom bridge
    network, and the no networking options. The host networking option is primarily
    used when your host is part of Docker Swarm, but it can be used without Swarm
    if you understand the limits of how ports are exposed when using it.
  prefs: []
  type: TYPE_NORMAL
- en: The default bridge network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding table, you learned that a bridge network only provides networking
    to containers running on the same Docker host. Unless you are running multiple
    Docker hosts by using Docker Swarm, you will usually use a bridged network with
    your Docker containers. When you install Docker, it will create what's known as
    the default Docker bridge network. By supplying the default bridge for all installations,
    Docker has made using a network in a container very simple. Many users simply
    start using Docker with the default networking settings and options, thereby starting
    up containers without knowing the limitations and potential security risks of
    the default bridge. Before using a Docker host, you should always consider creating
    a user-defined bridge, or multiple bridges, depending on your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker includes an easy to use default network, so why should you consider
    creating a user-defined bridge? Since the default bridge maintains backward compatibility,
    many of the bridge features had to be limited. Due to these limitations, the default
    bridge is considered to be inferior compared to a user-defined bridge. While that
    may sound a little harsh, consider the following list, which details items to
    consider when using the default bridge:'
  prefs: []
  type: TYPE_NORMAL
- en: When a container is started **without** a network specified, it will use the
    default bridge. This means that multiple containers will be able to communicate
    by default, without any consideration being given to the workloads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Consider*: If you are running multiple containers and you want to isolate
    some containers from others, you may inadvertently allow communications between
    containers since they are using the default bridge.'
  prefs: []
  type: TYPE_NORMAL
- en: The default bridge limits communications between containers to IP addresses
    only. Containers connected to user-defined bridges can communicate using container
    names or IP addresses. Containers that use a user-defined bridge can communicate
    using IP addresses or host names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Consider*: When you start up a container, the IP address may be different
    from the last time you ran the image.'
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted to configure an application that has multiple containers that
    interact, you can use the container names, which will remain constant through
    restarts. If you were using the default bridge, you may need to change the configuration
    files due the containers starting with a different IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Containers that use the default bridge need to be stopped before you can move
    them to a different network. However, on a container using a user-defined switch,
    you can change the network without restarting the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Consider*: Depending on your workloads, you may not be able to stop a running
    container without an agreed maintenance window. While a networking change would
    still require a change request in most companies, it can be done without stopping
    the container if you are using a user-defined bridge. This will limit any potential
    impact to the application and offers a quick failback if something is misconfigured
    on the new network bridge.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a single default bridge limits networking options for all containers.
    Since all the containers are on a single network, all networking settings are
    the same for all containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Consider*: You may have a requirement for some containers to run jumbo frames,
    while other containers will use a standard MTU size. If you only used the single
    default bridge, you can only set one MTU size. However, you could create a user-defined
    bridge that sets the MTU to 9000 and another that keeps the default MTU size of
    1500.'
  prefs: []
  type: TYPE_NORMAL
- en: With this, you can see why we mentioned that the default bridge is inferior
    to a user-defined bridge. Depending on your use case, you may be able to use the
    default bridge for all your needs, and for the purposes of this book, we will
    use the default bridge for our exercises. However, in a production environment
    running Docker, you should **always** create a new user-defined bridge.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know about the various networking options and the pros and cons
    of each type, it's time to dig into managing and creating Docker networks. Before
    we create a network, we'll take a look at the default networks that Docker includes
    by default and how to look at the details of a network using the Docker CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the available networks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To view all the existing networks on a Docker host, we can use the **network**
    management option in the Docker CLI with the **ls** option. When you execute a
    list of Docker networks, your output will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Default Docker network list'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.2_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Default Docker network list
  prefs: []
  type: TYPE_NORMAL
- en: The preceding list is from a base Docker installation, so only the three default
    networks options are available.
  prefs: []
  type: TYPE_NORMAL
- en: The **docker network ls** command does not contain a lot of information; it
    is meant to provide you with a quick summary of the available networks. To dig
    a little deeper into the details of a network, you can ask Docker to inspect the
    network, which will provide all the network settings.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving details on a network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have created multiple user-defined networks, you may start to lose
    track of the settings for each network, or what containers are running on each
    network. You can look at the details of each network on the host using the **docker
    network inspect <network name>** option. The output from an **inspect** command
    contains detailed information about the network, including the subnet, gateway,
    driver type, and all connected containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – network inspect output'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.3_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – network inspect output
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screenshot shows that the network is a bridge, but we already
    know that from the **"Driver": "bridge"** section of the output. In the containers
    section of the output, you can see that the bridge has two containers attached
    to it. The first container is named **NGINX1** and has an IP address of **192.168.10.3**,
    while the second container is named **frontend** and has an IP address of **192.168.10.2**.
    The **inspect** command also shows the assigned MAC address for each container
    and, if enabled, the IPV6 address.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to keep track of the networks on the host, let's dive
    into user-defined bridges.
  prefs: []
  type: TYPE_NORMAL
- en: Creating user-defined bridge networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you create a new user-defined network, you can supply most of the standard
    IP options that you would use when creating a new network outside of Docker. You
    can set options for the subnet, IP range, and gateway. Remember that the network
    you define here is only internal to your Docker host and that the IP addresses
    you assign will not be addressable outside the host. To read about more advanced
    options, you can visit the advanced Docker networking page at [https://docs.docker.com/engine/reference/commandline/network_create/#specify-advanced-options](https://docs.docker.com/engine/reference/commandline/network_create/#specify-advanced-options).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a user-defined network, we use the **network management** option
    in the Docker CLI, along with the **create** option. The syntax is very simple;
    you only need to provide the desired network name for the new network and Docker
    will create the new network. To create a new network called frontend, we simply
    need to execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Output from creating a Docker network'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.4_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – Output from creating a Docker network
  prefs: []
  type: TYPE_NORMAL
- en: 'This will return the network ID. If you list the networks again, you will see
    a new bridge network is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Docker network list'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.5_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – Docker network list
  prefs: []
  type: TYPE_NORMAL
- en: Since we did not specify any options other than the network name, Docker will
    assign a non-overlapping IP range to the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to create a second network called backend that used the **192.168.10.0/24**
    subnet using a gateway of **192.168.10.1**, you just need to add **--subnet**
    and **--gateway** to the **docker network create** command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Adding options example'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.6_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – Adding options example
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create a new network, like we did for the backend network example,
    Docker binds a new IP on the host equal to the gateway address we used in the
    **create** command. The following is the output of using **ip addr** on our host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Host IP added after network creation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.7_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – Host IP added after network creation
  prefs: []
  type: TYPE_NORMAL
- en: This will allow your host to route network traffic to any container that attaches
    to the switch. Containers can access network resources outside the host by using
    the hosts IP as the default gateway.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have created a user-defined network, let's look at how to assign
    the new network to a container when running an image.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting a container to a user-defined network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can connect a container to a specific network when starting the container
    by adding the **--network** option to your **docker run** command. To attach a
    new NGINX container to the frontend network we created earlier, we only need to
    add **--network=frontend** when we start the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Connecting a network at startup'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.8_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – Connecting a network at startup
  prefs: []
  type: TYPE_NORMAL
- en: The preceding command will start a new NGINX container named frontend, on the
    user-defined network named **frontend**.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the network on a running container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We mentioned that one advantage of using a user-defined network over the default
    network was the ability to change the container's network on the fly, without
    stopping the container.
  prefs: []
  type: TYPE_NORMAL
- en: To change the network of a running container, you can use the Docker network
    options known as **connect** and **disconnect**, along with the network name and
    the container name. When you use the **connect** option, you add a network to
    the container, while if you use the **disconnect** option, you remove a network
    from a container, all without the need to stop the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our NGINX example, we assigned the frontend network, but if we wanted to
    change that to the backend network, we only need to add one network and remove
    the other. The first step would be to attach the backend network using the **docker
    network connect** command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Connecting a network'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.9_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – Connecting a network
  prefs: []
  type: TYPE_NORMAL
- en: This will connect the network named backend to our container named frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second step is to remove the frontend network using the **disconnect**
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Disconnecting a network'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.10_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – Disconnecting a network
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering if you can attach a container to more than one network,
    and the answer is yes. If you had a requirement for a container to access a network
    that requires jumbo frames but it also needs to access a standard network connection,
    you could connect the container to two different user-defined networks. Detailing
    this scenario is out of scope for this book and can become a complex topic since
    it may require custom routing to be created in the container, but it's good to
    know that it can be done and that there are specific use cases for it.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you no longer need a user-defined network, you can delete the network from
    your host using the **docker network rm <network name>** command. To delete the
    frontend network we created earlier, we would execute the **docker network rm**
    command with the network name, **frontend**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Removing a network'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.11_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – Removing a network
  prefs: []
  type: TYPE_NORMAL
- en: 'If you had multiple networks that you wanted to remove, then you can use the
    **prune** command, which will delete all unused networks on the host. This is
    similar to pruning the unused volumes. You only need to run **docker network prune**
    to remove the unused networks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Pruning a network'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.12_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – Pruning a network
  prefs: []
  type: TYPE_NORMAL
- en: Once you've verified you want to continues, Docker will list the networks that
    were removed. In our example, it removed a network called **network4**.
  prefs: []
  type: TYPE_NORMAL
- en: Just like the **volume prune** command we discussed earlier, **this is a one-way
    process**. When you select yes to prune the networks, there is no undo, so always
    be **100%** sure that you want to delete the networks before verifying the action.
  prefs: []
  type: TYPE_NORMAL
- en: Running a container without networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that if you start a container without a network option, it will start
    connected to the default bridge network. You might have a requirement to test
    a container that may contain something suspicious, and having it connected to
    **network** could put the entire network at risk.
  prefs: []
  type: TYPE_NORMAL
- en: This is no different than the physical world. For example, if you had a machine
    that appeared to be acting in a malicious manner, you would down the network port
    or disconnect the network cable. In the container world, we may be running multiple
    containers on the host and we may not be able to simply pull the cable without
    effecting many workloads. We have two options available, depending on whether
    the container is already running, and if it is, you do not want to lose the running
    state.
  prefs: []
  type: TYPE_NORMAL
- en: If the container is stopped, you could simply start the container without an
    attached network by using the **--network=none** option when you start the container.
    This is the same process that you follow when you start a container with a user-defined
    network, except we specify the network name as **none**.
  prefs: []
  type: TYPE_NORMAL
- en: You may not be able to stop the container if you suspect it has something malicious
    running. If you needed to look at the running processes, RAM content, and so on,
    stopping the image would destroy anything running and you may lose valuable information.
    Rather than stopping and restarting the container using the network value of none,
    you could just disconnect the running container from the network. This would limit
    the container's ability to affect anything outside of the local image.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing container services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you know the networking options available in Docker, the next step
    is to expose any ports you want to accept traffic when you start a container.
    There are two options when it comes to exposing ports. The first is to use the
    **host network** option, while the second is to expose the port(s) on a bridge
    network when the container is started. Using the **host network** option is easier
    since you do not require any manual port mappings, but this makes it a challenge
    to keep track of ports as your number of running containers grows. We only suggest
    using the **host network** option if you plan to run a single container.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing ports using a host network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we stated in the table provided earlier in this chapter, *"A container using
    the host network driver will not get an IP address and does not need to expose
    ports to allow incoming traffic."* Since the container will start up directly
    on the host network, bypassing Docker's network stack completely, you do not need
    to expose any ports for the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, to start a web server running NGINX on the host, using host
    networking, you would run the **docker run** command while providing **host**
    as the network type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Using the host network option'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.13_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14 – Using the host network option
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to verify the container is running and to look at any ports that may
    be exposed, so we''ll run **docker ps** to list the running containers. The container
    shows as running, but under **PORTS**, we don''t see anything listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Example port view from a host connection'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.14_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15 – Example port view from a host connection
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the container was started using the **host network** option, we do not
    need to expose any ports. The NGINX container that we have been using runs on
    port **8080**, and since it bypasses Docker networking, the only method to prove
    it''s using port **8080** is to run **netstat** on the host system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – Host netstat showing port 8080 in use'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.15_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.16 – Host netstat showing port 8080 in use
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks like the container is running and listening on port 8080\. From another
    machine on the network, we can open a browser and enter the IP address of the
    Docker host machine and use port 8080:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – NGINX running on a host network'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.16_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.17 – NGINX running on a host network
  prefs: []
  type: TYPE_NORMAL
- en: Here, we received the welcome page from NGINX, proving that the container is
    running.
  prefs: []
  type: TYPE_NORMAL
- en: Since the **docker ps** command did not list the ports that are in use, you
    can see where you may start to lose track of the assigned ports if your host is
    running multiple containers when using the **host network** option. This is why
    we suggest limiting use of the **host network** option, unless you are running
    a single container or a container that requires host networking.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: As we have stated, a socket must be unique on the host. In our example, we have
    been using a single NIC and a single IP address, which means a port can only be
    used one on the host. Since a socket is a combination of the IP address and the
    port, you could add a second IP address to the single NIC or add an additional
    NIC with a new IP address to create a new, unique socket. This will allow you
    to create a new binding of an already assigned port to another process since the
    socket will be unique.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s stop the NGINX container and look at **netstat** again to show
    that the port is no longer in use. We will use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sudo docker stop nginx**'
  prefs: []
  type: TYPE_NORMAL
- en: '**sudo docker rm nginx**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we''ll use netstat to show the active ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 – Host netstat showing port 8080 is not in use'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.17_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.18 – Host netstat showing port 8080 is not in use
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the only port open on the host is SSH; port **8080** has been
    closed since the container has been stopped.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing ports using a bridge network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It may seem that using the **host network** option makes exposing ports easy,
    since you don't need to actually do anything to expose them. This may seem attractive
    initially, but if you were running multiple containers on a host and more than
    one was configured to run on the same port, such as port 8080 for our NGINX container,
    you would be limited to a single container due to the port conflict.
  prefs: []
  type: TYPE_NORMAL
- en: When an option seems easier, it is usually less robust or configurable, which
    is why it seems easier at the beginning. This is the case when exposing ports
    using host networking versus bridged networking, but once you understand how and
    why we expose ports using bridge networks, you will see why it offers a better
    all-round solution.
  prefs: []
  type: TYPE_NORMAL
- en: When you want to expose ports on a container that is using a bridge network,
    you only need to specify the ports you want to open when starting the container.
    If you have more than one bridge, you will need to provide the network name as
    well, but in our example, we will assume you are using the built-in bridge network.
  prefs: []
  type: TYPE_NORMAL
- en: When you expose a port in Docker, you need to supply the incoming (Docker host)
    port and the destination (the container) port using the **incoming port:destination
    port** syntax. Often, the numbers will be the same to keep things simple, but
    there will be scenarios where using a different port may be required.
  prefs: []
  type: TYPE_NORMAL
- en: If you only supply a port for the destination, a TCP connection will be assumed.
    You may need to expose UDP ports for a container, and to expose the port as a
    UDP port, just add **/udp** to the destination port assignment. So, your syntax
    would become **incoming port:destination port/udp**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using our example web server, we''ll start the container using the default
    bridge network listening on port **8080** using the **docker run** command with
    the **-p** option for the port; that is, **docker run -p 8080:8080 -p 8443:8443**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.19 – Exposing port 8080'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.18_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.19 – Exposing port 8080
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify the container is running, we will use the **docker ps** command and
    take note of the **PORTS** column, which shows the mapped port(s) for the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.20 – docker ps output showing assigned ports'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.19_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.20 – docker ps output showing assigned ports
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that the container is running and that we have mapped the incoming
    host ports **8080** and **8443** to the container ports **8080** and **8443**.
    Any incoming request to the Docker host on **8080** and **8443**, on any interface
    (0.0.0.0), will be forwarded to the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like when we used the host network, we can see that the host is listening
    on both **8080** and **8443** using netstat:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.21 – Host netstat showing port 8080'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.20_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.21 – Host netstat showing port 8080
  prefs: []
  type: TYPE_NORMAL
- en: 'Your project now calls for a second web server for another development site,
    and you want to deploy another NGINX container. The image uses ports **8080**
    and **8443** but both of those ports are in use by our first NGINX container.
    Attempting to run another container using **8080** and **8443** on the host will
    result in a port already allocated error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.22 – Port conflict example'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.21_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.22 – Port conflict example
  prefs: []
  type: TYPE_NORMAL
- en: 'One solution would be to create another container that listens on different
    ports, such as **8081** and **8444**, but that starts to become difficult to maintain.
    Instead, remember that when you expose a port, you designate the incoming and
    the destination ports. We want to use the same NGINX image, so we can''t change
    the container ports, but we can change the incoming ports on the host. When we
    start our second container, we will increase each port by one to avoid conflicts
    with the existing **8080** and **8443** rules, but we will still forward the ports
    to **8080** and **8433** on the new container. This may sound confusing, so it''s
    easier to see an example **docker run** command; that is, **docker run -p 8081:8080
    -p 80444:8443 –name nginx2 bitnami/nginx:latest**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.23 – Example of assigning ports 8081 and 8443'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.22_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.23 – Example of assigning ports 8081 and 8443
  prefs: []
  type: TYPE_NORMAL
- en: Since Docker returned the new container ID, we can see that, by increasing the
    incoming ports by one, we no longer have any conflicting ports.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing the currently running containers will show both NGINX containers and
    the port mappings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.24 – docker ps showing both running NGINX servers'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.23_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.24 – docker ps showing both running NGINX servers
  prefs: []
  type: TYPE_NORMAL
- en: 'Browsing to the host from another machine on the network on port 8081 will
    show the default NGINX welcome page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.25 – Browsing example to NGINX on port 8081'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.24_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.25 – Browsing example to NGINX on port 8081
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at netstat, we can see that all four ports are listening on the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.26 – Host netstat showing the four assigned NGINX ports'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_3.25_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.26 – Host netstat showing the four assigned NGINX ports
  prefs: []
  type: TYPE_NORMAL
- en: If you needed to run another NGINX container, you would just use another host
    port, potentially **8082** or **8445**. The main takeaway is that the incoming
    port on the host must be unique to avoid port conflicts. The container's port
    can be the same since each container runs in its own namespace and each has its
    own resources and ports.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about IP sockets and how hosts use ports to make
    a connection to a server. You learned that a socket is a combination of an IP
    address and the port and that it must be unique on the host. We then covered each
    networking type provided by Docker and use cases for each one, as well as when
    to use the default bridge network, a custom bridge network, host network, or no
    networking. Finally, you learned how to expose containers to external users.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll begin to explore Kubernetes by exploring the Kubernetes
    cluster, looking at its control plane, understanding the differences between a
    **kublet** and an API, learning how the worker node functions, and reviewing over
    25 Kubernetes objects.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Docker creates a default bridge network, there is no reason to create
    a custom bridge.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. True
  prefs: []
  type: TYPE_NORMAL
- en: B. False
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following is an example of a socket?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. **http:192.168.100.10**
  prefs: []
  type: TYPE_NORMAL
- en: B. **192.168.100.10**
  prefs: []
  type: TYPE_NORMAL
- en: C. **192.168.100.10:80**
  prefs: []
  type: TYPE_NORMAL
- en: D. **https://192.168.100.10**
  prefs: []
  type: TYPE_NORMAL
- en: How would you start a container running a web server on port **8080** named
    **nginx-web** on a host that already has its host port (**8080**) bound to another
    container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. **docker run -d nginx-web bitnami/nginx**
  prefs: []
  type: TYPE_NORMAL
- en: B. **docker run -p 8080:8080 -d nginx-web bitnami/nginx –force**
  prefs: []
  type: TYPE_NORMAL
- en: C. **docker run -p 8081:8080 -d nginx-web bitnami/nginx**
  prefs: []
  type: TYPE_NORMAL
- en: D. Since port **8080** is bound on the host, you cannot run a container on port
    **8080**
  prefs: []
  type: TYPE_NORMAL
- en: You suspect an image may contain malware. You need to run the image safely to
    look at its contents. What Docker command will mitigate any network impact?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. **docker run -isolate -it badimage bash**
  prefs: []
  type: TYPE_NORMAL
- en: B. **docker run -p 0:0 -it badimage bash**
  prefs: []
  type: TYPE_NORMAL
- en: C. **docker run -it badimage bash**
  prefs: []
  type: TYPE_NORMAL
- en: D. **docker run --network=none -it badimage bash**
  prefs: []
  type: TYPE_NORMAL
- en: Once a container is connected to a custom bridge network, you cannot change
    the connected network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. True
  prefs: []
  type: TYPE_NORMAL
- en: B. False
  prefs: []
  type: TYPE_NORMAL
- en: What is the highest IP port number you can expose on a container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. There is no limit
  prefs: []
  type: TYPE_NORMAL
- en: B. 65535
  prefs: []
  type: TYPE_NORMAL
- en: C. 65530
  prefs: []
  type: TYPE_NORMAL
- en: D. 65532
  prefs: []
  type: TYPE_NORMAL
- en: E. 65435
  prefs: []
  type: TYPE_NORMAL
