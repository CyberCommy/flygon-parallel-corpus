- en: Managing Signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Signals are software interrupts. They provide a way of managing asynchronous
    events, for example, a user from the terminal typing the interrupt key or another
    process sending a signal that must be managed. Every signal has a name that starts
    with `SIG` (for example, `SIGABRT`). This chapter will teach you how to write
    code to properly manage software interrupts, what the default actions defined
    by Linux for each signal are, and how to override them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning all of the signals and their default actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to ignore a signal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to trap a signal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to send a signal to another process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to let you try the programs in this chapter immediately, we've set
    up a Docker image that has all the tools and libraries we'll need throughout the
    book, it is based on Ubuntu 19.04.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to set it up, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install the Docker Engine from [www.docker.com](http://www.docker.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull the image from Docker Hub: `docker pull kasperondocker/system_programming_cookbook:latest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The image should now be available. Type in the following command to view the
    image: `docker images`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should have at least this image now: `kasperondocker/system_programming_cookbook`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Docker image with an interactive shell with the help of the following
    command: `docker run -it --cap-add sys_ptrace kasperondocker/system_programming_cookbook:latest /bin/bash`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The shell on the running container is now available. Use `root@39a5a8934370/#
    cd /BOOK/` to get all the programs developed, by chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `--cap-add sys_ptrace` argument is necessary to allow GDB in the Docker
    container to set breakpoints, which, by default, Docker does not allow.
  prefs: []
  type: TYPE_NORMAL
- en: Learning all of the signals and their default actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you all the signals and related default actions supported
    by Linux. We'll also learn why signals are an important concept and what Linux
    does for a software interrupt.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll list all the signals supported by our Linux distribution
    in order to be able to describe the most common ones in the *How it works...*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a shell, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this command on the Docker image of the book, which is based on
    the Ubuntu version 19.04 distribution, you''ll get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we'll learn what the default actions of the most common
    signals a process can receive are, a description for each, and how Linux manages
    these software interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *step 1,* we executed the `kill -l` command to get all the signals the current
    Linux distribution supports. The following table provides a list of the most common
    signals with the default action and description:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Signal** | **Description** | **Default Action** |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGHUP` | The Terminal controlling the process was closed (for example,
    the user logged out?) | Terminate |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGABRT` | Signal sent by `abort()`  | Terminate (with a core dump, if possible)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGSEGV` | Invalid memory reference | Terminate (with a core dump, if possible)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGSYS` | Bad system call or process tried to execute an invalid system
    call. | Terminate (with a core dump, if possible) |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGINT` | Interrupt generated from the keyboard (for example *Ctrl* + *C*)
    | Terminate |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGQUIT` | Quit generated from the keyboard (for example: *Ctrl* + */*)
    | Terminate (with a core dump, if possible) |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGPIPE` | A process tried to write to a pipe but with no reader | Terminate
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGILL` | A process tried to execute an illegal instruction | Terminate
    (with a core dump, if possible) |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGALRM` | Signal sent by `alarm()` | Terminate |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGSTOP` | Stop a process | Stop the process |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGIO` | Async I/O event | Terminate |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGTRAP` | Breakpoint trapped | Terminate |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGTERM` | Termination signal (catchable) | Terminate |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGKILL` | Process termination (un-catchable) | Terminate |'
  prefs: []
  type: TYPE_TB
- en: For each signal sent to a process, Linux applies its default action. The system
    developer can, of course, override this action by implementing the desired one
    on within the process, as we'll see in the *Learning how to trap a signal* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Signals are defined in the `<signal.h>` header file and are simply positive
    integers with a meaningful name always prefixed by the `SIG`word. What does Linux
    do when a signal (that is, a software interrupt) is raised? Simply put, it always
    applies the same sequential life cycle, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The signal is raised by a user of another process, or by Linux itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The signal is stored until Linux is able to deliver it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once delivered, Linux performs one of these specific actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ignore the signal: we''ve seen that there are signals that cannot be ignored
    (for example, `SIGKILL`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Perform the default action: you can refer to column 3 of the preceding table.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handle the signal with the registered function (which the system developer implemented).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the signals, described and defined in the `<signal.h>` header file are POSIX
    compliant. This means that each identifier, their names, and the default actions are
    defined by the POSIX.1-2003 standard, which Linux adheres to. This guarantees
    the portability of the `signals` implementation or support in the applications.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Learning how to trap a signal* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Learning how to ignore a signal* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Learning how to send a signal to another process* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 3](c27d5a31-a4f2-4925-b883-fa244edeb6ae.xhtml), *Dealing with Processes
    and Threads* for a refresh on processes and threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to ignore a signal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There might be cases where we just need to ignore a specific signal. However,
    rest assured, there are few signals that cannot be ignored, for example, `SIGKILL`
    (uncatchable). This recipe will teach you how to ignore a catchable signal.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To ignore a catchable signal, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On a shell, open a new source file called `signal_ignore.cpp` and start by
    adding the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this second program (`signal_uncatchable.cpp`), we want to see that an *uncatchable*
    signal cannot be *ignored*. To do this, we''ll use the `SIGKILL` signal that we''ve
    seen in the *Learning all of the signals and their default actions* recipe, which
    is not catchable (that is, the program cannot ignore it):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The next section will explain the details of the preceding two programs.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Step 1* contains the program to ignore the `SIGTERM` signal. We do this by
    calling the `signal();` system call by passing the specific signal as the first
    parameter (`SIGTERM`) and the action to follow as the second parameter, which,
    in this case, is `SIG_IGN`, is to ignore.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 2* has the same code as *step 1*. We just used the `signal();` method
    passing the `SIGKILL` parameter and `SIG_IGN`. In other words, we asked Linux
    to ignore the `SIGKILL` signal for this process (`signal_uncatchable.cpp` will
    become a process once built and executed). As we learned in the *Learning all
    of the signals and their default actions* recipe, `SIGKILL` is an uncatchable
    signal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build and run the two programs now. What we expect to see is the `SIGTERM` signal
    ignored in the first program and `SIGKILL` signal, which cannot be ignored in
    the second one, respectively. The output of the first program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d9e43c4-0a85-492b-ad1d-5bcd9eddc98d.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we retrieved the `PID` of the process, using `ps aux`, and sent the `SIGTERM` signal
    by running the command: `kill -15 115` (where `15` represents `SIGKILL`). As you
    can see, the process keeps running by completely ignoring the signal to terminate
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second program, `signal_uncatchable.cpp`, shows that even if we specified
    to catch the `SIGKILL` signal, Linux ignored this and killed our process anyway.
    We can see this in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ff0fb88-d0b7-463d-a3b6-c1a69327f748.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To have a list of all the signals supported on a Linux machine, the `kill -l` command
    is of great help and `man signal` contains all the details you need to successfully
    integrate the signal in your program.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Learning the Linux fundamentals – shell* recipe in [Chapter 1](c3cda38c-220e-4aae-89c6-c381df46daec.xhtml), *Getting
    Started with System Programming*, for a refresh on how to run programs on the
    shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Learning how to trap a signal* recipe'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Learning how to send a signal to another process* recipe'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Learning all of the signals and their default actions* recipe'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter3](c27d5a31-a4f2-4925-b883-fa244edeb6ae.xhtml)*, Dealing with Processes
    and Threads,* for a refresh on processes and threads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to trap a signal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will teach you how to catch (or trap) a signal in a program. There
    might be a need to perform some actions for a specific signal. An example of this
    is when an application receives the signal to terminate (`SIGTERM`) but we are
    required to clean up some used resources before quitting.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write an application where we''ll catch the `SIGTERM` signal, print
    a string, and terminate the application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On a shell, create a new file called `signal_trap.cpp`. We need to include,
    among other headers, `<signal.h>` to be able to handle signals. We also have to
    add the prototype needed to manage the signal we want to trap. In the `main` method
    then, we call the `signal()` system call by passing `SIGTERM` that we want to
    catch and the method used to manage it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to define the `handleSigTerm()` method (which can be named whatever
    we want):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The next section will describe the program in detail.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Step 1* essentially defines the `main` method. First, we require the `<signal.h>`
    header. In the definition of the `main` method, the central part is the `signal()`
    system call where we pass the `SIGTERM` signal we want to trap and the method
    we want to get called by Linux. This is an important aspect worth highlighting.
    The `signal()` system call accepts (as a second parameter) a pointer to a function
    that the system developer has to define, as we did. In the kernel, when a software
    interrupt is raised, Linux sends it to the specific process and the method will
    be called (in the form of a callback). The prototype of the `signal()` method
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Step 2* has the definition of the method that will manage the `SIGTERM` signal
    we want to trap. This method, in its simplicity, shows a couple of interesting
    things. First, this method is a callback invoked from the `signal()` system call.
    Second, we necessarily have to define its prototype as `void (*)(int) `, that
    is, return void and accept an integer in the input (it represents the signal that
    the application actually receives). Anything different from this prototype will
    result in a compilation error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now build and execute the program we''ve developed in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f6b91f1-1a20-4bfb-b77b-33756494b1f5.png)'
  prefs: []
  type: TYPE_IMG
- en: We built and linked the `signal_trap.cpp` program and generated the `a.out` executable.
    We run it; the PID associated with the process is `46`. On the right shell, we
    send the `SIGTERM` signal (with identifier = `15`) to the process with PID `46`.
    As you can see on the standard output (the shell on the left), the process caught
    the signal and called the method we defined `handleSigTerm()`. This method printed
    some logs in the standard output and called the `abort()` system call, which sends
    the `SIGABORT` signal to the running process. As you can see in the *Learning
    all of the signals and their default actions* recipe, the default action of `SIGABORT` is
    to terminate the process (and generate the core dump). You can, of course, play
    with it and terminate the process in another, more suitable, way, depending on
    the requirements you have (for example, `exit()`).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, what does happen to signals when a process forks (or executes) another
    one? The following table will help you to understand how to deal with signals
    with a process-child relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Signal Behavior** | **Process Fork** | **Process Exec** |'
  prefs: []
  type: TYPE_TB
- en: '| Default | Inherited | Inherited |'
  prefs: []
  type: TYPE_TB
- en: '| Ignored | Inherited | Inherited |'
  prefs: []
  type: TYPE_TB
- en: '| Handled | Inherited | Not inherited |'
  prefs: []
  type: TYPE_TB
- en: At this stage, you should not be surprised that, when a process forks another
    process, the child essentially inherits all the behaviors of the parent. When
    a process executes another task (with `exec`), it inherits the **default behavior** and
    the **ignored behavior**, but it does not inherit the handled method that is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Learning how to ignore a signal* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Learning all of the signals and their default actions* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Learning how to send a signal to another process* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 3](c27d5a31-a4f2-4925-b883-fa244edeb6ae.xhtml), *Dealing with Processes
    and Threads,* for a refresh on processes and threads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to send a signal to another process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There could be scenarios where a process needs to send a signal to other processes.
    This recipe will teach you how to achieve that using a hands-on approach.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll write a program that will send the `SIGTERM` signal to a running process.
    We''ll see the process terminating as expected. On a shell, open a new source
    file called `signal_send.cpp`. We''ll be using the system call, `kill()`, which
    sends a signal `sig` to a process specified by `pid`. The program accepts an input
    parameter, which is `pid` of the program to terminate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We'll be using the `signal_trap.cpp` program developed in the *Learning how
    to trap a signal* recipe as the process to terminate. The next section will go
    deep in the detail of the code seen here.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to see the correct behavior, we need to run a process we intend to
    terminate. We''ll run the `signal_trap.cpp` program. Let''s build and run the `signal_send.cpp`
    program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90e6729d-3779-4be7-a592-193d458d00a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we performed a couple of things, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We've built the `signal_trap.cpp` program and generated the `a.out` executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `./a.out`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the shell on the left, we took `pid` of the `a.out` process, which was `133`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've built the `signal_send.cpp` program to the `terminate` executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We run `./terminate` with the `pid` variable of the process `a.out` we wanted
    to terminate: `./terminate 133`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the shell on the right, we could see the `a.out` process terminating correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Step 1* has a couple of things we have to explain. First, we parsed the `pid` variable from
    the command-line parameter, converted to an integer, and then saved it into the
    `pid` variable. Second, we called the `kill()` system call by passing the `pid`
    variable and the `SIGTERM` signal we have to send to the running process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`man 2 kill`: `int kill(pid_t pid, int sig);`'
  prefs: []
  type: TYPE_NORMAL
- en: The `kill()` function sends the signal specified by `sig` to `pid`.
  prefs: []
  type: TYPE_NORMAL
- en: For System V compatibility, if the PID is negative (but not `-1`), the signal
    is sent to all of the processes whose process group IDs are equal to the absolute
    value of the process number. However, if the `pid` is 0, `sig` is sent to every
    process in the **invoking process's** process group.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to send a signal to another process (or processes), the sending process
    must have appropriate privileges. Put simply, a process can send signals to another
    process if the current user owns it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There might be cases where a process has to send a signal to itself. In this
    case, the system call, `raise()`, does the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note one final, yet very important, thing: the handler code that manages the
    signal raised must be reentrant. The rationale behind that is that the process
    might be in the middle of any processing, so the handler must be very careful
    in modifying any static or global data. A function is **reentrant** if the data
    manipulated is allocated on the stack or passed in the input.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Learning how to trap a signal* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Learning how to ignore a signal* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Learning all of the signals and their default actions* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
