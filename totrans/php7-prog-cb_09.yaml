- en: Chapter 9. Developing Middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating with middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using middleware to implement access control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving performance using the cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making inter-framework system calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using middleware to cross languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As often happens in the IT industry, terms get invented, and then used and abused.
    The term **middleware** is no exception. Arguably the first use of the term came
    out of the **Internet Engineering Task Force** (**IETF**) in the year 2000\. Originally,
    the term was applied to any software which operates between the transport (that
    is, TCP/IP) and the application layer. More recently, especially with the acceptance
    of **PHP Standard Recommendation number 7** (**PSR-7**), middleware, specifically
    in the PHP world, has been applied to the web client-server environment.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The recipes in this section will make use of the concrete classes defined in
    [Appendix](apa.html "Appendix A. Defining PSR-7 Classes"), *Defining PSR-7 Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating with middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One very important usage of middleware is to provide authentication. Most web-based
    applications need the ability to verify a visitor via username and password. By
    incorporating PSR-7 standards into an authentication class, you will make it generically
    useful across the board, so to speak, being secure enough that it can be used
    in any framework that provides PSR-7-compliant request and response objects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We begin by defining an `Application\Acl\AuthenticateInterface` class. We use
    this interface to support the Adapter software design pattern, making our `Authenticate`
    class more generically useful by allowing a variety of adapters, each of which
    can draw authentication from a different source (for example, from a file, using
    OAuth2, and so on). Note the use of the PHP 7 ability to define the return value
    data type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that by defining a method that requires a PSR-7-compliant request, and
    produces a PSR-7-compliant response, we have made this interface universally applicable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define the adapter that implements the `login()` method required by
    the interface. We make sure to use the appropriate classes, and define fitting
    constants and properties. The constructor makes use of `Application\Database\Connection`,
    defined in [Chapter 5](ch05.html "Chapter 5. Interacting with a Database"), *Interacting
    with a Database*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The core `login()` method extracts the username and password from the request
    object. We then do a straightforward database lookup. If there is a match, we
    store user information in the response body, JSON-encoded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best practice**'
  prefs: []
  type: TYPE_NORMAL
- en: Never store passwords in clear text. When you need to do a password match, use
    `password_verify()`, which negates the need to reproduce the password hash.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Authenticate` class is a wrapper for an adapter class that implements
    `AuthenticationInterface`. Accordingly, the constructor takes an adapter class
    as an argument, as well as a string that serves as the key, in which authentication
    information is stored in `$_SESSION`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we provide a login form with a security token, which helps prevent
    **Cross Site Request Forgery** (**CSRF**) attacks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `login()` method in this class checks whether the token is valid.
    If not, a 400 response is returned. Otherwise, the `login()` method of the adapter
    is called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, be sure to follow the recipes defined in [Appendix](apa.html
    "Appendix A. Defining PSR-7 Classes"), *Defining PSR-7 Classes*. Next, go ahead
    and define the classes presented in this recipe, summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Discussed in these steps |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Application\Acl\AuthenticateInterface` | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `Application\Acl\DbTable` | 2 - 3 |'
  prefs: []
  type: TYPE_TB
- en: '| `Application\Acl\Authenticate` | 4 - 6 |'
  prefs: []
  type: TYPE_TB
- en: 'You can then define a `chap_09_middleware_authenticate.php` calling program
    that sets up autoloading and uses the appropriate classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You are now in a position to set up the authentication adapter and core class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Be sure to initialize the incoming request, and set up the request to be made
    to the authentication class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the incoming class method to see if it is `POST`. If so, pass a request
    to the authentication class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The display logic looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output from an invalid authentication attempt. Notice the `401`
    status code on the right. In this illustration, you could add a `var_dump()` of
    the response object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is a successful authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For guidance on how to avoid CSRF and other attacks, please see [Chapter 12](ch12.html
    "Chapter 12. Improving Web Security"), *Improving Web Security*.
  prefs: []
  type: TYPE_NORMAL
- en: Using middleware to implement access control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name implies, middleware sits in the middle of a sequence of function
    or method calls. Accordingly, middleware is well suited for the task of "gate
    keeper". You can easily implement an **Access Control List** (**ACL**) mechanism
    with a middleware class that reads the ACL, and allows or denies access to the
    next function or method call in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Probably the most difficult part of the process is determining which factors
    to include in the ACL. For the purposes of illustration, let''s say that our users
    are all assigned a `level` and a `status`. In this illustration, the level is
    defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The status could indicate how far they are in the membership signup process.
    For example, a status of `0` could indicate they've initiated the membership signup
    process, but have not yet been confirmed. A status of `1` could indicate their
    e-mail address is confirmed, but they have not paid the monthly fee, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to define the resources we plan to control. In this case, we
    will assume there is a need to control access to a series of web pages on the
    site. Accordingly, we need to define an array of such resources. In the ACL, we
    can then refer to the key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the most important piece of configuration is to make assignments to
    pages according to `level` and `status`. The generic template used in the configuration
    array might look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are in a position to define the `Acl` class. As before, we use a few
    classes, and define constants and properties appropriate for access control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `__construct()` method, we break up the assignments array into `$pages`,
    the resources to be controlled, `$levels`, and `$allowed`, which are the actual
    assignments. If the array does not include one of these three sub-components,
    an exception is thrown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have noticed that we allow inheritance. In `$allowed`, the `inherits`
    key can be set to another key within the array. If so, we need to merge its values
    with the values currently under examination. We iterate through `$allowed` in
    reverse, merging any inherited values each time through the loop. This method,
    incidentally, also only isolates rules that apply to a certain `status` and `level`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When processing authorization, we initialize a few variables, and then extract
    the page requested from the original request URI. If the page parameter doesn''t
    exist, we set a `400` code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we decode the request body contents, and acquire the `status` and
    `level`. We are then in a position to call `mergeInherited()`, which returns an
    array of pages accessible to this `status` and `level`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If the requested page is in the `$allowed` array, we set the status code to
    a happy `200`, and return an authorized setting along with the web page that corresponds
    to the page code requested:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We then return the response, JSON-encoded, and we are done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After that, you will need to define `Application\Acl\Acl`, which is discussed
    in this recipe. Now move to the `/path/to/source/for/this/chapter` folder and
    create two directories: `public` and `pages`. In `pages`, create a series of PHP
    files, such as `page1.php`, `page2.php`, and so on. Here is an example of how
    one of these pages might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also define a `menu.php` page, which could be included in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `logout.php` page should destroy the session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `auth.php` page will display a login screen (as described in the previous
    recipe):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then create a configuration file that allows access to web pages depending
    on level and status. For the sake of illustration, call it `chap_09_middleware_acl_config.php`
    and return an array that might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the `public` folder, define `index.php`, which sets up autoloading,
    and ultimately calls up both the `Authenticate` and `Acl` classes. As with other
    recipes, define configuration files, set up autoloading, and use certain classes.
    Also, don''t forget to start the session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best practice**'
  prefs: []
  type: TYPE_NORMAL
- en: It is a best practice to protect your sessions. An easy way to help protect
    a session is to use `session_regenerate_id()`, which invalidates the existing
    PHP session identifier and generates a new one. Thus, if an attacker were to obtain
    the session identifier through illegal means, the window of time in which any
    given session identifier is valid is kept to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now pull in the ACL configuration, and create instances for `Authenticate`
    as well as `Acl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define incoming and outbound request instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If the incoming request method was `post`, process the authentication calling
    the `login()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If the session key defined for authentication is populated, that means the
    user has been successfully authenticated. If not, we program an anonymous function,
    called **later**, which includes the authentication login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, you can proceed with the ACL check. You first need to find, from
    the original query, which web page the user wants to visit, however:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then reprogram the `$outbound` request to include this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you''ll be in a position to check authorization, supplying the outbound
    request as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then examine the return response for the `authorized` parameter, and
    program an anonymous function to include the return `page` parameter if OK, and
    the `sorry` page otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all you need to do is to set the form action and wrap the anonymous function
    in HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To test it, you can use the built-in PHP web server, but you will need to use
    the `-t` flag to indicate that the document root is `public`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: From a browser, you can access the `http://localhost:8080/` URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to access any page, you will simply be redirected back to the login
    page. As per the configuration, a user with status = `1`, and level = `BEG` can
    only access page `1` and log out. If, when logged in as this user, you try to
    access page 2, here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example relies on `$_SESSION` as the sole means of user authentication
    once they have logged in. For good examples of how you can protect PHP sessions,
    please see [Chapter 12](ch12.html "Chapter 12. Improving Web Security"), *Improving
    Web Security*, specifically the recipe entitled *Safeguarding the PHP session*.
  prefs: []
  type: TYPE_NORMAL
- en: Improving performance using the cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The cache software design pattern is where you store a result that takes a long
    time to generate. This could take the form of a lengthy view script or a complex
    database query. The storage destination needs to be highly performant, of course,
    if you wish to improve the user experience of website visitors. As different installations
    will have different potential storage targets, the cache mechanism lends itself
    to the adapter pattern as well. Examples of potential storage destinations include
    memory, a database, and the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with a couple of other recipes in this chapter, as there are shared constants,
    we define a discreet `Application\Cache\Constants` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Seeing as we are following the adapter design pattern, we define an interface
    next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to define our first cache adapter, in this illustration, by
    using a MySQL database. We need to define properties that will hold column names
    as well as prepared statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor allows us to provide key column names as well as an `Application\Database\Connection`
    instance and the name of the table used for the cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The next few methods prepare statements, and are called when we access the
    database. We do not show all the methods, but present enough to give you the idea:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we define a method that determines whether data for a given key exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The core methods are ones that read from and write to the cache. Here is the
    method that retrieves from the cache. All we need to do is to execute the prepared
    statement, which performs a `SELECT`, with a `WHERE` clause, which incorporates
    the key and group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'When writing to the cache, we first determine whether an entry for this cache
    key exists. If so, we perform an `UPDATE`; otherwise, we perform an `INSERT`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define two methods that remove the cache either by key or by group.
    Removal by group provides a convenient mechanism if there are a large number of
    items that need to be deleted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we define getters and setters for each of the properties. Not all are
    shown here to conserve space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The filesystem cache adapter defines the same methods as defined earlier. Note
    the use of `md5(),` not for security, but as a way of quickly generating a text
    string from the key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to present the core cache mechanism. In the constructor, we
    accept a class that implements `CacheAdapterInterface` as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next are a series of wrapper methods that call methods of the same name from
    the adapter, but accept a `Psr\Http\Message\RequestInterface` class an an argument,
    and return a `Psr\Http\Message\ResponseInterface` as a response. We start with
    a simple one: `hasKey()`. Note how we extract the `key` from the request parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To retrieve information from the cache, we need to pull the key and group parameters
    from the request object, and then call the same method from the adapter. If no
    results are obtained, we set a `204` code, which indicates the request was a success,
    but no content was produced. Otherwise, we set a `200` (success) code, and iterate
    through the results. Everything is then stuffed into a response object, which
    is returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Strangely, writing to the cache is almost identical, except that the results
    are expected to be either a number (that is, the number of rows affected), or
    a Boolean result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The remove methods are, as expected, quite similar to each other:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to demonstrate the use of the `Acl` class, you will need to define
    the classes described in this recipe, summarized here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Discussed in these steps |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Application\Cache\Constants` | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `Application\Cache\CacheAdapterInterface` | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `Application\Cache\Database` | 3 - 10 |'
  prefs: []
  type: TYPE_TB
- en: '| `Application\Cache\File` | 11 |'
  prefs: []
  type: TYPE_TB
- en: '| `Application\Cache\Core` | 12 - 16 |'
  prefs: []
  type: TYPE_TB
- en: 'Next, define a test program, which you could call `chap_09_middleware_cache_db.php`.
    In this program, as usual, define constants for necessary files, set up autoloading,
    use the appropriate classes, oh... and write a function that produces prime numbers
    (you''re probably re-reading that last little bit at this point. Not to worry,
    we can help you with that!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, a function that takes a long time to run is needed, so prime number generator,
    here we go! The numbers 1, 2, and 3 are given as primes. We use the PHP 7 `yield
    from` syntax to produce these first three. then, we skip right to 5, and proceed
    up to the maximum value requested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then set up a database cache adapter instance, which serves as an argument
    for the core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you wish to use the file cache adapter instead, here is the
    appropriate code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted to clear the cache, here is how it might be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `time()` and `microtime()` to see how long this script runs with
    and without the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, generate a cache request. A status code of `200` indicates you were able
    to obtain a list of primes from the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, you can assume nothing was obtained from the cache, which means
    you need to generate prime numbers, and save the results to the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then check the stop time, calculate the difference, and have a look
    at your new list of primes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the expected output before values were stored in the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can now run the same program again, this time retrieving from the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Allowing for the fact that our little prime number generator is not the world's
    most efficient, and also that the demonstration was run on a laptop, the time
    went from over 30 seconds down to milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another possible cache adapter could be built around commands that are part
    of the **Alternate PHP Cache** (**APC**) extension. This extension includes such
    functions as `apc_exists()`, `apc_store()`, `apc_fetch()`, and `apc_clear_cache()`.
    These functions are perfect for our `hasKey()`, `saveToCache()`, `getFromCache()`,
    and `removeBy*()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might consider making slight changes to the cache adapter classes described
    previously following PSR-6, which is a standards recommendation directed towards
    the cache. There is not the same level of acceptance of this standard as with
    PSR-7, however, so we decided to not follow this standard exactly in the recipe
    presented here. For more information on PSR-6, please refer to [http://www.php-fig.org/psr/psr-6/](http://www.php-fig.org/psr/psr-6/).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routing refers to the process of accepting user-friendly URLs, dissecting the
    URL into its component parts, and then making a determination as to which class
    and method should be dispatched. The advantage of such an implementation is that
    not only can you make your URLs **Search Engine Optimization** (**SEO**)-friendly,
    but you can also create rules, incorporating regular expression patterns, which
    can extract values of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Probably the most popular approach is to take advantage of a web server that
    supports **URL rewriting**. An example of this is an Apache web server configured
    to use `mod_rewrite`. You then define rewriting rules that allow graphic file
    requests and requests for CSS and JavaScript to pass untouched. Otherwise, the
    request would be funneled through a routing method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another potential approach is to simply have your web server virtual host definition
    point to a specific routing script, which then invokes the routing class, make
    routing decisions, and redirect appropriately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first code to consider is how to define routing configuration. The obvious
    answer is to construct an array, where each key would point to a regular expression
    against which the URI path would match, and some form of action. An example of
    such configuration is shown in the following code snippet. In this example, we
    have three routes defined: `home`, `page`, and the default. The default should
    be last as it will match anything not matched previously. The action is in the
    form of an anonymous function that will be executed if a route match occurs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define our `Router` class. We first define constants and properties
    that will be of use during the process of examining and matching a route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor accepts a `ServerRequestInterface` compliant class, the path
    to the document root, and the configuration file mentioned earlier. Note that
    we throw an exception if the default configuration is not supplied:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have a series of getters that allow us to retrieve the original request,
    document root, and final route match:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isFileOrDir()` method is used to determine whether we are trying to match
    against a CSS, JavaScript, or graphic request (among other possibilities):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally we define `match()`, which iterates through the configuration array
    and runs the `uri` parameter through `preg_match()`. If positive, the configuration
    key and `$matches` array populated by `preg_match()` are stored in `$routeMatch`,
    and the callback is returned. If there is no match, the default callback is returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, change to `/path/to/source/for/this/chapter` and create a directory
    called `routing`. Next, define a file, `index.php`, which sets up autoloading
    and uses the right classes. You can define a constant `PAGE_DIR` that points to
    the `pages` directory created in the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the configuration array discussed in step 3 of this recipe. Note
    that you could add `(/)?` at the end of the pattern to account for an optional
    trailing slash. Also, for the `home` route, you could offer two options: either
    `/` or `/home`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then define a router instance, supplying an initialized `ServerRequest`
    instance as the first argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'You then need to check to see whether the request is a file or directory, and
    also whether the route match is `/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define `main.php`, something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, a revised menu that uses user-friendly routing is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the configuration using Apache, define a virtual host definition that
    points to `/path/to/source/for/this/chapter/routing`. In addition, define a `.htaccess`
    file that directs any request that is not a file, directory, or link to `index.php`.
    Alternatively, you could just use the built-in PHP webserver. In a terminal window
    or command prompt, type this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In a browser, the output when requesting `http://localhost:8080/home` is something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For information on rewriting using the **NGINX** web server, have a look at
    this article: [http://nginx.org/en/docs/http/ngx_http_rewrite_module.html](http://nginx.org/en/docs/http/ngx_http_rewrite_module.html).
    There are plenty of sophisticated PHP routing libraries available that introduce
    far greater functionality than the simple router presented here. These include
    Altorouter ([http://altorouter.com/](http://altorouter.com/)), TreeRoute ([https://github.com/baryshev/TreeRoute](https://github.com/baryshev/TreeRoute)),
    FastRoute ([https://github.com/nikic/FastRoute](https://github.com/nikic/FastRoute)),
    and Aura.Router. ([https://github.com/auraphp/Aura.Router](https://github.com/auraphp/Aura.Router)).
    In addition, most frameworks (for example, Zend Framework 2 or CodeIgniter) have
    their own routing capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: Making inter-framework system calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the primary reasons for the development of PSR-7 (and middleware) was
    a growing need to make calls between frameworks. It is of interest to note that
    the main documentation for PSR-7 is hosted by **PHP Framework Interop** **Group**
    (**PHP-FIG**).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The primary mechanism used in middleware inter-framework calls is to create
    a driver program that executes framework calls in succession, maintaining a common
    request and response object. The request and response objects are expected to
    represent `Psr\Http\Message\ServerRequestInterface` and `Psr\Http\Message\ResponseInterface`,
    respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the purposes of this illustration, we define a middleware session validator.
    The constants and properties reflect the session `thumbprint`, which is a term
    we use to incorporate factors such as the website visitor''s IP address, browser,
    and language settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor takes a `ServerRequestInterface` instance and the session as
    arguments. If the session is an array (such as `$_SESSION`), we wrap it in a class.
    The reason why we do this is in case we are passed a session object, such as `JSession`
    used in Joomla. We then create the thumbprint using the previously mentioned factors.
    If the stored thumbprint is not available, we assume this is the first time, and
    store the current print as well as stop time, if this parameter is set. We used
    `md5()` because it''s a fast hash, is not exposed externally, and is therefore
    useful to this application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s not required to define `__invoke()`, but this magic method is quite convenient
    for standalone middleware classes. As is the convention, we accept `ServerRequestInterface`
    and `ResponseInterface` instances as arguments. In this method, we simply check
    to see whether the current thumbprint matches the one stored. The first time,
    of course, they will match. But on subsequent requests, the chances are an attacker
    intent on session hijacking will be caught out. In addition, if the session time
    exceeds the stop time (if set), likewise, a `401` code will be sent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now put our new middleware class to use. The main problems with inter-framework
    calls, at least at this point, are summarized here. Accordingly, how we implement
    middleware depends heavily on the last point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Not all PHP frameworks are PSR-7-compliant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Existing PSR-7 implementations are not complete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All frameworks want to be the "boss"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, have a look at the configuration files for **Zend Expressive**,
    which is a self-proclaimed *PSR7 Middleware Microframework*. Here is the file,
    `middleware-pipeline.global.php`, which is located in the `config/autoload` folder
    in a standard Expressive application. The dependencies key is used to identify
    the middleware wrapper classes that will be activated in the pipeline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the `middleware_pipline` key, you can identify classes that will be executed
    before or after the routing process occurs. Optional parameters include `path`,
    `error`, and `priority`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Another technique is to modify the source code of an existing framework module,
    and make a request to a PSR-7-compliant middleware application. Here is an example
    modifying a **Joomla!** installation to include a middleware session validator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, add this code the end of the `index.php` file in the `/path/to/joomla`
    folder. Since Joomla! uses Composer, we can leverage the Composer autoloader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then create an instance of our middleware session validator, and make
    a validation request just before `$app = JFactory::getApplication(''site'');`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, create the `Application\MiddleWare\Session\Validator` test middleware
    class described in steps 2-5\. Then you will need to go to [https://getcomposer.org/](https://getcomposer.org/)
    and follow the directions to obtain Composer. Download it to the `/path/to/source/for/this/chapter`
    folder. Next, build a basic Zend Expressive application, as shown next. Be sure
    to select `No` when prompted for minimal skeleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a `folder /path/to/source/for/this/chapter/expressive`. Change
    to this directory. Modify `public/index.php` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'You will then need to create a wrapper class that invokes our session validator
    middleware. Create a `SessionValidateAction.php` file that needs to go in the
    `/path/to/source/for/this/chapter/expressive/src/App/Action` folder. For the purposes
    of this illustration, set the stop time parameter to a short duration. In this
    case, `time() + 10` gives you 10 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'You will now need to add the new class to the middleware pipeline. Modify `config/autoload/middleware-pipeline.global.php`
    as follows. Modifications are shown in **bold**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: You might also consider modifying the home page template to show the status
    of `$_SESSION`. The file in question is `/path/to/source/for/this/chapter/expressive/templates/app/home-page.phtml`.
    Simply adding `var_dump($_SESSION)` should suffice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After 10 seconds, refresh the browser. You should now see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using middleware to cross languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Except in cases where you are trying to communicate between different versions
    of PHP, PSR-7 middleware will be of minimal use. Recall what the acronym stands
    for: **PHP Standards Recommendations**. Accordingly, if you need to make a request
    to an application written in another language, treat it as you would any other
    web service HTTP request.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the case of PHP 4, you actually have a chance in that there is limited support
    for object-oriented programming. Accordingly, the best approach would be to downgrade
    the basic PSR-7 classes described in the first three recipes. There is not enough
    space to cover all the changes, but we present a potential PHP 4 version of `Application\MiddleWare\ServerRequest`.
    The first thing to note is that there are no namespaces! Accordingly, we use a
    classname with underscores, _, in place of namespace separators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'All properties are identified in PHP 4 using the key word `var`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The `initialize()` method is almost the same, except that syntax such as `$this->getServerParams()[''REQUEST_URI'']`
    was not allowed in PHP 4\. Accordingly, we need to split this out into a separate
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the `$_XXX` super-globals were present in later versions of PHP 4:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The null coalesce operator was only introduced in PHP 7\. We need to use `isset(XXX)
    ? XXX : '''';` instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The JSON extension was not introduced until PHP 5\. Accordingly, we need to
    be satisfied with raw input. We could also possibly use `serialize()` or `unserialize()`
    in place of `json_encode()` and `json_decode()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The `withXXX()` methods work pretty much the same in PHP 4:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, the `withoutXXX()` methods work the same as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'For websites using other languages, we could use the PSR-7 classes to formulate
    requests and responses, but would then need to use an HTTP client to communicate
    with the other website. As an example, recall the demonstration of a `Request`
    discussed in the recipe *Developing a PSR-7 request class* from this chapter.
    Here is the example from the *How it works...* section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
