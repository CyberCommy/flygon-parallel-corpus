- en: Chapter 9. Procedural Dungeon Generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps the most iconic and defining feature of roguelike games is their procedurally
    generated levels. This is one of the main features that contributes to the replayability
    that the genre is renowned for having. It keeps the game fresh and challenging
    and the players on their toes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout the course of this book, we''ve progressed from the simple generation
    of single numbers to the implementation of complex procedural behavior, such as
    path finding. It''s time for our pièce de résistance: procedurally generating
    our levels. In addition to this, we''ll also work on making levels more distinct
    using the functions that we created in [Chapter 6](ch06.html "Chapter 6. Procedurally
    Generating Art"), *Procedurally Generating Art*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of procedurally designing levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maze generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Room generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tile mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefits of procedural level design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The procedural generation of game levels and environments brings with it a myriad
    of benefits, not only for players but also for developers. It's always good to
    understand the positives and negatives of a technology before we use it. So, let's
    take a look at some of the biggest benefits that it brings to games before we
    implement it.
  prefs: []
  type: TYPE_NORMAL
- en: Replayability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most obvious benefit of procedurally generated levels is their variety and
    the replayability that they bring to a game. With each run, the environment changes.
    This means that players cannot learn the locations of items, enemies, and this
    keeps the challenge alive and fresh, giving players reasons to play the game again
    and again.
  prefs: []
  type: TYPE_NORMAL
- en: A reduction in development time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another benefit that is common in all implementations of procedural generation
    is the time that it saves in development. In our roguelike game, we're going to
    have an endless number of unique levels. If we were creating our levels manually
    this would simply not be possible. We would be limited to perhaps a hundred levels
    at the most.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing procedural generation like this takes this workload off the developers,
    saving both time and money, and increases the scope of what's possible.
  prefs: []
  type: TYPE_NORMAL
- en: Larger game worlds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that procedural generation in itself is in no way random. We induce
    randomness by using random values and terms in our algorithms and calculations.
    Given that, we can use procedural generation within a level design to share levels
    without actually having to store them.
  prefs: []
  type: TYPE_NORMAL
- en: Lots of games that generate worlds randomly will allow you to input a world
    seed. With this value, two people on two different machines can generate the same
    level. With this approach, you can generate a theoretically never-ending level,
    ensuring that all players generate the same one. Also, you'll only have to store
    the world seed instead of potentially hundreds of megabytes of world data.
  prefs: []
  type: TYPE_NORMAL
- en: Considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with everything, there are two sides of the same coin. Therefore, despite
    the benefits that procedural level generation brings, there are some considerations
    and compromises that need to be made.
  prefs: []
  type: TYPE_NORMAL
- en: A lack of control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lack of control is a common pitfall of procedural generation in general, but
    it's perhaps never more prevalent than when generating levels. Game levels are
    the arena in which our stories are told and our game mechanics are experimented
    with. Given that, they are usually handcrafted by dedicated level designers. Leaving
    this job to an algorithm results in a significant loss of control.
  prefs: []
  type: TYPE_NORMAL
- en: Games with simple mechanics and stories will generally fair okay, but if you
    have complex mechanics or a story that you want to tell in a particular way, procedural
    level generation may require you to relinquish more control than you can afford.
    An algorithm can never replicate the little touches that a seasoned professional
    brings.
  prefs: []
  type: TYPE_NORMAL
- en: Required computing power
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another consideration that needs to be taken into account is the computing power
    that is required. In our case, it's not that bad. We only have a 2D array of a
    small size that needs to be generated. However, if you're generating 3D terrain
    on a large scale, this cost becomes more significant and needs to be factored.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a situation where we are required to work with a level grid of 1000
    by 1000\. Every time we generate a level there will be a significant number of
    calculations that will need to be performed, and we need to ensure that all our
    players' hardware can cope! With steady increases in the computing power this
    is becoming less of an issue. In fact, this is the reason why games are becoming
    very complex and dynamic. We have the hardware that is required to achieve it,
    but we still need to be conscious of the limits.
  prefs: []
  type: TYPE_NORMAL
- en: Suitability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final consideration is simply whether your game will benefit from procedural
    generation. Just because it might be technically possible to implement it in a
    title, it doesn't mean that it belongs there. If you don't require lots of levels
    and you have complex mechanics and systems, then it's probably not worth implementing
    it. You're better off spending this time in handcrafting a selection of levels
    that you know will work really well.
  prefs: []
  type: TYPE_NORMAL
- en: This is a good point to bear in mind in general. Don't get carried away with
    the technicalities of the game and how amazing the code is. The bottom line is
    that your game needs to be fun and engaging. Always prioritize gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of dungeon generation overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dungeon generation is a vast topic with a wide range of possible implementations,
    with each implementation having its own characteristics. However, underneath the
    nuances of different algorithms, dungeon generation generally involves the generation
    of rooms and a maze and the integration of the two, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An overview of dungeon generation overview](img/B04920_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Procedurally generating dungeons is not that different from the work that we
    did on path finding. It's all about viewing a level as nodes and manipulating
    them. Before we implement it we'll break it down into the three main stages that
    were identified previously, namely the generation of rooms, the generation of
    a maze, and the integration of all together.
  prefs: []
  type: TYPE_NORMAL
- en: Generating rooms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dungeons are a series of interconnected rooms, and their generation is the
    first step in many systems. There is no complex algorithm behind this; we simply
    choose a room size and place a number of them in the level. The characteristics
    of this level will be determined by factors such as the number of rooms, their
    size, and how they are placed, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating rooms](img/B04920_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Generating a maze
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another important step in dungeon generation is to generate a maze throughout
    the playable area, turning the level into a series of connected hallways. These
    can then either join the existing rooms, or have rooms carved into them to create
    open areas. There are a number of algorithms that are used to generated mazes
    like this, and we''ll use the popular **recursive backtracker** algorithm. Don''t
    worry, we''ll have a look at this algorithm in detail shortly! The following screenshot
    shows an example of such a maze:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating a maze](img/B04920_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Connecting rooms and mazes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you choose to generate rooms first and then create a maze to connect them,
    the final step is to integrate them. Currently, the maze will run right past all
    the rooms, but thankfully, it''s an easy task to join them. We need to just look
    around each room and add a connecting block to a valid adjacent path, as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting rooms and mazes](img/B04920_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In our implementation, we're actually going to do this the other way around.
    We'll generate a maze and then carve open areas into it. This method creates more
    open and maze-like areas, whereas the first method creates interconnected closed
    rooms.
  prefs: []
  type: TYPE_NORMAL
- en: The recursive backtracker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recursive backtracker, as the name suggests, involves recursively calling
    a function that carves passages between two tiles in the game grid. By choosing
    random directions to carve this path, the algorithm carves its way through the
    level as far as possible before resolving its recursions, working back to the
    start node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is pseudocode for one such algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose random direction and make a connection to the adjacent node if it has
    not yet been visited. This node becomes the current node (a recursive call).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all the adjacent cells in each direction have already been visited, go back
    to the last cell (return from the previous recursive call).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you're back at the start node, the algorithm is complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we can see, there's really not much to it! The only pitfall is that you need
    to have the entire maze in memory. For large mazes this method can be inefficient
    or maybe not possible at all! However, for our implementation, it will work perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: Procedurally generating a dungeon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to put this theory into practice and implement procedural dungeon
    generation in our game for real. We'll move the `Level` class from loading its
    data from a text file to generating it at runtime, and we'll also cover the application
    of the correct sprites to the tiles in the random level.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we identified, one way of approaching this is to generate a maze over the
    entire play area and then generate rooms to carve out some larger open areas.
    This method not only generates tighter, more intertwined levels, but also saves
    us the step of having to connect mazes to rooms, leaving us with just two steps
    to generate great levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Procedurally generating a dungeon](img/B04920_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Changing how we view the maze
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we write any code, we're going to make a change to the project so that
    we can easily see the entire level. Currently, the view is zoomed, and we have
    the light blocking the level. We want to be able to see the entire maze as we
    work on the algorithm. So let's make some changes.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that we'll do is disable the main game view and instead draw
    everything using the **UI** view. The **Game** view draws draws everything twice
    as large as the original size, while the UI view draws things with a scale of
    1:1\. By disabling the change to the **Game** view, we'll see more of the level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'All that we''ve done here is comment out the line that sets the main game''s
    view. Let''s now do the same for the code responsible for drawing the light in
    the level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'These two changes drastically change how the level now appears and will help
    us see the maze as we work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing how we view the maze](img/B04920_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Updating the Game and Level classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start implementing the maze generator, we need to define some functions
    that we''ll be using. For starters, our level is currently loaded from the `Level::LoadLevelFromFile`
    function. We need to create an appropriate function for the new code. Let''s remove
    the `Level::LoadLevelFromFile` function and add the following code in its place
    in `Level.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to need a similar function in the `Game` class, which will encapsulate
    all the code to generate a random level, so ensure that you add the same function
    declaration to `Game.h` also. We have a couple of functions that are related to
    generating a level, and all of these can be encapsulated in this function. We
    need to add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A call to `Level::GenerateLevel`: This enables the placement of key in the
    level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A call to `Game::PopulateLevel`: This helps in the generation of a random level
    goal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice one of these items is to add a key to the level. The item already exists
    in our solution, as does all supporting code, and as we'll soon be able to generate
    levels at random we can now spawn one in the level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add this function to `Game.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We created the `Goal::GenerateLevelGoal` function in [Chapter 8](ch08.html "Chapter 8. Procedural
    Behavior and Mechanics"), *Procedural Behavior and Mechanics*. So, this is where
    we actually implement it. Each time a new level is generated, we create a 1 in
    3 chance that a goal will be generated if there isn't one that's currently active.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we now have the function that will generate our levels at random, and
    have added the key, let''s quickly add the code to generate a new level when the
    player reaches the door. We already have the if statement ready, we just need
    to add the behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that this is completed, all we have left to do is call our `Game::GenerateLevel`
    function instead of our depreciated `Level::LoadLevelFromFile`, and remove the
    code to set the players location and the call to `Game::PopulateLevel`. Our new
    `Game::GenerateLevel` function will take care of all of that. Let''s update the
    following code in `Game::Initialize`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that the code is updated, we can now turn our attention towards the dungeon
    generation algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a maze
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first stage of creating a random dungeon is to generate a maze throughout
    the entire play area. We've covered the recursive backtracker method that we're
    going to use. However, we need to do some preparation beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing before the generation of a maze
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The recursive backtracking algorithm works by forging passages between two
    nodes. Given this, we need the maze to be in a position where all the nodes in
    the grid are surrounded by walls, that is, something that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing before the generation of a maze](img/B04920_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The shaded squares represent wall tiles, and the blank squares represent floor
    space. You will see in the left grid that each floor tile is surrounded on all
    sides by a wall. The right tile shows what the grid would look like once the algorithm
    is run, breaking through these walls to create paths. Our task is to make the
    grid look like the one on the left!
  prefs: []
  type: TYPE_NORMAL
- en: When you look at the grid to the left, you will see that all the shaded tiles
    have odd indices; only the tiles that have an even column and a row index are
    blank. This makes it easy to create this grid. We need to loop through all the
    tiles, and if both the indices are even, we leave it blank. Otherwise, we convert
    it into a wall tile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start defining the `Level::GenerateLevel` function by implementing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Before we run our game we need to quickly disable any code that uses the level
    grid. This includes our call to `Game::PopulateLevel` and the placement of the
    key in `Game::GenerateLevel`. It also includes the call to `Game::SpawnRandomTiles`
    in `Game::Initialize`. These functions rely on the level grid been setup, and
    it isn't yet! Without disabling these the game will hang as it looks for floor
    tiles! We'll turn them back on when we're done.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game now, you will see that we have a grid that looks like the
    image to the left. The first step is complete!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the result when we run the game now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing before the generation of a maze](img/B04920_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Carving passages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that the checkerboard pattern is created, it''s time to implement the main
    body of the algorithm. Here''s a reminder of how the recursive backtracker algorithm
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose a random direction and make a connection to the adjacent node if it has
    not yet been visited. This node becomes the current node (a recursive call).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all adjacent cells in each direction have already been visited, go back to
    the last cell (return from the previous recursive call).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you're back at the start node, the algorithm is complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We know that this algorithm is recursive, so let''s start by declaring the
    function that will contain the algorithm. Since this function will create paths
    between two nodes, we''ll call it `CreatePath`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Starting with the first point in the algorithm breakdown, we need to identify
    the node that we're working with and choose a random direction. Getting the correct
    node is easy, and to choose a random direction, we'll use an array. We can define
    an array of `sf::vector2i` that defines all the possible directions. For example,
    `{-2, 0}` will indicate a movement to the tile to the left, as we'll decrement
    the column index by 2.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, we have to move two tiles at a time due to the checkerboard pattern.
    The tile that is directly adjacent to us is a wall so we need to move one step
    further to reach the tile that we want to work on. We then need to shuffle the
    array of directions so that the algorithm doesn't tend towards any one in particular.
    If we didn't do this for example, it would always check north first, resulting
    in lots of north-running passages!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start defining the `Level::CreatePath` function by adding the following
    to `Level.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Next, we iterate over these directions and check whether we can find any valid
    tiles that have not yet been visited. A tile is valid if it exists in the grid,
    and you can tell whether it's been visited yet or not depending on whether it's
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add this functionality by appending the following code to the open function''s
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If the code reaches this point we know that we're looking at a new tile as it's
    both valid and currently empty. To create a path to it we need to knock down the
    wall between us and change both the wall and our new tile with floor tiles. We
    now call `Level::CreatPath` once more, passing the indices of the new tile as
    the parameters. It's here that the recursion happens and the algorithm progresses
    forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s finish the function''s definition with the following bit of code to
    achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let's clarify exactly what's happening here. Every time an empty tile is identified,
    a recursive call to `Level::CarvePath` is made, and that tile's indices are passed.
    As it does this, it works its way through the level, nesting deeper and deeper
    into recursion.
  prefs: []
  type: TYPE_NORMAL
- en: When all the directions have been checked and there is no valid tile, the current
    call from `Level::CreatePath` will return, allowing the previous call to check
    its remaining directions. As this process continues the algorithm works its way
    back through the path until it reaches the start node, at which point nodes have
    been visited.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hopefully, the comments in the function make it clear which part is doing what.
    Now that this is complete we can now call it from the `Level::GenerateLevel` function
    right after we set up the grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile the project once again and see what we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Carving passages](img/B04920_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have the maze! For some games, this will be enough, but we don't want all
    the single tile paths. We're want more open areas so that we can fight the enemies!
    You'll also see that the tile sprites are looking very weird. Don't worry about
    it now; we'll fix it as soon as we add the rooms!
  prefs: []
  type: TYPE_NORMAL
- en: Adding rooms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Previously, we learned that adding rooms was a simple task. We now get to see
    this firsthand. Our goal is to add some open areas, and the simplest way to do
    this is to pick some random locations and convert the surrounding tiles to floor
    tiles. To keep the `Level` class neat, we''ll encompass this behavior in its own
    function. Add the following function declaration to `Level.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`private`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In our ongoing efforts to write versatile and scalable code, we added a parameter
    to denote how many rooms we want to create so that we can vary it at will.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s jump right into defining the function. To start, we''re going to need
    a loop to iterate once for each room that we wish to add. Add the following method
    definition in `Level.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create our rooms. The first task is to decide how big we want them
    to be. After playing with the algorithm I found that having a greater number of
    smaller rooms works well. As always, we''ll throw in some RNG here by having the
    rooms'' size fall within a random range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will generate rooms with a width and height of either 1 or 2\. I know that
    this sounds small, but trust me. It works really well!
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we need to choose a place in the level for this room to be placed. We''ll
    pick a random point and build the room around it. For this we need to generate
    a random tile index and then create nested `for` loops to iterate over the 2D
    array, thus describing the room:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When generating the start position, you can see that we've been careful not
    to include the outer edge in either direction. These are the level's retaining
    walls and should be left alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the function now simply involves turning the room tiles into
    floor tiles. First, we check whether we haven''t gone out of bounds by making
    a call to `Level::TileIsValid`. We then ensure that the new title does not lie
    on the outer edge of the grid; the outer rows/columns should all be walls to contain
    the level. If both of these criteria are met, we can make it a floor block by
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It's time to make a call to this function. Currently in `Level::GenerateLevel`
    we set our grid up and then make the first call to `Level::CreatePath` to start
    the recursive algorithm. When this first initial call is returned, we know that
    the maze has been fully generated. It's at this stage that we'll create the rooms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s append a call to the new `Level::CreateRooms` function right after the
    first call to `Level::CreatePath`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time for another build so that we can see our work. Hopefully now we
    have a random maze running through the level as well as a number of larger open
    areas where we can allow players to fight more freely:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding rooms](img/B04920_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Choosing the tile textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now we've been loading a prebuilt level from a text file. This level file
    already knew which textures needed to be used and where they should be used, but
    since we're now generating them procedurally, that's not the case. We need to
    decide which tiles should have which sprites.
  prefs: []
  type: TYPE_NORMAL
- en: The if/else approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common way of approaching this is simply to create a monstrous `if/else` statement.
    In principle, it's a simple task; define each tile through a series of `if` statements
    and set the right tile. However, in reality, you end up with a complex mess of
    code that is very difficult to read.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a situation where you have a tile set of fifty possible variants. The
    amount of code required to choose which tile goes where would be crazy. Thankfully,
    there's a much simpler solution to the problem, and it is one of my favorite examples
    of an elegant solution to a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise tile maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our game, we concern ourselves with four directions, namely up, down, left,
    and right. Given that, when we need to calculate tile textures we only need to
    check in these four directions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bitwise tile maps](img/B04920_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, you can see that the tiles marked with 0s are those
    that are used to determine the texture given to tile X. This is where the elegant
    solution comes into play. If we read the tiles into a binary number, starting
    from the top tile and counting from the least significant digit, we get the 4
    digit binary number, 0000\. If the tile is a wall we set the corresponding bit
    to 1\. If the tile is floor we leave it as 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we apply this to the four possible tile locations that surround the tile
    X, we can calculate values for each tile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bitwise tile maps](img/B04920_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Hopefully, this diagram makes things clearer. Starting from the top tile and
    reading clockwise, we feed the values of the tiles into a bit integer from the
    least significant digit to the most. This gives each tile surrounding the main
    tile a distinct value, and we can visualize this through the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bitwise tile maps](img/B04920_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Calculating the tile values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When deciding upon the tile texture that we need, we evaluate which tiles surround
    the target tile, and where we have a wall we store its value that we identified
    in the previous image. A real example will help you visualize this process. Let''s
    suppose that we need to find the correct texture for tile X:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculating the tile values](img/B04920_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this scenario, the tile value will be calculated in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 + 4 = 5
  prefs: []
  type: TYPE_NORMAL
- en: Using this method, each possible tile orientation for X is represented through
    a unique value ranging from 0 to 15\. It's so elegant and simple!
  prefs: []
  type: TYPE_NORMAL
- en: Mapping the tile value to textures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final piece of this puzzle is mapping these values to textures. In `Util.h`,
    you will see that the following enumerator defines the all types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: While the order of these tiles may seem somewhat random, they are actually in
    a very specific order. Enumerators start counting from 0\. Therefore, we can see
    that the first value, `WALL_SINGLE`, has a value of 0\. Going back to our chart,
    we can see that this is correct, as that's the texture that we'll need when there
    is nothing surrounding the tile.
  prefs: []
  type: TYPE_NORMAL
- en: Taking another random example, the `WALL_TOP` value has a value of 10\. If we
    look at the grid, this will mean that the tiles only to the right and left of
    the target tile are walls. 2 + 8 = 10\. That's correct! For all possible tiles,
    I worked out their bitmask values and ensured that their enumerator values matched
    up.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating tile textures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get this implemented in the project. First, we''ll declare a function
    that we can encapsulate this behavior in our `Level` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For the function''s body, we want to start by iterating over all the tiles,
    identifying which of them are walls. It''s these tiles that need their sprites
    calculating correct texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we look at those tiles around us, using the values we calculated earlier,
    to come up with a final value for the tile. We check each tile in procession,
    again starting from the top, going clockwise, and increasing the value by the
    appropriate amount if there is a wall there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'All that''s left at this stage is to assign the correct texture and ID to the
    tile. We previously covered how we set up the enumerator, denoting the tile types
    to line up directly with this value, so we can simply use the texture value as
    the tile type and the index of the texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With this the function is complete. The final step is to ensure that we add
    a call to it in the `Level::GenerateLevel` function right after we''ve generated
    the rooms, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s not waste any time and get our game built:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculating tile textures](img/B04920_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How great does that look! Run it a few times and see all the different mazes
    that are generated. We generate a maze, carve some larger areas, and resolve the
    textures. Procedurally generated dungeons. While this is great, we can do better.
    Our mazes lack character and individuality. So let's introduce some aesthetic
    variance to the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Creating unique floor themes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html "Chapter 6. Procedurally Generating Art"), *Procedurally
    Generating Art*, we spent some time looking at procedurally generating sprites.
    We also created a function named `Level::SetColor`, which allows us to set an
    overlay color for all the tiles in the level. Let's put this to use and create
    a unique feel for each floor of the dungeon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create distinct floors that each have a unique aesthetic. Every 5 levels
    we can generate a new random color and apply it to our level. Our `Level` class
    already has the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use these to track how many rooms we have generated and when we should
    change the effect. To start, we have to keep track of which floor and room we''re
    on. At the end of the `Level::GenerateLevel` function, we''ll start by incrementing
    the `m_roomNumber` variable. When it''s `5`, we can increment `m_floorNumber`
    and generate a new color overlay; don''t forget to reset the room counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As we learned in [Chapter 6](ch06.html "Chapter 6. Procedurally Generating Art"),
    *Procedurally Generating Art*, to generate a new color we need to generate three
    random values that lie between 0 and 255\. These values are the red, green, and
    blue channels that make up the color. The fourth value is alpha and denotes the
    transparency of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to bear in mind that if we generate color values that are closer
    to 0, we'll get a white color, and if we go too far on the other end, the color
    will be too dark. For this reason, we aren't going to generate a number anywhere
    in the range of 0 to 255, but cap this slightly so that we always get a workable
    color. The alpha value will be set to 255 every time, as we don't want any of
    the tiles to be transparent.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll generate a random color and then make a call to `Level::SetColor`, passing
    the newly generated value to it. This will give the level a unique aesthetics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the second time we wanted to generate a random color. Given this, it
    might be a good candidate to receive its own function. As a short exercise, abstract
    this code into its own function and update the game code accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can run our game and see the results, we need to make one more change.
    Currently, a random level color will only be set when we move the floors for the
    first time. We need to execute the same code when our level is first generated.
    We can do this in the constructor of the level. Let''s simply append the following
    code to `Level::Level`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now we're ready to run the game once more. We can see that when our level is
    a random color, and when we make our way through 5 levels we know this color will
    change!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the game and see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating unique floor themes](img/B04920_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding entry and exit points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we're no longer loading our level from pre-defined level data, we need
    to calculate a valid entry and exit point for each room. Since the whole level
    is a maze, we can generate an entry point right at the bottom of maze and make
    it the player's goal to find the exit at the top of the level. The multiple passages
    and dead ends will keep the player searching!
  prefs: []
  type: TYPE_NORMAL
- en: We already have these tiles defined in our wall enumerator, so it's a simple
    case of finding locations for them in the level. As always, we'll start by declaring
    a function in which this behavior will lie. It's always a good idea to encapsulate
    chunks of code that perform a single task in a function. This not only makes behavior
    and responsibility clear, but also makes code more reusable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s declare the following function in `Level.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, for the method body, we want to start by identifying suitable indices for
    the start and end tiles. Since we'll place the tiles on the top and bottom rows,
    we only have to generate a single index, namely the column. The rows' indices
    will be 0 and `GRID_HEIGHT-1` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we''ll select a column index at random and check whether the location
    is suitable for entry node. For the entry node, we need to ensure that there''s
    no tile above. Likewise, for the exit node, we need to ensure that there''s nothing
    below us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the `while` loops like this needs to be approached with extreme caution.
    If a valid tile did not exist, the program will hang and crash. In this case,
    we can be sure that there's always a valid tile due to the way the algorithm works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the start and end nodes identified, all that''s left is to
    set the nodes as the correct type of tiles. The entry node needs to be set to
    `TILE::WALL_ENTRANCE`, and the exit node has to be set to `TILE::WALL_DOOR_LOCKED`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that this function is finished, we just need to make a call to it once
    a level is generated. We''ll do this at the end of the `Level::GenreateLevel`
    function right after we calculate the textures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Setting a player's spawn location
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we have identified the entrance and exit nodes, we need to move our player
    accordingly. The code to generate a start node lies in the level class, so we're
    going to need to add a function that will return this start location. We could
    just generate the entrance and exit nodes in the game class, but this would be
    poor design. It's much better to place the code where it belongs and create `getter`
    and `setter` methods to access it.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we can return the spawn location we actually have to calculate
    it! To do so, we need to know where the entry node is. Once the `Level::GenerateEntryExit`
    function has returned that information is lost. We could iterate over the bottom
    row of the tiles to find it, but that would be inefficient. Instead, we'll create
    a variable in `Level` class to hold this information and calculate the spawn location
    in `Level::GenerateEntryExit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by declaring these variables in `Level.h`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, we know that the entrance to each level is going to be somewhere in the
    bottom row. This means that to calculate the spawn location we simply need to
    find the absolute position of the tile immediately above that. The `Level` class
    already has a function to get the absolute location of a tile, so it's as simple
    as making a single call to that function and passing the correct tile.
  prefs: []
  type: TYPE_NORMAL
- en: While we're here we need to sneak in a little bit of similar code. We need to
    store the location of the new exit so that the `Level::UnlockDoor` function knows
    which tile to change. The Level class already has a variable for this information,
    so it's a simple one-liner code that we'll sneak in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s append this behavior to the end of the `Level::GenerateEntryExit` function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all that we need is a dead simple `getter` function to return the spawn
    location of the player, don''t forget the declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now it's time to apply this spawn location to a player. `Game::GenerateLevel`
    is the function where we generate a level so we'll set the player's location here.
    After the call to `Level::GenerateLevel` we can fetch the spawn location, knowing
    that it will be updated, and use this value as the position for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also now uncomment the code to spawn a key, our call to `Game::PopulateLevel`,
    and our call to `Game::SpawnRandomTiles`. With our level now setup these function
    will work as intended. Let''s get that code uncommented, and update `Game::GenerateLevel`
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Time to test the code. Now when we run the game, we should see not only a great
    looking maze, but also an entrance at the bottom with our player directly above
    it, and an exit at the top of the level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting a player''s spawn location](img/B04920_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Undoing the debug changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The work on our dungeon generation is now complete! Let''s quickly revert the
    debug changes that we made to the code. We need to uncomment the line that enables
    the game view and the lighting code; both of these lines are in the `Game::Draw`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of adding or removing the debug code like this, you could create a `dev`
    mode that can be toggled and is available in the DEBUG mode.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To help you test your knowledge of this chapter''s content, here are a few
    exercises that you should work on. They are not imperative to the rest of the
    book, but working on them will help you assess your strengths and weaknesses in
    the material covered:'
  prefs: []
  type: TYPE_NORMAL
- en: There are many different algorithms available that could be used to generate
    mazes, such as the randomized **Prim**'s algorithm and **Kruskal**'s algorithm.
    Choose one of these algorithms and have a go at replacing the recursive backtracking
    implementation with your own implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We worked with quite a small level size. Try increasing it and varying the characteristics
    of the levels that are generated. Increase the number of rooms, their size, and
    so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may have noticed that our torches are missing! Since we no longer load the
    level from a level file, we need to add them ourselves. Torches should be placed
    on tiles of the `TILE::WALL_TOP` type. Have a go at creating this function yourself.
    If you get stuck, you can always look at the next chapter's code for a hint on
    where to start.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we learned how our game, which previously loaded predefined
    level data from a text file, can generate its own level data during runtime. This
    brings a great level of replayability to the game, ensuring gameplay stays fresh
    and challenging. We also used a function that we defined in the earlier chapters
    to bring more character to our levels; we used sprite effects to create a distinct
    feeling for each floor. Practically all aspects of our game are procedurally generated
    now, and we have a fully-fledged roguelike project under our belt.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our work on the template project is complete, we'll be using the final
    chapter to take a look at component-based design. Procedural generation is all
    about flexibility. Therefore, it makes sense that we'd want to work with the most
    flexible architecture. Component-based architecture can achieve this. Having a
    good understanding of this design approach will help you progress and build larger,
    more flexible systems.
  prefs: []
  type: TYPE_NORMAL
