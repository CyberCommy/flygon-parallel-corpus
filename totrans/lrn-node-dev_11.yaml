- en: Testing the Node Applications â€“ Part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll continue our journey of testing the Node applications.
    In the previous chapter, we looked at the basic testing framework and worked on
    synchronous as well as asynchronous Node application. In this chapter we'll move
    on to testing the Express applications, then we'll look into a method to organize
    our test better in the result output, and last but not least we'll get into some
    advanced methods of testing Node application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we''ll look into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up testing for Express app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Express application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing test with `describe()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test spies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the Express application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll be setting up an Express app and then, we'll look at
    how we can test it to verify that the data that comes back from our routes is
    what the user should be getting. Now before we do any of that, we will need to
    create an Express server and that's the goal of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up testing for the Express app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start with installing Express. We''ll use `npm i`, which is short for
    install, to install Express. Remember, you could always replace install with `i`.
    We''ll grab the most recent version, `@4.16.2`. Now, we''ll be using the `save`
    flag as opposed to the save `dev` flag that we''ve used for testing in the previous
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This command is going to install Express as a regular dependency, which is
    exactly what we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b264ed25-457b-42ed-aa81-95a9d3b293c5.png)'
  prefs: []
  type: TYPE_IMG
- en: We need Express when we deploy to production, whether it's Heroku or some other
    service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back inside the app, if we open up `package.json`, we can see we have dependencies
    which we''ve seen before, and `devDependencies` which is new to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is how we can break up the different dependencies. From here, we'll make
    a `server` folder inside the root of the project where we can store the server
    example as well as the test file. We'll make a directory called `server`. Then
    inside `server`, we'll make a file called `server.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `server.js` file will contain the actual code that starts up our server.
    We''ll define our routes, we''ll listen to a port, all that stuff is going to
    happen in here. This is what we had before for the previous server chapter. In
    `server.js`, we''ll add `const express`, and this will get equal to the `require
    (''express'')` return result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we can make our application by creating a variable called `app` and
    setting it equal to a call to `express`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can start configuring our routes. Let''s set up just one for this section,
    `app.get`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will set up an HTTP GET handler. The URL will be just `/` (forward slash),
    the root of the website. And when someone requests that, for the moment we''ll
    specify a really simple string as the return result. We get the request and the
    response object like we do for all of our `express` routes. Yo respond, we''ll
    call `res.send`, sending back the string `Hello World!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step in the process will be to listen on a port using `app.listen`.
    We''ll bind to port `3000` by passing it in as the first and only argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we are now done. We have a basic Express server. Before
    we move on to explore how to test these routes, let''s start it up. We''ll do
    that by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When we run this, we don't get any logs because we haven't added a callback
    function for when the server starts, but it should indeed be up.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we go over to Chrome and visit `localhost:3000`, we get Hello world! printing
    to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/238604f2-8f63-4c3b-b7a1-21f278d8c9c6.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we are ready to move on to start testing our Express application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Express app using SuperTest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we'll learn an easy, no-nonsense way to test our Express applications.
    That means we can verify that when we make an HTTP GET request to the `/` URL,
    we get the `Hello world!` response back.
  prefs: []
  type: TYPE_NORMAL
- en: Now traditionally, testing HTTP apps has been one of the more difficult things
    to test. We would have to fire up a server, like we did in the previous section.
    Then we would need some code to actually make the request to the appropriate URL.
    And then we have to dig through the response, getting what we want, and making
    assertions about it, whether it's headers, the status code, the body, or anything
    else. It is a real burden. That is not the goal for this section. Our goal here
    is to make testing easy and approachable, so we'll use a library called SuperTest
    to test our Express applications.
  prefs: []
  type: TYPE_NORMAL
- en: SuperTest was created by the developers who originally created Express. It has
    built-in support for Express and it makes testing your Express apps dead simple.
  prefs: []
  type: TYPE_NORMAL
- en: The SuperTest documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to get started, let''s pull up the docs page so you know where it
    lives if you ever want to look at any other features that it has to offer. If
    you Google `supertest`, it should be the first result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f38bb5a-5756-44c8-8b0e-895ef3042dfe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s the VisionMedia repository and the repository itself is called SuperTest.
    Let''s switch over to the repository page and we can take a quick look at what
    it has to offer. On this page, we can find installation instructions and introduction
    stuff. We don''t really need that. Let''s take a quick look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4774cb87-52c5-459c-be9e-22b805d7f3f5.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the previous screenshot, we can see an example of how SuperTest
    works. We create an Express application, just like we normally would, and we define
    a route. Then we make a call to the `request` method, which is provided by SuperTest,
    passing in our Express application. We say we want to make a `get` request to
    the `/` URL. Then we start making assertions. There's no need to manually check
    either the headers, the status code, or the body. It has built-in assertions for
    all of that.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test for the Express app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started, we'll install SuperTest in our application by running npm install
    from the Terminal. We have the Node server still running. Let's shut that down
    and then install the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `npm i`, the module name is `supertest` and we''ll be grabbing the
    most recent version, `@2.0.0`. This is a test-specific module so we''ll be installing
    it with save. We''ll use `save-dev` to add it to the `devDependencies` in `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/91335d87-250c-4135-b7e8-668ca5977ef0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With SuperTest installed, we are now ready to work on the `server.test.js`
    file. As it doesn''t yet exist inside the `server` folder, so we can create it.
    It''s going to sit just alongside `server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5647907-a1e0-4e25-b9e5-3b35e634bc81.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have `server.test.js` in place, we can start setting up our very
    first test. First, we''ll be creating a constant called request and setting that
    equal to the return result from requiring `supertest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the main method we''ll be using to test our Express apps. From here,
    we can load in the Express application. Now inside `server.js`, we don''t have
    an export that exports the app, so we''ll have to add that. I''ll add it next
    to the `app.listen` statement by creating `module.exports.app` and setting that
    equal to the `app` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have an export called app that we can access from other files. The `server.js`
    is still going to run as expected when we start it from the Terminal, not in test
    mode. We just added an export so if anyone happens to require it, they can get
    access to that app. Inside `server.test.js`, we''ll make a variable to import
    this. We''ll call the variable `app`. Then we''ll require using `require(''./server.js'')`,
    or just `server`. Then we''ll access the `.app` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, we now have everything we need to write our very first test.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the test for the Express app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first test we''ll write is a test that verifies when we make an HTTP GET
    request to the `/` URL, we get `Hello world!` back. To do this, we will be calling
    `it` just like we did for our other tests in the previous chapter. We''re still
    using `mocha` as the actual test framework. We''re using SuperTest to fill in
    the gaps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll set up the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is going to be an asynchronous call so I are providing `done` as the argument
    to let `mocha` know to wait before determining whether or not the test passed
    or failed. From here, we can now make our very first call to `request`. To use
    SuperTest, we call `request` passing in the actual Express application. In this
    case, we pass in the `app` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Then we can start chaining together all the methods we need to make the request,
    make our assertions, and finally wrap things up. First up, you'll be using a method
    to actually make that request, whether it's a `get`, `put`, `delete`, or a `post`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we''ll be making a `get` request, so we will use `.get`. The `.get`
    request takes the URL. So, we''ll provide `/` (forward slash), just as we did
    in `server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we can make some assertions. To make assertions, we''ll use `.expect`.
    Now `.expect` is one of those methods that does different things depending on
    what you pass to it. In our case, we''ll be passing in a string. Let''s pass in
    a string which will be the response body that we assert, `Hello world!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''re done and we''ve made our assertions, we can wrap things up.
    To wrap up a request in SuperTest, all we do is we call `.end` passing in `done`
    as the callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This handles everything behind the scenes so you don't need to manually call
    `done` at a later point in time. All of it is handled by SuperTest. With these
    four lines (in the previous code), we have successfully tested our very first
    API request.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our first API request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll kick things off in the Terminal by running our `test-watch` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The test script is going to start and as shown here, we have some tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/412cbf0b-4734-47eb-b4e0-92f75fe19b2d.png)'
  prefs: []
  type: TYPE_IMG
- en: We have our test, `should return hello world response`, showing up in the previous
    screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can take things a step further making other assertions about the data
    that comes back. For example, we can use expect after the `.get` request in `server.test.js`
    to make an assertion about the status code. By default, all of our Express calls
    are going to return a `200` status code, which means that things went OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we save the file, the test still passes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a37cd1c-3c98-4e2d-8fc4-ea79b890c976.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s make some changes to the request to make these tests fail. First
    up, in `server.js` we''ll just add a few characters (`ww`) to the string, and
    save the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This should cause the SuperTest test to fail and it does indeed do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6bd94fa-5169-4ff0-8f3a-17e5df616194.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the previous screenshot, we get a message, `expected 'Hello world!'
    response body, but we got 'Hello wwworld!'`. This is letting us know exactly what
    happened. Back inside `server.js`, we can remove those extra characters (`ww`)
    and try something else.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up custom status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we haven''t talked about how to set a custom status for our response, but
    we can do that with one method, `.status`. Let''s add `.status` in `server.js`,
    chaining it on, before, `send(''Hello world!'')`, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can pass in the numerical status code. For example, we could use a
    `404` for page not found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If we save the file this time around, the body is going to match up, but inside
    the Terminal we can see we now have a different error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c75b0864-1897-4484-b5c7-a428d5394a5d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We expected a `200`, but we got a `404`. Using SuperTest, we can make all sorts
    of assertions about our application. Now the same thing is true for different
    types of responses. For example, we can create an object as the response. Let''s
    make a simple object and we''ll create a property called `error`. Then we''ll
    set `error` equal to a generic error message for a `404`, something like `Page
    not found`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''re sending back a JSON body, but currently we''re not making any assertions
    about that body so the test is going to fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27e0ba2b-48fd-4105-a9ac-c6902106ede5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can update our tests to `expect` JSON to come back. In order to get that
    done, all we have to do inside `server.test` is change what we pass to `expect`.
    Instead of passing in a string, we''ll pass in an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can match up that object exactly. Inside the object, we''ll `expect`
    that the `error` property exists and that it equals exactly what we have in `server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll change the `.expect` call to a `404` from `200`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, our assertions now match up with the actual endpoint we''ve
    defined inside the Express application. Let''s save the file and see if all the
    tests pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ab5f585-ac2e-4164-888c-96995b2f1703.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the previous screenshot, we can see it is indeed passing. The `Should
    return hello world` response is passing. It took about `41ms` (milliseconds) to
    complete, and that is perfectly fine.
  prefs: []
  type: TYPE_NORMAL
- en: Adding flexibility to SuperTest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A lot of the built-in assertions do get the job done for the majority of cases.
    There are times where you want a little more flexibility. For example, in the
    previous chapter, we learned about all those cool assertions expect can make.
    We can use `toInclude`, `toExclude`, all of that stuff is really handy and it''s
    a shame to lose it. Luckily, there''s a lot of flexibility with SuperTest. What
    we can do instead of taking an object and passing it into expect, or a number
    for the status code, we can provide a function. This function will get called
    by SuperTest and it will get passed the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This means we can access headers, body, anything we want to access from the
    HTTP responseâ€”it's going to be available in the function. We can pipe it through
    the regular expect assertion library like we've done in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s load it in, creating a constant called `expect` and setting it equal
    to require `expect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now before we look at how it''s going to work, we''ll make a change in `server.js`.
    Here, we''ll add a second property on to the `.status` object. We''ll add an `error`
    and then add something else. Let''s use `name`, setting it equal to the application
    name, `Todo App v1.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have this in place, we can take a look at how we can use those custom
    assertions inside our test file. In the `.expect` object, we'll have access to
    the response and in the response there is a body property. This will be a JavaScript
    object with key-value pairs, which means we would expect to have an `error` property
    and a `name` property, which we set in `server.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back inside our test file, we can make a custom assertion using `expect`. I''ll
    `expect` something about the body, `res.body`. Now we can use any assertion we
    like, not just the equals assertion, which is the only one SuperTest supports.
    Let''s use the `toInclude` assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, `toInclude` lets you specify a subset of the properties on the object.
    As long as it has those ones that''s fine. It doesn''t matter that it has extra
    ones. In our case, inside `toInclude`, we can just specify the `error` message,
    leaving off the fact that name exists at all. We want to check that `error: Page
    not found`, formatted exactly like we have it inside of `server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we save the file back inside the Terminal, things restart and all
    of my tests are passing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e33be389-d1e9-4939-881b-31908affca8d.png)'
  prefs: []
  type: TYPE_IMG
- en: Using a combination of SuperTest and expect we can have super flexible test
    suites for our HTTP endpoints. With this in place, we'll create another `express`
    route and we'll define a test that makes sure it works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an express route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There will be two sides to this express route, the actual setup in `server.js`
    and the test. We can start inside `server.js`. In here, we''ll make a new route.
    First, let''s add a few comments to specify exactly what we''ll do. It''s going
    to be an HTTP `GET` route. The route itself will be `/users` and we can just assume
    this returns an array of users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can pass an array back through the `send` method, just like we do an object
    in the previous code. Now this array is going to be an array of objects where
    each object is a user. For now, we want to give users a `name` property and an
    `age` prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll create two or three users for this example. Now once we have this
    done, we''ll be responsible for writing a test that asserts it works as expected.
    That''s going to happen in `server.test.js`. Inside `server.test.js`, we''ll make
    a new test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And this test is going to assert a couple of things. First up, we assert that
    the status code that comes back is a `200` and we want to make an assertion that
    inside of that array and we''ll do that using `toInclude`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start with defining the endpoint first. Inside `server.js`, just following
    the comments, we''ll call `app.get` so we can register the brand new HTTP endpoint
    for our application. This one is going to be at `/users`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we''ll specify the callback that takes both request and response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This will let us actually respond to the request, and the goal here is just
    to respond with an array. In this case, I''ll call `response.send` passing in
    an array of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The first object will be `name`. We''ll set the `name` equal to `Mike` and
    we''ll set his `age` equal to `27`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then I can add another object. Let''s add the second object to the array with
    a name equal to `Andrew` and an age equal to `25`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last one, we''ll set the name equal to `Jen` and the age equal to `26`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our endpoint done, we can save `server.js`, move into `server.test.js`,
    and start worrying about actually creating our test case.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the test for the express route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `server.test.js`, just following the comments, we need to start things out
    by calling `it`. `it` is the only way to make a new test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll specify the callback function. It will get past the `done` argument
    because this one is going to be asynchronous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To kick things off inside the test case, we''ll be calling requests just like
    we did in hello world response, passing in the Express application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can set up the actual call. In this case, we''re just making a call,
    a `get` request, to the following URL, inside of quotes, `/users`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we can start making our assertions and the first thing we''re supposed
    to assert that the status code is at `200`, which is the default status code used
    by Express. We can assert that by calling `.expect` and passing in the status
    code as a number. In this case, we''ll pass in `200`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we''ll use a custom `expect` assertion. This means that we''ll
    call `expect` passing in a function and use `toInclude` inside `it` to make the
    assertion that you exist in that users array. We''ll call `expect` the method
    passing in the function, and that function will get called with the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This will let us make some assertions about the response. What we''re actually
    going to do is make an assertion using `expect`. We''ll expect something about
    the response body. In this case, we''ll be checking that it includes using `toInclude`,
    our user object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now remember you can call `toInclude` on both arrays and objects. All we do
    is pass in the item we want to confirm is in the array. In our case, it''s an
    object where the `name` property equals `Andrew` and the `age` property equals
    `25`, which is what we used inside `server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our custom `expect` call in place, at the very bottom we can
    call `.end`. This is going to wrap up the request and we can pass in `done` as
    the callback so it can properly fire off those errors if any actually occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, we are ready to get going. We can save the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the Terminal, we can see the tests are indeed rerunning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3521bffa-2049-4c26-a4a7-6bcdd5586349.png)'
  prefs: []
  type: TYPE_IMG
- en: We have a test as shown in the previous screenshot, `should return my user object`.
    It is passing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can confirm that we''ll not go crazy and test the wrong thing by just
    messing up the data. We will now add a lowercase `a` after the uppercase one in
    `Andrew` in `server.js`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The test is going to fail. We can see that in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/508cafd2-49ef-4e05-8d44-0c33b51c793f.png)'
  prefs: []
  type: TYPE_IMG
- en: We have done testing for our Express apps. We'll now talk about one more way
    we can test our Node code.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing test with describe()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to use `describe()`. `describe` is a function
    injected into our test files, just like the `it` function is. It comes from `mocha`
    and it''s really fantastic. Essentially, it lets us group tests together. That
    makes it a lot easier to scan the test output. If we run our `npm test` command
    in the Terminal, we get our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e8cf5ce-b9fb-45a3-84ea-dc4804f28ba3.png)'
  prefs: []
  type: TYPE_IMG
- en: We have seven tests and currently they're all grouped together. It's really
    hard to look for the tests in the `utils` file and it's impossible to find the
    tests for `asyncAdd` without scanning all of the text. What we'll do is call `describe()`.
    This will let us make groups of tests. We can give that group a name. It will
    make our test output much more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `utils.test.js` file, right after the `utils` constant, we''ll call
    `describe()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The describe object takes two arguments, just like `it`. The first one is the
    name and the other is the callback function. We''ll use `Utils`. This will be
    the `describe` block that contains all of the tests in the `utils.test` file.
    Then we''ll provide the function. This is the callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Inside the callback function, we'll be defining tests. Any test defined in the
    callback function will be a part of the `utils` block. That means we can take
    our existing tests, cut them out of the file, paste them in there, and we'll have
    a `describe` block called `utils` with all of the tests for this file. So, let's
    do just that.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll grab all the tests, excluding the ones that are just playground tests
    where we play around with various `expect` functionality. We''ll then paste them
    right into the callback function. The resultant code is going to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'These are four tests for `add`, `asyncAdd`, `square`, and `asyncSquare` respectively.
    Now we''ll save the file and we can start up the `test-watch` script from the
    Terminal and check the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The script will start and run through our tests, and as shown in the following
    screenshot, we''ll have different outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02860fc6-4a4f-4142-be2c-54f79836c70a.png)'
  prefs: []
  type: TYPE_IMG
- en: We have a `Utils` section and under `Utils`, we have all of the tests in that
    `describe` block. This makes reading and scanning your tests much, much easier.
    We can do the same thing for the individual methods.
  prefs: []
  type: TYPE_NORMAL
- en: Adding describe() for individual methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, in the case of `utils.test.js` (refer to the previous screenshot), we
    have one test per method, but if you have a lot of tests that are targeting a
    complex method, it''s best to wrap that in its own `describe` block. We can nest
    `describe` blocks and tests in any way we like. For example, right inside `utils`
    just after the `describe` statement, we can call `describe` again. We can pass
    a new description. Let''s use `#` (pound sign) followed by `add`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `#` (pound sign) followed by the method name is the common syntax for adding
    a `describe` block for a specific method. Then we can provide that callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can take any tests we want to add into that group, cut them out, and
    paste them in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Then I can save the file. This will rerun the test suite and now we have test
    output that''s even more scannable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc75b06b-dcc9-4b98-8f16-53fd5d39688f.png)'
  prefs: []
  type: TYPE_IMG
- en: It's super easy to find the `utils` add method tests because they're clearly
    labelled. Now you could go as crazy or as uncrazy with this as you want. There
    really is no hard-and-fast rule for how often to use `describe` to structure your
    tests. It's really up to you to figure out what makes sense given the amount of
    tests you have for a method or a file.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we have quite a few tests in the file so it definitely makes sense
    to add that `utils` block. And I just wanted to show you you could nest them,
    so I added it for `add` as well. If I was writing this code, I probably wouldn't
    add a second layer of tests, but if I had more than one test per method, I definitely
    would add a second `describe` block.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the route describe block for the server.test.js file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s create some `describe` blocks in the `server.test` file. We''ll
    create a route `describe` block called `Server`. Then we''ll create `describe`
    blocks for both the route URL and for `/users`. We''ll have `GET/`. That will
    have the test case in there, `some test case`. Then alongside `//`, we''ll have
    `GET /users`, and that will have its own test case, `some test case` as explained
    in the comments next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now the test cases are obviously already defined. All we need to do is call
    `describe` three times to generate the previously explained structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with calling `describe()` once following the comments part, and
    this description will be for the route, so we''ll call this one `Server`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This is going to contain all the tests in our `server` file. We can add the
    callback function next and we can move on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we''ll call `describe` again. This time we''re creating a `describe`
    block for tests that test the `GET /` route and add the callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can simply take our test, cut it out, and paste it right inside the
    `describe` callback. The resultant code is going to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we''ll call `describe` the third time. We''ll be calling `describe`
    passing in as the description `GET /users`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll have our callback function as always and then we can copy and paste
    our test right inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we are now done. We have a much better structure for our
    tests and when we rerun the test suite by saving the file, we''ll be able to see
    that in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b29209b4-2c4b-4d9e-9971-b45402671484.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the previous code, we have a much more scannable test suite. We
    can see our server tests right away. We can create groups of tests for each feature.
    Since we have static data right now, we really don't need more than one test per
    feature. But down the line, we will have multiple tests for each of our HTTP requests,
    so it's a good idea to get into that habit of creating `describe` blocks early.
    And that's it for this one!
  prefs: []
  type: TYPE_NORMAL
- en: Test spies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, which is the final section for the testing chapter, we'll learn
    some pretty advanced testing techniques. We'll be using these techniques as we
    build real-world apps, but for now let's start off with an example. We'll worry
    about the vocabulary for what we're about to do in just a second.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the moment, we''ll close all our current files and create a new directory
    in the root of the project. We''ll make a new folder called `spies`. We''ll talk
    about what exactly `spies` are and how they relate to testing in just a moment.
    Inside `spies`, we''ll make two files: `app.js` (this is the file that we''ll
    be testing) and a second one, called `db.js`. In our example, we can just assume
    that `db.js` is a file that has all sorts of methods for saving and reading data
    from the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `db.js`, we''ll create one function using `module.exports`. Let''s create
    a function called `saveUser`. The `saveUser` function will be a really simple
    function, and it will take a `user` object like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll just print it to the screen using the `console.log` statement.
    We''ll print it a little message, `Saving the user`, and we''ll also print out
    the object as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now obviously, this is not a real `saveUser` function. We do not interact with
    any sort of database, but it will illustrate exactly how we will be using `spies`
    to test our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we will fill our `app.js`, and this is the file we''ll actually be
    testing. Inside `app.js`, we''ll create a new function: `module.exports.handleSignup`.
    In the context of an application with authentication, `handleSignup` might take
    an `email` and a `password`; maybe it goes ahead and checks if the `email` already
    exists. If it doesn''t, great; it saves the user and then it sends some sort of
    a welcome email. We can simulate that by creating an arrow function (`=>`) that
    takes in `email` and a `password`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the arrow function (`=>`), we''ll leave three comments. These will be
    things that the function is supposed to do. It will check if the `email` already
    exists; it will save the user to the database; and finally, we''ll send that welcome
    email:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, these three things are just an example of what a `handleSignup` method
    might actually do. When we go through the real process, you''ll see how it pans
    out. Now, we already have one of these in place. We just created `saveUser`, so
    we''ll do is call `saveUser` instead of having this second comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s not imported just yet, but that''s not going to stop us from calling
    it; we''ll add the import in just a second, and we''ll pass in what it expects,
    the `user` object. Now, we don''t have a `user` object; we have an `email` and
    a `password`. We can create that `user` object by setting `email` equal to the
    `email` argument and setting `password` equal to the `password` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now one important thing to note: inside ES6, if the property name in an object
    you''re setting is the same as the variable name, you can actually define it like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In this example, since we're setting a `password` property equal to whatever
    on the `password` variable, there's no need to have both. This ES6 syntax also
    allows us to create a much simpler-looking call. There's no need to have it on
    multiple lines since it's pretty reasonable in length.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, at the top, we can load in `db` by creating a variable, calling it `db`,
    and setting it equal to `require(''db.js'')`. That is a local file, so we''ll
    start it with a `./` to grab it from the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this is an example of something that we''ll want to test inside our code.
    We have a `handleSignup` method. It takes an `email` and a `password`, and we
    need to make sure that `db.saveUser` works as well. That is a big problem, and
    this means that we''re not just testing `handleSignup`, we are also testing the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: We're testing `handleSignup`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We're testing our code that checks if an `email` exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maybe that allows another function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We're checking if the `saveUser` function works as expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: we're checking if the welcome email is sent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a real pain. What we'll do instead is fake the `saveUser` function.
    It's never actually going to execute the code inside it `db`, but it will let
    us verify that when we run `handleSignup`, `saveUser` gets called. We're going
    to do this with something called `spies`.
  prefs: []
  type: TYPE_NORMAL
- en: The `spies` function let you swap out a real function such as `saveUser` for
    a testing utility. When that test function gets called we can create various assertions
    about it, making sure it was called with certain arguments. Let's start exploring
    that.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test file for spies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start it with creating a new file. Inside the `spies` directory, we''ll
    make a new file called `app.test.js`, and we can start playing around with `spies`.
    Now, `spies` comes built-in with `expect`, so all we have to do is load it in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'From here we can create our very first test. We''ll put this in a `describe`
    block so it''s easier to find over in our test output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll call this `describe` block `App` and we''ll add my callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can add individual test cases. First up, we''ll call `it` and make a
    new test where we can just play around with `spies`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We won''t be calling the function in our `app.js` file just yet. We''ll add
    in the `it` object a string say, `Should call the spy correctly`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: In order to visualize how `spies` work, we'll go through the most basic example
    we can. First up, creating a `spy`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a spy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a `spy`, we''ll call a function `expect.createSpy` inside the `it`
    callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The `createSpy` is going to return a function, and that is the function that
    we''ll swap out for the real one, which means we do want to store that in a variable.
    I''ll create a variable called `spy`, setting it equal to the returned result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we would inject `spy` into our code, whether it''s `app.js` or some
    other function, and we would wait for it to get called. We can call it directly
    just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Setting up spies assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next up, we can set up a series of assertions using expect's spies assertions
    by heading over to the browser and going to the `expect` documentation, mjackson
    expect ([https://github.com/mjackson/expect](https://github.com/mjackson/expect)).
  prefs: []
  type: TYPE_NORMAL
- en: 'On this page, we can scroll down to the spies section, where they talk about
    all the assertions we have access to. We should start seeing spies in the method
    names, and that''s when we know we''ve gotten there:'
  prefs: []
  type: TYPE_NORMAL
- en: '&gt;![](img/0311259d-04c6-4edb-93e7-fbe4b349cede.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the previous code, we have the `toHaveBeenCalled` function and
    this is our first assertion with spies. We can assert that our `spy` was indeed
    called. Inside Atom, we''ll do that by calling `expect` and passing in the `spy`,
    just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll add the assertion, `toHaveBeenCalled`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'This will cause the test to pass if `spy` was called, which it was, and it''ll
    cause the test to fail if the `spy` was never called. We can run the test suite
    inside the Terminal using the `npm run test-watch` command, and this is going
    to kick off the tests using `nodemon`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33d05e07-6245-4e92-a744-5563a2d22312.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the previous screenshot, we have all our test cases, and under the
    `App` one, we have `should call the spy correctly`. It did indeed pass, which
    is fantastic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s comment out the line where I call `spy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'And this time around, the test should fail because `spy` was never actually
    called, and as shown in the following screenshot, we see `spy was not called`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69b6fdcc-3963-40fa-95b5-6e75ecafce77.png)'
  prefs: []
  type: TYPE_IMG
- en: More details out of spy assertion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, checking if a `spy` was called or not called is great, but we can get
    even more detail out of our assertions. For example, what if I call the `spy`
    with the name `Andrew` and the age `25`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Now, we want to verify if the `spy` was not just called but was called with
    these arguments? Well, luckily, we have an assertion for that too. Instead of
    `toHaveBeenCalled`, we can call `toHaveBeenCalledWith`, and this lets us pass
    in some arguments and verify the `spy` was indeed called with those arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following code, we''ll assert that my `spy` was called with
    `Andrew` and the number `25`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'When we save the file and the test cases restart, we should see all the tests
    passing, and that''s exactly what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ae4a79e-ed08-452a-b700-444efee2ad00.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if the `spy` was not called with the mentioned data, I''ll remove `25`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Now if we rerun the test suite, the test will fail. It will give you an error
    message letting you know that `spy was never called with [ 'Andrew', 25 ]`. This
    is causing the test to fail, which is fantastic.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are plenty of other assertions we can use with our spies. You can find
    them in the `expect` docs. We have `toHaveBeenCalled`, which we used; `toNotHaveBeenCalled`,
    verifying that a `spy` was not called. Then we have `toHaveBeenCalledWith`, which
    we also used. You can see there''s a lot more to spies as well: how to create
    spies, which we''ve already done, and a few other methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Swapping of the function with spy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our purposes, we need a spy so we can simulate that function inside of `app.js`
    (`saveUser`). We need a way to replace `saveUser` function with a `spy`. Then
    we can verify that when `handleSignup` gets called, it does indeed call `saveUser`.
    It doesn't need to actually go through the process over in `db.js`; this is not
    important to our tests. The only thing that is important is that the function
    was called with the correct arguments.
  prefs: []
  type: TYPE_NORMAL
- en: To do that, we'll look at an npm module called `rewire`, which lets us swap
    out variables for our tests. In our case, in our test file, we'll be able to replace
    the `db` object with something else completely. Then, when the code runs, instead
    of calling `db.saveUser` as defined in `app.js`, it will be calling `db.saveUser`,
    which will be a `spy`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and setting up the rewire function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, we do need to install `rewire` in the Terminal. It''s a fantastic
    test utility. It''s pretty essential for testing functions with side effects,
    like the one we have seen in this section. Let''s run `npm install`. The module
    name itself is called `rewire`, and we''ll be grabbing the most recent version
    as of this filming, version `@3.0.2`. This is a test-specific module. We''ll not
    need it for our application to run regularly, so we will be using the `--save-dev`
    flag to add it to our `package.json` dependencies list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/772b3e90-b3e7-4f24-abdf-7a844dcbde72.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the module is installed we can get started using it, and it''s pretty
    simple to set up. Inside `app.test.js` we can start by loading it in. Up at the
    very top, we''ll create a new constant. This one will be called `rewire`, and
    we''ll set it equal to the returned result from requiring `rewire`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Replacing db with the spy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, the way that `rewire` works is it requires you to use `rewire` instead
    of require when you''re loading in the file that you want to mock out. For this
    example, we want to replace `db` with something else, so when we load an `app`
    we have to load it in in a special way. We''ll make a variable called `app`, and
    we''ll set it equal to `rewire` followed by what we would usually put inside of
    `require`. In this case it''s a relative file, a file that we created `./app`
    will get the job done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Now rewire loads your file through require, but it also adds two methods onto
    `app`. These methods are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.__set__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.__get__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use these to mock out various data inside of `app.js`. That means we'll
    make a simulation of the `db` object, the one that comes back from `db.js`, but
    we'll swap out the function with a `spy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside our `describe` block, we can kick things off by making a variable. This
    variable is going to be called `db`, and we''ll set it equal to an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing we need to mock out in our case is `saveUser`. Inside the object,
    we''ll define `saveUser` and then I''ll set it equal to a `spy` by creating one
    using `expect.createSpy`, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have this `db` variable, and the only thing left to do is replace it.
    We do that using `app.__set__`, and this is going to take two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The first one is the thing you want to replace. We''re trying to replace `db`,
    and we''re trying to replace it with the `db` variable, which is our object that
    has the `saveUser` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: With that in place, we can now write a test that verifies that `handleSignup`
    does indeed call `saveUser`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a test to verify swapping of the function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To verify if `handleSignup` calls `saveUser`, inside `app.test.js`, we''ll
    call `it`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can pass in our function, and this is what will actually run when the
    test gets executed, and there''s no need to use any asynchronous done arguments.
    This will be a synchronous test for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the callback function, we can come up with an `email` and a `password`
    that we''ll pass in to `handleSignup` in `db.js`. We''ll make a variable called
    `email` setting it equal to some email `andrew@example.com`, and we can do the
    same thing with the `password`, `var password`; we''ll set that equal to `123abc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we will call `handleSignup`. This is the function we want to test.
    We''ll call `app.handleSignup`, passing in our two arguments, `email` and `password`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Now at this point, `handleSignup` will get executed. This means that the code
    over here will run and it will fire `db.saveUser`, but `db.saveUser` is not the
    method in `db.js`; it's a `spy` instead, which means we can now use those assertions
    we just learned about.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside of the test case, we''ll use `expect` to `expect` something about `db`;
    the variable `.saveUser`, which we set equal to a `spy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll call `.toHaveBeenCalledWith` with an object because that is what `db.js`
    should have been called with. We''ll use that same ES6 shortcut: `email`, `password`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates an `email` attribute set to the `email` variable, and a `password`
    attribute set to the `password` variable. With this in place, we can now save
    our test file, and in the Terminal we can restart the `test-watch` script by using
    the up arrow key twice to rerun our `npm run test-watch` command. This is going
    to kick off our test suite, starting up all of our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62d3796d-0000-4bab-882f-4b588b6d3ad5.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the previous screenshot, we see `should call the spy correctly`
    passes. Also, the test case we just created also passes. We can see `should call
    saveUser with the user object`, and this is fantastic. We now have a way to test
    pretty much anything inside Node. We can even test functions that call other functions,
    verifying that the communication happens as expected. All of this can be done
    using spies.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked into testing the Express applications as we did with
    the synchronous and async Node applications in the previous chapter. Then, we
    worked on organizing our tests with the `describe()` object so that we can see
    our different test methods right away.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section we explored one more way we can test our Node applications,
    that is, spies. We created test files for spies, looked into the `spy` assertions
    and swapping of a function with `spy`.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That's the end of the book! Through the course of is book, you learned the fundamentals
    of Node.js so that you test and deploy Node.js applications on the web. We hope
    that you liked the journey this book has taken you through. We wish you all the
    success and hope that you continue to better your Node.js applications.
  prefs: []
  type: TYPE_NORMAL
