- en: 12\. Intermediate Calculus with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to solve problems when given equations
    dealing with the change in a variable. In this chapter, you'll use numerical methods
    to model populations and temperatures and use differential equations to calculate
    their past values or predict their future values. You'll learn how to use binary
    search to *guess and check* your way to a very accurate solution when you know
    it's in a specific range of numbers. You'll also model situations where objects
    move and solve for their future positions when given differential equations for
    their velocity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Math students often complain that there's no real-world application for the
    kinds of problems arising in algebra and geometry, such as factoring polynomials
    or bisecting angles, but the same can't be said for differential equations. Using
    the tools, you'll learn about in this chapter, you will be able to model and solve
    real-life problems in physics, electronics, and engineering with differential
    equations. Python is the perfect tool for mathematicians and scientists who want
    to be able to crunch numbers and solve problems but don't want to have to get
    another degree in computer science to do so. Python is one of the most popular
    programming languages due to its ease of use and lack of unnecessary abstraction.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: By the 1600s, mathematicians had modeled the motion of falling objects with
    mathematical equations and had set their sights on the planets in outer space.
    Newton modeled their motion and the equations he came up with referred not only
    to unknown numbers but also the changes in those numbers. For example, his equations
    didn't only contain an unknown angle, but the change in that angle (its angular
    velocity) and even the change in the change in the angle (its acceleration)! There
    were no tools for solving those equations, so he had to invent the tools himself.
    These tools became known as calculus.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Differential Equations
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Solving an equation in a math class usually involves an unknown number, *x*.
    The equation hides the value but gives you hints as to how to find the value,
    such as ![1](image/B15968_12_InlineEquation1.png). But to solve a differential
    equation, you''re only given information regarding the derivative of a function,
    and you''re expected to find the function. It could be something as simple as
    the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: Finding a function with derivative 2'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.1: Finding a function with derivative 2'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'This means *find a function whose derivative is 2.* This can also be written
    as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: Alternative way to represent derivative of the function'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.2: Alternative way to represent derivative of the function'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: By simple integration, we can find functions that work in this equation because
    we know the function *y = 2x* has a derivative of 2\. In fact, many related functions,
    such as *y = 2x + 1*, *y = 2x + 2*, *y = 2x + 3*, and so on, all have a derivative
    of 2\. So, we write a general form, that is, *y = 2x + C*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Things get more complicated when we don''t have much to go on, like in this
    equation:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: Derivative of a function whose value is the function itself'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_03.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.3: Derivative of a function whose value is the function itself'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: This is asking for a function whose derivative is the function itself.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: To understand how differential equations are used, let's start with simple functions,
    and ones involving things in the real world, such as money.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Interest Calculations
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's a crucial tool in the study of differential equations that originated
    in the study of interest calculations in the middle ages. Let's take a look at
    the following exercise.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.01: Calculating Interest'
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A savings account pays 2% annual interest. If $3,500 is invested, how much money
    is in the account after 5 years?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'The formula for simple interest is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4: Formula for simple interest'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4：简单利息公式'
- en: '](image/B15968_12_04.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_04.jpg)'
- en: 'Figure 12.4: Formula for simple interest'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：简单利息公式
- en: 'Here, *I* is the interest, *P* is the principal or the original amount invested,
    *r* is the rate of interest or growth, and *t* is the time the amount has been
    invested for. By this formula, the interest earned on the amount is *I = (3500)(0.02)(5)
    = $350*. Follow these steps to complete this exercise:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*I*是利息，*P*是本金或原始投资金额，*r*是利率或增长率，*t*是投资金额已投资的时间。根据这个公式，金额的利息为*I = (3500)(0.02)(5)
    = 350美元*。按照以下步骤完成此练习：
- en: 'This is a good opportunity to start a program that will take in an initial
    amount, interest rate, and time and output the interest earned using the preceding
    formula:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个很好的机会来开始一个程序，它将接受初始金额、利率和时间，并使用前面的公式输出利息收入：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see in the docstring of the `amount` function, it will take a starting
    amount and a rate of growth and return the amount of the investment after the
    given number of years. Let''s see the interest earned in 1-5 years:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您在`amount`函数的文档字符串中所看到的，它将接受一个起始金额和增长率，并返回给定年数后的投资金额。让我们看看1-5年内的利息收入：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here''s the output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But this isn''t really how interest works. A few times every year, we calculate
    the interest earned for that fraction of the year, add it to the principal, and
    the new principal is higher. The next interest calculation is on the higher number,
    hence the name *compound interest*. The formula for the amount after *t* years,
    given *n* compounding per year, is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是利息的真正工作方式。每年几次，我们计算该年份的利息收入，将其加到本金中，新的本金更高。下一次的利息计算是在更高的数字上，因此称为*复利*。给定*每年n次复利*的*t*年后的金额的公式如下：
- en: '![Figure 12.5: Formula to calculate the amount after t years'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5：计算t年后的金额公式'
- en: '](image/B15968_12_05.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_05.jpg)'
- en: 'Figure 12.5: Formula to calculate the amount after t years'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：计算t年后的金额公式
- en: 'Let''s change our `amount` function to the following:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`amount`函数更改为以下内容：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this function, we added the interest earned in the fraction of the year
    given by the number of compounding. If we only compound the interest once a year,
    it looks like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们添加了按复利次数给出的年份的利息收入。如果我们每年只计算一次复利，看起来是这样的：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is what we get:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们得到的：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, at the end of 5 years, we've earned $364, not just $350\. Compounding more
    often, even with the same interest rate, makes the amount grow more quickly. If
    we changed the compounding to 12 per year (compounding monthly), we'd end up with
    $3,867 after 5 years, a little more than compounding annually.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在5年结束时，我们赚了364美元，而不仅仅是350美元。即使利率相同，复利更频繁也会使金额增长更快。如果我们将复利更改为每年12次（每月复利），我们将在5年后得到3867美元，比年复利多一点。
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3dUWz7C.](https://packt.live/3dUWz7C
    )
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3dUWz7C](https://packt.live/3dUWz7C)。
- en: You can also run this example online at [https://packt.live/3iqUKCO.](https://packt.live/3iqUKCO
    )
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/3iqUKCO](https://packt.live/3iqUKCO)上在线运行此示例。
- en: 'Exercise 12.02: Calculating Compound Interest – Part 1'
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.02：计算复利-第1部分
- en: '$2,000 is invested in a savings account that earns 5.5% annual interest, compounded
    monthly. How long will it take for the amount to grow to $8,000? Follow these
    steps to work this out:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个年利率为5.5%的储蓄账户中投资了2000美元，按月复利。要将金额增长到8000美元需要多长时间？按照以下步骤来解决这个问题：
- en: 'We''ll print out the first 5 years of the investment using our `amount` function
    from the previous exercise:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用我们从上一个练习中的`amount`函数打印出投资的前5年：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After 5 years, the amount is only $2,631\. To get to $8,000, we''ll have to
    go to 20 or 30 years:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5年后，金额只有2631美元。要达到8000美元，我们必须走20或30年：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Sometime between 25 and 30 years, we'll get to $8,000\. The way to get more
    exact is to guess smarter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在25到30年之间的某个时候，我们将达到8000美元。更精确的方法是更聪明地猜测。
- en: 'We''ll cut the range in half and guess higher or lower based on what we get
    out. For example, the average of 25 and 30 years is 27.5, so we enter the following:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将范围减半，并根据我们得到的结果猜测更高或更低。例如，25年和30年的平均值是27.5，因此我们输入以下内容：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the output:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, we'd reach $9,000 in 27.5 years. The time to get to $8,000 must be less
    than that.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将在27.5年内达到9000美元。达到8000美元的时间必须少于这个时间。
- en: 'We''ll calculate the average of 25 and 27.5 and plug that in:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将计算25和27.5的平均值并将其代入：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following is the output:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s write a program to keep doing this until we find our answer. This is
    called a **binary search**. Let''s create a `bin_search` function that will take
    the name of the function we''re using, the lower and upper bounds of the range
    we''re searching over, and the target output—in this case, 8,000—as parameters:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写一个程序，直到找到答案为止。这称为**二分搜索**。让我们创建一个`bin_search`函数，它将使用我们正在使用的函数的名称，我们正在搜索的范围的下限和上限以及目标输出（在本例中为8000）作为参数：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here''s the critical line. It plugs the average into the function, using all
    the other required parameters, and assigns the output to the `guess` variable.
    We''ll check whether that variable is equal to our target or whether we have to
    guess higher or lower:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是关键的一行。它将平均值插入函数中，使用所有其他必需的参数，并将输出分配给`guess`变量。我们将检查该变量是否等于我们的目标，或者我们是否需要猜测更高或更低：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We''ll plug the lower and higher ends of our range into our function, as well
    as our target number, to get our approximation:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将我们范围的下限和上限以及我们的目标数字代入我们的函数，以获得我们的近似值：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Looks like we''ll get to $8,000 in **25 years and 4 months**. Let''s check
    that:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看起来我们将在**25年零4个月**内达到8000美元。让我们检查一下：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Sure enough, the balance after that compounding is just over $8,000:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 果然，复利后的余额超过了8000美元：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We'll use the binary search again, but for now, let's use our code to find a
    rather important mathematical constant that comes up often in differential equations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用二分搜索，但现在，让我们使用我们的代码来找到一个在微分方程中经常出现的相当重要的数学常数。
- en: Note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3iq95PV.](https://packt.live/3iq95PV
    )
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3iq95PV](https://packt.live/3iq95PV)
- en: You can also run this example online at [https://packt.live/2BpdbHI.](https://packt.live/2BpdbHI
    )
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2BpdbHI](https://packt.live/2BpdbHI)上在线运行此示例
- en: 'Exercise 12.03: Calculating Compound Interest – Part 2'
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.03：计算复利-第2部分
- en: How much would you make if you invested $1 at 100% interest for 1 year, compounded
    continuously?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以100%的利率投资$1，连续复利1年，您会赚多少？
- en: 'Remember that the more frequently you compound the interest, the higher the
    final amount will be. How much do you think it will be? $1.50? $2? The principal,
    rate, and time are all 1, but what is the `comps` variable? Follow these steps
    to complete this exercise:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，复利的频率越高，最终金额就越高。您认为会是多少？$1.50？$2？本金、利率和时间都是1，但`comps`变量是什么？按照以下步骤完成这个练习：
- en: 'To approximate compounding continuously, we''ll compound the interest every
    second (*365*24*60*60* times per year):'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了近似连续复利，我们将每秒复利一次（每年*365*24*60*60*次）：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is around $2.72\. That number, 2.71828…, is the number *e*, which is the
    base of natural logarithms. It''s very useful for modeling populations in the
    natural world since animals, plants, and microorganisms don''t wait until the
    end of the month to reproduce—they do so continuously. So, when interest is compounded
    continuously or when a population is growing naturally, we''ll use this formula:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 大约是$2.72。这个数字，2.71828…，是自然对数的底数*e*。它对于模拟自然界中的人口非常有用，因为动物、植物和微生物不会等到月底才繁殖-它们是持续不断地繁殖。因此，当利息连续复利或人口自然增长时，我们将使用这个公式：
- en: '![Figure 12.6: Formula to calculate compound interest'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.6：计算复利的公式'
- en: '](image/B15968_12_06.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_06.jpg)'
- en: 'Figure 12.6: Formula to calculate compound interest'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：计算复利的公式
- en: 'Let''s create a function to do this quickly. First, we''ll need to import *e*
    from the `math` module for our continuous compounding:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个函数来快速完成这个任务。首先，我们需要从`math`模块中导入*e*以进行连续复利：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a `pert` function that will plug in the initial amount or population,
    the growth rate, and the time, and return the final amount:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`pert`函数，它将插入初始金额或人口、增长率和时间，并返回最终金额：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We will return to this function throughout this chapter. For now, let's answer
    some more investment questions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中多次使用这个函数。现在，让我们回答更多的投资问题。
- en: Note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2D2Q1r0.](https://packt.live/2D2Q1r0
    )
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2D2Q1r0](https://packt.live/2D2Q1r0)
- en: You can also run this example online at [https://packt.live/31G5pDQ.](https://packt.live/31G5pDQ
    )
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/31G5pDQ](https://packt.live/31G5pDQ)上在线运行此示例
- en: 'Exercise 12.04: Calculating Compound Interest – Part 3'
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.04：计算复利-第3部分
- en: 'A person borrows $5,000 at 18% annual interest compounded monthly. How much
    will the person owe after 1 year? Follow these steps to complete this exercise:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个人以每月复利的18%年利率借了$5,000。1年后这个人会欠多少钱？按照以下步骤完成这个练习：
- en: 'We can just put it into our function call:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将其放入我们的函数调用中：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For comparison, let's see what would happen if the interest was compounded continuously.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较，让我们看看如果利息是连续复利会发生什么。
- en: 'We''ll use our `pert` function to input `P = 5000`, `r = 0.18`, and `t = 1`
    as values:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用我们的`pert`函数输入`P = 5000`，`r = 0.18`和`t = 1`作为值：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The resulting amount is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 得到的金额如下：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/31ES5Qi.](https://packt.live/31ES5Qi
    )
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/31ES5Qi](https://packt.live/31ES5Qi)
- en: You can also run this example online at [https://packt.live/3f5j0s4.](https://packt.live/3f5j0s4
    )
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/3f5j0s4](https://packt.live/3f5j0s4)上在线运行此示例
- en: 'Exercise 12.05: Becoming a Millionaire'
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.05：成为百万富翁
- en: 'How long would it take to become a millionaire if you invested $1,000 at 8%
    annual interest compounded daily? What if the initial amount is $10,000? Follow
    these steps to complete this exercise:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以每日复利8%的年利率投资$1,000，要成为百万富翁需要多长时间？如果初始金额是$10,000呢？按照以下步骤完成这个练习：
- en: 'First, let''s define the `bin_search` function, as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们定义`bin_search`函数，如下所示：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s take some wild guesses and see what we would get if the $1,000 were
    invested for these numbers of years:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们猜一些野生的猜测，看看如果$1,000投资这些年，我们会得到多少：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here''s the output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After 50 years, you still would only have $54,000, not a million. But after
    100 years, you''d have almost 3 million:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 50年后，您仍然只有$54,000，而不是一百万。但是100年后，您将拥有近300万：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here''s the output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The answer must be somewhere between 50 and 100\. Looks like a job for our
    binary search:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 答案必须在50和100之间。看起来是我们二分搜索的任务：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We get this output:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This shows that after 86.36 years, we''ll have 1 million dollars. If the initial
    investment is $10,000, then update the `guess` variable in the `bin_search` function:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这表明在86.36年后，我们将拥有100万美元。如果初始投资是$10,000，那么在`bin_search`函数中更新`guess`变量：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here''s how we''ll print out the output we want:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将打印所需输出的方法：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'So, we reach 1 million dollars in somewhere between 50 and 60 years. Let''s
    change `1000` to `10000` in our binary search function and check it:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们在50到60年之间就能达到100万美元。让我们在我们的二分搜索函数中将`1000`改为`10000`并检查一下：
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We get this output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Just over 57.57 years to reach a million dollars.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 超过57.57年才能达到一百万美元。
- en: So, we've started off learning about differential equations by studying compound
    interest. An initial amount of money had a rate of interest applied to it at intervals
    of a year, a month, or a day.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们开始学习微分方程是通过研究复利来学习的。一定金额的钱每年、每月或每天都会有利息率。初始金额
- en: Note
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/31ycoPg.](https://packt.live/31ycoPg
    )
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/31ycoPg](https://packt.live/31ycoPg)
- en: You can also run this example online at [https://packt.live/2NMT9sX.](https://packt.live/2NMT9sX
    )
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2NMT9sX](https://packt.live/2NMT9sX)上在线运行此示例
- en: Now, we'll extend the same reasoning to amounts of people, animals, bacteria,
    and heat, which change constantly, or *continuously*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将同样的推理扩展到人、动物、细菌和热量的数量，这些数量不断变化，或者说是*连续*的。
- en: Population Growth
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人口增长
- en: 'Differential equations are useful for finding a formula for the population
    of people, animals, and bacteria at a certain time; for example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 微分方程对于找到特定时间的人口、动物和细菌的数量的公式非常有用；例如：
- en: '![Figure 12.7: Differential equation to calculate population at time t'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.7：计算时间t的微分方程'
- en: '](image/B15968_12_07.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_07.jpg)'
- en: 'Figure 12.7: Differential equation to calculate population at time t'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：计算时间t的微分方程
- en: 'This differential equation means the rate of change of *y* is proportional
    to *y*, or the population grows proportional to its amount. This is the definition
    of population growth rate: a fraction or percentage of the population. The solution
    is similar to our interest problems involving continuous compounding:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个微分方程意味着*y*的变化速率与*y*成比例，或者说人口的增长与其数量成比例。这就是人口增长率的定义：人口的一部分或百分比。解决方案类似于涉及连续复利的利息问题：
- en: '![Figure 12.8: Differential equation to calculate the rate of change'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.8：计算变化率的微分方程'
- en: '](image/B15968_12_08.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_08.jpg)'
- en: 'Figure 12.8: Differential equation to calculate the rate of change'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：计算变化率的微分方程
- en: 'Exercise 12.06: Calculating the Population Growth Rate – Part 1'
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.06：计算人口增长率-第1部分
- en: 'In the 1980s, the annual population growth rate in Kenya was 4%. At that rate,
    how long would it take for the population to double? Follow these steps to complete
    this exercise:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在1980年代，肯尼亚的年人口增长率为4%。以这个速度，人口翻倍需要多长时间？按照以下步骤完成这个练习：
- en: 'No matter what the starting population, we''re looking for *t*, which makes
    the factor *e*rt equal to 2\. We can use our `pert` function and our binomial
    search function, with a little tweaking:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论初始人口是多少，我们都在寻找使因子*e*rt等于2的*t*。我们可以使用我们的`pert`函数和二项式搜索函数，稍作调整：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We''re looking for the time, *t*, that will, with a growth rate of 4%, turn
    our initial population of 1 into 2\. We estimate it will be somewhere between
    1 and 100 years:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在寻找时间*t*，以4%的增长率将我们的初始人口从1增加到2。我们估计这个时间会在1到100年之间：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can check that with algebra. We take the log of both sides of the equation
    and solve *t*:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用代数来验证这一点。我们取方程两边的对数并解出*t*：
- en: '![Figure 12.9: Equation to solve for time (t)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.9：解决时间(t)的方程'
- en: '](image/B15968_12_09.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_09.jpg)'
- en: 'Figure 12.9: Equation to solve for time (t)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9：解决时间(t)的方程
- en: 'This means that in just over 17 years, the population of Kenya will have doubled.
    We can check this with our `amount` function. In 1989, the population of Kenya
    was 21,000,000:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着在17年多一点的时间内，肯尼亚的人口将翻倍。我们可以用我们的`amount`函数来验证这一点。1989年，肯尼亚的人口为2100万：
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following is the output:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Yes, using a million compoundings a year, the population grows to almost 42
    million in 17.3 years.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，每年使用一百万次复利，人口在17.3年内增长到了将近4200万。
- en: In response to this, the Kenyan government made a big push to promote *family
    planning*. Did it work?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对此的回应，肯尼亚政府大力推广*计划生育*。这有效果吗？
- en: Note
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2BxsfCT.](https://packt.live/2BxsfCT
    )
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2BxsfCT](https://packt.live/2BxsfCT)
- en: You can also run this example online at [https://packt.live/2Zuoy9c.](https://packt.live/2Zuoy9c
    )
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2Zuoy9c](https://packt.live/2Zuoy9c)上在线运行此示例
- en: 'Exercise 12.07: Calculating the Population Growth Rate – Part 2'
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.07：计算人口增长率-第2部分
- en: In 2010, the population of Kenya was 42.0 million. In 2019, it was 52.5 million.
    What is the population growth rate per year for that range?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年，肯尼亚的人口为4200万。到2019年，人口为5250万。该范围的年人口增长率是多少？
- en: Once again, we can use our binary search function to return a growth factor,
    *r*, given the initial population (in millions), the time, *t*, and the target
    population (in millions) after 9 years.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次使用二分搜索函数，返回给定初始人口（以百万计）、时间*t*和9年后的目标人口（以百万计）的增长因子*r*。
- en: 'In the `bin_search` function, change the time to `9`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在`bin_search`函数中，将时间更改为`9`：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, we''ll find the annual growth rate for those 9 years. We know it''s between
    0 and 2:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将找到这9年的年增长率。我们知道它在0到2之间：
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The value that is printed is as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 打印出的值如下：
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The family planning program must have worked! Kenya reduced its population growth
    rate to 2.5%.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 计划生育项目一定是有效的！肯尼亚将其人口增长率降低到了2.5%。
- en: Note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3eWKzDW.](https://packt.live/3eWKzDW
    )
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3eWKzDW](https://packt.live/3eWKzDW)
- en: You can also run this example online at [https://packt.live/31EKPUq.](https://packt.live/31EKPUq
    )
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/31EKPUq](https://packt.live/31EKPUq)上在线运行此示例
- en: Half-Life of Radioactive Materials
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 放射性材料的半衰期
- en: Much like population problems, half-life problems concern a population, but
    one of atoms of radioactive materials where half the atoms change over time into
    atoms of a different substance. For example, Carbon-14 decays into Nitrogen-14,
    and it takes about 5,730 years for half the carbon to decay. This makes *radiocarbon
    dating* a crucial tool in everything from archaeology to detecting forged artworks.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与人口问题类似，半衰期问题涉及一个群体，但其中一半是放射性材料的原子，其中一半的原子随着时间变成了不同物质的原子。例如，碳-14衰变成氮-14，大约需要5730年才能使一半的碳衰变。这使得*放射性碳测年*成为从考古学到检测伪造艺术品的关键工具。
- en: 'Exercise 12.08: Measuring Radioactive Decay'
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.08：测量放射性衰变
- en: Radium-226 has a half-life of 1,600 years. How much of the radium in a given
    sample will disappear in 800 years?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 镭-226的半衰期为1600年。在给定样本中，800年内将消失多少镭？
- en: 'The differential equation meaning "*the rate of decay of a substance is proportional
    to the amount of the substance*" is expressed like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 意思是“物质的衰变速率与物质的数量成比例”的微分方程表达如下：
- en: '![Figure 12.10: Differential equation for calculating rate of decay of a substance'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.10：用于计算物质衰变速率的微分方程'
- en: '](image/B15968_12_10.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_10.jpg)'
- en: 'Figure 12.10: Differential equation for calculating rate of decay of a substance'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10：用于计算物质衰变速率的微分方程
- en: 'The solution is similar to that for our population problems, except that the
    decay factor is negative, since the amount decreases:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案与我们的人口问题类似，只是衰减因子是负的，因为数量减少：
- en: '![Figure 12.11: Calculating rate of change with negative decay factor'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.11：使用负衰变因子计算变化率'
- en: '](image/B15968_12_11.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_11.jpg)'
- en: 'Figure 12.11: Calculating rate of change with negative decay factor'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11：使用负衰变因子计算变化率
- en: 'This means the final amount is equal to the initial amount of time, *e*, to
    the product of a decay factor, *r*, and time, *t*. We can use our binary search
    function as if this were a population problem. We''re looking for the growth rate,
    *r*, that cuts our population in half in 1,600 years. Follow these steps to complete
    this exercise:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着最终金额等于时间的初始金额，*e*，乘以衰减因子，*r*，和时间，*t*的乘积。我们可以像解决人口问题一样使用我们的二分搜索函数。我们正在寻找在1,600年内使我们的人口减半的增长率*r*。按照以下步骤完成这个练习：
- en: 'Change *t* in the `guess =` line in the `bin_search` function to `1600`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bin_search`函数中的`guess =`行中将`t`更改为`1600`：
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, search for the growth factor, which we figure is going to be between
    -2 and 0\. Our target amount is ½ of the starting amount:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，搜索增长因子，我们认为它将在-2和0之间。我们的目标金额是起始金额的一半：
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following is the output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'That''s the decay factor, *r*, for Radium-226\. All we have to do to find out
    the percentage of the sample left after 800 years is plug that into our `pert`
    function:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是镭-226的衰变因子*r*。我们要做的就是将其插入我们的`pert`函数中，以找出800年后剩下的样本的百分比：
- en: '[PRE51]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The following is the output:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE52]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: So, around 71% of the sample remains after 800 years.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，大约71%的样本在800年后仍然存在。
- en: Note
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2YSzQ84.](https://packt.live/2YSzQ84
    )
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2YSzQ84](https://packt.live/2YSzQ84)
- en: You can also run this example online at [https://packt.live/2ByUwJj.](https://packt.live/2ByUwJj
    )
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2ByUwJj](https://packt.live/2ByUwJj)上在线运行此示例
- en: 'Exercise 12.09: Measuring the Age of a Historical Artifact'
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.09：测量历史文物的年龄
- en: A sample of cloth is radiocarbon-tested for age. This means the scientists measure
    how much Carbon-14 (half-life 5,730 years) has decayed into a more stable isotope.
    They find the amount of Carbon-14 remaining is 10 times that of Carbon-13\. How
    old is the cloth?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对一块布进行了放射性碳测年。这意味着科学家们测量了有多少碳-14（半衰期5730年）衰变成了更稳定的同位素。他们发现剩下的碳-14的数量是碳-13的10倍。这块布有多大年龄？
- en: 'If Carbon-14 takes 5,730 years for half its amount to decay, we need to find
    the rate, *r*, for our Pert formula:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果碳-14需要5730年使其数量减半，我们需要找到我们的Pert公式的速率*r*：
- en: '![Figure 12.12: The Pert formula'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.12：Pert公式'
- en: '](image/B15968_12_12.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_12.jpg)'
- en: 'Figure 12.12: The Pert formula'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12：Pert公式
- en: 'Follow these steps to complete this exercise:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个练习：
- en: 'We use our binary search function to solve *r*:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用我们的二分搜索函数来解决*r*：
- en: '[PRE53]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This is the line that''s changed. We put a beginning amount of `1` into the
    `pert` function, *r* will be `avg`, and `5730` will be the target time:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是更改的那一行。如果我们在`pert`函数中放入一个起始金额为`1`，*r*将是`avg`，`5730`将是目标时间：
- en: '[PRE54]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following is the output:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE55]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '*r = -0.000120968*, so our Pert formula becomes as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*r = -0.000120968*，因此我们的Pert公式变为如下：'
- en: '![Figure 12.13: Substituting the new value of r in the Pert formula'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.13：在Pert公式中替换r的新值'
- en: '](image/B15968_12_13.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_13.jpg)'
- en: 'Figure 12.13: Substituting the new value of r in the Pert formula'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13：在Pert公式中替换r的新值
- en: 'This means *x* grams of Carbon-14 decayed, and 10x grams, 10 times as much,
    remains. So, the decayed amount is 1/11th or 0.091 of the whole sample. The ending
    amount is 1 – 0.091\. That makes our Pert equation as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着*x*克的碳-14衰变了，剩下的是10x克，是整个样本的10倍。因此，衰变量是整个样本的1/11或0.091。结束金额是1-0.091。这使我们的Pert方程如下：
- en: '![Figure 12.14: Pert equation with ending amount'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.14：带有结束金额的Pert方程'
- en: '](image/B15968_12_14.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_14.jpg)'
- en: 'Figure 12.14: Pert equation with ending amount'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14：带有结束金额的Pert方程
- en: 'The only unknown in our equation is *t*, so we''re changing our `bin_search`
    function to guess and check strategically for the correct *t*. Go back to your
    `bin_search` function; the beginning should look like this:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们方程中唯一未知的是*t*，因此我们正在更改我们的`bin_search`函数，以便有策略地猜测和检查正确的*t*。返回到您的`bin_search`函数；开头应该是这样的：
- en: '[PRE56]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here''s the line we''re changing. We''re plugging in 1 for the original amount,
    the long decimal is our *r*, and the average of our time range is used for the
    time. The target is 0.091 of the sample, and this will keep guessing and averaging
    until it returns the exact number of years to get to the target:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们正在更改的行。我们将1代入原始量，长小数是我们的*r*，时间范围的平均值用于时间。目标是样本的0.091，这将保持猜测和平均值，直到返回确切的年数以达到目标值：
- en: '[PRE57]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Since it''s a decreasing function, if the guess is less than the target, we''ll
    have overshot it and the `upper` number will be replaced by the average:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于它是一个递减函数，如果猜测小于目标值，我们将会超过目标值，`upper`数字将被替换为平均值：
- en: '[PRE58]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Notice we changed the `if guess < target:` line. We''re looking for the number
    of years it''ll take the amount to decay from 1 to 0.91 at the given rate. We
    suspect it''s somewhere between 1 and 100,000 years. The second `print` line is
    just a check that our `pert` function confirms that after 5,730 years, the amount
    left is exactly half the original amount. Here''s the output when we run our code:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，我们更改了`if guess < target:`行。我们正在寻找从1到0.91的衰减量所需的年数，以给定的速率。我们怀疑它在1到100,000年之间。第二个`print`行只是检查我们的`pert`函数确认在5,730年后，剩余量正好是原始量的一半。当我们运行代码时，这是输出：
- en: '[PRE59]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: According to our calculations, the cloth is around **780 years** old.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的计算，这块布大约有**780年**的历史。
- en: So, we originally wrote this code to measure the amount of money left in an
    investment that grew at a given rate for a certain time. In this section, we applied
    this to the amount of radioactive material left in an object after decaying at
    a known rate for an unknown amount of time. This is how scientists calculate the
    age of archaeological artifacts.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们最初编写此代码是为了测量投资中剩余的金额，该投资以给定的利率增长一段时间。在本节中，我们将此应用于物体中放射性物质的剩余量，该物质以已知速率衰变，时间未知。这就是科学家计算考古文物年龄的方法。
- en: Note
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3eOJJJv.](https://packt.live/3eOJJJv
    )
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3eOJJJv](https://packt.live/3eOJJJv)。
- en: You can also run this example online at [https://packt.live/38mESgn.](https://packt.live/38mESgn
    )
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/38mESgn](https://packt.live/38mESgn)上在线运行此示例。
- en: Next, we'll use the same idea but apply it to the change in the temperature
    of objects such as a cup of coffee or a human body.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用相同的思路，但将其应用于物体的温度变化，比如一杯咖啡或人体的温度。
- en: Newton's Law of Cooling
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 牛顿冷却定律
- en: 'Did you ever wonder how the **Crime Scene Investigator** (**CSI**) with the
    latex gloves on police shows can tell the time of death of the victim? Isaac Newton
    is credited with figuring out that the cooling of substances follows a differential
    equation:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经想过在警察节目中带着乳胶手套的**犯罪现场调查员**（**CSI**）如何判断受害者的死亡时间？艾萨克·牛顿被认为是发现物质冷却遵循微分方程的人：
- en: '![Figure 12.15: Differential equation for rate of change of temperature'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.15：温度变化速率的微分方程'
- en: '](image/B15968_12_15.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_15.jpg)'
- en: 'Figure 12.15: Differential equation for rate of change of temperature'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15：温度变化速率的微分方程
- en: 'See how this differential equation is slightly different than the ones we''ve
    seen before? Instead of the rate of change of the temperature of the substance
    being proportional to the temperature of the substance, this says *"the rate of
    change of the temperature of a substance is proportional to the difference between
    the temperature of the substance and the temperature of the environment."* So,
    if a cup of hot coffee is left in a hot room, its temperature is going to change
    less quickly than if it''s left in a very cold room. Similarly, we know the starting
    temperature of the body of the victim on the police show: 98.6° F.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个微分方程与我们以前看到的微分方程略有不同？这不是物质温度变化速率与物质温度成比例，而是说“物质温度变化速率与物质温度与环境温度之间的差值成比例”。因此，如果一杯热咖啡放在热的房间里，它的温度变化速度会比放在非常冷的房间里慢。同样，我们知道警察节目中受害者的体温起始温度：98.6°F。
- en: 'Exercise 12.10: Calculating the Time of Death'
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.10：计算死亡时间
- en: An investigator arrives at the scene of the crime and measures the temperature
    of the environment and the body. If the environment is 65° and the body is 80°,
    the investigator notes the time and waits an hour. The difference between the
    temperatures of the body and the environment is 15\. An hour later, the environment
    is still 65° and the body has further cooled to 75°. The difference in temperatures
    is now 10°. When did the victim die?
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一名调查员到达犯罪现场并测量环境和尸体的温度。如果环境温度为65°，尸体温度为80°，调查员记录时间并等待一小时。尸体温度与环境温度的差为15度。一个小时后，环境温度仍为65°，尸体进一步冷却至75°。温度差现在为10度。受害者是何时死亡的？
- en: 'With this information, she can set up the following equation:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，她可以建立以下方程：
- en: '![Figure 12.16: Equation for calculating the time of death'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.16：计算死亡时间的方程'
- en: '](image/B15968_12_16.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_16.jpg)'
- en: 'Figure 12.16: Equation for calculating the time of death'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16：计算死亡时间的方程
- en: 'Follow these steps to complete this exercise:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个练习：
- en: 'We can use our binary search to find out what the decay rate for the temperature
    is. We''ll need to import `e` and make sure we have our `pert` and `average` functions:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用二分搜索来找出温度的衰减率。我们需要导入`e`并确保我们有`pert`和`average`函数：
- en: '[PRE60]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The first part of our `bin_search` function is the same as before:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`bin_search`函数的第一部分与以前相同：
- en: '[PRE61]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here''s the important change: our original amount (the temperature difference)
    is 15 degrees, and we want to know *r*, the rate of change in our Pert formula:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里的重要变化是：我们的原始量（温度差）为15度，我们想知道*r*，即我们Pert公式中的变化率：
- en: '[PRE62]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here''s the output:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'That''s the rate of decay for this situation, so we know the beginning difference
    between the temperature of the body and the environment (98.6 – 65), as well as
    the final difference (10) and the rate of decay. Here''s a graph of the situation:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这种情况的衰减速率，所以我们知道了尸体温度与环境温度之间的初始差异（98.6-65），以及最终差异（10）和衰减速率。这是情况的图表：
- en: '![Figure 12.17: A graph of the cooling body'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.17：冷却体的图表'
- en: '](image/B15968_12_17.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_17.jpg)'
- en: 'Figure 12.17: A graph of the cooling body'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17：冷却体的图表
- en: 'All we need to know is the number of hours it took for that difference to decay
    to 10\. Our equation is as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要知道差异衰减到10所需的小时数。我们的方程如下：
- en: '![Figure 12.18: Number of hours taken for the difference to decay to 10'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.18：差异衰减到10所需的小时数'
- en: '](image/B15968_12_18.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_18.jpg)'
- en: 'Figure 12.18: Number of hours taken for the difference to decay to 10'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.18：差异衰减到10所需的小时数
- en: 'We change our binary search function to get the time:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们改变我们的二分搜索函数来获取时间：
- en: '[PRE64]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: But if the time is too low, the difference will be too high. The easiest way
    to get around this is to make the higher *t* the *lower* part of the function
    call and the lower *t* the *upper* end of the range to search.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果时间太短，差异将太大。绕过这个最简单的方法是将更高的*t*作为函数调用的*较低*部分，将较低的*t*作为搜索范围的*上限*。
- en: 'The investigator figures the time has to be between 0 and 5 hours:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调查员推断时间必须在0到5小时之间：
- en: '[PRE65]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The output will be as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下：
- en: '[PRE66]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Almost exactly 3 hours. That looks close to the time when the *y*-value of the
    curve in the preceding graph is 10.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎正好3小时。这看起来接近前图中曲线的*y*值为10的时间。
- en: 'Let''s check that in our `pert` function. Start at a difference of 33.6 degrees
    with *r = -0.4055* and *t = 3.0*. Hopefully, we end up with 10:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在我们的`pert`函数中检查一下。从*r = -0.4055*和*t = 3.0*开始，差异为33.6度。希望最终得到10：
- en: '[PRE67]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The following is the output:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE68]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: So, now, when the star detective arrives on the scene at 2:30 a.m., the investigator
    can say, "The time of death was around 11:30 pm."
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在，当明星侦探在凌晨2:30到达现场时，调查员可以说，“死亡时间大约是晚上11:30。”
- en: Note
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/38jN68K.](https://packt.live/38jN68K
    )
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/38jN68K.](https://packt.live/38jN68K )
- en: You can also run this example online at [https://packt.live/3gefegi.](https://packt.live/3gefegi
    )
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/3gefegi.](https://packt.live/3gefegi )上在线运行此示例
- en: 'Exercise 12.11: Calculating the Rate of Change in Temperature'
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.11：计算温度变化的速率
- en: 'A cup of coffee at a perfect temperature of 175° F is left in a 72° room. We
    wait 15 minutes and measure the temperature of the coffee to find it has changed
    to 140°. At this rate, what will its temperature be 1 hour from the start? Follow
    these steps to complete this exercise:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 一杯温度为175°F的咖啡放在一个72°F的房间里。我们等待15分钟，测量咖啡的温度，发现它已经变成了140°F。按照这个速度，从开始算起1小时后它的温度会是多少？按照以下步骤完成这个练习：
- en: 'The difference starts at 103° (175-72). In 0.25 hours, it''s changed to 68°
    (140-72). Now, we can set up an equation:![Figure 12.19: Equation for calculating
    difference in the coffee''s temperature'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 差异从103°（175-72）开始。在0.25小时内，它变为68°（140-72）。现在，我们可以建立一个方程：![图12.19：计算咖啡温度差异的方程
- en: '](image/B15968_12_19.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_19.jpg)'
- en: 'Figure 12.19: Equation for calculating difference in the coffee''s temperature'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.19：计算咖啡温度差异的方程
- en: 'We can change our binary search function to reflect this situation. Change
    the `guess=` line in the `bin_search` function to this:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以改变我们的二分搜索函数以反映这种情况。将`guess=`行更改为`bin_search`函数中的以下内容：
- en: '[PRE69]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Run it to find what *r* between -2 and 0 will give us a difference of 68°:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行它，找出在-2和0之间的*r*将给我们带来68°的差异：
- en: '[PRE70]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here''s the output:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE71]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'That''s fast! Put that into our Pert formula with *P = 103* and *t=1*:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太快了！将其放入我们的Pert公式中，*P = 103*和*t=1*：
- en: '[PRE72]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The following is the output:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE73]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: That's the difference in 1 hour. If the room is 72°, that means the coffee will
    be *72 + 19.5 = 91.5°*.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这是1小时的差异。如果房间温度为72°，那意味着咖啡将是*72 + 19.5 = 91.5°*。
- en: Note
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3gl5p0i.](https://packt.live/3gl5p0i
    )
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 访问此特定部分的源代码，请参阅[https://packt.live/3gl5p0i.](https://packt.live/3gl5p0i )
- en: You can also run this example online at [https://packt.live/2YTdCmw.](https://packt.live/2YTdCmw
    )
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2YTdCmw.](https://packt.live/2YTdCmw )上在线运行此示例
- en: Mixture Problems
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合问题
- en: 'In algebra, there are word problems where you have to figure out how much material
    you have to add to a mixture to get a certain concentration or amount. In calculus,
    naturally, the problem has to be harder: for example, the mixture is changing;
    material is going into the mixture, and material is going out. You have to find
    out how much mixture or how much of the solvent is present after a specific amount
    of time. Let''s look at the following exercise to better understand this concept.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在代数中，有一些需要计算的文字问题，您必须计算出需要添加多少材料到混合物中才能获得特定的浓度或数量。在微积分中，自然，问题必须更难：例如，混合物正在改变；材料正在进入混合物，材料正在流出。您必须找出在特定时间后有多少混合物或溶剂。让我们看看以下练习，以更好地理解这个概念。
- en: 'Exercise 12.12: Solving Mixture Problems – Part 1'
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.12：解决混合问题-第1部分
- en: A tank contains 82 gallons of brine in which 18 pounds of salt is dissolved.
    Brine containing 3 pounds of dissolved salt per gallon flows into the tank at
    the rate of 5 gallons per minute. The mixture, which is kept uniform by stirring,
    flows out of the tank at a rate of 2 gallons per minute. How much salt is in the
    tank at the end of 39 minutes?
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 一个罐子里含有82加仑的卤水，其中溶解了18磅的盐。每分钟以5加仑的速度流入罐子的卤水中含有每加仑3磅的溶解盐。这种混合物通过搅拌保持均匀，以每分钟2加仑的速度流出罐子。39分钟后罐子里有多少盐？
- en: 'As you can imagine, this kind of problem leads to some complicated differential
    equations, and only after pages of algebra do you get an equation (usually involving
    *e* to some power) into which you can plug the time and get your final amount.
    However, using programming, we can simply start with our given starting solution
    and add and subtract whatever material the problem calls for. It''s a matter of
    keeping track of solution and solute. Follow these steps to complete this exercise:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以想象的，这种问题会导致一些复杂的微分方程，只有经过几页的代数运算，你才能得到一个方程（通常涉及到* e*的某个幂），然后你可以将时间代入并得到最终的数量。然而，使用编程，我们只需从给定的起始溶液开始，并添加和减去问题所需的任何材料。这只是一个跟踪溶液和溶质的问题。按照以下步骤完成这个练习：
- en: 'Let''s create a function to find the salt content after `t` minutes, given
    our initial conditions:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个函数，以找出在`t`分钟后的盐含量，给定我们的初始条件：
- en: '[PRE74]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then, every minute, 5 more gallons of brine is being added, containing 15 pounds
    (5 gallons at 3 pounds of salt *per gallon*) of salt:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，每分钟都会添加5加仑的卤水，其中含有15磅（每加仑3磅盐*每加仑*）的盐：
- en: '[PRE75]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, 2 gallons of the brine flows out every minute, but how much salt is in
    it? That requires us to find the concentration of each gallon of brine:![Figure
    12.20: Formula to calculate the concentration of each gallon of brine'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，每分钟流出2加仑的卤水，但其中含有多少盐呢？这要求我们找出每加仑卤水的浓度：![图12.20：计算每加仑卤水浓度的公式
- en: '](image/B15968_12_20.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_20.jpg)'
- en: 'Figure 12.20: Formula to calculate the concentration of each gallon of brine'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20：计算每加仑卤水浓度的公式
- en: 'This can be easily converted into code, as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以很容易地转换为代码，如下所示：
- en: '[PRE76]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'So, the salt leaving the tank every minute will be the number of gallons of
    solution flowing out, times the concentration of salt:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，每分钟离开罐子的盐将是流出的溶液加仑数乘以盐的浓度：
- en: '[PRE77]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'After the loop finishes, we can print out the final amounts of brine and the
    salt:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环结束后，我们可以打印出卤水和盐的最终数量：
- en: '[PRE78]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'To solve our problem, we simply run our `salt_content` function with *t=39*:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决我们的问题，我们只需运行我们的`salt_content`函数，*t=39*：
- en: '[PRE79]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The output is as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE80]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: That means we end up with 469 pounds of salt after 39 minutes. That number is
    very close to the analytical solution, but it's not exact. What could we do to
    get more accurate results? Remember, the idea behind *e*, the base of natural
    logarithms, is that it simulates constant change in a value, and we're only calculating
    our changes in our solution once every minute.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在39分钟后，我们最终得到469磅盐。这个数字非常接近解析解，但并不完全相同。我们该怎么做才能得到更准确的结果呢？记住，自然对数的底数*e*的背后思想是模拟值的恒定变化，而我们只是每分钟计算一次我们溶液的变化。
- en: 'Let''s introduce a variable, `frac`, that will let us calculate our changes
    in fractions of a minute:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们引入一个名为`frac`的变量，它将让我们计算分钟的变化：
- en: '[PRE81]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The `frac=0.001` value in the parameters means we''ll calculate the changes
    a thousand times per minute. That means we''ll multiply the times we loop by 1,000,
    or 1/`frac`, and we''ll multiply the change in our amounts by `frac`:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参数中的`frac=0.001`值表示我们将每分钟计算一千次变化。这意味着我们将循环的次数乘以1,000，或者1/`frac`，我们将我们的数量变化乘以`frac`：
- en: '[PRE82]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The output changes to the following:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 输出变成了以下内容：
- en: '[PRE83]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 470.7 pounds of salt is even closer to the analytical solution, and using smaller
    fractions of a minute doesn't change the output much.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 470.7磅盐甚至更接近解析解，使用更小的分钟分数并不会改变输出太多。
- en: Note
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2BlX2Tn.](https://packt.live/2BlX2Tn
    )
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2BlX2Tn](https://packt.live/2BlX2Tn)。
- en: You can also run this example online at [https://packt.live/3dSrEcm.](https://packt.live/3dSrEcm
    )
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/3dSrEcm](https://packt.live/3dSrEcm)上在线运行此示例。
- en: Let's use this function on other problems.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在其他问题上使用这个函数。
- en: 'Exercise 12.13: Solving Mixture Problems – Part 2'
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.13：解决混合问题-第2部分
- en: 'A tank contains a solution of 10,000 L of brine with a concentration of 1 kg
    of salt per 100 L. Brine with 2 kg of salt per 100 L flows into the tank at a
    rate of 20 L per second. The (uniform) mixture leaves at a rate of 10 L per second.
    Find out how much salt is in the tank in 5 minutes. Follow these steps to complete
    this exercise:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 一个罐子里含有10,000升浓度为每100升1千克盐的卤水溶液。每秒以20升的速度流入罐中含有每100升2千克盐的卤水。混合物（均匀）以每秒10升的速度流出。找出在5分钟内罐中有多少盐。按照以下步骤完成这个练习：
- en: 'So, we need to do a little arithmetic to find out our initial amount of salt,
    but 1 kg of salt per 100 L is 100 kg of salt in 10,000 L, and it''s 0.4 kg of
    salt in 20 L, which is flowing into the tank. Here''s our new function:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们需要进行一些简单的算术运算来找出我们的初始盐量，但是每100升1千克盐是10,000升中的100千克盐，而流入罐中的20升中是0.4千克盐。这是我们的新函数：
- en: '[PRE84]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, let''s call the `salt_content` function:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们调用`salt_content`函数：
- en: '[PRE85]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The output when we call the function is as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用函数时，输出如下：
- en: '[PRE86]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: (Remember, our numbers are all in seconds, and we want 5 minutes, hence the
    `5*60` parameter.)
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: （记住，我们所有的数字都是以秒为单位的，我们想要5分钟，因此是`5*60`参数。）
- en: The output tells us there's 183 kg of salt in the solution in 5 minutes. This
    is very close to the analytical solution.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 输出告诉我们，在5分钟内溶液中有183千克盐。这非常接近解析解。
- en: 'We can simplify our task by changing the hardcoded numbers to variables, so
    when we have a problem with a different initial amount of brine, for example,
    we can just enter a different number into the function call. We''ll need variables
    for the initial amount of brine (or any solution), the initial amount of solute
    (so far, we''ve been using salt), the velocity of brine in, the velocity of salt
    in, and the velocity of brine out. Here''s how to change the function:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过将硬编码的数字更改为变量来简化我们的任务，因此当我们遇到不同初始卤水量的问题时，例如，我们只需在函数调用中输入不同的数字。我们需要变量来表示初始卤水量（或任何溶液）、溶质的初始量（到目前为止，我们一直在使用盐）、卤水的流入速度、盐的流入速度和卤水的流出速度。以下是如何更改函数的方法：
- en: '[PRE87]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now, to solve the last problem, our function call would have more arguments:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The output is as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: As you can see, the output should be the same as in *step 1*. Let's apply this
    to more problems.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3gkTWOd.](https://packt.live/3gkTWOd
    )
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3eSWF17.](https://packt.live/3eSWF17
    )
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.14: Solving Mixture Problems – Part 3'
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A vat contains 100 L of a sugar-water mixture with 900 g of sugar. A sugar-water
    mixture containing 5 g of sugar per L enters the vat at a rate of 2 L per minute.
    Another mixture containing 10 g of sugar per L flows into the vat at a rate of
    1 L per minute. The vat is kept mixed, and the resulting mixture is drained from
    the vat at 3 L per minute. Find the amount of sugar in the vat in 1 hour. Follow
    these steps to complete this exercise:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'The only trick here is that the total solution entering is 3 L per minute,
    and the total solute entering is 20 g per minute. Here''s the function call:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The output will be as follows:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The amount of solute is 705 g.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2YRWNIl.](https://packt.live/2YRWNIl
    )
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2YRWKfD.](https://packt.live/2YRWKfD
    )
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.15: Solving Mixture Problems – Part 4'
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if we added pure water? Would that make it harder or easier? Let's try
    this one.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'A tank contains 1,200 L of a brine mixture of water and 18 g of salt. Fresh
    water enters the tank at a rate of 15 L per minute and the tank is mixed to remain
    uniform. A pipe drains the mixture at a rate of 10 L per minute. How much salt
    is in the tank after 15 minutes? Follow these steps to complete this exercise:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use our `salt_content` function, but the `salt in` variable will be
    set to `0`. This makes the following function call:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The output for the salt content after 15 minutes is as follows:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The salt content has decreased from 18 g to 15.9 g.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2ZsLTIs.](https://packt.live/2ZsLTIs
    )
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2AnLrT8.](https://packt.live/2AnLrT8
    )
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: So, we've seen several topics from differential equations that normally require
    a lot of algebraic manipulation to find an equation for the situation so that
    (presumably) we can plug in a variable and get the temperature, position, or amount
    we're looking for. Modeling using Python and running simulations as we have has
    saved us a lot of algebra and still got us very accurate answers.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Euler's Method
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In undergraduate math classes, you''re taught all these algebraic methods for
    taking derivatives and integrals and solving differential equations. We didn''t
    mention Laplace transforms, which are even more complicated ways of solving differential
    equations algebraically. Now, for the dirty secret about differential equations
    they don''t tell you in school, unless you major in engineering: most differential
    equations you come across in real life have *no analytical solution*.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: The good news is there have been numerical methods for avoiding messy algebra
    for hundreds of years, and with the invention of computers, these methods have
    become standard. Even when there is an analytical solution, numerical methods
    can be almost as accurate for practical purposes as the analytical method and
    take a fraction of the time to get a solution.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea of Euler''s method is very simple:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Start at the known point.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the derivative at this point using the differential equation. This
    is the direction the curve is taking at this point.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move a tiny step in the direction you calculated.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat until you get to the end of the desired range.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Exercise 12.16: Solving Differential Equations with Euler''s Method'
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You''re given the differential equation ![2](image/B15968_12_InlineEquation4.png).
    You want to know the output of the function *y = f(x)* at a specific value of
    *x*. You''re given one point on the graph: *f(0) = 1*. This means, *"the derivative
    of this function at every point is the y-value of the function at that point."*
    Remember, the derivative is the slope or the direction that point on the graph
    is heading. Euler''s method is to start at the initial value, in this case, at
    (0,1), and calculate the direction to the next point using the differential equation.
    The **Differential Equations** (**DE**) states the slope is the *y*-value, so
    we take a small step in the positive *x*-direction:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.21: Taking a small step (hopefully) in the right direction'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_21.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.21: Taking a small step (hopefully) in the right direction'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'The derivative is as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.22: Derivative of the function'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_22.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.22: Derivative of the function'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 'So, *ΔY* becomes the following:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.23: Formula to calculate ΔY'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_23.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.23: Formula to calculate ΔY'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s the product of the derivative and the stepsize. To find the next *y*-value,
    we add *ΔY* to the previous *y*-value. At the new point, we repeat this process:
    calculate the slope of the function at this point, multiply by the stepsize, and
    add that to the present *y*-value. Follow these steps:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a Python function to do that:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'So, we know the initial `x` and `y`. We want to know `y` when `x=2`; the stepsize
    can be ½:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The following is the output:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We no longer need the `print` statement inside the `euler` function, so comment
    it out:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The first line is the result of calculating the slope, which is simply the
    *y*-value, 1, multiplying that by the stepsize, ½, and moving up that distance.
    If the derivative had been negative, we''d have moved down. On the second line,
    we multiplied the *y*-value, 1.5, by the stepsize, 0.5, and got 0.75\. We moved
    up from 0.75 to 2.25 and so on. Taking small steps in the x-direction until we
    got to our target x-value, 2, we ended up at a *y*-value of 5.0625\. We no longer
    need to print out each step, but let''s cut the stepsize in half 10 times:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The following is the output:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'So, the smaller the stepsize, the closer we seem to be getting to 7.37\. Here''s
    a graph of the paths of the approximations:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.24: Better approximations with a smaller stepsize'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_24.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.24: Better approximations with a smaller stepsize'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: The fourth curve (the curve to the right) is the path of our approximations
    with stepsize 1\. The third graph has stepsize ½, the second curve ¼, and the
    first curve 1/8\. We choose the ![a](image/B15968_12_InlineEquation2.png) differential
    equation because we know the algebraic solution.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: 'When *x* is 2, *e*2 *= 7.389*. Adding the actual curve of *y=e*x (the first
    curve on the left), we can see that the smaller the stepsize, the closer the approximations
    get to the actual curve:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.25: The actual curve added to the left side of the first curve'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_25.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.25: The actual curve added to the left side of the first curve'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: But the last approximation, with stepsize 0.001953125, took 1,024 steps between
    0 and 2\. It's easy to see why Euler's method wasn't preferred to algebraic methods
    before the invention of the computer.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2VEQiaa.](https://packt.live/2VEQiaa
    )
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2ByZvtv.](https://packt.live/2ByZvtv
    )
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.17: Using Euler''s Method to Evaluate a Function'
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use Euler''s method and stepsize 0.001 on the **initial value problem** (**IVP**):'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.26: Euler''s method on initial VP'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_26.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.26: Euler''s method on initial VP'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, *y(0) = 1* in order to calculate the approximate solution *y(x)* for
    when *x = 0.3*:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `euler` function, enter the differential equation in the `slope=` line:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Enter the proper parameters in the function call:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The output should be as follows:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This means that by taking tiny steps from our known point (0,1) going in the
    direction specified by the differential equation, we were able to predict that
    1.49 is the approximate *y*-value corresponding to the x-value 0.3.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3inHj6S.](https://packt.live/3inHj6S
    )
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2VFLEbF.](https://packt.live/2VFLEbF
    )
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: Runge-Kutta Method
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Euler's method is based only on the derivative at each point, it has the
    problem of always overshooting or undershooting the true curve. Not surprisingly,
    in the centuries since Euler's method was invented, improvements have been made
    to offset its drawbacks. One such improvement is the **Runge-Kutta** (**RK**)
    method, which averages together four approximations, one of which is Euler's method,
    using the beginning of the interval, another using the end of the interval, and
    two other approximations using the midpoint of the interval. When averaged together,
    the approximations at the midpoint are given a higher weight.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the equations when the DE is given, *f(x,y)*, the starting *x* and
    *y*, *x*0 and *y*0, and the step size, *h*:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.27: Equations when f(x,y) is given'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_27.jpg)'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.27: Equations when f(x,y) is given'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: 'For the next *y*, we average together the four preceding approximations, with
    double the weight on *k*2 and *k*3:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.28: Formula for averaging the 4 preceding approximations'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_28.jpg)'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.28: Formula for averaging the 4 preceding approximations'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, of course, *x* is incremented by *h*:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.29: Incrementing x by h'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_29.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.29: Incrementing x by h'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: This is a lot to code, but its power is impressive.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.18: Implementing the Runge-Kutta Method'
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the Runge-Kutta method and stepsize 0.2 on the IVP:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.30: Runge Kutta method with stepsize 0.2'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_30.jpg)'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.30: Runge Kutta method with stepsize 0.2'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the differential equation. Let''s call it `deriv(x,y)`:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Now, we''ll define the Runge-Kutta method, calling it `rk4`:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'When we start at *y(0) = 0* and we want *y(1)* using a stepsize of 0.2, here''s
    what we call:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Our progress is printed out as follows:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The same problem using the same stepsize, but using Euler''s method, is less
    accurate. In the `euler` function, change the `slope=` line to match the new differential
    equation:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Now, we print out the solution using Euler''s method:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The following is the output:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'This isn''t very close to the Runge-Kutta solution. However, the Runge-Kutta
    improvement may have been more useful before computers, because we can simply
    decrease the step size in Euler''s method and get a much better approximation.
    This is the same output for Euler''s method with a stepsize of 0.001:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The following is the output:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: This has been a brief look at the *numerical methods* used to solve equations,
    not by doing algebra but by feeding the starting point into a computer program
    and taking small steps in the direction indicated by the differential equations.
    This is an enormous field of calculus, especially now that free software and programming
    languages, coupled with fast computer processors, make easy work of previously
    laborious calculations.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3eWxF95.](https://packt.live/3eWxF95
    )
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3dUlkkg.](https://packt.live/3dUlkkg
    )
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: Pursuit Curves
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A big topic in calculus is the pursuit curve, which is the path traced by an
    agent pursuing a moving target. Since the pursuer moves directly toward its target,
    and then the target moves, this situation leads to all kinds of differential equations.
    The algebra can get very ugly, and that's why calculus professors love the topic.
    However, as we know, differential equations are usually about finding a general
    algebraic solution, that is, a function, not a number. In theory, we then plug
    values into the function to find the location of a particle or the temperature
    of a room at a specific time. Using Python, we skip the algebraic step by modeling
    the situation and finding a numerical solution. What we lose in generality, we
    gain in ease of computation.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.19: Finding Where the Predator Catches the Prey'
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A rabbit starts at (0,0) and runs in the positive *y*-direction at 1 unit per
    second. A fox starts at (20,0) and pursues the rabbit, running 1.5 times as fast
    as the rabbit. At what *y*-value does the fox catch the rabbit?
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll need some functions from the `math` module to measure distance
    and angles:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'We''ll write a function to measure the distance between the predator''s position
    and the prey''s position using the Pythagorean Theorem:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The key is that the change in *y* over the change in *x* between the locations
    of the prey and the predator represents the tangent of the angle we want. We know
    their locations, so we use the inverse tangent function, called `atan2`, to calculate
    the angle so that the predator points directly at the prey. All we really want
    is to know how much to change the predator''s *x*- and *y*-coordinates for them
    to move 1 unit toward the prey. To turn the predator toward the prey, we need
    to find the angle between the two points, as shown in the following diagram:![Figure
    12.31: The angle between predator and prey'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_12_31.jpg)'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.31: The angle between predator and prey'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we know the change, we can multiply the vector by whatever velocity we
    want:'
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: We calculate the change in `x` and `y`, calculate the angle using the `arctangent`
    function, and then we use cosine and sine to find the corresponding changes in
    the predator's *x*- and *y*-coordinates so that it walks one unit toward the prey.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the chase can begin. We start the predator and prey at their stated locations.
    Then, we start a loop where we move the prey one unit (or an increment of that
    for more accuracy):'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Now, we run the chase and print out the *y*-value where the predator catches
    the prey:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The output is as follows:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: This is extremely close to the theoretical value of 24.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3f6x44Z.](https://packt.live/3f6x44Z
    )
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2NO1A7v.](https://packt.live/2NO1A7v
    )
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.20: Using Turtles to Visualize Pursuit Curves'
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll visualize the path of the predator and prey, which
    is called the *pursuit curve*. There''s a built-in module in Python, based on
    the virtual turtles of the Logo programming language, that makes it easy to create
    virtual agents that can walk around the screen according to the code we write.
    Follow these steps to complete this exercise:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the functions from the `turtle` module:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'We set up the size of the screen according to the desired lower-left point,
    which we''ll make (-30, -30), and the upper-right point, which we''ll make (40,40):'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Setting up the predator and prey means creating a `Turtle` object and setting
    its color, position, and speed. The turtle leaves paths when it walks, so we tell
    it `penup` to keep it from drawing until it gets to its starting location. Then,
    we tell it `pendown` so that it will start drawing:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'We set up the prey by making the turtle green and giving it the shape of a
    turtle:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The `pursue` function should look familiar, but it has built-in functions to
    calculate the distance and even for pointing at another turtle:'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'We''ll execute the `pursue` function and then once it prints the output, we''ll
    tell it the program is done so that the graphics window doesn''t freeze:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'If you run this, you can watch the chase. Here''s what the final output should
    look like:![Figure 12.32: The path of the predator is a logarithmic curve'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_12_32.jpg)'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.32: The path of the predator is a logarithmic curve'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '**Extension**: Change the prey''s path into a circle. After the line to make
    the prey move forward, add this line:'
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'This will make the prey turn left a fraction of a degree every step. But if
    the turn is the same every time, it''ll eventually make a circle. The resulting
    path looks like this:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.33: The pursuit curve when the prey is fleeing in a circular path'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_33.jpg)'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.33: The pursuit curve when the prey is fleeing in a circular path'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3dWHDG6.](https://packt.live/3dWHDG6
    )
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: This section does not currently have an online interactive example and will
    need to be run locally.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: Position, Velocity, and Acceleration
  id: totrans-553
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Differential equations are often used to study the paths of projectiles, and
    this can be said to be the origin of calculus. Newton invented the tools of calculus
    to solve the differential equations that resulted from his study of the movements
    of the planets and showed that falling objects on Earth are subject to the same
    laws of physics as orbiting planets.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.21: Calculating the Height of a Projectile above the Ground'
  id: totrans-555
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A ball is thrown upward with an initial velocity of 29 m/s. How long before
    it hits the ground? Follow these steps to complete this exercise:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: 'In algebra class, we''re led to calculate the height of a projectile using
    an equation:![Figure 12.34: Formula to calculate the height of a projectile'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_12_34.jpg)'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.34: Formula to calculate the height of a projectile'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: Here, *h*0 is the initial height, *v*0 is the initial upward velocity, *t* is
    the number of seconds elapsed, and *g* is the acceleration due to gravity, around
    32 feet or 9.8 meters per second. But projectiles don't calculate their position
    using equations; they simply travel in the direction their derivative indicates.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s model that:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: So, for the first second, the ball will be thrown up at 29 meters per second
    but will be slowed down by gravity 9.8 meters per second, meaning after a second,
    it's only going *29 – 9.8 = 19.2* meters per second. So, after a second, the ball
    should be 19.2 meters up in the air. We repeat that every second until its height
    is 0.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the `height` function should look like:'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The velocity and height are assigned their starting values, *v*0 and *h*0,
    and then the velocity is updated by *g* and the acceleration (due to gravity),
    and then the height, *h*, is updated by the velocity. We repeat our calculation
    every second and check to see when the ball''s height returns to zero:'
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The following is the output:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'It looks like the ball hits the ground somewhere between 4 and 5 seconds. But
    when we put *t = 5* into the preceding formula, we get the following:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.35: Substituting the values in the formula for calculating the
    height of a projectile'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_35.jpg)'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.35: Substituting the values in the formula for calculating the height
    of a projectile'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: 'After 5 seconds, the ball should still be 22.5 meters in the air. What''s wrong
    with our code? As you should know by now, the ball doesn''t only change its velocity
    once every second. Its velocity is changing constantly. Just like compound interest,
    we need to calculate the new velocity many times a second. That''s easy for Python.
    We''ll just introduce an `inc` variable for the increment in time. Remember that
    this increases the number of times we loop through the calculations, so the `for
    i in range` line changes too. Then, *g* and *v* are multiplied by the increment.
    We''ll recalculate every half a second:'
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Run this using the same code to execute:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The output is now as follows:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The ball is in the air for longer, and at 5 seconds, it''s 10.3 meters in the
    air. If we make the increment very small, it should get much closer to 22.5 meters
    at 5 seconds. Change `inc` to 0.001, run it again, and you''ll get this output:'
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'To answer the question of when the ball hits the ground, we''ll have to do
    a binary search between 5 and 6 seconds. As in previous searches, we use our `bin_search`
    function and change the `guess =` line to reflect the number we''re *guessing*:'
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'All we had to change was the `guess =` line with the parameters of the `height`
    function. The last parameter, *t*, is what we''re searching for, so that''s what
    we''re averaging. The binary search function will plug in values between 5 and
    6 and return the value of *t* that returns 0:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Here''s the output:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Now, we solve the quadratic equation:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '*29t – 4.9t*2 *= 0*'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: 'For *t*, we get *t = 0* and *5.9184*. Of course, the height of the ball was
    0 before we threw it, and the second value is very close to what we got. Here''s
    what the graph of the function looks like. Neglecting air resistance, the graph
    of the particle''s height over time follows a parabolic path:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.36: The path of a projectile without air resistance'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_36.jpg)'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.36: The path of a projectile without air resistance'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: This was a test of our code because we had a nice formula to check our output.
    Now, we will move on to harder calculus problems involving velocity and acceleration
    where there isn't a formula to help us check the answers.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2VEAkN4.](https://packt.live/2VEAkN4
    )
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2Bzpz7Z.](https://packt.live/2Bzpz7Z
    )
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: An Example of Calculating the Height of a Projectile with Air Resistance
  id: totrans-598
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Math students are forced to study particles traveling in perfect parabolic
    paths from algebra through calculus. Unfortunately, that''s not how real particles
    travel. In real life, objects travel through some medium such as air or water
    and are slowed down depending on the density of the medium, their cross-sectional
    area, and other factors. This makes for a complicated equation for the force that''s
    applied to a projectile. In the simplest of terms, *the force on a projectile
    is the acceleration due to gravity and deceleration proportional to the square
    of its velocity*. The equation looks like this:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '*F = mg - kv*2'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: With air resistance, we'll need to know the mass, *m*, of the projectile. The
    acceleration due to gravity, *g*, is 9.8 m/s2. The *k* variable is a combination
    of at least three different factors, but the value *k = 0.27* yields realistic
    results for this situation.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: As in the previous exercise, we calculate the acceleration and use it to update
    the velocity. Then, we update the position of the projectile according to the
    velocity.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: 'The force on the projectile is made up of two parts: the usual acceleration
    due to gravity and a drag component. Let''s write a Python function to calculate
    that:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Many times, our values are multiplied by `inc`, the increment variable, so that
    we can take smaller steps to get better approximations, as we did before. The
    `gravity` and `drag` variables are taken directly from the force equation. Notice
    that if the velocity is greater than 0, the projectile is traveling upward, so
    the downward force is the sum of the gravity and drag forces. Otherwise, the projectile
    is traveling downward, so the force of gravity is still downward but the drag
    is slowing it down, so we use the difference of the gravity and the drag.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll adapt our `height` function from the previous exercise to calculate
    the time it takes for the height to equal 0 and add in a call to our `force` function:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'It''s the `v -=` line that''s doing the heavy lifting in this function. The
    velocity will be acted on by the downward force. When we run this using *k = 0*,
    we should get the same time and ending velocity as in the previous problem, with
    no air resistance:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The output is as follows:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Yes; in the previous exercise, the projectile took 5.9 seconds to reach the
    ground. When there's no air resistance and the ending height is the same as the
    initial height, the ending velocity will be the same as the initial velocity,
    only in the opposite direction, so –29 m/s.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's put in our more realistic value for *k*, `0.27`, and see how long
    it takes the particle to reach the ground and how fast it will be going. What
    do you predict?
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `v -=` line in the `height` function to the following:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The output when you run the program will be as follows:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'So, the projectile went up and back down in only 2.2 seconds, and the final
    velocity was –5.9 m/s. If we juxtapose the graphs of the heights of the projectiles
    with and without air resistance, we certainly get a lot less height with air resistance:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.37: The height of a projectile, with air resistance (the inner
    curve)'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_37.jpg)'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.37: The height of a projectile, with air resistance (the inner curve)'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: That sure is a lot of resistance. Play around with different values for *k*,
    the constant of drag, to get different ending times and ending velocities. This
    leads us to a very interesting idea in math and science, known as **terminal velocity**,
    when the downward and upward forces on a projectile equal out and it no longer
    accelerates.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.22: Calculating the Terminal Velocity'
  id: totrans-623
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your projectile started at an initial height of 3,000 meters and jumped out
    of a plane (downward velocity of 0), what velocity would it reach? Would it simply
    continue accelerating until the projectile hits the ground?
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the mass to 80 kg, an average weight for a human, and *k* to `0.27`.
    Follow these steps to complete this exercise:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have your `force` function from the previous example.
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change your `height` function so that it looks like this:'
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Here''s the important line where we tell the `force` function the mass, the
    value of *k*, and so on:'
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'We go through 500 loops but only print out the velocity every 50th loop. Let''s
    run it with this line:'
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'This is the output we receive:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'The velocity starts at 0 and gets more and more negative until it stops decreasing.
    It evens out around 54 m/s (negative because it''s downward), which is around
    120 miles per hour, the terminal velocity for a human body in free fall. Here''s
    a graph of the velocity over time:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.38: The velocity of a body in free fall with air resistance'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_38.jpg)'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.38: The velocity of a body in free fall with air resistance'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2NNmWBM.](https://packt.live/2NNmWBM
    )
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2BUuXCp.](https://packt.live/2BUuXCp
    )
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's complete an activity to test what we have learned in this chapter.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 12.01: Finding the Velocity and Location of a Particle'
  id: totrans-643
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The velocity vector of a particle moving in the *x-y* plane has the following
    components:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.39: Differential equation for the velocity vector of a particle'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_39.jpg)'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.39: Differential equation for the velocity vector of a particle'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: Find all the times (and coordinates) at which the line tangent to the curve
    is horizontal, and then find the speed of the particle at *t = 1*.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this activity:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: Write functions for *dx/dt* and *dy/dt*.
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loop through the output to find where the derivative is 0 by finding the values
    where the derivative goes from positive to negative or vice versa. Then, use binary
    search to find more accurate approximations.
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `position` function and take incremental steps of time using loops,
    changing the position of the particle according to the derivatives (the *change
    in position*) given previously. The function should stop at the desired elapsed
    time and print out the *x-y* coordinates.
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plug the times you found in *step 2* into the `position` function to find the
    *x-y* coordinates of the particle when the derivative is 0.
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You're asked for the speed of the particle at time *t = 1*. Find the vertical
    and horizontal components of the particle's velocity using the differential equations
    you're given, and also find the hypotenuse of the right triangle created with
    those components acting as the legs.
  id: totrans-654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 702.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-657
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Calculus is a very powerful set of tools for modeling real situations, from
    the transfer of heat to the motion of planets. It has enabled us to calculate
    the rate of change of a function in an instant and the area under complicated
    curves (tasks that seemed impossible using only the tools of algebra and geometry).
    In this chapter, we've been able to deal with the rate of change of a value (the
    derivative) as a value in itself, and we've calculated some very accurate results
    using Python loops and functions. Modeling situations that lead to differential
    equations, such as the paths of projectiles, was what drove the development of
    the first electronic computers.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: Math classes may still emphasize algebraic solutions to equations, even differential
    equations, but as we've seen in this chapter, using a computer is a straightforward
    way to model a real-life situation such as a predator pursuing its prey. We changed
    variables such as the amount of money in an investment, the amount of salt in
    a mixture, and the direction a predator was facing thousands of times, recalculating
    amounts and distances every step, and got very accurate results. Python was the
    perfect tool to set some starting conditions and let the program run until a projectile
    hit the ground or reached a terminal velocity. Python also helped us avoid laborious
    algebraic manipulations and let us *brute force* an answer by creating a simple
    model of a falling object or a predator pursuing its prey. This was *simple* because
    we didn't have to repeat the calculations thousands of times—the computer did.
    Plus, these numerical methods are already used on differential equations that
    have no simple algebraic solution, and they even work on those equations that
    do. Hopefully, this chapter has proven the power of using a computer to model
    and analyze complicated real-world situations.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: Now, you've learned how to build on Python's loops, variables, conditionals,
    functions, and lists to solve complicated problems in statistics, probability,
    and calculus. You've also learned how to time the execution of your code and plot
    your output. You've used Python's state-of-the-art numerical package, `numpy`,
    to speed up calculations and manipulate arrays for a host of applications. You've
    also seen Python programming being applied to every math topic under the sun,
    and now you'll be able to apply it to any real-life situations you encounter in
    the future.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: JMK95
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: GEA39
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
