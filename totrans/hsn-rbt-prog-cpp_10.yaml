- en: Building an Object-Following Robot with OpenCV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After installing OpenCV in the previous chapter, it is now time to perform
    image-processing operations using the OpenCV library. In this chapter, we will
    cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Image processing with OpenCV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing a video feed from the Pi camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an object-following robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are no new technical requirements as such for this chapter, but you will
    require the following things to perform the examples:'
  prefs: []
  type: TYPE_NORMAL
- en: A red, green, or blue colored ball for detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Pi camera and an ultrasonic sensor mounted on the robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter can be downloaded from [https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Image processing with OpenCV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at the important functions of the OpenCV library.
    After that, we will write a simple C++ program using the OpenCV libraries and
    perform different image-processing operations on an image.
  prefs: []
  type: TYPE_NORMAL
- en: Important functions in OpenCV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before writing any OpenCV program, it is important to understand some of the
    main functions in OpenCV and the output that these functions can give us. Let''s
    start by looking at the functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`imread()`**: The `imread()` function is used to read an image or a video
    feed from the Pi camera or webcam. Inside the `imread()` function, we have to
    provide the location of the image. If the image and program files are in the same
    folder, we only need to provide the name of the image. However, if the image is
    stored in a different folder, then we need to provide the complete path of the
    image inside the `imread` function. We store the image value from the `imread()`
    function inside a matrix (`Mat`) variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the image and `.cpp` files are in the same folder, the code will look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If the image and `.cpp` file are in different folders, the code will look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`imshow()`: The `imshow()` function is used to show or view the image:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `imshow()` function consists of two parameters, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is the window text
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter is the variable name of the image that is to be displayed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of the `imshow()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9cb8e918-e21b-4484-994c-a53e49eaf1f6.png)'
  prefs: []
  type: TYPE_IMG
- en: '`resize()`: The `resize()` function is used to resize the dimensions of the
    image. This function is generally used when users are working with multiple windows
    at the same time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This function consist of three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is the variable name of the original image (`img`) that
    is to be resized.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter is the variable name of the new image (`rzimg`) that will
    be resized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third parameter is `cvSize`, and in this we enter the **new width** andthe
    **height value**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of the `resize()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fcade67-80dc-476e-b1d2-1a7ad3138fa3.png)'
  prefs: []
  type: TYPE_IMG
- en: '`flip()`: This function is used to flip the image either horizontally, or vertically,
    or both at the same time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This function consists of three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter (`img`) is the variable name of the original image.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter (`flipimage`) is the variable name of the flipped image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third parameter is the flipping type; `0` denotes a vertical flip, `1` represents
    a horizontal flip, and `-1` means that the image should flip both horizontally
    and vertically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of the `flip()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e0a5b4a-3110-465f-af3f-f2e5d0309fe8.png)'
  prefs: []
  type: TYPE_IMG
- en: '`cvtColor()`: This function is used to convert a normal RGB-colored image into
    a gray-scale image:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This function consists of three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter (`img`) is the variable name of the original image
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter (`grayimage`) is the variable of the new image that will
    be converted to gray-scale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third parameter, `COLOR_BGR2GRAY`,is the conversion type; BGR is RGB written
    in reverse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of the `cvtColor()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6bb5991a-bb09-4079-b1e7-36fb272f016d.png)'
  prefs: []
  type: TYPE_IMG
- en: '`threshold()`: The thresholding method is used to separate out regions of an
    image that represent an object. In simple terms, thresholding is used to recognize
    a particular object in an image. The thresholding method takes a source image
    (`src`), the thresholding value, and the maximum threshold value (`255`) as an
    input. It produces an output image (`thresimg`) by comparing the pixel values
    of the source image to the threshold value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The threshold function consists of five parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter (`src`) is the variable name of the image that is to be
    thresholded.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter (`thresimg`) is the variable name of the thresholded image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third parameter (`threshold value`) is the threshold value (from 0 to 255).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth parameter (`max threshold value`) is the maximum threshold value
    (`255`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fifth parameter (`threshold type`) is the thresholding type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generally, there are five types of thresholding, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**0-binary**: Binary thresholding is the simplest form of thresholding. In
    this thresholding, if any pixel on the source image (`src`) has a value greater than
    the threshold value, then in the output image (`thresimg`), this pixel is set
    to the maximum threshold value (`255`), and it will turn white. On the other hand,
    if any pixel on the source image has a value less than the threshold value, then
    in the output image the pixel value is set to `0`, and it will appear black.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, in the following code, the thresholded value is set to `85`, the
    maximum threshold value is `255`, and the thresholding type is a binary represented
    by the number `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So, if any pixels on the Apple Image source image have a value greater than
    the threshold value (that is, greater than `85`), then those pixels will turn
    white in the output image. Similarly, the pixels on the source image whose values
    are less than the threshold value will turn black in the output image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dcdf5b7c-3085-4601-a90f-fbb742150def.png)'
  prefs: []
  type: TYPE_IMG
- en: Binary thresholding
  prefs: []
  type: TYPE_NORMAL
- en: '**1-binary inverted**: Binary inverted thresholding is exactly the opposite
    of binary thresholding. In this type of thresholding, the pixel of the output
    image will turn black (`0`) if the source image''s pixel value is greater than
    the threshold value, and will turn white (`255`) if the pixel value of the source
    image is less than the threshold value:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/64064bd2-0ac0-4793-a79a-c5600f8f2d18.png)'
  prefs: []
  type: TYPE_IMG
- en: Binary inverted thresholding
  prefs: []
  type: TYPE_NORMAL
- en: '**2-truncated** **thresholding**: In truncated thresholding, if any pixel value
    on the `src` source image is greater than the threshold value, then in the output
    image, this pixel will be set to the threshold value. On the other hand, if any
    pixel value on the `src` source image is less than the threshold value, then in
    the output image, the pixel will retain its original color value:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/fcf7b239-5bf5-4a6f-a6d7-d76f05083cb9.png)'
  prefs: []
  type: TYPE_IMG
- en: Truncated thresholding
  prefs: []
  type: TYPE_NORMAL
- en: '**3-threshold to zero**: In this thresholding, if any pixel value on the `src` source
    imageis greater than the threshold value, then in the output image, the pixel
    will retain its original color value. On the other hand, if any pixel value on
    the `src`source image is less than the threshold value, then in the output image
    the pixel will be set to `0` (that is, black):'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/6f3a8fc1-a1b9-4010-9f76-43c7598b936f.png)'
  prefs: []
  type: TYPE_IMG
- en: Threshold to zero
  prefs: []
  type: TYPE_NORMAL
- en: '**4-threshold to zero inverted**: In this thresholding, if any pixel value
    on the `src` is greater than the threshold value, then in the output image, the pixel
    will be set to `0`. If any pixel value on the `src`is less than the threshold
    value, then in the output image, the pixel will retain its original color value:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/2c0e2d36-c417-4ab2-9ca8-6369d7808e9d.png)'
  prefs: []
  type: TYPE_IMG
- en: Threshold to zero inverted
  prefs: []
  type: TYPE_NORMAL
- en: '`inRange()`: The `inRange()` function is an advanced form of the thresholding
    function. Inside this function, we have to enter the minimum and maximum RGB color
    values of the object that we want to recognize. The `inRange()` function consists
    of four parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first parameter (`img`) is the variable name of the image that is to be
    thresholded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are two `Scalar` functions. In the second parameter, which is the first
    `Scalar` function, we have to enter the minimum RGB color of the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the third parameter, which is the second `Scalar` function, we will enter
    the maximum RGB color value of the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The fourth parameter (`thresImage`) represents the output of the threshold
    image:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Image moments**—the concept of image moments is borrowed from **moments**,
    which is used in both mechanics and statistics to describe the spatial distribution
    of a set of points. In image processing or computer vision, an image moment is
    used to find the **centroid** of a shape, which is the average mean of all the
    points in a shape. In simple terms, image moments are used to find the center
    of any object once we have segmented it from the entire image. For example, in
    our case, we might want to find the center of the apple. The **image moments formula**
    for calculating the center of an object from an image is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03fefae2-083d-4dc8-a8ac-d5a21dc4d18c.png)'
  prefs: []
  type: TYPE_IMG
- en: '*x* represents the width of image'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '*y* represents the height of image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*M10* represents the sum of all the *x* values in the image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*M01* represents the sum of all the *y* values in the image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*M00* represents the entire area of the image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`circle`: As the name suggests, this function is used to draw a circle. It
    takes five parameters as the input:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first parameter (`img`) is the variable name of the image on which you have
    to draw the circle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter (`point`) is the center (the *x*, *y* position) point for
    the circle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third parameter (`radius`) is the radius of the circle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth parameter (`Scalar(B,G,R)`) is for coloring the circle; we do this
    using the `Scalar()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The fifth parameter (`thickness`) is the thickness of the circle:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Object recognition using OpenCV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve understood the important functions of OpenCV, let''s write
    a program to detect a colored ball from an image. Before we start, the first thing
    we have to do is to take a proper photo of the ball. You can use any ball for
    this project, but just make sure that the ball has a single color (red, green,
    or blue color ball is highly recommended) and that it is not multicolored. I''m
    using a green ball for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b106b7e4-d5e1-4315-9a5f-780605e86b64.png)'
  prefs: []
  type: TYPE_IMG
- en: Capturing the image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To capture the image of your ball, place it on some dark surface. I have placed
    my green ball on a mobile phone case, which is black:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6682ea0b-0d22-4d37-9f4c-f97c19c5f083.png)'
  prefs: []
  type: TYPE_IMG
- en: If your ball is black, or of a dark color, you can place the ball on a surface
    that has a light color. This is to make sure there is a very high contrast between
    the color of the ball and the color of the background, which will help us in thresholding
    later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'While capturing the image, make sure that there are no white colored patches
    on the ball, as this may cause problems later on while thresholding:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a50b303b-299f-4688-a872-7b1113acd8c0.png)'
  prefs: []
  type: TYPE_IMG
- en: The photo on the left has a big white region because of too much lighting. On
    the right, the ball is lit up properly.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are satisfied with the captured image, transfer it to your laptop.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the RGB pixel values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now find the RGB pixel values of the ball by examining different points
    on it using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Paint and open the saved image of the ball, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ed5a0ead-7fce-4d7a-b840-4bac834a0314.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, using the color picker tool, take samples of the color by clicking anywhere
    on the ball:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5a72281c-cd2c-488c-9a25-862740b7f79e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Color 1 box will show the sample of the color that was clicked on. In my
    case, this is green:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55d4a8ea-436c-44b7-809a-ced4e08fef9e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click on the Edit Colors option, you will see the RGB color value of
    that particular pixel. In my case, the RGB color value for the green pixel is
    Red: `61`, Green: `177`, and Blue: `66`. Make a note of these values and save
    them for later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/79be885f-8be2-4410-9213-6f295f4e68af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, select the color picker option again and click on another colored area
    of the ball to find out the RGB color value of that particular pixel. Again, note
    down this value. Do the same thing 13 to 14 times, making sure you include the
    lightest and the darkest colors on the ball:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/73e809be-ab83-4576-8502-61e1f9202d22.png)'
  prefs: []
  type: TYPE_IMG
- en: I have noted down the RGB values for six points on the edges of the ball, four
    points at random places around the ball, and six points on places where the color
    is either light green or dark green. After finding out the RGB values, highlight
    the lowest red, green, and blue color values and the highest red, green, and blue
    color values. We will use these values in our program later on to threshold the
    image.
  prefs: []
  type: TYPE_NORMAL
- en: You now need to transfer this image to your RPi. I transferred my image via Google
    Drive**. **I did this by uploading the image to Google Drive, next, opening the
    default Chromium web browser inside my RPi, signing into my Gmail account, opening
    Google Drive, and downloading the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The object detection program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The program for detecting the green ball is named `ObjectDetection.cpp` and
    I have saved it inside the `OpenCV_codes` folder. I have also copied the `greenball.png`
    image to this folder. You can download the `ObjectDetection.cpp` program from
    the `Chapter07` folder of the GitHub repository. So, the program for detecting
    the green ball is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, we are importing four OpenCV libraries, which are `opencv.hpp`,
    `core.hpp`, `highgui.hpp`, and `imgproc.hpp`. We then declared the `cv` namespace
    that is a part of the OpenCV library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the explanation of the preceding program:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `main` function, we declared three matrix variables called `img`,
    `resizeimg`, and `thresimage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, the `greenball.png` file is read by the `imread()` function and stored
    in the `img` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `imshow("Green Ball Image", img)` line will display the image in a new
    window, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/78b0c58b-4365-4476-8a93-ae7f0cff4575.png)'
  prefs: []
  type: TYPE_IMG
- en: After this, the `waitKey(0)` function will wait for the keyboard input. It will
    then execute the next set of code. Once you press any key, the next two lines
    of code for resizing the image will execute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `resize` function will resize the width and height of the image so that
    the new width of the image is `640` and the height is `480`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cd1136d0-cd91-4c74-ad86-b7b2c19c79d3.png)'
  prefs: []
  type: TYPE_IMG
- en: The thresholding operation is then performed using the `inRange` function. Inside
    the first `Scalar` function, I have entered the minimum RGB values for the green
    color of my ball, and in the second `Scalar` function, I have entered the maximum
    RGB values thereof. The thresholded image is stored in the `thresimage` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `Scalar` function, we have to enter the blue value first, followed
    by green, and then red.
  prefs: []
  type: TYPE_NORMAL
- en: 'After thresholding, the color of the ball will become white and the remaining
    portion of the image will become black. Some portions in the middle of the ball
    will appear black, which is fine. If large areas appear as black inside the white
    color, this means that the thresholding has not happened properly. In this case,
    you can try modifying the RGB values inside the `Scalar` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7dbbcb36-3994-479a-baff-e29aae6ba464.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, using moments, we find the center of the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `moments(thresimage,true)` line, we have provided the `thresimage` variable
    as an input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next three lines of code, we find the center of the white area and store
    that value in the point variable, `p`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, to display the center of the ball, we use the `circle` function.
    Inside the circle function, we use the `img` variable as we will display the circular
    dot on the original image. Next, the point variable, `p`, tells the function where
    we have to display the dot. The width of the circular dot is set to `5`, and the
    color of the circular dot will be red, as we have only filled the last parameter
    of the `Scalar` function, which denotes the color red. If you want to set another
    color, you can change the color values inside the `Scalar` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/59d0c10b-6ec9-4fb7-800c-c3ef54c1006d.png)'
  prefs: []
  type: TYPE_IMG
- en: Press any key one more time and the final `waitKey(0)` function will close all
    of the windows apart from the Terminal window. To close the Terminal window, press
    *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the preceding program, we have learned how to resize, threshold, and generate
    a point (the red dot) on top of the image of the green ball. In the next section,
    we will perform some image recognition operations on a live video feed.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenCV camera feed program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now write a simple C++ program to view the camera feed from the Pi
    camera. The program for viewing the video is as follows. The program is named
    `Camerafeed.cpp` and you can download it from the `Chaper07` folder of the GitHub
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The OpenCV libraries and namespace declaration is similar to that of the previous
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: First, inside the `main` function, we are declaring a matrix variable called
    `videoframe`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, the `VideoCapture` datatype is used to capture a video feed from the Pi
    camera. It has a variable called `vid(0)`. The `0` number inside the `vid(0)`
    variable represents the index number of the camera. Currently, since we have only
    one camera attached to the RPi, the Pi camera will have an index of `0`. If you
    attach a USB camera to the Raspberry Pi, then the USB camera will have an index
    of `1`. By changing the index number, you can switch between the Pi camera and
    the USB camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we specify that the `!vid.isOpened()` condition should be called if the
    camera is not able to capture any video feed. In this case, an `"Error opening
    camera"` message will be printed in the Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, the `vid.read(videoframe)` command will read the camera feed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `imshow("Video output", videoframe)` line, we can now view the camera
    feed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `waitKey` command will wait for keyboard input. Once you press any key,
    it will exit the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is how you can view a video feed using the Pi camera.
  prefs: []
  type: TYPE_NORMAL
- en: Building an object-following robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After thresholding an image and viewing the video feed from the Pi camera, we
    will combine both of these programs to create our object-following robot program.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will write two programs. In the first program, we place
    the ball in front of the camera and trace it by creating a dot (using moments)
    in the center of the ball. Next, we will move the ball **up**, **down**, **left**, and **right**
    and note the point values at different positions on the camera.
  prefs: []
  type: TYPE_NORMAL
- en: In the second program, we will use these point values as an input and make the
    robot follow the ball object.
  prefs: []
  type: TYPE_NORMAL
- en: Ball tracing using moments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before following the ball, the robot should first be able to trace it using
    the Pi camera. Before writing the program, let's see how we are going to track
    the ball.
  prefs: []
  type: TYPE_NORMAL
- en: Programming logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will resize the camera resolution to 640 x 480, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/573110e3-d48d-4160-a850-58337f40e3d3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After resizing the width and height, we divide the camera screen horizontally
    into three equal sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58b91348-dc48-4cff-a1e8-39b77c1dd6f4.png)'
  prefs: []
  type: TYPE_IMG
- en: The **x coordinate values** from 0 to 214 represent the left section. The **x
    coordinate values** from 214 to 428 represent the forward section, while the **x
    coordinate values** from 428 to 640 represent the right section. We do not need
    to write any specific program to divide the camera screen into these three different
    sections, we just need to remember the minimum and maximum** x point values** for
    each of these sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will perform thresholding on the ball object. After this, we will
    use moments and generate a dot on the center of the ball. We will print the point
    value in the console and check the *x* and *y* point values at a particular segment
    of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f14fbb93-e742-4108-b319-a23790fa82b9.png)'
  prefs: []
  type: TYPE_IMG
- en: If the ball is in the **FORWARD** section, the **x coordinate value** must be
    between **214** and **428**. Since we are not dividing the screen vertically,
    we don't need to consider the *y* values. Let's now start with the ball tracing
    program.
  prefs: []
  type: TYPE_NORMAL
- en: The ball tracing program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `BallTracing.cpp` program is as follows. You can download this program
    from the `Chapter07` folder of the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `main` function, we have three matrix variables by the name of `videofeed`,
    `resizevideo`, and `thresholdvideo`. We have also declared a `VideoCapture` variable
    called `vid(0)` for capturing the video.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps explain the `BallTracing.cpp` program in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `for` loop, the `vid.read(videofeed)` code will read the camera feed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `resize` function, we resize the camera resolution to 640 x 480\.
    The resized video feed is stored in the `resizevideo` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, using the `flip` function, we flip the resized image horizontally. The
    output of the flipped video is again stored in the `resizevideo` variable. If
    we don't flip the video horizontally, the ball will appear as though it is moving
    on the right side when you move to the left and vice versa. If you have mounted
    the Pi camera upside down then you will need to flip the resized image vertically.
    To flip it vertically, set the third parameter to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, with the `inRange` function, we threshold the video feed to make the colored
    ball stand out from the rest of the image. The thresholded video output is stored
    in the `thresholdvideo` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `moments`, we find the center of the ball that is stored in the point
    variable, `p`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `circle` function, we display a red dot on the ball inside the `resizevideo`
    feed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first `imshow` function will display the resized (`resizedvideo`) video
    feed, while the second `imshow` function will display the thresholded (`thresholdvideo`)
    video feed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f05e7531-1c94-4573-ba08-46c39265d628.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, the left window shows the `resizevideo` feed and
    we see the red dot on the green ball. The right window shows the threshold video
    feed, in which only the region of the ball is appearing white.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `cout<<Mat(p)<<endl;` code will display the *x* and *y* point values
    of the red dot inside the console. When you move the ball, the red dot will also
    move with it and the *x* and *y* position of the red dot will be displayed inside
    the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the preceding screenshot, the values inside the square brackets, `[298
    ; 213]`, are the point values. So the *x* value of the red dot in my case is in
    the range of 298 to 306 and the *y* value is in the range of 216 to 218.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the object-following robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After tracing the position of the ball, what remains is to make our robot follow
    the ball. We are going to use the *x* and *y* coordinate values as an input. While
    following the ball, however, we also have to make sure that the robot is at a
    suitable distance from the ball, so that it does not collide with the ball or
    the person who is holding it. To do this, we will also attach the ultrasonic sensor
    to our robot. For this project, I have attached the ultrasonic sensor **trigger**
    pin to the **wiringPi pin no 12**, and the **echo** pin to the **wiringPi pin
    no 13** via a** voltage divider circuit**.
  prefs: []
  type: TYPE_NORMAL
- en: Object-following robot program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The object-following robot program is basically a combination of the obstacle-avoiding
    program from [Chapter 4](a6ef702a-1576-4aa5-8e2a-b2b431b313bb.xhtml), *Building
    an Obstacle-Avoiding Robot,* and the preceding ball-tracing program. The program
    is called `ObjectFollowingRobot.cpp` and you can download it from the `Chapter07`
    folder of the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` function, after calculating the distance, thresholding the video,
    and placing the dot at the center of ball, let''s take a look at the rest of the
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: The first `if` condition (`if(distance < 15)`), will check whether the robot
    is 15 cm away from the object. If the distance is less than 15 cm, the robot will
    stop. The forward, left, right, and stop functions are declared above the `main`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath the `stop()` function, the `cout` statement will first print the
    message, `"Object close to Robot"`**.** After that, it will print the point(x,y)
    value (`Mat(p)`) and then the `distance` value. Inside every `if` condition, the
    `cout` statement will print the region (such as `LEFT`, `FORWARD`, or `RIGHT`),
    the point value, and the `distance` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the distance is greater than 15 cm, the `else` condition will execute. Inside
    the `else` condition, there are three `if` conditions to find the position of
    the ball (by using the red dot on it as a reference).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, as soon as the camera is activated, or when the ball moves out of the camera's
    view, the red dot (the point) will reset to a position of **x:0**, **y:0**, which
    is at the extreme top-left of the screen**.** The first `if` condition(`if(x<20
    && y< 20)`) inside the `else` block will check whether the position of the red
    dot is less than 20 on both the *x* and *y* axis. If it is, the robot will stop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the *x* position is between 20 and 170 and the *y* position is greater than
    20, the red dot will be in the **LEFT** region and the robot will turn **LEFT**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this program, I have reduced the width of the **LEFT** and **RIGHT** regions
    and increased the width of the **FORWARD** region, as shown in the following photo.
    You can modify the width of each region according to your requirements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a53a8bd1-4f76-4ab6-aaf4-bc0c0a18646b.png)'
  prefs: []
  type: TYPE_IMG
- en: If the **x position** is between **170** and **470, **thered dot is in the **FORWARD**
    region and the robot will move **FORWARD**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the** x position** is between **470** and **640****, **thered dot is in the
    **RIGHT** region and the robot will turn** RIGHT**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Power up your robot using a power bank so that it can move freely. Next, compile
    the program and build it on your RPi robot. As long as the ball is not in front
    of the robot, the red dot will remain in the extreme top-left corner of the screen
    and the robot will not move. If you move the ball in front of the camera and if
    you are 15 cm away from the robot, the robot will start following the ball.
  prefs: []
  type: TYPE_NORMAL
- en: As the robot follows the ball, the color of the ball will vary because of external
    factors, such as sunlight or the light in the room. If the light in the room is
    low, the ball will appear a little darker to the robot. Similarly, if there is
    too much light in the room, some parts of the ball may also appear white. This
    may cause the thresholding to not work properly, which might mean the robot does
    not follow the ball smoothly. In this case, you will need to adjust the RGB values.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at some of the important functions inside OpenCV
    libraries. After that, we put these functions to the test and recognized an object
    from an image. Next, we learned how to read a video feed from the Pi camera, how
    to threshold a colored ball, and how to place a red dot on top of it. Finally,
    we used the Pi camera and the ultrasonic sensor to detect the ball and follow
    it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to expand our OpenCV knowledge by detecting
    human faces using the Haar Cascade. After that, we will recognize a smile and
    make the robot follow the face.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the process of separating an object from an image called?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the command to flip the image vertically?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If x>428 and y>320, what block will the red dot be in?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the command used for resizing the camera resolution?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the object is not in front of the camera then where will the red dot be placed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
