- en: Continuous Delivery Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already covered the most crucial parts of the Continuous Delivery process:
    the commit phase, the artifact repository, automated acceptance testing, and configuration
    management.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on the missing parts of the final pipeline, which
    are the environments and infrastructure, application versioning, and nonfunctional
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing different software environments and their infrastructures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing the connection between Jenkins agents and servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing various kinds of nonfunctional tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presenting the challenges of nonfunctional tests in the Continuous Delivery
    process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining different types of application versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Completing the Continuous Delivery pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the concept of smoke testing and adding it to the final pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environments and infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have always used one Docker host for everything and treated it as
    the virtualization of endless resources where we can deploy everything. Obviously,
    the Docker host can actually be a cluster of machines and we will show how to
    create it using Docker Swarm in the next chapters. However, even if the Docker
    host were unlimited in terms of resources, we still need to think about the underlying
    infrastructure for at least two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Physical location of the machines matters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No testing should be done on the production physical machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking these facts into consideration, in this section, we will discuss different
    types of environment, their role in the Continuous Delivery process, and infrastructure
    security aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Types of environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are four most common environment types: production, staging, QA (testing),
    and development. Let''s discuss each of them and its infrastructure.'
  prefs: []
  type: TYPE_NORMAL
- en: Production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Production is the environment that is used by the end user. It exists in every
    company and, of course, it is the most important environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following diagram and see how most production environments
    are organized:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3092eae3-1a55-4505-987b-d3aff24db07c.png)'
  prefs: []
  type: TYPE_IMG
- en: Users access the service through the load balancer, which chooses the exact
    machine. If the application is released in multiple physical locations, then the
    (first) device is usually a DNS-based geographic load balancer. In each location,
    we have a cluster of servers. If we use Docker, then that cluster of servers can
    be hidden behind one or multiple Docker hosts (which are internally composed of
    many machines using Docker Swarm).
  prefs: []
  type: TYPE_NORMAL
- en: The physical location of machines matters because the request-response time
    can differ significantly depending on the physical distance. Moreover, the database
    and other dependent services should be located on a machine that is close to where
    the service is deployed. What's even more important is that the database should
    be sharded in a way that the replication overhead between different locations
    is minimized. Otherwise, we may end up waiting a lot for the databases to reach
    consensus between its instances located far away from each other. More details
    on the physical aspects are beyond the scope of this book, but it's important
    to remember that Docker is not always a silver bullet.
  prefs: []
  type: TYPE_NORMAL
- en: Containerization and virtualization allow you to think about servers as an infinite
    resource; however, some physical aspects such as location are still relevant.
  prefs: []
  type: TYPE_NORMAL
- en: Staging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The staging environment is the place where the release candidate is deployed
    in order to perform the final tests before going live. Ideally, this environment
    is a mirror of the production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following to see how such an environment should look in
    the context of the delivery process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3dcb04d1-39d0-4e73-9773-1de9f5de4b47.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the staging environment an exact a production clone. If the application
    is deployed in multiple locations, then the staging should also have multiple
    locations.
  prefs: []
  type: TYPE_NORMAL
- en: In the Continuous Delivery process, all automated acceptance functional and
    nonfunctional tests are run against this environment. While most functional tests
    don't usually require identical production-like infrastructure, in the case of
    nonfunctional (especially performance) tests, it's a must.
  prefs: []
  type: TYPE_NORMAL
- en: It is not uncommon that, for the purpose of cost saving, the staging infrastructure
    differs from the production (usually it contains fewer machines). Such an approach
    can, however, lead to many production issues. *Michael T. Nygard*, in his great
    book *Release It!*, gives an example of a real-life scenario in which fewer machines
    were used in the staging environment than in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'The story goes like this: in one company, the system was stable until a certain
    code change, which caused the production to be extremely slow, even though all
    stress tests passed. How was it possible? It happened that there was a synchronization
    point, in which each server communicated with each other. In the case of the staging,
    there was one server, so actually there was no blocker. In production, however,
    there were many servers, which resulted in servers waiting for each other. This
    example is just the tip of the iceberg and many production issues may fail to
    be tested by acceptance tests if the staging environment is different from the
    production environment.'
  prefs: []
  type: TYPE_NORMAL
- en: QA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The QA environment (also called the testing environment) is intended for the
    QA team to perform exploratory testing and for external applications (which depend
    on our service) to perform integration testing. The use cases and the infrastructure
    of the QA environment are presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e9e70c25-4395-435b-91ff-36d3657f285d.png)'
  prefs: []
  type: TYPE_IMG
- en: While staging does not need to be stable (in the case of Continuous Delivery,
    it is changed after every code change committed to the repository), the QA instance
    needs to provide a certain stability and expose the same (or backward compatible)
    API as the production. Contrary to the staging environment, the infrastructure
    can be different from the production, since its purpose is not to ensure that
    the release candidate works properly.
  prefs: []
  type: TYPE_NORMAL
- en: A very common case is to allocate fewer machines (for example, only from one
    location) for the purpose of the QA instance.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to the QA environment is usually done in a separate pipeline, so that
    it will be independent from the automatic release process. Such an approach is
    convenient, because the QA instance has a different life cycle than production
    (for instance, the QA team may want to perform testing on the experimental code
    branched from the trunk).
  prefs: []
  type: TYPE_NORMAL
- en: Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The development environment can be created as a shared server for all developers
    or each developer can have his/her own development environment. A simple diagram
    is presented here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4ded0bd8-f76b-4509-bd96-f0cb95bd5606.png)'
  prefs: []
  type: TYPE_IMG
- en: The development environment always contains the latest version of the code.
    It is used to enable integration between developers and can be treated the same
    way as the QA environment, but is used by developers, not QAs.
  prefs: []
  type: TYPE_NORMAL
- en: Environments in Continuous Delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the purpose of the Continuous Delivery process, the staging environment
    is indispensable. In some very rare cases, when the performance is not important
    and the project does not have many dependencies, we could perform the acceptance
    tests on the local (development) Docker host (like we did in the previous chapter),
    but that should be an exception, not a rule. In such a case, we always risk some
    production issues related to the environment.
  prefs: []
  type: TYPE_NORMAL
- en: The other environments are usually not important with regard to Continuous Delivery.
    If we would like to deploy to the QA or development environment with every commit,
    then we can create separate pipelines for that purpose (being careful not to obscure
    the main release pipeline). In many cases, deployment to the QA environment is
    triggered manually, because it can have different life cycles from production.
  prefs: []
  type: TYPE_NORMAL
- en: Securing environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All environments need to be well secured. That's clear. What's even more obvious
    is that the most important requirement is to keep the production secure, because
    our business depends on it and the consequences of any security flaw can be highest
    there.
  prefs: []
  type: TYPE_NORMAL
- en: Security is a broad topic. In this section, we focus only on the topics related
    to the Continuous Delivery process. Nevertheless, setting up a complete server
    infrastructure requires much more knowledge about security.
  prefs: []
  type: TYPE_NORMAL
- en: In the Continuous Delivery process, the slave must have access to servers, so
    that it can deploy the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different approaches for providing slaves with the server''s credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Put SSH key into slave**: If we don''t use dynamic Docker slave provisioning,
    then we can configure Jenkins slave machines to contain private SSH keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Put SSH key into slave image:** If we use dynamic Docker slave provisioning,
    we could add the SSH private key into the Docker slave image. However, it creates
    a possible security hole, since anyone who has access to that image would have
    access to the production servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jenkins credentials**: We can configure Jenkins to store credentials and
    use them in the pipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Copy to Slave Jenkins plugin**: We can copy the SSH key dynamically into
    the slave while starting the Jenkins build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each solution has some advantages and drawbacks. While using any of them we
    have to take extra caution, since, when a slave has access to the production,
    then anyone breaking into the slave breaks into the production.
  prefs: []
  type: TYPE_NORMAL
- en: The most risky solution is to put SSH private keys into the Jenkins slave image,
    since then all the places where the image is stored (the Docker registry or Docker
    host with Jenkins) need to be well secured.
  prefs: []
  type: TYPE_NORMAL
- en: Nonfunctional testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned a lot about functional requirements and automated acceptance testing
    in the previous chapter. However, what should we do with nonfunctional requirements?
    Or even more challenging, what if there are no requirements? Should we skip them
    at all in the Continuous Delivery process? Let's answer these questions throughout
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: Nonfunctional aspects of the software are always important, because they can
    cause a significant risk to the operation of the system.
  prefs: []
  type: TYPE_NORMAL
- en: For example, many applications fail, because they are not able to bear the load
    of a sudden increase in the number of users. In the book *Usability Engineering*,
    *Jakob Nielsen,* writes that 1.0 second is about the limit for the user's flow
    of thought to stay uninterrupted. Imagine that our system, with the growing load,
    starts to exceed that limit. Users can stop using the service just because of
    its performance. Taking it into consideration, nonfunctional testing is as important
    as functional testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To cut a long story short, we should always take the following steps for nonfunctional
    testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Decide which nonfunctional aspects are crucial to our business
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For each of them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify the tests the same way we did for acceptance testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a stage to the Continuous Delivery pipeline (after acceptance testing, while
    the application is still deployed on the staging environment)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application comes to the release stage only after all nonfunctional tests
    pass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Irrespective of the type of the nonfunctional test, the idea is always the same.
    The approach, however, may slightly differ. Let's examine different test types
    and the challenges they pose.
  prefs: []
  type: TYPE_NORMAL
- en: Types of nonfunctional test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional test are always related to the same aspect—the behavior of the system.
    On the contrary, nonfunctional tests concern a lot of different aspects. Let's
    discuss the most common system properties and how they can be tested inside the
    Continuous Delivery process.
  prefs: []
  type: TYPE_NORMAL
- en: Performance testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance tests are the most widely used nonfunctional tests. They measure
    the responsiveness and stability of the system. The simplest performance test
    we could create is to send a request to the web service and measure its **round-trip
    time** (**RTT**).
  prefs: []
  type: TYPE_NORMAL
- en: There are different definitions of performance testing. In many places, they
    are meant to include load, stress, and scalability testing. Sometimes they are
    also described as white-box tests. In this book, we define performance testing
    as the most basic form of black-box test to measure the latency of the system.
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of performance testing, we can use a dedicated framework (for
    Java the most popular is JMeter) or just use the same tool we used for acceptance
    tests. A simple performance test is usually added as a pipeline stage just after
    Acceptance tests. Such a test should fail if the RTT exceeds the given limit and
    it detects bugs that definitely slow down the service.
  prefs: []
  type: TYPE_NORMAL
- en: The JMeter plugin for Jenkins can show performance trends over the time.
  prefs: []
  type: TYPE_NORMAL
- en: Load testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Load tests are used to check how the system functions when there are a lot of
    concurrent requests. While a system can be very fast with a single request, it
    does not mean that it works fast enough with 1,000 requests at the same time.
    During load testing, we measure the average request-response time of many concurrent
    calls, usually performed from many machines. Load testing is a very common QA
    phase in the release cycle. To automate it, we can use the same tools as with
    the simple performance test; however, in the case of larger systems, we may need
    a separate client environment to perform a large number of concurrent requests.
  prefs: []
  type: TYPE_NORMAL
- en: Stress testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stress testing, also called capacity testing or throughput testing, is a test
    that determines how many concurrent users can access our service. It may sound
    the same as load testing; however, in the case of load testing, we set the number
    of concurrent users (throughput) to a given number, check the response time (latency),
    and make the build fail if the limit is exceeded. During stress testing, however,
    we keep the latency constant and increase the throughput to discover the maximum
    number of concurrent calls when the system is still operable. So the result of
    a stress test may be notification that our system can handle 10,000 concurrent
    users, which helps us prepare for the peak usage time.
  prefs: []
  type: TYPE_NORMAL
- en: Stress testing is not well suited for the Continuous Delivery process, because
    it requires long tests with an increasing number of concurrent requests. It should
    be prepared as a separate script of a separate Jenkins pipeline and triggered
    on demand, when we know that the code change can cause performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scalability testing explains how latency and throughput change when we add more
    servers or services. The perfect characteristic would be linear, which means if
    we have one server and the average request-response time is 500 ms when used by
    100 parallel users, then adding another server would keep the response time the
    same and allow us to add another 100 parallel users. In reality, it's often hard
    to achieve thsi because of keeping data consistency between servers.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability testing should be automated and should provide the graph presenting
    the relationship between the number of machines and the number of concurrent users.
    Such data is helpful in determining the limits of the system and the point at
    which adding more machines does not help.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability tests, similar to stress tests, are hard to put into the Continuous
    Delivery pipeline and should rather be kept separate.
  prefs: []
  type: TYPE_NORMAL
- en: Endurance testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Endurance tests, also called longevity tests, run the system for a long time
    to see if the performance drops after a certain period of time. They detect memory
    leaks and stability issues. Since they require a system running for a long time,
    it doesn't make sense to run them inside the Continuous Delivery pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Security testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security testing deals with different aspects related to security mechanisms
    and data protection. Some security aspects are purely functional requirements
    such as authentication, authorization, or role assignment. These parts should
    be checked the same way as any other functional requirement—during the acceptance
    test phase. There are also other security aspects that are nonfunctional; for
    example, the system should be protected against SQL injection. No client would
    probably specify such a requirement, but it's implicit.
  prefs: []
  type: TYPE_NORMAL
- en: Security tests should be included in Continuous Delivery as a pipeline stage.
    They can be written using the same frameworks as the acceptance tests or with
    dedicated security testing frameworks, for example, BDD security.
  prefs: []
  type: TYPE_NORMAL
- en: Security should also always be a part the explanatory testing process, in which
    testers and security experts detect security holes and add new testing scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintainability tests explain how simple a system is to maintain. In other words,
    they judge code quality. We already have related stages in the commit phase that
    check the test coverage and perform static code analysis. The Sonar tool can also
    give some overview of the code quality and the technical debt.
  prefs: []
  type: TYPE_NORMAL
- en: Recovery testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recovery testing is a technique to determine how quickly the system can recover
    after it crashed because of a software or hardware failure. The best case would
    be if the system does not fail at all, even if a part of its services is down.
    Some companies even perform production failures on purpose to check if they can
    survive a disaster. The best known example is Netflix and their Chaos Monkey tool,
    which randomly terminates random instances of the production environment. Such
    an approach forces engineers to write code that makes systems resilient to failures.
  prefs: []
  type: TYPE_NORMAL
- en: Recovery testing is obviously not part of the Continuous Delivery process, but
    rather a periodic event to check the overall health.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about Chaos Monkey at [https://github.com/Netflix/chaosmonkey](https://github.com/Netflix/chaosmonkey).
  prefs: []
  type: TYPE_NORMAL
- en: There are many more nonfunctional test types, which are closer to or further
    from the code and the Continuous Delivery process. Some of them relate to the
    law such as compliance testing; others are related to the documentation or internationalization.
    There are also usability testings and volume testings (which check whether the
    system behaves well in the case of large amounts of data). Most of these tests,
    however, have no part in the Continuous Delivery process.
  prefs: []
  type: TYPE_NORMAL
- en: Nonfunctional challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nonfunctional aspects pose new challenges to the software development and delivery:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Long test run**: The tests can take a long time to run and may need a special
    execution environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Incremental nature**: It''s hard to set the limit value when the test should
    fail (unless SLA is well defined). Even if the edge limit is set, the application
    would probably incrementally approach the limit. In most cases, actually, no one
    code change caused the test failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vague requirements**: Users usually don''t have much input concerning nonfunctional
    requirements. They may provide some guidelines concerning the request-response
    time or the number of users; however, they won''t probably know much about maintainability,
    security, or scalability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiplicity**: There are a lot of different nonfunctional tests and choosing
    which should be implemented requires making some compromises.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The best approach to address nonfunctional aspects is to take the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make a list of all nonfunctional test types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Cross out explicitly the test you don''t need for your system. There may be
    a lot of reasons you don''t need one kind of test, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The service is super small and a simple performance test is enough
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system is internal only and available only for read-only, so it may not
    need any security checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system is designed for one machine only and does not need any scaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cost of creating certain tests is too high
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Split your tests into two groups:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Continuous Delivery**: It is possible to add it to the pipeline'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analysis**: It is not possible to add to the pipeline because of their execution
    time, their nature, or the associated cost'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the Continuous Delivery group, implement the related pipeline stages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the Analysis group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create automated tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schedule when they should be run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schedule meetings to discuss their results and take action points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A very good approach is to have a nightly build with the long tests that don't
    fit the Continuous Delivery pipeline. Then, it's possible to schedule a weekly
    meeting to monitor and analyze the trends of system performance.
  prefs: []
  type: TYPE_NORMAL
- en: As presented, there are many types of nonfunctional test and they pose additional
    challenges to the delivery process. Nevertheless, for the sake of the stability
    of our system, these tests should never be blankly skipped. The technical implementation
    differs depending on the test type, but in most cases they can be implemented
    in a similar manner to functional acceptance tests and should be run against the
    staging environment.
  prefs: []
  type: TYPE_NORMAL
- en: If you're interested in the topic of nonfunctional testing, system properties,
    and system stability, then read the book *Release It!* by *Michael T. Nygard*.
  prefs: []
  type: TYPE_NORMAL
- en: Application versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, during every Jenkins build, we have created a new Docker image, pushed
    it into the Docker registry, and used the **latest** version throughout the process.
    However, such a solution has at least three disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: If, during the Jenkins build, after the acceptance tests, someone pushes a new
    version of the image, then we can end up releasing the untested version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We always push an image named in the same way; thus, so effectively, it is overwritten
    in the Docker registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's very hard to manage images without versions just by their hashed-style
    IDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the recommended way of managing Docker image versions together with
    the Continuous Delivery process? In this section, we get to see different versioning
    strategies and learn different ways of creating versions in the Jenkins pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different ways to version applications.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss these most popular solutions, which can be applied together with
    the Continuous Delivery process (when each commit creates a new version).
  prefs: []
  type: TYPE_NORMAL
- en: '**Semantic versioning**: The most popular solution is to use sequence-based
    identifiers (usually in the form of x.y.z). This method requires a commit to the
    repository done by Jenkins in order to increase the current version number, which
    is usually stored in the build file. This solution is well supported by Maven,
    Gradle, and other build tools. The identifier usually consists of three numbers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**x**: This is the major version; the software does not need to    be backward-compatible
    when this version is incremented'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**y**: This is the minor version; the software needs to be backward compatible
    when the version is incremented'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**z:** This is the build number; this is sometimes also considered as a backward
    and forward-compatible change'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timestamp**: Using the date and time of the build for the application version
    is less verbose than sequential numbers, but very convenient in the case of the
    Continuous Delivery process, because it does not require committing back to the
    repository by Jenkins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hash**: A randomly generated hash version shares the benefit of the datetime
    and is probably the simplest solution possible. The drawback is that it''s not
    possible to look at two versions and tell which is the latest one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mixed**: There are many variations of the solutions described earlier, for
    example, major and minor versions with the datetime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All solutions are fine to use with the Continuous Delivery process. Semantic
    versioning requires, however, a commit to the repository from the build execution,
    so that the version is increased in the source code repository.
  prefs: []
  type: TYPE_NORMAL
- en: Maven (and the other build tools) popularized version snapshotting, which added
    a suffix SNAPSHOT to the versions that are not released, but kept just for the
    development process. Since Continuous Delivery means releasing every change, there
    are no snapshots.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning in the Jenkins pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described earlier, there are different possibilities when it comes to using
    software versioning and each of them can be implemented in Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let's use the datetime.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use the timestamp information from Jenkins, you need to install
    the Build Timestamp Plugin and set the timestamp format in the Jenkins configuration
    (for example, to "yyyyMMdd-HHmm").
  prefs: []
  type: TYPE_NORMAL
- en: 'In every place where we use the Docker image, we need to add the tag suffix:
    `${BUILD_TIMESTAMP}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `Docker build` stage should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After the changes, when we run the Jenkins build, we should have the image tagged
    with the timestamp version in our Docker registry.
  prefs: []
  type: TYPE_NORMAL
- en: Note that after explicitly tagging the image, it's no longer implicitly tagged
    as the latest.
  prefs: []
  type: TYPE_NORMAL
- en: With versioning completed, we are finally ready to complete the Continuous Delivery
    pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Complete Continuous Delivery pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After discussing all the aspects of Ansible, environments, nonfunctional testing,
    and versioning, we are ready to extend the Jenkins pipeline and finalize a simple,
    but complete, Continuous Delivery pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will do it in a few steps as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the inventory of staging and production environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update acceptance tests to use the remote host (instead of local)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release the application to the production environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a smoke test which makes sure the application was successfully released
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inventory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In their simplest form, we can have two environments: staging and production,
    each having one Docker host machine. In real life, we may want to add more host
    groups for each environment if we want to have servers in different locations
    or having different requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create two Ansible inventory files. Starting from the staging, we can
    define the `inventory/staging` file. Assuming the staging address is `192.168.0.241`,
    it would have the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'By analogy, if the production IP address is `192.168.0.242`, then the `inventory/production` should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It may look oversimplified to have just one machine for each environment; however,
    using Docker Swarm (which we show later in this book), a cluster of hosts can
    be hidden behind one Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: Having the inventory defined, we can change acceptance testing to use the staging
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance testing environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Depending on our needs, we could test the application by running it on the
    local Docker host (like we did in the previous chapter) or using the remote staging
    environment. The former solution is closer to what happens in production, so it
    can be considered as a better one. This is very close to what was presented in
    the *Method 1: Jenkins-first acceptance testing* section of the previous chapter.
    The only difference is that now we deploy the application on a remote Docker host.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to do this, we could use `docker` (or the `docker-compose` command)
    with the `-H` parameter, which specifies the remote Docker host address. This
    would be a good solution and if you don't plan to use Ansible or any other configuration
    management tool, then that is the way to go. Nevertheless, for the reasons already
    mentioned in this chapter, it is beneficial to use Ansible. In that case, we can
    use the `ansible-playbook` command inside the Continuous Delivery pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If `playbook.yml` and docker-compose.yml look the same as in the *Ansible with
    Docker* section, then it should be enough to deploy the application with dependencies
    into the staging environment.
  prefs: []
  type: TYPE_NORMAL
- en: The `Acceptance test` stage looks exactly the same as in the previous chapter.
    The only adjustment can be the hostname of the staging environment (or its load
    balancer). It's also possible to add stages for performance testing or other nonfunctional
    tests against the application running on the staging environment.
  prefs: []
  type: TYPE_NORMAL
- en: After all tests are passed, it's high time to release the application.
  prefs: []
  type: TYPE_NORMAL
- en: Release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The production environment should be as close to the staging environment as
    possible. The Jenkins step for the release should also be very similar to the
    stage that deploys the application to the staging environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the simplest scenario, the only differences are the inventory file and the
    application configuration (for example, in case of a Spring Boot application,
    we would set a different Spring profile, which results in taking a different properties
    file). In our case, there are no application properties, so the only difference
    is the inventory file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In reality, the release step can be a little more complex if we want to provide
    zero downtime deployment. More on that topic is presented in the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: After the release is done, we might think that everything is completed; however,
    there is one more missing stage, a smoke test.
  prefs: []
  type: TYPE_NORMAL
- en: Smoke testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A smoke test is a very small subset of acceptance tests whose only purpose is
    to check that the release process is completed successfully. Otherwise, we could
    have a situation in which the application is perfectly fine; however, there is
    an issue in the release process, so we may end up with a non-working production.
  prefs: []
  type: TYPE_NORMAL
- en: 'The smoke test is usually defined in the same way as the acceptance test. So
    the `Smoke test` stage in the pipeline should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After everything is set up, the Continuous Delivery build should run automatically
    and the application should be released to production. With this step, we have
    completed the Continuous Delivery pipeline in its simplest, but fully productive,
    form.
  prefs: []
  type: TYPE_NORMAL
- en: Complete Jenkinsfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To sum up, throughout the recent chapters we have created quite a few stages,
    which results in a complete Continuous Delivery pipeline that could be successfully
    used in many projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we see the complete Jenkins file for the calculator project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can find this Jenkinsfile on GitHub at [https://github.com/leszko/calculator/blob/master/Jenkinsfile](https://github.com/leszko/calculator/blob/master/Jenkinsfile).
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have covered a lot of new aspects for the Continuous Delivery
    pipeline; to better understand the concept, we recommend you perform the following
    exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a performance test, which tests the "hello world" service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The "hello world" service can be taken from the previous chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `performance_test.sh`  script, which makes 100 calls in parallel and
    checks whether the average request-response time is below 1 second
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use Cucumber or the `curl` command for the script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a Jenkins pipeline that builds the "hello world" web service as a versioned
    Docker image and performs performance test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `Docker build` stage, which builds the Docker image with the "hello
    world" service and adds a timestamp as a version tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an Ansible playbook that uses the Docker image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the `Deploy to staging` stage, which deploys the image into the remote machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the `Performance testing` stage, which executes `performance_test.sh`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the pipeline and observe the results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have completed the Continuous Delivery pipeline, which
    finally releases the application. The following are the key takeaways from the
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purpose of Continuous Delivery, two environments are indispensable:
    staging and production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nonfunctional tests are an essential part of the Continuous Delivery process
    and should always be considered as pipeline stages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nonfunctional tests that don't fit the Continuous Delivery process should be
    considered as periodic tasks in order to monitor the overall performance trends.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications should always be versioned; however, the versioning strategy depends
    on the type of the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The minimal Continuous Delivery pipeline can be implemented as a sequence of
    scripts that ends with two stages: release and smoke test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The smoke test should always be added as the last stage of the Continuous Delivery
    pipeline in order to check whether the release was successful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will have a look at the Docker Swarm tool, which helps
    us to create a cluster of Docker hosts.
  prefs: []
  type: TYPE_NORMAL
