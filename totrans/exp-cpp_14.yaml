- en: Networking and Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network programming is becoming more and more popular. Most computers are connected
    to the internet, and more and more applications now rely on that. From simple
    program updates that might require an internet connection to applications that
    rely on a stable internet connection, network programming is becoming a necessary
    part of application development.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ language did not have support for networking until recent standard updates.
    Networking support has been postponed later standards, most probably until C++23\.
    However, we can prepare for that release beforehand by tackling a network application.
    We will also discuss the standard extension for networking and see what will it look
    like to have networking supported in the language. This chapter will concentrate
    on the main principles of networking and the protocols driving communication between
    devices. Designing a network application is a great addition to your skillset
    as a programmer.
  prefs: []
  type: TYPE_NORMAL
- en: One of the major problems developers face regularly is the security of applications.
    Whether it's related to the input data being processed or coding with proven patterns
    and practices, the security of the application must be the number-one priority.
    It's especially important for network applications. In this chapter, we will also
    delve into techniques and best practices for secure programming in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to computer networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sockets and socket programming in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a network application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding security issues in C++ programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging secure programming techniques in project development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The g++ compiler, along with the `-std=c++2a` option, will be used to compile
    the examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source files for this chapter at [https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Discovering network programming in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two computers interact together using networks. Computers connect to the internet
    using a special hardware component called a **network adapter** or a **network
    interface controller**. The operating system installed on the computer provides
    drivers to work with the network adapter; that is, to support network communications
    the computer must have a network adapter installed with an OS that supports the
    networking stack. By stack, we mean the layers of modifications that the piece
    of data goes through when traveling from one computer to another. For example,
    opening a website on a browser renders data that's been gathered through the network.
    That data is received as a sequence of zeros and ones and then transformed into
    a form that's more intelligible to the web browser. Layering is essential in networking.
    Network communication as we know it today consists of several layers conforming
    to the OSI model we'll discuss here. The network interface controller is a hardware
    component that supports the physical and data link layers of the **Open System
    Interconnection** (**OSI**) model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The OSI model aims to standardize communication functions between a wide range
    of devices. Devices differ in structure and organization. This relates to both
    hardware and software. For example, a smartphone using an Intel CPU running an
    Android OS is different from a MacBook computer running a macOS Catalina. The
    difference is not the names and companies behind the aforementioned products,
    but the structure and organization of hardware and software. To eliminate the
    differences in network communication, a set of standardized protocols and intercommunication
    functions is proposed as the OSI model. The layers that we mentioned earlier are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Application layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presentation layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Session layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transport layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data-link layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A more simplified model includes the following four layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application**: This processes the details of the particular application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transport**: This provides data transmission between two hosts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network**:This handles the transferal of packets around the network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Link**: This includes the device driver in the operating system, along with
    the network adapter inside the computer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The link (or data-link) layer includes the device driver in the operating system,
    along with the network adapter in the computer.
  prefs: []
  type: TYPE_NORMAL
- en: To understand these layers, let's suppose you are using a desktop application
    for messaging such as *Skype* or *Telegram*. When you type in a message and hit
    the send button, the message goes through the network to its destination. In this
    scenario, let's suppose you are sending a text message to your friend who has
    the same application installed on their computer. This might seem simple from
    a high-level perspective, but the process is sophisticated and even the simplest
    message undergoes a lot of transformations before reaching its destination. First
    of all, when you hit the send button, the text message gets converted into binary
    form. The network adapter operates with binaries. Its basic function is to send
    and receive binary data through the medium. Besides the actual data that's sent
    over the network, the network adapter should know the destination address of the
    data. The destination address is one of many properties that's appended to user
    data. By user data, we mean the text that you typed and sent to your friend. The
    destination address is the unique address of your friend's computer. The typed
    text is packaged with the destination address and other information that's necessary
    for it to be sent to its target. Your friend's computer (including the network
    adapter, OS, and the messaging application) receives and unpackages the data.
    The text contained in that package is then rendered on the screen by the messaging
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Almost every OSI layer mentioned at the beginning of this chapter adds its
    specific header to the data that''s sent over the network. The following diagram
    depicts how the data from the application layer gets stacked with headers before
    it''s moved to its destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a757ca62-f6cd-41ca-a522-d59b4bb81220.png)'
  prefs: []
  type: TYPE_IMG
- en: OSI model
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the first line (the **Application Layer**) in the preceding diagram.
    The **Data** is the text that you've typed into the messaging application in order
    to send it to your friend. In each layer, all the way down to the **Physical Layer**,
    the data is packaged with headers specific to each layer of the OSI model. The
    computer on the other side receives and retrieves the packaged data. In each layer,
    it removes the header specific to that layer and moves the rest of the package
    up to the next layer. Finally, the data reaches your friend's messaging application.
  prefs: []
  type: TYPE_NORMAL
- en: As programmers, we are mostly concerned with writing applications that are able
    to send and receive data over a network without delving into the details of the
    layers. However, we need a minimal understanding of how layers augment data on
    higher levels with headers. Let's learn how a network application works in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Network applications under the hood
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A network application installed on a device communicates with other applications
    installed on other devices through the network. In this chapter, we''ll discuss
    applications working together through the internet. A high-level overview of this
    communication can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e256446-4904-4374-be81-67b37eae5d24.png)'
  prefs: []
  type: TYPE_IMG
- en: At the lowest level of communication is the physical layer, which transmits
    bits of data through the medium. A medium, in this case, is the network cable
    (consider Wi-Fi communication too). The user application abstracts from the lower
    levels of network communication. Everything a programmer needs is provided by
    the operating system. The operating system implements the low-level details of
    the network communication, such as the **Transmission Control Protocol**/**Internet
    Protocol **(**TCP**/**IP**) suite.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever an application needs to access the network, whether it's a local area
    network or the internet, it requests the operating system to provide an access
    point. The OS manages to provide a gateway to the network by utilizing a network
    adapter and specific software that speaks to the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more detailed illustration of this looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/000a23f6-9ba9-4102-8fe3-88292e377065.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The operating system provides an API to work with its networking subsystem.
    The main abstraction that programmers should care about is the socket. We can
    treat a socket as a file that sends its contents through the network adapter.
    Sockets are the access points that connect two computers via the network, as depicted
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26dbd171-672b-494d-b565-81f297597189.png)'
  prefs: []
  type: TYPE_IMG
- en: From the programmer's perspective, the socket is a structure that allows us
    to implement data through the network in applications. The socket is a connection
    point that either sends or receives data; that is, an application receives data
    via sockets too. The operating system provides a socket for the application upon
    request. An application can have more than one socket. Client applications in
    the client-server architecture usually operate with a single socket. Now, let's
    delve into socket programming in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Programming network applications using sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned previously, a socket is an abstraction over network communication.
    We treat them as regular files – everything written to a socket is sent via the
    network to its destination by the operating system. Everything that is received
    via the network is written into the socket – again, by the operating system. This
    way, the OS provides two-way communication for network applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose that we run two different applications working with the network.
    For example, we open a web browser to surf the web and use a messaging application
    (such as Skype) to chat with friends. The web browser represents a client application
    in a client-server network architecture. The server, in this case, is the computer
    that responds with the requested data. For example, we type an address into the
    address bar of the web browser and see the resulting web page on the screen. Whenever
    we visit a website, the web browser requests a socket from the operating system.
    In terms of coding, the web browser creates a socket using the API provided by
    the OS. We can describe the socket with a more specific prefix: a client socket.
    For the server to process client requests, the computer running the web server
    must listen for incoming connections; that is, the server application creates
    a server socket intended to listen to connections.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever a connection is established between the client and server, data communication
    can proceed. The following diagram depicts a web browser request to **facebook.com**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/025167ab-52c6-40b9-a864-ee63f96cdb67.png)'
  prefs: []
  type: TYPE_IMG
- en: Pay attention to the group of numbers in the preceding diagram. This is called
    an **Internet Protocol** (**IP**) **address**. The IP address is the location
    that we need in order to transfer data to the device. There are billions of devices
    connected to the internet. To make a unique distinction between them, each device
    exposes a unique numeric value representing its address. A connection is established
    using the IP protocol, which is why we call it an IP address. An IP address consists
    of four groups of 1-byte length numbers. Its dotted-decimal representation is
    in the form X.X.X.X, where X is the 1-byte number. The values at each position
    range from 0 to 255. More specifically, it's a version 4 IP address. Modern systems
    use a version 6 address, which is a combination of numbers and letters, providing
    a wider range of available address values.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a socket, we assign the IP address of the local computer to it;
    that is, we're binding the socket to the address. When using the socket to send
    data to another device in the network, we should set its destination address.
    The destination address is held by another socket on that device. To create a
    connection between two devices, we use two sockets. A reasonable question might
    arise— What if there are several applications running on the device? What if we
    run several applications, each of which has created a socket for itself? Which
    one should receive the incoming data?
  prefs: []
  type: TYPE_NORMAL
- en: To answer these questions, take a good look at the preceding diagram. You should
    see a number after the colon at the end of the IP address. That's called the **port
    number**. The port number is a 2-byte length number that's assigned to the socket
    by the operating system. Because of the 2-byte length limit, the OS cannot assign
    more than 65,536 unique port numbers to sockets; that is, you cannot have more
    than 65,536 simultaneous running processes or threads communicating via the network
    (however, there are ways to reuse sockets). Apart from that, there are port numbers
    that are reserved for specific applications. These ports are called well-known
    ports and range from 0 to 1023\. They are reserved for privileged services. For
    example, the HTTP server's port number is 80\. That doesn't mean it can't use
    other ports.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn how to create a socket in C++. We will design a wrapper class that
    encapsulates **Portable Operating System Interface** (**POSIX**) sockets, also
    known as **Berkeley** or **BSD** sockets. It has a standard set of functions for
    socket programming. The C++ extension for network programming will be a tremendous
    addition to the language. The working draft contains information on the networking
    interface. We will discuss this later in this chapter. Before that, let's try
    to create our own networking wrappers for existing and low-level libraries. When
    we use POSIX sockets, we depend on the operating system's API. The OS provides
    an API that represents the functions and objects that are used to create sockets,
    send and receive data, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'POSIX represents a socket as a file descriptor. We use it almost as if it were
    a regular file. File descriptors follow the UNIX philosophy of providing a common
    interface to data input/output. The following code creates a socket using the
    `socket()` function (defined in the `<sys/socket.h>` header):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The declaration of the `socket()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, `AF_INET`, `SOCK_STREAM`, and `IPPROTO_TCP` are numeric values. The domain
    parameter specifies the protocol family of the socket. We use `AF_INET` to specify
    the IPv4 protocol. For IPv6, we use `AF_INET6`. The second parameter specifies
    the type of the socket, that is, whether it's a stream-oriented or datagram socket.
    For each specific type, the last parameter should be specified accordingly. In
    the preceding example, we specified `SOCK_STREAM` with `IPPROTO_TCP`. The **Transmission
    Control Protocol** (**TCP**) represents a reliable stream-oriented protocol. This
    is why we set the type parameter to `SOCK_STREAM`. Before we implement a simple
    socket application, let's find out more about network protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Network protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A network protocol is a collection of rules and data formats that define intercommunication
    between applications. For example, a web browser and a web server communicate
    via **Hyper-Text Transfer Protocol** (**HTTP**). HTTP is more like a set of rules than
    a transport protocol. Transport protocols are at the base of every network communication.
    An example of a transport protocol would be TCP. When we mentioned the TCP/IP
    suite, we meant the implementation of TCP over IP. We can consider the **Internet
    Protocol** (**IP**) as the heart of internet communications.
  prefs: []
  type: TYPE_NORMAL
- en: 'It provides host-to-host routing and addressing. Everything that we send or
    receive via the internet is packaged as an *IP packet*. The following is what
    the IPv4 packet looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/947b4431-3e7b-4324-a92c-42a6140bcb04.png)'
  prefs: []
  type: TYPE_IMG
- en: The IP header weighs 20 bytes. It combines necessary flags and options for delivering
    a packet from the source address to the destination address. In the domain of
    the IP protocol, we usually call a packet a datagram. Each layer has its specific
    terms for packets. More careful specialists talk about encapsulating TCP segments
    into IP datagrams. It's totally fine to call them packets*.*
  prefs: []
  type: TYPE_NORMAL
- en: Each protocol at the higher level appends meta-information to the data that's
    sent and received via the network; for example, TCP data is encapsulated in an
    IP datagram. Besides this meta-information, the protocol also defines the underlying
    rules and operations that should be performed to complete a data transfer between
    two and more devices.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more detailed information in specific documents called **Request
    for Comments **(**RFCs**). For example, RFC 791 describes the Internet Protocol,
    while RFC 793 describes the Transmission Control Protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Many popular applications – file transfer, email, web, and others – use TCP
    as their main transport protocol. For example, the HTTP protocol defines the format
    of the messages that are transferred from the client to the server and vice versa.
    The actual transfer happens using a transport protocol – in this case, TCP. However,
    the HTTP standard doesn't limit TCP to being the only transport protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the TCP header being appended to the data
    before passing it to the lower level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84ddead5-264a-4848-8552-5bc1e8c1986f.png)'
  prefs: []
  type: TYPE_IMG
- en: Pay attention to the source port number and destination port number. Those are
    the unique identifiers that differentiate between running processes in operating
    systems. Also, take a look at the sequence and acknowledgment numbers. They are
    TCP-specific and used for transmission reliability.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, TCP is used due to its following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Retransmission of lost data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In-order delivery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data integrity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Congestion control and avoidance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IP**(short for Internet Protocol) is not reliable. It doesn''t care for lost
    packets, which is why TCP handles the retransmission of lost packets. It marks
    each packet with a unique identifier that should be acknowledged by the other
    side of the transmission. If the sender does not receive an **acknowledgment code** (**ACK**)
    for a packet, the protocol will resend the packet (a limited number of times).
    It is also crucial to receive packets in the proper order. TCP reorders received
    packets to represent correctly ordered information. That''s why, when listening
    to music online, we don''t listen to the end of the song at its beginning.'
  prefs: []
  type: TYPE_NORMAL
- en: Retransmission of packets might lead to another problem known as **network congestion**.
    This happens when a node doesn't manage to send packets fast enough. Packets get
    stuck for a while and unnecessary retransmission increases their number. Various
    implementations of TCP employ algorithms for congestion avoidance.
  prefs: []
  type: TYPE_NORMAL
- en: It maintains a congestion window – a factor that determines the amount of data
    that can be sent out. Using the slow-start mechanism, TCP slowly increases the
    congestion window after initializing the connection. Though the protocol is described
    in the corresponding **Request for Comments** (**RFC**), there are plenty of mechanisms
    that are implemented differently in operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: On the other side of the fence is the **User Datagram Protocol** (**UDP**).
    The main difference between these two is that TCP is reliable. This means that,
    in the case of lost network packets, it resends the same packet until it reaches
    its designated destination. Because of its reliability, data transmissions via
    TCP are considered to take longer than using UDP. UDP doesn't guarantee we can
    deliver packets properly and without losses. Instead, developers should take care
    of resending, checking, and verifying the data transmission. Applications that
    require fast communication tend to rely on UDP. For example, a video call application
    or an online game uses UDP because of its speed. Even if a couple of packets get
    lost during the transmission, it won't affect the user experience. It's better
    to have small glitches while playing a game or talking to a friend in a video
    chat than to wait seconds for the next frame of the game or video.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the main reasons why TCP is slower than UDP is the bigger number of
    steps in the connection initiation procedure for TCP. The following diagram shows
    the process of connection establishment in TCP, also known as the three-way handshake:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/297eb191-d103-4058-b238-d114d4404673.png)'
  prefs: []
  type: TYPE_IMG
- en: The client picks a random number when sending a `SYN` packet to the server.
    The server increments that random number by one, picks another random number,
    and replies with a `SYN-ACK` packet. The client increments both numbers received
    from the server by one and completes the handshake by sending the last `ACK` to
    the server. After the three-way handshake is successfully completed, the client
    and server can transfer packets to each other. This connection establishment process
    applies to every TCP connection. Details of the handshake are hidden from the
    developers of network applications. We create the socket and start listening to
    incoming connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the difference between the two types of endpoint. One of them is the
    client. When implementing a network application, we should make a clear distinction
    between the client and the server because they have different implementations.
    This relates to the type of sockets as well. When creating a server socket, we
    are making it listen to incoming connections, while the client doesn''t listen
    – it makes requests. The following diagram depicts certain functions and their
    invocation sequence for the client and server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abc95252-99b1-40e7-8518-218dab92e194.png)'
  prefs: []
  type: TYPE_IMG
- en: When creating a socket in code, we specify the protocol and the type of the socket.
    When we want a reliable connection between two endpoints, we choose TCP. The interesting
    thing is that we can use a transport protocol such as TCP to build our own protocol.
    Let's say we define a special document format to send and receive in order to
    treat the communication valid. For example, each document should start with the
    word PACKT. HTTP works the same way. It uses TCP for transport and defines a communication
    format over it. In the case of UDP, we should also design and implement a reliability
    strategy for communication. The preceding diagram shows how TCP establishes a
    connection between two endpoints. The client sends a `SYN` request to the server.
    The server answers with the `SYN-ACK` response, letting the client know that it's
    fine to continue the handshake. Finally, the client answers with an `ACK` to the
    server stating the connection is officially established. They can communicate
    as long as they want.
  prefs: []
  type: TYPE_NORMAL
- en: '**Synchronize** (**SYN**) and ACK are protocol-defined terms that have become
    common in network programming.'
  prefs: []
  type: TYPE_NORMAL
- en: UDP doesn't work this way. It sends data to the destination without worrying
    about an established connection. If you use UDP but need some reliability, you
    should implement it by yourself; for example, by checking whether a portion of
    data reached the destination. To check it, you can wait for the destination to
    answer with a custom-defined `ACK` packet. Most reliability-oriented implementations
    might repeat already existing protocols, such as TCP. However, there are many
    scenarios where you don't need them; for example, you don't need congestion avoidance
    because you don't need to send the same packet twice.
  prefs: []
  type: TYPE_NORMAL
- en: We designed a strategy game in the previous chapter. Suppose the game is online
    and you are playing with a real opponent instead of an automated enemy player.
    Each frame of the game is rendered based on the data that's received across the
    network. If we put some effort into making the data transfer reliable, increasing
    the data integrity, and making sure none of the packets are lost, the user experience
    may be hurt because of the desynchronization of players. This scenario is good
    for using UDP. We can implement data transfer without a retransmission strategy
    so that we squeeze the speed of the game. Of course, using UDP doesn't force us
    to avoid reliability. In the same scenario, we might need to make sure the packet
    is received successfully by the player. For example, when the player surrenders,
    we should make sure the opponent receives the message. So, we can have conditional
    reliability based on packet priority of. UDP provides flexibility and speed in
    network applications.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at an implementation of a TCP server application.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a network application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The approach of designing an application with a small subsystem that requires
    a network connection is different compared to a fully network-related application.
    An example of the latter might be a client-server application for file storage
    and synchronization (such as Dropbox). It consists of a server and clients, where
    the client is installed as a desktop or mobile application that can also be used
    as a file explorer. Each update to the files in the system controlled by Dropbox
    will be instantly synchronized with the server. This way, you will always have
    your files in the cloud and can access them anywhere with an internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be designing a similar simplified server application for file storage
    and manipulation. The following are the main tasks of the server:'
  prefs: []
  type: TYPE_NORMAL
- en: Receive files from client applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store files at specified locations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send files to clients upon request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Referring to [Chapter 10](069ab9af-21a4-4b8c-bc3f-f7bc0d9e4712.xhtml), *Designing
    World-Ready Applications*, we can move forward to the following top-level design
    of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45a77bf5-8c18-40ec-9537-129401650f37.png)'
  prefs: []
  type: TYPE_IMG
- en: Each of the rectangles in the preceding diagram represents a class or a collection
    of classes concerned with specific tasks. For example, the **Storage Manager**
    handles everything related to storing and retrieving files. Whether it uses classes
    such as a file, location, database, and so on does not concern us that much at
    this point.
  prefs: []
  type: TYPE_NORMAL
- en: The **Client Manager** is a class or a group of classes that represent handling
    everything related to authenticating or authorizing clients (by client, we mean
    a client application), keeping steady connections with clients, receiving files
    from clients, sending files to clients, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We specifically emphasized **Networking** as an entity of interest in this chapter.
    Everything that relates to a network connection, along with data transfers from
    and to clients, is handled via **Networking**. Now, let's see what functionality
    we can use to design the Networking class (we will call it Network Manager for
    convenience).
  prefs: []
  type: TYPE_NORMAL
- en: Using POSIX sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned previously, functions such as `socket()`, `bind()`, and `accept()`
    are library functions that are supported by default in most Unix systems. Previously,
    we included the `<sys/socket.h>` file. Besides that, we will need several other
    header files. Let's implement the classic TCP server example and wrap it in the
    Networking module for our file transfer application server.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned previously, server-side development differs from client-side
    development in terms of the type of socket and its behavior. Although both sides
    operate with sockets, the server-side socket is continuously listening for incoming
    connections, while the client-side socket initiates a connection with the server.
    For the server socket to wait for connections, we create a socket and bind it
    to the server IP address and a port number that clients will try to connect to.
    The following C code represents the creation and binding of a TCP server socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first call creates a socket. The third parameter is set to 0, meaning that
    the default protocol will be selected based on the type of the socket. The type
    is passed as the second parameter, `SOCK_STREAM`, which makes the protocol value
    equal to `IPPROTO_TCP` by default. The `bind()` function binds the socket with
    the specified IP address and port number. We specified them in the `sockaddr_in`
    structure, which combines network address-related details in it.
  prefs: []
  type: TYPE_NORMAL
- en: Although we skipped this in the preceding code, you should consider checking
    the calls to `socket()` and `bind()` functions (and other functions in POSIX sockets)
    against errors. Almost all of them return `-1` in the event of an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note the `htons()` function. It takes care of converting its arguments
    into network byte order. The problem is hidden in the way computers are designed.
    Some machines (Intel microprocessors, for example) use **little-endian** byte
    ordering, while others use **big-endian** ordering. **Little-endian** ordering
    places the least significant byte first. **Big-endian** ordering places the most
    significant byte first. The following diagram shows the difference between the
    two:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16478fe6-bab4-4ef2-9d55-9473870f4425.png)'
  prefs: []
  type: TYPE_IMG
- en: The network byte order is a convention independent of specific machine architectures.
    The `htons()` function converts the provided port number from host byte order
    (**little-** or **big-endian**) into network byte order (independent from the
    machine).
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it – the socket is ready. Now, we should specify that it is ready for
    incoming connections. To specify that, we use the `listen()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As its name suggests, it listens for incoming connections. The second argument
    that's passed to the `listen()` function specifies the number of connections that
    the server will queue before discarding new incoming requests. In the preceding
    code, we specified `5` as the maximum number. In a high-load environment, we would
    increase this number. The maximum number is specified by the `SOMAXCONN` constant
    defined in the `<sys/socket.h>` header.
  prefs: []
  type: TYPE_NORMAL
- en: 'The choice of backlog number (the second parameter of the `listen()` function)
    is based on factors such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If the rate of the connection requests is high for a short period of time, the
    backlog number should have a larger value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The duration of the server handles an incoming connection. The shorter the time,
    the smaller the backlog value will be.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When a connection initiation is happening, we can either to drop it or accept
    it and continue processing the connection. That''s why we use the `accept()` function
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The two things to consider in the preceding code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the accepted socket connection information is written into the client's `sockaddr_in`
    structure. We can gather everything necessary about the client from that struct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, pay attention to the return value of the `accept()` function. It's a new
    socket that's created to handle requests from that particular client. The next
    call to the `accept()` function will return another value that will represent
    another client with a separate connection. We should handle this properly because
    the `accept()` call is blocking; that is, it waits for new connection requests.
    We will modify the preceding code so that it accepts multiple connections being
    handled in separate threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last line with the comment in the preceding code states that `new_socket`
    can be used to receive or send data to the client. Let''s see how we can achieve
    this and then start designing our `Networking` class. To read the data that''s
    received by the socket, we need to use the `recv()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `recv()` function takes a `char*` buffer to write data into it. It stops
    writing at `sizeof(buffer)`. The last parameter of the function is the additional
    flag we can set for reading. You should consider calling the function several
    times to read bigger than the `BUFFER_MAX_SIZE` data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to send data over the socket, we call the `send()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With that, we've covered almost all the functions that are required to implement
    a server application. Now, let's wrap them in a C++ class and incorporate multithreading
    so that we can process client requests concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a POSIX socket wrapper class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s design and implement a class that will serve as the starting point for
    network-based applications. The main interface of the class looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It's natural for the `Networking` class to be a singleton because we want a
    single instance to listen for incoming connections. It's also important to have
    multiple objects, each of which represents a separate connection with a client.
    Let's gradually make the class design better. Earlier, we saw that each new client
    socket is created after the server socket listens to and then accepts a connection
    request.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we can send or receive data through that new client socket. The
    server operates similarly to what can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d1c32ac-afd0-44be-a927-e1e391ec20c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That is, after accepting each incoming connection, we will have one separate
    socket for a connection. We store them in the `clients_` vector in the `Networking`
    class. Therefore, we can write the main logic of creating a server socket, listening,
    and accepting new connections in a single function that can work concurrently
    if required. The `start_server()` function serves as the starting point for the
    server to listen for incoming connections. The following code block illustrates
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, we've stopped at a point where we should accept incoming connections (see
    the comment in the preceding code snippet). We have two choices here (actually,
    there are more than two choices, but we will only discuss two of them). We can
    either place the call to `accept()` directly into the `start_server()` function
    or we can implement a separate function that the `Networking` class user will
    call whenever applicable.
  prefs: []
  type: TYPE_NORMAL
- en: It's not a bad practice to have specific exception classes for each error case
    that we have in the project. The preceding code might be rewritten when considering
    custom exceptions. You can do that as a homework project.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the choices has the `accept()` function in the `start_server()` function,
    which pushes each new connection into the `clients_` vector, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, we used an infinite loop. This may sound awful, but as long as the server
    is running, it must accept new connections. However, we all know that the infinite
    loop blocks the execution of code; that is, it won''t ever leave the `start_server()`
    function. We introduced our network application as a project that has at least
    three components: the Client Manager, the Storage Manager, and the one we are
    designing right now – the `Networking` class.'
  prefs: []
  type: TYPE_NORMAL
- en: The execution of one component must not affect the others in a bad way; that
    is, we can use threads to make some components run in the background. The `start_server()`
    function running in the context of a thread is a nice solution, although we should
    now care about the synchronization issues we covered in [Chapter 8](fc8fb840-e179-4725-9e44-403b63be460d.xhtml)*,
    Concurrency and Multithreading*.
  prefs: []
  type: TYPE_NORMAL
- en: Also, pay attention to the incompleteness of the preceding loop. After accepting
    a connection, it pushes the client data into the `clients_` vector. We should
    consider using another structure for that as we also need to store the socket
    descriptor, along with the client. We can use `std::undordered_map` to map the
    socket descriptor to the client connection information, but a simple `std::pair`
    or `std::tuple` would be fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, let''s go even further and create a custom object representing the
    client connection, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will modify the `Networking` class so that it stores a vector of `Client`
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can change the design approach and make the `Client` object responsible
    for sending and receiving data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Even better, we can attach an `std::thread` object to the `Client` class so
    that each object handles data transfer in a separate thread. However, you should
    be careful not to starve the system. The number of incoming connections can increase
    drastically and the server application will become stuck. We will discuss this
    scenario in the next section when we discuss security issues. It's suggested you
    leverage thread pools that will both help us reuse threads and keep control over
    the number of threads running in the program.
  prefs: []
  type: TYPE_NORMAL
- en: The final design of the class depends on the type of data that we receive and
    send to the client. There are at least two different approaches. One of them is
    connecting to the client, receiving the necessary data, and shutting down the
    connection. The second approach is implementing a protocol by which the client
    and server will communicate. Although it sounds complex, the protocol might be
    simple.
  prefs: []
  type: TYPE_NORMAL
- en: It's also extensible and makes the application more robust because you can support
    more features as the project evolves. We will get back to designing the protocol
    for authenticating client requests in the next section, when we discuss how to
    secure the network server application.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the C++ code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compared to many languages, C++ is a little harder to master in terms of secure
    coding. There are plenty of guidelines that provide advice regarding how to and
    how not to avoid security risks in C++ programs. One of the most popular issues
    that we discussed in [Chapter 1](2297d785-7242-4149-8b31-f9af1fcdd833.xhtml), *Building
    C++ Applications*, is using preprocessor macros. The example we used had the following
    macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Improper use of this macro leads to logic errors that are hard to spot. In
    the following code, the programmer expects to get `16` printed to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is `7`. The issue here is with the missing parentheses around the
    `arg` parameter; that is, the preceding macro should be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this example is popular, we strongly suggest avoiding macros as much
    as possible. C++ provides plenty of constructs that can be processed at compile
    time, such as `constexpr`, `consteval`, and `constinit` – even if statements have
    a `constexpr` alternative. Use them if you need compile-time processing in your
    code. And, of course, there are modules, a long-awaited addition to the language.
    You should prefer using modules everywhere you used an `#include` with ubiquitous
    include guards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It's not only more secure, but also more efficient because modules are processed
    once (we can consider them as precompiled headers).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we don''t want you to become paranoid about for security issues, you
    should be careful almost everywhere. You will avoid most of these issues by learning
    the language''s quirks and oddities. Also, a good practice would be to use the
    newest features that replace or fix the disadvantages of previous versions. For
    example, consider the following `create_array()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The caller of the `create_array()` function is left with a pointer to the non-existing
    array because `arr` has an automatic storage duration. We can replace the preceding
    code with a better alternative if required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings are treated as character arrays and are the reason behind many buffer
    overflow issues. One of the most popular issues is writing data into a string
    buffer while ignoring its size. The `std::string` class is a safer alternative
    to C strings in that regard. However, when supporting legacy code, you should
    be careful when using functions such as `strcpy()`, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that, legally, `small_buffer` should have a null-terminator at the end
    of it, it will only cope with the first three characters of the `long_text` string.
    However, the following happens after calling `strcpy()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e5109ce-bee4-4c01-b755-126f953aacc8.png)'
  prefs: []
  type: TYPE_IMG
- en: You should be even more careful when implementing network applications. Most
    data coming from client connections should be handled properly, and buffer overflows
    are not rare. Let's learn how to make network applications more secure.
  prefs: []
  type: TYPE_NORMAL
- en: Securing network applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section of this book, we designed a network application that
    receives client data using socket connections. Besides the fact that most viruses
    that penetrate the system are from the outside world, network applications have
    this natural tendency to open up the computer to various threats on the internet.
    First of all, whenever you are running a network application, an open port exists
    in the system. Someone who knows the exact port that your application is listening
    on can intrude by faking protocol data. We will mostly discuss the server-side
    of network applications here; however, some of the topics here apply to client
    applications as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the first things you should do is incorporate client authorization and
    authentication. These are two terms that are easy to confuse. Be careful not to
    use them interchangeably; they are different:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication** is the process of validating client access. It means that
    not every incoming connection request is served right away. Before transferring
    data to and from the client, the server application must be sure that the client
    is a known client. In almost the same way we access a social network platform
    by typing in our email and password, the authentication of a client defines whether
    the client has the right to access the system at all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**, on the other hand, defines what exactly the client can do
    in the system. It''s a set of permissions that are provided to specific clients.
    For instance, the client application we discussed in the previous section is able
    to upload files to the system. Sooner or later, you might want to incorporate
    paid subscriptions and provide paying clients with a wider range of features;
    for example, by allowing them to create folders to organize their files. So, when
    a client requests a folder''s creation, we might want to authorize the request
    to discover if the client has the right to do so.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the client application initiates a connection with the server, all the
    server gets is the connection details (IP address, port number). To let the server
    know who is behind the client application (the actual user), the client application
    sends over the user's credentials. Usually, this process involves sending the
    user a unique identifier (such as a username or email address) with the password
    to access the system. The server then checks these credentials against its database
    and verifies whether it should grant access to the client. This form of communication
    between the client and the server might be a simple text transfer or a formatted
    object transfer.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the protocol that''s defined by the server might require the client
    to send a **JavaScript Object Notation** (**JSON**) document in the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The response from the server allows the client to proceed further or update
    its UI to let the user know the result of the operation. There are several cases
    that you might have encountered while using any web or network application when
    signing in. For example, a wrongly typed password might lead to an `Invalid username
    or password` error being returned by the server.
  prefs: []
  type: TYPE_NORMAL
- en: Besides this first necessary step, it is wise to validate every piece of data
    coming from the client application. A buffer overflow might be avoided quite easily
    if the email field is checked for its size. For example, the client application,
    when intentionally trying to break the system, might send a JSON object that has
    a very large value for its fields. That check is on the server's shoulders. Preventing
    security flaws starts with data validation.
  prefs: []
  type: TYPE_NORMAL
- en: Another form of security attack is making too many requests per second from
    a single or multiple clients. For example, a client application making hundreds
    of authentication requests in 1 second causes the server to intensively process
    those requests and waste its resources trying to serve them all. It would be better
    to check the rate of client requests, for example, limiting them to a single request
    per second.
  prefs: []
  type: TYPE_NORMAL
- en: These forms of attack (intentional or unintentional) are referred to as **Denial
    of Service** (**DOS**) attacks. The more advanced version of a DOS attack takes
    the form of making a huge number of requests to the server from multiple clients.
    This form is called a **Distributed DOS** (**DDOS**) attack. A simple approach
    might be to blacklist IP addresses that are trying to crash the system by making
    multiple requests per second. As a programmer of network applications, you should
    consider all the issues described here and many others outside the scope of this
    book when developing your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced designing network applications in C++. With effect
    from its first version, C++ has lacked built-in support for networking. The C++23
    standard plans to finally introduce it in the language.
  prefs: []
  type: TYPE_NORMAL
- en: We started off by introducing the basics of networking. Understanding networking
    completely takes a lot of time, but there are several foundational concepts that
    every programmer must know before implementing an application in any way related
    to the network. Those foundational concepts include layering in the OSI model
    and different kinds of transport protocol, such as TCP and UDP. Having an understanding
    of the differences between TCP and UDP is necessary for any programmer. As we
    learned, TCP makes reliable connections between sockets, and sockets are the next
    thing that a programmer encounters when developing network applications. Those
    are the connection points of two instances of applications. Whenever we need to
    send or receive data through a network, we should define a socket and work with
    it almost as we would work with a regular file.
  prefs: []
  type: TYPE_NORMAL
- en: All the abstractions and concepts that we use in application development are
    handled by the OS and, in the end, by the network adapter. This is a device that's
    capable of sending data through a network medium. Receiving data from the medium
    doesn't guarantee safety. The network adapter receives anything coming from the
    medium. To make sure we are handling incoming data correctly, we should also take
    care of application security. The last section of this chapter was about writing
    secure code and validating the input to make sure no harm will be done to the
    program. Securing your program is a good step in making sure your programs are
    of high quality. One of the best approaches to developing programs is testing
    them thoroughly. You may recall that, in [Chapter 10](069ab9af-21a4-4b8c-bc3f-f7bc0d9e4712.xhtml), *Designing
    World-Ready Applications*, we discussed software development steps and explained
    that one of the most important steps explained testing the program once the coding
    phase is complete. After testing it, you will most probably discover a lot of
    bugs. Some of these bugs are hard to reproduce and fix, and that's where debugging
    comes to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is all about testing and debugging your programs the right
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: List all seven layers of the OSI model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the point of port numbers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you use sockets in network applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe the sequence of operations you should perform at the server-side to
    receive data using a TCP socket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the differences between TCP and UDP?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why shouldn't you use macro definitions in your code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you differentiate between different client applications when implementing
    a server application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*TCP/IP Illustrated, Volume 1: The Protocol**s*, by R. Stevens: [https://www.amazon.com/TCP-Illustrated-Protocols-Addison-Wesley-Professional/dp/0321336313/](https://www.amazon.com/TCP-Illustrated-Protocols-Addison-Wesley-Professional/dp/0321336313/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Networking Fundamentals*, by Gordon Davies:[ https://www.packtpub.com/cloud-networking/networking-fundamentals](https://www.packtpub.com/cloud-networking/networking-fundamentals)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
