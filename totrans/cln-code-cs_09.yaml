- en: Designing and Developing APIs
  prefs: []
  type: TYPE_NORMAL
- en: '**Application Programming Interfaces** (**APIs**) have never been so vital
    in so many ways as they are these days. APIs are used to connect governments and
    institutions in the sharing of data and in a collaborative manner for business
    and governmental issues. They are used between doctors'' surgeries and hospitals
    to share patient data in real time. You use APIs every day when you connect to
    your emails and collaborate with your colleagues and clients through platforms
    such as Microsoft Teams, Microsoft Azure, Amazon Web Services, and Google Cloud
    Platform.'
  prefs: []
  type: TYPE_NORMAL
- en: Every time you chat with someone or have a video call with them using your computers
    or phones, you are using APIs. When streaming video conferences, entering a website
    technical support chat, or streaming your favorite music and videos, you are using
    APIs. So, as a programmer, it is imperative that you are well versed in what APIs
    are and how to design, develop, secure, and deploy them.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will talk about what APIs are, how they benefit you, and
    why it is necessary to learn about them. We will also be discussing API proxies,
    design and development guidelines, how to design APIs using RAML, and how to document
    APIs using Swagger.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is an API?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API proxies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API design guidelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API design using RAML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swagger API development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter will assist you in gaining the following skills:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding APIs and why you need to learn about them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding API proxies and why we use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being aware of design guidelines when designing your own APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using RAML to design your own APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Swagger to document your APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the basics of good API design
    and you will be armed with the knowledge needed to push your API abilities forward. It
    is important to understand what an API is, and so that is how we shall start this
    chapter. But first, make sure that you implement the following technical requirements
    to get the most out of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using the following technologies in this chapter to create an API:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2019 Community edition or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swashbuckle.AspNetCore 5 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swagger ([https://swagger.io](https://swagger.io))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atom ([http://atom.io](http://atom.io))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API Workbench by MuleSoft
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is an API?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**APIs** are reusable libraries that can be shared between different applications
    and can be made available via REST services (in which case, they are referred
    to as **RESTful APIs**).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Representational State Transfer** (**REST**) was introduced by Roy Fielding
    in 2000.'
  prefs: []
  type: TYPE_NORMAL
- en: 'REST is an architectural style that is made up of *constraints*. Altogether
    there are six constraints that should be considered when writing REST services.
    These constraints are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Uniform interface**: This is used to identify resources, and it manipulates
    these resources through *representation*. Messages use hypermedia and are self-descriptive. **Hypermedia
    as the Engine of Application State** (**HATEOAS**) is utilized to contain information
    about what operation can be carried out next by the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client-server**: This constraint utilizes information hiding through *encapsulation*. So,
    only the API calls that are to be used by clients will be visible and all the
    other APIs will be kept hidden. A RESTful API should be independent of other parts
    of the system, making it loosely coupled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateless**: This states that the RESTful API has no session nor history.
    If a session or history is required by the client, then the client must provide
    all the relevant information in the request to the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cacheable**: This constraint means that resources must declare themselves
    cacheable. This means that resources can be accessed quickly. As a result, our
    RESTful API gains speed and our server load is reduced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layered system**: The layered system constraint dictates that each layer
    must do one and only one thing. Each component should only know what it needs
    to use in order to function and perform its tasks. A component should not know
    about the parts of the system that it does not use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optional executable code**: The executable code constraint is optional. This
    constraint determines that servers can, on a temporary basis, extend or customize
    the functionality of a client by transferring executable code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, when designing an API, it would be prudent to assume that the end user will
    be a programmer with any level of experience. They should be able to easily obtain
    the API, read up on it, and put it to work straight away.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry about creating the perfect API. APIs usually evolve over time anyway,
    and if you have ever worked with Microsoft APIs, you will know that they regularly
    upgrade them. APIs with features that will be removed in the future are often
    marked with an annotation that informs the user not to use a particular property
    or method as they will be removed in a future release. Then, when they will no
    longer be used, they usually get marked with an obsolete annotation before they
    are finally removed. This tells the users of the API to upgrade any apps using
    deprecated features.
  prefs: []
  type: TYPE_NORMAL
- en: Why use REST services for API access? Well, many companies make large profits
    from making their APIs available online and charging for them. So, RESTful APIs
    can be a very valuable asset. Rapid API ([https://rapidapi.com/](https://rapidapi.com/))
    has free and paid APIs available for use.
  prefs: []
  type: TYPE_NORMAL
- en: Your APIs can remain permanently in place. If you use a cloud provider, your
    APIs can be highly scalable and you can make them generally available either for
    free or via a subscription. You can encapsulate all the complicated workings and
    expose what you need to via a simple interface, and because your APIs will be
    small and cacheable, they are very fast. Let's look now at API proxies and why
    you would use them.
  prefs: []
  type: TYPE_NORMAL
- en: API proxies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **API proxy** is a class that sits between the client and your API. It is,
    in essence, an API contract between you and the developers who will be using your
    API. So, rather than giving developers direct access to your API's backend services,
    which may break over time as you refactor and extend them, you provide assurance
    to the consumers of your API that the API contract will be honored, even when
    the backend services change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram displays the communication between the client, an API
    proxy, the actual API being accessed, and the API''s communication with the data
    source:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac1cf264-d3a0-461d-9552-f325c10357bd.png)'
  prefs: []
  type: TYPE_IMG
- en: A console application that shows how easy it is to implement the proxy pattern
    will be programmed in this section. Our example will have an interface that will
    be implemented by the API and the proxy. The API will return the actual message
    and the proxy will obtain the message from the API and pass it to the client.
    Proxies can also do much more than simply call the API method and return a response.
    They can perform authentication, authorization, routing based on credentials,
    and much more. However, our example will be kept to the absolute minimum so that
    you can see the simplicity in the proxy pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new .NET Framework console application. Add the `Apis`, `Interfaces`,
    and `Proxies` folders and place the `HelloWorldInterface` interface into the `Interfaces` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Our interface method, `GetMessage()`, returns a message as a string. Both the
    proxy and API class will implement this interface. The `HelloWorldApi` class implements
    `HelloWorldInterface`, so add it to the `Apis` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, our API class implements the interface and returns a `"Hello
    World!"` message. We have also made the class an internal class. This prevents
    external callers from being able to access the contents of this class. Now, we''ll
    add our `HelloWorldProxy` class to the `Proxies` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our proxy class is set to `public` as this class will be called by clients.
    The proxy class will call the `GetMessage()` method within the API class and return
    the response to the caller. All that''s left to do now is to modify our `Main()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Our `Main()` class calls the `GetMessage()` method of the `HelloWorldProxy` proxy
    class. Our proxy class calls the API class and the returned method is printed
    in the console window. The console then waits for a keypress before it exits.
  prefs: []
  type: TYPE_NORMAL
- en: Run the code and view the output; you have successfully implemented an API proxy
    class. You can make your proxies as simple or as complicated as they need to be,
    but what you have done here is the foundation for success.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be building an API. So, let's discuss what we will
    be building, and then get going with working on it. Once you've completed the
    project, you will have a working API that generates a monthly dividend payment
    calendar in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: API design guidelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are some basic guidelines to follow to write an effective API—for example,
    your resources should use nouns in plural form. So, for example, if you had a
    wholesale website, then your URLs would look something like the following dummy
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://wholesale-website.com/api/customers/1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://wholesale-website.com/api/products/20`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding URLs will follow the controller routes of `api/controller/id`.
    In terms of relationships within the business domain, these should also be reflected
    in URLs such as `http://wholesale-website.com/api/categories/12/products`—this
    call will return a list of products for category `12`.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to use a verb as a resource, then you can do so. When making an
    HTTP request, use `GET` to retrieve items, `HEAD` to retrieve only headers, `POST` to
    insert or save a new resource, `PUT` to replace a resource, and `DELETE` to remove
    a resource. Keep resources lean by using query parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'When paginating results, a ready-made set of links should be made available
    to the client. RFC 5988 introduced **link headers**. In the specification, an **International
    Resource Identifier (IRI)** is a typed connection between two resources. For more
    information, refer to [https://www.greenbytes.de/tech/webdav/rfc5988.html](https://www.greenbytes.de/tech/webdav/rfc5988.html).
    The format of link header requests is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<https://wholesale-website.com/api/products?page=10&per_page=100>; rel="next"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<https://wholesale-website.com/api/products?page=11&per_page=100>; rel="last"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The versioning of your API can be done in the URL. So, each resource will have
    a different URL for the same resource, as in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://wholesale-website.com/api/v1/cart`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://wholesale-website.com/api/v2/cart`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This form of versioning is very simple and makes it easy to find the correct
    version of the API.
  prefs: []
  type: TYPE_NORMAL
- en: JSON is the preferred resource representation. It is much more human-readable
    than XML and is also lighter in size. When you are using the `POST`, `PUT`, and `PATCH` verbs,
    you should also require the content-type header to be set to application/JSON,
    or throw the `415` HTTP status code (which means unsupported media type). Gzip
    is a single-file/stream lossless data compression utility. Use Gzip by default
    to save a good percentage in bandwidth, and always set the HTTP `Accept-Encoding` header
    to `gzip`.
  prefs: []
  type: TYPE_NORMAL
- en: Always use HTTPS (TLS) for your APIs. The identification of the caller should
    always be done in the header. We saw this with our API when we set the `x-api-key` header
    with our API access key. Each request should be authenticated and authorized.
    Unauthorized access should result in an `HTTP 403 Forbidden` response. Also, use
    the correct HTTP response codes. So, if a request is successful, use the `200` status
    code, for a resource that is not found, use `404`, and so on. For an exhaustive
    list of HTTP status codes, visit [https://httpstatuses.com/](https://httpstatuses.com/).
    OAuth 2.0 is the industry-standard protocol for authorization. You can read all
    about it at [https://oauth.net/2/](https://oauth.net/2/).
  prefs: []
  type: TYPE_NORMAL
- en: An API should provide documentation on its usage with examples. Documentation
    should always be up to date with the current version, and it should be visually
    appealing and easy to read. We'll look at Swagger to help us create documentation
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You never know when your API is going to need to scale. So, this should be factored
    in from the start. In our *Dividend Calendar API* project in the next chapter,
    you will see how we implement throttling to just one API call per month on a specific
    day of the month. However, you can effectively come up with 1,001 different ways
    to throttle your APIs depending on your own needs, but this should be done at
    the start of a project. So, as soon as you start a new project, think *scalability*.
  prefs: []
  type: TYPE_NORMAL
- en: For security and performance reasons, you may decide to implement an API proxy.
    An API proxy disconnects the client from accessing your API directly. A proxy
    can access an API in the same project or on an external API. By using a proxy,
    you can avoid exposing your database schema.
  prefs: []
  type: TYPE_NORMAL
- en: Responses to the client should never match the structure of your database. This
    can act as a green light for hackers. So, avoid one-to-one mappings between database
    structures and the responses you send back to clients. You should also hide identifiers
    from your clients as they can be used to manually access data by the client.
  prefs: []
  type: TYPE_NORMAL
- en: An API contains resources. A **resource** is an item that can be operated on
    in some way. Resources can be files or data. For example, students in a school
    database are resources that can be added, edited, or deleted. Video files can
    be retrieved and played, as can audio files. Images are also resources, as are
    report templates that will be opened, manipulated, and filled with data before
    they are presented to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Often, resources form collections of items, such as students in a school database.
    `Students` is the name of a collection of the `Student` type. Resources are accessed
    via a URL. A URL contains the path to a resource.
  prefs: []
  type: TYPE_NORMAL
- en: URLs are known as **API endpoints**. An API endpoint is an address of a resource.
    This resource may be accessed by an URL with one or more parameters or an URL
    without any parameters. An URL should only contain plural nouns (names of resources)
    and should not contain verbs or actions. Parameters can be used to identify a
    single resource within a collection. Pagination should be employed if the dataset
    is going to be very large. For requests with parameters that break the URI length
    limit, you can place the parameters in the body of a `POST` request.
  prefs: []
  type: TYPE_NORMAL
- en: Verbs form part of the HTTP request. The `POST` verb is used to add a resource.
    To retrieve one or more resources, you use the `GET` verb. `PUT` updates or replaces
    one or more resources, and `PATCH` updates or modifies a resource or collection.
    `DELETE` deletes a resource or collection.
  prefs: []
  type: TYPE_NORMAL
- en: You should always make sure you provide and respond to HTTP status codes appropriately.
    For a complete list of HTTP status codes, visit [https://httpstatuses.com/](https://httpstatuses.com/).
  prefs: []
  type: TYPE_NORMAL
- en: As for field, method, and property names, you can use any convention you like,
    but it must be consistent and follow the company guidelines. Camel case convention
    is normally used in JSON. Since you will be developing APIs in C#, it is best
    to stick to the industry-standard C# naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Since your API will evolve over time, it is best to employ some form of versioning.
    Versioning allows consumers to consume specific versions of your API. This can
    be very important for providing backward compatibility when new versions of your
    API implement breaking changes. It is normally a good idea to have the version
    number, such as v1 or v2, included in the URL. Whatever method you use to version
    your APIs, just remember to be *consistent*.
  prefs: []
  type: TYPE_NORMAL
- en: If you will be consuming third-party APIs, you will need to keep the API keys
    secret. One way to accomplish this is to store the keys in a key vault, such as
    Azure Key Vault, which requires authentication and authorization. You should also
    secure your own APIs with a method of your choosing. A common method nowadays
    is through the use of API keys. You will see how to use API keys and Azure Key
    Vault to secure third-party keys and your own APIs in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Well-defined software boundaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nobody in their right mind likes spaghetti code. It is very hard to read, maintain,
    and extend. So, when designing an API, you can overcome this problem with well-defined
    software boundaries. A well-defined software boundary is known as a **bounded
    context** in **Domain-Driven Design** (**DDD**). In business terms, a bounded
    context is a business operational unit, such as HR, finance, customer services,
    infrastructure, and so on. These business operational units are known as **domains**,
    and they can be broken down into smaller sub-domains. Then, these sub-domains
    can be broken down into even smaller sub-domains.
  prefs: []
  type: TYPE_NORMAL
- en: By breaking a business up into business operational units, domain experts can
    be employed in those specific areas. A common language can be determined at the
    start of a project so that the business understands the IT terms and the IT staff
    understands the business terms. If the business and IT staff are language-aligned,
    there is less margin for errors due to misunderstandings from both sides.
  prefs: []
  type: TYPE_NORMAL
- en: Having a major project broken down into sub-domains means that you can have
    smaller teams working independently on projects. So, large development teams can
    be grouped into smaller teams working concurrently on various projects.
  prefs: []
  type: TYPE_NORMAL
- en: DDD is a big subject in itself and is not covered here. However, links to more
    information are posted in the *Further reading* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The only items that should be exposed by APIs are the interfaces that form contracts
    and API endpoints. Everything else should be hidden from the subscriber and consumer.
    This means that even large databases can be broken down so that each API has its
    own database. Given how large and complex websites can be by today's standards,
    we can even have micro-services with micro-databases and micro-frontends.
  prefs: []
  type: TYPE_NORMAL
- en: A micro-frontend is a small portion of a web page that is dynamically retrieved
    and modified according to user interactions. That frontend will interact with
    an API, which in turn will access a micro-database. This is ideal in terms of
    **Single-Page Applications** (**SPAs**).
  prefs: []
  type: TYPE_NORMAL
- en: 'SPAs are websites consisting of a single page. When a user initiates an action,
    only the required portion of the web page is updated; the rest of the page remains
    the same. So, for example, say the web page has an aside. That aside displays
    adverts. Those adverts are stored in the database as portions of HTML. The aside
    is set to auto-update itself every 5 seconds. When 5 seconds is up, the aside
    requests the API to assign a new advert. The API then uses whatever algorithm
    is in place to obtain a new advert to display from the database. The HTML document
    is then updated, and the aside is updated with the new advert. The following diagram
    shows the typical SPA life cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52b9aa3b-83f9-42c3-91f9-090c0663f494.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This aside is a well-defined software boundary. It does not need to know anything
    whatsoever about the rest of the page it is displayed in. All it is concerned
    with is displaying a new advert every 5 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5031ec6d-2f95-4332-a93f-474caa205164.png)'
  prefs: []
  type: TYPE_IMG
- en: The previous diagram shows an SPA communicating with a RESTful API via an API
    proxy, and the API is able to access documents and databases.
  prefs: []
  type: TYPE_NORMAL
- en: The only components that make up the aside are an HTML document fragment, a
    micro-service, and a database. These can be worked on by a small team in whatever
    technology that the team prefers and is comfortable with. The full SPA could be
    made up of hundreds of micro-documents, micros-services, and micro-databases.
    The key point is that these services could be made up of any technology and worked
    on independently by any team. Multiple projects could also be worked on concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within our bounded context, we can use the following software methodologies
    to improve the quality of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Single Responsibility**, **Open/Closed**, **Liskov**, **Interface Segregation**,
    and **Dependency Inversion** (**SOLID**) principles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Don''t Repeat Yourself **(**DRY**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**You Ain''t Gonna Need It **(**YAGNI**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keep It Simple, Stupid** (**KISS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These methodologies work well together to eliminate duplicate code, prevent
    you from writing code that you don't need, and to keep objects and methods small.
    The reason why we develop for a class and a method is that they should both do
    only one thing and do it well.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces are used to perform logical groupings. We can use namespaces to define
    software boundaries. The more specific a namespace is, the more meaningful it
    is to the programmer. Meaningful namespaces help programmers to partition code
    and find what they are looking for with ease. Use namespaces to logically group
    interfaces, classes, structs, and enums.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to design an API using RAML. Then, you
    will generate a C# API from the RAML file.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the importance of good quality API documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working on a project, it is necessary to understand all the APIs that are
    already used. The reason for this is that you can often end up writing code that
    already exists, which obviously leads to wasted effort. Not only that but by writing
    your own version of code that already exists, you now have two copies of code that
    do the same thing. This adds to the complexity of the software and increases the
    maintenance overhead as both versions of the code must be maintained. It also
    adds the potential for bugs.
  prefs: []
  type: TYPE_NORMAL
- en: On massive projects that are spread across multiple technologies and repositories,
    with teams that have a high staff turnaround, and especially where no documentation
    exists, code duplication becomes a real problem. Sometimes, there will only be
    one or two domain experts, with the majority of the team not knowing the system
    at all. I have worked on projects like this before and they are a real pain to
    maintain and expand.
  prefs: []
  type: TYPE_NORMAL
- en: That is why API documentation is vital for any project, no matter how large
    or how small it is. It is inevitable in the field of software development that
    people will move on, especially when more lucrative work is offered elsewhere.
    If the person moving on is the domain expert, then they will take their knowledge
    with them. If no documentation exists, then new developers to the project will
    have a steep learning curve in understanding the project by having to read the
    code. If the code is messy and complex, this can cause a real headache for onboarding
    new staff.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, due to the lack of system knowledge, programmers will be inclined
    to more or less write the code they need from scratch to get the job done as they
    will be under pressure to deliver to the business on time. This will often lead
    to duplicate code and code reuse not being utilized. This causes the software
    to become complex and error-prone, and this kind of software ends up being hard
    to extend and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you understand why APIs must be documented. A well-documented API will
    lead to greater understanding by programmers and is more inclined to get reused,
    thereby reducing the potential for code duplication and producing code that is
    hard to extend or maintain.
  prefs: []
  type: TYPE_NORMAL
- en: You should also be aware of any code that is marked as deprecated or obsolete.
    Deprecated code will be removed in future releases and obsolete code is no longer
    in use. If you are using APIs that are marked as deprecated or obsolete, then
    this code should be prioritized to address first.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the importance of good quality API documentation, we
    will look at a tool called Swagger. Swagger is an easy-to-use tool for producing
    nice-looking, high-quality API documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger API development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Swagger provides a powerful set of tools that are focused around API development.
    With Swagger, you can do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Design**: Design your API and model it to keep up with specification-based
    standards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build**: Build an API in C# that is stable and reusable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Document**: Provide developers with documentation that they can interact
    with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test**: Easily test your API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Standardize**: Apply constraints to your API architecture using your company
    guidelines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to get Swagger up and running in our ASP.NET Core 3.0+ project.
    So, start by creating the project in Visual Studio 2019\. Select the Web API and
    No Authentication settings. Before we continue, it is worth noting that Swagger
    automatically generates aesthetically pleasing documentation that is functional.
    Very little code is required to set up Swagger, which is why many modern APIs
    use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can use Swagger, we first need to install support for it in our project.
    To install Swagger, you must install version 5 or higher of the `Swashbuckle.AspNetCore` dependency
    package. As of the time of writing, the version available on NuGet is version
    5.3.3\. After the installation is complete, we need to add the Swagger services
    that we will be using to the services collection. In our case, we will only be
    using Swagger to document our API. In the `Startup.cs` class, add the following
    line to the `ConfigureServices()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the code we''ve just added, the Swagger documenting service has been assigned
    to the services collection. Our API version is `v1` and our API title is `Weather
    Forecast API`. We now need to update the `Configure()` method to add our Swagger
    middleware, as follows, immediately after the `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `Configure()` method, we are informing our app to use Swagger and the
    Swagger UI, and we assign our Swagger endpoint for `Weather Forecast API`. Next,
    you will need to install the `Swashbuckle.AspNetCore.Newtonsoft` NuGet dependency
    package (version 5.3.3, as of the time of writing). Then, add the following line
    to your `ConfigureServices()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We added Newtonsoft support for our Swagger documentation generation. That
    is all there is to getting Swagger up and running. So, run your project and navigate
    to `https://localhost:PORT_NUMBER/swagger/index.html`. You should see the following
    web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4628e779-2c78-41dc-acad-7caea58b65fa.png)'
  prefs: []
  type: TYPE_IMG
- en: We will now take a look at why we should pass immutable structs instead of mutable
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Passing immutable structs instead of mutable objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you are going to write a computer program that processes 1
    million objects and 1 million immutable structs. You will see how much quicker,
    in terms of performance, structs are over objects. We will be writing some code
    that processes 1 million objects in 1,440 milliseconds and processes 1 million
    structs in 841 milliseconds. That is a difference of 599 milliseconds. Such a
    small unit of time might not sound like a lot, but when working with massive datasets,
    you will see big performance improvements when using immutable structs over mutable
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Values in mutable objects can also be modified between threads, which can be
    very bad for business. Imagine having £15,000 in your bank account and you pay
    your landlord £435 in rent. Your account has an overdraft limit that can be exceeded.
    Now, at the same time that you are paying £435, someone else is paying a car firm
    £23,000 for a new car. The value on your account is modified by the car purchaser's
    thread. So, you end up paying your landlord £23,000, leaving your bank balance
    £8,000 in debt. We won't code an example of mutable data being changed between
    threads as this was covered in [Chapter 8](21b5d748-3720-4bea-a03c-5420862c01b3.xhtml),
    *Threading and Concurrency*.
  prefs: []
  type: TYPE_NORMAL
- en: The key points of this section are that structs are faster than objects and
    immutable structs are thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: When creating and passing objects, structs are more performant than objects.
    You can also make structs immutable so that they are thread-safe. Here, we will
    write a small program. This program will have two methods—one will create 1 million
    person objects and the other will create 1 million person structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new .NET Framework console application called `CH11_WellDefinedBoundaries` and
    the following `PersonObject` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This object will be used to create 1 million people objects. Now, add the `PersonStruct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This struct is immutable, with the `readonly` properties being set via the
    constructor and used to create our 1 million structs. Now, we can modify the program
    to show the performance between object and struct creation. Add the `CreateObject()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we start a stopwatch, create a new list, and add 1 million
    person objects to the list. We then stop the stopwatch, output the results to
    the window, and then call the garbage collector to clean up our resources. Let''s
    now add our `CreateStructs()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Our structure does a similar thing here as for the `CreateObjects()` methods,
    but creates a list of structs and adds 1 million structs to the list. Finally,
    modify the `Main()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We call both of our methods and then wait for the user to press any key before
    we exit. Run the program and you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5264597-6436-4a94-8ef7-6175e9f9350d.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the previous screenshot, it took 1,440 milliseconds to create
    1 million objects and add them to a list of objects, and only 841 milliseconds
    to create 1 million structs and add them to a list of structs.
  prefs: []
  type: TYPE_NORMAL
- en: So, not only are you able to make structs immutable and thread-safe as they
    cannot be modified between threads, but they also perform a lot faster when compared
    to objects. Therefore, if you are dealing with large amounts of data, structs
    can save you a lot of processing time. Not only that but if you are charged per
    cycle of execution time by your cloud computing service, then using structs over
    objects is going to save you money.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now have a look at writing third-party API tests for the APIs that you
    will be using.
  prefs: []
  type: TYPE_NORMAL
- en: Testing third-party APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may ask "*Why should I test third-party APIs*?" Well, that is a good question.
    The reason why you should test third-party APIs is that just like your own code,
    third-party code is susceptible to programming errors. I remember once running
    into some real difficulty on a document processing website I was building for
    a law firm. After much investigation, I found the problem was down due to faulty
    JavaScript embedded in the Microsoft API that I was using. The following screenshot
    is of the GitHub Issues page for the Microsoft Cognitive Toolkit, which has 738 outstanding issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/140266fd-a189-4b3a-8816-e41df0518541.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the Microsoft Cognitive Toolkit, third-party APIs do have
    issues. That means as the programmer, the onus is on you to ensure that the third-party
    APIs that you employ work as expected. Should you encounter any bugs, then it
    is good practice to inform the third party of the bugs. If the API is open source
    and you have access to the source code, you can even check out the code and submit
    your own fixes.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you encounter bugs in third-party code that will not be addressed in
    time for you to meet your deadlines, then one option you have available to you
    is to write a **wrapper class**that has all the same constructors, methods, and
    properties and makes them call the same constructors, methods, and properties
    on the third-party class, with the exception that you write your own bug-free
    version of the third-party property or method that has the bug in it. [Chapter
    11](c9f56c87-1d5a-45e1-b03c-30a2fb9f7713.xhtml), *Addressing Cross-Cutting Concerns*,
    provides sections on the proxy pattern and decorator pattern, which will help
    you write wrapper classes.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your own APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 6](ba53f821-d126-4fba-89a8-c148233510c1.xhtml), *Unit Testing,*
    and [Chapter 7](ab872898-c782-4edc-bc4f-d0ec85592dfa.xhtml), *End-to-End System
    Testing*, you saw, with code examples, how to test your own code. You should always
    test your own APIs as it is important to have complete trust in the quality of
    your APIs. Therefore, as a programmer, you should always unit test your code before
    you pass it on to quality assurance. Quality assurance should then run integration
    and regression testing on the API to ensure it meets the company's agreed level
    of quality.
  prefs: []
  type: TYPE_NORMAL
- en: Your API may do exactly what the business has asked for and be perfect without
    bugs; but when it's integrated with the system, do peculiar things happen that
    you were unable to test for in certain situations? Often, I have encountered situations
    in development teams where code will work on one person's computer but not on
    other computers. Yet, there often seems to be no logical reason for this to be
    the case. These problems can be incredibly frustrating and even time-consuming
    to get to the bottom of. But you want these problems to be ironed out before you
    pass on your code for quality assurance, and most definitely before it is released
    into production. Having to deal with customer bugs is not always a pleasant experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing your programs should involve the following:'
  prefs: []
  type: TYPE_NORMAL
- en: When given the correct range of values, the method under test outputs the correct
    result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When given the incorrect range of values, the method provides the appropriate
    response without crashing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that your API should only include what the business has asked for and
    should not make the internal details accessible to clients. This is where the
    product backlog, which is part of the Scrum project management methodology, is
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'The product backlog is the list of new features and technical debts that you
    and your team will be working on. Each item in the product backlog will have a
    description and acceptance criteria, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/550047ec-c17e-4810-9076-a1eb5ea19ee0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You write your unit tests around the acceptance criteria. Your tests will include
    the normal path of execution and abnormal paths of execution. Using this screenshot
    as an example, we have two acceptance criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: Data is successfully obtained from third-party APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data is successfully stored in Cosmos DB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In these two acceptance criteria, we know we will be calling APIs that obtain
    data. That data will be obtained from third parties. Once obtained, the data will
    then be stored in the database. On the face of it, this specification that we
    have to work with is quite vague. In real life, I have found that this is often
    the case.
  prefs: []
  type: TYPE_NORMAL
- en: Given the vagueness of the specification, we will make the assumption that the
    specification will be generic and will apply to different API calls, and we can
    assume that the data returned is JSON data. We will also make the assumption that
    the returned JSON data will be stored in its raw form in a Cosmos DB database.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what tests can we write for our first acceptance criteria? Well, we can
    write the following test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: When given an URL with a parameter list, assert that we receive a status of
    `200` and JSON returned for a `GET` request when all the correct information is
    supplied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assert that we receive a status of `401` when an unauthorized `GET` request
    has been made.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assert that we receive a status of `403` when the authenticated user is forbidden
    from accessing the resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assert that we receive a status of `500` when the server is down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What tests can we write for our second acceptance criteria? Well, we can write
    the following test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Assert that unauthorized access to the database is denied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assert that the API handles cases where the database is unavailable gracefully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assert that authorized access to the database is granted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assert that JSON insertion into the database succeeds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, even from such a vague specification, we have been able to obtain eight
    test cases. Between them, all these cases test for a successful roundtrip to the
    third-party server and back, and then into the database. They also test for various
    points at which the process could fail. If all of these tests pass, we have complete
    confidence in our code and that it will pass quality control when it leaves our
    hands as developers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at how to design APIs using RAML.
  prefs: []
  type: TYPE_NORMAL
- en: API design using RAML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss designing an API using RAML. You can gain in-depth
    knowledge about all aspects of RAML from the RAML website ([https://raml.org/developers/design-your-api](https://raml.org/developers/design-your-api)). We
    are going to learn the basics of RAML by designing a really simple API using API
    Workbench in Atom. We'll start with the installation.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to install the packages.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Atom and API Workbench by MuleSoft
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see how to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by installing Atom from [http://atom.io](http://atom.io).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, click on Install a Package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/84999249-f95c-43c6-8dc7-293851edc1a8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, search for `api-workbench by mulesoft` and install it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a16b724d-e6d1-46b8-8733-c5a57095c552.png)'
  prefs: []
  type: TYPE_IMG
- en: The installation is successful if you find it listed under Packages | Installed
    Packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we've installed the packages, let's move onto creating the project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see how to go about this:'
  prefs: []
  type: TYPE_NORMAL
- en: Click File | Add Project Folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder or select an existing one. I will create a new folder called `C:\Development\RAML` and
    open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new file to your project folder called `Shop.raml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the file and select Add New | Create New API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give it any name you want and then click on Ok. You have now just created your
    first API design.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you look at the RAML file, you will see that its contents are in human-readable
    text. The API we''ve just created contains a simple `GET` command that returns
    a string that contains the words `"Hello World"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is RAML code. You will see that it is pretty similar to JSON in that the
    code is simple, human-readable code that is indented. Delete the file. From the Packages menu,
    select API Workbench | Create RAML Project. Fill out the Create RAML Project dialog,
    as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cdb8093f-1fe4-48c7-a255-488bffe88415.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The settings in this dialog will produce the following RAML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The main difference between the last RAML file and the first one you viewed
    is the insertion of the `version` and `baseUri` properties. These settings also
    update your Project folder''s content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/edc9a28c-8900-4cb1-b1e7-2f21a28d954f.png)'
  prefs: []
  type: TYPE_IMG
- en: For a very detailed tutorial on this subject, head on over to[ ](http://apiworkbench.com/docs/)[http://apiworkbench.com/docs/](http://apiworkbench.com/docs/).
    This URL also provides details on how to add resources and methods; fill method
    bodies and responses; add sub-resources; add examples and types; create and extract
    resource types; add resource type parameters, method parameters, and traits; reuse
    traits, resource types, and libraries; add more types and resources; extract libraries;
    and much more than we can cover in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a design that is language implementation-agnostic, how do we
    generate our API in C#?
  prefs: []
  type: TYPE_NORMAL
- en: Generating our C# API from our agnostic RAML design specification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need to have, as a minimum, Visual Studio 2019 Community edition installed.
    Then, make sure you close Visual Studio. Also, download and install the Visual
    Studio `MuleSoftInc.RAMLToolsforNET` tool. With these tools installed, we will
    now proceed through the steps required to produce the skeleton framework of our
    previously specified API. This will be accomplished by adding a RAML/OAS contract
    and importing our RAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio 2019, create a new .NET Framework console application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click on the project and select Add RAML/OAS Contract. This will open
    the following dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bacd4cb7-ca52-41c2-904c-35491f7cd8bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Upload, and then select your RAML file. The Import RAML/OAS dialog
    will then be presented. Fill the dialog out as shown and then click on Import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5944bca4-a050-46f6-880f-d0ee6aefb58d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Your project will now be updated with the required dependencies, and new folders
    and files will be added to your console application. You will notice three root
    folders, called `Contracts`, `Controllers`, and `Models`. In the `Contracts` folder,
    we have our RAML file and the `IV1HelloWorldController` interface. It contains
    one method: `Task<IHttpActionResult> Get()`. The `v1HelloWorldController` class
    implements the `Iv1HelloWorldController` interface. Let''s have a look at the
    implemented `Get()` method in the controller class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that the code comments out the instantiation
    of the `HelloWorldGet200` class and the returned result. The `HelloWorldGet200` class
    is our model class. We can update our model to whatever data we want it to contain.
    In our simple example, we won''t bother too much with this; we will just return
    the `"Hello World!"` string. Update the uncommented line to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Ok()` method returns a type of `OkNegotiatedContentResult<T>`. We will
    call this `Get()` method from our `Main()` method in the `Program` class. Update
    the `Main()` method, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we are running asynchronous code in a static method, we must add the work
    to the thread pool queue. We then execute our code and wait for the result. Once
    the code returns, we simply wait for a keypress and then exit.
  prefs: []
  type: TYPE_NORMAL
- en: We have created an MVC API within a console app and executed API calls based
    on the RAML file that we imported. This same process works for the ASP.NET and
    ASP.NET Core websites. We will now extract RAML from an existing API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the dividend calendar API project from earlier on in this chapter. Then,
    right-click on the project and select Extract RAML. Then, once the extraction
    has finished, run your project. Change the URL to `https://localhost:44325/raml`. When
    you extract RAML, the code generation process adds a `RamlController` class to
    your project, along with a RAML view. You will see that your API is now documented,
    as shown in the RAML view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dccb261d-f9c4-4b26-b0ed-5ac073ed5dd3.png)'
  prefs: []
  type: TYPE_IMG
- en: By using RAML, you can design an API and then generate the structure and you
    can reverse engineer an API. The RAML specification helps you design your API
    and make changes by modifying the RAML code. You can view the [http://raml.org](http://raml.org) website
    for more information on how to get the most out of the RAML specification if you
    want to know more. We'll now have a look at Swagger and how to use it in ASP.NET
    Core 3+ projects.
  prefs: []
  type: TYPE_NORMAL
- en: Well, we've now reached the end of this chapter. Now, we will summarize what
    we have achieved and learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed what an API is. Then, we looked at how we can
    use API proxies as contracts between ourselves and the consumers of our APIs.
    This protects our APIs from direct access by third parties. Next, we looked at
    a number of design guidelines for improving the quality of our APIs.
  prefs: []
  type: TYPE_NORMAL
- en: We then went on to discuss Swagger and saw how to document the Weather API with
    Swagger. Testing APIs was then covered, and we saw why it is good to test your
    code and any third-party code that you use in your projects. Finally, we looked
    at designing a language-agnostic API using RAML and translated it into a working
    project using C#.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will write a project to demonstrate securing keys using
    Azure Key Vault and securing our own API using API keys. But before then, let's
    put your brain to work to see what you have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does API stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does REST stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the six constraints of REST?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does HATEOAS stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is RAML?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Swagger?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is meant by the term **well-defined software boundary**?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you understand the APIs that you are using?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What performs better—structs or objects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you test third-party APIs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you test your own APIs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you determine what tests to write for your code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name three ways to organize code into well-defined software boundaries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://weblogs.asp.net/sukumarraju/asp-net-web-api-testing-using-nunit-framework](https://weblogs.asp.net/sukumarraju/asp-net-web-api-testing-using-nunit-framework) provides
    a complete example of using NUnit to test web APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://raml.org/developers/design-your-api](https://raml.org/developers/design-your-api) shows
    you how to design your API with RAML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://apiworkbench.com/docs/](http://apiworkbench.com/docs/) provides documentation
    on using RAML in Atom to design your APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://dotnetcoretutorials.com/2017/10/19/using-swagger-asp-net-core/](https://dotnetcoretutorials.com/2017/10/19/using-swagger-asp-net-core/) is
    a good introduction to using Swagger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://swagger.io/about/](https://swagger.io/about/) takes you to the Swagger
    About page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://httpstatuses.com/](https://httpstatuses.com/) is a list of HTTP status
    codes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.greenbytes.de/tech/webdav/rfc5988.html](https://www.greenbytes.de/tech/webdav/rfc5988.html) is
    the web linking specification RFC 5988.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://oauth.net/2/](https://oauth.net/2/) takes you to the OAuth 2.0 home
    page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Domain-driven_design](https://en.wikipedia.org/wiki/Domain-driven_design) is
    the Wikipedia page for domain-driven design.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/gb/application-development/hands-domain-driven-design-net-core](https://www.packtpub.com/gb/application-development/hands-domain-driven-design-net-core) provides
    information on the *Hands-On Domain-Driven Design with .NET Core* book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/gb/application-development/test-driven-development-c-and-net-core-mvc-video](https://www.packtpub.com/gb/application-development/test-driven-development-c-and-net-core-mvc-video) provides
    information on *Test-Driven Development with C# and .NET Core and MVC*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
