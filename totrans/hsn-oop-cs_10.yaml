- en: Exploring ADO.NET with Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have any exposure to web development, you might have heard of ASP.NET,
    which is a framework for web development. Similarly, if you have worked with databases
    before in .NET projects, you should have heard of or used ADO.NET. ADO.NET is
    a framework that's similar to ASP.NET, but instead of web development, this framework
    is used for database-related work. **ActiveX Data Object** (**ADO**) was an old
    technology created by Microsoft, but the evolution to ADO.NET has been extraordinary. ADO.NET
    contains classes and methods that can be used to easily establish a connection
    with a database management system such as SQL Server or Oracle. Not only that,
    it also provides methods and objects that help to execute commands in the database, such
    as select, insert, update, and delete.
  prefs: []
  type: TYPE_NORMAL
- en: We need a separate framework for database connection and activity because there
    are a lot of different database systems that can be used when developing an application.
    Databases are a very important part of an application; applications need data
    and data needs to be stored in a database. Because databases are so important
    and there are so many databases available, it would be very hard for a developer
    to write all of the necessary code. It's not worth writing separate bits of code
    when we could write one piece of code that is reusable. This is why Microsoft
    came up with the ADO.NET framework. This framework has different data providers,
    datasets, data adapters, and various other things that are related to databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The fundamentals of ADO.NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DataProvider`, `Connection`, Command, `DataReader`, and `DataAdapter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting SQL Server Database and the Oracle Database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stored Procedures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entity Frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactions in SQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fundamentals of ADO.NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn about ADO.NET, we need to know how an application works with a database.
    Then, we need to know how ADO.NET provides support for this process. Let's start
    by learning about some important concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Data providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are different kinds of data providers available in ADO.NET. The most
    popular data providers are SQL Server, **Open Database Connectivity** (**ODBC**),
    **Object Linking and Embedding Database** (**OLE DB**), and **Java Database Connectivity**
    (**JDBC**). These data providers have a very similar code structure, which makes
    a developer''s life much easier. If you have used one in the past, you will be
    able to use any of the others without much difficulty. These data providers can
    be divided into different components: Connection, Command, DataReader, and DataAdapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Connection objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Connection is a component that establishes a connection with a database to
    execute a command on the database. It doesn’t matter which database you want to
    connect, you can use ADO.NET for them all. Even if there is no specific data provider
    for a particular database, you can use the OLE DB data provider to connect with
    any database. This connection object has a property called `connectionstring`.
    That is one of the most important elements of connection. The `connection` string
    is a string that holds data as key-value pairs. For example, a `connection` string
    contains information about the server in which the database is located, the name
    of the database, the user credentials, and some more information. If the database
    is in the same computer, you have to use `localhost` as the server. `ConnectionString` contains
    the database name and the authorization data, such as the username and password
    required to access the database. Let''s see an example of `connectionString` for
    SQL Server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Data Source` is the server name as the database is located in the same
    computer. The `database` keyword in the `connection` string holds the name of
    the database, which is `testdb` in this example. You will see in some `connection`
    strings that `Initial Catalog` is used instead of the `database` keyword in the
    `connection` string to store the name of the database. You can use either `Initial
    Catalog` or `database` to specify the name of the database in `connection` string.
    The last part of the `connectionString` property that we have here is `Integrated
    Security`, which is used as authentication. If you set it as `TRUE` or `SSPI`,
    this means that you are instructing the program to use Windows authentication
    to access the database. If you have a specific database user that you want to
    use, you can specify that by adding a `user` key and a `password` key in the `connection`
    string. You can provide some other data as well, including connection timeout
    and connect timeout. This `connection` string contains the minimum information
    required.
  prefs: []
  type: TYPE_NORMAL
- en: The Command object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Command object is used to give instructions to the database. Every data
    provider has its own `command` object that is inherited from the `DbCommand` object.
    The `command` object in the SQL data provider is `SqlCommand`, whereas the OLE
    DB provider has an `OleDbCommand` object. The command object is used to execute
    any kind of SQL statement, such as `SELECT`, `UPDATE`, `INSERT`, or `DELETE`.
    Command objects can also execute Stored Procedures. Later in the *Working with
    stored procedures* section, we will look at how to do that. They also have a few
    methods that are used to let the compiler know what type of command we are executing.
    For example, the `ExecuteReader` method queries in the database and returns a
    `DataReader` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f96dd52-b7d0-43c7-b7e0-2f3fee8e016c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The database table appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ebac9153-a68e-4396-a835-8fd820be2ee0.png)'
  prefs: []
  type: TYPE_IMG
- en: '`ExecuteNonQuery` is another method that is mainly used to execute non-query
    methods, such as `INSERT`, `UPDATE`, and `DELETE`. When you insert some data into
    a database, you are not querying anything in the database, you just want to insert
    the data. The same goes for update and delete. The `ExecuteNonQuery` method returns
    an `INT` value, which represents how many rows in the database were affected by
    the command. For example, if you are inserting a person in a `Person` table, you
    are inserting one new row in the table, so only one row is getting affected. The
    method will therefore return `1` to you.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example code of the `ExecuteNonQuery()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f35418b-b946-4445-ae17-8ee44902ed6c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s say you want to update the `Age` of Mr. John Nash. When you execute
    the `UPDATE` query, it will affect only one row of the table, so it will return
    `1`. But, for example, if you execute a query in which the condition matches several
    different rows, it will update all of the rows and return the total number of
    rows that were affected. Take a look at the following example. Here, we have a
    `Food` table that has different food items. Every item has a category:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f6d39da-42f7-4e37-ad95-9bdc5224b034.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we can see that there is no discount on any food items. Let''s say that
    we now want to give a discount of 5% on every breakfast item. To change the `Discount`
    value, you will have to execute an `UPDATE` command to update all of the rows.
    From the table, we can see that there are two breakfast items in the table. If
    we run an `UPDATE` command with a condition that applies only to `Category= ''Breakfast''`,
    it should affect two rows. Let''s see the C# code for this process. We are going
    to use the `ExecuteNonQuery` command here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c24b2fb-f033-42d2-9852-6161247fb734.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see from the output that `2` rows were affected. Now, let''s take a
    look at the database table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c81a6489-b638-46c0-be38-ab3ab8e8bf1c.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that two rows were changed.
  prefs: []
  type: TYPE_NORMAL
- en: If you execute a `DELETE` command using the `ExecuteNonQuery` method, it will
    return the amount of rows that were affected. If you get `0` as a result, this
    means that your command wasn't successfully executed.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other methods in the `SQLCommand` object. `ExecuteScalar` returns
    a scalar value from the query. `ExecuteXMLReader` returns an `XmlReader` object.
    There are other methods that work in an asynchronous way. All of these methods
    work in a similar way to the examples shown here.
  prefs: []
  type: TYPE_NORMAL
- en: There is a property in the Command object called `CommandType`. `CommandType`
    is an `enum` type that states how the command is provided. The enum values are
    `Text`, `StoredProcedure`, and `TableDirect`. If text is selected, the SQL command
    will be executed as an SQL query in the data source directly. In `StoredProcedure`,
    you can set parameters and execute `storedprocedures` to execute a command in
    the database. By default, the value is set as `TEXT`. This is why, in the earlier
    examples, we didn't set the value of `CommandType`.
  prefs: []
  type: TYPE_NORMAL
- en: The DataReader object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'DataReader objects provide a way of reading a forward-only stream of rows from
    database. Like the others, a DataReader is an object of a data provider. Every
    data provider has different DataReader objects that inherit from `DbDataReader`.
    When you execute an `ExecuteReader` command, it returns a `DataReader` object.
    You can process this `DataReader` object to collect the data you have queried
    for. If you are using SQL Server as your database, you should use the `SqlDataReader`
    object. `SqlDataReader` has a method called `Read()`, which returns `true` when
    you have available data in the `DataReader` object to read. If there is no data
    in the `SqlDataReader` object, the `Read()` method will return `false`. It''s
    a common practice to first check whether the `Read()` method is `true` and then
    read the data. The following example shows how `SqlDataReader` is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `command.ExecuteReader()` method returns an `SqlDataReader` object,
    which holds the result of the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we hold the returned object in a variable called **reader**, which is
    of the `SqlDataReader` type. Then, we check whether its `Read()` method is `true`.
    If it is, we execute the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the reader is working as an array and we get the value of the database
    table columns sequentially from the index. As we can see from the following table
    structure in the database, it has four columns, Id, FirstName, LastName, and Age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7a7aba8-e697-45b4-8491-53aeafdc4e76.png)'
  prefs: []
  type: TYPE_IMG
- en: These columns will be mapped one after another. `reader[0]` refers to the Id
    column, `reader[1]` refers to the Firstname column, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The statement we have written will print the value of the FirstName column, where
    it will find `reader[1]`. It will then print the value of the LastName column,
    where it will find `reader[2]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this array index is confusing for you and if you want more readability,
    feel free to use named indexes instead of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will print the same thing. Instead of putting `reader[1]`, we have written
    `reader["FirstName"]`, so it's clearer which column we are accessing. If you use
    this approach, make sure the name is written correctly.
  prefs: []
  type: TYPE_NORMAL
- en: DataAdapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`DataAdapter` is another way to read and use data from a data source. DataAdapter
    gives you an easy way to store the data directly to a dataset. You can also use
    DataAdapter to write back in the data source from the dataset. Every provider
    has its own DataAdapter. An SQL data provider, for example, has `SqlDataAdapter`.'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to various databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's see some examples of how to connect to different databases using ADO.NET.
    If you are using ADO.NET, the most probable database system you are going to use
    is SQL Server Database as that is the best match when you are using a Microsoft
    stack. You won't, however, have any reduction in performance or encounter problems
    if you use any other source. Let's see how we can connect with other databases
    with ADO.NET.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To connect to SQL Server, we need to use the SQL Server provider in ADO.NET.
    Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The Oracle database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To connect to the Oracle database, we need to use the ODBC provider in ADO.NET.
    Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Working with DataReaders and DataAdapters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`DataReaders` and `DataAdapter`s are core objects of a data provider. These
    are some of the most important features that ADO.NET provides. Let''s see how
    to work these objects.'
  prefs: []
  type: TYPE_NORMAL
- en: DataReaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every provider has DataReaders. Underneath, all classes do the same thing.
    `SqlDataReader`, `OdbcDataReader`, and `OleDbDataReader` all implement the `IDataReader` interface.
    The main use of DataReader is to read data from a data source when it is coming
    from a stream. Let''s take a look at the different properties that a data reader
    has:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Depth` | The depth of nesting for a row |'
  prefs: []
  type: TYPE_TB
- en: '| `FieldCount` | Returns the number of columns in a row |'
  prefs: []
  type: TYPE_TB
- en: '| `IsClosed` | Returns `TRUE` if `DataReader` is closed |'
  prefs: []
  type: TYPE_TB
- en: '| `Item` | Returns the value of a column |'
  prefs: []
  type: TYPE_TB
- en: '| `RecordsAffected` | The number of rows affected |'
  prefs: []
  type: TYPE_TB
- en: 'A DataReader has the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Close` | This method will close the `DataReader` object. |'
  prefs: []
  type: TYPE_TB
- en: '| `Read` | This method will read the next piece of data in `DataReader`. |'
  prefs: []
  type: TYPE_TB
- en: '| `NextResult` | This method will move the head to the next result. |'
  prefs: []
  type: TYPE_TB
- en: '| `GetString`,`GetChar`, and so on | The `GetString` method will return the
    value in string format. `GetChar` will return the value in `Char` format. There
    are other methods that will return a value in that particular type. |'
  prefs: []
  type: TYPE_TB
- en: 'The following code snippet shows an example of `DataReader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: DataAdapters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DataAdapters work like a bridge between disconnected ADO.NET objects and the
    data source. This means that they help to establish a connection and execute commands
    in the database. They also map back the query results to the disconnected ADO.NET
    objects. Data Adapters use `DataSet` or `DataTable` to store data after its retrieval
    from a data source. `DataAdapter` has a method called `Fill()`,which collects
    data from a data source and populates `DataSet` or `DataTable`. If you want to
    retrieve the schema information, you can use another method called `FillSchema()`.
    A further method, named `Update()`, transfers all changes made in `DataSet` or `DataTable`
    to the data source.
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits of using Data Adapters is that no information about the
    connection, database, tables, columns, or any other information related to the
    data source is passed to the disconnected object. It's therefore safe to use when
    passing a value to an external source.
  prefs: []
  type: TYPE_NORMAL
- en: Working with stored procedures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Stored Procedures** are batches of SQL statements that are stored in a database
    for the purpose of reuse. ADO.NET has support for Stored Procedures, which means
    that we can use ADO.NET to call stored procedures in a database and get results
    from them. It is a very common practice to pass parameters, which could be input
    or output parameters, to stored procedures. The ADO.NET command object has parameters
    that are objects of the parameter type. Depending on the provider, the parameter
    object changes, but they all follow the same base. Let''s take a look at how to
    use stored procedures instead of normal SQL statements in ADO.NET.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a stored procedure, the SQL string that is passed in `SQLCommand` should
    be the name of the Stored Procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We normally pass parameters to stored procedures as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now see the stored procedure to get an idea of how the parameter is
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Working with the Entity Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**The Entity Framework** (**EF**) is an **Object Relational Mapper** (**ORM**)
    framework developed by Microsoft. It was developed for .NET developers to work
    with databases easily using entity objects. It sits in the middle of your backend
    code or business logic and the database. It allows the developer to write code
    in the application language, C#, to talk with the database. This means that there
    is no need to use and write the ADO.NET code manually, which we did in the preceding
    sections. EF has different kinds of commands to the normal SQL commands. EF commands,
    which look very similar to C# code, will communicate with the database using SQL
    in the background. It can communicate with any type of data source, so you don''t
    have to worry about setting up or writing different code for each DBMS.'
  prefs: []
  type: TYPE_NORMAL
- en: What is an entity in the Entity Framework?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An entity is a class in the application domain that is also included as a `DbSet` property
    in the derived `DbContext` class. An entity is transformed into a table and the
    properties of an entity are transformed as columns when EF executes it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Different types of Entity properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see what different types of properties an Entity can have:'
  prefs: []
  type: TYPE_NORMAL
- en: Scalar properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Navigation properties. These include the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference Navigation properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collection Navigation properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalar properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the properties that are used as columns in the database directly.
    They are used to save and query in the database. Let''s see an example of these
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following properties are scalar properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Navigation properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This type of property represents relationships between entities. They are not
    related directly to particular columns. There are two types of navigation properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reference navigation property:** If another entity type is used as a property,
    it is called a reference navigation property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collection navigation property:** If an entity is included as a collection
    type, it is called a collection navigation property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of navigation properties is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Student` is a reference navigation property and `Students` is a collection
    navigation property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see the two approaches of using EF: the **code-first approach**
    and the **database-first approach**.'
  prefs: []
  type: TYPE_NORMAL
- en: The code-first approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This can be thought of as similar to domain-driven design. In this approach,
    you write the entity objects and the domain and then use the domain to generate
    a database using EF. Using different attributes in the entity objects, EF can
    understand what to do with the database and how. For example, if you want a particular
    property in your model to be treated as a primary key, you can use data annotations
    or a fluent API to indicate to the EF that it should treat this column as a primary
    key when creating the table in the database.
  prefs: []
  type: TYPE_NORMAL
- en: The database-first approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this approach, you create the database first and then ask EF to generate
    the entity for you. You make all of your changes at the database level and not
    in your entities in the backend application. Here, the EF does a different job
    to in the code-first approach. In the database-first approach, EF reads through
    the database tables and columns and generates C# classes models in which each
    column is treated as a property. The EF also takes care of the relationship between
    different database tables and creates the same kind of relationship in the generated
    models.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Entity Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both approaches have their benefits, but the code-first approach is more popular
    among developers as you have to deal less with the database and work more in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'An EF doesn''t comes with the .NET framework by default. You have to download
    the library from the NuGet package manager and install it in the project you are
    working with. To download and install the entity framework, you can open the Nuget
    Package Manager Console and write the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will download and install the Entity Framework in your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6bbdf13-aa11-4bf5-835c-2fd98bb06f76.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you are not comfortable with the Package Manager Console, you can also use
    the GUI''s Manage Packages for Solution window to install entity framework. Go
    to the Browse tab and search for Entity Framework. You will see it at the top
    of the search results. Click it and install it in your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f3940da-0cc2-4ff0-8fa3-76fa73a0036e.png)'
  prefs: []
  type: TYPE_IMG
- en: Installing Entity Framework using Nuget Package Manager
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we are focusing more on C#, so we will look more closely at the
    code-first approach than the database-first approach. In the code-first approach,
    as we don't touch the database code, we need to make our entity objects in a way
    that can be followed when creating a database. After we have created the database
    tables, if we want to update the tables or change the tables, we need to use migrations.
    Database migration creates a new instance of the database and applies the new
    changes in the new instance. By using migrations, it's easier to manipulate the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now learn a little bit more about the history and the flow of EF. It was
    first published in the year 2008 with .NET 3.5\. At the time of writing this book,
    the latest version of EF is version 6\. EF also has a .NET Core version that is
    called **Entity Framework Core**. Both frameworks are open source. When you install
    an entity framework in your project and write a **Plain Old CLR Object** (**POCO**)
    class, that POCO class is used by the entity framework. First, EF creates an **Entity
    Data Model** (**EDM**) from it. This EDM is used later to save and query in the
    database. **Language Integrated Queries **(**LINQs**) and SQL can both be used
    to give instructions to EF. When one entity object is used in EDM, it is tracked.
    When it is updated, the database will also be updated.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `SaveChanges()` method to execute insert, update, and delete
    activity in the database. For asynchronous programming, the `SaveChangesAsync()`
    method is used. For a better query experience, EF has first-level caching, so
    when repeated queries are executed, EF returns the results from the cache instead
    of going to the database to collect the same result.
  prefs: []
  type: TYPE_NORMAL
- en: 'An EF API mainly does four things:'
  prefs: []
  type: TYPE_NORMAL
- en: Maps classes to the database schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Translates LINQs into Entity Queries to SQL and executes them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracks changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saves changes in the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'EF converts entity objects and context classes into EDM, and EDM is used in
    the database. For example, let''s say we have the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The EF will convert it into EDM, which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Then, this EDM will be used to create or update the `Person` database table.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions in SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A transaction is a single unit of work that either has to complete the whole
    work or roll back to its previous state. A transaction can't stop in the middle
    of a piece of work. It's a very important feature for sensitive data-handling.
    One of the best uses of transactions is when dealing with money-transfer processes.
    When a person transfers some money to another person's account, if any error occurs in
    the middle of the process, the whole process should be cancelled or rolled back.
  prefs: []
  type: TYPE_NORMAL
- en: There are four properties of a transaction in SQL: **Atomic, Consistent, Isolated,
    and Durable** (**ACID**).
  prefs: []
  type: TYPE_NORMAL
- en: Atomic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Atomic means that all statements in a group must be executed. If one of the
    statements in a group doesn't get executed, none of the statement should be executed.
    The whole group of the statement should work as a single unit.
  prefs: []
  type: TYPE_NORMAL
- en: Consistent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a transaction is executed, the database should reach from one state to
    another. We call the initial point the starting point and the point after execution
    the end point. In a transaction, the start and end points should be clear. If
    the transaction is successful, the database state should be at the end point,
    otherwise it should be at the start point. Maintaining this consistency is what
    this property is about.
  prefs: []
  type: TYPE_NORMAL
- en: Isolated
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A group of a statements that are part of a transaction should be isolated from
    other statements in another transaction or manual statements. While a transaction
    is running, if another statement changes a particular piece of data, the whole
    transaction would produce bad data. When a transaction is run, all other outside
    statements are not allowed to run on that particular piece of data in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Durable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a group of statements is executed, the result needs to be stored in a
    permanent place. If, in the middle of a transaction, an error occurs, the statements
    can be rolled back and the database goes to its previous position.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions plays a very important role in SQL, so the SQL data provider provides
    the `SQLTransaction` class, which can be used to execute transactions using ADO.NET.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data is a very important part of a software application. To maintain data, we
    need some kind of database that will store the data in a structured way, so that
    it can be easily retrieved, saved, updated, and deleted. It's essential that our
    software is able to communicate with a data source to use the data. The ADO.NET
    framework provides this facility to .NET developers. Learning and understanding
    ADO.NET is one of the basic requirements of any .NET developer. In this chapter,
    we covered the fundamentals of ADO.NET elements, such as `DataProvider`s, `Connection`,
    Command, `DataReader`, and `DataAdapter`. We also learned how to connect with
    the SQL Server database and the Oracle Database using ADO.NET. We discussed stored
    procedures and explained what the Entity Framework is and how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will be talking about a very interesting topic: Reflection.'
  prefs: []
  type: TYPE_NORMAL
