- en: Networking with QtNetwork
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Humans are social creatures and, increasingly, so are the software systems we
    create. As useful as computers are on their own, they are far more useful when
    connected to other computers. Whether on a small local switch or the global internet,
    engaging with other systems over a network is crucial functionality for much modern
    software. In this chapter, we're going to explore the networking capabilities
    offered by Qt and how to use them within PyQt5.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Low-level networking with sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP communications with `QNetworkAccessManager`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will, as in other chapters, need a basic Python and PyQt5 setup as described
    in [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml), *Getting Started with
    PyQt*, and you will benefit from downloading the example code from our GitHub
    repository at [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter08](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you will want access to at least one other Python-equipped computer
    on the same local area network.
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action: [http://bit.ly/2M5xqid](http://bit.ly/2M5xqid)
  prefs: []
  type: TYPE_NORMAL
- en: Low-level networking with sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nearly every modern network uses the **internet protocol suite**, also known
    as **TCP/IP**, to facilitate connections between computers or other devices. TCP/IP
    is a set of protocols that manage the transmission of raw data over the network.
    The most common way to work with TCP/IP directly in code is with a **socket API**.
  prefs: []
  type: TYPE_NORMAL
- en: A socket is a file-like object that represents a single point of network connectivity
    for the system. Every socket has a **host address**, **network port**, and **transmission
    protocol**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The host address, also known as an **IP address**, is a set of numbers used
    to identify a single network host on a network. Although backbone systems rely
    on the IPv6 protocol, most personal computers still use the older IPv4 address,
    which consists of four numbers between `0` and `255` separated by a dot. You can
    find the address of your system using GUI tools, or by typing one of the following
    commands into a command-line terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '| OS | Command |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Windows | `ipconfig` |'
  prefs: []
  type: TYPE_TB
- en: '| macOS | `ifconfig` |'
  prefs: []
  type: TYPE_TB
- en: '| Linux | `ip address` |'
  prefs: []
  type: TYPE_TB
- en: Port is simply a number from `0` to `65535`. Although you can create a socket
    with any port number, certain port numbers are assigned to common services; these
    are called **well-known ports**. For example, HTTP servers are typically assigned
    to port `80`, and SSH is typically on port `22`. On many operating systems, administrative
    or root privileges are required to create a socket on ports less than `1024`.
  prefs: []
  type: TYPE_NORMAL
- en: An official list of well-known ports can be found at [https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Transmission protocols include **Transmission Control Protocol** (**TCP**) and
    **User Datagram Protocol** (**UDP**). TCP is a stateful connection between two
    systems. You can think of it as a phone call—a connection is established, information
    is exchanged, and at some definite point the connection is disconnected. Because
    of its statefulness, TCP ensures that all transmitted packets are received. UDP,
    on the other hand, is a stateless protocol. Think of it like using a walkie-talkie—users
    transmit a message, which receivers may or may not receive in whole or in part,
    and an explicit connection is never established. UDP is comparatively lightweight
    and often used for broadcast messages since it doesn't require a connection to
    a specific host.
  prefs: []
  type: TYPE_NORMAL
- en: The `QtNetwork` module provides us with classes to establish TCP and UDP socket
    connections. To understand how they work, we're going to construct two chat systems—one
    using UDP, the other using TCP.
  prefs: []
  type: TYPE_NORMAL
- en: Building a chat GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin by creating a basic GUI form that we can use for both versions
    of the chat application. Start with the application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow*, and add this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The GUI is pretty simple, just a text edit to display the conversation, a line
    edit to enter a message, and a button to send. We've also implemented a signal
    we can emit whenever the user submits a new message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GUI will also have two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `send()` method, triggered by the `send_btn` button, emits our `submitted`
    signal containing the text in the line edit, and the `write_message()` method
    which receives a `username` and `message` and writes it to the text edit using
    some simple formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Down in the `MainWindow.__init__()` method, add in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, before we can do any networking code, we need to add an `import` for
    `QtNetwork`. Add it to the top of the file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This code will be the base code for both our UDP and TCP chat applications,
    so save one copy of this file as `udp_chat.py` and another as `tcp_chat.py`. We'll
    complete each application by creating a backend object for the form.
  prefs: []
  type: TYPE_NORMAL
- en: Building a UDP chat client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UDP is most commonly used in broadcast applications on local networks, so to
    demonstrate this, we're going to make our UDP chat a local-network-only broadcast
    chat. That means that any computer on a local network running a copy of this application
    will be able to view and participate in the conversation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by creating our backend class, which we''ll call `UdpChatInterface`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our backend inherits `QObject` so that we can use Qt signals, of which we've
    defined two—a `received` signal that we'll emit when a message is received, and
    an `error` signal that we'll emit when an error happens. We've also defined a
    port number to use, and a `delimiter` string. The `delimiter` string will be used
    to separate the username and message when we serialize our message for transmission;
    so, when the user `alanm` sends the message `Hello World`, our interface will
    send the string `alanm||Hello World` out on the wire.
  prefs: []
  type: TYPE_NORMAL
- en: Only one application can be bound to a port at one time; if you already have
    an application using port `7777`, you should change this number to something else
    between `1024` and `65535`. On Windows, macOS, and older Linux systems, the `netstat`
    command can be used to show which ports are in use. On newer Linux systems, the
    `ss` command can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now start an `__init__()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After calling `super()` and storing the `username` variable, our first order
    of business is to create and configure a `QUdpSocket` object. Before we can use
    the socket, it must be **bound** to a localhost address and a port number. `QtNetwork.QHostAddress.Any`
    represents all addresses on the local system so our socket will be listening and
    sending on port `7777` on all local interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the socket, we have to handle its signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Socket objects have two signals that we're interested in watching. The first
    is `readyRead`, and it's emitted whenever data is received by the socket. We're
    going to handle that signal in a method called `process_datagrams()`, which we'll
    write in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: The `error` signal is emitted when there is an error of any kind, which we'll
    handle in an instance method called `on_error()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with that error handler since it''s relatively simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This method has a little bit of Qt magic in it. Network errors are defined in
    the `SocketError` enum of the `QAbstractSocket` class (the parent class of `UdpSocket`).
    Unfortunately, if we just try to print the error, we get the integer value of
    the constant. To actually get a meaningful string, we're going to dig into the
    `staticMetaObject` associated with `QAbstractSocket`. We first get the index of
    the enum class containing the error constants, then use `valueToKey()` to convert
    our socket error integer into its constant name. This trick can be used with any
    Qt enum to retrieve a meaningful name rather than just its integer value.
  prefs: []
  type: TYPE_NORMAL
- en: One that's been retrieved, we simply format the error in a message and emit
    it in our `error` signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s tackle `process_datagrams()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A single UDP transmission is known as a **datagram**. When a datagram is received
    by our socket, it is stored in a buffer and the `readyRead` signal is emitted.
    As long as that buffer has datagrams waiting, the socket's `hasPendingDatagrams()`
    will return `True`. Thus, we loop continually while there are pending datagrams,
    calling the socket's `receiveDatagram()` method, which returns and removes the
    next datagram waiting in the buffer until all the datagrams are retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: The datagram object returned by `receiveDatagram()` is a `QByteArray`, the Qt
    equivalent of a Python `bytes` object. Since our program is transmitting strings,
    rather than binary objects, we can just convert the `QByteArray` to a Unicode
    string. The fastest way to do this is to first cast it to a `bytes` object, then
    use the `decode()` method to convert it to UTF-8 Unicode text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our raw string, we need to check it to make sure it came from
    another instance of `udp_chat.py`, then split it out into its `username` and `message`
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If the raw text received by the socket doesn't contain our `delimiter` string,
    it's most likely from some other program or a corrupt packet, and we'll just skip
    it. Otherwise, we'll split it at the first instance of the `delimiter` into the
    `username` and `message` strings, then emit those strings with the `received`
    signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final thing our chat client needs is a method to send a message, which
    we''ll implement in the `send_message()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This method starts by formatting the passed message with our configured username
    using the `delimiter` string, then encodes the formatted string as a `bytes` object.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we write the datagram to our socket object using the `writeDatagram()`
    method. This method takes a `QByteArray` (to which we have cast our `bytes` object)
    and a destination address and port. Our destination is specified as `QHostAddress.Broadcast`,
    which indicates that we want to use the broadcast address, and the port is, of
    course, the one we defined in our class variable.
  prefs: []
  type: TYPE_NORMAL
- en: The **broadcast address** is a reserved address on a TCP/IP network which, when
    used, indicates that the transmission should be received by all hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s summarize what we''ve done in this backend:'
  prefs: []
  type: TYPE_NORMAL
- en: When a message is sent, it is prefixed with the username and broadcast as a
    byte array to all hosts on the network on port `7777`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a message is received on port `7777`, it is converted from a byte array
    to a string. The message and username are split and emitted in a signal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an error occurs, the error number is converted to an error string and emitted
    with an error signal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we just need to hook our backend into the frontend form.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Back in our `MainWindow` constructor, we need to finish up our application
    by creating a `UdpChatInterface` object and connecting its signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Before creating the interface, we're determining the `username` by grabbing
    the name of the current user's home directory. This is a bit of a hack, but it
    works well enough for our purposes here.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create our interface object and connect the chat window `submitted`
    signal to its `send_message()` slot.
  prefs: []
  type: TYPE_NORMAL
- en: We then connect the interface's `received` signal to the chat window's `write_message()`
    method, and the `error` signal to a lambda function that shows the error in a
    `QMessageBox`.
  prefs: []
  type: TYPE_NORMAL
- en: With everything wired up, we're ready to test.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the chat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test this chat system, you'll need two computers with Python and PyQt5 installed
    running on the same local area network. You may need to disable the systems' firewalls
    or open UPD port `7777` before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve done that, copy `udp_chat.py` to both machines and launch it.
    Type a message on one machine; it should show up in the chat window on both machines,
    looking something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/152c38db-31b6-4c6a-b19e-beea931a4787.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the systems also pick up and react to their own broadcast messages,
    so we don't need to worry about echoing our own messages in the text area.
  prefs: []
  type: TYPE_NORMAL
- en: UDP is certainly simple to work with, but it has many limitations. For example,
    UDP broadcasts cannot usually be routed outside a local network, and the lack
    of stateful connection means that there is no way to know whether a transmission
    was received or lost. In the *Building a TCP chat client* section, we'll build
    a TCP version of our chat that doesn't have these issues.
  prefs: []
  type: TYPE_NORMAL
- en: Building a TCP chat client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TCP is a stateful transmission protocol, meaning that a connection is established
    and maintained until the transmission is complete. TCP is also primarily a one-to-one
    connection between hosts, which we generally implement using a **client-server**
    design. Our TCP chat application will make a direct connection between two network
    hosts and will contain both a client component that will connect to other instances
    of the app and a server component that will handle incoming client connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `tcp_chat.py` file you created earlier, start a TCP chat interface class
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, this is identical to the UDP interface apart from the name. Now let''s
    create the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As before, the interface object takes a `username`, but we've added a `recipient`
    argument as well. Since TCP requires a direct connection to another host, we need
    to specify which remote host we want to connect to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to create the server component that will listen for incoming connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`listener` is a `QTcpServer` object. `QTcpServer` enables our interface to
    receive incoming connections from TCP clients on the given interface and port,
    which in this case we''ve set to any local interface on port `7777`.'
  prefs: []
  type: TYPE_NORMAL
- en: When there is an error with an incoming connection, the server object emits
    an `acceptError` signal, which we connect to an `on_error()` method. These are
    the same kind of errors that `UdpSocket` emits, so we can copy the `on_error()`
    method from `udp_chat.py` and handle them identically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `newConnection` signal is emitted whenever a new connection comes into
    the server; we''re going to handle that in a method called `on_connection()`,
    which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The server's `nextPendingConnection()` method returns the next waiting connection
    as a `QTcpSocket` object. Like `QUdpSocket`, `QTcpSocket` emits a `readyRead`
    signal when it receives data. We'll connect this signal to a `process_datastream()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll save a reference to our new connection in the `self.connections`
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Working with data streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While UDP sockets work with datagrams, TCP sockets work with **data streams**.
    As the name implies, data streams involve a flow of data rather than discrete
    units. TCP transmissions are sent as a stream of network packets that may or may
    not arrive in the correct order, and it's up to the receiver to correctly reassemble
    the data received. To make this process easier, we can wrap our socket in a `QtCore.QDataStream`
    object, which provides a generic interface for reading and writing data from file-like
    sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin our method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We're iterating through the connected sockets and passing each to a `QDataStream`
    object. The `socket` object has a `bytesAvailable()` method that tells us how
    many bytes of data are queued up to be read. If this number is zero, we're going
    to continue to the next connection in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'If not, we''ll read from the data stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`QDataStream.readQString()` attempts to pull a string from the data stream
    and return it. Despite the name, in PyQt5 this method actually returns a Python
    Unicode string, not a `QString`. It''s important to understand that this method
    *only* works if a `QString` was sent with the original packet. If some other object
    was sent (a raw byte string, an integer, and so on), `readQString()` will return
    `None`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `QDataStream` has methods for writing and reading a variety of data types.
    See its documentation at [https://doc.qt.io/qt-5/qdatastream.html](https://doc.qt.io/qt-5/qdatastream.html).
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the transmission as a string, we check for the `delimiter` string
    in the raw message and, if found, split the raw message and emit the `received`
    signal.
  prefs: []
  type: TYPE_NORMAL
- en: Sending data over TCP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QTcpServer` has handled the reception of messages; now we need to implement
    sending messages. To do this, we first need to create a `QTcpSocket` object to
    be our client socket.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add this to the end of `__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We've created a default `QTcpSocket` object and connected its `error` signal
    to our error handling method. Note that we don't need to bind this socket because
    it won't be listening.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the client socket, we''ll create a `send_message()` method; just as
    with our UDP chat, this method will start by formatting the message it into the
    raw transmission string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to connect to the remote host with which we''re going to communicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The socket's `state` property can tell us whether our socket is connected to
    a remote host. The `QAbstractSocket.ConnectedState` state indicates that our client
    is connected to a server. If it's not, we call the socket's `connectToHost()`
    method to establish the connection to our recipient host.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can be fairly certain we've connected, let's send the message. To
    do this, we once again turn to the `QDataStream` object to handle the delicate
    aspects of communicating with our TCP socket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by creating a new data stream attached to the client socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can write a string to the data stream using its `writeQString()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s important to understand that objects can be pulled from the data stream
    only in the order we sent them. For instance, if we wanted to prefix the string
    with its length so that the recipient can check it for corruption, we might do
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `process_datastream()` method would then have to be adjusted accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The last thing we need to do in `send_message()` is emit our message locally
    so that the local display can show it. Since this isn't a broadcast message, our
    local TCP server won't hear the messages being sent out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this at the end of `send_message()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s summarize how this backend operates:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a TCP server component:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TCP server object listens for connections from remote hosts on port `7777`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When one is received, it stores the connection as a socket and waits for data
    from that socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When data is received, it is read from the socket using a data stream, interpreted,
    and emitted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have a TCP client component:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a message needs to be sent, it is first formatted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then the connection state is checked, and one is established if necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the connection state is ensured, the message is written to the socket using
    a data stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting our backend and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Back in `MainWindow.__init__()`, we need to add the relevant code to create
    our interface and connect the signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Since we need a recipient, we'll ask the user using a `QInputDialog`. This dialog
    class allows you to easily query a user for a single value. In this case, we're
    asking for the IP address or hostname of the other system. This value we pass
    to the `TcpChatInterface` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code is essentially the same as the UDP chat client.
  prefs: []
  type: TYPE_NORMAL
- en: To test this chat client, you'll need to run one copy on another computer on
    the same network or on an address you can reach from your own network. When you
    launch the client, specify the IP or hostname of the other machine. Once both
    clients are running, you should be able to send messages back and forth. If you
    launch the client on a third machine, note that you won't see the messages, since
    they are being directed to a single machine only.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP communications with QNetworkAccessManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**HyperText Transfer Protocol** (**HTTP**) is the protocol on which the World
    Wide Web is built, and arguably the most important communications protocol of
    our time. We could certainly implement our own HTTP communications on top of sockets,
    but Qt has already done the work for us. The `QNetworkAccessManager` class implements
    an object that can transmit HTTP requests and receive HTTP replies. We can use
    this class to create applications that communicate with web services and APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: Simple downloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To demonstrate the basic use of `QNetworkAccessManager`, we''re going to build
    a simple command-line HTTP download tool. Open a blank file called `downloader.py`
    and let''s start with some imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Since we aren't doing a GUI here, we don't need `QtWidgets` or `QtGui`, just
    `QtNetwork`, and `QtCore`. We'll also use the standard library `path` module for
    some filesystem-based operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `QObject` subclass for our download engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Inside our download engine, we're creating a `QNetworkAccessManager` and connecting
    its `finished` signal to a callback called `on_finish()`. The `finished` signal
    is emitted when the manager completes a network transaction and has a reply ready
    to process, which it includes with the signal.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a `QNetworkRequest` object. `QNetworkRequest` represents the
    HTTP request that we're sending to the remote server and contains all the information
    we're going to send. In this case, we just need the URL that has been passed into
    the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we tell our network manager to execute the request using `get()`. The
    `get()` method sends our request using the HTTP `GET` method, which is typically
    used for requesting information for download. The manager will send this request
    and await a reply.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the reply comes, it will be sent to our `on_finished()` callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `reply` object here is a `QNetworkReply` instance, which contains the data
    and metadata received from the remote server.
  prefs: []
  type: TYPE_NORMAL
- en: We first try to determine a filename, which we'll use for saving the file. The
    reply's `url` property contains the URL to which the original request was made,
    and we can query the URL's `fileName` property. Sometimes this is empty, though,
    so we'll fall back to the `'download'` string.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll check whether the filename already exists on our system. For safety,
    we exit if it does, so that you don't destroy important files on your system testing
    this demo.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we extract the data from the reply using its `readAll()` method, writing
    this data to a local file. Notice that we open the file in `wb` mode (write-binary)
    since `readAll()` returns binary data in the form of a `QByteAarray` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main execution code for our `Downloader` class comes last:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're just getting the first argument from the command line and passing
    it into our `Downloader` object. Notice that we use `QCoreApplication` rather
    than `QApplication`; this class is used when you want to create a command-line
    Qt application. It's otherwise the same as `QApplication`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, using `QNetworkAccessManager` is as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `QNetworkAccessManager` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `QNetworkRequest` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass the request to the manager's `get()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle the reply in a callback connected to the manager's `finished` signal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Posting data and files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Retrieving data with a `GET` request is fairly simple HTTP; for a deeper exploration
    of HTTP communications with PyQt5, we're going to build a utility that will allow
    us to send `POST` requests with arbitrary key-value and file data to a remote
    URL. This utility might be useful for testing web APIs, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Building the GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting with a copy of your Qt application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow*, let''s add our main GUI code into the
    `MainWindow.__init__()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple form built on a `QWidget` object. There is a line input for
    the URL, a table widget for entering key-value pairs, and a button that will be
    used to trigger a file dialog and store the selected filename.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we have a `submit` button for sending the request and a read-only
    text edit that will display the returned results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fname` button calls `on_file_btn()` when clicked, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This method simply calls a `QFileDialog` function to retrieve a filename to
    open. In order to keep things simple, we're taking the slightly unorthodox approach
    of storing the filename as our `QPushButton` text.
  prefs: []
  type: TYPE_NORMAL
- en: The final `MainWindow` method is `submit()`, which is called when the `submit`
    button is clicked. We'll come back to that method after writing our web backend
    since its operation depends on how we define that backend.
  prefs: []
  type: TYPE_NORMAL
- en: The POSTing backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our web posting backend will be based on a `QObject` simply so that we can use
    signals and slots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by subclassing `QObject` and creating a signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `replyReceived` will be emitted when we receive a reply from the server
    to which we're posting and will carry with it the body of the reply as a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're creating our `QNetworkAccessManager` object and connecting its `finished`
    signal to a local method called `on_reply()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `on_reply()` method will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Recall that the `finished` signal carries with it a `QNetworkReply` object.
    We can call its `readAll()` method to get the body of the reply as a `QByteArray`.
    Just as we did with our raw socket data, we first cast this to a `bytes` object,
    then use the `decode()` method to convert it to UTF-8 Unicode data. Finally, we'll
    emit our `replyReceived` signal with the string from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need a method that will actually post our key-value data and file to
    a URL. We''ll call it `make_request()`, and it begins as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Just as with a `GET` request, we start by creating a `QNetworkRequest` object
    from the provided URL. Unlike the `GET` request, however, our `POST` request carries
    a data payload. To carry this payload, we need to create a special object that
    we can send with the request.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few ways that an HTTP request can format a data payload, but the
    most common way to transmit a file over HTTP is to use a **Multipart Form** request.
    This kind of request contains both key-value data and byte-encoded file data and
    is what you would get from submitting an HTML form containing a mix of input widgets
    and file widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform this kind of request in PyQt, we will begin by creating a `QtNetwork.QHttpMultiPart`
    object, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There are different types of multipart HTTP messages, and we define which type
    we want by passing a `QtNetwork.QHttpMultiPart.ContentType` enum constant to the
    constructor. The type we need for transmitting file and form data together is
    `FormDataType`, which we've used here.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP multipart object is a container for `QHttpPart` objects, each of which
    represents a component of our data payload. We need to create these parts from
    the data passed into this method and add them to our multipart object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with our key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Each HTTP part has a header and a body. The header contains metadata about the
    part, including its **Content-Disposition**—in other words, what it contains.
    In the case of form data, that would be `form-data`.
  prefs: []
  type: TYPE_NORMAL
- en: So, for each key-value pair in the `data` dictionary, we're creating a single
    `QHttpPart` object, setting the Content-Disposition header to `form-data` with
    a `name` argument set to the key. Finally, we set the body of the HTTP part to
    our value (encoded as a byte string) and add the HTTP part to our multipart object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To include our file, we need to do something similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This time, our Content-Disposition header is still set to `form-data`, but also
    includes a `filename` argument set to the name of our file. The body of the HTTP
    part is set to the contents of the file. Note that we open the file in `rb` mode,
    meaning that its binary contents will be read as a `bytes` object rather than
    interpreting it as plaintext. This is important as `setBody()` expects bytes rather
    than Unicode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our multipart object is built, we can call the `post()` method of
    our `QNetworkAccessManager` object to send the request with the multipart data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in `MainWindow.__init__()`, let''s create a `Poster` object to work with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Since `replyReceived` emits the reply body as a string, we can connect it directly
    to `setText` in our response widget to view the server's response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, it''s time to create our `submit()` callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Remember that `make_request()` wants `QUrl`, a `dict` of the key-value pairs,
    and a filename string; so, this method simply goes through each widget, extracting
    and formatting the data, then passes it to `make_request()`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the utility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have access to a server that accepts POST requests and file uploads,
    you can certainly use that to test your script; if not, you can also use the `sample_http_server.py`
    script included with the example code for this chapter. This script requires only
    Python 3 and the standard library and will echo back your POST request to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch the server script in a console window, then in a second console run
    your `poster.py` script and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Enter `http://localhost:8000` for the URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a few arbitrary key-value pairs to the table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select a file (probably a not-very-large text file, such as one of your Python
    scripts) to upload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click Submit Post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You should see a printout of your request in both the server console window
    and in the response text edit on the GUI. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fbc5b22b-9a2f-4e97-8897-c328187ecffd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To summarize, handling a `POST` request with `QNetworkAccessManager` involves
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a `QNetworkAccessManager` and connecting its `finished` signal to a
    method that will process a `QNetworkReply`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `QNetworkRequest` pointed to the target URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a data payload object, such as a `QHttpMultiPart` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing the request and data payload to the `QNetworkAccessManager` object's
    `post()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored connecting our PyQt applications to the network.
    You learned how to do low-level programming with sockets, including both a UDP
    broadcast application and TCP client-server application. You also learned how
    to interact with HTTP services using `QNetworkAccessManager`, beginning with simple
    downloading and ending with the uploading of complex multi-part form and file
    data.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will explore the use of SQL databases to store and retrieve
    data. You will learn how to build and query a SQL database, how to integrate SQL
    commands into your applications using the `QtSQL` module, and how to use SQL model-view
    components to quickly build data-driven GUI applications.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try these questions to test your knowledge from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You are designing an application that will emit a status message to the local
    network, which you will monitor with administrator tools. What kind of socket
    object would be a good choice?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your GUI class has a `QTcpSocket` object called `self.socket`. You've connected
    its `readyRead` signal to the following method, but it's not working. What's happening,
    and how can you fix it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Use `QTcpServer` to implement a simple service that listens on port `8080` and
    prints any requests received. Make it reply to the client with a byte string of
    your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''re creating a download function for your application to retrieve a large
    data file for import into your application. The code does not work. Read the code
    and decide what you''re doing wrong:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Modify your `poster.py` script so that it sends the key-value data as JSON rather
    than HTTP form data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For further information, please refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: More information on the datagram packet structure can be found at [https://en.wikipedia.org/wiki/Datagram](https://en.wikipedia.org/wiki/Datagram).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the ever-increasing focus on security and privacy in network communications,
    it's important to know how to work with SSL. See [https://doc.qt.io/qt-5/ssl.html](https://doc.qt.io/qt-5/ssl.html)
    for an overview of the `QtNetwork` facilities for working with SSL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Mozilla Developer Network** has a large number of resources for understanding
    HTTP and its various standards and protocols at [https://developer.mozilla.org/en-US/docs/Web/HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
