- en: Chapter 1. Getting to Know Bash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Bourne Again SHell** (**bash**) is arguably one of the most important
    pieces of software in existence. Without bash shell's many utilities and the problem-solving
    potential it gives its users by integrating and interfacing system utilities in
    a programmable way (called **bash scripting**), many of the very important security-related
    problems of the modern world would be very tedious to solve. Utilities such as
    `grep`, `wget`, `vi`, and `awk` enable their users to do very powerful string
    processing, data mining, and information management. System administrators, developers,
    security engineers, and penetration testers all across the world for many years
    have sworn by its sheer problem-solving potential and effectiveness in enabling
    them to tackle their day-to-day technical challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Why are discussing the bash shell? Why is it so popular among system administrators,
    penetration testers, and developers? Well, there may be other reasons, but fundamentally
    the bash shell is the most standardized and is usually, with regard to most popular
    operating systems, implemented from a single code base—one source for the official
    source code. This means one can guarantee a certain base set of execution behaviors
    for a bash script or collection of commands regardless of the operating system
    hosting the bash implementation. Operating systems popularly have unique implementations
    of the **Korn Shell** (**ksh**) and other terminal emulator software.
  prefs: []
  type: TYPE_NORMAL
- en: The only disadvantage, if any, of the Linux or Unix environment that bash is
    native to is that for most people, especially those accustomed to the **Graphical
    User Interface** (**GUI**), the learning curve may be a little steep. This is
    mainly because the way information is represented. The general Linux/Unix culture
    and conventions can often be difficult to appreciate for newcomers and possibly
    due to the lack of tooltips, hints, and rich graphical interaction design and
    user experience engineering GUIs often benefit from. This book and especially
    this chapter will introduce some of the witty but brilliant Linux/Unix culture
    and conventions so that you can get comfortable enough with the bash shell and
    eventually find your own way around and follow the more advance topics later on
    in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the book, the bash environment or the host operating system that
    will be discussed will be Kali Linux. Kali Linux is a distribution adapted from
    Debian, and it is packed with utilities focused purely on technical security problem
    solving and testing. Because knowing how to wield your terminal is strongly associated
    with knowing your operating system and its various nuances, this chapter and the
    following chapters will introduce some topics related to the Kali Linux operating
    system, its configuration setup, and default behavior to enable you to properly
    use your terminal utilities.
  prefs: []
  type: TYPE_NORMAL
- en: If you're already a seasoned "basher", feel free to skip this chapter and move
    on to the more security-focused topics in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Getting help from the man pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bash shells typically come bundled with a very useful utility called man files,
    short for manual files. It's a utility that gives you a standardized format to
    document the purpose and usage of most of the utilities, libraries, and even system
    calls available to you in your Unix/Linux environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will frequently make use of the conventions and
    descriptive style used in man files so that you can comfortably switch over to
    using the man pages to support what you've learnt in the following sections and
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using man files is pretty easy; all you need to do is fire off the following
    command from your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous command, `[SECTION NUMBER]` is the number of the man page section
    to be referenced and `[MAN PAGE NAME]` is, well, the name of the man page. Usually,
    it is the name of the command, system call, or library itself. For example, if
    you want to look up the man page for the man command itself, you would execute
    the following command from your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the previous command, `1` tells man to use section 1 and the `man` argument
    suffixing the command is the name of the man page, which is also the name of the
    command to which the page is dedicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Man page sections are numbered according to a specification of their own. Here''s
    how the numbers are appropriated:'
  prefs: []
  type: TYPE_NORMAL
- en: '**General commands**: You usually use this section to look up the information
    about commands used on the command line. In a previous example in this section,
    we used it to look up information about the man file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**System calls**; This section documents the arguments and purpose of common
    system calls facilitated by the host operating system.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**C library functions**: This section is very useful for C developers and developers
    who use languages developed as C derivatives such as Python. It will give you
    information about the arguments, defining header files, behavior, and purpose
    of certain fundamental C library function calls.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Special files**: This section documents special-purpose files, typically
    those in the `/dev/` directory, for instance, character devices, pseudo terminals,
    and so on. Try picking a couple files in the `/dev/` directory of your operating
    system and executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**File formats and conventions**: This section documents common file formats
    used to structure information about the system, for instance, logfile formats,
    the password file formats, and so on. Usually, any file is used to document the
    information generated by common operating system utilities.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Games and Screensavers**: This section contains information about games and
    screensavers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Miscellanea**: This section contains information about miscellaneous commands
    and other information. It is reserved for documentation of anything that does
    not fit into the other categories.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**System administration commands and daemons**: This section is dedicated to
    administration commands and information about system daemons.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For a synopsis and full description of these sections, try checking out the
    intro man files for each of them. You can reach these files by executing the following
    command for each section number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: I've documented all the man page section numbers and their traditional purpose
    here. Of course, it is up to developers to uphold these conventions, but generally
    all you will be interested in is section 1, and if you're going to do some reverse
    engineering, section 2, 3, and 4 will also be of great help.
  prefs: []
  type: TYPE_NORMAL
- en: 'The man page layout is standardized to contain a certain collection of sections.
    Each section of the man page describes a given property of the command, system
    call, or library being discussed. The following list explains the purpose of the
    common sections in man file:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: This is the name of the command, function, system call, or file format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Synopsis**: This is a formal description of the command, system call, file
    format, or what have you describing the usage specification. The way the syntax
    or usage specifications for commands are specified takes a little understanding
    to appreciate properly. You may notice the braces in the specification, these
    are not to be interpreted as literal parts of the command invocation. In fact,
    they indicate that whatever appears inside the brackets is an optional argument.
    Also, the "|" character indicates that either the symbols preceding it or following
    it can be specified as part of the command invocation but not both; think of it
    as a logical OR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: This is an informal description and discussion of the man
    page topic, detailing its purpose and more information about the options and possible
    arguments mentioned in the Synopsis section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Examples**: This is a collection of examples for the usage of the man page
    topic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**See also**: This is a collection of references, web pages, and other resources
    containing further information about the topic being discussed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more about the Linux manual pages, please see the *Further reading* section
    at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating and searching the filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Navigating and searching the Linux filesystem is one of the most essential skills
    the developers, system administrators, and penetration testers will need to master
    in order to realize the full potential of their bash consoles and utilities. To
    properly master this skill, you will need a good understanding of the organization
    of your host operating system though it is a little out of context of this book
    to have a thorough discussion of the Kali Linux operating system's inner workings
    and organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigating a filesystem requires the use of a sample collection of the tools
    and utilities. Here''s a breakdown of these tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Command name | Common name | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cd` | Change Directory | This changes your current working directory |'
  prefs: []
  type: TYPE_TB
- en: '| `ls` | List | This lists the contents of the current working directory |'
  prefs: []
  type: TYPE_TB
- en: '| `pwd` | Print Working Directory | This displays the current working directory
    |'
  prefs: []
  type: TYPE_TB
- en: '| `find` | Find | This locates or verifies the existence of a file based on
    a the values of certain attributes |'
  prefs: []
  type: TYPE_TB
- en: Navigating directories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Navigating directories is popularly done by using the `cd` command, which is
    probably one of the simplest commands to use. All you need to do is supply the
    directory you wish to change to and `cd` will do the rest. It also has very useful
    shorthands to speed up the most common tasks users perform when navigating their
    filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what the command usage specification looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the syntax specification, `[directory]` is the directory you wish to change
    your current working directory to and `[-L|-P]` may be any one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-L`: When changing directory, symbolic links should not be respected. The
    current directory will be changed to include the name of the symbolic link and
    not its target. This is described in documentation as making the symbolic link
    logical, since it forces the name of the symbolic link to be treated as logical
    element in the path being set as the working directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Symbolic links are constructs on a filesystem that allow one file or directory
    to act purely as a reference to another file. These links affect the way path
    resolution occurs, since in some situations when a symbolic link is followed,
    it will allow one path to direct the current directory to a file represented by
    another name, as opposed to a pathname resolving strictly as it is named.
  prefs: []
  type: TYPE_NORMAL
- en: '`-P`: This is the opposite of the `-L` command. This specifies that should
    the file being set as the current directory be symbolic link, it should be resolved
    completely before being set as the current directory. This means if you visit
    a symbolic link, your current path will not reflect the name of the symbolic link
    you used to reach it, unless of course if the link has the same name as its target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a typical usage example of the `cd` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will change your current directory to the root directory,
    which is named `/`; everything hosted on your filesystem is usually reachable
    from this directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cd ~`: This command is used to navigate to the current user''s home directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cd ../`: This command is used to navigate to the directory directly above
    the current one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the preceding command, one can have `cd` navigate an arbitrary number of
    directories above the current one, for instance, by supplying it a command as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are some other commands that can be used to navigate to different
    directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cd .`: This command is used to navigate to the current directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cd –`: This command is used to navigate to the previous directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cd --`: This command is used to navigate to the second-last directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To see whether you have indeed changed your current working directory to the
    one you''ve specified, you can invoke the `pwd` command that will print your working
    directory. The syntax for the `pwd` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `–L` or `--logical` and `–P` or `--physical` invocation options serve the
    same purpose as in the `cd` command.
  prefs: []
  type: TYPE_NORMAL
- en: Listing directory contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's not enough to just move between directories. You will eventually want to
    find out what's inside these directories. You can do this by using the `ls` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the usage specification for the `ls` command—adapted from
    its man page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command specification is another popular Linux/Unix convention.
    It''s a shorthand to specify that any of the letters appearing in the brackets
    can be specified as part of the command invocation. Also, any number of them may
    be specified at the same time. For instance, consider the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: According to the command specification, they are all acceptable ways to use
    the `ls` command. Whether or not any of these will actually do something useful
    depends on how each switch affects the `ls` command's behavior. You should keep
    in mind that some options may have opposing effects or certain combinations may
    have no effect, like a general note when reading usage specifications such as
    the one for `ls`.
  prefs: []
  type: TYPE_NORMAL
- en: The `[FILE]` or `[DIRECTORY]` argument would be any path or file at which you
    wish to fire `ls`. Without any arguments, `ls` will list the current working directory's
    entries.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **switch** is a popular jargon for the options, that is, anything directly
    following the hyphen, specified as part of the command invocation. For example,
    `–l` is a switch.
  prefs: []
  type: TYPE_NORMAL
- en: Here's what some of the switches do—we will only discuss some of the most important
    switches here for the sake of brevity. Keep in mind that the `ls` command lists
    directory contents, so all its options will be focused on organizing and presenting
    a given directory's contents in a specified way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the `ls` command''s invocation options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-a –-all`: This displays all the directory entries and does not omit directories
    or file starting with "." in their names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-d –directory`: This lists the directory entries and not their contents. This
    will also force `ls` not to dereference symbolic links.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-h`: This prints sizes in human-readable format, for instance, instead of
    the number of bytes only it will display file sizes in gigabytes, kilobytes, or
    megabytes where applicable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-i`: This prints the **inode** number of each file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inodes or `i-nodes` are data structures assigned to files that represent detailed
    information about their access rights, access times, sizes, owners, and the location
    of the file on the actual block devices—the physical medium hosting the file—as
    well as other important housekeeping-orientated details.
  prefs: []
  type: TYPE_NORMAL
- en: '`-l`: This lists the entries in long format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-R –-recursive`: This recursively lists directory contents. This tells `ls`
    to nest down all the levels of the specified path and enumerate all the reachable
    file paths, instead of stopping once the working directory is listed—as is the
    default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-S`: This lists the entries sorted by file size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-x`: This sorts entries alphabetically by extension, for example, all PDFs
    after MP3s.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some examples of these options in action. For instance, if
    you''d like to say sort a bunch of files by their size, while displaying human-readable
    file sizes and all the access rights and creation times—which seems like a lot
    of work—you would run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You''re output could look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing directory contents](img/5107OT_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another very useful example would be checking the volume of logins to the system.
    This can be done by looking at the output of the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Generally, keeping track of the contents of the `/var/log/` directory will always
    be a good way to grab a good synopsis of the activity on a system.
  prefs: []
  type: TYPE_NORMAL
- en: Searching the filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another important skill is being able to find resources on your filesystem
    in a compact yet powerful way. One of the ways you can do this is by using the
    aptly named `find` command. The following command is how `find` works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find out more about the `find` command by checking out the man file
    on it. This can be done by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This was discussed in the *Getting help from the man pages* section earlier
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, the first three switches, namely, `-H`, `-L`, and `–P`, all control
    the way symbolic links are treated. The following list tells what they do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-H`: This tells `find` not to follow symbolic links. Symbolic links will be
    treated as normal files and will not resolve them to their targets. Putting it
    simply, if a directory contains a symbolic link, the symbolic link will be treated
    as any other file. This does not affect symbolic links that form part of the selection
    criteria; these will be resolved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-L`: This forces `find` to follow symbolic links in the directories being
    processed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-P`: This forces `find` to treat symbolic links as normal files. If a symbolic
    link is encountered during execution, `find` will inspect the properties of the
    symbolic link itself and not its target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `–D` switch is used to allow `find` to print debug information if you need
    to know a little about what `find` is up to while it's searching for the files
    you want. `-0level` controls how `find` optimizes tests and it also allows you
    to reorder some tests. The `level` part can be specified as any number between
    0 and 3 (inclusive).
  prefs: []
  type: TYPE_NORMAL
- en: The `[path...]` part of the argument is used to tell find where to look for
    files. You can also use the `.` and `..` shorthands to specify the current and
    directory one level up respectively, as with the `cd` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next argument, or rather group of arguments, is quite an important one:
    the `[expression]`. It consists of all the arguments that control the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Options**: This tells what kind of files `find` should look for'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tests**: This tells how to identify the files it is looking for'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions**: This tells what `find` should do with the files once they are
    found'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the structural breakdown of the `find` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous code only serves as information about the structure of the expression,
    to let you know which options go where. Many of the switches for each section
    have been omitted for brevity. The `:=` characters mean that whatever is on the
    left-hand side is defined by whatever is defined on the right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: So now that you know where everything goes, let's look at what some of these
    arguments do. The `find` command has quite a number of very powerful options and
    operational modes, and one could quite literally write an entire book about `find`
    itself. So to make sure you don't get short changed—buying a book about "command
    line hacking" and instead learning only about `find`—we will only discuss some
    of the most common options and arguments penetration testers, system administrators,
    and developers use. The rest of the `find` command's power can be learned from
    the Linux manual files.
  prefs: []
  type: TYPE_NORMAL
- en: The following is a summary of some of the `find` command's possible arguments
    for options, tests, and actions.
  prefs: []
  type: TYPE_NORMAL
- en: Directory traversal options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are some of the options arguments you can use with `find`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-maxdepth n`: This specifies that tests must only be applied to entries in
    directories at most `n` levels below the current directory. This option is useful
    if you''re searching through directories that have a similar structure. For instance,
    if each directory below the one you''re searching has something like a `lib` directory
    that contains uninteresting files, you can skip all such directories by specifying
    this option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-mindepth n`: This specifies that tests should only be applied to files at
    depth of at least `n` directories lower than the specified path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-daystart`: This forces any `–amin`, `-atime`, `-cmin`, `-ctime`, or equivalent
    time-related tests to use the time starting from the beginning of the current
    day, rather than 24 hours ago—as is the default behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-mount`: This forbids `find` from traveling into other filesystems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `find` command allows you to specify numeric arguments using convenient
    shorthands to indicate an "at least" or "at most" type comparison with the specified
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '`+n`: This indicates the specified argument is to be compared as greater than,
    or at least `n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-n`: This indicates the specified argument is to be compared as less than
    or at most `n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n`: This forces find to compare `n` as is, and the attribute must have the
    exact value of `n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File testing options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tests are applied to a file and either return `true` or `false`: either the
    file being tested has the desired attribute or it doesn''t. More than one test
    can also be supplied, in which case a logical combination—which can also be specified—is
    applied. By default, if no Boolean is supplied to combined to tests, a logical
    AND is assumed. This means both tests must be true for the file to be *found*
    or *reported*. The following are some of the file testing options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-amin n`: This specifies that the last access time of the file should be *n*
    minutes ago. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-amin 20`: This means the file must have been accessed exactly 20 minutes
    ago'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-amin +35`: This means the file must have been accessed at most 35 minutes
    ago'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-atime n`: This specifies that the file should have been access *n*24* hours
    ago, meaning *n* days. Any fractional part of this number is ignored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-mmin n`: This specifies that the file should have been modified *n* minutes
    ago.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-mtime n`: This is the same as `–atime`, except it matches against the files
    modified time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-executable | -readable | -writable`: This matches any file that has access
    rights indicating that the file is executable, readable, or writable, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-perm`: This mode specifies that the file group should be name. The `–perm`
    option offers a myriad of different ways to specify the access mode being tested,
    here''s how it works.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The access mode bits can be prefixed with anyone of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mode`: This means no prefix and the mode must be matched exactly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-mode`: This means the file''s mode must have at least the specified bits
    set. This will match files with other bits set as long as the specified bits are
    set as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/mode`: This means that any of the specified bits must be set for the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mode itself can also be specified in two different ways, symbolically using
    characters to indicate user types and access modes or the octal decimal mode specification.
  prefs: []
  type: TYPE_NORMAL
- en: '`-iname nAmE`: This specifies that the name of the file should match `nAmE`
    if the case is ignored; in other words, case-insensitive name matching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-regex pattern`: This matches the specified pattern as a regular expression
    against the file''s pathname. Your regular expression must describe the entire
    pathname.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regular expressions are merely ways to describe a set of strings with a specified
    number of properties in common. If you want to describe a string, you must be
    able to detail all the properties of the string from beginning to the end. If
    you don't describe a single character in some or other way, the regular expression
    won't match!
  prefs: []
  type: TYPE_NORMAL
- en: Regular expression are in themselves a language, for instance, you could write
    a regular expressions to describe regular expressions! This means you will need
    to know how to speak this language in order to use regular expressions properly.
    To find out how to do this, see the *Further reading* section at the end of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few simple examples of the `–regex` option''s usage:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Find all the files directly under the `/etc/` directory that start with the
    letter `p` and end in anything using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Find all the files on the filesystem that are called configuration, ignoring
    case, and accommodating abbreviations such as `confg`, `cnfg`, and `cnfig` using
    the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'See the following screenshot for a practical example of the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![File testing options](img/5107OT_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The regular expression used here must describe the entire file''s path! For
    instance, consider the difference in results between the following two regular
    expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Bash script comments**'
  prefs: []
  type: TYPE_NORMAL
- en: Any bash command or text fed to the bash interpreter and preceded by a hash
    character is considered a comment, and it will not interpreted.
  prefs: []
  type: TYPE_NORMAL
- en: File action options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are some of the action arguments you can use with `find`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-delete`: This action forces `find` to delete any file for which the specified
    test returns `true`. For instance, consider the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This command will find and delete anything reachable one level from the root
    that has a name such as 'virus'—case-insensitive.
  prefs: []
  type: TYPE_NORMAL
- en: '`-exec`: This allows you to specify an arbitrary command to execute on all
    files that match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The way this argument works is to build a command line—which is probably passed
    to some `exec*` type system call—using the results of the `find` operation for
    every result. The `find` command will use any argument after the `–exec` switch
    as a literal argument to the command being executed and any instance of the `{}`
    chars as a placeholder for the name of the file, until a `;` character is encountered.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider the following as the `–exec` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual command line(s) that will be run will look something like the following
    command, since the only file that will match will be `/etc/passwd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'See the following screenshot for a comparison of the `stat` and `find –exec`
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![File action options](img/5107OT_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`-execdir`: This works the same way `–exec` does, except it will isolate execution
    of the specified command to the directory of the match file. This works great
    if you''d like to execute commands based on the contents of a directory that has
    certain files. For instance, you may want to edit all the `.bashrc` files for
    users that don''t have `.vimrc`, which is a configuration script for the VIM text
    editor. We will discuss more about the `.bashrc` code later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-print0`: This prints the file''s full name to standard output. This argument
    also has the added benefit of terminating filenames with a NULL character, or
    `0x0` character, so as to allow filenames to contain newlines. It also helps make
    sure that any program interpreting the output of find will be able to determine
    the separation between filenames, as they will be strictly separated by NULL characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NULL characters are traditionally used to mark the end of a character string.
    The NULL character itself is represented at memory level as a `0` value so that
    compilers and operating systems can clearly recognize the delimitation between
    strings appearing in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '`-ls`: This lists the current file by executing `ls –dils`, and the output
    is printed to standard output. The `–dils` option makes sure that the directory
    entries are printed. If the matched file is a directory, then inode is printed,
    and the entry appears in the `ls` command''s long listing format as well as the
    size of the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a couple more actions you can specify. For the rest of them, please
    see the manual file on the `find` command, which you can access using the man
    `find` command.
  prefs: []
  type: TYPE_NORMAL
- en: So as far as searching your filesystem for files, directories, or generally
    any other interesting things, that's pretty much it. The next fundamental skill
    you'll need to master is redirecting output from one command to another.
  prefs: []
  type: TYPE_NORMAL
- en: Using I/O redirection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I/O redirection is one of the easiest things to master when it comes to the
    bash scripting. It's as simple as knowing where you want your input to go and
    where it's coming from. It may seem like this is a very interesting topic and
    you might not see why you need to know this, but redirecting output—if you truly
    get to understand what it's all about—will be what you're doing on your command
    line almost 80 percent of the time! It's essentially the one thing that allows
    you to combine different utilities and have them work together quite effectively
    on the command line in a compact and simple way. For instance, you may want to
    search through the output from `nmap` or `tcpdump` or a key-logger by feeding
    its output to another file or program to analyze.
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To redirect the output of one program that is invoked from the command line
    into a file, all you need to do is add a `>` symbol at the end of the command
    line for the said program and proceed this with a filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, using the most recent example, if you want to redirect the output
    of the `find` command to a file named something like `writeable-files.txt`, this
    is how it would be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one small detail about this kind of I/O redirection though, as with
    many of the common bash shorthands: there''s usually quite a bit going on under
    the hood. If used as demonstrated previously, the only output that will actually
    appear in the chosen file (for the previous example it is `writeable-files.txt`)
    would be the output actually printed to the standard output file that is commonly
    referred to as file descriptor 0, which is the default destination for normal
    output.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: File descriptors are constructs in operating systems that represent access to
    an actual section of the physical storage mechanism or a file. File descriptors
    are nothing more than numbers that are associated to other data structures managed
    by the kernel that represent open files. Each process has its own "private" set
    of file descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you open a file using a text editor or generally perform any editing
    of a resource stored on a physical medium, a file descriptor representing the
    involved file is passed to the kernel through a system call. The kernel then uses
    this number to look up other details about the file in a data structure only the
    kernel should have access to.
  prefs: []
  type: TYPE_NORMAL
- en: The file descriptor's primary purpose is to help abstract and logically isolate
    details about the actual process involved with accessing the storage mechanism.
    After all, reading and writing to files is quite an essential operation to computer
    systems and it would be quite tedious—and error-prone—to do many things if writing
    to a file meant accommodating actions such as spinning/stopping the hard drive
    disk, interpreting different filesystems' organization, and handling read/write
    errors!
  prefs: []
  type: TYPE_NORMAL
- en: 'Output destined for or coming from any file descriptor can be redirected, provided
    that you have the correct access rights from your bash shell! Here''s the code
    to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the previous command, `a` and `b` are both file descriptors. If `a` or `b`
    are not explicitly set, then they default to 1, which is standard output.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about output destined for the standard error file? How do you redirect
    that? Well as it turns out this is pretty easy too, and here''s the code to do
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the previous example, we specified the redirection symbol
    as `2>`, which simply means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Redirect everything from file descriptor 1 to the file called `writeable-files.txt`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You can also combine or bond the two standard output files, namely send the
    output of both input and output to a single file if there is anything interesting
    being printed to the standard error output. It is done using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s also a simpler abbreviation for this and here''s what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Redirect everything from file descriptor 1 to file descriptor 0 and then redirect
    everything from file descriptor 0 to `[output file]`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The previous redirection commands will all assume that the specified file does
    not exist; if it does, the output being directed will overwrite whatever is currently
    in the file. What will you do if you''d like to append text to a file? Well, the
    following command shows how that works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As before, the `&`, `n`, and `m` notations are all optional parameters and work
    exactly the same as they did in previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you can redirect output, you should also be able to redirect input using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Its pretty straightforward really: if `>` means redirect output, then `<` means
    redirect the ''output'' of the right operand, which from the perspective of the
    left operand is input.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with output redirection, you can also control which file descriptors you''d
    like to include in the redirection using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous command, `[n]` is the file descriptor number, as with output
    redirection. The following are a few examples you can test out on your terminal
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '`keylogs.txt < /dev/`tty``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding command redirects all the input written to the terminal into the
    file called `keylogs.txt`. It achieves this by getting the current `tty` device
    associated to the terminal console using the `tty` command.
  prefs: []
  type: TYPE_NORMAL
- en: '`wc –l < /etc/passwd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding command redirects input from the `/etc/passwd` file that contains
    all the usernames and other user account-orientated details to the `wc` command,
    which is used to count lines, file sizes, and other file attributes. Using the
    `–l` switch causes the `wc` command to count all the lines, or more specifically
    all the new line characters it encounters, until an end of file (`EOF`) sentinel
    is reached.
  prefs: []
  type: TYPE_NORMAL
- en: Using pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All we've been discussing in this section is redirecting output command to another
    file; what about redirecting output from one command to another? Well that's exactly
    what the next section is for.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pipes are interprocess communication mechanisms, which are mechanisms that allow
    processes to communicate with one another, in operating systems that allow output
    from one process to be funneled from to another process as input. In other words,
    you can turn the standard output of one program into the standard input of another.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, many pipes work exactly this way by duplicating file descriptor 0 for
    one process and allowing another process to write to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command shows how to use a pipe in bash speak:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that this time the `|` character, referred to literally as a pipe
    if used this way, is an actual part of the command invocation. Of course, `[command
    line]` would be the command you would like to invoke. The pipe will feed output
    from the first command line as input to the second command line argument. You
    can actually specify as many pipes as you your machine will accommodate, which
    would look something like the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cat /etc/passwd | wc –l`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is equivalent to the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the previous commands:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Using pipes](img/5107OT_01_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Count the number of files in the operating system''s `root` directory using
    the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'List all available usernames using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using pipes](img/5107OT_01_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'List all the open services from an `nmap` scan using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Getting to know grep
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Global Regular Expression Print** (**grep**) utility is a staple for all
    command-line jockeys. The `grep` utility in its most basic functionality gives
    its users the ability to run regular expressions on a given input file or stream
    and prints the matching results. More advanced features of `grep` allow you to
    specify which attributes of the matching text you'd like to print, whether you'd
    like the output colorized, or even how many lines around the matching output you
    should print. It's packed with many very useful features, and once mastered they
    become an essential part of any penetration tester, developer, or system administrator's
    arsenal.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To properly make use of `grep`, you will need at least basic understanding and
    practice with regular expressions. Regular expressions will not be covered in
    their entirety here, though simple examples and basic elements of regular expression
    language will be covered. For more extensive reading on regular expressions and
    how they work, see the *Further reading* section at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expression language – a crash course
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regular expressions are merely strings that describe a collection of strings
    using a special language—in formal language theory terms, any collection or set
    of strings is termed as language. Being able to wield this language to your disposal
    is an invaluable skill. It will help you do many things from static code source
    analysis, reverse engineering, malware fingerprinting and larger vulnerability
    assessment, and exploit development.
  prefs: []
  type: TYPE_NORMAL
- en: The regular expression language supported by `grep` is filled with useful shorthands
    to simplify the description of a set of common strings, for instance, describing
    a string consisting of any decimal number, any lowercase or uppercase alphabetic
    character or even any printable character. So given that any string or collection
    of strings must be composed of a collection of smaller strings, if you know how
    to match or describe any alphabetic character or any decimal number, you should
    be able to describe anything composed of characters from those character classes.
    A character class is simply a language composed of length 1 strings from a specific
    collection of characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to define some "control" characters. Given that you will
    be describing strings using other strings, there needs to be a way to designate
    special meaning to given characters or substrings in your regular expression.
    Otherwise, all you''d be able to do is compare one string to another, character
    by character. You can do that as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`^`: The following regular expression must be matched at the beginning of a
    line, for example, `^this is the start of the line`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$`: The preceding regular expression must be matched at the end of a line,
    for example, `this is the end of the line$`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[]`: The description of a character class, or a list of characters, is contained
    within the brackets, and strings that match contain characters in the specified
    list. Certain character classes can be described using shorthands. We will see
    some of them throughout the rest of the chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`()`: This logically groups regular expressions together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|: This is a logical OR of two regular expressions, for instance, `([expression])
    | ([expression])`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`?`: This matches the preceding regular expression at least once. For example,
    `keith?` will match any string that either contains "keith" or doesn''t at all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+`: This matches the preceding regular expression at least once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{n}`: This matches the preceding regular expression exactly *n* times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{n,m}`: This matches the preceding regular expression at least *n* times and
    at most `m` times. For example `[0-9]{0,10}` will match any decimal number containing
    between 0 and 10 digits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a small collection of some of the shorthands `grep` supports
    as an extended regular expression language:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[:alnum:]`: This matches alphanumeric characters, any decimal digit, or alphabetical
    character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:alpha:]`: This matches strictly alphabetical characters a-z'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:digit:]`: This strictly matches decimal numbers 0-9'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:punt:]`: Any punctuation character will be matched'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a number of other character class shorthands available; see the manual
    page for `grep` for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions are simply collections of these control characters and character
    classes. For example, you could combine them in any way you like as long as all
    the brackets, braces, and parenthesis are balanced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have some basic background in regular expressions, let''s look
    at the `grep` utility''s usage specification using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Please remember this is a mere summary of the structure of the command and does
    not mention all possible options. For more information about the `grep` utility's
    regular expression syntax, please see the *Further reading* section at the end
    of this chapter, as well as the man page for Perl regular expressions, which can
    be reached by executing the command `man 3 pcresyntax`. You can also learn more
    about regular expression by checking out the man page on POSIX.2 regular expressions,
    Kali Linux might not have the man page mentioned in the previous command. You
    can get the regex manual page using the command `man 7 regex`.
  prefs: []
  type: TYPE_NORMAL
- en: Building on this specification, let's look at some of the options in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expression matcher selection options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Part of the invocation of `grep` requires you to let `grep` know what method
    you would like to use to match your pattern with the contents of the file. This
    is because `grep` is capable of more than just running regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the options for matcher selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-E` or `–-extended-regexp`: This interprets the `PATTERN` argument as an extended
    regular expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Extended regular expression language is pretty much what everyone uses today,
    but this wasn't always the case. Way back in Unix's heyday, regular expressions
    were represented using something called **POSIX** (**Portable Operating System
    Interface**) basic regular expression language. Some years later, Unix developers
    added some functionality to the regular expression language and a new standard
    for representing this new, more shorthand-laden language was created called the
    **Extended Regular Expression** (**ERE**) language standard.
  prefs: []
  type: TYPE_NORMAL
- en: '`-F or –-fixed-strings`: This tells `grep` to interpret `PATTERN` as a list
    of fixed strings separated by newlines to look for in the given file list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the following screenshot shows the output of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Regular expression matcher selection options](img/5107OT_01_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '-`P or –-perl-regexp`: This allows `grep` to interpret `PATTERN` as a Perl
    regular expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expression matching control options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following options allow you to control a little about how the data being
    matched should be treated, whether you'd like to match whole words in your input
    or whole lines or funnel in a number of patterns from a given file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the options for matching control:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-e PATTERN` or `–-regexp=PATTERN`: This forces the `PATTERN` argument supplied
    here to be used as `PATTERN` to match against the input files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following command is an example of the usage for the preceding option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example matches the line that starts with the word `root`.
  prefs: []
  type: TYPE_NORMAL
- en: '`-f` or `–-file=FILE`: This grabs a list of patterns to use from the supplied
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, consider a file containing the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This file can be used with the `–f` option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`-v` or `–-invert-match`: This inverts the matching, which means select or
    report only file contents that don''t match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-w` or `–-word-regexp`: This report lines from the input files that have whole
    matching words.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, see the output of the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the previous output, and maybe some of your own testing,
    the first two runs did not describe a complete word of the contents of the `/etc/passwd`
    file. However, the last run does; so it's the only one that actually produces
    output.
  prefs: []
  type: TYPE_NORMAL
- en: '`-x` or `–-line-regexp`: This reports or prints lines from the input file that
    have whole lines matching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output control options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `grep` utility also allows you to control how it reports information about
    successful matches. You can also specify which attributes of the matches to report
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the some of the output control options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-c` or `–-count`: This doesn''t report on the matched data, instead prints
    the number of matches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-L` or `–-files-without-match`: This prints only the names of files that contain
    no matches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-l` or `–-files-with-matches`: This prints only the names of files that contain
    matches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-m` or `–max-count=NUM`: This stops processing input after `NUM` number of
    matches. If input comes from standard input or using an input redirection, the
    processing will stop after `NUM` lines are read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-o` or `–only-matching`: This prints the matching parts of the input data,
    each on a separate line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File selection options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following options allow you to specify where the input files should come
    from and also control some of the attributes of the input data as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the options for the file selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-a` or `–-text`: This forces binary files to be processed as text. This allows
    you to operate `grep` much like the strings utility, which returns all the printable
    strings from a given file with the added benefit of being able to match the strings
    using regular expressions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The which command**'
  prefs: []
  type: TYPE_NORMAL
- en: The `which` command prints the canonical file path of the supplied argument.
    Here, it appears in back-ticks so that the bash shell will substitute this command
    for the value it produces, which effectively means `grep` will be running through
    the binary for the `echo` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the previous command is as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![File selection options](img/5107OT_01_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`--binary-files=TYPE`: This checks if a file supplied as input is a binary
    file. If yes, then it treats the file as the specified `TYPE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-D ACTION` or `–-devices=ACTION`: This processes the input file as a device
    and uses the `ACTION` parameter to siphon input from it. By default, `ACTION`
    is read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--exclude=GLOB`: This skips any files whose name matches GLOB; wild cards
    are honored in the matching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-R`, `–r`, or `–-recursive`: This processes all the reachable file entries
    in nested directories from the current directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well that's pretty much it as far as `grep` goes. Hopefully, you'll be able
    to make use of these options to find what you're looking for. It takes a little
    practice and getting used to but once mastered, `grep` is an invaluable utility.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got to know some of the basics of the bash shell. We covered
    man pages, a very important resource for everyone, from seasoned system administrators
    and kernel developers to newbie penetration testers and security engineers. We
    also use powerful and efficient ways to find certain files using very descriptive
    attributes and regular expressions. We covered another very important tool called
    `grep`, which allowed us to make effective use of regular expressions to find
    files based on their content and also pinpoint them in fine detail.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will focus on customizing your bash terminal and enabling powerful
    features to make using your terminal a more information-rich and convenient experience.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following references were accessed by the author on April 22, 2014:'
  prefs: []
  type: TYPE_NORMAL
- en: Linux Manual Pages at [http://www.tldp.org/manpages/man.html](http://www.tldp.org/manpages/man.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux man pages online [http://man7.org/linux/man-pages/index.html](http://man7.org/linux/man-pages/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15 Practical Grep Command Examples at [http://www.thegeekstuff.com/2009/03/15-practical-unix-grep-command-examples/](http://www.thegeekstuff.com/2009/03/15-practical-unix-grep-command-examples/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples using grep at [http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_04_02.html](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_04_02.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expressions at [http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_04_01.html](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_04_01.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux Programmer's Manual, Man 1 intro at [http://www.man7.org/linux/man-pages/man1/intro.1.html](http://www.man7.org/linux/man-pages/man1/intro.1.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux Programmer's Manual, Man 2 intro at [http://www.man7.org/linux/man-pages/man1/intro.2.html](http://www.man7.org/linux/man-pages/man1/intro.2.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
