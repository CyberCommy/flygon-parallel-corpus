- en: Trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **tree** is a hierarchical form of data structure. In the case of other data
    structures such as lists, queues, and stacks that we have discussed till now,
    the items are stored in a sequential way. However, in the case of a tree data
    structure, there is a *parent-child* relationship between the items. The top of
    the tree's data structure is known as a **root node**. This is the ancestor of
    all other nodes in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Tree data structures are very important owing to their use in various important
    applications. Trees are used for a number of things, such as parsing expressions,
    searches, storing data, manipulating data, sorting, priority queues, and so on.
    Certain document types, such as XML and HTML, can also be represented in a tree
    form. We shall look at some of the uses of trees in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Terms and definitions of trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary trees and binary search trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tree traversal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ternary search tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the source code discussed in this chapter is provided in the GitHub repository
    for this book at [https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-3.x-Second-Edition/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-3.x-Second-Edition/tree/master/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's consider some terminology associated with tree data structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand trees, we need to first understand the basic concepts related
    to them. A tree is a data structure in which data is organized in a hierarchical
    form. The following diagram contains a typical tree consisting of character nodes
    lettered **A** through to **M**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ad37d16c-654b-46f2-bc31-a4dc5536795a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is a list of terms associated with a tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node**: Each circled letter in the preceding diagram represents a node. A
    node is any data structure that actually stores the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Root node**: The root node is the first node from which all other nodes in
    the tree are attached. In every tree, there is always one unique root node. The
    root node in our example tree is node A.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sub-tree**: A sub-tree of a tree is a tree with its nodes being a descendant
    of some other tree. For example, nodes F, K, and L form a sub-tree of the original
    tree consisting of all the nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Degree**: The total number of children of the given node is called the **degree
    of that node**. A tree consisting of only one node has a degree of 0\. The degree
    of node A in the preceding diagram is 2, the degree of node B is 3, the degree
    of node C is 3, and similarly, the degree of node G is 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leaf node**: The leaf node does not have any children, and is the terminal
    node of the given tree. The degree of the leaf node is always 0\. In the preceding
    diagram, the nodes J, E, K, L, H, M, and I are all leaf nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edge**: The connection among any given two nodes in the tree is called an **edge**.
    The total number of edges in a given tree will be a maximum of one less than the
    total nodes in the tree. An example edge is shown in the preceding sample tree
    structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parent**: A node in the tree which has a further sub-tree is the parent node
    of that sub-tree. For example, node B is the parent of nodes D, E, and F, and
    node F is the parent of nodes K and L.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Child**: This is a node connected to its parent, and it is the node that
    is a descendant of that node. For example, nodes B and C are children of node
    A, while the nodes H, G, and I are the children of node C.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sibling**: All nodes with the same parent are siblings. For example, nodes
    B and C are siblings, and, similarly, nodes D, E, and F are also siblings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Level**: The root node of the tree is considered to be at level 0\. The children
    of the root node are considered at level 1, and the children of the nodes at level
    1 are considered at level 2, and so on. For example, the root node is at level
    0, nodes B and C are at level 1, and nodes D, E, F, H, G, and I are at level 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Height of a tree**: The total number of the nodes in the longest path of
    the tree is the height of a tree. For example, in the preceding example tree,
    the height of the tree is 4 as the longest paths, `A-B-D-J` or `A-C-G-M` or `A-B-F-K`,
    all have a total number of 4 nodes each.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Depth**: The depth of a node is the number of edges from the root of the
    tree to that node. In the preceding tree example, the depth of node H is 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We shall begin our treatment of trees by considering the node in a tree and
    abstracting a class.
  prefs: []
  type: TYPE_NORMAL
- en: Tree nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In linear data structures, data items are stored in a sequential order, one
    after another, whereas nonlinear data structures store data items in a non-linear
    order, where a data item can be connected to more than one data item. All of the
    data items in the linear data structures can be traversed in one pass, whereas
    this is not possible in the case of a non-linear data structure. The trees are
    the non-linear data structure; they store the data differently from other linear
    data structures such as *arrays*, *lists,* *stacks,* and *queues.*
  prefs: []
  type: TYPE_NORMAL
- en: In the tree data structure, the nodes are arranged in a *parent-child* relationship.
    There should not be any cycle among the nodes in trees. The tree structure has
    nodes to form a hierarchy, and a tree that has no node is called an **empty tree**.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will discuss one of most important and special kinds of trees available,
    that is, the *binary tree.* A binary tree is a collection of nodes, where the
    nodes in the tree can have zero, 1, or 2 child nodes. A simple binary tree has
    a maximum of two children, that is, the left child and the right child. For example,
    in the following binary tree example, there is a root node that has two children
    (left child, right child):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/17ebd6df-f607-4b65-8032-03d8be1cd394.png)'
  prefs: []
  type: TYPE_IMG
- en: A tree is called a **full** **binary tree** if all the nodes of a binary tree
    have either zero or two children, and if there is no node that has `1` child. A
    binary tree is called a **complete binary tree** if it is completely filled, with
    a possible exception at the bottom level, which is filled from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like in our previous implementations, a node is a container for data and
    holds references to other nodes. In a binary tree node, these references are to
    the left and the right children. Let''s look at the following code for building
    a binary tree `node` class in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this class, we must first create four nodes—`n1`, `n2`, `n3`, and `n4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we connect the nodes to each other according to the property of a binary
    tree. We let `n1` be the root node, with `n2` and `n3` as its children. Finally,
    we take `n4` as the left child to `n2`. Take a look at the following diagram to
    see how we connect these nodes to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9775f219-4ae9-4ffb-a41b-391cb5ed7c2f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next code snippet should be following in order to connect the nodes to
    each other according to the preceding diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have set a very simple tree structure of four nodes. The first important
    operation that we would like to perform on trees is traversal. To understand traversing,
    let''s traverse the left sub-tree of this binary tree. We will start from the
    root node, print out the node, and move down the tree to the next left node. We
    keep doing this until we have reached the end of the left sub-tree, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of traversing the preceding code block is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tree traversal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The method to visit all the nodes in a tree is called **tree traversal**. This
    can be done either **depth-first** **search** (**DFS**) or **breadth-first search** (**BFS**).
    We will discuss these two methods in the subsequent subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Depth-first traversal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In depth-first traversal, we traverse the tree, starting from the root, and
    go deeper into the tree as much as possible on each child, and then continue to
    traverse to the next sibling. We use the recursive approach for tree traversal. There
    are three forms of depth-first traversal, namely, in-order, pre-order, and post-order.
  prefs: []
  type: TYPE_NORMAL
- en: In-order traversal and infix notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In-order tree traversal works as follows. First of all, we check if the current
    node is null or empty. If it is not empty, we traverse the tree. In in-order tree
    traversal, we follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We start traversing the left sub-tree and call the `inorder` function recursively
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we visit the root node
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we traverse the right sub-tree and call the `inorder` function recursively
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, in a nutshell, in in-order tree traversal, we visit the nodes in the tree
    in the order of (left sub-tree, root, right sub-tree).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider an example to understand in-order tree traversal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/489c693f-15f5-4762-b70c-9ca81bbe5bb8.png)'
  prefs: []
  type: TYPE_IMG
- en: In the example binary tree for in-order traversal, first, we recursively visit
    the left sub-tree of the root node **A**. The left sub-tree of node **A** has
    node **B** as root, so we again go to the left sub-tree of the root node **B**,
    that is, node **D**. We recursively go to the left sub-tree of root node **D **so
    that we get the left child with root node **D**. So, first, we visit the left
    child, that is, **G**, then visit the root node, **D**, and then visit the right
    child, **H**.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we visit node **B** and then visit node **E**. In this manner, we have
    visited the left sub-tree with the root node **A**. So, next, we visit the root
    node **A**. After that, we will visit the right sub-tree with root node **A**.
    Here, we go to the left sub-tree with root node **C**, which is null, so next
    we visit node **C**, and then we visit the right child of node **C**, that is,
    node **F**.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the in-order traversal for this example tree is `G–D-H-B-E-A-C-F`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python implementation of a recursive function to return an `inorder` listing
    of nodes in a tree is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We visit the node by printing the visited node. In this case, we first recursively
    call the `inorder` function with `current.left_child`, then we visit the root
    node, and finally we recursively call the `inorder` function with `current.right_child` once
    more.
  prefs: []
  type: TYPE_NORMAL
- en: The **infix** notation (also known as reverse Polish notation) is a commonly
    used notation to express arithmetic expressions where the operators are placed
    in-between the operands. It is common to use this way of representing an arithmetic expression since
    this is the way we are normally taught in schools. For example, the operator is
    inserted (infixed) between the operands, as in `3 + 4`. When necessary, parentheses
    can be used to build a more complex expression, such as `(4 + 5) * (5 - 3)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An expression tree is a special kind of **binary tree** that can be used to
    represent arithmetic expressions. This in-order traversal of an expression tree
    produce the infix notation. For example, consider the following expression tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d46a0ed5-4f9f-406d-8028-c5bf7b0c17ed.png)'
  prefs: []
  type: TYPE_IMG
- en: The in-order traversal of the preceding expression tree gives us the infix notation,
    that is, `(5 + 3)`.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-order traversal and prefix notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pre-order tree traversal works as follows. First of all, we check if the current
    node is null or empty. If it is not empty, we traverse the tree. The pre-order tree
    traversal works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We start traversing with the root node
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we traverse the left sub-tree and call the `preorder` function with the
    left sub-tree recursively
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we visit the right sub-tree and call the `preorder` function with the
    right sub-tree recursively
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, to traverse a tree in pre-order mode, we visit the tree in the order of
    root node, the left sub-tree, and the right sub-tree node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example tree to understand pre-order traversal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f20499f8-7a4a-48f8-afc8-4269b864006d.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example of a binary tree, first, we visit root node **A**.
    Next, we go to the left sub-tree of root node **A**. The left sub-tree of node
    **A** has node **B** as the root, so we visit this root node and the go to the
    left sub-tree of root node **B**, that is, node **D**. We then visit node **D** and
    go to the left sub-tree of root node **D**, and then we visit the left child, **G**,
    which is the sub-tree of root node **D**. Next, we visit the right child of the
    sub-tree with root node **D**, that is, node **H**. Next, we visit the right child
    of the sub-tree with root node **B**, that is, node **E**. So, in this manner,
    we have visited root node **A** and the left sub-tree with root node **A**. Now,
    we will visit the right sub-tree of root node **A**. Here, we visit the root node
    **C**, and then we go to the left sub-tree with root node **C**, which is null,
    so next, we visit the right child of node **C**, that is, node **F**.
  prefs: []
  type: TYPE_NORMAL
- en: The pre-order traversal for this example tree would be `A-B-D-G-H-E-C-F`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recursive function for `pre-order` tree traversal is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Prefix notation is commonly referred to as Polish notation. In this notation,
    the operator comes before its operands. Prefix notation is well known to LISP
    programmers. For example, the arithmetic expression to add two numbers, 3 and
    4, would be shown as `+ 3 4`. Since there is no ambiguity of precedence, parentheses
    are not required: `* + 4 5 - 5 3`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider another example, that is, the `(3 +4) * 5 `. This can also be
    represented as `* (+ 3 4) 5` in prefix notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pre-order traversal of an expression tree results in the prefix notation
    of the arithmetic expression. For example, consider the following expression tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/08f7ec34-8fde-4a49-86ae-6fbcaac63487.png)'
  prefs: []
  type: TYPE_IMG
- en: The preorder traversal of the preceding tree will give the expression in prefix
    notation as `+- 8 3 3`.
  prefs: []
  type: TYPE_NORMAL
- en: Post-order traversal and postfix notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Post-order` tree traversal works as follows. First of all, we check if the
    current node is null or empty. If it is not empty, we traverse the tree. `Post-order` tree
    traversal works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We start traversing the left sub-tree and call the `postorder` function recursively
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we traverse the right sub-tree and call the postorder function recursively
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we visit the root node
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So. in a nutshell, regarding `post-order` tree traversal, we visit the nodes
    in the tree in the order of left sub-tree, right sub-tree, and finally the root
    node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example tree to understand post-order tree traversal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/690334be-b950-44af-bf9d-ce1599bdefd8.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we first visit the left sub-tree of root node **A**
    recursively. We get to the last left subtree, that is, root node D, and then we
    visit the left node of it, which is node **G**. Then, we visit the right child,
    H, and then we visit the root node D. Following the same rule, we next visit the
    right child of node **B**, that is, node **E**. Then, we visit node **B**. Following
    on from this, we traverse the right sub-tree of node **A**. Here, we first reach
    the last right sub-tree and visit node **F**, and then we visit node **C**. Finally,
    we visit root node **A**.
  prefs: []
  type: TYPE_NORMAL
- en: The postorder traversal for this example tree would be `G-H-D-E-B-F-C-A`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the `post-order` method for tree traversal is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Postfix or **reverse Polish notation** (**RPN**) places the operator after its
    operands, as in `3 4 +`. As is the case with Polish notation, there is no further
    confusion over the precedence of operators, so parentheses are never needed: `4
    5 + 5 3 - *`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The post-order traversal of the following expression tree will give the postfix
    notation of the arithmetic expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d133d129-c15f-41b9-bf01-a200e247e709.png)'
  prefs: []
  type: TYPE_IMG
- en: The postfix notation for the preceding expression tree is `8 3 -3 +`.
  prefs: []
  type: TYPE_NORMAL
- en: Breadth-first traversal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Breadth-first traversal starts from the root of the tree and then visits every
    node on the next level of the tree. Then, we move to the next level in the tree,
    and so on. This kind of tree traversal is breadth-first as it broadens the tree
    by traversing all the nodes in a level before going deep into the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following example tree and traverse it by using the breadth-first
    traversal method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8d106753-e386-4549-9027-1709e4845e18.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we start by visiting the root node at **level 0**,
    that is, the node with a value of **4**. We visit this node by printing out its
    value. Next, we move to **level 1** and visit all the nodes on this level, which
    are the nodes with the values **2** and **8**. Finally, we move to the next level
    in the tree, that is, **level 3**, and we visit all the nodes at this level. The
    nodes at this level are **1**, **3**, **5**, and **10**.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the breadth-first tree traversal for this tree is as follows—**4**, **2**,
    **8**, **1**, **3**, **5**, and **10**.
  prefs: []
  type: TYPE_NORMAL
- en: This mode of traversal is implemented using a queue data structure. Starting
    with the root node, we push it into a queue. The node at the front of the queue
    is accessed (dequeued) and either printed or stored for later use. The left node
    is added to the queue followed by the right node. Since the queue is not empty,
    we repeat this process.
  prefs: []
  type: TYPE_NORMAL
- en: The Python implementation of this algorithm will enqueue the root node **4**,
    dequeue it, and visit the node. Next, nodes **2** and **8** are enqueued as they
    are the left and right nodes at the next level, respectively. Node **2** is dequeued
    so that it can be visited. Next, its left and right nodes, that is, nodes **1**
    and **3**, are enqueued. At this point, the node at the front of the queue is
    **8**. We dequeue and visit node **8**, after which we enqueue its left and right
    nodes. This process continues until the queue is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python implementation of breadth-first traversal is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We enqueue the root node and keep a list of the visited nodes in the `list_of_nodes` list.
    The `dequeue` class is used to maintain a queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If the number of elements in `traversal_queue` is greater than zero, the body
    of the loop is executed. The node at the front of the queue is popped off and
    appended to the `list_of_nodes` list. The first `if` statement will `enqueue` the
    left child node if the `node` provided with a left node exists. The second `if` statement
    does the same for the right child node.
  prefs: []
  type: TYPE_NORMAL
- en: The `list_of_nodes` list is returned in the last statement.
  prefs: []
  type: TYPE_NORMAL
- en: Binary trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A binary tree is one in which each node has a maximum of two children. The nodes
    in the binary tree are organized in the form of left sub-tree and right sub-tree.
    If the tree has a root, R, and two sub-trees, that is, left sub-tree `T1`, and
    right sub-tree `T2`, then their roots are called `left successor` and `right successor`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is an example of a binary tree with five nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6519f2a2-5a73-4a88-81c8-c30ca11ba492.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are the following observations that we have made regarding the preceding
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: Each node holds a reference to a right and left node if the nodes do not exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The root node is denoted with **5**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The root node has two sub-trees, where the left sub-tree has one node, that
    is, a node with a value of **3**, and the right sub-tree has three nodes with
    the values **7**, **6**, and **9**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The node with a value of **3** is a left successor node, whereas the node with
    a value of **7** is the right successor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A regular binary tree has no other rules as to how elements are arranged in
    the tree. It should only satisfy the condition that each node should have a maximum
    of two children.
  prefs: []
  type: TYPE_NORMAL
- en: Binary search trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **binary search tree** (**BST**) is a special kind of binary tree. It is one
    of the most important and commonly used data structures in computer science applications.
    A binary search tree is a tree that is structurally a binary tree, and stores
    data in its nodes very efficiently. It provides very fast search operations, and
    other operations such as insertion and deletion are also very easy and convenient.
  prefs: []
  type: TYPE_NORMAL
- en: 'A binary tree is called a binary search tree if the value at any node in the
    tree is greater than the values in all the nodes of its left sub-tree, and less
    than or equal to the values of all the nodes of the right sub-tree. For example,
    if **K1**, **K2**, and **K3** are key values in a tree of three nodes (as shown
    in the following diagram), then it should satisfy the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: The key values of *K2<=K1*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The key values *K3>K1*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram depicts this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4ad947ef-1686-45c9-ae03-cb7620cb4aec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s consider another example so that we have a better understanding of binary
    search trees. Consider the following tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8d71ac43-cacf-4faf-91c6-338483487b3f.png)'
  prefs: []
  type: TYPE_IMG
- en: This is an example of a BST. In this tree, all of the nodes in the left sub-tree are
    less than or equal to the value of that node. Also, all of the nodes in the right
    sub-tree of this node are greater than that of the parent node.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our tree for the properties of a BST, we notice that all of the nodes
    in the left sub-tree of the root node have a value less than 5\. Likewise, all
    the nodes in the right sub-tree have a value that is greater than 5\. This property
    applies to all the nodes in a BST, with no exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering another example of a binary tree, let''s see if it is a binary
    search tree or not. Despite the fact that the following diagram looks similar
    to the previous diagram, it does not qualify as a BST as node **7** is greater
    than the root node **5**; however, it is located to the left of the root node.
    Node **4** is to the right sub-tree of its parent node **7**, which is incorrect.
    Thus, the following diagram is not a binary search tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/13e662dd-8b8f-445e-afec-59e6fc6dfad9.png)'
  prefs: []
  type: TYPE_IMG
- en: Binary search tree implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin the implementation of a BST in Python. We need to keep track of
    the root node of the tree, so we start by creating a `Tree` class that holds a
    reference to the root node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: That's all that is needed to maintain the state of a tree. Let's examine the
    main operations on the tree in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Binary search tree operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The operations that can be performed on a binary search tree are `insert`, `delete`,
    `finding min`, `finding max`, `searching`, and so on. We will discuss them in
    subsequent subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the minimum and maximum nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The structure of the binary search tree makes searching a node that has a maximum
    or a minimum value very easy.
  prefs: []
  type: TYPE_NORMAL
- en: To find a node that has the smallest value in the tree, we start traversal from
    the root of the tree and visit the left node each time until we reach the end
    of the tree. Similarly, we traverse the right sub-tree recursively until we reach
    the end to find the node with the biggest value in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following diagram; we move down from node **6** to
    **3** and then from node **3** to **1** to find the node with the smallest value.
    Similarly, to find the maximum value node from the tree, we go down from the root
    to the right-hand side of the tree, then go from node **6** to node **8** and
    then node **8** to node **10** to find the node with the largest value. Here is
    an example BST tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4b26eee0-da90-49ec-bcc6-bb7ab38cd8d1.png)'
  prefs: []
  type: TYPE_IMG
- en: This concept of finding the minimum and maximum nodes applies to sub-trees,
    too. Thus, the minimum node in the sub-tree with root node **8** is node **7**.
    Similarly, the node that has the maximum value within that sub-tree is **10**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python implementation of the method that returns the minimum node is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `while` loop continues to get the left node and visits it until the last
    left node points to `None`. It is a very simple method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the following is the code of the method that returns the maximum
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The running time complexity to find the minimum or maximum value in a BST is O(*h*),
    where `h` is the height of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: There are essentially two other operations, that is, `insert` and `delete`,
    and they are very important for BST. It is important to ensure that we maintain
    the property of the BST tree while applying these operations on the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important operations to implement on a binary search tree is
    to insert data items in the tree. As we have already discussed, regarding the
    properties of the binary search tree, for each node in the tree, the left child
    nodes should contain the data less than their own value and the right child nodes
    should have data greater than their value. So, we have to ensure that the property
    of the binary search tree satisfies whenever we insert an item in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s create a binary search tree by inserting data items **5**,
    **3**, **7**, and **1** in the tree. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insert 5:** We start with the first data item, **5**. To do this, we will
    create a node with its data attribute set to **5**, since it is the first node.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Insert 3:** Now, we want to add the second node with value **3** so that
    data value **3** is compared with the existing node value, **5**, of the root
    node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since the node value **3** is less than **5**, it will be placed in the left
    sub-tree of node **5**. Our BST will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5cc8c9f2-30ef-4a54-8ccf-034a25fc7b6e.png)'
  prefs: []
  type: TYPE_IMG
- en: The tree satisfies the BST rule, where all the nodes in the left sub-tree are
    less than the parent.
  prefs: []
  type: TYPE_NORMAL
- en: '**Insert 7:** To add another node of value **7** to the tree, we start from
    the root node with value **5** and make a comparison:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/825b1134-b2e5-4422-a074-0a9edd9500d3.png)'
  prefs: []
  type: TYPE_IMG
- en: Since **7** is greater than **5**, the node with value **7** is placed to the
    right of this root.
  prefs: []
  type: TYPE_NORMAL
- en: '**Insert 1:** Let''s add another node with value **1**. Starting from the root
    of the tree, we make a comparison between **1** and **5**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/77b2a9ae-1353-4526-bce0-0d0071fa2db9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This comparison shows that **1** is less than **5**, so we go to the left node
    of **5**, which is the node with a value of **3**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/cc62c702-3223-4bfc-817b-b4c688f3a41a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we compare **1** with **3**, since **1** is less than **3**, we move a
    level below node **3** and to its left. However, there is no node there. Therefore,
    we create a node with the value **1** and associate it with the left pointer of
    node **3** to obtain the following structure. Here, we have the final binary search
    tree of **4** nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/026ebb91-6c6b-43df-815f-0a4e2e2ff30a.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that this example contains only integers or numbers. So, if we need
    to store the string data in the binary search tree, in this case strings would
    be compared alphabetically. And, if we want to store our own custom data types
    inside a BST, we will have to make sure that our class supports ordering.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python implementation of the `insert` method to add the nodes in the BST
    is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s understand each of the instructions of this `insert` function,
    step by step. We will begin with a function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'By now, you will be used to the fact that we encapsulate the data in a node.
    This way, we hide away the `node` class from the client code, who only needs to
    deal with the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A first check will be done to find out whether we have a root node. If we don''t,
    the new node becomes the root node (we cannot have a tree without a root node):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As we walk down the tree, we need to keep track of the current node we are
    working on, as well as its parent. The `current` variable is always used for this
    purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we must perform a comparison. If the data held in the new node is less
    than the data held in the current node, then we check whether the current node
    has a left child node. If it doesn''t, this is where we insert the new node. Otherwise,
    we keep traversing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to take care of the greater than or equal case. If the current
    node doesn''t have a right child node, then the new node is inserted as the right
    child node. Otherwise, we move down and continue looking for an insertion point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Insertion of a node in a BST takes `O(h)`, where `h` is the height of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another important operation on a BST is the `deletion` or `removal` of nodes.
    There are three scenarios that we need to cater for during this process. The node
    that we want to remove might have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No children**: If there is no leaf node, directly remove the node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One child**: In this case, we swap the value of that node with its child,
    and then delete the node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Two children**: In this case, we first find the in-order successor or predecessor,
    swap the value with it, and then delete that node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first scenario is the easiest to handle. If the node about to be removed
    has no children, we simply remove it from its parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9a0542ba-4bd8-473e-9a43-23bfcd1b5bf2.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, node **A** has no children, so we will simply delete
    it from its parent, that is, node **Z**.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, when the node we want to remove has one child, the parent
    of that node is made to point to the child of that particular node. Let''s take
    a look at the following diagram, where we want to delete node **6** who has one
    child, that is, node **5**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/31d35eef-0bc8-40a2-981d-aea941d428a2.png)'
  prefs: []
  type: TYPE_IMG
- en: In order to delete node **6**, which has node **5** as its only child, we point
    the left pointer of node **9** to node **5**. Here, we need to ensure that the
    child and parent relationship follows the properties of a binary search tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more complex scenario arises when the node we want to delete has two children.
    Consider the following example tree, where we want to delete node **9**, which
    has two children:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/038348fb-2f25-4010-96a1-1e817fa197ab.png)'
  prefs: []
  type: TYPE_IMG
- en: We cannot simply replace node **9** with either node **6** or **13**. What we
    need to do is find the next biggest descendant of node **9**. This is node **12**.
    To get to node **12**, we move to the right node of node **9**. Then, we move
    left to find the leftmost node. Node **12** is called the in-order successor of
    node **9**. The second step resembles the move to find the maximum node in a sub-tree.
  prefs: []
  type: TYPE_NORMAL
- en: We replace the value of node **9** with the value **12** and remove node **12**.
    Upon removing node **12**, we end up with a simpler form of node removal that
    was addressed previously. Node 12 has no children, so we apply the rule for removing
    nodes without children accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `node` class does not have a reference to a parent. As such, we need to
    use a helper method to `search` and return the node with its parent node. This
    method is similar to the `search` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference is that before we update the current variable inside the
    loop, we store its parent with `parent = current`. The method to do the actual
    removal of a node begins with this search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We pass the parent and the found nodes to `parent` and `node`, respectively
    with the `parent, node = self.get_node_with_parent(data)` line. It is important
    to know the number of children that the node has that we want to delete, and we
    do so in the `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we know the number of children a node has that we want to delete, we
    need to handle various conditions in which a node can be deleted. The first part
    of the `if` statement handles the case where the node has no children:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In cases where the node to be deleted has only one child, the `elif` part of
    the `if` statement does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `next_node` is used to keep track of that single node. which is the child
    of the node that is to be deleted. We then connect `parent.left_child` or `parent.right_child`
    to `next_node`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we handle the condition where the node we want to delete has two children:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In finding the in-order successor, we move to the right node with `leftmost_node
    = node.right_child`. As long as a left node exists, `leftmost_node.left_child`
    will evaluate to `True` and the `while` loop will run. When we get to the leftmost
    node, it will either be a leaf node (meaning that it will have no child node)
    or have a right child.
  prefs: []
  type: TYPE_NORMAL
- en: 'We update the node that''s about to be removed with the value of the in-order
    successor with `node.data = leftmost_node.data`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding statement allows us to properly attach the parent of the leftmost
    node with any child node. Observe how the right-hand side of the equals sign stays
    unchanged. This is because the in-order successor can only have a right child
    as its only child.
  prefs: []
  type: TYPE_NORMAL
- en: The `remove` operation takes `O(*h*)`, where `h` is the height of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Searching the tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A binary search tree is a tree data structure in which all the nodes follow
    the property that all the nodes in the left sub-tree of a node have lower key
    values, and have greater key values in its right sub-tree. Thus, searching for
    an element with a given key value is quite easy. Let''s consider an example binary
    search tree that has nodes **1**, **2**, **3**, **4**, **8**, **5**, and **10**,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5c287e15-284f-4eab-99f3-7efe3b2b34c5.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding tree, if we wish to search for a node with a value of **5**,
    then we start from the root node and compare it with the root. As node **5** is
    a greater value compared to root node value **4**, we move to the right sub-tree.
    In the right sub-tree, we have node **8** as the root node; we compare node **5**
    with node **8**. As the node to be searched has a smaller value than node **8**,
    we move to the left sub-tree. When we move to the left sub-tree, we compare the
    left sub-tree node **5** with the required node with value **5**. This is a match,
    so we return `"item found"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation of the `searching` method in a binary search tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we will return the data if it was found, or `None` if
    the data wasn't found. We start searching from the root node. Next, if the data
    item to be searched for doesn't exist in the tree, we return `None` to the client
    code. We might also have found the data—in that case, we return the data.
  prefs: []
  type: TYPE_NORMAL
- en: If the data we are searching for is less than that of the current node, we go
    down the tree to the left. Furthermore, in the `else` part of the code, we check
    if the data we are looking for is greater than the data held in the current node,
    which means that we go down the tree to the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can write some client code to test how the BST works. We must create
    a tree and insert a few numbers between `1` and `10`. Then, we search for all
    the numbers in that range. The ones that exist in the tree get printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Benefits of a binary search tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A binary search tree is a better choice compared to arrays and linked lists.
    A BST is fast for most operations such as searching, insertion, and deletion,
    whereas arrays provide fast searching, but are comparatively slow in insertion
    and deletion operations. In a similar fashion, linked lists are efficient in performing
    insertion and deletion operations, but are slower when performing the search operation.
    The `best-case` running time complexity for searching an element from a binary
    search tree is `O(log n)`, and the `worst-case` time complexity is `O(n)`, whereas
    both `best-case` and `worst-case` time complexity for searching in lists is `O(n)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table provides a comparison of the array, linked list, and binary
    search tree data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Properties** | **Array** | **Linked list** | **BST** |'
  prefs: []
  type: TYPE_TB
- en: '| **Data structure** | Linear. | Linear. | Non-linear. |'
  prefs: []
  type: TYPE_TB
- en: '| **Ease of use** | Easy to create and use. Average-case complexity for search,
    insert, and delete is `O(n)`. | Insertion and deletion is fast, especially with
    the doubly linked list. | Access of elements, insertion, and deletion is fast
    with the average-case complexity of `O(log n)`. |'
  prefs: []
  type: TYPE_TB
- en: '| **Access Complexity** | Easy to access elements. Complexity is `O(1)`. |
    Only sequential access is possible, so slow. Average and worst-case complexity
    is `O(n)`. | Access is fast, but slow when the tree is unbalanced, with the worst-case
    complexity of `O(n)`. |'
  prefs: []
  type: TYPE_TB
- en: '| **Search complexity** | Average and worst-case complexity is `O(n)`. | It
    is slow due to sequential searching. Average and worst-case complexity is `O(n)`.
    | Worst-case complexity for searching is `O(n)`. |'
  prefs: []
  type: TYPE_TB
- en: '| **Insertion complexity** | Insertion is slow. Average and worst-case complexity
    is `O(n)`. | Average and worst-case complexity is `O(1)`. | The worst-case complexity
    for insertion is `O(n)`. |'
  prefs: []
  type: TYPE_TB
- en: '| **Deletion complexity** | Deletion is slow. Average and worst-case complexity
    is `O(n)`. | Average and worst-case complexity is `O(1)`. | The worst-case complexity
    for deletion is `O(n)`. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s consider an example to understand when the binary search tree is a good
    choice to store the data. Let''s assume that we have the following data nodes—**5**,
    **3**, **7**, **1**, **4****,** **6**, and **9**. If we use a list to store this
    data, the worst-case scenario will require us to search through the entire list
    of seven elements for finding the item. So, it will require seven comparisons
    to search for item **9** in this data node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2ebb36ce-b7e3-4149-833f-fe26f1d5e61e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, if we use a binary search tree to store these values, as shown in
    the following diagram, in the worst-case scenario, we would require three comparisons
    to search for item **9**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9232922d-cb33-4d9f-8f58-3c09482b5e0c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, it is important to note that the efficiency of searching also depends
    on how we built the binary search tree. If the tree hasn''t been constructed properly,
    it can be slow. For example, if we had inserted the elements into the tree in
    the order {**1**, **3**, **4**, **5**, **6**, **7**,**9**}, as shown in the following
    diagram, then the tree would not be more efficient than the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/72619b66-237f-4771-a7bc-0211b8e82bee.png)'
  prefs: []
  type: TYPE_IMG
- en: Thus, choosing a self-balancing tree helps to improve the `search` operation.
    Here, we should note that the binary search tree is a better choice in most of
    the cases; however, we should try to balance the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Balancing trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen in the previous section that if nodes are inserted into a tree
    in a sequential order, it becomes slow and behaves more or less like a list; that
    is, each node has exactly one child node. To improve the performance of the tree
    data structure, we generally like to reduce the height of the tree as much as
    possible to balance the tree by filling up each row in the tree. This process
    is called **balancing the tree**.
  prefs: []
  type: TYPE_NORMAL
- en: There are different types of self-balancing trees, such as red-black trees,
    AA trees, and scapegoat trees. These balance the tree during each operation that
    modifies the tree, such as insert or delete. There are also external algorithms
    that balance a tree. The benefits of these are that you don't need to balance
    the tree on every single operation and can leave balancing to the point where
    you need it.
  prefs: []
  type: TYPE_NORMAL
- en: Expression trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An arithmetic expression is represented by a combination of operators and operands
    where the operators can be unary or binary. An arithmetic expression can also
    be represented using a **binary tree**, which is called an expression tree. This
    tree structure can also be used to parse arithmetic and boolean expressions. In
    an expression tree, all the leaf nodes contain the operands and non-leaf nodes
    contain the operators. We should also note that the expression tree will have
    one of its sub-trees (right sub-tree or left sub-tree) empty in the case of a
    unary operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the expression tree for `3 + 4` would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8286c09a-c33a-4d43-907e-8955d357ad4b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For a slightly more complex expression, `(4 + 5) * (5-3)`, we would get the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/cf45c4ca-4483-4c7e-81dd-cab97ec9ba5f.png)'
  prefs: []
  type: TYPE_IMG
- en: The arithmetic expression can be expressed using three notations (that is, infix,
    postfix, and prefix), as discussed in the previous section on tree traversal. Due
    to this, it becomes easy to evaluate an expression tree for the given arithmetic
    expression. The reverse Polish notation provides faster calculations. We will
    show you how to construct the expression tree for the given postfix notation in
    the following subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing a reverse Polish expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are going to build up a tree for an expression written in postfix notation.
    Then, we will calculate the result. We will use a simple tree implementation.
    To keep it simple, since we are going to grow the tree by merging smaller trees,
    we only need a tree node implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to build the tree, we are going to enlist the items with the help
    of a stack. Let''s just create an arithmetic expression and set up our stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Since Python is a language that tries hard to have sensible defaults, its `split()`
    method splits on whitespace by default. (If you think about it, this is most likely
    what you would expect.) The result is going to be that `expr` is a list with the
    values `4`, `5`, `+`, `5`, `3`, `-`, and `*`.
  prefs: []
  type: TYPE_NORMAL
- en: Each element of the `expr` list is going to be either an operator or an operand.
    If we get an operand, then we embed it in a tree node and push it onto the stack.
    If we get an operator, on the other hand, then we embed the operator into a tree
    node and pop its two operands into the node's left and right children. Here, we
    have to take care to ensure that the first pop goes into the right child; otherwise,
    we will have problems with subtraction and division.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code to build the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we perform a conversion from `string` to `int` in the case of an
    operand. You could use `float()` instead, if you wish to support floating point
    operands.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of this operation, we should have one single element in the stack,
    and that holds the full tree. If we want to evaluate the expression, we would
    build the following little function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we pass in a node to the function. If the node contains
    an operand, then we simply return that value. If we get an operator, then we perform
    the operation that the operator represents on the node's two children. However,
    since one or more of the children could also contain either operators or operands,
    we call the `calc()` function recursively on the two child nodes (bearing in mind
    that all the children of every node are also nodes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just need to pop the root node off the stack and pass it into the `calc()`
    function. Then, we should have the result of the calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Running this program should yield the result `18`, which is the result of `(4
    + 5) * (5 - 3)`.
  prefs: []
  type: TYPE_NORMAL
- en: Heaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A heap data structure is a specialization of a tree in which the nodes are ordered
    in a specific way. Heaps are divided into `max` heaps and `min` heaps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a `max` heap, each parent node value must always be greater than or equal
    to its children. It follows that the root node must be the greatest value in the
    tree. Consider the following diagram for the max heap, where all the nodes have
    greater values compared to their children:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d0bd32c7-21a2-4f0b-a2a9-908d904f5933.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In a min heap, each parent node must be less than or equal to both its children.
    As a consequence, the root node holds the lowest value. Consider the following
    diagram for the min heap, where all the nodes have smaller values compared to
    their children:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5bc4330e-b3b1-4dad-bace-f5ee12e66be2.png)'
  prefs: []
  type: TYPE_IMG
- en: Heaps are used for a number of different things. For one, they are used to implement
    priority queues. There is also a very efficient sorting algorithm, called **heap
    sort**, that uses heaps. We are going to study these in depth in subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Ternary search tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A ternary tree is a data structure where each node of the tree can contain up
    to `3` children. It is different compared to the binary search tree in the sense
    that a node in a binary tree can have a maximum of `2` children, whereas a node
    in the ternary tree can have a maximum of `3` children. The ternary tree data
    structure is also considered a special case of the trie data structure. In trie
    data structure, each node contains 26 pointers to its children when we use trie
    data structure to store strings in contrast to the ternary search tree data structure,
    where we have 3 pointers to its children.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ternary search tree can be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Each node stores a character in it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has the equal pointer that points to a node that stores a value equal to
    the current node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has the left pointer that points to a node that stores a value smaller than
    the current node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has the right pointer that points to a node that stores a value greater than
    the current node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each node has a flag variable that keeps track of whether that node is the end
    of a string or not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To better understand the ternary search tree data structure, we will demonstrate
    it through an example where we insert the strings **PUT**, **CAT**, **SIT**, **SING**,
    and **PUSH** to an empty ternary tree, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0f216d85-eb1f-46d4-b73f-6f5234881607.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inserting a value into a ternary search tree is quite similar to how we do
    it in a binary search tree. In the ternary search tree, we follow these steps
    to insert a string in the ternary search tree:'
  prefs: []
  type: TYPE_NORMAL
- en: Since the tree is empty initially, we start by creating the root node with the
    first character, **P**, and then we create another node for the character **U**,
    and finally the character **T**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we wish to add the word **CAT**. First, we compare the first character **C** with
    the root node character, **P**. Since it does not match, and it is smaller than
    the root node, we create a new node for the character **C** on the left-hand side
    of the root node. Furthermore, we create the nodes for characters **A** and **T**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we add a new word, **SIT**. First, we compare the first character, **S**,
    with the root node character, **P**. Since it does not match, and character **S**
    is greater than character **P**, we create a new node on the right-hand side for
    the character **S**. Furthermore, we create nodes for characters **I** and **T**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we insert a new word, **SING**, into the ternary search tree. We start
    by comparing the first character, **S**, to the root node. Since it does not match,
    and the character **S** is greater than the root node **P**, we look at the next
    character to the right-hand side, that is, **S**. Here, the character matches,
    so we compare the next character, which is **I**; this also matches. Next, we
    compare the character **N**, to the character **T** in the tree. Here, the characters
    do not match, so we move to the left-hand side of node **T**. Here, we create
    a new node for the character **N**. Furthermore, we create another new node for
    the character **G**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we add a new node, **PUSH**, in the ternary search tree. First, we compare
    the first character of the word, that is, **P**, to the root node. Since it matches,
    we look at the next character in the ternary tree. Here, the character **U** also
    matches with the next character of the word. So, we look at the next character
    of the word, that is, **S**. It doesn't match with the next character in the tree,
    which is **T**. Therefore, we create a new node for the character **S** to the
    left-hand side of node **T** since character **S** is smaller than **T**. Next,
    we create another node for the next character, **H**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take note that each node in the ternary tree keeps track of which node is the
    leaf node or non-leaf node via the use of a flag variable.
  prefs: []
  type: TYPE_NORMAL
- en: Ternary search trees are very efficient for strings searching for related applications
    such as when we wish to search all of the strings that start with a given prefix,
    or when we wish to search for a phone number that starts with given specific numbers,
    spell checks, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at tree data structures and their uses. We studied
    binary trees in particular, which is a subtype of tree where each node has two
    children at most. We also looked at how a binary tree can be used as a searchable
    data structure with a BST. The breadth-first and depth-first search traversal
    modes were also implemented in Python by using queue recursion.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at how a binary tree can be used to represent an arithmetic or
    a Boolean expression. We then built an expression tree to represent an arithmetic
    expression. Afterward, we showed you how to use a stack to parse an expression
    written in RPN, build up the expression tree, and finally traverse it to get the
    result of the arithmetic expression.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we mentioned heaps, a specialization of a tree structure. We have tried
    to at least lay down the theoretical foundation for the heap in this chapter so
    that we can go on to implement heaps for different purposes in upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be discussing the details of hash tables and symbol
    tables.
  prefs: []
  type: TYPE_NORMAL
