- en: Chapter 2. Automating Tests – Migrating and Seeding Your Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have created some base models and the general outline of the database.
    Now, we need to create database migrations and seeding. Traditionally, database
    "dump" files have been used as a way to pass around both the schema, which is
    the structure of the tables, and the data, which would be the initial or predefined
    records, such as default values; unchanging lists, such as cities or countries;
    and users such as "admin". These dump files that contain SQL can be committed
    to source code control. This is not always the best way to maintain the integrity
    of the database; since every time a developer adds records or modifies the database,
    all of the developers in the team would need to drop and recreate the database
    or add or delete the data, tables, rows, columns, or indexes manually. Migrations
    allow the database to live in the form of code, actually residing inside the Laravel
    project, as well as to be versioned within source code control.
  prefs: []
  type: TYPE_NORMAL
- en: Migrations are run from the command line and can also be automated to automatically
    create the database, whenever required if it doesn't already exist, or drop and
    recreate the tables and populate the tables if they already exist. Migrations
    have existed for a while in Laravel, so their presence in Laravel 5 is not surprising.
  prefs: []
  type: TYPE_NORMAL
- en: Using Laravel's migration feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step is to run the `artisan` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a table named `migration`, which has two columns: `migration`,
    which is a varchar 255 in MySQL, and `batch`, which is an integer. This table
    will be used by Laravel to keep track of which migrations have been run. In other
    words, it maintains a history of all of the operations that have been performed.
    The following is a list of the main operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`install`: As mentioned earlier, this operation installs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`refresh`: This operation resets and reruns all of the migrations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reset`: This operation rolls back all of migrations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rollback`: This operation is a type of "undo", and simply rolls back the last
    operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`: This operation produces a table-like output of the migrations and
    states whether or not they have been run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of migration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Laravel 5 contains two migrations in the `/database/migrations` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The first migration creates the `users` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second one creates the `password_resets` table, which, as you may have
    guessed, is used to recover lost passwords. Unless specified, the migrations operate
    on the database that is configured in the `/config/database.php` configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Migrations extend the `Migration` class and use the `Blueprint` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two methods: `up` and `down`, which are used when the `migrate` commands
    and the `rollback` commands are used, respectively. The `Schema::create()` method
    is called with the table name as the first parameter and a function callback as
    the second parameter, which accepts an instance of a `Blueprint` object as a parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `$table` object has a few methods that perform tasks such as creating indexes,
    setting up auto-increment fields, stating which type of fields should be created,
    and passing the name of the field as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The first command is used to create an auto-increment field `id`, which will
    be the primary key of the table. Then, string fields, such as `name`, `email`,
    and `password` are created. Note that the unique method is chained to the `create`
    statement for the `email` field, stating that the `email` field will be used as
    the login name/user ID, as this is a common practice in most modern web applications.
    The `rememberToken` is used to allow the user to remain authenticated per each
    session. This token gets reset on each login and logout, protecting the user from
    a potentially malicious hijacking attempt.
  prefs: []
  type: TYPE_NORMAL
- en: The Laravel migration magic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Laravel migrations are also capable of creating timestamp fields that are used
    to automatically store creation and update information for each model through
    its table row.
  prefs: []
  type: TYPE_NORMAL
- en: $table->timestamps();
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following line of code tells the migration to automatically create two
    columns in the table, namely `created_at` and `updated_at`, which is automatically
    used by Laravel''s Eloquent **Object-relational mapping** (**ORM**) to allow the
    application to know when the object was created and when it was updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$table->timestamps()`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the fields are updated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Another great Laravel feature is the soft delete field. This provides a type
    of **recycle bin** to allow the data to be optionally restored at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: 'This feature simply adds another column to the table to allow soft deleting
    of the data. The code to be added to the migration looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This adds a column to the `database, deleted_at,` which will either have `null`
    as its value or a timestamp to indicate when the record was deleted. This builds
    a recycle bin feature right into your database application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The migration is initiated and the tables are created. The **migration** table
    now appears, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![$table->timestamps();](graphics/B04559_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The structure of the `users` table is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![$table->timestamps();](graphics/B04559_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To rollback the migration, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `rollback` command uses the migration table to determine which actions to
    rollback. In this case, the `migrations` table, after it has been run, is now
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: From schema to migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common situation that occurs during the development process is that a schema
    is created, and then, we need to create a migration from that schema. At the time
    of writing, there is no official tool to do this in the Laravel core, but there
    are several packages available.
  prefs: []
  type: TYPE_NORMAL
- en: One such package is the `migrations-generator` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the following line to the `require-dev` section of the `composer.json`
    file to require the `migrations-generator` dependency in the `composer.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also necessary to add the following text to the `composer.json` file
    at the root level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Composer's require-dev command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `require-dev` command, as opposed to `require`, is a mechanism of a composer
    that allows certain packages that are needed only in the development phase. Most
    testing tools and migration tools will only be used in the local development machine,
    QA machine, and/or in a continuous integration environment, but not in the production
    environment. This mechanism keeps your production installation free of unnecessary
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel's providers array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Laravel's `providers` array in the `config/app.php` file lists the providers
    that are available to Laravel at all times.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add both the `way generator` and the `Xethron migration` service providers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The composer update command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `composer update` command is a simple, yet powerful way to make sure that
    everything that needs to be in place is actually working and free of errors. After
    running this command, we're now ready to run the migrations.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the migrations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Simply type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `artisan` command will display a list of all of the possible commands. The
    `migrate:generate` command should be included on the list of valid commands. If
    this command is not on the list, then something is not configured correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you confirm that the `migrate:generate` command exists in the list, simply
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will start the process.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we have used the MySQL database. By entering `Y` when prompted,
    the process will begin and the output should show one migration file created for
    each table in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how your command prompt should appear at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Migration anatomy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider an example of one of the lines in the migration file; we can see that
    the table object is used in a chain of methods. The following line of the migration
    file sets up the state attributes in the location eloquent attribute in the `locations`
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: List tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, it is necessary to create or import a list of finite items that usually
    remain constant, such as cities, states, countries, and similar items. Let's call
    these list tables or lookup tables. In these tables, the ID should usually be
    positive. These lists may grow, but they usually will not have any data that is
    deleted or updated. The `smallInteger` type is used to keep the table small and
    also represent a value that belongs to a finite list, something that will not
    grow naturally. The next method, `unsigned`, states that the limit will be 65535\.
    This value should be enough to represent most of the states, provinces, or similar
    types of geographical regions where a hotel could be located. The last method
    in the chain adds an index to the database column. This is essential in list tables
    like these, which are used in the `select` statements or in the `read` statements.
    The `Read` statements will be discussed in [Chapter 9](ch09.html "Chapter 9. Scaling
    Laravel"), *Scaling Laravel*. It is important to use unsigned, as it doubles the
    positive limit, which otherwise would be 32767\. Using the index, we can speed
    up the look up time and access a cached version of the data in the table.
  prefs: []
  type: TYPE_NORMAL
- en: The softDelete and timestamp properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Regarding `softDeletes` and `timestamps` for list tables, it depends. If the
    table is not very large, it shouldn''t be too harmful to keep track of any updates,
    inserts, or deletions if they do happen; however, if the list consists of countries,
    where changes occur infrequently and are very small, it would be prudent to omit
    `softDeletes` and `timestamps`. So, the entire table will probably fit into the
    memory and will be very fast. To omit timestamps, it''s necessary to add the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Creating seeds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create our database seeder, we will modify the `DatabaseSeeder` class that
    extends `Seeder`. The name of the file is `database/seeds/DatabaseSeeder.php`.
    The contents of the file will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The seeder file sets up the very basic possible scenario. For initial testing,
    we don't need to even add every country, state, city, and location possible to
    the database; we simply need to add the essential information to create various
    scenarios. To create a new reservation; for example, we will create an instance
    of each of the user, country, state, city, location, and accommodation models,
    and then create two rooms, which are added to an array of rooms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a repository for the reservation that will implement a very simple
    repository interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create `ReservationRepository`, which implements `RepositoryInterface`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create the method that is needed to create the reservation and
    also to populate the pivot table, `reservation_room`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `array_except()` Laravel helper is used to return the `attributes` array,
    except for the `$rooms` array, which will be used for the `sync()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we set each attribute of the model to the attributes that are set in
    the method. We will need to add the method that will establish the many-to-many
    relationship between the reservations and rooms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we need to add `withTimestamps()` to the relationship so that
    the timestamps will be updated, indicating when the relationship was saved in
    the `reservation_room` pivot table.
  prefs: []
  type: TYPE_NORMAL
- en: Database testing with PHPUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PHPUnit is well integrated with Laravel 5 as it was with Laravel 4, so it is
    rather easy to set up the testing environment. A good method for testing would
    be to use the SQLite database and to set it up to reside in the memory, but you
    need to modify the `config/database.php` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to modify the `phpunit.xml` file to set a `DB_DRIVER` environment
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to modify the following line in the `config/database.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We modify the preceding line to match with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will set up PHPUnit to run our migrations on the in-memory `sqlite`
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `tests` directory, there are two classes: a `TestCase` class that extends
    the `LaravelTestCase` class and an `ExampleTest` class that extends the `TestCase`
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add two methods to `TestCase` to perform the migrations, run the
    seeder, and then revert the database back to its original state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create a PHPUnit test to verify that the data is being saved correctly
    in the database. We need to modify `tests/ExampleTest.php` to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Running PHPUnit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start PHPUnit, simply type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The tests will be run. Since the `create` method of the `Reservation` class
    returns a reservation, we may use the `assertInstanceOf` method of PHPUnit to
    determine whether or not a reservation was created in the database. We can add
    any other assertions to make sure that the values saved are exactly what we intended.
    For example, we can assert that the start date is equal to `''2015-10-01''` and
    the size of the `room` array is equal to `two`. Together with the `testBasicExample()`
    method, we can ensure that a `GET` request to `"/"` returns a `200`. The PHPUnit
    results will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running PHPUnit](graphics/B04559_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that there were two dots to represent the tests. **OK** means that nothing
    failed, and we are told again that there were two tests and four assertions; one
    assertion in the example and the other three, which we have added to our `testReserveRoomExample`
    test. Had we tested that there were three rooms instead of two, PHPUnit would
    have produced the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that instead of the second dot, we have an `F` for failure, and instead
    of `OK`, we''re told that there was `1` failure. PHPUnit then lists which tests
    failed, and nicely tells us the line that I deliberately modified to be incorrect,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line is indeed incorrect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Remember that `2` is the value of the count `($reservationResult->rooms)`.
  prefs: []
  type: TYPE_NORMAL
- en: Functional testing with Behat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While phpspec follows the BDD by specification and is useful for specification
    and design in isolation, its complimentary tool Behat is used for integration
    and functional tests. Since phpspec suggests to mock everything, database queries
    wouldn't actually be executed, as the database is outside the context of that
    method. Behat is a great tool to perform behavioral testing on a certain feature.
    While phpspec is already included among Laravel 5's dependencies, Behat will be
    installed as an external module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command should be run to install and make Behat work with Laravel
    5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: After running the composer update, Behat's functionality is added to Laravel.
    Next, a `behat.yaml` file should be added to the root of the Laravel project to
    specify which extensions are to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This will create a `features` directory with a `bootstrap` directory inside
    it. A `FeaturesContext` class will also be created. Everything inside bootstrap
    will be run every time `behat` is run. This is useful to automatically run migrations
    and seeding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `features/bootstrap/FeaturesContext.php` file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `FeatureContext` class needs to extend the `MinkContext` class, so
    the class definition line will need to be modified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `prepare` and `cleanup` methods will be added to the class in order
    to perform the migrations. We will add the `@BeforeSuite` and `@AfterSuite` annotations
    to tell Behat to perform the migration and seeding before each suite and migrate
    to rollback in order to restore the database to its original state after each
    suite. Using annotations in the doc-block will be discussed in [Chapter 6](ch06.html
    "Chapter 6. Taming Complexity with Annotations"), *Taming Complexity with Annotations*.
    Our class now is structured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, a feature file needs to be created. Create `reservation.feature` in the
    room directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When `behat` is run as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output is produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Behat, as did phpspec, skillfully produces the output, showing you the methods
    that need to be created. Notice that camel case is used instead of snake case.
    This code should be copied in to the `FeatureContext` class. Notice that, by default,
    an exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the RESTful API will be called, so the guzzle HTTP package will need
    to be added to the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Next, add an attribute to the class to hold the `guzzle` object. We will add
    a `POST` request to a RESTful resource controller to create a reservation and
    expect a 201 code. Notice that the return code is a string and needs to be casted
    to an integer. Next, a `get` is performed to return all of the reservations.
  prefs: []
  type: TYPE_NORMAL
- en: 'There should only be one reservation created, since the migration and seeding
    run every time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to create `ReservationController`, use artisan from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the contents of the reservation controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, add `ReservationController` to the `routes.php` file, which is located
    in `app/Http/routes.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when `behat` is run, the result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuring Laravel to create migration files from the existing schemas is also
    a useful framework for non-greenfield projects. By running both the migrations
    and seeding in the testing environment, each test can benefit from a completely
    clean version of the database, and the initial data that allows it to have "just
    enough" in the database to minimally verify that the software performs as it needs
    to. When legacy code needs to be ported to Laravel, PHPUnit can be used to test
    any existing functions. Behat provides a behavioral-based alternative, which can
    skillfully perform end-to-end testing.
  prefs: []
  type: TYPE_NORMAL
- en: We designed our classes using phpspec in an isolated environment, concentrating
    only on the business rules and client's requests while mocking things, such as
    the actual entities, such as rooms. We then verified that the actual queries were
    executed and saved in the database correctly by the use of a functional testing
    testing tool, PHPUnit. Finally, we used Behat to perform end-to-end testing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll see the creation of a RESTful API, the basic CRUD
    operations (create, read, update, and delete), and discuss some best practices.
  prefs: []
  type: TYPE_NORMAL
