- en: Chapter 5. Manipulating the Zombie Browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our to-do HTTP application and understand how the Mocha testing
    framework works, we are ready to start creating tests using Zombie.js.
  prefs: []
  type: TYPE_NORMAL
- en: As covered before, Zombie.js allows you to create a simulated browser environment
    and manipulate it. These manipulations are the usual things users do with browsers,
    such as visiting a URL, clicking on links, filling and submitting forms, and others.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visiting a URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filling and submitting a form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for errors in the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating document content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding CSS selector syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter shows you how you can setup a Zombie.js browser that interacts
    with your web application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Visiting a URL**: First, we are going to pick up our application tests from
    where we left off. The whole app concerns users, but in this part, we''re mainly
    going to focus on functionality that the `Users` routes touch—rendering a signup
    form and actually creating a user record in the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, we left off with this single test file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This test simply loaded the user signup form and tested whether the browser
    considered it a success. Let's go through this test to fully understand what is
    going on.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we create a new browser by instantiating a new browser object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a Zombie.js browser, which represents an independent browser process
    that has the main job of maintaining state across requests: the URL history, the
    cookies, and the local storage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A browser also has a main window, and you can load a URL in it by using `browser.visit()`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This makes the browser perform an HTTP `GET` request to load the HTML page from
    that URL. Since Node.js and Zombie.js do asynchronous I/O processing, this only
    makes Zombie.js to start loading the page. Then Zombie.js tries to fetch the URL,
    parse the HTML document, and resolve all the dependencies by loading the referenced
    JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all that is done, we can be notified by passing a callback function to
    the `browser.wait()` method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using the `browser.wait` function, we pass a callback directly into
    the `browser.visit()` call, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here you pass in a callback function that gets invoked once there is an error
    or the browser is ready. If an error occurs, it is returned as the first argument—we
    check whether an error exists and throw it if it does, so that the test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second argument containing the browser object, which is the same as the
    browser object we already had. This means that we can omit the second argument
    altogether and work with the previous browser reference, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If it''s the same browser object, you may ask why that object is even passed.
    It''s there to support this form of invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that here we're using the capitalized pseudo-class `Browser` object; we're
    not instantiating `browser`. Instead, we're leaving that up to the `Browser` module
    to do it and to pass it on to us as the second argument of our callback function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From now on, we will prefer this last succinct form to the others shown here.
  prefs: []
  type: TYPE_NORMAL
- en: When is the browser ready?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we ask the browser to visit a URL, it calls us back when it's finished,
    but as web developers know, it's tricky to know exactly when a page load can be
    considered fully finished
  prefs: []
  type: TYPE_NORMAL
- en: A browser object has its own event loop that handles asynchronous events, such
    as loading resources, events, timeouts, and intervals. After a page is loaded
    and parsed, all the dependencies are loaded and parsed asynchronously—just like
    in real browsers—using this event loop.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these dependencies may contain JavaScript files that will be loaded,
    parsed, and evaluated. Furthermore, the HTML document may contain some additional
    inline scripts that will be executed. If any of these scripts have a callback
    waiting for the document to be ready, these callbacks will be executed before
    your `browser.visit()` callback fires your test callback. This means that if,
    for instance, you have jQuery code that gets fired when the document is ready,
    it will run before your callback. The same can be said for any subsequent AJAX
    callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, try adding the following code immediately before the
    closing `</body>` tag in the `templates/layout.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then change the test code in `test/users.js` so that it logs when the visit
    callback gets fired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To analyze this, we are going to run our tests in debug mode. In this mode,
    Zombie.js outputs some useful information, which includes the HTTP request activity
    that the browser is carrying out. To enable this mode, set the `DEBUG` environment
    variable like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now get the following debug output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are a Windows user, this last command will not work. You will need to
    set the `DEBUG` environment variable before running the Mocha command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also need to replace the forward slashes (`/`) to backslashes (`\`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `LOADED NEW` string is printed before the `VISIT IS DONE`
    string, which means that the browser performed and finished the AJAX request before
    your visit callback fired. You may wish to return to the code now and remove this
    extra console logging.
  prefs: []
  type: TYPE_NORMAL
- en: Options when visiting URLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also pass in some options to the browser, to modify some of the actions
    and conditions regarding how it loads the page. These options come in the form
    of an object that you pass as an argument to the `Browser.visit()` call, right
    before the callback, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the most useful options that we will discuss in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: debug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: maxWait
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: debug
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we''ve seen, by setting the `DEBUG` environment variable, you can get some
    output from Zombie.js. This feature can also be activated by setting the `debug`
    option to `true`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can define a set of headers to be sent out on each HTTP request that originates
    from this visit. By default, Zombie.js sends these header values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**user-agent**: Mozilla/5.0, Chrome/10.0.613.0, Safari/534.15, or Zombie.js/1.4.1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**accept-encoding**: identity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**host**: localhost:3000'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**connection**: keep-alive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `user-agent` header defines a fake user agent that somewhat mimics the Mozilla,
    Chrome, and Safari browsers, but you can change that in this setting, as you'll
    see later.
  prefs: []
  type: TYPE_NORMAL
- en: The `accept-encoding` header is specifying that no encoding should be done on
    the resulting document.
  prefs: []
  type: TYPE_NORMAL
- en: The `host` header is required as of HTTP 1.1 and specifies which hostname you're
    referring to for this request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `connection: keep-alive` header specifies that the connection to the server
    should be kept open after the request is done. This is an internal option that
    allows Node to reuse client-side sockets throughout many HTTP connections, which
    will slightly speed up your tests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add an additional header value, should your application need any, specify
    them like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that these values will also be sent for every request when loading dependencies
    such as subsequent CSS and JavaScript files referred to in your HTML document.
  prefs: []
  type: TYPE_NORMAL
- en: maxWait
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, when calling `Browser.visit`, Zombie.js loads the page, parses
    it, loads the dependencies, and runs any pending JavaScript code in the browser.
    If this takes more than 5 seconds, an error will be raised and your test will
    fail. If, for any reason, 5 seconds is not enough for all of this to happen, the
    limit can be increased by changing the `maxWait` option like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can specify the value as a string as `10ms`, `100ms`, `7.5s`, and so on..
  prefs: []
  type: TYPE_NORMAL
- en: Checking the existence of elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the `Browser.visit()` callback is fired, we check for errors. We also check
    whether the page was successfully loaded if the HTTP response status code was
    between 200 and 299\. These 2XX response codes correspond to the `ok` request
    state and are part of the server's way of telling the user-agent that everything
    went well.
  prefs: []
  type: TYPE_NORMAL
- en: Despite receiving an `ok` response, we shouldn't take the server's word for
    granted. We may have received the response status code and an HTML document, but
    can't be sure that we got the intended document containing the markup for the
    user signup form.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we may wish to verify that the document has a heading element
    containing the `New User` string and that the new user form elements are present.
    Here is the code for the complete test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The new lines on the test are highlighted. Let's go through them now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, `browser.text(<selector>)` is being used to extract the text content of
    the `h1` tag if (at least) one exists.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a selector matches more than one HTML element (which would happen if you
    had, in this case, more than one `h1` tag in the document), `browser.text(<selector>)`
    will return the concatenated text of all the matched nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the selector is just the tag name, but you can use any Sizzle-valid selector.
    These are similar to CSS3 selectors, which are also used in jQuery. If you're
    not familiar with these, don't worry, we will be seeing more examples of these
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The browser (and all browsers) stores the representation of the current document
    in an accessible structure called **Document Object Module** (**DOM**). The HTML
    markup inside a document is parsed by the browser and the DOM tree is built. This
    DOM can be traversed programmatically using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we are using the `browser.query(<selector>)` method to extract the first
    form element. This element is a DOM node, as you would find in the browser, and
    it respects the DOM specification. For now, we''re only testing whether it exists.
    After this, we are going to check whether some attributes are correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here we're verifying that the form method is `POST` and that, when the user
    submits it, it actually posts to the `/users` URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we verify if the form elements that are necessary to create a user are
    present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We're using the `browser.query(<selector>, <context>)` form to retrieve the
    first matching node, but this time, we're restraining the search to the subset
    child of `<context>`, which in our case is our `form` node. We are also using
    more complex selectors here, combining the tag name selector (`form`) with the
    ID selector `#id` and the attribute selector `[type=email]`. For instance, the
    first selector, `input[type=email]#email`, selects inputs that have the attribute
    of type `email` and an ID of the value `email`. This way, we're asserting that
    such an element exists since, if it didn't exist, the `browser.query()` call would
    return `undefined`, breaking the assert call.
  prefs: []
  type: TYPE_NORMAL
- en: Filling a form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have loaded a page containing the user subscription form, you can
    fill the form and submit it back to the server. For this, we will use a new test
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we''re revisiting the user creation form, and once the form has loaded,
    we''re filling in the e-mail and password fills by using the `browser.fill(<field>,
    <value>)` method. In this form, `browser.fill()` accepts several types of arguments
    as a field identifier. Here we''re using the label text that precedes the field.
    If you view the source for the empty user creation form, it will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the two label tags we are using here has a `for` attribute that indicates
    the `id` attribute of the tag it relates to. This is what Zombie.js uses to match
    the field in `browser.fill()`. Alternatively, we could also specify the field
    name or CSS selector, making the following fill directives equivalent to what
    we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then run the test by typing on the shell console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Provided the CouchDB server is accessible, these tests should then pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'But, if you run the tests again, they should fail. Try it now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is because we don't allow two users with the same e-mail address, and the
    browser yields a 409 response code as the result of such a user creation request.
    You could remove the user document from the database by hand before each test,
    but to fully remedy this, we need to automate the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we''re going to introduce the concept of fixtures. This is where we will
    define the username and password for our user, which will be used in other tests.
    You then need to create a file under `test/fixtures.json` with the following data
    for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This JSON file will then be consumed by the `users` test file by placing `require`
    right at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you also need to access the database, and for doing that we use the same
    library that the route listeners use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to add a before hook into the `Signup Form` test description scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This will make sure there is no such user record in our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''re using fixtures, let''s remove those hard-coded username and
    password strings from our test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This would then be the whole assembled user test file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When running this test repeatedly, you should always get a success message now.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the login form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the user creation flow tested, let's test if that user can
    log in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the test file pattern we have been using, you need to create a file
    under `test/session.js` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the missing dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: That concludes the opening ceremonies!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to start describing the login form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This `before` hook creates the test user document if one doesn't exist (instead
    of removing if it existed).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will test whether the login form loads and contains the relevant elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The only difference here from the user code is that the heading string should
    be `Log in` instead of `New User`. This happens because we have such a minimal
    user creation form, which suits us for the time being.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we are testing to see whether the login form actually works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here we're loading and filling in the e-mail and password fields and clicking
    on the **Log In** button. When clicking on the button, the login form is posted,
    the session is initiated, and the user is redirected to the to-do items page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run this test file from the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This test includes the case for when the user enters the right username and
    password, but what happens when that''s not the case? Let''s create a test case
    for it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here we're loading and filling the login form, but this time we're providing
    a wrong password. After clicking on the **Log In** button, the server should return
    `403 status code`, which will trigger an error passed in to our callback. Then
    we need to check the return status code by inspecting the `browser.statusCode`
    attribute, making sure it's the expected 403 forbidden code. Then we also verify
    that the user did not get redirected to the `/todo` URL and that the response
    document contains an alert message saying `Invalid password`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the to-do list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''re done with the user registration and the session initiation,
    we are ready to test the core of our app, which is to manage to-do items. We will
    start by segregating that part of the application tests into a file of their own
    at `test/todos.js`, which may start with the following boilerplate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here we have similar boilerplate code for the other modules, with the difference
    that now we are dealing with a database named `todos`, not `users`. Another difference
    is that we want to start with a clean to-do list for each test, so we're adding
    a `beforeEach` hook that removes all the to-do items for the test user.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to start carving out some tests, but there is at least one
    cumbersome repetitive task ahead that can be avoided at an early stage: logging
    in. We should assume that each test is individually reproducible and that the
    ordering of the tests doesn''t matter—each test should rely on one browser instance,
    mimicking one individual user session per test. Also, since all the to-do item
    manipulation is scoped to a user and the user session must be initiated, we need
    to abstract that away into its own module inside `test/login.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This module makes sure that a test user exists before loading, filling, and
    posting the user login form. After that it hands off the control to a `next` function.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the to-do list page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we are ready to add further description scopes inside our `todos` scope.
    One of these scopes is the to-do list, which will have this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here we can see that that we are making use of our `login` module to abstract
    away the session initiation dance, making sure our callback function only gets
    called once the user is logged in. Here we have three tests.
  prefs: []
  type: TYPE_NORMAL
- en: In our first test, named `should have core elements`, we are simply loading
    the empty to-do list and asserting that we have some elements in place, such as
    a heading containing the `Your To-dos` text and a link to create a new to-do item.
  prefs: []
  type: TYPE_NORMAL
- en: In the following test, named `should start with an empty list`, we are simply
    testing whether the to-do list contains zero elements.
  prefs: []
  type: TYPE_NORMAL
- en: In the last test of this scope, named `should not load when the user is not
    logged in`, we are asserting that this list is inaccessible to the user that has
    not yet initiated the session, making sure he is redirected to `/session/new`
    if we try to load the `To-do list` URL.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the to-do item creation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we need to test whether the to-do items can really be created. For that,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a new description scope that we''ll name `Todo creation form`—which
    will be another subscope of the `Todos` one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now test whether the to-do creation form is available for the user who
    is not logged in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here we are verifying that the user gets redirected to the login screen if an
    attempt is made to load the to-do item creation form without being logged in.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user is logged in, we check whether the page loads with some expected
    elements such as the title and the form elements for creating a new to-do item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Here we are verifying that the form is present, that it has the necessary attributes
    to make a `POST` request to the `/todos` URL, and that the form has a text area
    input and a button to press.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can also test whether we can successfully create a to-do item by filling
    the respective form and submitting it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here we are finally testing whether the form allows us to post a new item and
    whether the item gets created. We are doing that by loading and filling in the
    to-do item creation form; verifying that we've been redirected to the to-do item
    list page; and that this page contains the single to-do item that we've just created.
  prefs: []
  type: TYPE_NORMAL
- en: Testing to-do item removal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we''ve tested to-do item insertion, we can test whether one can actually
    remove these items from one''s list. We will place these tests inside a describe
    scope named `Todo removal form`, inside which we will test for two things: the
    removal of one to-do item when only one exists and the removal of a to-do item
    when more than one item exists.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are doing these two tests separately because it's easier to understand the
    one-item test and then move on to the more complex one and also to test separately
    that we are not making off-by-one errors that are so common in programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the removal from a one-item list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we run the test, there is a `beforeEach` hook that inserts a to-do item
    into the `todo` database for the test user. That''s just one to-do item that''s
    taken from `fixtures.todo`, which is a property we need to add to the `test/fixtures.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that, we're taking the opportunity here to add some additional
    fixtures that will help in future tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing analyzing the test code, we see that the test fetches the to-do
    list and then verifies that the number of to-do items is actually one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then it goes on to try and press the remove button of that one to-do item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The selector assumes that there is one to-do item on the table, which we had
    already verified before.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the browser cannot find a button or submit element from the given CSS selector,
    it will throw an error, ending the current test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, after pressing the button and submitting the removal form, we''re verifying
    that no errors occurred, that the browser was redirected back to the `/todos`
    URL, and that the presented list is now empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve tested that this works well for removing one item from a one-item
    list, let''s create a more evolved test that asserts that we can remove a specific
    item from a list of three items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This description scope will sit at the same level as the previous one, also
    inserting a document in the `todo` database, but this time the document contains
    a list of three to-do items, taken from the `fixtures.todos` attribute (instead
    of the previously used singular `fixtures.todo` attribute).
  prefs: []
  type: TYPE_NORMAL
- en: 'The test starts by visiting the `todo` list page and building a list of the
    expected to-do items, stored in the variable named `expectedList`. We then retrieve
    all the to-do list items found on the HTML document and verify that the content
    is what is expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have verified that all the expected to-do items are in place and in
    order, we go on to click on the button for the second item on the list by using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're using the special CSS selector `nth-child` for selecting exactly
    the row for the second do-to item and then fetching the code for removing submit
    button inside it, and finally pressing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the button is pressed, the form is submitted, and the browser calls back,
    we verify that there are no errors, that we got redirected back to the `/todos`
    URL, and also that it contains the expected list. We do this last bit by removing
    the second element from the previously used `expectedList` array and verifying
    that this is exactly what is shown in the current page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can run the tests individually by hand, but you should be able to run them
    all at once. For that, you simply need to call from the shell command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to change `package.json` so that you can inform **node package**
    **manager** (**npm**) how to run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now run your tests using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Zombie.js allows us to visit URLs, load HTML documents, and retrieve HTML elements
    using CSS selectors. It also allows us to easily fill forms and submit them, to
    click on buttons and follow links, to verify the return status code, and to analyze
    the response document in the same way using a terse, convenient API.
  prefs: []
  type: TYPE_NORMAL
