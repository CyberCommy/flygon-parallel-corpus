- en: '*Chapter 7*: Learning Redux and React Router'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll learn about Redux and React Router. Redux is still the
    most common method of managing global state shared across a React application.
    Using Redux global state, we can reduce a great deal of boilerplate code and streamline
    the application. React Router is also the most popular framework for managing
    client-side URL routing. Client-side URL routing allows a SPA application to behave
    in ways that are familiar to users expecting a classic-style web application that
    indicates where they are in the app. Both of these technologies are necessary
    for building SPA applications that look and feel like standard web apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about Redux state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about React Router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should have a basic understanding of web development using React. We will
    once again be using Node and Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository is at [https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node).
    Use the code in the `Chap7` folder.
  prefs: []
  type: TYPE_NORMAL
- en: To set up this chapter's code folder, go to your `HandsOnTypescript` folder
    and create a new folder called `Chap7`.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about Redux state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redux is still the most popular enterprise-level framework for creating and
    managing global state in a React application (although we can use Redux in any
    JavaScript app, not just React). Many newer frameworks have been created, and
    some of them have gained their own considerable following; however, Redux is still
    the most commonly used. You may find that Redux is difficult to understand at
    first. However, once we do learn it, we'll see its many benefits and why it is
    so often the go-to framework for large, complex React applications.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about React state in [*Chapter 4*](B15508_04_Final_JC_ePub.xhtml#_idTextAnchor072),
    *Learning Single-Page Application Concepts and How React Enables Them*, and [*Chapter
    5*](B15508_05_Final_JC_ePub.xhtml#_idTextAnchor081), *React Development with Hooks*.
    So, to reiterate, state, or a component's data, is the main driver of all UI changes
    in React. This is the reason why the React framework has the word "react" in its
    name, because it is reacting to these state changes (this is also known as being
    reactive). So, when creating and managing state, we generally want to associate
    local state with the component or the component's root parent most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: Component-based state can be limiting. There are cases where state is not specific
    to a component or even to a component hierarchy. State can sometimes be necessary
    for several components or other non-component services that make up an application.
    In addition to this, state in React is passed down only one way, from the parent
    down to children as props. It should not be done upstream. And this further constrains
    how state can be used in React. Redux therefore provides a mechanism not only
    to share state globally but also to allow injection and updating of state from
    any component as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's give an example to flesh this out a bit. In a typical enterprise-class
    application, we will always have authentication. And once a user is authenticated,
    we may receive certain data about the user â€“ for example, the user's full name,
    user ID, email, and so on. It should not seem unreasonable to think that these
    data points may be used by a significant portion of the components within an application.
    It would be tedious and error-prone therefore to have each component call to get
    this data and then save it locally in their own state. Doing it this way would
    mean that there were multiple copies of the data and as it changed, some components
    may end up keeping older versions of the data.
  prefs: []
  type: TYPE_NORMAL
- en: This sort of conflict can be the source of bugs. Therefore, it would be helpful
    to be able to maintain this data on the client in only one place and share it
    with whatever component needed it. This way, if this data ever did get updated,
    we could be assured that all components, no matter what section of the app they
    are in, would get the latest valid data. This is what Redux can do for our application.
    We can consider it a **single source of truth**.
  prefs: []
  type: TYPE_NORMAL
- en: Redux is a data storage service that maintains all the globally shared data
    in our React application. Redux provides not only the store itself, but also the
    base functions needed to add, remove, and share this data. One difference with
    React state, however, is that Redux state is not necessarily going to trigger
    UI updates. It certainly can if we desire to do so, but there is no explicit necessity
    for doing so. So, we should keep that in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how to set up Redux:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new React project in the `Chap7` folder like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once our project is set up, open it and use your command line to `cd` into the
    `redux-sample` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will now install Redux, which is actually several different dependencies.
    First, run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This command gives us the main dependencies, including the TypeScript types.
  prefs: []
  type: TYPE_NORMAL
- en: OK, now that we've done some basic setup, we need to understand a few more things
    about Redux before we continue. Redux uses a pair of concepts called reducers
    and actions. Let's see what each of these does.
  prefs: []
  type: TYPE_NORMAL
- en: Reducers and actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Redux, there is only a single store for all data. So, all our global data
    will live inside of a single Redux object. Now, the issue with this design is
    that, since this is global state, different app features will require different
    types of data and the entirety of the data is not always relevant to all parts
    of the application. So, the Redux creators came up with a scheme that uses reducers
    to filter and split up the single store into separated chunks. So, if component
    A only needs a specific piece of data, it does not have to deal with the entire
    store.
  prefs: []
  type: TYPE_NORMAL
- en: This design is a good way of separating data concerns. But the side effect of
    having such a design is that we need some way of updating the relevant portion
    of data without affecting any of the other pieces. This is what actions do. Actions
    are objects that provide the data for specific reducers only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a high-level view of what reducers and actions are, let''s
    look at some examples in code:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder called `store` under `src`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, create a file called `AppState.ts`. This file will store our aggregated
    reducer object called `rootReducer` of type `AppState`, which represents the global
    state. Insert this code into the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`rootReducer` represents an aggregated object of all of our reducers. We don''t
    have any reducers yet, but we will add the actual reducers once our setup is complete.
    `combineReducers` takes each of our reducers and combines them into a single object.
    At the bottom, we are creating a TypeScript type based upon our `rootReducer`
    by using the `ReturnType utility type`, and then exporting the new type called
    `AppState`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'A utility type is simply a helper class that the TypeScript team created to
    give specific functionality. There are many different utility types and a list
    can be found here: [https://www.typescriptlang.org/docs/handbook/utility-types.html](https://www.typescriptlang.org/docs/handbook/utility-types.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a file called `configureStore.ts`, which will contain our actual
    store object used by Redux and the app. This is what it should look like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, Redux's `createStore` method is used to build the actual store
    based upon our `AppState` object, `rootReducer`. `configureStore` is exported
    and used later to execute the creation of the store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we must update our `index.tsx` file to call our `configureStore` method
    and initialize Redux for our app. Update `index.tsx` like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we import `Provider` from `react-redux`. `Provider` is a React component
    that acts as a parent component to all other components and *provides* our store
    data. In addition, `Provider`, as shown, is receiving the initialized store by
    accepting the return value of the `configureStore` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This commented code is coming from the `create-react-app` project. It is included
    here for completeness. OK, so now we have a base-level setup of Redux. So, our
    example will continue by creating a call to get a user object. We will use the
    JSONPlaceholder API we learned about in [*Chapter 6*](B15508_06_Final_JC_ePub.xhtml#_idTextAnchor091),
    *Setting Up Our Project Using create-react-app and Testing with Jest*. After a
    successful login, it shares the user information by putting it into Redux as a
    reducer. Let''s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `UserReducer.ts`, inside of the `store` folder, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we do is create a constant for the action type called `USER_TYPE`.
    This is optional but helps us avoid issues such as typos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a type representing our `User`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, by convention, an action has two members: type and payload. So, we create
    a `UserAction` type with those members in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: And then, finally, we create our reducer called `UserReducer`. A reducer always
    takes the `state` and `action` parameters. Note, `state` is not the entire state,
    it is only the partial state relevant to some reducer. This reducer will know
    whether the passed-in `state` is its own based on the `action` type. Also notice
    that the original state is never mutated. This is extremely important. *Never*
    change the state directly. You should either return the state as is, which is
    done in `case` `default`, or return some other data. In this case, we return `action.payload`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now, we have to go back into our `AppState.ts` file and add this new reducer.
    The file should now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s start using our new state. Update the `App.tsx` file like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We will take `userid` as a parameter and then, based upon that ID, we will get
    the associated user from the JSON Placeholder API. Now, in order to do this, we
    need to use some Redux-specific Hooks so we can add our found user to the Redux
    store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update the `App` component in `App.tsx` like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'const onChangeUserId = onChangeUserId handler, we make a call to the JSONPlaceholder
    API. Then we use the usersResponse response object to get the result from our
    network API. We then get our desired user by filtering with the user ID we got
    from our UI. Then we use dispatch to send our action to our reducer. Also notice
    onChangeUserId is now an async function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This UI will take `userid` as an input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a child component that can display all of our user-related
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new component called `UserDisplay.tsx` and add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add the `UserDisplay` component to our `App` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: function App() {
  prefs: []
  type: TYPE_NORMAL
- en: const [userid, setUserid] = useState(0);
  prefs: []
  type: TYPE_NORMAL
- en: const dispatch = useDispatch();
  prefs: []
  type: TYPE_NORMAL
- en: 'const onChangeUserId = async (e:'
  prefs: []
  type: TYPE_NORMAL
- en: React.ChangeEvent<HTMLInputElement>) => {
  prefs: []
  type: TYPE_NORMAL
- en: const useridFromInput = e.target.value ?
  prefs: []
  type: TYPE_NORMAL
- en: 'Number(e.target.value) : 0;'
  prefs: []
  type: TYPE_NORMAL
- en: console.log("userid", useridFromInput);
  prefs: []
  type: TYPE_NORMAL
- en: setUserid(useridFromInput);
  prefs: []
  type: TYPE_NORMAL
- en: const usersResponse = await
  prefs: []
  type: TYPE_NORMAL
- en: fetch('https://jsonplaceholder.typicode.com/Â Â Â Â Â Â users');
  prefs: []
  type: TYPE_NORMAL
- en: if(usersResponse.ok) {
  prefs: []
  type: TYPE_NORMAL
- en: const users = await usersResponse.json();
  prefs: []
  type: TYPE_NORMAL
- en: 'const usr = users.find((userItem: any) => {'
  prefs: []
  type: TYPE_NORMAL
- en: return userItem && userItem.id === Â Â Â Â Â Â Â Â useridFromInput;
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: dispatch({
  prefs: []
  type: TYPE_NORMAL
- en: 'type: USER_TYPE,'
  prefs: []
  type: TYPE_NORMAL
- en: 'payload: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'id: usr.id,'
  prefs: []
  type: TYPE_NORMAL
- en: 'username: usr.username,'
  prefs: []
  type: TYPE_NORMAL
- en: 'email: usr.email,'
  prefs: []
  type: TYPE_NORMAL
- en: 'city: usr.address.city'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: return (
  prefs: []
  type: TYPE_NORMAL
- en: <React.Fragment>
  prefs: []
  type: TYPE_NORMAL
- en: <div className="App">
  prefs: []
  type: TYPE_NORMAL
- en: <label>user id</label>
  prefs: []
  type: TYPE_NORMAL
- en: <input value={userid} onChange={onChangeUserId} Â Â Â Â Â Â Â Â Â Â />
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: UserDisplay in the returned JSX UI so that our user information is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you load the browser at `http://localhost:3000` and enter `1` in the
    input, you should see this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.1 â€“ User object from the Redux store'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.01_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 â€“ User object from the Redux store
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now that we''ve seen a sample of a simple Redux store use case, let''s
    take it a step further and show what will happen when we have multiple reducers
    in the same store:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `PostDisplay.tsx` and add the following code. This
    component will display posted comments from the JSON Placeholder API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, like our previous example, here, we set up which state data we want
    using `useSelector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it looks very similar to `UserDisplay`, but it displays `post-r`elated
    information such as `title` and `body`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we update our Redux code to add our new reducer. First, add a new file
    inside of the `store` folder called `PostReducer.ts` and then add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Again, this is very similar to `UserReducer`, but focused on posts instead of
    users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to update the `AppState.tsx` file and add our new reducer to
    it. Add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, so now we''ll update our `App` component and add code specifically for
    finding a specific post by ID from the JSON Placeholder API. Update `App` with
    this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice we don't have a `dispatch` specific to any reducer. That's because dispatchers
    are just generic execution functions. The action will be routed to the appropriate
    reducer eventually.
  prefs: []
  type: TYPE_NORMAL
- en: '`onChangeUserId` has not changed but is shown here for completeness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`onChangePostId` is a new event handler for handling `post-r`elated data changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`OnChangePostId` dispatches a relevant `action` via the `dispatch` function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The UI has been slightly updated to handle the new `PostDisplay` component
    and separate it from the `UserDisplay` components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 7.2 â€“ PostDisplay result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.02_B15508_New.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 â€“ PostDisplay result
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in the console, when updating the `postid` input, there is no log
    for `UserDisplay`. This shows that the Redux store is not directly attached to
    the React render pipeline and only the components associated with a particular
    state change will re-render. This is different behavior from React Context and
    can be a benefit to performance by reducing unwanted renders (we'll talk about
    Context in the next section).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about Redux, the most popular way of managing global
    state in React. In larger apps, we will use a global state manager frequently,
    as there is generally a lot of global data sharing happening. In our application,
    we will store information about our logged-in user and other data that will be
    shared across the app, so having this capability will be valuable.
  prefs: []
  type: TYPE_NORMAL
- en: React Context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Context is a newer feature that came out a little before Hooks. Context is not
    a separate dependency but is built into React core. It allows similar functionality
    to Redux in that it allows state to be stored in a single source and then shared
    across components, without having to manually pass down props through the component
    hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'This capability is very efficient from a developer coding perspective because
    it eliminates the need to write a lot of boilerplate code to pass state down from
    a parent to its children. Here''s a visualization of a possible set of hierarchies
    in a larger React app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 â€“ React component hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.03_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 â€“ React component hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: In this example diagram, we have a single parent component and it has several
    children, which it is using in its own JSX. Those children also have their own
    children, and so on. So, if we were to configure the passing of props all the
    way down for every component hierarchy, it would be quite a bit of code, especially
    knowing that some hierarchies involve passing functions that may call back to
    some arbitrary parent. Having these sorts of prop relationships also causes additional
    cognitive load for developers, as they need to think about data relationships
    and how data is being moved among the components.
  prefs: []
  type: TYPE_NORMAL
- en: Both React Context and Redux are good ways of avoiding this state-passing boilerplate
    code, when appropriate. And for smaller projects, the simplicity of Context works
    well. However, for larger projects, I recommend against using Context.
  prefs: []
  type: TYPE_NORMAL
- en: React Context can have multiple parent providers, meaning it is possible to
    have more than one root context. For larger apps, this can be confusing and adds
    more boilerplate code. Additionally, the mixing of global state providers can
    be confusing. If a team decides to use both Context and Redux, when do we use
    each one? And if we use both now, we must maintain two styles for global state
    management.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, Context, unlike Redux, has no concept of reducers. Therefore, all
    users of Context will receive the entire set of state data, which is not a good
    practice in terms of the separation of concerns. Over time, it can become confusing
    as to what subset of the data a particular component should deal with.
  prefs: []
  type: TYPE_NORMAL
- en: 'One additional side effect of having all state data available to all component
    users is that, even if a component does not actually access the specific state
    member, any Context changes will trigger a re-render. For example, let''s say
    that the Context state looks like this `{ username, userage }` and our component
    only uses `username`. Even if `userage` alone changes, it triggers a re-render
    in that component. This is true even when `memo` is used (we covered `memo` in
    [*Chapter 5*](B15508_05_Final_JC_ePub.xhtml#_idTextAnchor081), *React Development
    with Hooks*). Let''s look at an example demonstrating this effect:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove `React.StrictMode` and `Provider` from `index.tsx` to avoid confusion.
    We''ll put this back later. Now, the `index.tsx` file should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, these comments are coming from `create-react-app` and are included here
    only for completeness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You can also remove any unused imports to avoid triggering warning messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create these two child components, where each one will use a unique member
    of our Context state. First, create the `UserAgeComp.tsx` component with this
    code in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This code uses object destructuring to only use the `userage` member of `TestContext`
    by using the `useContext` Hook, which we will create later, and displays it only.
    Now, create the `UserNameComp.tsx` component with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to create a parent component that has Context in it. Create the
    `ContextTester.tsx` file and add this code into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use `createContext` to create our `TestContext` object, which will
    hold our state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we click on `Update age` or `Update localstate`, you will see that the
    `console.log` statement in `UserNameComp` is never executed. That log statement
    was only executed one time when the page first loaded, which is what is supposed
    to happen since `UserNameComp` is using `memo` (`memo` only allows re-renders
    when props change). You should see only one set of logs in your **Console** tab
    (ignore the warnings, as we'll re-add our dependencies soon):![Figure 7.4 â€“ Context
    render result
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.04_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 â€“ Context render result
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, so then now, let''s force `UserNameComp` to use the `username` from our
    `TestContext`. So now, `UserNameComp` should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: const ContextTester = () => {
  prefs: []
  type: TYPE_NORMAL
- en: const [userage, setUserage] = useState(20);
  prefs: []
  type: TYPE_NORMAL
- en: const [localState, setLocalState] = useState(0);
  prefs: []
  type: TYPE_NORMAL
- en: const onClickAge = () => {
  prefs: []
  type: TYPE_NORMAL
- en: setUserage(
  prefs: []
  type: TYPE_NORMAL
- en: userage + 1
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: const onClickLocalState = () => {
  prefs: []
  type: TYPE_NORMAL
- en: setLocalState(localState + 1);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return (<React.Fragment>
  prefs: []
  type: TYPE_NORMAL
- en: <button onClick={onClickAge}>Update age</button>
  prefs: []
  type: TYPE_NORMAL
- en: <username is hardcoded to "dave" and never changes. And as you can see, UserNameComp
    was moved into TestContext.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run this code and then click on the buttons several times, we should
    see something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.5 â€“ Re-renders when using Context'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.05_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 â€“ Re-renders when using Context
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our `UserNameComp` component keeps getting re-rendered, even
    when we only change the `localState` variable. Why is this happening? `TestContext`
    is a component just like any other React component. And it does not use `memo`.
    So, when the parent component, `ContextTester`, gets re-rendered, it also gets
    re-rendered, which has a knock-on effect for any of its children. This is why
    `UserNameComp` keeps getting re-rendered although it never uses the `userage`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: So, as you can see, Context has some issues with its use, and it is my opinion
    that for large React applications, if you had to choose between the two, it would
    be better, albeit more complex, to use Redux.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about Context basics. Context is relatively easy
    to learn and use. And for smaller projects, it works very well. However, due to
    its simple design, for more complex projects, a more sophisticated global state
    management system may be preferable.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about React Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Router is the most commonly used routing framework in React. It is relatively
    simple to learn and use. Routing, as we discovered in [*Chapter 4*](B15508_04_Final_JC_ePub.xhtml#_idTextAnchor072),
    *Learning Single-Page Application Concepts and How React Enables Them*, is ubiquitous
    in web development. It is a feature expected by users of web apps, so learning
    how to use it for our React app is a requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Routes in React Router are simply React Router components that contain our
    own application components, and these components in turn represent our screens.
    In other words, a route in React Router is a logical representation of a virtual
    location (by virtual location, I mean a URL that is just a label and does not
    actually exist on any server). The "routers" in React Router act as parent components
    and our screen rendering components act as children. This is a bit difficult to
    understand by simply reading about it, so let''s create an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new React project under the `Chap7` folder in your terminal by calling
    this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it has completed creating our project, `cd` into the new `try-react-outer`
    folder, then let''s add some packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s update our `index.tsx` file so that it includes the root React
    Router component in our app. Update `index.tsx` like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'So now, since this tool is giving us routing, we must set up our individual
    routes. However, since routes ultimately are just containers for components that
    represent our screens, let''s create two of those screens first. Create a file
    called `ScreenA.tsx` and add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: It's a simple component that displays **ScreenA** in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a file called `ScreenB.tsx` and add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Again, it is a simple component displaying **ScreenB** in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s give our routes a try. Open `App.tsx` and add this code into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 7.6 â€“ Routed to ScreenA'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.06_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 â€“ Routed to ScreenA
  prefs: []
  type: TYPE_NORMAL
- en: 'But if we were to go to route `"/b"`, we should see **ScreenB** instead, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 â€“ Routed to ScreenB'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.07_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 â€“ Routed to ScreenB
  prefs: []
  type: TYPE_NORMAL
- en: So, as I stated at the beginning of the section, React Router routes are React
    components. This may seem weird as they have no visible UI. Nevertheless, they
    are parent components, except they render their children but have no UI of their
    own.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we know that when our app first loads, it is the `index.tsx` file that
    runs before anything else. And this is also where the core React Router service
    lives. When this service encounters a URL, it looks through the set of routes
    defined in our `App.tsx` file and selects a matching route. Once the matching
    route is selected, that route's child component is rendered. So, for example,
    the route with `path="/b"` would render the `ScreenB` component.
  prefs: []
  type: TYPE_NORMAL
- en: Let's drill into the details of our routing code. If we look back at our routes,
    we should see that our first route has a property called `exact`. This tells React
    Router not to use regular expressions in determining a route match but instead
    to look for an exact match. Next, we see a property called `path`, which of course
    is supposed to be our URL path after the root domain. This path is by default
    a "contains" path, meaning that any URL that contains the same value as the `path`
    property will be accepted and the first matching route will be rendered, unless
    we included the `exact` property.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you will also notice that we have a property called `component`, which
    of course refers to the child component that is to be rendered. And for simple
    scenarios, using this property works fine. But what if we need to pass some additional
    props to our component? React Router provides another property called `render`,
    which allows us to use what's called a **render property**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `render` property is a property that takes a function as its parameter. When
    the parent component does its rendering, it will call the `render` function internally.
    Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new component called `ScreenC.tsx` and add this code in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `ScreenC` component is much like the other components. However, it also
    receives a prop called `message` and uses that as its display. Let's see how we
    pass this prop in via our `render` property of React Router.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s update our `App` component and add this new component as a route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add a new `Route` that uses the `render` property and pass it the
    `renderScreenC` function. If we go to the `"/c"` path, we see basically the same
    thing as the other screens, but with our message, **This is Screen C**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.8 â€“ Routed to ScreenC'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.08_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.8 â€“ Routed to ScreenC
  prefs: []
  type: TYPE_NORMAL
- en: But also, I've included a log of the props that are being passed into the component
    and we can see things such as `history`, `location`, and `match` members being
    included. You will recall our render function, `renderScreenC`, had a signature
    of `(props:any) => { â€¦ }`. That `props` parameter is being passed in by our `Route`
    component from the React Router service. We'll take a look at these routing properties
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now we know how to get better control of our screen component renders by
    using the `render` property, but a typical URL can also have parameters that pass
    data to the screen. Let''s look at how to do this with React Router:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our `Route` for `ScreenC` like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `userid` field is now a parameter on the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s update our `ScreenC` component to accept Route props and handle
    our new `userid` parameter field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 7.9 â€“ Routed to ScreenC with a parameter'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.09_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.9 â€“ Routed to ScreenC with a parameter
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our `userid` parameter of value **1** is shown.
  prefs: []
  type: TYPE_NORMAL
- en: OK, so now we've used React Router more realistically, but there's another important
    characteristic to note about how React Router works. React Router acts basically
    like a stack of URLs. In other words, when a user visits the URLs of a site, they
    do so in a linear fashion. They go to A, then B, and maybe back to A, then C,
    and so on. And the result of this is that the browser history of a user can be
    saved as a stack, where you can go forward to a new URL or backward to a previously
    visited one. This characteristic of browser behavior is mostly maintained in React
    Router's `history` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, again, let''s update our code and take a look at some of the capabilities
    provided by the `history` object:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `ScreenC` component like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use another function inside of the `history` object. Update `ScreenC`
    again, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You can see we have a button called `"/b"` route.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One more thing to review: React Router recently added the Hooks capability.
    So, we no longer have to pass down route properties using a child''s props; we
    can just use Hooks. Here''s what it looks like (i''ve kept the non-Hooks as comments
    for your convenience):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have our new `useHistory` and `useParams` Hooks imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we call our `useHistory` and `useParams` Hooks to get `history` and the
    `userid` URL parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: And here, we use the Hooks objects to display the same messages as before. It's
    quite easy and nice to use.
  prefs: []
  type: TYPE_NORMAL
- en: There are of course more capabilities of the `history` object and React Router
    overall, but this is a good introduction to those capabilities and we will use
    more of these features as we begin to build our app in the coming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Routing is a vital part of web development. Routes help users know where they
    are in the application and can provide a sense of context. Routing also helps
    us as developers structure the logical sections of our application and group relevant
    items together. React Router allows us to do all these things by providing many
    programmatic features that allow us to build sophisticated routing into our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered some of the most important React-related frameworks. Redux
    is a sophisticated tool for managing global application state. React Router provides
    client-side URL management that looks and feels like classic-style web URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Working with high-quality technologies such as Redux and React Router will help
    us to write better code. And this in turn will help us give our users the best
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: We have reached the end of *Part 2*, which focused on client-side technologies.
    We will now begin learning about server-side technologies in *Part 3*.
  prefs: []
  type: TYPE_NORMAL
