- en: '*Chapter 11*: E2E Tests in Angular with Cypress'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An app having a couple of **end-to-end** (**E2E**) tests surely promises more
    reliability than an app having no tests at all, and in today''s world, with emerging
    businesses and complex applications, it becomes essential at some point to have
    E2E tests written to capture the entire flow of an application. Cypress is one
    of the best tools out there today when it comes to E2E tests for web applications.
    In this chapter, you''ll learn how to test your E2E flows in an Angular app with
    Cypress. Here are the recipes we''re going to cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first Cypress test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating if a **Document Object Model** (**DOM**) element is visible on the
    view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing form inputs and submission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for **XMLHttpRequests** (**XHRs**) to finish
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Cypress bundled packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Cypress fixtures to provide mock data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the recipes in this chapter, make sure you have **Git** and **Node.js**
    installed on your machine. You also need to have the `@angular/cli` package installed,
    which you can do with `npm install -g @angular/cli` from your terminal. The code
    for this chapter can be found at [https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter11](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter11).
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first Cypress test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have been writing E2E tests already, you might have been doing this using
    Protractor. Working with Cypress is a completely different experience, though.
    In this recipe, you'll set up Cypress with an existing Angular application and
    will write your first E2E test with Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project that we are going to work with resides in `chapter11/start_here/angular-cypress-starter`,
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in **Visual Studio Code** (**VS Code**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have the project opened locally, let's see the steps of the recipe
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app we''re working with is a simple counter application. It has a minimum
    and maximum values and some buttons that can increment, decrement, and reset the
    counter''s value. We''ll start by configuring Cypress for our application and
    will then move toward writing the test:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open a new terminal window/tab and make sure you''re inside the `chapter11/start_here/angular-cypress-starter`
    folder. Once inside, run the following command to install `Cypress` and `concurrently`
    in our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open your `package.json` file and add the following script inside the
    `scripts` object, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the `cypress:test` command to simultaneously start the `http://localhost:4200`
    Angular server and to start Cypress tests as well, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You should also see that Cypress creates a folder named `cypress` and some example
    tests inside it by default. Cypress also creates a `cypress.json` file to be able
    to provide some configuration. We will not remove these default tests but will
    instead ignore them in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ignore the default/example tests by modifying the `cypress.json` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you look again at the Cypress window now, you should see that we don't have
    any integration tests, as follows:![Figure 11.1 – No integration tests to execute
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_11.1_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – No integration tests to execute
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our first test now. We''ll just check whether the browser title
    of our app is **Writing your first Cypress test**. Create a new file inside the
    `cypress/integration` folder named `app.spec.js`, and paste the following code
    inside:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you look again at the Cypress window, you should see a new `app.spec.js`
    file listed, as follows:![Figure 11.2 – The new app.spec.js test file being shown
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_11.2_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – The new app.spec.js test file being shown
  prefs: []
  type: TYPE_NORMAL
- en: Tap the `app.spec.js` file in the window shown in *Figure 11.2*, and you should
    see the Cypress tests passing for the tests written in the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Kaboom! Within a few steps, we have now set up Cypress for our Angular application
    and have written our first test. You should see the Cypress window, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Our first Cypress test passes'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.3_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.3 – Our first Cypress test passes
  prefs: []
  type: TYPE_NORMAL
- en: Easy! Right? Now that you know how to configure Cypress for an Angular app,
    see the next section to understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cypress can be integrated with absolutely any framework and web development
    project. One interesting fact is that Cypress uses Mocha as the test runner behind
    the scenes. The tooling for Cypress watches for code changes so that you don't
    have to recompile the tests time and time again. Cypress also adds a shell around
    the application being tested to capture logs and access DOM elements during the
    tests, and some functionality for debugging tests.
  prefs: []
  type: TYPE_NORMAL
- en: At the very top of our `app.spec.js` file, we use the `context()` method that
    defines the test suite, basically defining the context of the tests about to be
    written inside. Then, we use a `beforeEach()` method to specify what should happen
    before each test is executed. Since each test starts with no data, we first have
    to make sure that Cypress navigates to our application's `http://localhost:4200`
    **Uniform Resource Locator** (**URL**). The reason we just specify `cy.visit('/')`
    and it still works is that we have already specified the `baseUrl` property in
    the `cypress.json` file. Therefore, we just have to provide relative URLs in our
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use the `it()` method to specify the titles for our first test,
    and then we use the `cy.title()` method, which is a handy helper, to fetch the
    text value of the **Title** of our **HyperText Markup Language** (**HTML**) page
    currently being rendered. We use the `'eq'` operator to check its value against
    the `'Writing your first Cypress test'` string, and it all works!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`cy.title()` documentation ([https://docs.cypress.io/api/commands/title.html#Syntax](https://docs.cypress.io/api/commands/title.html#Syntax))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cypress documentation—*Writing Your First Test* ([https://docs.cypress.io/guides/getting-started/writing-your-first-test.html](https://docs.cypress.io/guides/getting-started/writing-your-first-test.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating if a DOM element is visible on the view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned how to install and configure Cypress in an
    Angular app. There might be different cases in your application where you'd want
    to see if an element is visible on the DOM or not. In this recipe, we'll write
    some tests to identify if any elements are visible on the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project for this recipe resides `in chapter11/start_here/cypress-dom-element-visibility`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `npm run cypress:test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should run the app at `https://localhost:4200` and should open the Cypress
    window, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Cypress tests running for the cypress-dom-element-visibility
    app'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.4_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.4 – Cypress tests running for the cypress-dom-element-visibility app
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app and the Cypress tests running locally, let's see the
    steps of the recipe in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have the same old counter app from the previous recipe. However, some things
    have changed. We now have a button at the top that toggles the visibility of the
    the counter component `(CounterComponent)`. Also, we have to hover over the counter
    card to actually see the **Increment**, **Decrement**, and **Reset** action buttons.
    Let''s start writing some tests to check the visibility of the the counter component
    `(CounterComponent)` and for the actions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a test to check the visibility of the the counter component `(CounterComponent)`
    when we have clicked the **Toggle Counter Visibility** button to show it. We''ll
    check it by asserting the visibility of the elements having `.counter__heading`
    and `.counter` classes. Update the `cypress/integration/app.spec.js` file, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll write a test to check if our action buttons (**Increment**, **Decrement**,
    and **Reset**) show up when we hover over the `counter` component. Update the
    `app.spec.js` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the Cypress window now, you should see the test failing, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Unable to get action buttons on hovering'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.5_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.5 – Unable to get action buttons on hovering
  prefs: []
  type: TYPE_NORMAL
- en: The reason for the test's failure is that Cypress doesn't currently provide
    a **Cascading Style Sheets** (**CSS**) hover effect. In order to work around this,
    we'll install a package in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop the running Cypress and Angular app and then install the `cypress-real-events`
    package, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the `cypress/support/index.js` file and update it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, update the `app.spec.js` file to use the `.realHover()` method from the
    package on the `.counter` element, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the `cypress:test` command again using `npm run cypress:test`. Once
    the app is running and the Cypress window is opened, you should see all the tests
    passing, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.6 – All tests passing after using the cypress-real-events package'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.6_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.6 – All tests passing after using the cypress-real-events package
  prefs: []
  type: TYPE_NORMAL
- en: Awesomesauce! You've just learned how to check the visibility of DOM elements
    in different scenarios. These are, of course, not the only options available to
    identify and interact with DOM elements. Now that you've finished the recipe,
    see the next section to understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the beginning of the recipe, in our first test we use the `.should('have.length',
    0)` assertion. When we use the `'have.length'` assertion, Cypress checks the `length`
    property of the DOM elements found using the `cy.get()` method. Another assertion
    that we use is `.should('be.visible')`, which checks if an element is visible
    on the DOM. This assertion will pass as long as the element is visible on the
    screen—that is, none of the parent elements are hidden.
  prefs: []
  type: TYPE_NORMAL
- en: In the later test, we try to hover over the element with the `'.counter'` selector,
    using `cy.get('.counter').trigger('mouseover');`. This fails our test. Why? Because
    all the hover workarounds in Cypress eventually lead to triggering the JavaScript
    events and not affecting the CSS pseudo selectors, and since we have our action
    buttons (with the `'.counter__actions__action'` selector) shown on the `:hover`
    (CSS) of the element with the `'.counter'` selector, our tests fail because in
    the tests our action buttons are not actually shown. To tackle the issue, we use
    the `cypress-real-events` package, which has the `.realHover()` method that affects
    the pseudo selectors and eventually shows our action buttons.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cypress official documentation on the visibility of items ([https://docs.cypress.io/guides/core-concepts/interacting-with-elements.html#Visibility](https://docs.cypress.io/guides/core-concepts/interacting-with-elements.html#Visibility))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cypress-real-events` project repository ([https://github.com/dmtrKovalenko/cypress-real-events](https://github.com/dmtrKovalenko/cypress-real-events))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing form inputs and submission
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're building a web app, there's a high chance that you're going to have
    at least one form in it, and when it comes to forms we need to make sure that
    we have the right **user experience** (**UX**) and the right business logic in
    place. What better way to make sure everything works as expected than writing
    E2E tests for them? In this recipe, we're going to test a login form using Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project for this recipe resides in `chapter11/start_here/cy-testing-forms`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `npm run cypress:test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open a new Cypress window. Tap the `app.spec.ts` file and you should
    see the tests, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Cypress tests running for the app cy-testing-forms'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.7_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.7 – Cypress tests running for the app cy-testing-forms
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the Cypress tests running, let's see the steps of the recipe
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have to make sure that we see a **Success** alert when the form is successfully
    submitted. We also need to make sure that we see relevant errors if any of the
    inputs have an invalid value. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a new file inside the `cypress/integration` folder, named `login.spec.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll first make sure that our form cannot be submitted unless we have valid
    form inputs. To do that, let''s make sure that the **Submit** button is disabled
    when there are either no input values or invalid values. Open the `login.spec.js`
    file and add a test, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the `login.spec.js` file in the Cypress window and you should see
    the tests passing, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – Checking if the Submit button is disabled when there is invalid
    input'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.8_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.8 – Checking if the Submit button is disabled when there is invalid
    input
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add another test that validates that we see a success alert on submitting
    the right values for the inputs. Add another test in the `login.spec.js` file,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll add another test now to make sure the success alert hides on tapping
    the **Close** button. Since we''re using the same logic/code for the successful
    login, we''ll create a function to reuse it. Let''s modify the `login.spec.js`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The success alert should also hide when the input changes. To check that as
    well, let''s add another test, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s write a test to make sure we show error messages on invalid
    inputs. Add another test in the `logic.spec.js` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the **Tests** window now, you should see all the tests passing,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – All tests passing for the Login page'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.9_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.9 – All tests passing for the Login page
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! You now know how to use Cypress to test forms with some interesting
    use cases and assertions. See the next section to understand how it all works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since our app''s logic has a rule that the **Submit** button should be disabled
    until both the email and password inputs have valid values, we check if the button
    is disabled in our tests. We do this by using the `''be.disabled''` assertion
    on the **Submit** button, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We then use`.type()` method chaining on the `cy.get()` selector to type in both
    inputs one by one, and check if the button is disabled either when we have an
    invalid value for any input or no value entered at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform a successful login, we execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we get each input and type valid values in them, and then we call
    the `.click()` method on the **Submit** button. We then check if the success alert
    exists using the `'.alert.alert-success'` selector and the `should('be.visible')`
    assertion.
  prefs: []
  type: TYPE_NORMAL
- en: 'In cases where we want to check that the success alert has been dismissed on
    clicking the **Close** button on the alert or when any of the inputs change, we
    can''t just use the `should(''not.be.visible'')` assertion. This is because Cypress
    in this case would expect the alert to be in the DOM but just not be visible,
    whereas in our case (in our Angular app), the element doesn''t even exist in the
    DOM, so Cypress fails to get it. Therefore, we use the following code to check
    that the success alert doesn''t even exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'One final interesting thing is when we want to check if error messages for
    each input show when we type something in either of the inputs and clear the input.
    In this case, we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The reason we use the `.blur()` method is because when Cypress just clears the
    input the Angular change detection doesn't take place, which results in the error
    messages not showing on the view immediately. Since Angular's change detection
    does monkey-patching on the browser events, we trigger a `.blur()` event on both
    the inputs to trigger the change detection mechanism. As a result, our error messages
    show properly.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cypress recipes: Form interactions ([https://github.com/cypress-io/cypress-example-recipes/tree/master/examples/testing-dom__form-interactions](https://github.com/cypress-io/cypress-example-recipes/tree/master/examples/testing-dom__form-interactions))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cypress recipes: Login form ([https://github.com/cypress-io/cypress-example-recipes/tree/master/examples/logging-in__html-web-forms](https://github.com/cypress-io/cypress-example-recipes/tree/master/examples/logging-in__html-web-forms))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for XHRs to finish
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing **user interface** (**UI**) transitions is the essence of E2E testing.
    While it is important to test the predicted outcome of an action right away, there
    might be cases where the outcome actually has a dependency. For instance, if a
    user fills out the **Login** form, we can't show the success toast until we have
    a successful response from the backend server, hence we can't test whether the
    success toast is shown right away. In this recipe, you're going to learn how to
    wait for a specific XHR call to be completed before performing an assertion.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The project for this recipe resides in `chapter11/start_here/waiting-for-xhr`.
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `npm run cypress:test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open a new Cypress window. Tap the `user.spec.ts` file and you
    should see the tests, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10 – Cypress tests running for the waiting-for-xhr app'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.10_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.10 – Cypress tests running for the waiting-for-xhr app
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the Cypress tests running, let's see the steps of the recipe
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the tests right now work fine, even though we have XHR calls involved in
    getting the data. So, what is this recipe about exactly? Well, Cypress has a timeout
    of 4,000 **milliseconds** (**ms**) (4 seconds), during which it tries the assertion
    again and again until the assertion passes. What if our XHR takes more than 4,000
    ms? Let''s try it out in the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to simulate the scenario where the desired result occurs
    after 4,000 ms. We''ll use the `debounceTime` operator from `rxjs` for this, with
    a delay of 5,000 ms. Let''s apply it on the `valueChanges` Observable of the `searchForm`
    property in the `users.component.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now check the Cypress tests, you should see a test failing, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11 – Assertion failing for the test for searching a particular
    user'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.11_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.11 – Assertion failing for the test for searching a particular user
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now try to fix this, so it doesn''t matter how long the XHR takes—we''ll
    always wait for it to be completed before doing an assertion. Let''s intercept
    the XHR call and create an alias for it so that we can use it later to wait for
    the XHR call. Update the `users.spec.js` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s use the alias to wait for the XHR call to complete before the assertion.
    Update the `users.spec.js` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you check the Cypress tests now for `user.spec.js`, you should see all of
    them pass, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12 – Test waiting for the XHR call to be completed before the assertion'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.12_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.12 – Test waiting for the XHR call to be completed before the assertion
  prefs: []
  type: TYPE_NORMAL
- en: Great!! You now know how to implement E2E tests with Cypress that include waiting
    for a particular XHR call to finish before an assertion. To understand all the
    magic behind the recipe, see the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the recipe, we use something called variable aliasing. We first use the `cy.intercept()`
    method so that Cypress can listen to the network call. Note that we use a wildcard
    for the URL by using `https://api.randomuser.me/*` as the parameter, and then
    we use a `.as('searchUsers')` statement to give an alias for this interception.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we use the `cy.wait('@searchUsers');` statement, using the `searchUsers`
    alias to inform Cypress that it has to wait until the aliased interception happens—that
    is, until the network call is made, regardless of how long it takes. This makes
    our tests pass, even though the regular 4,000 ms Cypress timeout has already passed
    before actually getting the network call. Magic, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Well, I hope you liked this recipe—see the next section to view a link for further
    reading.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Waiting in Cypress ([https://docs.cypress.io/guides/guides/network-requests#Waiting](https://docs.cypress.io/guides/guides/network-requests#Waiting))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Cypress bundled packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cypress provides a bunch of bundled tools and packages that we can use in our
    tests to make things easier, not because writing tests with Cypress is otherwise
    hard, but because these libraries are used by many developers already and so they're
    familiar with them. In this recipe, we're going to look at the bundled `jQuery,
    Lodash, and Minimatch` libraries to test some of our use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project that we are going to work with resides in `chapter11/start_here/using-cypress-bundled-packages`,
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `npm run cypress:test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open a new Cypress window. Tap the `users.spec.ts` file and you
    should see the tests, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13 – using-cypress-bundled-packages tests running with Cypress'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.13_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.13 – using-cypress-bundled-packages tests running with Cypress
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the Cypress tests running, let's see the steps of the recipe
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we have the `users` list and a search app that fetches some
    users from an **application programming interface** (**API**) endpoint. We''re
    going to assert a few conditions for the DOM, validate the response from the API,
    and will assert the URL changes as well. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we''ll try out the bundled `jQuery` library along with Cypress.
    We can access this using `Cypress.$`. Let''s add another test and log out some
    DOM elements. Update the `users.spec.js` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the tests now and specifically the console, you should see the
    log, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14 – Search button logged using jQuery via Cypress.$'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.14_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.14 – Search button logged using jQuery via Cypress.$
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to log the user cards that we see after the HTTP call. Add
    another query and log in to the same test, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you see the test and the logs again on the console in the Cypress window,
    you will see that the `Cypress.$('app-user-card')` query doesn't return any DOM
    elements. This is because when the query is run, the HTTP call isn't completed.
    So, should we wait for the HTTP call to finish? Let's try that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a `cy.wait(5000)` to wait for 5 seconds, during which the HTTP call
    should have been completed, and let''s put an assertion with the `cy.wrap()` method
    as well to check that the **Search** button is disabled when there''s no value
    provided for the search input. Update the test, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you see the Cypress test and the console, you will see that we still get
    no DOM elements for the `<app-user-card>` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.15 – No user cards found using Cypress.$ even after using cy.wait
    (5000)'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.15_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.15 – No user cards found using Cypress.$ even after using cy.wait
    (5000)
  prefs: []
  type: TYPE_NORMAL
- en: We'll discuss in the *How it works…* section why this happens. For now, understand
    that you should only use `Cypress.$` for elements that are present in the DOM
    right from when the page is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s clean up our test by removing the `cy.wait()` method and the console
    logs. It should then look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll now add a test to verify that we get the same users from the Random
    User API for the same seed string. We already have the `API_USERS.js` file that
    contains the expected result. Let''s use the bundled `lodash` library in our next
    test to assert the matching values for the first name, the last name, and the
    email of the returned users, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you see the test now in Cypress, it should be passing, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.16 – Test passing with the usage of lodash via Cypress'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.16_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.16 – Test passing with the usage of lodash via Cypress
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re now going to use the `moment.js` package that is bundled with Cypress
    as well. Let''s assert that the user cards show the formatted date correctly,
    using `moment.js`. Write another test in the `users.spec.js` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The next package we''ll explore is the `minimatch` package. When we tap on
    a user card, it opens the user details. Since we append a timestamp to the URL
    as a query parameter, we can''t compare the URL as an exact match with our assertion.
    Let''s use the `minimatch` package to assert using a pattern instead. Add a new
    test, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: And boom! We now have all the tests passing using the bundled packages with
    Cypress. Now that we've finished the recipe, let's see in the next section how
    it all works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cypress bundles `jQuery` with it and we use it via the `Cypress.$` property.
    This allows us to perform everything that the `jQuery` function permits us to.
    It automatically checks which page is in the view using the `cy.visit()` method,
    and then queries the document using the provided selector.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '`Cypress.$` can only fetch from the document elements that are available immediately
    on the DOM. This is great for debugging the DOM using the Chrome DevTools in the
    Cypress test window. However, it is important to understand that it doesn''t have
    any context about the Angular change detection. Also, you can''t query any element
    that isn''t visible on the page right from the beginning, as we experienced following
    the recipe—that is, it doesn''t respect waiting for XHR calls for the elements
    to be visible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cypress also bundles `lodash` and exposes it via the `Cypress._` object. In
    the recipe, we use the `_.get()` method to get the nested properties from the
    `user` object. The `_.get()` method takes two parameters: the object, and a string
    that reflects the path for the properties—for example, we use `_.get(response,
    ''body.results'');`, which essentially returns a value for `response.body.results`.
    We also use the `_.each()` method to iterate over the arrays in the recipe. Note
    that we can use any `lodash` method in our Cypress test and not just the aforementioned
    methods.'
  prefs: []
  type: TYPE_NORMAL
- en: We also used the `minimatch` package, which Cypress exposes via the `Cypress.minimatch`
    object. The `minimatch` package is great for matching and testing glob patterns
    against strings. We use it to test the URL after navigating to a user's detail
    page using a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we also use the `moment.js` package that Cypress exposes via the `Cypress.moment`
    object. We use it to make sure the date of birth of each user is shown in the
    expected format on the view. Easy peasy.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cypress bundled tools ([https://docs.cypress.io/guides/references/bundled-tools](https://docs.cypress.io/guides/references/bundled-tools))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moment.js ([https://momentjs.com/](https://momentjs.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jQuery ([https://jquery.com/](https://jquery.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: lodash ([https://lodash.com](https://lodash.com))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimatch.js ([https://github.com/isaacs/minimatch](https://github.com/isaacs/minimatch))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Cypress fixtures to provide mock data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to writing E2E tests, fixtures play a great role in making sure
    the tests are not flaky. Consider that your tests rely on fetching data from your
    API server or your tests include snapshot testing, which includes fetching images
    from a **content delivery network** (**CDN**) or a third-party API. Although they're
    technically required for the tests to run successfully, it is not important that
    the server data and the images are fetched from the original source, therefore
    we can create fixtures for them. In this recipe, we'll create fixtures for the
    users' data as well as for the images to be shown on the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project that we are going to work with resides in `chapter11/start_here/using-cypress-fixtures`,
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `npm run cypress:test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open a new Cypress window. Tap the `users.spec.ts` file and you
    should see the tests, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.17 – using-cypress-fixtures tests running with Cypress'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.17_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.17 – using-cypress-fixtures tests running with Cypress
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the Cypress tests running, let's see the steps of the recipe
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have the same Angular application as in the previous recipe. However, we''ll
    now use Cypress fixtures to provide fixtures for our data and images. Let''s get
    started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll first create a fixture for our HTTP call to the `randomuser.me` API.
    Create a new file under the `cypress/fixtures` folder, named `users.json`. Then,
    copy the code from the c`hapter11/final/using-cypress-fixtures/cypress/fixtures/users.json`
    file and paste it into the newly created file. It should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s use the fixture in our `users.spec.js` file. We''ll use it in the
    `beforeEach()` life cycle hook since we want to use the fixture for all the tests
    in the file. This means we''ll also remove the existing usage of the `cy.intercept()`
    method in the file. Update the `users.spec.js` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We now need to remove the `constants/API_USERS.js` file from the project since
    we have the fixture now.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a new variable in which we''ll store the value of the `users`
    array and will use it instead of the `API_USERS` array. Let''s modify the `users.spec.js`
    file further, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll notice that all of our tests are still passing with the changes done.
    You can safely remove the `constants/API_USERS.js` file from the project now.
    Also, you can see the network calls in the Cypress **Tests** window to verify
    that we''re using the fixture instead of the actual API response, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.18 – Cypress tests using users.json fixture as XHR response'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.18_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.18 – Cypress tests using users.json fixture as XHR response
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to mock our images to load them from the disk instead of the
    `randomuser.me` API. For this, we already have the images stored in the `fixtures/images`
    folder. We just need to use them based on the URL for a particular user. To do
    so, modify the `users.spec.js` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you see the tests now, all of them should still be passing, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.19 – All tests passing after using images fixtures'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.19_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.19 – All tests passing after using images fixtures
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the tests, you might be thinking: "*It all seems exactly as before,
    Ahsan. How do I know we''re mocking the images?*" Well, good question. We already
    have a way to test that.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `cypress/fixtures/images` folder, we have a file named `9.jpg`, and
    another test file named `9_test.jpg`. Let''s modify the name of the `9.jpg` file
    to `9_original.jpg` and the `9_test.jpg` file to `9.jpg`. If you see the tests
    now, you should see a different result for the last test using the replaced file,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.20 – Cypress tests using images from the fixture'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.20_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.20 – Cypress tests using images from the fixture
  prefs: []
  type: TYPE_NORMAL
- en: Great!!! You now know how to use fixtures in Cypress E2E tests. Now that you've
    finished the recipe, see the next section on how this works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use fixtures in a Cypress test using the `cy.fixture()` method, which allows
    us to use data from a file. In this recipe, we use fixtures for the HTTP call
    that gets the user data and for the images. But how does it work? Essentially,
    the `fixture` method has four overloads, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `filePath` parameter takes a string as the file path relative to the `Fixture`
    folder, which defaults to the `cypress/fixture` path, although we can provide
    a different `Fixture` folder by defining a `fixturesFolder` property in the `cypress.json`
    configuration file. Notice that for the HTTP call, we use the `cy.fixture('users.json')`
    statement, which essentially points to the `cypress/fixture/users.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we use the `cy.fixture('users.json')` method before the `cy.visit()`
    method to ensure that our immediate XHR call that triggers on launching the application
    uses the fixture. If you change the code otherwise, you'll see that it doesn't
    work as expected. We then use the `.then()` method to get hold of the data from
    the `users.json` file. Once we get the data (`response`) object, we use the `cy.intercept()`
    method using a Minimatch glob pattern to intercept the HTTP call to get the users'
    data, and we provide this `response` object from the fixture as the response for
    the HTTP call. As a result, all the calls made to the endpoint matching the `'`[https://api.randomuser.me/](https://api.randomuser.me/)*`'`
    glob use our fixture—that is, the `users.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: We also do one more interesting thing in the recipe, and that is mocking the
    images to avoid fetching them from their original source. This is super-handy
    when you use a third-party API and you have to pay for each call made to the API.
    We already have the fixture images stored in the `cypress/fixture/images` folder.
    Therefore, we loop over the `API_USERS` array for each user and extract the filename
    (the `imageName` variable). We then intercept each HTTP call done to fetch the
    images and use the fixture image instead of the original resource in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cypress fixtures documentation ([https://docs.cypress.io/api/commands/fixture](https://docs.cypress.io/api/commands/fixture))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cy.intercept()` method documentation ([https://docs.cypress.io/api/commands/intercept](https://docs.cypress.io/api/commands/intercept))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
