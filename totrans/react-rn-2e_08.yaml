- en: Extending Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll learn how to add new capabilities to existing components
    by extending them. There are two React mechanisms that you can use to extend a
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: Component inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition with higher-order components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll start by learning about basic component inheritance, just like object-oriented
    class inheritance. Then you'll implement some higher-order components used to
    compose React components.
  prefs: []
  type: TYPE_NORMAL
- en: Component inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components are just classes. In fact, when you implement a component using **ES2015**
    class syntax, you extend the base `Component` class from React. You can keep on
    extending your classes like this to create your own base components.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you'll see how your components can inherit state, properties,
    and just about anything else, including JSX markup and event handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you have several React components that use the same initial state.
    You can implement a base component that sets this initial state. Then, any components
    that want to use this as their initial state can extend this component. Let''s
    implement a base component that sets some basic state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The state is an immutable `Map`. This base component also implements immutable
    data setter and getter methods. Let''s implement a component that extends this
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This component doesn''t actually have to set any initial state because it''s
    already set by `BaseComponent`. Since the state is already an immutable `Map`,
    you can tweak the initial state in `componentDidMount()` using `merge()`. Here''s
    what the rendered output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e02cbf22-0356-4bdc-9423-4f51752db9b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you delete the default text in the input element, you can see that the placeholder
    text added by `MyComponent` to the initial state is applied as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/fbbf16b0-ddb6-4f53-bd48-c3de4f29d678.png)'
  prefs: []
  type: TYPE_IMG
- en: You can also change the text to something else and the `onChange()` event handler
    will set the `name` state accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inheriting properties works by defining the default property values and the
    property types as static attributes of a base class. Any classes that inherit
    from this base class also inherit the property values and the property specs.
    Let''s take a look at a base class implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The class itself doesn't actually do anything. The only reason to define it
    is so that there's a place to declare the default property values and their type
    constraints. Respectively, these are the `defaultProps` and the `propTypes` static
    class attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at a component that inherits these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try rendering `MyComponent` to make sure that the inherited properties
    are working as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Despite the fact that `MyComponent` doesn't define any property defaults or
    types, you get the expected behavior. When you try to pass numbers to the `users`
    and `groups` properties, you don't see anything rendered. That's because `MyComponent`
    is expecting a `map()` method on these property values, and there isn't one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ErrorBoundary` elements are used here to isolate errors. Without them,
    any of the `MyComponent` elements failing would cause other components on the
    page to fail as well, for example, by passing number values to users and groups.
    Here''s what the `ErrorBoundary` component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This component uses the `componentDidCatch()` lifecycle method that you learned
    about in [Chapter 6](01d31b70-53c0-4d08-9bf7-93d0b513bced.xhtml), *The React Component
    Lifecycle*. If it catches an error, it sets the error state so that the `render()`
    method knows to not render the component that caused the error again. Here''s
    what the rendered content looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/befae03e-b792-4887-8ac2-7a4d4f504e0c.png)'
  prefs: []
  type: TYPE_IMG
- en: Inheriting JSX and event handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll learn about inheriting JSX and event handlers. You might
    want to use this approach if you have a single UI component that has the same
    UI elements and event handling logic, but there are differences in what the initial
    state should be, depending on where the component is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a base class would define the JSX and event handler methods, while
    the more specific components define the initial state that''s unique to the feature.
    Here''s an example base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This base component renders a list of items that, when clicked, toggles the
    style of the item text. By default, the state of this component has an empty item
    list. This means that it is safe to render this component without setting the
    component state. However, that''s not very useful, so let''s give this list some
    items by inheriting the base component and setting the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `componentDidMount()` lifecycle method can safely set the state of the component.
    The base component uses your `data` setter/getter to change the state of the component.
    Another thing that's handy about this approach is that if you want to override
    one of the event handlers of the base component, you can define the method in
    `MyComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the list looks like when rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3a20f49c-5d9d-441f-8cb3-0e358c5947fc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And here''s what the list looks like when all of the items have been clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/99c1b546-33c7-422f-8203-570bef2b79a7.png)'
  prefs: []
  type: TYPE_IMG
- en: Composition with higher-order components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll learn about **higher-order components**. If you're familiar
    with higher-order functions in functional programming, higher-order components
    work the same way. A **higher-order function** is a function that takes another
    function as input, and returns a new function as output. This returned function
    calls the original function in some way. The idea is to compose new behavior out
    of existing behavior.
  prefs: []
  type: TYPE_NORMAL
- en: With higher-order React components, you have a function that takes a component
    as input, and returns a new component as output. This is the preferred way to
    compose new behavior in React applications, and it seems that many of the popular
    React libraries are moving in this direction, if they haven't already. You get
    more flexibility when composing functionality this way.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional component rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One use case for a higher-order component is conditional rendering. For example,
    depending on the outcome of a predicate, the component is rendered or nothing
    is rendered. The predicate could be anything that's specific to the application,
    such as permissions or something like that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you have the following component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, to control the display of this component, you can wrap it with another
    component. Wrapping is handled by the higher-order function.
  prefs: []
  type: TYPE_NORMAL
- en: If you hear the term "wrapper" in the context of React, it's probably referring
    to a higher-order component. Essentially, this is what it does; it wraps the component
    that you pass to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a higher-order React component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The two arguments to this function are `Component`, which is the component that
    you're wrapping, and the `predicate` to call. If the call to `predicate()` returns
    `true`, then `<Component>` is returned. Otherwise, nothing will be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s actually compose a new component using this function, and your
    component that renders a paragraph of text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ve just created two new components using `MyComponent`, `cond()`, and
    a `predicate` function. Here''s the rendered output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5314290f-2c48-46df-b1b7-9a790269eb3b.png)'
  prefs: []
  type: TYPE_IMG
- en: Providing data sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s finish the chapter by looking at a more involved higher-order component
    example. You''ll implement a data store function that wraps a given component
    with a data source. This type of pattern is handy to know, because it''s used
    by React libraries such as **Redux**. Here''s the `connect()` function that''s
    used to wrap components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This module defines two internal immutable objects: `components` and `store`.
    The `components` list holds references to components that are listening to `store`
    changes. The `store` represents the entire application state.'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a store stems from **Flux**, a set of architectural patterns
    used to build large-scale React applications. I'll touch on Flux ideas throughout
    this book, but Flux goes way beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The important pieces of this module are the exported functions: `setState()`,
    `getState()`, and `connect()`. The `getState()` function simply returns a reference
    to the data store. The `setState()` function sets the state of the store, and then
    notifies all components that the state of the application has changed. The `connect()`
    function is the higher-order function that wraps the given component with a new
    one. When the component is mounted, it registers itself with the store so that
    it will receive updates when the store changes state. It renders the composed
    component by passing the `store` as properties.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use this utility to build a simple filter and list. First, the
    list component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two pieces of state that are passed to this component as properties.
    The first is the `filterValue` string that comes from the filter text input. The
    second is the `items` array of values to filter. It is filtered by constructing
    a case-insensitive regular expression and using it with `test()` inside `filter()`.
    Then, only items that match the `filterValue` are part of the JSX output of this
    component. Next, let''s look at `MyInput`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `MyInput` component renders an `<input>` element. The goal of the `onChange()`
    handler is to filter the user list so that only items that contain the current
    input text are displayed. It does this by setting the `filterValue` state whenever
    the text input changes. This will cause the `MyList` component to re-render with
    the new filter value to filter items with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the rendered filter input and item list looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5484c7d4-8726-42cf-9e9c-25bae93d685e.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the different ways to extend existing components.
    The first mechanism you learned about was inheritance. This is done using ES2015
    class syntax and is useful for implementing common methods or JSX markup.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you learned about higher-order components, where you use a function to
    wrap one component with another to provide it with new capabilities. This is the
    direction that new React applications are moving in, instead of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn how to render components based on the current
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When should you inherit component state?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should never inherit component state
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only when you have many different components that all share the same state structure,
    but render different output
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only when you want to share state between two or more components
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a higher-order component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A component rendered by another component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another name for a functional component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A component that returns another component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you inherit JSX from a component, what should you override?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Nothing. You're only inheriting to provide a new name for the component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should only override the state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can pass new state values to the inherited component in **`componentDidMount()`.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://reactjs.org/docs/components-and-props.html](https://reactjs.org/docs/components-and-props.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
