- en: Chapter 12. Refining Your Flux Apps with Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding chapter walked you through the implementation of a full-fledged
    React application built on top of a Flux architecture. In this chapter, you''ll
    make some modifications to this app so that it uses the Redux library to implement
    the Flux architecture. Here''s how this chapter is organized:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief overview of Redux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing reducer functions that control state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Redux action creators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting components to Redux stores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Redux entry point into your application's state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Redux?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get started with refactoring your application, we'll spend a couple
    of minutes looking at Redux at a high level. Just enough to whet your appetite.
    Ready?
  prefs: []
  type: TYPE_NORMAL
- en: One store to rule them all
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first major difference between traditional Flux applications and Redux is
    that, with Redux, you only have one store. A traditional Flux architecture might
    only call for one store as well, but it might have several of them. You would
    think that having multiple stores could actually simplify the architecture since
    you could separate states by different sections of the application. Indeed, this
    is a good tactic, but it doesn't necessarily hold up in practice. Creating more
    than one store can lead to confusion. Stores are moving parts in your architecture;
    if you have more of them, there's more potential for something to go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Redux removes this factor by allowing only one store. You might think that this
    would lead to a monolithic data structure that's difficult for various application
    features to use. This isn't the case, because you're free to structure your store
    any way you please.
  prefs: []
  type: TYPE_NORMAL
- en: Fewer moving parts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By only allowing one store, Redux takes moving parts out of the picture. Another
    place where Redux simplifies your architecture is in removing the need for a dedicated
    dispatcher. In traditional Flux architectures, the dispatcher is a distinct component
    that sends messages to stores. Since there's only one store in Redux architectures,
    you can just dispatch actions directly to the store. In other words, the store
    is the dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: The final place that Redux reduces the number of moving parts in your code is
    in event listeners. In traditional Flux applications, you have to manually subscribe
    and unsubscribe from store events in order to wire everything up correctly. This
    is a distraction when you can have a library handle the wiring work for you. This
    is something that Redux does well.
  prefs: []
  type: TYPE_NORMAL
- en: Uses the best parts of Flux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Redux is not Flux, in the traditional sense. Flux has a specification and a
    library that implements it. Redux is not this. As mentioned in the preceding section,
    Redux is a simplification of Flux. It keeps all of the Flux concepts that lead
    to sound application architectures while ignoring the tedious bits that can make
    Flux difficult to implement and ultimately difficult to adopt.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling state with reducers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The flagship concept of Redux is that, state is controlled by reducer functions.
    In this section, we'll get you caught up on what reducers are, followed by the
    implementation of reducer functions in your Snapterest app.
  prefs: []
  type: TYPE_NORMAL
- en: What are reducers?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reducers are functions that take a data collection, such as an object or an
    array, and return a new collection. The returned collection can have the same
    data in it, or it can have completely different data than the initial collection.
    In Redux applications, reducer functions take a slice of state, and return a new
    slice of state. That's it! You've just learned the crux of the Redux architecture.
    Now let's see reducer functions in action.
  prefs: []
  type: TYPE_NORMAL
- en: Reducer functions in Redux applications can be separated into modules that represent
    the part of the application state they work with. We'll look at the collection
    reducers, followed by the tweet reducers of the Snapterest app.
  prefs: []
  type: TYPE_NORMAL
- en: Collection reducers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s walk through the collection reducer function that changes part of
    the application state. First, let''s take a look at the function in its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the new state that's returned is based on the action that was
    dispatched. The action name is supplied to this function as an argument. Now let's
    walk through the different scenarios of this reducer.
  prefs: []
  type: TYPE_NORMAL
- en: Adding tweets to collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `add_tweet_to_collection` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `switch` statement detects that `action type` is `add_tweet_to_collection`.
    The action also has a `tweet` property that contains the actual tweet to add.
    The `tweet` variable is used here to build an object with the `tweet` ID as the
    key, and `tweet` as the value. This is the format that the `collectionTweets`
    object is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: Then we return the new state. It's important to remember that this should always
    be a new object, not a reference to some other object. This is how you avoid unintended
    side-effects in Redux applications. Thankfully, we can use the object spread operator
    to simplify this task.
  prefs: []
  type: TYPE_NORMAL
- en: Removing tweets from collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Removing a tweet from the `collectionTweets` object means that we have to delete
    the key which has the `tweet` ID to be deleted. Let''s see how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we're assigning a new object to the `collectionTweets` variable?
    Once again, the spread operator comes in handy here to avoid extra syntax. The
    reason we're doing it this way is so that the reducer always returns a new reference.
    Once we delete the tweet from our `collectionTweets` object, we can return the
    new state object that includes `collectionTweets` as a property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other tweet removal action is `remove_all_tweets_from_collection`. Here''s
    what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Removing all tweets means that we can just replace the `collectionTweets` value
    with a new empty object.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the collection name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a collection of tweets is renamed, we have to update the Redux store.
    This is done by getting `editingName` from the state when the `set_collection_name`
    action is dispatched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the `collectionName` value is set to `editingName`, and `isEditingName`
    is set to `false`. This is meant to indicate that since the value has been set,
    we know that the user is no longer editing the name.
  prefs: []
  type: TYPE_NORMAL
- en: Editing collection names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You just saw how to set the collection name once the user saves their changes.
    However, there''s more to editing text when it comes to tracking state in Redux
    stores. First, we have to enable the text to be edited in the first place; this
    gives the user some sort of visual cue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, there''s the text that the user is actively typing in the text input.
    This has to go somewhere in the store too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Not only will this cause the appropriate React components to re-render, but
    it also means that we have the text stored in the state, ready to go when the
    user is finished editing.
  prefs: []
  type: TYPE_NORMAL
- en: Tweet reducers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is only one action that the tweet reducer needs to handle, but this doesn't
    mean that we shouldn't have the tweet reducer in its own module in anticipation
    of future actions for tweets. For now, let's just focus on what our app currently
    does.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving tweets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take a look at the tweet reducer code that handles the `receive_tweet`
    action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This reducer is pretty straightforward. The `action.tweet` value is returned
    as the new state when the `receive_tweet` action is dispatched. Since this is
    a small reducer function, it might be a good place to point out some things that
    are common to all reducer functions.
  prefs: []
  type: TYPE_NORMAL
- en: The first argument that is passed to a reducer function is the old state. This
    argument has a default value because the first time the reducer is called, there
    is no state and this value is used to initialize it. In this case, the default
    state is null.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing to point out about reducers is that they always return a new
    state when called. Even if it doesn't produce any new state, a reducer function
    needs to return the old state. Redux will set the new state to whatever is returned
    by the reducer, even if you return undefined. This is why it's a good idea to
    have a `default` label in your `switch` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Simplified action creators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Redux, action creator functions are simpler than their traditional Flux
    counterparts. The main difference is that Redux action creator functions just
    return the action data. In traditional Flux, the action creators are also responsible
    for calling the dispatcher. Let''s take a look at the Redux action creator functions
    for Snapterest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, these functions return action objects that can then be dispatched—they
    don't actually call the dispatcher. You'll see why this is the case when we start
    connecting our React components to the Redux store. The main responsibility of
    action creator functions in a Redux app is to make sure that an object with the
    correct `type` property is returned, along with properties that are relevant to
    the action. For example, the `addTweetToCollection()` action creator accepts a
    tweet parameter, which is then passed to the action by returning it as a property
    of the returned object.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting components to an application state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have the reducer functions that handle creating a new application
    state, and the action creator functions that trigger our reducer functions. We
    still need to connect our React components to the Redux store. In this section,
    you'll learn how to use the `connect()` function to create a new version of your
    component that's connected to the Redux store.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping state and action creators to props
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea with Redux and React integration is that you tell Redux to wrap your
    component with a stateful component that has its state set when the Redux store
    changes. All we have to do is write a function that tells Redux how we want state
    values passed to our component as props. Additionally, we have to tell the component
    about any actions that it might want to dispatch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the general pattern that we''ll follow when connecting components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a breakdown of how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: The `connect()` function from the React-Redux package returns a new React component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `mapStateToProps()` function takes a state argument and returns an object
    with property values based on this state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `mapDispatchToProps()` function takes a `dispatch()` argument, which is
    used to dispatch actions, and returns an object with functions that can dispatch
    actions. These are added to the component's props.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Component` is a React component that you want connected to the Redux store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you start connecting components, you'll soon realize that Redux is taking
    care of many React component lifecycle chores for you. Where you would typically
    need to implement `componentDidMount()` functionality, suddenly, you don't need
    to. This leads to clean and concise React components.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the stream component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `Stream` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Not much about `Stream` has changed from its previous implementation. The main
    difference is that we've removed some lifecycle methods. All of the Redux connection
    code comes after the component declaration. The `mapStateToProps()` function returns
    the `tweet` property from the state. So now our component has a `tweet` prop.
    The `mapDispatchToProps()` function returns an empty object because `Stream` doesn't
    dispatch any actions. You don't actually have to provide this function when you
    have no actions. However, this might change in the future, and if the function
    is already there, you just need to add properties to the object.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the StreamTweet component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Stream` component renders the `StreamTweet` component, so let''s take
    a look at this next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `StreamTweet` component doesn't actually use any state from the Redux store.
    So why bother connecting it? The answer is, so that we can map action dispatcher
    functions to component props. Remember, action creator functions in Redux apps
    just return the action object instead of dispatching the action.
  prefs: []
  type: TYPE_NORMAL
- en: In the `mapDispatchToProps()` function here, we're dispatching an `addTweetToCollection()`
    action by passing its return value to `dispatch()`. Redux provides us with a simple
    dispatch function that's bound to the Redux store. Any time we want to dispatch
    an action, we can just call `dispatch()`. Now the `StreamTweet` component will
    have an `onImageClick()` function prop that can be used as an event handler to
    handle the click events.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the collection component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we just have to connect the `Collection` component and its child components.
    Here''s what the `Collection` component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `Collection` component doesn't dispatch any actions, so our `mapDispatchToProps()`
    function returns an empty object. It does use state from the Redux store though,
    so our `mapStateToProps()` implementation returns `state.collection`. This is
    how we slice the state of the entire application into pieces that the component
    cares about. For example, if our component needed access to some other state in
    addition to `Collection`, we'd return a new object made up of different slices
    of the overall state.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting collection controls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Within the `Collection` component, we have the `CollectionControls` component.
    Let''s see what it looks like once it''s been connected to the Redux store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This time, we have a component that requires objects from both `mapStateToProps()`
    and `mapDispatchToProps()`. Once again, we need to pass the collection state to
    this component as props. The `onRenameCollection()` event handler dispatches a
    `toggleIsEditingName()` action while the `onEmptyCollection()` event handler dispatches
    the `removeAllTweetsFromCollection()` action.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the TweetList component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lastly, we have the `TweetList` component; let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This component doesn't depend on the Redux store for any state. It does map
    an action dispatcher function to its props though. We don't necessarily need to
    connect the dispatcher here. For example, if this component's parent is connecting
    functions to the dispatcher, the function could be declared there and passed into
    this component as a prop. The benefit would be that `TweetList` would no longer
    require Redux at all. The downside would be having too many dispatch functions
    declared in one component. Luckily, you get to implement your component using
    whichever approach you see fit.
  prefs: []
  type: TYPE_NORMAL
- en: Creating stores and wiring your app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We're almost done refactoring our Snapterest app from a traditional Flux architecture,
    to one that's based on Redux. There's just two things left to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to combine our reducer functions into a single function in order
    to make a store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses the `combineReducers()` function to take our two existing reducer
    functions that exist in their own modules, and produces a single reducer that
    we can use to make a Redux store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There you have it—our Redux store is created, complete with its initial state
    that''s supplied by reducer functions by default. Now we just have to pass this
    store to our top-level React component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `Provider` component wraps our top-level application component and provides
    it, along with any child components that depend on an application state, with
    state updates.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to refine your Flux architecture using the
    Redux library. Redux applications should have only one store, action creators
    can be simple, and reducer functions control the transformation of the immutable
    state. The aim of Redux, in a nutshell, is to reduce the number of moving parts
    typically found in a traditional Flux architecture while retaining the unidirectional
    dataflow.
  prefs: []
  type: TYPE_NORMAL
- en: You then implemented the Snapterest application using Redux. Starting with the
    reducers, you returned a new state for the Redux store any time a valid action
    was dispatched. Then you built action creator functions that returned an object
    with the correct type property. Lastly, you refactored components so that they
    were connected to Redux. You made sure that the components could read store data
    as well as dispatch actions.
  prefs: []
  type: TYPE_NORMAL
- en: This is a wrap for this book. I hope you've learned enough about the essentials
    of React development that you can continue your journey of discovery by learning
    more advanced React topics. More importantly, I hope you learned more about React
    by building awesome React apps and then making them better.
  prefs: []
  type: TYPE_NORMAL
