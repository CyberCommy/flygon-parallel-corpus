- en: Chapter 5. Network Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 3. Troubleshooting a Web Application"), *Troubleshooting a Web Application*,
    we took an in-depth look at troubleshooting web applications; while we walked
    through a complex application error, we completely skipped the networking aspect
    of web applications. In this chapter, we will investigate a reported issue that
    will walk us through concepts such as DNS, routing, and of course network configuration
    for RHEL systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Networking is an essential skill for any Linux systems administrator. To quote
    a past instructor:'
  prefs: []
  type: TYPE_NORMAL
- en: A server without a network is useless to everyone.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As a systems administrator, every server or desktop that you manage will have
    some sort of network connection. Whether this network connection is within a segregated
    corporate network or directly connected to the Internet, a network is involved.
  prefs: []
  type: TYPE_NORMAL
- en: Since networking is such a critical topic, this chapter will cover many aspects
    of networking and network connectivity; however, it will not cover firewalls.
    Firewall troubleshooting and configuration will actually be covered in [Chapter
    6](part0037_split_000.html#1394Q1-8ae10833f0c4428b9e1482c7fee089b4 "Chapter 6. Diagnosing
    and Correcting Firewall Issues"), *Diagnosing and Correcting Firewall Issues*.
  prefs: []
  type: TYPE_NORMAL
- en: Database connectivity issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 3. Troubleshooting a Web Application"), *Troubleshooting a Web Application*,
    we were troubleshooting a problem with the company blog. In this chapter, we will
    once again troubleshoot this blog; however, today's issue is a bit different.
  prefs: []
  type: TYPE_NORMAL
- en: 'After arriving for the day, we receive a call from a developer stating: *The
    WordPress blog is returning an error that it cannot connect to the database*.'
  prefs: []
  type: TYPE_NORMAL
- en: Data collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to the troubleshooting process that we have been following, the next
    step is to gather as much data as possible around the issue. One of the best sources
    of information is the person reporting the issue; for this situation, we will
    ask two basic questions:'
  prefs: []
  type: TYPE_NORMAL
- en: How can I duplicate the issue and see the error?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has anything changed recently with the WordPress application?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When asked, the developer states that we can see the error simply by going to
    the blog in the web browser. On the second question, the developer informs us
    that the database service was recently moved from the webserver to a new dedicated
    database server. He also mentions that the move happened several days ago and
    that the application was working until today.
  prefs: []
  type: TYPE_NORMAL
- en: Since the database service was moved several days ago and the application was
    working up until this morning, it is not likely that this change caused the issue.
    However, we should not discount this as a possibility.
  prefs: []
  type: TYPE_NORMAL
- en: Duplicating the issue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in the previous chapters, a key data collection task is to duplicate
    the issue. We do this to not only verify that the issue being reported is the
    issue occurring but also to find any additional errors that may not have been
    reported.
  prefs: []
  type: TYPE_NORMAL
- en: Since the developer stated that we could duplicate this by going to the blog
    directly, we will do that from our web browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Duplicating the issue](img/00004.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It seems that we can duplicate the issue pretty easily. On the basis of this
    error, it appears that the application is simply saying that it is having issues
    establishing a database connection. While this in itself does not mean that the
    issue is network-related, it could be. The issue could also simply be an issue
    with the database service itself.
  prefs: []
  type: TYPE_NORMAL
- en: To determine whether the issue is a network issue or a database service issue,
    we will first need to find which server the application is configured to connect
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the database server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with the previous chapter, we will determine which server the application
    is using by looking through the application configuration files. From our previous
    troubleshooting in [Chapter 3](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 3. Troubleshooting a Web Application"), *Troubleshooting a Web Application*,
    we know that the WordPress application is hosted on `blog.example.com`. To get
    started, we will first log into the blog's webserver and look through the WordPress
    configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we will be executing commands against multiple systems, the examples in this
    chapter will include a hostname such as `blog` or `db` in the command-line prompt.
  prefs: []
  type: TYPE_NORMAL
- en: We learned in [Chapter 3](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 3. Troubleshooting a Web Application"), *Troubleshooting a Web Application*,
    that the WordPress database configuration is stored within the `/var/www/html/wp-config.php`
    file. To quickly search this file for database information, we can use the `grep`
    command to search for the string `DB` as this string was present for the database
    configuration in our previous incident.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With the above, we can see that the application is currently configured to connect
    to `db.example.com`. A simple first troubleshooting step is to simply attempt
    to connect to the database manually. A simple way to test the database connectivity
    manually is to use the `telnet` command.
  prefs: []
  type: TYPE_NORMAL
- en: Testing connectivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `telnet` command is a very useful network and network service troubleshooting
    tool as it is designed to simply establish a TCP-based network connection to the
    specified host and port. For our example, we will attempt to connect to the host
    `db.example.com` on port `3306`.
  prefs: []
  type: TYPE_NORMAL
- en: Port `3306` is the default port for MySQL and MariaDB; in the previous chapter,
    we already established that this web application requires one of these two database
    services. As we do not see a specific port listed in the `wp-config.php` file's
    configuration, we will assume that the database service is running on this default
    port.
  prefs: []
  type: TYPE_NORMAL
- en: Telnet from blog.example.com
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get started, we will execute the `telnet` command from the blog server itself.
    The fact that we are testing from the same server that the application runs on
    is important, as this allows us to test under the same network conditions as the
    application receiving the error.
  prefs: []
  type: TYPE_NORMAL
- en: To use telnet to connect to our database server, we will execute the `telnet`
    command followed by the hostname (`db.example.com`) and port (`3306`) that we
    wish to connect to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It seems that the telnet connection failed. What is interesting is the error
    being provided; the **No route to host** error seems to clearly indicate a potential
    network issue.
  prefs: []
  type: TYPE_NORMAL
- en: Telnet from our laptop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the connection attempt from the blog server failed with an error indicating
    there was a network-related issue, we can attempt the same connectivity from our
    laptop to determine whether the issue is on the blog server's side or the `db`
    server's side.
  prefs: []
  type: TYPE_NORMAL
- en: To test this connectivity from our laptop, we can once again use the `telnet`
    command. We can use this command even though our laptop is not necessarily running
    a Linux operating system. The reason for this is that the `telnet` command is
    a cross-platform utility; in this chapter, we will utilize several commands that
    are cross-platform. While there may not be many of them, in general, there are
    several commands that work on most operating systems, including those that do
    not traditionally have extensive command line functionality.
  prefs: []
  type: TYPE_NORMAL
- en: While some operating systems have been removing the `telnet` client from default
    installations, the software can still be installed. For our example, the laptop
    is running OS X, which currently deploys the `telnet` client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It seems that our laptop is also unable to connect to the database service;
    however, the error is different this time. This time it seems to suggest that
    the connection attempt was closed by the remote service. We also do not see a
    message from the remote service, which would indicate that the connection was
    never fully established.
  prefs: []
  type: TYPE_NORMAL
- en: One caveat to using the `telnet` command to establish port availability is that
    the `telnet` command will show a connection as **Connected**; however, the connection
    may not necessarily be established at this point. The general rule when working
    with telnet is to not assume that the connection was successful until a message
    from the remote service is received. In our example, we did not receive a message
    from the remote service.
  prefs: []
  type: TYPE_NORMAL
- en: Ping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since `telnet` from both the blog server and our laptop failed, we should check
    whether the issue is isolated to just the database service or connectivity to
    the server as a whole. One tool to test server-to-server connectivity is the `ping`
    command, which like the `telnet` command is a cross-platform utility.
  prefs: []
  type: TYPE_NORMAL
- en: To test connectivity with the `ping` command, we can simply execute the command
    followed by the host that we wish to `ping`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The error from the `ping` command seems to be very similar to the error from
    the `telnet` command. To understand this error better, let's first get a better
    understanding of how the `ping` command works.
  prefs: []
  type: TYPE_NORMAL
- en: First, before any other action, the `ping` command will try to resolve the hostname
    provided. What this means is that before doing anything else, our ping execution
    tried to identify the IP address of `db.example.com`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: From the results, we can see that the `ping` command identified this host as
    resolving to `192.168.33.12`. Once ping has the IP address, it will send an `ICMP`
    echo request network packet to that IP. In this case, this means that it is sending
    an `ICMP` echo request to `192.168.33.12`.
  prefs: []
  type: TYPE_NORMAL
- en: ICMP is a networking protocol that is used as a control system. When the remote
    host, such as `192.168.33.12` receives an `ICMP` echo request network packet,
    it is supposed to send an `ICMP` echo reply network packet back to the requesting
    host. This activity allows two hosts to validate network connectivity by performing
    a simple networking version of *ping pong*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If our `ICMP` echo request packet had never made it to the `192.168.33.12` server,
    we simply would have had no output from the `ping` command. However, we received
    an error; this means that the system on the other side is up, but there is an
    error with the connectivity between the two hosts that is preventing a full two-way
    discussion.
  prefs: []
  type: TYPE_NORMAL
- en: One question that arises around this issue is whether the error is true for
    all network connectivity from the blog server or isolated to the communication
    between the `blog` and the `db` server. We can test this by performing a `ping`
    request to another generic address. Since our system is connected to the Internet,
    we can simply use a common Internet domain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is an example of a working `ping` request and reply. Here,
    we can see not only the IP that [Google.com](http://Google.com) resolves to but
    also the returned `ping` requests. This means that, as our blog server sends an
    `ICMP echo request`, the remote server `216.58.216.46` sends an `ICMP echo reply`.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting DNS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Something interesting that both the `ping` and the `telnet` commands told us
    beyond network connectivity is the IP address of the `db.example.com` hostname.
    However, it seems that our results are different when performing these actions
    from our laptop as opposed to from the blog server.
  prefs: []
  type: TYPE_NORMAL
- en: From the blog server, our `telnet` tried to connect to `192.168.33.12`, the
    same address as our `ping` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this is simple; it seems that our laptop is getting a different
    DNS result as our blog server. If that is the case however, it could mean that
    our issue may simply be related to a DNS issue.
  prefs: []
  type: TYPE_NORMAL
- en: Checking DNS with dig
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: DNS is an important aspect of modern-day networks. Our current issue is a perfect
    example of its importance. In the WordPress configuration file, our database server
    is set to `db.example.com`. This means that before the application server can
    establish a database connection, it must first look up the IP address.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, it is fairly safe to assume that the IP address identified by
    `ping` is likely to be the IP address presented by DNS. However, this is not always
    the case as we may soon find out with our specific issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dig` command is a very useful DNS troubleshooting command; it is very
    flexible and can be used to perform many different types of DNS requests. To validate
    the DNS for `db.example.com`, we can simply execute the `dig` command followed
    by the hostname that we wish to query: `db.example.com`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the returned data from `dig`, we can see that the DNS name `db.example.com`
    does not resolve to `192.168.33.12`, but rather to `10.0.0.50`. We can see this
    in the `ANSWER SECTION` of the `dig` command's output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: One very useful option with `dig` is the option to specify a server to query.
    In the previous execution of `dig`, we could see that server `10.0.2.3` was the
    server that provided the `10.0.0.50` address.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since we are unfamiliar with this DNS server, we can validate the returned results
    further by querying Google's public DNS servers. We can do this by adding `@`
    followed by the DNS server IP or hostname that we wish to use. In the following
    example, we are requesting `8.8.8.8` a DNS server that is part of Google's public
    DNS infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Looking up DNS with nslookup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another great tool for troubleshooting DNS is `nslookup`. The `nslookup` command
    is a command that has been around for quite a while. In fact, it is yet another
    cross-platform command that exists on practically all major operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: To perform a simple DNS lookup with `nslookup`, we can simply run the command
    followed by the DNS name to query, similar to `dig`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Like `dig`, the `nslookup` command can be used to query a specific DNS server
    as well. This can be done via two methods. The first is by adding the server address
    at the end of the command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The second method is to use `nslookup` in the interactive mode. To go into the
    interactive mode, simply execute `nslookup` with no other options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Once in the interactive mode, specify the server to use by entering `server
    <dns server>`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Finally, to lookup the DNS name, we just type the domain to query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: So why use `nslookup` rather than `dig`? While the `dig` command is very useful,
    it is not a cross-platform command and has only traditionally existed on Unix
    and Linux systems. The `nslookup` command on the other hand is cross-platform
    and can be found in most environments where the `dig` command may be unavailable.
    It is important as a systems administrator to be familiar with many commands,
    and it is very useful to be able to perform a task using whichever command is
    available.
  prefs: []
  type: TYPE_NORMAL
- en: What did dig and nslookup tell us?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have used `dig` and `nslookup` to query the DNS name `db.example.com`,
    let's review what we have found.
  prefs: []
  type: TYPE_NORMAL
- en: The domain `db.example.com` actually resolves to `10.0.0.50`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ping` command returned `192.168.33.12` for the domain `db.example.com`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How is the `ping` command returning one address while DNS returns another? One
    possibility is a configuration in the `/etc/hosts` file. This is something that
    we can validate very quickly with a simple `grep` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: A bit about /etc/hosts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before DNS servers such as **Bind** were created, local `hosts` files were used
    to manage the domain-to-IP mappings. This file contained a list of every domain
    address that the system needed to connect to. However, over time, this method
    became complicated as networks grew from a few hosts to thousands and millions
    of hosts.
  prefs: []
  type: TYPE_NORMAL
- en: On Linux and most Unix distributions, the `hosts` file is located at `/etc/hosts`.
    By default, any entry in the `/etc/hosts` file will supersede DNS requests. This
    means that, by default, if there is a domain-to-IP mapping in the `/etc/hosts`
    file, this mapping will be used and the system will not pull the same domain from
    another DNS system.
  prefs: []
  type: TYPE_NORMAL
- en: This is the default behavior for Linux; however, we can check whether this server
    is using this default configuration by reading the `/etc/nsswitch.conf` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `nsswitch.conf` file is a configuration that allows administrators to configure
    which backend systems to use in order to look up items such as users, groups,
    netgroups, hostnames, and services. For example, if we wanted to configure a system
    to use `ldap` to look up user groups, we could do that by changing the values
    in the `/etc/nsswitch.conf` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Based on the output of the preceding `grep` command, the blog system is configured
    to use local group files and then the SSSD service to look up user groups. To
    add `ldap` to this configuration, simply add it to the list in the order desired
    (that is, `ldap files sss`).
  prefs: []
  type: TYPE_NORMAL
- en: For the DNS that is specified by the `hosts` configuration, it appears that
    our server is configured to look up hosts first on the basis of files and then
    the DNS. This means that our system will honor the `/etc/hosts` file before looking
    up a domain via DNS.
  prefs: []
  type: TYPE_NORMAL
- en: DNS summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have confirmed both DNS and the `/etc/hosts` file, we know that
    someone has configured this application server to think `db.example.com` resolves
    to `192.168.33.12`. Was this a mistake or is this a way to connect to the database
    server without using DNS?
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it is a bit too early to tell, but we do know that the host `192.168.33.12`
    did not send an `ICMP echo reply` to our `ICMP echo request` from the blog server.
  prefs: []
  type: TYPE_NORMAL
- en: Pinging from another location
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever dealing with network issues, it is always best to try the connection
    from multiple locations or servers. This may seem like something obvious to the
    data collector type of troubleshooter, but the educated guesser troubleshooter
    may overlook this extremely helpful step.
  prefs: []
  type: TYPE_NORMAL
- en: For our example, we will run a test `ping` from our laptop to `192.168.33.12`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: From the results of the `ping` request, it seems that our laptop is able to
    connect to `192.168.33.12` without any issue.
  prefs: []
  type: TYPE_NORMAL
- en: What does this tell us? Quite a bit actually! It tells us that the server in
    question is up; it also confirms that there is a connectivity issue, specifically
    between `blog.example.com` and `db.example.com`. If the issue were due to the
    `db.example.com` server being down or misconfigured, our laptop would also be
    impacted.
  prefs: []
  type: TYPE_NORMAL
- en: However that is not the case. It is actually quite the opposite; it seems that
    connectivity from our laptop to the server works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Testing port connectivity with cURL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier when testing the MariaDB port from our laptop with `telnet`, the `telnet`
    command was testing the server `10.0.0.50`. However, based on the `/etc/hosts`
    configuration, it seems that the desired database server is `192.168.33.12`.
  prefs: []
  type: TYPE_NORMAL
- en: To verify that the database service is actually up, we should perform the same
    `telnet` test with the `192.168.33.12` address. However, this time rather than
    using `telnet`, we will perform this test with `curl`.
  prefs: []
  type: TYPE_NORMAL
- en: I have seen many environments (especially lately) where installing the `telnet`
    client is forbidden or not performed by default. For environments such as these,
    it is important to have some tool that can test port connectivity. If telnet is
    not available, the `curl` command can be used as an alternative.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 3. Troubleshooting a Web Application"), *Troubleshooting a Web Application*,
    we used the `curl` command to request a web page. The `curl` command can actually
    be used with many different protocols; the protocol that we are interested in
    for this case is the Telnet protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The following is an example of using `curl` from our laptop to establish a connection
    to the `db.example.com` server over port `3306`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: From the example, it seems that not only was the laptop able to connect to the
    server on port `3306`, but the `curl` command also received a message from the
    `RCVD IAC 106` service.
  prefs: []
  type: TYPE_NORMAL
- en: When using `curl` for Telnet tests, it is necessary to use the `–v` (verbose)
    flag to put curl into the verbose mode. Without the verbose flag, `curl` will
    simply hide the connectivity details, and the connectivity details are exactly
    what we are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we can see that the connection from our laptop was
    successful; for comparison, we can use this same command to test connectivity
    from the blog server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the connection attempt failed.
  prefs: []
  type: TYPE_NORMAL
- en: From the above tests with `curl`, we can determine that the database server
    is listening and accepting connections on port `3306`; however, the blog server
    cannot connect to the database server. What we don't know is if the issue is on
    the blog server's side or on the database server's side. To identify which side
    of the connection is having an issue, we will need to look at the details of the
    network connections. To do this, we will use two commands, the first being `netstat`
    and the second being `tcpdump`.
  prefs: []
  type: TYPE_NORMAL
- en: Showing current network connections with netstat
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `netstat` command is a very extensive tool and can be used to troubleshoot
    many aspects of network issues. In this case, we will use two of the basic flags
    to print the existing network connections.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we executed the `netstat` command with the `–n` (no
    dns) flag, which tells `netstat` to not look up the DNS hostname of the IPs or
    translate port numbers to service names, and the `–a` (all) flag that tells `netstat`
    to print both listening and non-listening sockets.
  prefs: []
  type: TYPE_NORMAL
- en: These flags have the effect of `netstat`, showing all network connections and
    ports that are bound by applications.
  prefs: []
  type: TYPE_NORMAL
- en: The example `netstat` command shows quite a bit of information. To get a better
    understanding of this information, let's examine the output a little better.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The fifth column is the **Foreign Address** or remote address. This column lists
    the remote server's IP and port. Because of the type of example that we used earlier,
    this is listed as IP `0.0.0.0` and port `*`, which is a wildcard, meaning anything.
  prefs: []
  type: TYPE_NORMAL
- en: The sixth column, our final column, is the **State** socket. With TCP connections,
    the state will tell us the current state of the TCP connection. For our preceding
    example, the state is listed as `LISTEN`; this tells us that the listed socket
    is used for accepting TCP connections.
  prefs: []
  type: TYPE_NORMAL
- en: If we put all of the columns together, this single line tells us that our server
    is listening for new connections on port `25` via the IP `127.0.0.1` and that
    it is for TCP-based connections.
  prefs: []
  type: TYPE_NORMAL
- en: Using netstat to watch for new connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we understand the output of `netstat` a bit more, we can use it to
    look for new connections from our application server to our database server. To
    use `netstat` to watch for new connections, we will use an often overlooked feature
    of `netstat`.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the `vmstat` command, it is possible to put `netstat` into a continuous
    mode, which prints the same output every few seconds. To do this, simply put the
    interval at the end of the command.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we will use the same `netstat` flags with an interval
    of `5` s; however, we will also pipe the output to `grep` and use `grep` to filter
    for port `3306`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In addition to running the `netstat` command, we also can navigate to the `blog.example.com`
    address in our browser. We can do this to force the web application to attempt
    a connection to the database.
  prefs: []
  type: TYPE_NORMAL
- en: In general, web applications have two types of connections to a database, either
    persistent connections where they always stay connected to the database or non-persistent
    connections where they are established only when required. Since we don't know
    which type this WordPress installation uses, it is safer for this type of troubleshooting
    to assume they are non-persistent. This means that, in order to trigger database
    connections, there must be traffic to the WordPress application.
  prefs: []
  type: TYPE_NORMAL
- en: From the output of `netstat`, we can see connection attempts to the database,
    and not just any database but the database service at `192.168.33.12`. This information
    confirms that, when the web application is attempting to establish a connection,
    it is using the IP from the `hosts` file and not from DNS. Up until this point,
    we suspected that this was the case based on `telnet` and `ping` but had no proof
    of the connection from the application.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting fact however is that the `netstat` output shows that the TCP
    connection is in a `SYN_SENT` state. This `SYN_SENT` state is the state used when
    first establishing a network connection. The `netstat` command can print many
    different connection states; each one tells us where in the process the connection
    is in. This information can be key to identifying the root cause of network connectivity
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: Breakdown of netstat states
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before going too far, we should take a quick look at the different `netstat`
    states and what they mean. The following is a full list of states used by `netstat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ESTABLISHED`: The connection has been established and can be used for data
    transfer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SYN_SENT`: The TCP socket is attempting to establish a connection to the remote
    host'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SYN_RECV`: A TCP connection request has been received from the remote host'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FIN_WAIT1`: The TCP connection is closing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FIN_WAIT2`: The TCP connection is waiting for the remote host to close the
    connection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TIME_WAIT`: The socket is waiting after being closed for any outstanding network
    packets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CLOSE`: The socket is no longer being used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CLOSE_WAIT`: The remote end has closed its connection, and the local socket
    is being closed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LAST_ACK`: The remote end has initiated closing the connection, and the local
    system is waiting for a final acknowledgement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LISTEN`: The socket is being used to listen for incoming connections'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CLOSING`: Both the local and the remote sockets are closed, but not all data
    has been sent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UNKNOWN`: Used for sockets in an unknown state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the above list, we can determine that the connections to the database from
    the application never become `ESTABLISHED`. This means that the application server
    starts the connection in the `SYN_SENT` state, but it never transitions to the
    next state.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing network traffic with tcpdump
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get a better understanding of the network traffic, we will use a second command
    that allows us to look at the network traffic details—`tcpdump`. Here, the `netstat`
    command is used to print the status of sockets; the `tcpdump` command is used
    to create "`dumps`" or "`traces`" of network traffic. These dumps allow users
    to see all aspects of the network traffic captured.
  prefs: []
  type: TYPE_NORMAL
- en: With `tcpdump`, it is possible to look at the full TCP packet details, from
    the packet headers to the actual data being transmitted. Not only can it capture
    this data, but `tcpdump` can also write the captured data to a file. After the
    data is written to the file, it can be saved or moved and later read with the
    `tcpdump` command or other network packet analysis tools (for example, `wireshark`).
  prefs: []
  type: TYPE_NORMAL
- en: The following is a simple example of running `tcpdump` to capture the network
    traffic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, I have provided several flags to the `tcpdump` command.
    The first flag `–n` (no dns) tells `tcpdump` to not look up the hostname of any
    IPs that it finds. The rest of the flags `–vvv` (verbose) tell `tcpdump` to be
    very "very" verbose. The `tcpdump` command has three levels of verbosity; each
    `–v` that is added to the command line increases the verbosity level used. In
    the preceding example, `tcpdump` is in its most verbose mode.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example is one of the simplest ways to run `tcpdump`; however,
    it does not capture the traffic that we require.
  prefs: []
  type: TYPE_NORMAL
- en: Taking a look at the server's network interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When `tcpdump` is executed on systems with multiple network interfaces, unless
    an interface is defined the command will pick the lowest numbered interface to
    attach to. In the preceding example, the interface chosen was `enp0s3`; however,
    this may not be the interface used for database connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: Before using `tcpdump` to investigate our network connectivity issue, we first
    need to identify which network interface is used for this connectivity; to do
    this, we will use the `ip` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: At a high level, the `ip` command allows users to print, modify, and add network
    configurations. In the example above, we are telling the `ip` command to "show"
    us all of the available "links" by using the `show links` parameters. The links
    being shown are actually the defined network interfaces for this server.
  prefs: []
  type: TYPE_NORMAL
- en: What is a network interface?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When talking about a physical server, the network interface is generally a representation
    of a physical Ethernet port. If we assume that the machine used in the preceding
    example is a physical machine, we can assume that the `enp0s3` and `enp0s8` links
    are physical devices. In reality, however, the abovementioned machine is a virtual
    machine. This means that the devices are logically attached to this virtual machine;
    the kernel of this machine however does not know or even need to know the difference.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in this book most interfaces, with the exception of the "`lo`"
    or loopback interface, are directly related to physical (or virtually physical)
    network devices. It is possible, however, to create virtual interfaces, which
    allows you to create multiple interfaces that link back to a single physical interface.
    In general, these interfaces are seen with a "`:`" or "`.`" as a separator from
    the original device name. If we were to make a virtual interface for `enp0s8`,
    it would look something along the lines of `enp0s8:1`.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing device configuration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: From the `ip` command's output, we can see that there are three network interfaces
    defined. Before knowing which one is used for our database connectivity, we will
    first need to understand these interfaces better.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `lo` or loopback interface is the first one in the list. Anyone who has
    worked on Linux or Unix long enough will be very familiar with loopback interfaces.
    The loopback interface is designed to give users of the system a local network
    address that can only be used to connect back to the local system.
  prefs: []
  type: TYPE_NORMAL
- en: This special interface allows applications located on the same server to interact
    via TCP/IP without having to expose their connectivity externally to the wider
    network. It also allows these applications to interact without a network packet
    leaving the local server, thus making it a very fast networking connection.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, the loopback interface IP is well known as `127.0.0.1`. However,
    just like everything else in this book, we will first validate this information
    before assuming it to be true. We can do this by using the `ip` command to show
    the loopback interface's defined address.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example that shows available interfaces, the "`link show`" options
    were used; in order to show IP addresses, the "`addr show`" options can be used.
    The syntax for the `ip` command to print items follows this same scheme throughout.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example also specifies the name of the device we are interested
    in; this limits the output to the specified device. If we were to omit the device
    name from the preceding command, it would simply print the IP addresses for all
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: So, what does the above tell us about the lo interface? Well one thing that
    it tells us is that the `lo` interface is listening on the IPv4 address of 127.0.0.1;
    we can see this on the following line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This means that, if we want to connect to this host via the loopback interface,
    we can do so by targeting `127.0.0.1`. The `ip` command, however, also shows a
    second IP defined on this interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This shows us that the IPv6 address of `::1` is also bound to the lo interface.
    This address serves the same purpose as `127.0.0.1`, but it is designed for `IPv6`
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: With the above information from the `ip` command, we can see that the `lo` or
    loopback interface is defined as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The second interface defined on this server is `enp0s3`; this device, unlike
    lo, is either a physical device or a virtualized physical interface. The `ip`
    link show command executed earlier has already told us quite a bit about this
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: From this information, we know that the interface is up and able to be utilized.
    We also know that the MTU size is set to the default of 1500, and we can easily
    identify the MAC address. While the MTU size and the MAC address may not be extremely
    pertinent to this issue, they can be very useful in other situations.
  prefs: []
  type: TYPE_NORMAL
- en: However, for our current task of identifying which interface is used for database
    connectivity, we will need to identify which IPs are bound to this interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, we can see that the `enp0s3` interface is listening
    to the IPv4 IP of `10.0.2.15` (`inet 10.0.2.15/24`) as well as the IPv6 IP of
    `f380::a00:27ff:fe20:5d4b` (`inet6 fe80::a00:27ff:fe20:5d4b/64`). Does this tell
    us that connections to `192.168.33.12` go through this interface? No, but it also
    doesn't mean that they don't.
  prefs: []
  type: TYPE_NORMAL
- en: What this does tell us is that the `enp0s3` interface is used to connect to
    the `10.0.2.15/24` network. This network may or may not be able to route to the
    address of `192.168.33.12`; before making this determination, we should first
    review the next interface's configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The third interface on this system is `enp0s8`; it is also a physical or virtual
    network device, and from the information provided by the `ip` link show command,
    we can see that it has a similar configuration to `enp0s3`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: From this output, we can see that the interface of `enp0s8` is also in an "`UP`"
    state and has the default MTU size of 1500\. We can also determine the MAC address
    of this interface, which at this time is not specifically required; however, it
    may become useful later.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the IPs defined on this server, however, there is a significant
    difference from those of the `enp0s3` device.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `enp0s8` interface is listening on the IPv4 address of `192.168.33.11`
    (`inet 192.168.33.11/24`) and the IPv6 address of `fe80::a00:27ff:fe7f:fd54` (`inet6
    fe80::a00:27ff:fe7f:fd54/64`).
  prefs: []
  type: TYPE_NORMAL
- en: Does this mean that the `enp0s8` interface is used to connect to `192.168.33.12`?
    Well, actually, it may.
  prefs: []
  type: TYPE_NORMAL
- en: The subnet defined for `enp0s8` is `192.168.33.11/24`, which means that this
    interface is connected to a network of devices that span the IP range of `192.168.33.0`
    to `192.168.33.255`. Since the database server's `IP 192.168.33.12` is within
    this range, it is very likely that the communication to this address is over the
    `enp0s8` interface.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can "suspect" that the interface of `enp0s8` is used for communication
    to the database server. While this interface may be configured to talk to the
    subnet that contains `192.168.33.12`, it is entirely possible to force communication
    through another interface by using defined routes.
  prefs: []
  type: TYPE_NORMAL
- en: To check whether there is a route defined and forcing communication out through
    another interface, we will again use the `ip` command. For this task, however,
    we will use the "`route get`" options for the `ip` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: When executed with the "`route get`" arguments, the `ip` command will specifically
    output which interface is used to route to the specified IP.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding output, we can see that the `blog.example.com` server is
    in fact using the `enp0s8` interface to route to the 192.168.33.12 address, the
    IP of `db.example.com`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, not only have we used the `ip` command to determine what network
    interfaces exist on this server, but we have also used it to determine which interface
    a network packet would take to get to our target host.
  prefs: []
  type: TYPE_NORMAL
- en: The `ip` command is a very useful tool and has recently been slated to replace
    older commands such as `ifconfig` and `route`. If you are generally familiar with
    using commands such as `ifconfig` but not as familiar with the `ip` command, it
    is a good idea to review the usage covered above, as eventually, the `ifconfig`
    command will be deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the interface with tcpdump
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have identified the interface used for communication with `db.example.com`
    we can start our network trace by using `tcpdump`. As mentioned earlier, we will
    use the -`nvvv` flags to put `tcpdump` in the very "very" verbose mode without
    hostname resolution. This time, however, we will specify that `tcpdump` captures
    network traffic from the `enp0s8` interface; we can do this with the `-i` (interface)
    flag. We will also use the `-w` (write) flag to write the captured data to a file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When we first executed the `tcpdump` command, we received quite a bit of output
    to the screen. When told to save its output to a file, `tcpdump` will not output
    the captured data to the screen but rather continuously show a counter of captured
    packets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have `tcpdump` saving its captured data to a file, we need to duplicate
    the issue to try to generate database traffic. We will do this by using the same
    method as we did with the `netstat` command: by simply navigating to `blog.example.com`
    in a web browser.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we navigate to the WordPress site, we should see the `packets captured`
    counter increasing; this indicates that `tcpdump` has seen traffic and has captured
    it. Once the counter reaches a reasonable number, we can stop the `tcpdump` capture.
    To do this, simply press *Ctrl* + *C* on the command line; once stopped, we should
    see a message similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Reading the captured data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the captured the `network trace` saved to a file, we can use
    this file to investigate the database traffic. The benefit of having this data
    saved within a file is that we can read this data multiple times and iterate through
    filters to reduce the output. Further, when running `tcpdump` against the live
    network stream, we may catch traffic once but never again.
  prefs: []
  type: TYPE_NORMAL
- en: In order to read the saved data, we can run `tcpdump` with the `–r` (read) flag
    followed by the filename to read.
  prefs: []
  type: TYPE_NORMAL
- en: We could start by using the following command to print the packet header information
    for all `48` packets that we captured.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The output of this command, however, can be quite overwhelming; to get to the
    heart of the issue, we will need to narrow down the output of `tcpdump`. To do
    this, we will use tcpdump's ability to apply filters to the captured data. In
    particular, we will be filtering the output to a specific IP address by using
    the "`host`" filter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: By adding `host 192.168.33.12` to the end of the `tcpdump` command, the output
    is filtered to traffic that only relates to the host 192.168.33.12\. This is made
    possible by the `host` filter. The `tcpdump` command has many available filters;
    however, in this chapter, we will mainly utilize the host filter. I would strongly
    suggest becoming familiar with `tcpdump` filters for anyone troubleshooting network
    issues regularly.
  prefs: []
  type: TYPE_NORMAL
- en: When running `tcpdump` (in the same fashion as above), it is important to know
    that each line is a packet being either sent or received through the specified
    interface. The below example is one complete `tcpdump` line, which is essentially
    one packet that has passed through the `enp0s8` interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If we take a look at the preceding line, we can see that this packet is being
    sent from `192.168.33.11` to `192.168.33.12`. We can see this from the following
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The fact that this packet is a `SYN` packet actually tells us quite a bit about
    the packet.
  prefs: []
  type: TYPE_NORMAL
- en: A quick primer on TCP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Transmission Control Protocol** (**TCP**) is one of the most utilized protocols
    for Internet-based communications. It is the protocol of choice for many of the
    services that we rely on every day. From the HTTP protocol for loading web pages
    to the favorite of all Linux systems administrators, `SSH`, these protocols are
    implemented on top of the TCP protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: While TCP is highly used, it is also a rather advanced topic, a topic that every
    systems administrator should have at least a basic understanding of. In this section,
    we are going to quickly cover some TCP basics; this will by no means be an extensive
    guide but is just enough to understand the root of our issue.
  prefs: []
  type: TYPE_NORMAL
- en: To understand our issue, we must first understand how TCP connections are established.
    With TCP communications, there are generally two important parties, namely the
    client and the server. The client is the initiator of the connection and will
    send a `SYN` packet as the first step to establishing a TCP connection.
  prefs: []
  type: TYPE_NORMAL
- en: When the server receives a `SYN` packet and is willing to accept the connection,
    it will send a **Synchronize Acknowledgement** (**SYN-ACK**) packet back to the
    client. This is designed for the server to acknowledge that it has received the
    original `SYN` packet.
  prefs: []
  type: TYPE_NORMAL
- en: When the client receives this `SYN-ACK` packet, it then replies to the server
    with an `ACK`, sometimes referred to as a `SYN-ACK-ACK`. The idea behind this
    packet is for the client to acknowledge that it has received the server's acknowledgement.
  prefs: []
  type: TYPE_NORMAL
- en: This process is known as the *Three-Way Handshake* and is the foundation of
    TCP. The benefit of this method is that, with each system acknowledging the packets
    that it receives, there is no question as to whether the client and the server
    are able to communicate back and forth. Once a three-way handshake has been performed,
    the connection is moved to an established state. This is where other types of
    packets can be used, such as **Push** (**PSH**) packets, which are used to transfer
    information from the client to the server or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Types of TCP packet
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Speaking of additional types of packets, it is important to know that the component
    that defines whether a packet is a `SYN` packet or an `ACK` packet is simply a
    flag being set in the packet header.
  prefs: []
  type: TYPE_NORMAL
- en: On the first packet from our captured data, only the `SYN` flag is set; this
    is why we will see output such as `Flags [S]`. This is an example of the first
    packet being sent and that packet having only the `SYN` flag set.
  prefs: []
  type: TYPE_NORMAL
- en: An `SYN-ACK` packet is a packet where the `SYN` and the `ACK` flags are set.
    This is commonly seen as `[S.]` in `tcpdump`.
  prefs: []
  type: TYPE_NORMAL
- en: The following is a table of packet flags commonly seen during troubleshooting
    activities with `tcpdump`. This is by no means a full list, but it does give a
    general idea of the common packet types.
  prefs: []
  type: TYPE_NORMAL
- en: '`SYN- [S]`: This is a Synchronize packet, the first packet sent from the client
    to the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SYN-ACK- [S.]`: This is a Synchronize Acknowledgement packet; these packet
    flags are used to indicate that the server received the client''s `SYN` requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ACK- [.]`: The Acknowledgement packet is used by both the server and the client
    to acknowledge the received packets. After the initial `SYN` packet is sent, all
    subsequent packets should have the acknowledgement flag set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PSH- [P]`: This is a Push packet. It is designed to push the buffered network
    data to the receiver. This is the type of packet where data is actually transferred.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PSH-ACK- [P.]`: The Push Acknowledgement packet is used to both acknowledge
    a previous packet and send data to the recipient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FIN- [F]`: The `FIN` or Finish packet is used to tell the server that there
    is no more data and that it can close the established connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FIN-ACK- [F.]`: The Finish Acknowledgement packet is used to acknowledge that
    the previous Finish packet was received.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RST- [R]`: The Reset packet is used when the source system wishes to Reset
    the connection. In general, this is due to an error or the target port is not
    actually in the listening status.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RST-ACK -[R.]`: The Reset Acknowledgement packet is used to acknowledge that
    the previous Reset packet was received.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have explored the different types of packets, let's tie it all together
    and take a quick look back at the data captured earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If we break down these three packets, we can see that all three of them are
    from the source port of `37785`, targeting the destination port of 3306\. We can
    also see that these packets are `SYN` packets. What this means is that our system
    sent 3 `SYN` packets and never received an `SYN-ACK` from the destination, in
    this case `192.168.33.12`.
  prefs: []
  type: TYPE_NORMAL
- en: What does this tell us about our network connectivity to the host `192.168.33.12`?
    It tells us that either the remote server `192.168.33.12` is never receiving our
    packets or it is receiving them and we are never able to receive the `SYN-ACK`
    replies. If the issue were due to the database server not accepting our packet,
    we would expect to see an `RST` or `Reset` packet.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing collected data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, it is a good time to take an inventory of what information we
    have collected and what we know so far.
  prefs: []
  type: TYPE_NORMAL
- en: The first bit of key information that we have identified is that the blog server
    (`blog.example.com`) is unable to connect to the database server (`db.example.com`).
    The second bit of key information that we have identified is that the DNS name
    `db.example.com` resolves to `10.0.0.50`. However, there is also an `/etc/hosts`
    file entry overriding DNS on the `blog.example.com` server. Because of the hosts
    file, when the web application tries to connect to `db.example.com`, it is connecting
    to `192.168.33.12`.
  prefs: []
  type: TYPE_NORMAL
- en: We have also identified that the host `192.168.33.11` (`blog.example.com`) is
    sending the initial `SYN` packets to `192.168.33.12` when the WordPress application
    is accessed. However, the server `192.168.33.12` is either not receiving or not
    replying to these packets.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout our investigation, we reviewed the blog server's network configuration
    and we determined that it appears to be set up correctly. We can perform additional
    validation of this by simply using the ping command to send an ICMP echo to an
    IP within each network interface's subnet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: For the `enp0s3` interface, we can see that the IP address bound is `10.0.2.16`
    with a subnet of `/24` or `255.255.255.0`. With this setup, we should be able
    to communicate with another IP within this subnet. The following is the output
    of using the ping command to test connectivity to `10.0.2.2`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This shows that the `enp0s3` interface can at least connect to other IPs within
    its subnet. With `enp0s8`, we can perform the same test with another IP.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding command, we can see that `enp0s8` has the IP `192.168.33.11`
    bound to it with a subnet of `/24` or `255.255.255.0`. If we can use the ping
    command to communicate with any other IP in the `192.168.33.11/24` subnet, then
    we can validate that this interface is also configured correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: From the results, we can see that connectivity to the IP `192.168.33.1` is working
    as expected. Therefore, this means that, in at least a basic manner, the `enp0s8`
    interface is configured correctly.
  prefs: []
  type: TYPE_NORMAL
- en: With all of this information, we can assume that the `blog.example.com` server
    is configured correctly and can connect to the networks that it is configured
    for. From this point forward, if we want any more information about our issue,
    we will need to obtain it from the `db.example.com` (`192.168.33.12`) server.
  prefs: []
  type: TYPE_NORMAL
- en: Taking a look on the other side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it may not always be possible, when dealing with networking issues it
    is always best to troubleshoot from both sides of the conversation. In our earlier
    examples, we had two systems that make up our network conversation, namely the
    client and the server. So far we have looked at everything from the client's perspective;
    in this section, we are going to take a look at the other side of this conversation,
    from the server's perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the network configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we went through several steps before looking at the
    blog server's network configuration. In the case of the database server, we already
    know that the issue is related to networking and specifically the IP of `192.168.33.12`.
    Since we already know which IP the issue is related to, the first thing that we
    should do is identify which interface this IP is bound to.
  prefs: []
  type: TYPE_NORMAL
- en: One again, we will do this by using the `ip` command with the `addr show` options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In the earlier example, we used the `addr show` options to show the IPs associated
    with a single interface. This time, however, by omitting the interface name, the
    `ip` command shows all IPs and the interface that these IPs are bound to. This
    is a quick and simple way to show both the IP addresses and the interfaces associated
    with this server.
  prefs: []
  type: TYPE_NORMAL
- en: We can see from the preceding command that the database server has a similar
    configuration to the application server in that it has three interfaces. Before
    going too far, let's understand the server's interfaces better and see what information
    we can identify from them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The first interface on this server is the loopback interface `lo`. As discussed
    previously, this interface is common for every server and is only used for the
    local network traffic. This interface is not likely to be related to our issue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: It seems that, for the second interface, `enp0s3`, the database server's configuration
    is very similar to the blog server's. On the web application server, we also had
    an interface named `enp0s3` and this interface was also on the `10.0.2.0/24` network.
  prefs: []
  type: TYPE_NORMAL
- en: Since the connectivity between the blog and database servers seems to be targeting
    the IP of `192.168.33.12`, it seems that `enp0s3` is not an interface to focus
    on as the `enp0s3` interface has the IP `10.0.2.16` bound to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The third network device `enp0s8`, on the other hand, does have the IP `192.168.33.12`
    bound to it. The `enp0s8` device is also set up similar to the `enp0s8` device
    on the blog server, as it seems that the two devices are both on the `192.168.33.0/24`
    network.
  prefs: []
  type: TYPE_NORMAL
- en: From the previous troubleshooting, we know that the IP that our web application's
    targeting is IP 192.168.33.12\. With the `ip` command, we have confirmed that
    192.168.33.12 is bound to this server via the `enp0s8` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Testing connectivity from db.example.com
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we know that the database server has an expected network configuration,
    we need to establish whether this server is correctly connected to the `192.168.33.0/24`
    network. The simplest way is to perform a task that we performed earlier on the
    blog server; using `ping` to connect to another IP on that subnet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: With the above output, we can see that the database server is able to contact
    another IP on the `192.168.33.0/24` subnet. Earlier while troubleshooting, we
    tried to connect to the database server from the blog server and that test failed.
    An interesting test would be to validate that the connectivity fails the other
    way around as well when the database server initiates a connection to the blog
    server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: When running the `ping` command from the database server to the IP of the blog
    server (`192.168.33.11`), we can see that ping has replied with **Destination
    Host Unreachable**. This is the same error that we saw when attempting connectivity
    from the blog server as well.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, there are a number of reasons other than network connectivity
    issues that a ping will fail; to ensure that there is a connectivity issue, we
    should also test connectivity with `telnet`. We know that the blog server is accepting
    connections to the web server, so a simple `telnet` to the webserver's port should
    tell us definitively if there is any connectivity from the database server to
    the web server.
  prefs: []
  type: TYPE_NORMAL
- en: When running `telnet`, we need to specify a port to connect to. We know that
    the web server is running and, when we navigate to `http://blog.example.com`,
    we get a web page. On the basis of this information, we can determine that the
    default HTTP port is used and is listening. With this information, we also know
    that we can simply use telnet to connect to port `80`, the default port for `HTTP`
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: However, on this server, `telnet` is not installed. That's OK because we can
    use the `curl` command as we did in our previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: From the `curl` command's output, we can see that the communication issue is
    present irrespective of whether the blog or the database server initiates the
    connection.
  prefs: []
  type: TYPE_NORMAL
- en: Looking for connections with netstat
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, when troubleshooting from the blog server we used `netstat`
    to view the open TCP connections to the database server. Now that we are logged
    into the database server, we can use the same command to see the status of the
    connections from the database server's perspective. To do this, we will run `netstat`
    with an interval specified; this causes `netstat` to print network connection
    statistics every 5 s similar to the `vmstat` or `top` commands.
  prefs: []
  type: TYPE_NORMAL
- en: While the `netstat` command is running, we will simply refresh our browser to
    cause the WordPress application to attempt a database connection again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: After running `netstat` in what I like to call the `continuous mode`, and using
    `grep` to filter for the blog server's IP (192.168.33.11), we could not see any
    TCP connections or connection attempts.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, this would seem to indicate that the database server is never
    receiving a TCP packet from the blog server. We can confirm whether this is the
    case by using the `tcpdump` command to capture all network traffic on the `enp0s8`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing network connections with tcpdump
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Earlier when learning about `tcpdump`, we learned that it defaults to the interface
    with the lowest number. This means that, in order to capture the connection attempts,
    we must use the `-i` (interface) flag to trace the correct interface, `enp0s8`.
    In addition to telling `tcpdump` to watch the `enp0s8` interface, we are also
    going to have `tcpdump` write its output into a file. We will do this so that
    we can capture as much data as possible and later use the `tcpdump` command to
    analyze the data as many times as we need to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Now that `tcpdump` is running, we simply need to refresh our browser again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: After refreshing the browser and seeing the `packets captured` counter increase,
    we can stop `tcpdump` by pressing *Ctrl* + *C* on the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Once `tcpdump` has stopped, we can read the captured data with the `–r` (read)
    flag; however, this will print all of the packets that `tcpdump` captured. In
    some environments, this may be quite a lot of data. So, to trim the output to
    only the data that is useful, we will use the `port` filter to tell `tcpdump`
    to only output the captured traffic that is initiated from or targeting port 3306,
    the default MySQL port.
  prefs: []
  type: TYPE_NORMAL
- en: We can do this by adding `port 3306` to the end of the `tcpdump` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: While using the preceding filter, however, it seems that this database server
    is used by more than just the WordPress application. From the `tcpdump` output,
    we can see more traffic on port `3306` than just the blog server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To clean up this output further, we can add the host filter to the `tcpdump`
    command to filter out only the traffic that we are interested in: traffic from
    the host `192.168.33.11`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used the "`and`" operator to tell `tcpdump` to only print traffic that
    is to/from port `3306` and to/from host `192.168.33.11`.
  prefs: []
  type: TYPE_NORMAL
- en: The `tcpdump` command has many possible filters and operators; however, out
    of all of them, I would recommend becoming familiar with filtering based on port
    and host as these will suffice for most occasions.
  prefs: []
  type: TYPE_NORMAL
- en: If we break down the preceding captured network trace, we can see some interesting
    information; to make it a bit easier to spot, let's trim the output down to show
    just the IPs and flags being used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: From this information, we can see the `SYN` packets being sent from `blog.example.com`
    (`192.168.33.11`) and arriving on `db.example.com` (`192.168.33.12`). What we
    don't see, however, are the returned `SYN-ACKS`.
  prefs: []
  type: TYPE_NORMAL
- en: This tells us that we have at least found the source of the networking issue;
    the server `db.example.com` is not correctly replying to packets received from
    the blog server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the question is: What can cause this type of problem? There are many reasons
    for this issue to occur; in general, however, such an issue is due to a misconfiguration
    in the network configuration settings. Given the information that we have gathered,
    we can hypothesize that the database server is simply misconfigured.'
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, several ways to cause this type of problem with misconfigurations.
    In order to identify the possible misconfigurations, we can use the `tcpdump`
    command to capture all the network traffic on this server.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous examples of `tcpdump`, we always specified a single interface
    to watch. In most cases, this is appropriate for the issue as it reduces the volume
    of data being captured by `tcpdump`. On very active servers, a few minutes of
    `tcpdump` data can be very large, so it is always best to reduce the data to only
    what is required.
  prefs: []
  type: TYPE_NORMAL
- en: In some occasions, however, such as this issue, it is useful to tell `tcpdump`
    to capture the network traffic from all interfaces. To do this, we simply specify
    `any` as the interface to watch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have `tcpdump` capturing and saving all traffic on all interfaces,
    we will need to refresh our browser again to force the WordPress application to
    attempt database connections.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: After a few tries, we can stop the `tcpdump` again by pressing *Ctrl* + *C*.
    With the captured network data saved to a file, we can start to investigate what
    is happening with these connection attempts.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `tcpdump` captured a large number of packets, we will once again use
    the `host` filter to limit results to the network traffic to and from `192.168.33.11`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: With the captured data, it seems that we have found the expected `SYN-ACK`.
    To show this in a clearer fashion, let's trim the output to just the IPs and flags
    in use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: With a clearer picture, we can see an interesting series of network packets
    being transmitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The first packet is an `SYN` packet from `192.168.33.11` to `192.168.33.12`
    on port `3306`. This is the same type of packet that we have captured with the
    earlier `tcpdump` executions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: However, we have not seen the second packet before. In the second packet, we
    see that it is an `SYN-ACK` (identified by `Flags [S.]`). The `SYN-ACK` is being
    sent from `192.168.33.12` on port `3306` to `192.168.33.11` on port `47339` (the
    port that sent the original `SYN` packet).
  prefs: []
  type: TYPE_NORMAL
- en: At the first glance, this seems to be a normal `SYN` and `SYN-ACK` handshake.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The third packet, however, is interesting as it is a clear indication of an
    issue. The third packet is a `RESET` packet (identified by `Flags [R]`) sent from
    `192.168.33.11`, the blog server. The interesting thing about this is that, when
    executing `tcpdump` on the blog server, we never captured a `RESET` packet. If
    we execute `tcpdump` again on the blog server, we can see this one more time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding `tcpdump` output, we never see either the `SYN-ACK` or the
    `RESET` packets on the blog server. This either means that the `RESET` is being
    sent by another system or the `SYN-ACK` packet is being rejected by the blog server's
    kernel before `tcpdump` can capture it.
  prefs: []
  type: TYPE_NORMAL
- en: When the `tcpdump` command captures network traffic, it does so after the kernel
    has processed this network traffic. This means that if, for any reason, the kernel
    is rejecting the packet, it will not be seen via the `tcpdump` command. Thus,
    it is possible that the blog server's kernel is rejecting the return packets from
    the database server before `tcpdump` is able to capture them.
  prefs: []
  type: TYPE_NORMAL
- en: An additional interesting point revealed by performing a `tcpdump` on the database
    is that, if we look at the `tcpdump` performed on `enp0s8`, we do not see the
    `SYN-ACK` packet. However, if we tell `tcpdump` to look at all the interfaces
    we use, `tcpdump` also shows the `SYN-ACK` packet to be coming from `192.168.33.12`.
    This suggests that the `SYN-ACK` is being sent from another interface.
  prefs: []
  type: TYPE_NORMAL
- en: To confirm this, we can run a `tcpdump` again, limiting the capture to packets
    that traverse the `enp0s8` interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: From this execution of `tcpdump`, we can yet again only see the `SYN` packets
    from the blog server. However, if we run the same `tcpdump` against all interfaces,
    we should see not only the `SYN` packets but also the `SYN-ACK` packets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The `SYN-ACK` packet being returned to `192.168.33.11` is sourced from `192.168.33.12`.
    Earlier, we identified that this IP is bound to the network device `enp0s8`. However,
    when we use `tcpdump` to look at all of the packets being sent, the `SYN-ACK`
    is not captured going out of `enp0s8`. This means that the `SYN-ACK` packet is
    being sent from a different interface.
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How does an `SYN` packet arrive on one interface and an `SYN-ACK` get returned
    from another? One possible answer is that this is due to a misconfiguration in
    the routing definitions on the database server.
  prefs: []
  type: TYPE_NORMAL
- en: Every operating system that supports networking maintains something called a
    **routing table**. This routing table is a collection of defined network routes
    that a packet should take. To give a bit of context around this concept, let's
    use the two interfaces `enp0s3` and `enp0s8` as examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: If we look at these two interfaces, we know that the `enp0s8` interface is connected
    to the `192.168.33.0/24` (`inet 192.168.33.12/24`) network and the `enp0s3` interface
    is connected to the `10.0.2.0/24` (`inet 10.0.2.16/24`) network.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to connect to the IP 10.0.2.19, the packets should not go out of
    the `enp0s8` interface, as the optimal route for these packets would be to route
    through the `enp0s3` interface. The reason that this is the most optimal route
    is that the `enp0s3` interface is already part of the `10.0.2.0/24` network, which
    contains the IP `10.0.2.19`.
  prefs: []
  type: TYPE_NORMAL
- en: The `enp0s8` interface is part of a different network (`192.168.33.0/24`) and
    therefore, is the less optimal route. In fact, the `enp0s8` interface may not
    even be able to route to the `10.0.2.0/24` network.
  prefs: []
  type: TYPE_NORMAL
- en: Even though `enp0s8` may be a less optimal route, the kernel does not know this
    without a corresponding entry in the routing table. To dig deeper into our issue,
    we will need to view the routing table on this database server.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the routing table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Linux, there are a few ways to see the current routing table; in this section,
    I am going to cover two. The first method will utilize the `netstat` command.
  prefs: []
  type: TYPE_NORMAL
- en: To use the `netstat` command to view the routing table, simply run it with the
    `–r` (route) or `--route` flag. In the following example, we will also use the
    `-n` flag to prevent `netstat` from performing DNS lookups.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: While `netstat` might not be the best Linux command to print the routing table,
    there is a very specific reason for using it in this example. As I mentioned earlier
    in this chapter and book, the `netstat` command is a universal tool that exists
    on almost every modern server, router, or desktop. By knowing how to look at the
    routing table with `netstat`, you can perform basic network troubleshooting on
    any operating system that has `netstat` installed.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it is a safe bet that the `netstat` command would be available and
    can provide you with at least the basic details of the system's networking status
    and configurations.
  prefs: []
  type: TYPE_NORMAL
- en: The format of `netstat` can be a bit cryptic compared with the other utilities
    such as the `ip` command. However, the preceding routing table shows us quite
    a bit of information. To get a better understanding, let's break down the output
    route by route.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the output of the `netstat` command has multiple columns, eight
    to be precise. The first column is the `Destination` column. This is used to define
    what destination address is in scope for the route. In the preceding example,
    the destination is `0.0.0.0`, which is essentially a wildcard value meaning that
    any and everything should be routed via this table entry.
  prefs: []
  type: TYPE_NORMAL
- en: The second column is `Gateway`. The gateway address is the next hop that the
    network packets utilizing this route should be sent to. For this example, the
    next hop or gateway address is set to `10.0.2.2`; this means that any packets
    being routed via this table entry will be sent to `10.0.2.2`, which should then
    route the packets to the next system until they reach their destination.
  prefs: []
  type: TYPE_NORMAL
- en: The third column is `Genmask`, which is essentially a way of stating the "`generality`"
    of the route. Another way of thinking about this column is as a `netmask`; in
    the preceding example, the "`genmask`" is set to `0.0.0.0`, which is an open scope.
    This means that packets to anywhere should be routed out of this routing table
    entry.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth column is the `Flag` column, which is used to provide specific information
    about this route. The `U` value in the example means that the interface to use
    for this route is in an up state. The `G` value is used to show that the route
    utilizes a gateway address. In the preceding example, we can see that our route
    utilizes a gateway address; however, not all of this system's routes do.
  prefs: []
  type: TYPE_NORMAL
- en: The fifth, sixth, and seventh columns are not frequently used on Linux servers.
    The `MSS` column is used to show the **maximum segment size** specified for this
    route. The value of 0 means that this value is set to the default and not altered.
  prefs: []
  type: TYPE_NORMAL
- en: The `Window` column is the TCP window size, which denotes the maximum amount
    of data that will be accepted in a single burst. Again, when the value is set
    to 0, the default size will be used.
  prefs: []
  type: TYPE_NORMAL
- en: The seventh column is `irtt`, which is used to specify the **Initial Round-trip
    Time** for this route. The kernel will resend packets that are never responded
    to by setting an initial round-trip time; you can increase or decrease the time
    after which the kernel considers packets lost. As in the case of the previous
    two columns, the value of 0 means that the default value will be used for packets
    using this route.
  prefs: []
  type: TYPE_NORMAL
- en: The eighth and the last column, the `IFace` column, is the network interface
    that the packets utilizing this route should use. In the preceding example, this
    is the `enp0s3` interface.
  prefs: []
  type: TYPE_NORMAL
- en: The default route
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first route in our example is actually a very special route for our system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the details of this route and the definition of each column, we
    can determine that this route is the default route for the server. The default
    route is a special route that is used "by default" when no other route supersedes
    it. To put it simply, if we have packets that are to be sent to an address such
    as `172.0.0.10`, these packets would go through the default route.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is that there is no other route in our database server's
    routing table that specifies the IP `172.0.0.10`. As such, the system simply sends
    packets to this IP through the default route, a catchall route.
  prefs: []
  type: TYPE_NORMAL
- en: We can identify that the first route is the server's default route because of
    the destination address of `0.0.0.0`, which essentially means anything. The second
    indication is the `Genmask` of `0.0.0.0`, which together with the destination
    means any IPv4 address.
  prefs: []
  type: TYPE_NORMAL
- en: It is also typical of the default route to use a gateway address, so the fact
    that the gateway is set with wildcards for `destination` and `genmask` is a clear
    indication that the abovementioned route is the default route.
  prefs: []
  type: TYPE_NORMAL
- en: 'A non-default route will commonly look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The abovementioned route has a destination of 10.0.2.0 and a `genmask` of 255.255.255.0;
    this is essentially saying that anything in the 10.0.2.0/24 network would match
    this route.
  prefs: []
  type: TYPE_NORMAL
- en: Since the range of this route is `10.0.2.0/24`, it is likely that this route
    was added by the `enp0s3` interface configuration. We can determine this on the
    basis of the `enp0s3` interface configuration, as it is attached to the `10.0.2.0/24`
    network, which is the target of this route. By default, Linux will automatically
    add routes on the basis of the network interface's configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This route is a way for the kernel to ensure that communication for the `10.0.2.0/24`
    network goes out of the `enp0s3` interface, as this route will supersede the default
    route. With network routing, the most specific route will always be used. Since
    the default route is a wildcard and this route is specific to the `10.0.2.0/24`
    network, this route will be used for anything within the network.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing IP to show the routing table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another tool for reviewing the routing table is the `ip` command. The `ip` command,
    as we can see from its use within this chapter, is a very extensive utility and
    can be used for practically everything network-related on a modern Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: One use for the `ip` command is to add, remove, or show network routing configurations.
    To display the current routing table, simply execute the `ip` command with the
    `route show` options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: While learning to use the `netstat` command is important for non-Linux operating
    systems, the `ip` command is an essential tool for any Linux network troubleshooting
    or configuration.
  prefs: []
  type: TYPE_NORMAL
- en: As we use the `ip` command for troubleshooting routes, we may even find it easier
    than the `netstat` command. One example is finding the default route. When the
    `ip` command displays the default route, it uses the word default as the destination
    rather than 0.0.0.0, a method that is much easier to understand especially for
    newer system administrators.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also easier to read other routes as well. For instance, earlier while
    looking at routes via `netstat`, our example route looked like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `ip` command, the same route is shown in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: In my opinion, the format of `ip` route show is a much simpler format than the
    format of the `netstat -rn` command.
  prefs: []
  type: TYPE_NORMAL
- en: Looking for routing misconfigurations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we know how to look at the routing table on the server, we can use
    the `ip` command to find any routes that may cause issues with our database connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see five routes defined on our system. Let's break down these routes
    to get a better understanding of them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The first two routes we have already covered and will not review again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The third route defines that all traffic from `169.254.0.0/16` (`169.254.0.0`
    to `169.254.255.255`) is sent via the `enp0s8` device. This route is a very broad
    route but most likely does not impact our routing to the IP `192.168.33.11`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The fourth and fifth route, however, will change how network packets to 192.168.33.11
    are routed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The fourth route defines that all the traffic to the `192.168.33.0/24` (`192.168.33.0`
    to `192.168.33.255`) network is routed out of the `enp0s8` interface and sourced
    from `192.168.33.12`. This route appears to also be added automatically by the
    `enp0s8` interface's configuration; this is similar to the earlier route added
    by `enp0s3`.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `enp0s8` device is defined to be a part of the `192.168.33.0/24` network,
    it only makes sense to route traffic for this network out of this interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The fifth route, however, defines that all traffic to the specific IP `192.168.33.11`
    (the blog server's IP) is sent to the gateway of `10.0.2.1` via the `enp0s3` device.
    This is interesting because the fifth route and the fourth route have a very conflicting
    configuration, as they both define what to do with IPs in the `192.168.33.0/24`
    network.
  prefs: []
  type: TYPE_NORMAL
- en: More specific routes win
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As mentioned earlier, the *golden rule* of routing network packets is that the
    more specific route always wins. If we look at the routing configuration, we have
    one route that says all traffic in the `192.168.33.0/24` subnet should go out
    the `enp0s8` device. There is also a second route that says specifically `192.168.33.11`
    should go out through the `enp0s3` device. The IP `192.168.33.11` applies to both
    of these rules but which route should the system send packets through?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is always the more specific route.
  prefs: []
  type: TYPE_NORMAL
- en: Since the second route specifically defines that all traffic to `192.168.33.11`
    goes out of the `enp0s3` interface, the kernel will route all return packets through
    the `enp0s3` interface. This is the case irrespective of the route defined for
    `192.168.33.0/24` or even the default route.
  prefs: []
  type: TYPE_NORMAL
- en: We can see all of this in action by using the `ip` command with the `route get`
    options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The `ip` command with the `route get` options will take the IP provided and
    output which route the packets will take.
  prefs: []
  type: TYPE_NORMAL
- en: When we use this command with `192.168.33.11`, we can see that `ip` specifically
    shows that the route will be through the `enp0s3` device. If we use the same command
    with the other IPs, we can see how the default route and the `192.168.33.0/24`
    routes are used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: We can see here that when an IP address that is within a subnet with a specific
    route defined is provided, this specific route is taken. However, when an IP is
    not defined by a specific route, the default route is taken.
  prefs: []
  type: TYPE_NORMAL
- en: Hypothesis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand how packets to `192.168.33.11` are routed, we should
    adjust our previous hypothesis to reflect that the route of `192.168.33.11` to
    `enp0s3` is not correct and is causing our issue.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, what is happening (and we see this via `tcpdump`) is that, when
    the database server (`192.168.33.12`) receives a network packet from the blog
    server (`192.168.33.11`), it arrives on the `enp0s8` device. However, when the
    database server is sending reply packets (`SYN-ACK`) to the web application server,
    the packets are being sent out via the `enp0s3` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `enp0s3` device is connected to the `10.0.2.0/24` network, it seems
    that the packet is being rejected (`RESET`) by another system or device on the
    `10.0.2.0/24` network. Most likely, this is due to the fact that this is a prime
    example of asynchronous routing.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous routing is where a packet arrives on one interface but is replied
    to on another. In most network configurations, this is denied by default, but
    in some cases, can be enabled; however, these cases are not extremely common.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, since the `enp0s8` interface is part of the `192.168.33.0/24` subnet,
    it does not make sense to enable asynchronous routing. Our packets to `192.168.33.11`
    should simply be routed via the `enp0s8` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Trial and error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have identified our issue with data collection and established
    a possible cause with our hypothesis, we can start our next troubleshooting step:
    using trial and error to correct the issue.'
  prefs: []
  type: TYPE_NORMAL
- en: Removing the invalid route
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To correct our issue, we need to remove the invalid route for `192.168.33.11`.
    To do this, we will yet again use the `ip` command, this time with the `route
    del` options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we used the `ip` command with the `route del` options
    to remove a route that targets a single IP. We can use the same command and options
    to remove routes that are defined for subnets. The following example will remove
    the route for the `169.254.0.0/16` network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'From the `ip` route show execution, we can see that there is no longer a conflicting
    route for `192.168.33.11`. The question is: Did this fix our issue? The only way
    to know for sure is to test it and to do this we can simply refresh our browser
    that has the blog''s error page loaded.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing the invalid route](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It seems that we were successful at correcting the issue. If we perform a `tcpdump`
    now, we can validate that the blog and database servers are able to communicate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output is what we would expect to see from a healthy connection.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we see four packets, the first is an `SYN` (`Flags [S],`) from `blog.example.com`
    (`192.168.33.11`), followed by an `SYN-ACK` (`Flags [S.],`) from `db.example.com`
    (`192.168.33.12`) and an `ACK` (or `SYN-ACK-ACK`) (`Flags [.],`) from `blog.example.com`
    (`192.168.33.12`). These three packets are the completed TCP three-way handshake.
    The fourth packet is a `PUSH` (`Flags [P.],`) packet, which is the actual transfer
    of data. All of these are signs of a good working network connection.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have removed the invalid route from the routing table, we can see
    the blog is working; this means we have finished, right? No, not yet at least.
  prefs: []
  type: TYPE_NORMAL
- en: When we removed the route by using the `ip` command, we removed the route from
    the active routing table, but we did not remove the route from the system as a
    whole. If we were to restart networking, or simply reboot the server, this invalid
    route would reappear.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: This is because, when the system boots, it configures the network on the basis
    of the configurations within a set of files. The `ip` command is used to manipulate
    the live network configuration, but not these network configuration files. So,
    any change made with the `ip` command is not made permanently, but is only temporarily
    until the next time the system reads and applies the network configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully remove this route from the network configuration, we will
    need to modify the networking configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: On Red Hat Enterprise Linux-based systems, the networking configuration files
    are mostly stored within the `/etc/sysconfig/network-scripts` folder. To get started,
    we can first switch to this folder and execute ls –la to identify the current
    network configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: From the directory listing, we can see several configuration files. In general,
    however, we will mostly only be interested in files that begin with "`ifcfg-`"
    and files that begin with "`route-`."
  prefs: []
  type: TYPE_NORMAL
- en: The files that begin with "`ifcfg-`" are used to define network interfaces;
    the naming convention of these files is "`ifcfg-<device name>`"; for example,
    to see `enp0s8's` configuration, we could read the `ifcfg-enp0s8` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: We can see that this configuration file defines the IP address and `Netmask`
    used for this interface.
  prefs: []
  type: TYPE_NORMAL
- en: The "`route-`" files are used to define the system's routing configuration.
    The convention for this file is similar to that of the interface files, "`route-<device
    name>`." In the folder listing, there was only one route file, `route-enp0s3`.
    This is the most likely location for the incorrect route to be defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: In general, unless a static route (routes that are statically defined) is defined,
    the "`route-*`" files do not exist. We can see here that only one route is defined
    in this file, which means that all the other routes defined in the routing table
    are dynamically configured on the basis of the interface configurations.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the route defined in the `route-enp0s3` file does
    not specify an interface. Because of this, the interface will be defined on the
    basis of the filename; if this same entry were in the route-`enp0s8` file, the
    network service would attempt to define the route on the `enp0s8` interface.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that this route no longer appears in the routing table, we need to
    remove it from this file; alternatively, in this case, since it is the only route,
    we should remove the file in its entirety.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: The decision to remove the file and the route is dependent on the environment
    being supported; if you are ever unsure if this is the correct action, you should
    ask someone who can tell you if it is or isn't beforehand. For this example, we
    will assume that it is OK to remove this network configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: After restarting the network service, we should see the route disappear.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Now that the route is gone and the network configurations have been reloaded,
    we can safely say that we have corrected the issue. We can validate this by once
    again loading the webpage to ensure that the blog is working.
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuration files](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we look back at this chapter, we learned quite a bit about troubleshooting
    network connectivity issues on Linux. We learned how to use the `netstat` and
    `tcpdump` tools to look at the incoming and outgoing connections. We learned about
    the TCP three-way handshake and how the `/etc/hosts` file can supersede the DNS
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered many commands, and while we gave a pretty good overview
    of each command and what it does, there are some that we barely scratched the
    surface on.
  prefs: []
  type: TYPE_NORMAL
- en: Commands such as `tcpdump` are a prime example of this. In this chapter, we
    used `tcpdump` quite a bit, but this tool is capable of far more than we used
    it for. Of all of the commands that we covered in this book, I personally feel
    that `tcpdump` is one to spend time learning, as it is a very useful and powerful
    tool. I have used it to solve many issues, and sometimes, these issues were not
    network-specific but application-specific.
  prefs: []
  type: TYPE_NORMAL
- en: In this next chapter, we will keep this networking momentum going with troubleshooting
    firewalls. We will probably see some of the same commands that we used in this
    chapter reappear in the next chapter, but this is OK; it just shows how important
    it is to understand networking and the tools to troubleshoot it.
  prefs: []
  type: TYPE_NORMAL
