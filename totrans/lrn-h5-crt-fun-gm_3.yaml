- en: Chapter 3. Understanding the Gravity of HTML5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into the game that we'll build in this chapter, we will examine
    why writing applications in HTML and JavaScript can be difficult when deploying
    in multiple different browsers. We will focus on simple and practical solutions
    to these problems, especially with regards to HTML5 and the latest APIs used today.
  prefs: []
  type: TYPE_NORMAL
- en: The game we will build in this chapter will be a basic jelly wobbly gravity
    game. It will make use of HTML5's new API for vector graphics, native audio manipulation,
    and drag-and-drop. As the backbone of the rendering system for this game, we will
    use the old JavaScript timer, which, as we will see, is not at all appropriate
    for games such as this one where we need multiple updates per second. Thankfully,
    modern browsers have solved this issue, and taken into account the need we have
    for highly efficient rendering engines. However, we won't be discussing this new
    feature until the next game. Just for completion, this new feature is known as
    **requestAnimationFrame**.
  prefs: []
  type: TYPE_NORMAL
- en: Browser compatibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Anyone who has done any web development at all has quickly developed a very
    deep, profound, and thorough hatred towards the way different browsers interpret
    and render the same code. However, if we dig a bit deeper into this phenomena,
    and look for the root cause of these discrepancies, it will surprise some people
    to realize that the problem is not what it seems. While finding the cause for
    rendering differences is easy, for example, some browsers define the box model
    differently, finding the cause for differences in code may not be so clear. Surprisingly,
    some developers seem to despise the JavaScript language because some code runs
    differently in some browsers. However, the truth of the matter is that JavaScript
    is actually quite portable, and its API is quite stable and consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Believe it or not, most of these headaches are caused by the DOM API, and not
    JavaScript itself. Some browsers register DOM-related events one way, while other
    browsers don't acknowledge that method, and instead use their own variation for
    it. The same goes for manipulating DOM elements and subtrees.
  prefs: []
  type: TYPE_NORMAL
- en: For example, one way to remove a node from the DOM is to call the `remove` method
    on the node itself. However, as of this writing, only a very limited handful of
    browsers expose this functionality. Most commonly, browsers allow us to remove
    a node from a DOM tree by calling the `removeChild` method on a parent node, passing
    a reference to the child node to be removed from the parent.
  prefs: []
  type: TYPE_NORMAL
- en: The key point to be made here is this; JavaScript itself is very consistent
    across browsers, but the way that browsers allow us to programmatically interact
    with the DOM, although this is most commonly done via JavaScript, may vary from
    browser to browser. While none of this is news to anybody, and certainly is not
    unique to HTML5, it is still important to remember that the main tool we have
    for programming the web platform, that is, JavaScript, is a very powerful and
    consistent one. The problem that we need to keep in mind is the DOM API (as well
    as CSS, although this particular issue is becoming less and less of an issue,
    as browsers are beginning to agree on common standards related to that).
  prefs: []
  type: TYPE_NORMAL
- en: Supporting different browsers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are different approaches that we can take when developing an HTML5 application
    in order to ensure that the code runs the same in different browsers, and that
    the design is rendered the same as well. Some of these practices are painful and
    tedious, others are unreliable, and others are simply good enough. Unfortunately,
    as long as there are so many browser differences as there are today, there will
    never be one single silver bullet that completely makes the problem disappear.
  prefs: []
  type: TYPE_NORMAL
- en: The two main goals when it comes to writing code that runs practically identical
    in different browsers are; write as little unique code to each browser as possible,
    and write code that degrades gracefully. It is one thing to specifically target
    a couple of unique features specific to a particular browser, but it is a completely
    different issue to maintain two or more separate code bases. Remember this, that
    the best code you can possibly write, both in terms of efficient execution and
    security, is the code that you never have to write at all. The more code you write,
    the more subject to errors and faults your code will be. Thus, avoid writing too
    much code that does the same thing as other code you're also writing, but writing
    it uniquely for a different browser.
  prefs: []
  type: TYPE_NORMAL
- en: While being a perfectionist can be a great attribute, we must be realistic that
    we won't achieve perfection any time soon. Not only that, but in most cases (certainly
    in all cases where a video game is involved) we don't need to write software that
    is anywhere near perfect. At the end of the day, whether you agree with it or
    not, the goal of software development is to produce software that is good enough.
    As long as the program solves the problem for which it was written, and does so
    in a reasonable fashion, then for all practical purposes, we can say that the
    software is good.
  prefs: []
  type: TYPE_NORMAL
- en: With that introduction behind us, keep those two principles in mind as you develop
    HTML5 applications, including games, aimed at reaching hundreds of millions of
    people world wide. True, there are some browser-specific functionalities that
    may make a game unplayable, or at least make the user experience significantly
    different, that the final result might not be desirable. But, pay close attention
    to what you're really trying to accomplish, so as to discern what browser differences
    are good enough. It may very well be that a feature targeted to a particular browser
    is used by so few users that there is no cost benefit to the feature. What we
    never want to do, however, is to deploy an unusable product.
  prefs: []
  type: TYPE_NORMAL
- en: HTML5 libraries and frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our quest for multiple browser support in cost efficient ways, we can find
    comfort in knowing that we're not alone in this struggle. Today, there are so
    many open source projects aimed at solving this same problem of browser compatibility
    that we can possibly play the alphabet game, where we name a different HTML5 library
    or framework for each letter of the alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: There are normally two reasons for the existence of such tools, namely to abstract
    away browser differences, and to speed up development. While most abstractions
    provided by today's JavaScript tools attempt to provide the client with a single
    interface that unifies browser discrepancies, a lot of these libraries also provide
    functionality that simply speed development time and effort.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By far, the most popular JavaScript library is one called jQuery. If you haven't
    heard of jQuery before, chances are that you just woke up from a very deep and
    profound hibernation, while your body traveled through distant galaxies. Some
    of the main benefits for using jQuery includes a very powerful DOM query and manipulation
    engine, a very simple, unified **XHR** (**XML HTTP Request** also known as Ajax)
    interface, and the ability to extend it through a well defined plugin interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'One example of how using a JavaScript library, particularly jQuery, can save
    you development time and effort is trying to make an asynchronous request to your
    server. Without jQuery, there is a bit of boilerplate code that we''d need to
    write so that different browsers all behave the same. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in contrast, that exact functionality can be achieved with the following
    code using jQuery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the awesome things about jQuery''s XHR functionality is that it is highly
    flexible. At a bare minimum, we can achieve the same behavior as in the previous
    code, in a completely cross-browser fashion, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In conclusion, much can be done with very little effort, time, and code, with
    jQuery. All of this also comes with the added benefit that the library is developed
    by a very dedicated team, with a very involved and active community behind it.
    For more information about jQuery, check out the official website at [http://www.jquery.com](http://www.jquery.com).
  prefs: []
  type: TYPE_NORMAL
- en: Google Web Toolkit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another popular and extremely powerful JavaScript tool is **Google Web Toolkit**
    (**GWT**). First of all, GWT is not a mere library that provides a handful of
    abstractions on top of JavaScript, but rather a full blown development toolkit
    that uses the Java language (which itself comes with all of its benefits), then
    compiles and translates the Java code into highly optimized, browser-specific
    JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: It is silly to try to compare jQuery with GWT, as each solve different problems,
    and take a completely different look at web development. However, it is worth
    saying that while jQuery is a great tool that is currently found in the toolbox
    of nearly every web developer today, it is not intended for, nor is it a very
    good fit for actual game development. Google Web Toolkit, on the other hand, while
    not the most appropriate tool for small, trivial HTML and JavaScript projects,
    lends itself very well to game development. In fact, the popular game Angry Birds
    used Google Web Toolkit in the development of the Google Chrome version of the
    game.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, while GWT is enough a subject to occupy its own book, it is a
    great tool to consider when you take on your next large web development project,
    where one of the goals is to provide multiple browser support to your application.
    For more information about Google Web Toolkit, check out the official website
    at [https://developers.google.com/web-toolkit/](https://developers.google.com/web-toolkit/).
  prefs: []
  type: TYPE_NORMAL
- en: Supporting browsers with limited HTML5 features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As was previously mentioned, none of the browser-caused development headaches
    mentioned above are new with, or specific to, HTML5\. However, it is important
    to know that this same problem has not gone away with HTML5 (yet). Furthermore,
    HTML5 brings with it a whole new level of cross-browser nightmares. For instance,
    while most HTML5 related APIs are well defined in a documented specification,
    there are also many APIs that are currently in an experimental stage (for a discussion
    on experimental APIs and vendor prefixes, refer back to the online chapter, *Setting
    up the Environment*, and [Chapter 2](ch02.html "Chapter 2. HTML5 Typography"),
    *HTML5 Typography*, where the topic is more thoroughly discussed). On top of that,
    there are also browsers that don't yet support some HTML5 features, or currently
    offer limited support, or worse yet, they provide support through a different
    interface than other browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Again, as web developers we must always have the user at the top of the list
    of priorities when creating a new application. Since the problem of browser compatibility
    is still among us, some people feel that HTML5 is still a thing for the future,
    and the usefulness of its new features remain yet to be seen. The rest of this
    section will describe ways that we can use HTML5 today without having to worry
    about less desirable browsers, and yet provide a functional application to users
    using such browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Gracefully degrade
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you pay close attention to the previous code snippet where we attempted to
    create an **XHR** object that works in many different browsers, you will notice
    that the code deliberately halts execution if the browser executing the code doesn't
    support one of the two options the code searched for. That is a great example
    of what we should not do, if at all possible. Whenever a specific feature is not
    available to a certain browser, the first option should be to provide an alternative
    construct, even if this alternative method doesn't quite provide the same behavior.
    We should do all that we can to at least provide a functional experience in the
    worst case scenario, where the browser has zero support for what we're trying
    to accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: For example, HTML5 provides a new storage mechanism that's similar to a cookie
    (in other words, a simple key-value pair storage), but with the main difference
    being that this storage mechanism stores the data completely in the client, and
    that data is never sent back and forth to the server as part of the HTTP request.
    While the specifics of what this storage system is and how it works will be covered
    later in the book, we can summarize it by saying that this storage system (called
    Local Storage) stores key-value pairs, and does so through a well defined interface,
    and from a property of the Window object named `localStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: One powerful application for Local Storage is to cache asynchronous requests
    made by the user, so that the subsequent requests can be fetched directly from
    the browser's local storage, thus avoiding the round trip to the server. However,
    if a browser doesn't support local storage, the worst case scenario in this particular
    case would be that the application would need to fetch a subsequent request from
    the server again. While not practical or efficient, this is by far a problem one
    should not lose sleep over, except if that means that we'll need to write lots
    of extra code to test for the presence of the `localStorage` object every time
    we need to use it, thus polluting the code base with many repetitive conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple solution to a problem such as this is to use polyfills, which we''ll
    discuss more in depth next. In short, though, a polyfill is a JavaScript alternative
    that the browser can use when the original implementation is not yet available.
    This way, you can load the polyfill if the browser needs it, and the rest of the
    code base can use the functionality through the original interface, and never
    know which implementation it is working with. In the case of `localStorage`, we
    could simply check whether the authentic API is available, and write code that
    mimics its behavior if it is not available. The following code snippet shows this
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Although the preceding polyfill really doesn't store any data beyond the current
    session, this particular implementation of a local storage polyfill can be enough
    for the needs of a given application. At the very least, this implementation allows
    us to code to the official interface (calling the real methods defined by the
    specification), and no exceptions are thrown by the browser, since the methods
    are indeed present. Eventually, whenever the browser that didn't support the HTML5
    API, and thus used our polyfill because of the conditional that checked for browser
    support of the feature, that conditional will no longer trigger the polyfill to
    be loaded, thus the client code will always refer to the original implementation
    and no changes will be needed to the main source code.
  prefs: []
  type: TYPE_NORMAL
- en: While it is quite exciting to consider what polyfills can do for us, the observant
    student will quickly notice that writing complete, secure, and accurate polyfills
    is slightly more complicated than adding simple CSS hacks to a style sheet in
    order to make a design compatible with different browsers. Even though the sample
    local storage polyfill shown previously was relatively complicated, it does not
    completely mimic the official interface, and neither does it behave 100 percent
    the same with the little functionality that it did implement. Soon the organized
    student will ask how much time he or she should expect to spend writing bullet-proof
    polyfills. The answer, which I'm glad to report is a positive one, is given and
    explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Polyfills
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To answer the preceding question, that is, how much time should you expect to
    spend writing your own robust polyfills in order to be able to start using HTML5
    features today, and still have your code run on multiple different browsers is,
    zero. Unless you really want the experience of writing a fallback for different
    browsers, there is no reason to cook your own libraries and such, since much work
    has already been done on this area by hundreds of other developers who have shared
    their work with the community.
  prefs: []
  type: TYPE_NORMAL
- en: With polyfills, there really isn't a single JavaScript import that we can use
    at the top of our HTML5 project that will magically extend every deficient browser,
    and make them 100 percent HTML5 ready. However, there are many separate projects
    available, so that if you're trying to use a particular element, you can simply
    import that particular polyfill. While there is no definitive source where all
    of these polyfills can be found, a simple Google or Bing search for the particular
    functionality you want should quickly connect you to an appropriate polyfill.
  prefs: []
  type: TYPE_NORMAL
- en: Modernizr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One particular tool that is worth mentioning is Modernizr. This JavaScript library
    inspects the page that loads it, and detects which HTML5 features are available
    in the user's browser. This way, we can very easily check whether or not a particular
    API is available, and take action accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: As of this writing, the current version of Modernizr allows us to test for a
    particular API or feature, and load specific polyfills in the case that the test
    returns positive or negative, which makes adding polyfills when needed very easy
    and effortless.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, Modernizr also includes HTML5 Shiv, which is a very small piece
    of JavaScript that allows us to use all of the HTML5 semantic tags in browsers
    that don't recognize them. Note that this will not add the actual functionality
    of the tags, but will merely allow you to style those tags through CSS. The reason
    is that in Internet Explorer Version 8 and below, if we try to style an element
    that the browser doesn't recognize, it will simply ignore any CSS applied to it.
    With Modernizr, however, those elements are created (using JavaScript), so that
    the browser then knows about the tags, and thus allows CSS to be applied to them.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about Modernizr, check out the official website at [http://modernizr.com/](http://modernizr.com/).
  prefs: []
  type: TYPE_NORMAL
- en: The game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project game we'll build in this chapter is simply called *Basic Jelly Wobbling
    Gravity Game*. The goal of the game is to feed our main hero enough jelly that
    he gets sick and drops to the floor with a severe tummy ache. The main character
    is controlled through the left and right arrow keys on the keyboard, and in order
    to eat a jelly, you simply have to direct the hero underneath a falling jelly.
    Every time you feed the hero a jelly, his health meter decreases slightly. Once
    enough jelly has been fed, and the health meter reaches zero, the hero gets too
    sick and faints. If you let a jelly drop on the floor, nothing happens except
    that the jelly splashes everywhere. This is a Basic Jelly Wobbling Gravity Game.
    Can you serve Prince George enough jelly until he passes out?
  prefs: []
  type: TYPE_NORMAL
- en: '![The game](img/6029OT_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In order to demonstrate a few principles about HTML5 game development, we'll
    build this game completely with DOM elements. While this approach is normally
    not the desired approach, you will notice that many games still perform quite
    nicely on most modern browsers, and on the average desktop or laptop computer
    today. However, as we'll learn in the chapters to follow, there are a few techniques,
    tools, and APIs available to us in HTML5 that are far more appropriate for game
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as is common to this book, most game elements will be kept to a minimum
    in terms of complexity, so that it can be explained and understood easily. Specifically
    in this game, we'll only use SVG graphics as a proof of concept instead of diving
    deeply into the potential and opportunity available to us through the SVG standard.
    The same goes for drag-and-drop, as there is so much more that can be done with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Code structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way this code is structured is very straightforward. Every element in the
    game is absolutely positioned through CSS, and each element is made up of some
    HTML container styled with a background image or some CSS3 properties that give
    it a fresh look with rounded corners, drop shadows, and so on. Also, although
    some people might prefer object oriented programming to functional programming,
    and better cohesion instead of global variables everywhere, we'll take exactly
    that approach in this game, and focus on the HTML5 aspects instead of the design
    of the game. The same goes for the style and quality of the graphics. All that
    you see in this game was created by myself using a free photo editor program,
    and it took me no longer than 30 minutes to create all of the graphics you see
    in the game. This was mostly to show that fun games can be built even if you're
    on a budget, or don't have a dedicated graphics design team.
  prefs: []
  type: TYPE_NORMAL
- en: Since we're loading all of the SVG entities right inline with our HTML structure,
    we place them inside a `div` container that is hidden from the user, then we clone
    each entity that we need a copy of and use it on the game. We use this technique
    for all of the jellies and the hero. The hero SVG is left the same as what was
    exported from the vector editor software. The jelly SVG is slightly modified by
    removing all of the colors that they were designed with, and replaced with CSS
    classes. This way we can create different CSS classes that specify different colors,
    and each new instance of the jelly SVG is assigned a random class. The final result
    is one single SVG model hidden inside the invisible `div` container, and each
    instance of it, using zero extra code, is given a different color to add variety
    to the game. We could also have randomly assigned a different size and rotation
    to each jelly instance, but this was left out for an exercise to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Although we could have used data attributes instead of ID attributes for all
    of those elements, there would have been no real benefit over using them over
    the IDs, just as there is really no benefit in using IDs over data-attributes
    in this situation.
  prefs: []
  type: TYPE_NORMAL
- en: Note how there are two targets where the `bowl-top` can be dragged onto. Actually,
    there is really only one, which is the element `bowl-top-target`. The other element
    that looks like a target, which was cleverly given an ID of `bowl-top-faux-target`,
    is only there for the visual effect. Since a real drop target (an element where
    a draggable element can be placed at the end of a drag option) is only activated
    once the mouse pointer moves over it, there wasn't enough room on that table to
    accomplish the desired effect of showing a small outlined area where `bowl-top`
    appears to be dropped.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there is one global timer used in the game, which controls the frequency
    at which we call the game loop function, named `tick()`. Although this is not
    a chapter on proper game design, I will point out that you should avoid the temptation
    to create multiple timers for different purposes. Some people out there won't
    think twice before firing off an event through a unique timer separate from the
    main game timer. Doing so, especially in HTML5 games, can have negative side effects
    both in performance and in synchronizing all of the events.
  prefs: []
  type: TYPE_NORMAL
- en: API usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The three APIs used in this game are audio, SVG, and drag-and-drop. A brief
    explanation of how each of these APIs were used in the game will follow, where
    only a general overview of the feature is given. In the next section, however,
    we'll take a detailed look at what each of these features actually do, and how
    we can use it in this and other situations. For the complete source code for this
    game, check out the book's page from Packt Publishing's website.
  prefs: []
  type: TYPE_NORMAL
- en: Web audio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Audio was used both for a never-ending loop used as a background song, as well
    as individual sound effects that are fired off when a jelly is launched up, bounces
    off the walls, splatters on the floor, or is eaten by the hungry hero. An old
    school sound effect is also fired off when the hero finally dies from eating too
    much jelly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way that each audio entity is managed in the game is through a simple encapsulation
    that holds references to individual sound files, and exposes an interface allowing
    us to play a file, fade sound files in and out, as well as add new sound files
    to the list of audios managed by this class. The code for the same is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we instantiate a global object of this custom `SoundFx` type, where every
    sound clip used in the game is stored. This way, if we want to play any type of
    sound, we simply call the `play` method on this global reference. Take a look
    at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Scalable Vector Graphics (SVG)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned previously, the way SVG is used in the game is limited simply because
    the SVG spec is so robust and can get fairly complex. As you'll see in the in-depth
    description of the SVG API, there were a lot of things that we could have done
    to each individual primitive shape drawn through SVG (such as natively animating
    the hero's facial expressions, or making each jelly jiggle or rotate, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'The way we switch the sprite that represents a jelly into a splashed out jelly,
    when a jelly hits the floor is pretty clever. When we draw the jelly vectors using
    the vector editor software, we create two separate images, each representing a
    different state of the jelly. Both images are stacked on top of each other, so
    that they line up properly. Then, inside the HTML code, we assign a CSS class
    to each of these images. These classes are called jelly-block and splash, representing
    a jelly in its natural state, and a jelly splashed on the floor. In both of these
    classes, one of the vectors is hidden and the other is not. Depending on the state
    of each jelly element, these two classes are toggled back and forth. This is all
    done by simply assigning one of the two classes `jelly-svg-on` and `jelly-svg-off`
    to the parent svg element holding these two vector groups, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The way the preceding styles are driven is simple. By default, every jelly
    element is given a CSS class of `jelly-svg-on`, meaning that the jelly is not
    splashed. Then, when a jelly is calculated to have hit the floor, we remove that
    class, and add the CSS class of `jelly-svg-off`, as seen in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Drag-and-drop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to the way SVG was used in the game, drag-and-drop made its way into
    the final product taking a backseat to web audio. Yet, the role that drag-and-drop
    plays in the game is arguably the most important one, it starts the game. Instead
    of having the game start playing right away when the page first loads, or instead
    of having the user press a button or hit a key to start game play, the player
    needs to drag the lid away from the bowl where all the jellies are stored, and
    place it next to the bowl on the table where it sits.
  prefs: []
  type: TYPE_NORMAL
- en: The way drag-and-drop works in HTML5 is simple and intuitive. We register at
    least one object to be a draggable object (the one you drag around), and at least
    one other object to be a drop target (the object where the draggable can be dropped
    into). Then we register callback functions for whatever events we want that apply
    to the dragging and dropping behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In the game, we only listen for five events, two on the draggable element, and
    three on the drop target element. First, we listen for when the draggable is first
    dragged by the user (on drag start), which we respond to by making the bowl lid
    image invisible and placing a copy of the lid behind the mouse pointer, so that
    it appears that the user is truly dragging that lid.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we listened for the event that is triggered when the user finally releases
    the mouse button, indicating the end of the dragging action (on drag end). At
    this point, we simply restore the bowl lid back to where it was originally, on
    top of the bowl. This event is fired whenever the dragging action is finished,
    and the drop was not done inside a valid drop target (the user didn't drop the
    lid where it was expected), which essentially restarts the process.
  prefs: []
  type: TYPE_NORMAL
- en: The three events that we listen for on the drop target are the `onDragLeave`,
    `onDragOver`, and `onDrop`. Whenever a draggable is dropped inside a drop target,
    the target's `onDrop` event is fired. In this case, all we do is call the `startGame()`
    function, which sets the game in motion. As part of the set up for this `startGame`
    function, we move the bowl lid element into the exact pixel position where it
    was dropped, and remove the draggable attribute, so that the user can no longer
    drag that element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The functions `onDragOver` and `onDragLeave` are triggered whenever the mouse
    pointer is moved on top of, and hovered out of the target object, respectively.
    In our case, all we do in each of those functions is toggle the visibility of
    the bowl lid and the image that shows behind the cursor while the dragging is
    happening. This can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Web audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The new web audio API defines a way to play audio right into the browser without
    the need for a single plugin. For a high level experience, we can simply add a
    few audio tags throughout our HTML page, and the browser takes care of displaying
    a player for the user to interact with and play, pause, stop, rewind, fast forward,
    and adjust the volume. Alternatively, we can use the JavaScript interface available,
    and either control the audio tags on the page with it, or achieve much more powerful
    and complex tasks.
  prefs: []
  type: TYPE_NORMAL
- en: One key detail to remember about browser support and the web audio API, is that
    different browsers support different file formats. When defining an audio tag,
    similar to an image tag, we specify the path to the source file. The difference
    is that with audio, we can specify multiple sources for the same file (but different
    formats), then the browser can choose the file it supports, or the best option
    it has, in case it supports multiple file formats. Currently there are three audio
    formats supported by all major browsers, namely `.mp3`, .`wav`, and `.ogg`. As
    of this writing, no single audio format is supported in all major browsers, which
    means that whenever we use the web audio API, we'll need at least two versions
    of each and every file we play through the API, if we wish to reach the greatest
    possible audience.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, keep in mind that although we can (and should) specify multiple audio
    files per each audio element, each browser only downloads one of these files.
    This is a very handy (and obvious) feature because downloading multiple copies
    of the same file would be awfully inefficient and bandwidth heavy.
  prefs: []
  type: TYPE_NORMAL
- en: How to use it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest way to get started with the web audio API is with an inline HTML5
    element. The code for it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the above snippet to a page will not result in anything visible. In
    order to add more control to the tag, including adding a player to the page so
    that the user can interact with it, we can choose from the elements associated
    with the tag. These attributes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**autoplay**: It starts playing the file right away as soon as the browser
    has downloaded it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**controls**: It displays a visual player with buttons through which the user
    can control audio playback'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**loop**: It is used to continuously play the file indefinitely'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**muted**: It is used when audio output is muted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**preload**: It specifies how the audio resource is to be preloaded by the
    browser'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To achieve a similar result through JavaScript, we can create a DOM element
    of type audio, or instantiate a JavaScript object of type Audio. Adding the optional
    attributes can be done the same way we would to any other JavaScript object. Note
    that creating an instance of Audio has the exact same effect as creating a reference
    to a DOM element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Although the JavaScript Audio object may seem easier to deal with, especially
    since it takes that awesome constructor argument that saves us a whole line of
    code, they both behave exactly the same, and can only be told apart at run time
    if you really want to be picky and distinguish them from each other. One small
    detail that you should know is that when we create that audio reference in JavaScript,
    it is not necessary to append it to the DOM in order to play the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'However you decide to approach this setup step, once we have a reference to
    an audio object in JavaScript, we can control it with any one of the many events
    and attributes associated with the object. The audio objects are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**play()**: It starts playing the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pause()**: It stops playing the file, and maintains the currentTime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**paused**: Is a Boolean representing the current play state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**canPlayType**: Is used to find out whether the browser supports a particular
    audio type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**currentSrc**: It returns the absolute path to the file currently assigned
    to the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**currentTime**: It returns the current play position in seconds, as a floating
    point number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**duration**: It returns the total play time in seconds, as a floating point
    number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ended**: Is a Boolean indicating whether the currentTime is equal to duration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**readyState**: It indicates the state of the download of the source file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**volume**: It indicates the current volume of the file, ranging from 0 to
    1 both inclusive. This number is relative to the current system volume.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SVG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Scalable Vector Graphics** (**SVG**) for short, is an XML based format that
    describes graphics. This format may seem complicated enough to be confused with
    a full blown programming language for 2D graphics, but in truth it is just a markup
    language. While SVG may seem new to some web developers, the specification was
    first developed back in 1999.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main difference between a vector graphic and a raster graphic (in other
    words, a bitmap) is the way that the graphic is described. In a bitmap, each pixel
    is essentially represented by three or four numbers, representing the color of
    that individual pixel (RGB), along with a possible opacity level. Looking at it
    from a broader sense, a bitmap is nothing more than a grid of pixels. Vectors,
    on the other hand, are described by a series of mathematical functions that describe
    lines, shapes, and colors, instead of each individual point on the entire image.
    To put it in simple terms, vector graphics do a fantastic job of scaling its dimensions,
    as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SVG](img/6029OT_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you zoom in or try to stretch a vector graph, it will always be as smooth
    as the original, since the shape is defined (and scaled) using the same mathematical
    functions (as exemplified on the image on the left). Raster graphics, on the other
    hand, are only defined by the same grid of pixels. Scaling that grid just means
    multiplying the dimensions of the grid, resulting in the blocky, pixelated image
    represented by the image on the right.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the SVG standard does much more than simply define shapes, lines, paths,
    and colors. The specification also defines transformations and animations that
    can be applied to any single primitive, a group of primitives, or the entire SVG
    context. The specification also allows for SVG to be a very accessible format,
    meaning that it is possible to include text and other meta data right into the
    file, so that other applications can understand the file in other ways besides
    just the graphics. For example, search engines can crawl and index, not only your
    web pages, but also any SVG graphic.
  prefs: []
  type: TYPE_NORMAL
- en: Since SVG is text based (as opposed to storing binary data, such as an audio
    file, for example), it is also possible to compress an SVG image using such compression
    algorithms as the popular Gzip, which is so prevalent in the world of web development
    these days. When an SVG file is saved as its own, standalone file, it is given
    the extension `.svg`. If the file is Gzip compressed, that extension should be
    `.svgz`, so that the browser knows to uncompress the file before processing it.
  prefs: []
  type: TYPE_NORMAL
- en: SVG files can be used in an HTML file in a few different ways. Since the file
    itself can be saved as its own file, it is possible to embed the entire file on
    a page using the object tag, using an ordinary image tag, or even using an XHR
    object to fetch its contents from a server, and injected right into the HTML document.
    Alternatively, the contents of an SVG file can be manually copied into the host
    HTML file, so that its contents are imported inline.
  prefs: []
  type: TYPE_NORMAL
- en: 'To import an SVG graphic inline into an HTML document, we simply insert an
    `svg` tag, with all of its contents as children nodes of it. As of this writing,
    the XML namespace attribute is required, along with the version number, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: While this may seem easy enough for a simple red circle, once the image gets
    to be more complex, it gets a bit hard to manage all of it in one file. Thus,
    it may be more convenient to simply save all of the SVG files externally, then
    import them individually. This approach also lends itself much better to resource
    sharing and reuse, as we can import the same graphic in multiple files without
    having to copy the entire file every time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: One final note about SVG before we dive into some hands on examples, is that
    every node inside the parent `svg` tag (including that parent node) is managed
    by the browser. Thus, every one of these nodes can be styled through CSS. If that's
    not enough, every node inside an SVG graphic can have browser events registered
    to them, allowing us to interact with the graphic and all of its individual components
    the same way as most other DOM elements. This makes SVG a very dynamic, highly
    flexible graphics format.
  prefs: []
  type: TYPE_NORMAL
- en: If the SVG instance is inlined with the HTML, then we can simply get a direct
    reference to the parent svg node, or to any child node direct though JavaScript.
    Once we have that reference, we can act on the objects just like any other DOM
    elements. However, if the SVG is external to the HTML, we need to take one extra
    step and load in the actual SVG file into the JavaScript variable. Once this step
    is done, we can work with the SVG's subtree as though it is local to the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important details about the preceding code snippet that you should always
    remember are:'
  prefs: []
  type: TYPE_NORMAL
- en: The imported SVG Document is treated as an external document (similar to an
    Iframe), meaning that any CSS outside of that document (such as the host document)
    is outside of its scope. Thus, if you want to apply a CSS class to an SVG node
    from a `getSVGDocument()` call, that CSS class must be defined within the same
    SVG file that was imported originally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CSS attributes for SVG are slightly different. For example, instead of defining
    a background color you would define a fill color. Basically, the same attributes
    that are used on the SVG elements themselves, are the same ones you'd use in a
    corresponding stylesheet declaration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any browser-specific CSS attributes can be applied to SVG nodes (for example,
    transition, cursor, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus, the preceding example is completed with the following `.svg` file as
    the corresponding `red-circle.svg` file, as used in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How to use it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although it is highly recommended that you use a professional vector editor
    software when composing complex SVG graphics, such as Inkspace or Adobe Illustrator,
    this section will walk you through the basics of SVG composition. This way you
    can draw basic shapes and graphs by hand, or at least be familiar with the fundamentals
    of SVG drawing.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that whether you are importing your SVG graphics into your HTML through
    any of the methods described previously, drawing them inline, or even creating
    them dynamically through JavaScript, you will need to include the XML namespace
    to the root `svg` element. This is a common mistake made by newcomers to SVG,
    which may result in your graphics not showing up on the page.
  prefs: []
  type: TYPE_NORMAL
- en: The primitive shapes we can draw with SVG are rectangle, circle, ellipse, line,
    polyline, polygon, and path. Some of these primitives share attributes (such as
    width and height), while others have attributes that are unique to that shape
    (such as the radius of a circle). Everything you see in an SVG graphic is a result
    of these primitives used together in some combination.
  prefs: []
  type: TYPE_NORMAL
- en: Everything in SVG is drawn inside an SVG canvas, which is defined by the parent
    `svg` tag. This canvas is always rectangular, even though the shapes inside it
    can be of any shape that can be created by any of the primitives. Also, the canvas
    has its own coordinate system, which places the point origin at the top left corner
    of the canvas. The width and height of the canvas (determined by the parent `svg`
    tag) determines the dimensions of the drawing area, and all the (x, y) points
    reference inside the canvas (by all the child elements of `svg`) are relative
    to that point.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a boilerplate for the following examples, we''ll assume an external `svg`
    file, where we''ll set the canvas size to 1000 x 1000 pixels, and draw away inside
    it. To view the final result of each example, you can use any one of the methods
    described in the previous section on how to load an SVG image into an HTML file.
    the following code snippet shows how the `svg` tag is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Drawing a rectangle is as simple as it can get with SVG. Simply specify a width
    and height to a `rect` element, and that''s it. Optionally, we can specify a stroke
    width and stroke color (where a stroke is the same thing as a border), along with
    a background color. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, every shape is rendered at the origin (x = 0, y = 0), with no stroke
    (`stroke-width = 0`), and a background color (fill) set to all black (hexadecimal
    value of #000000, and RGB value of 0, 0, 0).'
  prefs: []
  type: TYPE_NORMAL
- en: The circle is drawn with a `circle` tag by specifying at least three attributes,
    namely an *x* and *y* position (denoted by `cx` and `cy`), along with a radius
    value (denoted by the letter `r`). The center of the circle is placed at position
    (`cx`, `cy`), and the radius length does not take into account the width of the
    stroke, if one is present.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that by default, just like positioned DOM elements, every node
    has the same z-index. Thus, if two or more elements overlap, whatever element
    was drawn last (meaning that it is positioned farther from the parent than its
    sibling element) is rendered on top.
  prefs: []
  type: TYPE_NORMAL
- en: Ellipses are very similar to circles, with the only difference being that they
    have a radius for each direction (vertical and horizontal). Other than that minor
    detail, drawing an ellipse is the exact same as drawing a circle. Of course, we
    can simulate circles by drawing ellipses that have both radii of the same length.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: With those basic shapes out of the way, we will now proceed to drawing more
    complex shapes. Instead of just following a few predefined points and lengths,
    we now get to choose exactly where each point goes in the shapes we'll be drawing.
    While this makes it slightly harder to draw shapes by hand, it also makes the
    possibilities much more extensive.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a line is both simple and fast. Simply specify two points within the
    SVG coordinate space, and you have a line. Each point is specified by an enumerated
    (x, y) pair.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Next we'll cover the polyline, which is an extension of a regular line. The
    difference between a line and a polyline is that, as the name implies, a polyline
    is a collection of lines. While a regular line only takes in two coordinate points,
    a polyline takes two or more points, with a line connecting them in order. Also,
    if we specify a fill color for the polyline, the last point will be connected
    to the first, and the shape formed by that enclosed area will have the fill applied
    to it. Obviously, if no fill is specified, the polyline is rendered as a simple
    shape made out of nothing but straight lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The next shape we''ll look at is the polygon. Scarily similar to a polyline,
    the polygon is drawn exactly in the same way as a polyline, but with two very
    important distinctions. First, a polygon must have at least three points. Secondly,
    a polygon is always a closed shape. This means that the last point and the first
    point of the sequence are physically connected, whereas in a polyline, that connection
    is only made by the fill, if one is assigned to the polyline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![How to use it](img/6029OT_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The polyline is shown on the left side of the preceding screenshot, while the
    shape on the right is a polygon that uses the exact same points to describe its
    position and orientation. The only difference between the two is that a polygon
    is forcefully closed. Of course, we can also simulate that behavior using a polyline
    by simply manually connecting the last point with the first.
  prefs: []
  type: TYPE_NORMAL
- en: SVG also allows us to draw very complex shapes with smooth curves, instead of
    the line-based shapes covered previously. To do so, we can use the path element,
    which might be a little complex at first, as it has several different attributes
    we can manipulate. One key feature of paths is that it allows us to either move
    the pointer to a location within the coordinate space, or to draw a line to a
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'All path attributes that describe the path are put inside the `d` attribute.
    These attributes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**M**: move to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: line to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**H**: horizontal line to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**V**: vertical line to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C: curve to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**S**: smooth curve to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q**: quadratic Bezier curve'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**T**: smooth quadratic Bezier curve'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A**: elliptical arc'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Z**: close path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These attributes can be repeated as many times as needed, although it may be
    a good idea to break down the overall drawing into multiple smaller paths. Some
    reasons to separate a larger drawing into multiple paths are to make the figure
    more manageable, easier to troubleshoot, and easier to understand. The code for
    this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Unless you practice and train yourself to look at path descriptions, it may
    be hard to just look at those codes and visualize the path. Take your time and
    look at each attribute individually. The preceding example first moves the pointer
    to point (100, 100), then a line is drawn from that point to another point (100,
    300). This makes a vertical line from the last position where the pointer was,
    to the point specified by the line to attribute. Next, the cursor is changed from
    where it was to a new position (250, 100). Note that simply moving the cursor
    doesn''t affect any previous drawing calls, nor does it do any drawing at that
    time. Finally, a second vertical line is drawn to point (250, 300). A third line
    is drawn at an equal distance from the first line. This can be seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to use it](img/6029OT_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that whatever values we define for fill, stroke, stroke width, and so on,
    are applied to the entire path. The solution to the problem of wanting different
    fill and stroke values is to create additional paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drawing curves is still a bit more complicated. A curve requires three values,
    namely two control points, and the final point to which the line is drawn. To
    illustrate how control points work, observe the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'While executing the preceding code as shown in the following screenshot, we
    can see the relationship between control points and the curvature of a line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to use it](img/6029OT_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a cubic Bezier curve where the red lines show where the first and last
    curve points connect with the control points.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing curves just the way you want is a rather complex problem to solve by
    hand. Different curve functions behave different from each other, so be sure to
    experiment with them all until you get a good feel for how they each work. Remember
    that although it is a good idea to have at least some understanding of how these
    curves and other drawing primitives work, it is highly recommended that you always
    use appropriate software to help you create your drawings. Ideally, we would use
    our creativity to create the drawing, and let the computer figure out how to represent
    that using SVG.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The description attributes for paths can be specified using either a lowercase
    or an uppercase letter. The difference is that an uppercase letter means that
    the point is absolute, and a lowercase letter means that the point is relative.
    This concept of relative and absolute points is not quite the same as in HTML,
    where a relative offset means that the destination point is relative to its own
    original location, and an absolute point is one that's completely relative to
    the element's parent.
  prefs: []
  type: TYPE_NORMAL
- en: In SVG world, an absolute point is relative to the canvas' origin, and a relative
    point is relative to the last point defined. For example, if you move the pointer
    to location (10, 10), then do a relative move with values of 10 15, the pointer
    will end up, not at location (10, 15), but 10 units away from the x position,
    and 15 units away from the y position. The new position of the pointer would then
    be location (20, 25).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, SVG is capable of rendering text to the screen. Imagine how time consuming
    it would be to render each letter by hand using lines and paths. Thankfully, the
    SVG API specifies a very simple interface for text rendering.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the SVG standard does much more than simply define shapes, lines, paths,
    and colors. The specification also defines groups of elements, whereby one may
    literally group a collection of nodes, so that they can possibly all be treated
    together as a single unit. There are also transformations, animations, gradients,
    and even photo filters, all of which can be applied to the simple primitives that
    are described previously. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Drag-and-drop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although creating drag-and-drop functionality manually is not a very challenging
    ordeal, HTML5 takes drag-and-drop to a whole new level. With the new API, we're
    given the ability to do so much more than just let the browser handle the dragging
    and dropping actions. The interface allows for customizing the exact way that
    things are dragged, how the dragging action looks, what data is carried with the
    draggable object, and so on. Plus, not having to worry about how the low level
    events are tracked in different platforms and devices is a nice, welcome touch.
  prefs: []
  type: TYPE_NORMAL
- en: For the curious reader, the way we could implement our own drag-and-drop behavior
    is really quite simple; first, we listen for a mouse down event on the element
    we want to drag. When that happens, we set a mouse down flag, which we unset once
    the mouse up event is fired, whether on the element we wish to drag or not. Next,
    we listen for a mouse movement event, where we check if the mouse is down. If
    the mouse is moving while the mouse down flag is set, we have a drag motion. One
    way to handle it is to update the position of the draggable element every time
    the mouse moves, then setting the element's position when the mouse up event is
    called. Of course, there are several small details that we'd need to keep track
    of, or at least be mindful of, such as how to detect where the draggable element
    was dropped, and how to move it back to its original position if needed.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that the drag-and-drop API provided by the browser is very
    flexible, and extremely efficient. Since this feature was first introduced, a
    lot of developers continued to use JavaScript implementations of it for various
    reasons, but mostly because a lot of people felt that the native HTML5 version
    was a bit hard to use, buggy, or not quite as practical as the version provided
    by whatever other library they chose to use. However, today the API is widely
    supported, fairly polished, and highly recommended.
  prefs: []
  type: TYPE_NORMAL
- en: How to use it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, the way that the drag-and-drop API works is very straight forward. First
    we need to mark one or more elements as draggable by setting the `draggable` attribute
    to true for those elements, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Just this step alone will make those elements all draggable. Of course, that
    isn''t of any use unless we have a place to drop those elements. Believe it or
    not, we actually can drop a dragged element anywhere. The problem is that we don''t
    have any code in place to handle the event of something being dropped. We can
    register such events on any element, including the body tag, for example. This
    is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we append a new list element to the unordered list every time
    a list element is dropped anywhere on the page, since every element on the page
    is a child of the body node. Also, whenever a draggable element hovers over the
    body element, we add a CSS class called `dropme`, which is meant to give the user
    a visual feedback letting them know that the drag event is taking place. When
    the draggable is dropped, we remove that class from the body element indicating
    the end of the drag action.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing we can do with the drag and drop API is transfer data between objects.
    This data can be a string, or any data type that can be converted into a string.
    We do this by setting the desired data to the `dataTransfer` object available
    to us during the drag action. The data must be set when the drag start function
    is fired by the system. The key associated with the `dataTransfer` data can be
    any string of our choosing as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter touched on the very important topic of browser support and code
    portability. As productive and efficient developers, we should always strive to
    create maintainable code. Thus, the more browsers we can support with the same
    code base, the more efficient we are. In order to help us achieve this goal, we
    can create abstractions that encapsulate code that varies from browser to browser,
    as well as from device to device. Another alternative is to use existing polyfills
    that other people have written, and thus accomplish the same thing, but with possibly
    less effort and more reliability.
  prefs: []
  type: TYPE_NORMAL
- en: The game we built in this chapter makes use of three HTML5 APIs, namely drag-and-drop,
    web audio, and SVG. Native drag-and-drop provided in HTML5 is a lot more than
    simply dragging DOM elements around the screen. With it we can customize a lot
    of the visual elements related to the drag-and-drop action, as well as specify
    data that is carried through the draggable element and the target where it is
    dropped.
  prefs: []
  type: TYPE_NORMAL
- en: Web audio allows us to manage multiple audio entities. Although most modern
    browsers support more than one audio format, there is not yet a single audio format
    that is supported by all of these modern web browsers. Because of that, it is
    recommended that we link at least two different versions of each audio file we
    wish to play through the API, so that all modern browsers are capable of playing
    that file. Although we can specify multiple sources for each audio element (where
    each source is a different version of the same file, but encoded in a different
    format), the browser is smart enough to only download the one file that it supports
    and knows how to play, or the one file that is most appropriate for it to playback.
    This makes load time shorter, and saves both the user and your server quite a
    bit of bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: Scalable Vector Graphics is an XML-based description language for two dimensional
    graphics, which can be embedded in a web page in a variety of ways. Since all
    of the graphical elements are nothing more than XML nodes rendered by the browser
    onto an SVG canvas, each of these graphical elements are managed by the browser,
    and can, therefore, be styled through CSS, and have user input events linked to
    them. We can also register callback functions with each SVG primitive for events
    generated by the browser, such as when the element is loaded, focused, blurred,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw how none of the timer functions provided by JavaScript are at
    all appropriate for fast games. Thankfully, there is a new rendering API that
    we'll cover in the next chapter that can be used to overcome the deficiencies
    of JavaScript timers. Using the request animation frame interface allows us to
    render our games much more efficiently because the browser itself manages the
    timer that is used, as well as allows our games to be more CPU-friendly by not
    rendering a screen that is not visible (such as when the browser is minimized,
    or a different tab is focused).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will write a traditional snake game, with the main focus
    points being rendering the entire game scene using the canvas API (as opposed
    to using raw DOM elements), application cache for offline game play, web workers,
    and the new and powerful JavaScript typed arrays. As alluded earlier in this chapter,
    we will also take a look at the new way to render very dynamic graphics in HTML5
    apps, using requestAnimationFrame to access the browser's very own rendering pipeline.
  prefs: []
  type: TYPE_NORMAL
