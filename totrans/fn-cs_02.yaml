- en: Chapter 2. Walkthrough Delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we applied delegates in the code we created. When
    we discussed the concept of functional programming, we applied one of the built-in
    delegates that C# has. In this chapter, we are going to delve into the delegates
    that will be used a lot in functional C# programming by discussing the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The definition, syntax, and use of delegates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining delegates into multicast delegates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using built-in delegates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the variance in delegates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A delegate is a data type in C# that encapsulates a method that has particular
    parameters and return types (signatures). In other words, a delegate will define
    the parameters and the return type of a method. Delegates are similar to function
    pointers in C/C++ since both stores the reference to the method with a particular
    signature. Like a function pointer in C/C++, a delegate keeps a memory address
    of the method it refers to. The compiler will complain if it refers to a function
    with a different signature. However, because of the unmanaged nature of the C++
    language, one can point functions to arbitrary locations (by casting).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following delegate syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the explanation for each element of the preceding delegate syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AccessModifier** : This is the modifier that is used to set the accessibility
    of the delegate. It can be public, private, internal, or protected. However, we
    can omit it, and if we do that, the default modifier will be internal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**delegate** : This is the keyword we need in order to initialize a delegate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ReturnType** : This is a returning data type of the method we assign to this
    delegate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DelegateName** : This is the identity of the delegate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**parameters** : This is the list of parameters that the method we assign to
    this delegate takes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By referring to the preceding syntax, we can initialize the delegate, for instance,
    `SingleStringDelegate` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have the preceding delegate, we can assign a method possessing the
    same signature to the delegate. The method can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, the method can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Since both methods have an identical signature, we can assign them to `SingleStringDelegate`
    using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding syntax is used to assign the `AssignData()` method to a variable
    typed `SingleStringDelegate` , and for the `WriteToConsole()` method, we can use
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is common to name a delegate type ending with the word `Delegate` —for example,
    `SingleStringDelegate` —in order to be able to distinguish the delegate name and
    the method name. However, it is not mandatory and we can omit this.
  prefs: []
  type: TYPE_NORMAL
- en: Simple delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For further discussion on delegates, let''s take a look at the following method,
    which we can find at `SimpleDelegates.csproj` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Rectangle()` method in the preceding code can be assigned to the delegate
    variable given in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following method can also be assigned to the `AreaCalculatorDelegate` delegate
    because the signature of the method is what the delegate type expects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To assign a method to a delegate, we just need to create a variable of the
    delegate data type which has signature compatibility with the method to be assigned.
    The following is the `Main()` method, which will create the delegate variable
    and invoke the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we create two variables named `rect` and `sqr` whose
    type is `AreaCalculatorDelegate` . Here is the code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have assigned the `rect` and `sqr` variables to the `Rectangle()`
    and `Square()` methods, we can invoke these methods using the delegate variable.
    Let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We assign variable `i` and `j` with the result of `rect()` and `sqr()` . Although
    both of them are variable names, they refer to the method address location. One
    invokes a method referred by these variables to execute the logic contained. We
    are effectively executing the two `Console.WriteLine()` methods to produce the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple delegates](img/Image00010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is now clear to the reader that why we display the output shown in the preceding
    screenshot. The `rect` and `sqr` variables now store the reference to `Rectangle()`
    and `Square()` methods respectively. We are effectively calling the `Rectangle()`
    method while invoking the `rect` delegate and `Square()` method, all the while
    invoking the `sqr` delegate.
  prefs: []
  type: TYPE_NORMAL
- en: Multicast delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just discussed a simple delegate where we assign a particular method
    to a delegate variable. We can call it a unicast delegate. However, the delegates
    can actually invoke multiple methods using one variable. For this purpose, we
    can call it a multicast delegate. In the case of multicast delegate, it is like
    a list of delegates stored inside an internal list. When we invoke a multicast
    delegate, the delegates in the list are synchronously called in the correct order.
    There are several ways to create a multicast delegate. The two we will discuss
    in detail are the `Delegate.Combine()` and `Delegate.Remove()` methods and the
    `+=` and `-=` (increment and decrement) operators.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Delegate.Combine() and Delegate.Remove() methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s first examine the following code, creating a multicast delegate using
    the `Delegate.Combine()` method. Suppose we have a delegate named `CalculatorDelegate`
    , as follows, which we can find at `CombineDelegates.csproj` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have the following four methods that have the same signature as the
    `CalculatorDelegate` signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There are four methods, and they are `Add()` , `Subtract()` , `Multiply()`
    , and `Division()` . We are going to cast these methods in a single variable-typed
    delegate. Now, take a look at the following `CombineDelegate()` method to achieve
    this goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this method, the following output will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Delegate.Combine() and Delegate.Remove() methods](img/Image00011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have successfully invoked four methods by calling a single delegate. The
    delegate we called in the preceding code is in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually `calcMultiples` delegate has stored four delegates variables internally,
    corresponding to each of the method which we combined. Thanks to the `Delegate.Combine()`
    method, we can combine the delegates using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can also create the array of delegates by calling `GetInvocationList()` from
    the delegate variable. By retrieving the delegate array, we can iterate over the
    array like we do for ordinary arrays. We can retrieve the `Length` property to
    count how many delegates are there in the invocation list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In multicast delegates, we are able to combine as well remove delegates from
    the invocation list. Let''s take a look at the following `RemoveDelegate()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding method, the following output will be displayed in the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Delegate.Combine() and Delegate.Remove() methods](img/Image00012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similar to the `CombineDelegate()` method, we combine the four methods into
    a single variable-typed delegate in the `RemoveDelegate()` method. The `calcDelegates3`
    delegate is the delegate that keeps the four methods. Indeed, when we invoke `calcDelegates3`
    , it calls the four methods in a proper order. Next, in the `RemoveDelegate()`
    method, we invoke the `Delegate.Remove()` method in order to remove the selected
    delegate in the invocation list. Based on the preceding code, the syntax is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet is used to remove the `mulDel` delegate variable
    from the invocation list. As we can see in the preceding figure displaying the
    output of the `RemoveDelegate()` invocation, the `Multiply()` method is no longer
    invoked right after it's removed from invocation list.
  prefs: []
  type: TYPE_NORMAL
- en: 'An invocation list associated with a delegate can contain duplicate entries.
    This means that we can add the same method to the invocation list more than once.
    Now let''s try to insert the duplicate entries into the invocation list by adding
    the `DuplicateEntries()` method to the project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s run the `DuplicateEntries()` method, and the console will show the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Delegate.Combine() and Delegate.Remove() methods](img/Image00013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'By examining the preceding code, we can see that the `duplicateDelegates2`
    variable contains three invocation methods, which are `addDel` , `subDel` , and
    `mulDel` . Look at the following code snippet for more details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we add `subDel` and `addDel` to the invocation list like we do in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, the invocation list of `duplicateDelegates4` contains two duplicate methods.
    However, when we invoke the `DuplicateEntries()` method, `addDel` and `subDel`
    are invoked twice and the invocation order is just like the order in which we
    add the delegate to the invocation list.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Delegate.Combine()` and `Delegate.Remove()` static methods will return
    the `Delegate` data type instead of the instance of `Delegate` itself. As a result,
    casting the return of both methods to the expected instance delegate is required
    when using them.
  prefs: []
  type: TYPE_NORMAL
- en: Using += and -= operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It''s quite easy to create multicast delegates using `+=` and `-=` operators
    since that will be like treating any data types in C#. We can also use the `+`
    and `-` operators to add and remove delegates in an invocation list. Here is the
    sample code we can find at `AddSubtractDelegates.csproj` in order to combine delegates
    and remove select delegates from the invocation list using the operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have the four methods that we use in the preceding project, `CombineDelegates.csproj`
    : `Add()` , `Subtract()` , `Multiply()` , and `Division()` . We will get the following
    output if we run the `AddSubtractDelegate()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using += and -= operators](img/Image00014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the starting lines of the `AddSubtractDelegate()` method, we create four
    variables typed `CalculatorDelegate` for each of the four methods we have, just
    like we did in the previous project. We then create one more variable named `multiDel`
    in order to generate the multicast delegate. Here, we can see that we add the
    delegate to the multicast delegate variable using the operator only, in which
    we use the `+` and `+=` operators. Let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code snippet, after combining all four delegates into the
    `multiDel` delegate, we call the `multiDel` delegate, and what we get based on
    the output console display is the program to invoke the four methods in a proper
    order. The four methods are `Add()` , `Subtract()` , `Multiply()` , and `Division()`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove the delegate from the invocation list, we use the `-` and `-=` operators
    in the preceding code. Let''s take a look at the following code snippet to examine
    what we have to do in order to remove the delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Since we have removed the `subDel` and `mulDel` delegates from the invocation
    list, the program only calls two methods, the `Add()` and `Division()` methods,
    when we invoke the `mulDel` delegate. This proves that we have successfully removed
    the delegate from the invocation list using the `-` and `-=` operators.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using `+=` and `-=` to assign a multicast delegate doesn't fit the functional
    programming approach since it breaks the immutability concept. However, we can
    still use the `+` and `-` operators to add a delegate to the invocation list and
    remove the delegate from the invocation list consecutively in a functional approach.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C#, not only are we able to declare a delegate, but we are also able to use
    the built-in delegate from the C# standard library. This built-in delegate also
    applies to the generic data type, so let's discuss the generic delegate prior
    to discussing the built-in delegate.
  prefs: []
  type: TYPE_NORMAL
- en: Generic delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A delegate type can use a generic type as its parameter. Using the generic
    type, we can put off the specification of one or more types in parameters or return
    values until the delegate is initialized into a variable. In other words, we do
    not specify the data types of the delegate''s parameters and return values when
    we define a delegate type. To discuss this in more detail, let''s take a look
    at the following code, which we can find at `GenericDelegates.csproj` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a delegate name, `FormulaDelegate` , using the generic data type. As
    we can see, there is a `T` symbol, which represents the data type we will define
    when declaring the variable typed `FormulaDelegate` . We continue by adding the
    following two methods that have completely different signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s take a look at the following code in order to explain how we declare
    the variable-typed delegate and invoke the method from the delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following result will be displayed in the console when we run the `GenericDelegateInvoke()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generic delegates](img/Image00015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding code, we can declare two methods that have different signature
    using only one delegate type. The `intAddition` delegate refers to the `AddInt()`
    method, which applies the `int` data type in its parameters and return value,
    while the `doubleAddition` delegate refers to the `AddDouble()` method, which
    applies the `double` data type in its parameters and return value. However, in
    order for the delegate to know the data type of the method it refers, we have
    to define the data type in angular brackets (`<>` ) when we initialize the delegate.
    The following code snippet is the delegate initialization that uses the generic
    data type (symbolized by the angular brackets):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Because we have defined the data type, the delegate can match the data type
    of the method it refers. That's why, from the output console, we can invoke the
    two methods that have different signatures.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have successfully used a generic type for delegates, applying one generic
    template. The following code, which we can find at `MultiTemplateDelegates.csproj`
    , shows us that the delegate can also apply the multigeneric template in one delegate
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will create a new delegate named `AdditionDelegate` , which
    has two parameters with two different data types. `T1` and `T2` represent the
    data type that will be defined in the variable-typed delegate declaration. Now,
    let''s create two methods that have different signatures, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To refer the `AdditionDelegate` delegate to the `AddIntDouble()` and `AddFloatDouble()`
    methods and invoke the delegate, we can create the `VoidDelegateInvoke()` method,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the `VoidDelegateInvoke()` method, we will see the following output
    on our console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generic delegates](img/Image00016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding console output, it can be seen that we have successfully
    invoked the `intDoubleAdd` and `floatDoubleAdd` delegates although they have different
    method signatures. This is possible since we apply the `T1` and `T2` template
    in the `AdditionDelegate` delegate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to create the multitemplate delegate again, but this time, we use
    the method that has a return value. The declaration of the delegate will be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add the two methods `AddIntDoubleConvert()` and `AddFloatDoubleConvert()`
    to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to use the `AddAndConvert` delegate, we can create the `ReturnValueDelegateInvoke()`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When we invoke the `ReturnValueDelegateInvoke()` method, we get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generic delegates](img/Image00017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Again, we successfully invoke the two different signature methods using a multitemplate
    generic type.
  prefs: []
  type: TYPE_NORMAL
- en: The Action and Func delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go back to the following delegate declaration we discussed earlier in
    the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'C# has a built-in delegate that can take a maximum of 16 parameters and return
    void. It is called the `Action` delegate. In other words, the `Action` delegate
    will point to a method that return nothing and takes zero, one, or more input
    parameters. Due to the existence of the `Action` delegate, we no longer need to
    declare a delegate, and we can immediately assign any method to the delegate.
    We can modify the preceding `MultiTemplateDelegates.csproj` project and remove
    the `AdditionDelegate` delegate since we will now use the `Action` delegate. Then,
    the `ActionDelegateInvoke()` method in `MultiTemplateDelegates.csproj` will be
    modified to become `ActionDelegateInvoke()` with the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can find the preceding code in the `ActionFuncDelegates.csproj` project.
    As we can see, now we apply the `Action` delegate to replace the `AdditionDelegate`
    delegate in the `MultiTemplateDelegates.csproj` project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'C# has another built-in delegate that has a return value by taking a maximum
    of 16 parameters. They are `Func` delegates. Let''s go back to the `MultiTemplateDelegates.csproj`
    project and find the following delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can remove the preceding delegate since it matches the declaration of the
    `Func` delegate. So, we can modify the `ReturnValueDelegateInvoke()` method in
    the `MultiTemplateDelegates.csproj` project for it to become the `FuncDelegateInvoke()`
    method with the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we  no longer need the `AddAndConvert` delegate anymore since we have
    applied the `Func` delegate, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Using the `Action` and `Func` built-in delegates, the code becomes shorter and
    the definition of the delegate becomes easier and quicker.
  prefs: []
  type: TYPE_NORMAL
- en: Distinguishing variance in delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A generic delegate has the ability to be assigned by a method that has an unmatched
    signature to the delegate. We can call this variance in delegates. There are two
    variances in delegates, and they are covariance and contravariance. Covariance
    allows a method to have a return type that is more derived (subtype) than the
    return type that is defined in the delegate. On the other hand, contravariance
    allows a method to have parameter types that are less derived (supertype) than
    the parameter types that are defined in the delegate.
  prefs: []
  type: TYPE_NORMAL
- en: Covariance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is an example of covariance in delegates, which we can find in
    the `Covariance.csproj` project. First, we initialize the following delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a delegate returning the `TextWriter` data type. Then, we also
    create the `StreamWriterMethod()` method returning the `StreamWriter` object,
    which has the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We create the `StringWriterMethod()` method as well, returning the `StringWriter`
    object with the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have two methods returning different objects, `StreamWriter` and `StringWriter`
    . The return value data type of these methods is also different, with the `CovarianceDelegate`
    delegate returning the `TextWriter` object. However, since `StreamWriter` and
    `StringWriter` are derived from the `TextWriter` object, we can apply covariance
    in assigning these two methods to the `CovarianceDelegate` delegate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `CovarianceStreamWriterInvoke()` method implementation, which assigns
    the `StreamWriterMethod()` method to the `CovarianceDelegate` delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `StreamWriterMethod()` method, we create `StreamWriter` , writing content
    to the console using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `CovarianceStreamWriterInvoke()` method, we call this code in
    order to write the content to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the `CovarianceStreamWriterInvoke()` method, the following output
    will be displayed in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Covariance](img/Image00018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding output console, we serve the list of directories we have
    inside the Visual Studio 2015 installation path. Indeed, you might have a different
    list if you installed a different version of Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to utilize the `StringWriterMethod()` method to create a
    `CovarianceDelegate` delegate. We create the `CovarianceStringWriterInvoke()`
    method, which has the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We have generated `StringWriter` in the `StringWriterMethod()` method using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we call the following code to write the string to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the `CovarianceStringWriterInvoke()` method, the string we have defined
    in the `arrString` string array in the `StringWriterMethod()` method will be displayed,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Covariance](img/Image00019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, from our discussion on covariance, we have proved the covariance in delegates.
    The `CovarianceDelegate` delegate returning `TextWriter` can be assigned to the
    method returning `StreamWriter` and `StringWriter` . The following code snippet
    is taken from several preceding codes to conclude the covariance in delegates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Contravariance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s continue our discussion on variance in delegates by discussing
    contravariance. The following is the `ContravarianceDelegate` delegate declaration,
    which we can find in the `Contravariance.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding delegate is going to be assigned to the following method, which
    has the `TextWriter` data type parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The assignment will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the `ContravarianceTextWriterInvoke()` method, the console will display
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Contravariance](img/Image00020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding output, we have successfully assigned a method, taking the
    `TextWriter` parameter to the delegate taking the `StreamWriter` parameter. This
    happens because `StreamWriter` is derived from `TextWriter` . Let''s take a look
    at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet is taken from the code we discussed in contravariance.
    Here, we can see that `contravDelegate` , a variable typed `ContravarianceDelegate`
    , can be assigned to the `TextWriterMethod()` method even though they both have
    different signatures. This is because `StreamWriter` is derived from the `TextWriter`
    object. Since the `TextWriterMethod()` method can work with a `TextWriter` data
    type, it will surely be able to work with a `StreamWriter` data type as well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A delegate is useful in order to encapsulate a method. It is like any data type
    in C# in which a variable can be initialized to have the delegate data type. Since
    it similar to data types, increment and decrement operations can be applied to
    the delegate, making it possible to create a multicast delegate from several delegates.
    However, one thing to remember, since the `Delegate.Combine()` and `Delegate.Remove()`
    methods return the `Delegate` data type, is that we have to cast the return of
    both methods to the expected instance delegate when using them. Compared to the
    `+=` and `-=` operators use, however, since they are implemented at the language
    level in the compiler and the delegate type is known, there's no need to cast
    the result of the increment and decrement delegate operation.
  prefs: []
  type: TYPE_NORMAL
- en: C# also has built-in delegates, `Action` and `Func` , which make the code shorter,
    and the definition of the delegate becomes easier and quicker. As a result, the
    code gets simpler to be analyzed. Also, there are two variances in the use of
    delegates; covariance and contravariance, which will allow us to assign a method
    to the delegate. Covariance allows a method to have a return type that is more
    derived than the return type that is defined in the delegate, while contravariance
    allows a method to have the parameter types that are less derived than the parameter
    types that are defined in the delegate.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a better understanding about delegates. Let's move on to the next
    chapter, where we are going to leverage the power of delegates to express anonymous
    methods using the lambda expression.
  prefs: []
  type: TYPE_NORMAL
