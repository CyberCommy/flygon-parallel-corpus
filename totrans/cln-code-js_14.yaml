- en: Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most problems we encounter are not new. Many programmers that have come before
    us have tackled similar problems and, via their struggles, various patterns of
    programming have emerged. We call these design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns are the useful structures, styles, and stencils that our code
    sits within. A design pattern may prescribe anything from the overall scaffolding
    of a code base to the individual syntactic pieces used to build expressions, functions,
    and modules. By building software, we are constantly, and often unknowingly, in
    the process of *designing*. It is through this process of designing that we are
    defining the experience that users and maintainers will go through when exposed
    to our code.
  prefs: []
  type: TYPE_NORMAL
- en: To attune us to this perspective of the designer instead of programmer, for
    a moment, let's consider the design of a simple software abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The perspective of a designer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architectural design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modular design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning and harmony
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The perspective of a designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To bestow us with the perspective of a designer, let's explore a simple problem.
    We must construct an abstraction that allows users to give us two strings, a subject string
    and a query string. We must then calculate a count of the query strings found
    within the subject string.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, consider the following query string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And have a look at the following subject string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We should receive a result of `2`.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes as a designer, we care about the experience of those who must
    use our code. For now, we won't worry about our implementation; we will instead
    only consider the interface, as it is primarily the interface to our code that
    will drive our fellow programmers' experiences.
  prefs: []
  type: TYPE_NORMAL
- en: 'The very first thing we may do as a designer is to define a function with a
    carefully chosen name and a specific set of named arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This function accepts `needle` and `haystack` and will return `Number`, indicating
    the count of `needle` within `haystack`. The consumer of our code would make use
    of it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We are using the popular idiom of needle-in-a-haystack to describe the problem
    of looking for a substring within another string. Considering popular idioms is
    a crucial part of designing code, but we must be wary of idioms being misunderstood.
  prefs: []
  type: TYPE_NORMAL
- en: 'The design of a piece of code should be defined by the problem domain we wish
    to solve and the user experience we wish to reveal. Another programmer, given
    the same problem domain, may have chosen a different solution. For example, they
    may have employed partial application to allow the following calling syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Or perhaps they may have designed a more verbose syntax that involves invoking
    a `Haystack` constructor and calling its `count()` method like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This *classical* approach arguably has a nice semantic relationship between
    the object (`Haystack`) and the `count` method. It meshes well with the OOP concepts
    we've explored in previous chapters. That said, some programmers may find it to
    be overly verbose.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s also the possibility of a more descriptive API where the arguments
    are defined within a configuration object (that is, a plain object literal passed
    as the sole argument):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s also the possibility that this counting functionality may form the
    part of a larger set of string-related utilities and, hence, can be incorporated
    into a larger custom-named module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We may even consider it okay to modify the native `String.prototype`, even
    though it is inadvisable, so that we have a `count` method available on all strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In terms of our naming conventions as well, we may wish to avoid the needle-in-a-haystack
    idiom and, instead, use more descriptive names where perhaps there is less risk
    of misunderstanding, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`searchableString` and `subString`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`query` and `content`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search` and `corpus`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The choices available to us, even within this very narrow problem domain, are
    overwhelming. You'll likely have many of your own strong opinions about which
    approach and naming conventions would have been superior here.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that we can solve a seemingly simple problem with so many different
    approaches shows us how there is a need for a decision process. And this process
    is software design. Effective software design employs design patterns to encapsulate
    problem domains and provide familiarity and ease of comprehension to fellow programmers.
  prefs: []
  type: TYPE_NORMAL
- en: The intent with our exploration of the needle-in-a-haystack problem was not
    to find a solution, but rather to highlight the difficulty of software design,
    and to expose our minds to a more user-oriented perspective. It also reminds us
    that there is very rarely one ideal design.
  prefs: []
  type: TYPE_NORMAL
- en: 'A well-chosen design pattern, given any problem domain, can be said to have
    two basic characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**It solves the problem well**: A well-chosen design pattern will be well-suited
    to the problem domain so that we can fluidly express the nature of the problem
    and its solution easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It is familiar and usable**: A well-chosen design pattern will be familiar
    to our fellow programmers. It''ll be immediately obvious how can they can use
    it or make changes to the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns are useful in a variety of contexts and scales. We use them
    when we write individual operations and functions, but we also use them when structuring
    our entire code base. Design patterns, as such, are hierarchical. They exist on
    the macro and micro scale of a code base. A singular code base can easily contain
    many design pattern within.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 2](fd19fa13-f04a-4e03-9bc3-ba318cacf731.xhtml), *Tenets of Clean
    Code*, we spoke about familiarity as a crucial characteristic. A car mechanic
    opening the hood of a car will hope to see many familiar patterns: from the individual
    pieces of wiring and welding of Components to the larger construction of the cylinders,
    valves, and pistons. There is a certain layout they would expect to find and if
    it is not there, then they would be left scratching their heads, wondering how
    to approach whatever problem they''re trying to solve.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Familiarity increases the maintainability and usability of our solutions. Consider
    the following directory structure and the displayed `logger.js` source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9c3cb805-3237-4651-b5b4-4e65a6188a83.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What design patterns can we observe here? Let''s take a look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: The use of a top-level `app/` directory to contain all the source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The existence of **Models, Views, and Controllers** (**MVC**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The separation of utilities into its own directory (`utils/`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The camel case naming of files (for example,`binarySearch.js`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of a Conventional Module pattern in `logger.js` (that is, exporting
    a plain object of methods)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of `... && msgs.length` to confirm a nonzero (that is, truthy) length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring constants at the top of a file (that is, `const ALL_LOGS_LEVEL`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Possibly others...)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Design patterns are not just large, lofty architectural structures. They can
    exist in every part of our code base: the directory structure, the naming of files,
    and the individual expressions of our code. At every level, our usage of common
    patterns can increase our ability to express the problem domain, and increase
    the familiarity of our code to newcomers. Patterns exist within patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using design patterns well can have beneficial effects on all of the tenets
    of clean code we covered previously—reliability, efficiency, maintainability,
    and usability:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliability**: A good design pattern will suit the problem domain and allow
    you to easily express your desired logic and data structures without too much
    complexity. The familiarity of your adopted design patterns will also enable other
    programmers to easily understand and improve upon the reliability of your code
    over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficiency**: A good design pattern will enable you to fuss less about how
    to structure your code base or your individual modules. It''ll enable you to spend
    more time worrying about the problem domain. Well-selected design patterns will
    also aid in making the interfaces between different pieces of code streamlined
    and understandable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: A good design pattern allows for easy adaptation. If there
    is a change of specification or a bug that needs to be fixed, the programmer can
    easily find the desired area of change/insertion and make the change without hassle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usability**: A good design pattern is easy to understand due to its familiarity.
    A fellow programmer can easily comprehend the flow of the code and quickly make
    correct assertions about how it works and how they can make use of it. A good
    design pattern will also create a pleasant user experience, whether expressed
    via a programmatic API or a GUI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see that a lot of what makes design patterns useful is only actualized
    if we pick the right one. We'll be exploring a selection of popular design patterns
    and, for each, we'll discuss the types of situations they're suited to. This exploration
    should hopefully give you a good idea of what it means to select a good design
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '**Be warned***:* just as good design proliferates via convention, so does bad
    design. We discussed the phenomenon of cargo culting in [Chapter 3](4aede822-c58b-4e6b-81cd-ba27582e9aa7.xhtml),
    *The Enemies of Clean Code*, and so we are not strangers to how such types of
    bad designs may spread, but it''s important to remain mindful of these traps when
    employing design patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: Architectural design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Architectural design patterns are the ways in which we tie our code together.
    If we have a dozen different modules, it is how those modules talk to each other
    that defines our architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The architectural design patterns utilized in JavaScript code bases have changed
    massively over recent years. With the steady proliferation of popular frameworks
    such as React and Angular, we've seen code bases take on new conventions. The
    landscape is still very much shifting, so we shouldn't expect any specific standard
    to emerge any time soon. Nonetheless, most frameworks tend to follow the same
    broad architectural patterns.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a popular architectural pattern is the separation of data logic
    and rendering logic. This is famously adopted by many different UI frameworks,
    albeit with different styles. This is likely due to the heritage of software UI
    and the early established pattern of MVC that eventually became the de facto approach.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll be covering two famous architectural design patterns,
    MVC and its offshoot, **Model-View-ViewModel** (**MVVM**). Together, these should
    give us an awareness of the types of concerns that are typically separated and
    will hopefully inspire us to seek a similar level of clarity in the architectures
    we create.
  prefs: []
  type: TYPE_NORMAL
- en: MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MVC is characterized by a separation between these three concepts. An MVC architecture
    may involve many individual Models, Views, and Controllers that all work in concert
    to solve a given problem. Each of these parts can be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Model**: This describes the data and how business logic mutates that
    data. Changes in the data will manifest in changes to the View.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The View**: This describes how the Model is rendered (its format, layout,
    and appearance) and will invoke the Controller whenever there is an action that
    needs to occur, possibly in response to a user event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Controller**: This accepts instructions from the View and informs the
    Model what actions or changes to carry out, which will go on to affect whatever
    is rendered to the user via the View.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can observe the flow of control in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d5ca9398-52c3-4cdd-b323-74d3941bd397.png)'
  prefs: []
  type: TYPE_IMG
- en: The MVC pattern provides us with a way to separate our various concerns. It
    prescribes where we should put logic about business decisions (that is, in Models)
    and where we should put logic about displaying things to the user (that is, Views).
    Additionally, it gives us the Controller, which enables these two concerns to
    talk to each other. The separation that MVC fosters is hugely beneficial as it
    means our fellow programmers can easily discern where to make required changes
    or fixes.
  prefs: []
  type: TYPE_NORMAL
- en: MVC was originally posed in 1978 by Trygve Reenskaug while working at Xerox
    PARC. Its original purpose was to support the user's illusion of seeing and manipulating
    the domain information directly. At the time, this was quite revolutionary, but
    we now, as end users, take such UIs (and their transparent relation to their data)
    for granted.
  prefs: []
  type: TYPE_NORMAL
- en: A working example of MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To illustrate how an implementation of MVC might look in JavaScript, let's build
    a very simple program. It will be a basic mutable number application that renders
    a simple UI where the user can see the current number and choose to update it
    via either incrementing or decrementing its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can implement the logic and containment of our data using a Model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In addition to storing the value itself, this class also accepts and relies
    upon a callback function called `onChangeCallback`. This callback function will
    be provided by the Controller and will be called whenever the value changes. This
    is necessary so that we can kick off a re-render of the View if the Model changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to build the Controller, which will act as a very simple bridge
    (or glue) between `view` and `model`. It registers the necessary callbacks to
    know when either the user requests a change via `view` or the underlying data
    of the `model` changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `view` is responsible for retrieving data from `model` and rendering it
    to the user. To do this, it creates a DOM hierarchy in which the data will sit.
    It also listens for and escalates user events to `controller` when either the
    `increment` or `decrement` button is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is quite a lengthy View as we're having to create its DOM representation
    manually. Many modern frameworks (React, Angular, Svelte, and so on) allow you
    to declaratively express your hierarchy using either plain HTML or a hybrid syntax
    such as JSX (a syntax extension to JavaScript itself that permits XML-like tags
    within JavaScript code).
  prefs: []
  type: TYPE_NORMAL
- en: 'This *View* has two rendering methods: `renderInitial` will carry out the initial
    render, which sets up the DOM elements, and then the `renderUpdate` method is
    responsible for updating the number whenever it changes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tying this all together, our simple program would be initialized like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`view` is given access to `model` so that it can retrieve the data to render.
    `controller` is given to both `model` and `view` so that it can glue them together
    by setting up the appropriate callbacks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of a user clicking the `+` (increment) button, the following process
    would kick off:'
  prefs: []
  type: TYPE_NORMAL
- en: The DOM click event from `incrementButton` is received by the View
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The View fires its `onIncrementCallback()`, listened to by the Controller
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Controller instructs the Model to `increment()`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Model calls its mutation callback, that is, `onChangeCallback`, listened
    to by the Controller
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Controller instructs the View to re-render
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may be wondering why we bother with the separation between the Controller
    and the Model. Why can't the *View* just communicate with the Model directly and
    vice versa? Well, it can! But if we did that, we'd be polluting both our *View*
    and our *Model* with more logic and hence more complexity. We could equally just
    place everything in the *View* and have no Model, but you can imagine how unwieldy
    that would get. Fundamentally, the degree and quantity of separation will vary
    with every project you pursue. At its core, MVC teaches us about the general idea
    of how to separate the problem domain from its presentation. How we wield this
    separation is up to us.
  prefs: []
  type: TYPE_NORMAL
- en: Since 1978, when MVC was first coined, many adaptations of it have surfaced,
    but its central theme of separation between *Model* and *View* has persisted through
    the decades. Consider the architectural design of a React application. It includes
    Components, which contain the logic for rendering state, and typically will include
    several domain-specific reducers, which take actions (for example, *user has clicked
    something!*) and derive state from those actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This architecture looks surprisingly similar to traditional MVC:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3fb419a2-2ce5-4af8-a214-a7ad4d6d9d45.png)'
  prefs: []
  type: TYPE_IMG
- en: MVC, as a general guiding pattern, has impacted the design of countless frameworks
    and code bases throughout the last few decades, and it will continue to do so.
    Not every adaptation, reproduction, or MVC will abide by the original description
    posed in 1978 but, usually, these adaptations will stay true to the centrally
    important theme of separating a Model from its View and of having a View be a
    reflection (or even, a derivation) of a Model.
  prefs: []
  type: TYPE_NORMAL
- en: MVVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MVVM is similar in spirit to its ancestor, MVC. It prescribes a strict separation
    between the underlying business logic and data that drives a program and the rendering
    of that data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Model**: This describes the data and how business logic mutates that
    data. Changes in the data will manifest in changes to the **View**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The View**: This describes how the **Model** is rendered (its structure,
    layout, and appearance) and will invoke the **Data Binding** mechanism of the
    **ViewModel** whenever there is an action that needs to occur, possibly in response
    to a user event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The ViewModel**: This is the glue between the **Model** and the **View**
    and enables them to talk to each other via a **Data Binding** mechanism. This
    mechanism tends to vary a lot between implementations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The relationship between these parts is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e3109724-cf07-41a4-8303-a04730b7f4ce.png)'
  prefs: []
  type: TYPE_IMG
- en: The MVVM architecture is more popular in frontend JavaScript as it suits the
    need of having a constantly updated **View**, while traditional MVC is more popular
    on the backend as it caters well to the simple render-once nature of most HTTP
    responses.
  prefs: []
  type: TYPE_NORMAL
- en: Within MVVM, the data binding between the **ViewModel** and the **View** usually
    uses DOM events to track user intent and then mutates data on the **Model**, which
    then emits mutation events of its own that can be listened for by the **ViewModel**,
    resulting in the **View** being constantly kept up to date with changing data.
  prefs: []
  type: TYPE_NORMAL
- en: Many frameworks will have their own adaptation of data-binding. Angular, for
    example, allows you to specify in your HTML templates a custom attribute called
    `ng-model`, which will tie a user input element such as `<input>` to a given data
    model, allowing data to flow in both directions. If the Model is updated, `<input>`
    will be updated to reflect that and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: MV* and the nature of software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout your time as a JavaScript programmer, you will encounter variations
    of both MVC and MVVM. As patterns, they are infinitely applicable as they are
    concerned with the very basic tenets of a software system: the input of data into
    a system, the processing of that data, and the subsequent output of that processed
    data. There are a few other ways we could choose to architect these tenets into
    a code base, but it''s likely that, in the end, almost every time, we''ll end
    up with a system that delineates these concerns in a spirit similar to MVC (or
    MVVM).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a firm idea of how we might architect a code base and the
    types of delineations that characterize a well-designed architecture, we can explore
    the individual pieces of that code base: the modules themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In JavaScript, the word module has changed over the years. A module used to
    be any piece of code that was distinct and self-contained. A few years ago, you
    might have expressed several modules within the same file like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Nowadays, however, the word *module* tends to refer to Modules (capital *M)*
    as prescribed by the ECMAScript specification. These Modules are distinct files
    imported and exported across a code base via `import` and `export` statements.
    Using such Modules, we might have a `DropdownComponent.js` file that looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it uses the `export` statement to export its class. If we wish
    to use this class as a dependency, we would import it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: ECMAScript Modules are slowly gaining more support across various environments.
    To make use of them within the browser, you can provide an *entry* script tag
    with a type of *modul**e*, that is, `<script type="module" />`. Within Node.js,
    at the time of writing, ES Modules are still an experimental feature, so you can
    either rely on the old style of importing (`const thing = require('./thing')`)
    or you can enable *experimental modules* by using the `--experimental-modules`
    flag and using the `.mjs` extension on all of your JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the `import` and `export` statements permit a variety of syntaxes. These
    allow you to define the names of what you''re exporting or importing. In a scenario
    where a Module is only exporting one item, it is conventional to use `export default
    [item]` as we have done in `DropdownComponent.js`. This ensures that any dependents
    of the Module can import it and name it as they wish, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast to this, you can specifically name your exports by declaring them
    within curly braces and using the `as` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will mean that any importers will need to specifically specify the name
    of `TheDropdown`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can export named items by having specific declarations inline
    with your `export` statements, such as `var`, `const`, `let`, function declarations,
    or class definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'On the importing side, such named exports can be imported by, again, using
    curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When importing, you can also optionally designate the local name of that import
    with the `as` keyword to have its local name be different to its exported named
    (this is especially useful in cases of naming conflicts):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s conventional to aggregate exports in areas of your code that provide
    several related abstractions. For example, if you have composed a small Component
    library, where each Component exports itself as `default`, then you could have
    `index.js` that exposes all of the Components together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In Node.js, an `index.js`/`index.mjs` file is imported by default if you try
    to import an entire directory. That is, if you import `'./components/'`, it would
    first look for the index file and, if available, would import it. In the browser,
    no such convention currently exists. All imports must be fully qualified filenames.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, very conveniently, now import our entire set of Components by using
    the asterisk with our `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: There are some additional nuances and complexities around modules in JavaScript,
    especially when considering the legacies of Node.js, that we, unfortunately, don't
    have time to go into, but what we've covered so far should give you a good enough
    coverage of the topic to be productive and nicely paves the way for us to explore
    the topic of modular design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Modular design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modular design patterns are the structures and syntactic conventions we use
    to craft individual modules. We would usually employ these patterns within distinct
    JavaScript Modules. Each distinct file should offer up and export a specific abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself using these patterns several times within the same file,
    then it may be worth splitting them out. The directory and file structure of a
    given code base should ideally reflect its landscape of abstractions. You shouldn't
    have several abstractions crammed into a single file.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Constructor pattern uses a singular constructor and then manually fills
    its `prototype` with methods and properties. This was the traditional approach
    for creating classical OOP-like classes in JavaScript before the class definition
    syntax existed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, it begins with the definition of a constructor as a function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This would then be followed by assigning individual methods to the prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Or it would be followed by replacing the entire `prototype` with an object
    literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The latter approach tends to be preferred as it''s more encapsulated and succinct.
    Nowadays, of course, if you wished to use the Constructor pattern, you would likely
    opt for method definitions as they take up less space than individual key-value
    pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The instantiation of a constructor would be via the `new` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This creates a new object that has an internal `[[Prototype]]` of the constructor's
    `prototype` (that is, our object, which contains `getNumberOfPages`, `renderFrontCover`,
    and `renderBackCover`).
  prefs: []
  type: TYPE_NORMAL
- en: If you're struggling to recall the prototypal mechanisms that underlie constructors
    and instantiation, then please revisit [Chapter 6](ae94cc02-a077-4ffb-903a-b9ec222a2a09.xhtml),
    *Primitives and Built-in Types*, and, specifically, the section called *The prototype*.
  prefs: []
  type: TYPE_NORMAL
- en: When to use the Constructor pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Constructor pattern is useful in scenarios where you wish to have an abstraction
    that encapsulates the concept of a noun, that is, a thing that would make sense
    to have an instance of. Examples may include `NavigationComponent` or `StorageDevice`.
    The Constructor pattern allows you to create abstractions akin to traditional
    OOP classes. So, if you're coming from a classical OOP language, then you can
    feel free to use the Constructor pattern where you may have previously used classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re not sure whether the Constructor pattern is applicable, consider
    whether the following questions are true:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the concept expressible as a noun?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the concept require construction?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will the concept vary between instances?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the concept you're abstracting does not fulfill any of the preceding criteria,
    then you may want to consider another modular design pattern. An example of this
    may be a utility module that has various helper methods. Such a module may not
    require construction since it is essentially a collection of methods, and these
    methods and their behaviors would not vary between instances.
  prefs: []
  type: TYPE_NORMAL
- en: The Constructor pattern has largely fallen out of favor since the introduction
    of class definitions into JavaScript, which allow you to declare classes in a
    fashion much more akin to classical OOP languages (that is, `class X extends Y
    {...}`). Skip ahead to *The* *Class pattern* section to see this in action!
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance with the Constructor pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To achieve inheritance with the Constructor pattern, you need to manually make
    your `prototype` objects inherit from your parent constructor's `prototype`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the risk of over simplifying, we''ll illustrate this with the classic example
    of an `Animal` super-class and a `Monkey` subclass. Here is our definition of
    `Animal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Technically, to achieve inheritance, we want to create an object that has `[[Prototype]]`
    of `Animal.prototype` prototype and then use that newly-created object as our
    sub-class `prototype` subclass. The end goal is a prototypal tree that looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The easiest way to create an object with a given `[[Prototype]]` is with `Object.create(ThePrototype)`.
    Here, we can use it to extend `Animal.prototype` and assign the result to `Monkey.prototype`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then freely assign methods and properties to this new object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now try to instantiate `Monkey`, then we should be able to access not
    only its own methods and properties but also those we inherited from `Animal.prototype`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**Remember**, this only works because `Monkey.prototype` (that is, `[[Prototype]]`
    of every `Monkey` instance) does itself have `[[Prototype]]` of `Animal.prototype`.
    And, as we know, if a property cannot be found on a given object, then it''ll
    be looked for on its `[[Prototype]]` (*if available*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be quite cumbersome to individually set a prototype''s properties and
    methods one at a time, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to this, another pattern has emerged to make things easier: using `Object.assign()`.
    This allows us to set properties and methods in bulk as object literals, and it
    means we can make use of the method definition syntax as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`Object.assign` here will assign any properties from its second (and third,
    fourth, and so on) arguments to the object passed as the first argument. This
    provides us with a more succinct syntax for adding properties to our child `prototype`
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: The Constructor pattern and its inheritance conventions have largely lost favor
    due to the newer class definition syntax, which allows a more succinct and simpler
    way to harness prototypal inheritance in JavaScript. As such, the very next thing
    we will explore is the Class pattern, which uses this newer syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reminder**: For a more thorough refresher on `[[Prototype]]` (which is vital
    to understanding constructors and classes in JavaScript), you should re visit
    the section on *The prototype* in [Chapter 6](ae94cc02-a077-4ffb-903a-b9ec222a2a09.xhtml),
    *Primitives and Built-in Types*. A lot of the design patterns in this chapter
    make use of the prototype mechanism, so it''s useful to have it fresh in your
    mind.'
  prefs: []
  type: TYPE_NORMAL
- en: The Class pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Class pattern, which relies on the newer class definition syntax, has largely
    replaced the Constructor pattern. It involves the creation of classes, analogous
    to classical OOP languages, although behind the scenes it uses the same prototypal
    mechanism that the Constructor pattern uses. So, it can be said that it's just
    a bit of extra syntactic *sugar* to make the language a bit more expressive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a basic class that abstracts the concept of a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The creation of a class via this syntax is effectively the creation of a constructor
    with an attached prototype, hence the following code is exactly equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Using the Class pattern is certainly aesthetically preferable to the clunky
    and older Constructor pattern, but do not be misled! Behind the scenes, exactly
    the same mechanisms are at play.
  prefs: []
  type: TYPE_NORMAL
- en: When to use the Class pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Class pattern, much like the Constructor pattern, is useful when you have
    a self-contained concept that fulfills the following criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: The concept is expressible as a noun
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept requires construction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept will vary between instances of itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples of concepts that abide by these criteria and are hence
    reasonable to express via the Class pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: A database record (represents a piece of data and allows inquiry and manipulation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A todo item component (represents a todo item and allows it to be rendered)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A binary tree (represents a binary-tree data structure)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typically such cases will stick out quite obviously to you. If you're having
    trouble, consider the use cases of your abstraction and try to write some consumer
    code, that is, pseudo code that utilizes your abstraction. If it seems sensible
    and doesn't feel too awkward to use, then you've probably landed on a good pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Static methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Static methods and properties can be declared by using the `static` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'These properties and methods could also easily be added after the initial class
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Static methods are useful when you have a method or property whose functionality
    and existence are semantically related to the entire class as opposed to a singular
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Public and private fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To declare a public field (that is, a property) on your instance, you can simply
    declare this within the class definition syntax in line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'These fields are initialized for each instance and are, therefore, mutable
    on the instance itself. They''re most useful when you need to define some sensible
    default for a given property. This can then be easily overridden within the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also define private fields by prefixing their identifier with a `#`
    symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Traditionally, JavaScript had no concept of private fields, so programmers opted
    instead to prefix properties intended as private with one or more underscores
    (for example, `__somePropertyName`). This was understood as a social contract
    where other programmers would not mess with these properties (knowing that doing
    so might break things in unexpected ways).
  prefs: []
  type: TYPE_NORMAL
- en: 'Private fields are only accessible by the class itself. Sub-classes do not
    have access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Private fields should be used with extreme caution as they can severely limit
    the extensibility of your code, hence increasing its rigidity and lack of flexibility.
    If you use a private field, you should ensure that you have considered the consequences.
    It may be the case that what you need is, in fact, just a pseudo-private field,
    prefixed with an underscore (for example, `_private`) or another obscure piece
    of punctuation (for example, `$_private`). Doing this will, by convention, ensure
    that fellow programmers making use of your interface will (hopefully) understand
    that they should not make use of the field publicly. If they do so, then the implication
    is that they may break things. If they wish to extend your class with their own
    implementation, then they can make use of your private field freely.
  prefs: []
  type: TYPE_NORMAL
- en: Extending classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inheritance within the Class pattern can very simply be achieved by using the `class
    ... extends` syntax like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This will ensure that any instance of `Tiger` will have `[[Prototype]]`, which
    itself has `[[Prototype]]` of `Animal.prototype`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have confirmed that each new instance of `Tiger` has `[[Prototype]]`
    of `Tiger.prototype` and that `Tiger.prototype` inherits from `Animal.prototype.`
  prefs: []
  type: TYPE_NORMAL
- en: Mixing-in classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conventionally, an extension is used not only to create semantic sub-classes
    but also to provide mixins of methods. JavaScript provides no native mixing-in
    mechanism so to achieve it you, either need to augment the prototype after the
    definition or effectively inherit from your mixins (as if they are superclasses).
  prefs: []
  type: TYPE_NORMAL
- en: 'Augmenting a `prototype` with your mixins is the simplest approach. We can
    achieve this by specifying mixins as objects and then adding them to `prototype`
    of a class via a convenient method such as `Object.assign`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach, however, does not allow `MyClass` to override its own mixin
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This is expected behavior but creates a headache for us in some cases. Therefore,
    to achieve a more generalized mixin approach, we can explore a different mechanism.
    Instead of directly *mixing-in* methods to an existing `prototype` object, we
    can use inheritance. This can most easily be achieved by so-called *Subclass Factories.*
    These are essentially just functions that themselves return a class that extends
    a specified super-class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example of how it might work in reality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can additionally implement a helper to combine any number of these *Subclass
    Factories*. It can do so by constructing a chain (or tree) of `[[Prototype]]`
    links that is as long as the list of `mixins` we provide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Note how we have the default `base` class of our mixin reduction as `Object`.
    This is to ensure that `Object` is always at the top of our inheritance tree (and
    that we're not creating pointless intermediary classes).
  prefs: []
  type: TYPE_NORMAL
- en: 'And here''s how we would make use of our `mixin` helper: first, we''d define
    our sub-class factories (that is, the actual mixins):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can construct a class definition using both of these mixins via the
    `mixin` helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the result''s `MyClass` instances will have access to its own
    prototype (containing `myMethod`), alpha''s prototype (containing `alphaMethod`),
    and bravo''s prototype (containing `bravoMethod`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Mixins can be awkward to get right, so it helps to utilize a library or proven
    piece of code to take care of this for you. The mixin mechanism you should use
    will probably depend on the exact characteristics you''re seeking. In this section,
    we''ve seen two examples: one where we compose methods into a singular `[[Prototype]]`
    via `Object.assign()`, and another where we create a tree of inheritance (that
    is, a chain of `[[Prototypes]]`) to represent our mixin hierarchy. Hopefully,
    you are now in a better position to select which one of these (or indeed, all
    of the others available online) are best suited to your needs.'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a super-class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All functions within a class defined using the method definition syntax have
    the `super` binding available, which provides access to the super-class and its
    properties. The `super()` function is available to invoke directly (which will
    call the constructor of the super-class) and can provide access to specific methods
    (`super.methodName()`).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are extending another class and you are defining your own constructor,
    you must call `super()` and you must do so before any other code within your constructor
    that modifies the instance (that is, `this`) in any way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If your constructor attempts to call `super()` after modifying the instance,
    or if it attempts to avoid calling `super()`, then you will receive `ReferenceError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `super` binding and its oddities are described in greater detail in [Chapter
    6](ae94cc02-a077-4ffb-903a-b9ec222a2a09.xhtml), *Primitives and Built-in Types*
    (see the section on *Function bindings*).
  prefs: []
  type: TYPE_NORMAL
- en: The Prototype pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Prototype pattern involves using plain objects to act as templates for other
    objects. The Prototype pattern extends this template object directly without fussing
    with instantiation via `new` or `Constructor.prototype` objects. You can think
    of it as similar to conventional constructor or Class patterns minus the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, you''ll first create an object to act as your template. This will
    have all of the methods and properties associated with your abstraction. In the
    case of an `inputComponent` abstraction, it may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note how `inputComponent` starts with a lowercase character. By convention,
    only constructor functions should be named with an initial capital letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using our `inputComponent` template, we can then create (or instantiate) specific
    instances using `Object.create`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''ve learned, `Object.create(thePrototype)` simply creates a new object
    and sets its internal `[[Prototype]]` property to `thePrototype`, meaning that
    any properties accessed on the new object will be looked for on `thePrototype`
    if they are not available on the object itself. As such, we can treat the resulting
    object just like any other classical instance, accessing properties as we would
    on instances resulting from the more conventional Constructor or Class patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'For convenience, we could also introduce a method on `inputComponent` itself
    designed to do the object creation work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that we can create individual instances with slightly less code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we wish to create other types of inputs, then we can easily extend `inputComponent`,
    as we already have; add some methods to our the resulting object; and then offer
    that new object up for others to extend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: To override a particular method and access its parent, as you can see, we need
    to reference and call it directly (`InputComponent.render.call()`). You may expect
    that we should be able to use `super.render()` but, unfortunately, `super` only
    refers to `[[Prototype]]` of the object (the home) on which the containing method
    is defined. And because `Object.assign()` effectively steals these methods off
    their home objects, `super` would refer to the wrong thing.
  prefs: []
  type: TYPE_NORMAL
- en: The Prototype pattern is rather confusingly named. As we've seen, both the conventional
    Constructor pattern and the newer Class pattern involve the prototype, so you
    may want to instead refer to this pattern as the *Object Extension Pattern* or
    even the *No-Constructor Approach to Prototypal Inheritance*. Whatever you decide,
    it's quite a rare pattern. The classical OOP patterns are usually favored.
  prefs: []
  type: TYPE_NORMAL
- en: When to use the Prototype pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Prototype pattern is most useful in scenarios where you have an abstraction
    that will have varying characteristics between instances (or extensions) but does
    not require construction. At its core, the Prototype pattern really only refers
    to the extension mechanism (that is, via `Object.create`), so it can equally be
    used in any scenario where you have objects that may semantically relate to other
    objects via inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a scenario in which we need to represent sandwich data. Every sandwich
    has a name, a bread type, and three slots for ingredients. For example, here is
    the representation of a BLT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We may wish to create an adaptation of the BLT, reusing most of its characteristics
    except the `Tomato` ingredient, which will be replaced with `Avocado`. We could
    simply clone the object wholesale, by using `Object.assign` to copy all the properties
    from `theBLT` to a fresh object and then specifically copying over (that is, overwriting)
    `slotC`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'But what if the BLT''s `breadType` was changed? Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `theBLA` is out of sync with `theBLT`. We have realized that what we actually
    want  here is an inheritance Model so that `breadType` of `theBLA` will always
    match `breadType` of its parent sandwich. To achieve this, we can simply change
    our creation of `theBLA` so that it inherits from `theBLT` (using the Prototype
    pattern):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'If we later change a characteristic of `theBLT`, it will helpfully be reflected
    in `theBLA` via inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This constructor-less Model of inheritance, as you can see, can be useful in
    some scenarios. We could equally represent this data using straightforward classes
    but with such basic data that may be overkill. The Prototype pattern is useful
    in that it provides a simple and explicit mechanism of inheritance that *can*
    result in less clunky code (although, equally, if misapplied, can lead to more
    complexity).
  prefs: []
  type: TYPE_NORMAL
- en: The Revealing Module pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Revealing Module pattern is a pattern used to encapsulate some private
    logic and then expose a public API. There are a few adaptations of this pattern,
    but usually it is expressed via an **Immediately Invoked Function Expression**
    (**IIFE**) that returns an object literal containing the public methods and properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Any functions returned by the IIFE will form a closure around their respective
    scopes, meaning that they will continue to have access to the *private* scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a real-world Revealing Module would be this simple DOM Component
    that contains logic for rendering a notification to users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The notification variable in the outer scope will refer to the object returned
    by the IIFE, meaning we have access to its public API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The Revealing Module pattern is especially useful in scenarios where you need
    to have a delineation between private and public, where you have specific initialization
    logic, and where, for whatever reason, your abstraction does not suit more object-oriented
    patterns (Class or Constructor patterns).
  prefs: []
  type: TYPE_NORMAL
- en: Before the existence of class definitions and `#private` fields, the Revealing
    Module pattern was the only easy way to emulate real privacy. As such, it has
    somewhat fallen out of favor. Some programmers still make use of it but, usually,
    only due to aesthetic preferences.
  prefs: []
  type: TYPE_NORMAL
- en: The Conventional Module pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Conventional Module pattern is usually expressed as a plain object literal
    with a set of methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s quite typical for such a module to also reveal specific initialization
    methods such as `initialize`, `init`, or `setup`. Alternatively, we may want to
    provide methods that change the state or configuration of the entire module (such
    as `setConfig`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The Conventional Module pattern is incredibly flexible since it is just a plain
    object. JavaScript''s treatment of functions as first-class citizens (that is,
    they''re just like any other value) means that you can easily compose the objects
    of methods from functions defined elsewhere, as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Conventionally, you may have considered using an inheritance or mixin pattern
    to include this `log` method in our library module, but here we're simply composing
    it ourselves by referencing and inserting it directly into our object. This pattern
    gives us a lot of flexibility in terms of how we reuse code in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: When to use the Conventional Module pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Conventional Module pattern is useful in any scenario where you simply
    wish to wrap up a set of related methods or properties into something with a common
    name. They are often used for collections of common methods that somehow relate
    to each other, such as logging utilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The Conventional Module pattern is just an object, so it's arguably unnecessary
    to even mention it at all. But, technically, it is an alternative to other techniques
    of abstraction definition, so it's useful to designate it as a pattern of its
    own.
  prefs: []
  type: TYPE_NORMAL
- en: The Singleton Class pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Class pattern is quite quickly become the de facto pattern for creating
    abstractions of all types, including singletons and utility objects as well, so
    it may not always be the case that your class will need to be utilized as a conventionally
    OOP class with inheritance and instantiation. For example, we may wish to set
    up a utility object with a class definition so that we can define any initialization
    logic within the constructor and provide a semblance of encapsulation within its
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're creating and immediately instantiating a class. This is similar
    in spirit to the Revealing Module pattern where we utilize an IIFE to encapsulate
    initialization logic and the public API. Here, instead of achieving that encapsulation
    via a scope (and the resulting closure around private variables), we are using
    the straightforward constructor to define our initialization. We then are using
    the regular instance properties and methods to define both our private variables
    and our public interface.
  prefs: []
  type: TYPE_NORMAL
- en: When to use the Singleton Class pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Singletons are useful when only one instance of a class is required. The singular
    instance produced is similar in nature to the Conventional or Revealing Module
    pattern. It enables you to wrap up an abstraction with the option of private variables
    and implicit construction logic. Common use cases of singletons include *Utilities*,
    *Logging*, *Caching*, *Global Event Buse*s, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Planning and harmony
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deciding on which architectural and modular design patterns to use can be a
    tricky process, as usually at the time of deciding, it may not be immediately
    obvious what all of the requirements of the project are. Also, we as programmers
    are not omniscient. We are flawed, egoistic, and usually passionate individuals.
    This combination, if not kept in check, can yield chaotic code bases with designs
    that block the very productivity, reliability, and maintainability that we are
    trying to foster. To be wary of these pitfalls, remember the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Expect change and adaptation**: Every software project will involve change
    at some point. If we are forward-thinking in our architectural and modular designs,
    then we will be able to limit this future pain, but never begin a project thinking
    that you will create the *One True Solution*. Instead, iterate, question your
    judgment, and then iterate again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consult with other programmers**: Talk to the stakeholders who will have
    to make use of your code. That may be fellow programmers on your team or other
    programmers who''ll be making use of the interfaces that you''re providing. Field
    opinions and data and then make an informed decision.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid cargo culting and ego**: Be aware of cargo culting and your ego and
    how, if we''re not careful, we can blindly inherit ways of doing things without
    crucially considering their suitability, or we can be trapped by our egos: thinking
    that one specific design or methodology is perfect just because it''s the one
    we personally know and love.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bias toward harmony and consistency**: When designing an architecture, above
    all, seek harmony. There is always the possibility of many individually tailored
    parts of a code base, but too many internal differences can confuse maintainers
    and lead to a code base of splintered quality and reliability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored the purpose and application of design patterns
    in JavaScript. This has spanned a foundational introspection on what it even means
    for something to be a design pattern and an exploration of some common modular
    and architectural design patterns. We have explored the various ways we can declare
    abstractions using JavaScript's native mechanisms such as classes and prototypes,
    and some more novel mechanisms such as the Revealing Module pattern. Our deep
    coverage of these patterns will ensure that, in the future, we have ample options
    available to us when crafting our abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be exploring real-world challenges encountered
    by JavaScript programmers, such as state management and network communication,
    and applying our knowledge of new perspectives to them.
  prefs: []
  type: TYPE_NORMAL
