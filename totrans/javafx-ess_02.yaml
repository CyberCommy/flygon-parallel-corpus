- en: Chapter 2. JavaFX 8 Essentials and Creating a Custom UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting to know the essentials of JavaFX will definitely help you to easily
    build complicated and complex UI solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will get a brief introduction about JavaFX 8 architecture,
    so you get an idea of how JavaFX architecture components and engines interconnect
    together with your JavaFX application efficiently and render its graphics smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to render graphics on the JavaFX scene and, for that, we
    will create a basic application using a scene, some controls, and styling.
  prefs: []
  type: TYPE_NORMAL
- en: We will touch upon the fundamentals of Java SE 8 features (such as **Lambda**
    and **functional interfaces**) to help increase code readability, quality, and
    productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have our first structured JavaFX 8 application, wouldn't it be nice
    if you could change the UI of your application without altering its functionality?
    You will learn about theming by having a glance at the fundamentals of JavaFX
    CSS styling.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will find out how to use Scene Builder to create and define UI
    screens graphically and save them as a JavaFX FXML-formatted file. And you will
    get hands-on experience of creating *custom controls*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding JavaFX architecture components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JavaFX components to set up the UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Java SE 8, Lambda expressions, and other features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Theming your application to target different platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the application UI with CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Scene Builder tool to create the UI visually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a custom UI with FXML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick review of the JavaFX 8 architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To better understand how the framework's components and engines interact together
    to run your JavaFX application, this section gives a high-level description of
    the JavaFX architecture and ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure illustrates the JavaFX platform's architectural components.
    It displays each component and how each of them interconnects.
  prefs: []
  type: TYPE_NORMAL
- en: The engine that is responsible for running your JavaFX application code lies
    below the JavaFX public APIs.
  prefs: []
  type: TYPE_NORMAL
- en: This engine is composed of subcomponents. These include **Prism**, a JavaFX
    high-performance graphics engine; the Glass toolkit, a small and efficient windowing
    system; a media engine; and a web engine.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While these components are not exposed through public APIs, we will describe
    them so you have a better idea of what makes JavaFX applications run successfully
    in an efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: '![Quick review of the JavaFX 8 architecture](img/B03998_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: JavaFX architecture diagram
  prefs: []
  type: TYPE_NORMAL
- en: For more information and a description of the JavaFX architecture and ecosystem,
    visit [http://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-architecture.htm](http://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-architecture.htm).
  prefs: []
  type: TYPE_NORMAL
- en: Scene graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every application has a starting root point to construct a UI hierarchy, and
    the starting point for JavaFX applications is the *scene graph*. In the preceding
    screenshot, it is shown as part of the top layer in blue. It is the root tree
    of nodes that represents all of the visual elements of the application's user
    interface. It also tracks and handles any user input and can be rendered, as it
    is itself a UI node.
  prefs: []
  type: TYPE_NORMAL
- en: '*Node* is any single element in the scene graph tree. Each node has these properties
    by default – an ID for identification, a list of style classes for changing its
    visual properties, and a bounding volume to fit correctly on the scene with other
    components and inside its parent layout container node, with the exception of
    the root node of a scene graph.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each node in a scene graph tree has a single parent but could have zero or
    more children; however, the scene root has no parent (is null). Moreover, JavaFX
    has a mechanism to ensure a node could have only a single parent; it can also
    have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual effects, such as blurs and shadows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling components transparency via opacity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU-accelerated 2D transforms, transitions, and rotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3D transforms such as transitions, scaling, and rotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event handlers (such as mouse events, key events, or other input methods such
    as touch events)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An application-specific state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows the relationship between the stage, scene, UI nodes,
    and graphical tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scene graphs](img/B03998_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: JavaFX UI tree hierarchy relationship
  prefs: []
  type: TYPE_NORMAL
- en: The graphics primitives also are an integral part of the JavaFX scene graph,
    such as lines, rectangles, and text in addition to images, media, UI controls,
    and layout containers.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to delivering complex and rich UIs for customers, scene graphs
    simplify this task. Also, you can use the `javafx.animation` APIs to quickly and
    easily animate various graphics in the scene graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these features, the `javafx.scene` API allows the creation and
    specification of several content types as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nodes**: Any node element represented as UI controls, charts, groups, containers,
    embedded web browser, shapes (2-D and 3-D), images, media, and text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Effects**: These are simple objects that, when applied to a UI node, change
    its appearance on the scene graph node, such as blurs, shadows, and color adjustment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State**: Any application-specific state such as transforms (positioning and
    orientation of nodes) and visual effects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java public APIs for JavaFX features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is your Swiss-knife toolkit provided as a complete set of Java public APIs
    that support rich client application development.
  prefs: []
  type: TYPE_NORMAL
- en: These APIs provide you with unprecedented flexibility to construct your rich
    client UI applications by combining the best capabilities of the Java SE platform
    with comprehensive, immersive media functionality into an intuitive and comprehensive
    one-stop development environment at hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'These Java APIs for JavaFX allow you to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the powerful features of Java SE, from generics, annotations, and multithreading,
    to new Lambda Expressions (introduced in Java SE 8).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides an easier way for web developers to use JavaFX from other JVM-based
    dynamic languages, such as *JavaScript*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing large and complex JavaFX applications by integrating other system languages,
    such as *Groovy*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding your UI controls to your controller attributes for automatic notifications
    and updates to be reflected from your model to bound UI nodes. Binding includes
    support for high-performance lazy binding, binding expressions, bound sequence
    expressions, and partial bind reevaluation. We will see this in action and more
    in [Chapter 3](ch03.html "Chapter 3. Developing a JavaFX Desktop and Web Application"),
    *Developing a JavaFX Desktop and Web Application*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing observable lists and maps, which allow applications to wire UIs
    to data models to observe the changes in those data models and update the corresponding
    UI control accordingly by extending the Java collections library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphics System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JavaFX Graphics System, shown in Purple in the preceding figure, supports
    both 2D and 3D scene graphs to run smoothly on the JavaFX scene graph layer. As
    it is the implementation detail beneath this layer, it provides the rendering
    software stack when running on a system that doesn't have sufficient graphics
    hardware to support hardware-accelerated rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JavaFX platform has two graphics-accelerated pipelines that implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prism**: This is the engine that processes all render jobs. It can run on
    both hardware and software renderers, including 3D. Rasterization and rendering
    of JavaFX scenes are taken care of by this engine. Based on the device being used,
    the following multiple render paths are possible:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DirectX 9 on Windows XP and Vista, and DirectX 11 on Windows 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenGL on Linux, Mac, and Embedded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software rendering when hardware acceleration is not possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quantum Toolkit**: This is responsible for linking the Prism engine and Glass
    Windowing Toolkit together to make them available to the JavaFX layer above them
    in the stack. This is in addition to managing any threading rules related to rendering
    versus event handling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Glass Windowing Toolkit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Glass Windowing Toolkit, shown in red in the middle portion of the preceding
    figure, serves as the platform-dependent layer that connects the JavaFX platform
    to the native operating system.
  prefs: []
  type: TYPE_NORMAL
- en: As its main responsibility is to provide native operating services, such as
    managing the timers, windows, and surfaces, its position in the rendering stack
    is the lowest.
  prefs: []
  type: TYPE_NORMAL
- en: JavaFX threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Normally, the system runs two or more of the following threads at any given
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaFX application thread**: This is the main and primary thread used by
    the JavaFX application to run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prism render thread**: This handles rendering separately from the event dispatcher.
    It renders frame N while frame N +1 is being prepared to process next. Its big
    advantage is the ability to perform concurrent processing, especially on modern
    systems that have multiple processors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Media thread**: This runs in the background and synchronizes the latest frames
    through the scene graph by using the JavaFX application thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pulse**: This enables you to have a way to handle events asynchronously.
    It helps you manage synchronization between the JavaFX scene graph elements state
    and an event of the scene graph with the Prism engine. When it is fired, the state
    of the elements on the scene graph is synchronized to the rendering layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any Layout nodes and CSS are also tied to pulse events.
  prefs: []
  type: TYPE_NORMAL
- en: The *Glass Windowing Toolkit* executes all pulse events using high-resolution
    native timers to make the execution.
  prefs: []
  type: TYPE_NORMAL
- en: Media and images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JavaFX `javafx.scene.media` APIs provide media functionality. JavaFX supports
    both visual and audio media. For audio files, it supports `MP3`, `AIFF`, and `WAV`
    files and `FLV` video files.
  prefs: []
  type: TYPE_NORMAL
- en: You can access your media functionalities through three main separate components
    provided by JavaFX media – the `Media` object represents a media file, `MediaPlayer`
    plays a media file, and `MediaView` is a node that displays the media into your
    scene graph.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Media Engine component, shown in orange in the preceding figure, has been
    designed carefully with stability and performance in mind to provide a consistent
    behavior across all supported platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Web component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The web engine component, shown in green in the preceding figure, is one of
    the most important JavaFX UI controls and is built based on the WebKit engine,
    which is an open source web browser engine that supports HTML5, JavaScript, CSS,
    DOM rendering, and SVG graphics. It provides a web viewer and full browsing functionality
    through its API. We will dive deep into this in [Chapter 3](ch03.html "Chapter 3. Developing
    a JavaFX Desktop and Web Application"), *Developing a JavaFX Desktop and Web Application*,
    when developing web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'It allows you to add and implement the following features in your Java applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Render any HTML content from a local or remote URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide Back and Forward navigation, and support history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reload the content for any updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animate and apply CSS effects to the web component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide rich editing control for HTML content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can execute JavaScript commands and handle web control events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layout components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When building a rich and complex UI, we need a way to allow for flexible and
    dynamic arrangements of the UI controls within the JavaFX application. This is
    the best place to use Layout containers or panes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Layout API includes the following container classes that automate common
    layout UI patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**BorderPane**: This lays out its content nodes in the top, bottom, right,
    left, or center region'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HBox**: This arranges its content nodes horizontally in a single row'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VBox**: This arranges its content nodes vertically in a single column'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**StackPane**: This places its content nodes in a back-to-front single stack
    at the center of the pane'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GridPane**: This enable the creation of a flexible grid of rows and columns
    in which to lay out content nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FlowPane**: This arranges its content nodes in either a horizontal or vertical
    flow, wrapping at the specified width (for horizontal) or height (for vertical)
    boundaries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TilePane**: This places its content nodes in uniformly sized layout cells
    or tiles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AnchorPane**: This enables the creation of anchor nodes to the top, bottom,
    left-hand side, or center of the layout, and we can freely position its child
    nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Different containers can be nested within a JavaFX application; to achieve the
    desired layout structure, we will see this in action next when developing our
    Custom UI.
  prefs: []
  type: TYPE_NORMAL
- en: JavaFX controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaFX controls are the building blocks of your UI layout, and they reside in
    the `javafx.scene.control` package as a set of JavaFX APIs. They are built by
    using nodes in the scene graph. They can be themed and skinned by JavaFX CSS.
    They are portable *across different platforms*. They take full advantage of the
    visually rich features of the JavaFX platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'This figure shows some of the UI controls that are currently supported and
    there are more not shown here as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JavaFX controls](img/B03998_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: JavaFX UI controls sample
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more detailed information about all the available JavaFX UI controls, see
    the official tutorial at [http://docs.oracle.com/javase/8/javafx/user-interface-tutorial/ui_controls.htm#JFXUI336](http://docs.oracle.com/javase/8/javafx/user-interface-tutorial/ui_controls.htm#JFXUI336)
    and the API documentation for the `javafx.scene.control` package.
  prefs: []
  type: TYPE_NORMAL
- en: Java SE 8 features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will scratch the surface of Java SE 8 to understand two of the most important
    features – lambda or lambda expressions and functional interfaces, which make
    the lambdas available to us, to help write better, concise, and low-boilerplate
    JavaFX 8 code. However, keep in mind that we will not address every lambda detail
    in this book, as this is not a Java SE 8 book.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get a better idea of Java''s lambda roadmap, visit the following official
    tutorial: [http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html](http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The primary goal of project **lambda** in the Java language is to address the
    lack of functional programming and provide a way to do functional programming
    easily by creating anonymous (unnamed) functions in a similar manner to creating
    anonymous objects instead of methods in Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you saw in the example from [Chapter 1](ch01.html "Chapter 1. Getting Started
    with JavaFX 8"), *Getting Started with JavaFX 8*, we talked about the usual approach
    for defining a handler for the pressed event on a JavaFX button by using an anonymous
    inner class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code is very verbose as compared to just wiring up a single line of code
    that sets the `text` attribute of the message text field in a button action. Wouldn't
    it be nice to be able to rewrite this block of code containing your logic without
    the need of so much boilerplate code?
  prefs: []
  type: TYPE_NORMAL
- en: 'Java SE 8 solves this with a Lambda expressions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Beyond making your code more concise and easy to read, lambda expressions make
    your code perform better as well.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two ways to write lambda expressions, and the general form is as
    shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Syntax](img/B03998_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Lambda expression general form – creating a new thread as an example
  prefs: []
  type: TYPE_NORMAL
- en: 'These two ways are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(param1, param2, ...) -> expression;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(param1, param2, ...) -> { /* code statements */ };`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first form, the expression form, is used when we assign only one line of
    code or just a simple expression. While the second one, the block form, is a body
    of single or multiple lines of code, with a return statement, so we need to wrap
    them with curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following three statements are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '`btn.setOnAction((ActionEvent event) -> {message.setText("Hello World!");});`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`btn.setOnAction( (event) -> message.setText("Hello World!"));`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`btn.setOnAction(event -> message.setText("Hello World!"));`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To dive deeper into the new lambda expressions and their related features alongside
    the Java SE 8 features, I encourage you to try this articles series – Java SE
    8 new features tour: [http://tamanmohamed.blogspot.com/2014/06/java-se-8-new-features-tour-big-change.html](http://tamanmohamed.blogspot.com/2014/06/java-se-8-new-features-tour-big-change.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Functional interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lambda expression is fantastic, isn't it?, but you may be wondering what its
    exact type is, so it can be assigned to variables and passed to methods.
  prefs: []
  type: TYPE_NORMAL
- en: The answer is in the power of functional interfaces. How? Functional interfaces,
    cleverly created by Java language designers/architects as closures, use the concept
    of **Single Abstract Method** (**SAM**), providing an interface with just one
    abstract method, and the `@FunctionalInterface` annotation. The single abstract
    method pattern is an integral part of Java SE 8's lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s clear things up with an example to illustrate the concept of both functional
    interfaces and lambda expressions. I have created a functional interface called
    `Calculator.java` containing a single abstract method, `calculate()`. Once it
    is created, you can declare and assign variables to lambda expressions. The following
    is the functional interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to create variables and assign them lambda expressions. The
    following code creates and assigns lambda expressions to our functional interface
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the code should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Theming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with designers and UX/UI specialists, you will hear about skinning
    the application or changing its appearance. Both terms are often interchangeable,
    and both of them reflect the basic concept of *theming*.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of theming is to change the entire application style by changing its
    control appearance and without altering its underlying functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In JavaFX, you have the ability to create, modify, or use existing themes to
    skin your applications, scene, or even just a UI control.
  prefs: []
  type: TYPE_NORMAL
- en: CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaFX **Cascading Style Sheets** (**CSS**) can be applied to any node in the
    JavaFX scene graph; they are applied to the nodes asynchronously. Styles can also
    be easily assigned to the scene at runtime, allowing an application's appearance
    to change dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: It is based on the W3C CSS version 2.1 specifications, and is currently compatible
    with some additions from the current work on version 3\. The JavaFX CSS support
    and extensions have been designed to allow JavaFX CSS style sheets to be parsed
    cleanly by any compliant CSS parser. This enables the mixing of CSS styles for
    JavaFX and for other purposes (such as for HTML pages) into a single style sheet.
  prefs: []
  type: TYPE_NORMAL
- en: All JavaFX property names are prefixed with an extension of `-fx-`, including
    those that might looks compatible with standard HTML CSS, because some JavaFX
    values have slightly different semantics from standard ones.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more about JavaFX CSS, see the Skinning JavaFX Applications with CSS document
    and the reference guide at [http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html](http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html).
  prefs: []
  type: TYPE_NORMAL
- en: Applying CSS theme
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is a custom simple JavaFX CSS rule, `ButtonStyle.css`, that is to be used
    in our theming process to theme a button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two ways to apply CSS style sheets to change the look-and-feel theming
    of our JavaFX applications:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a JavaFX Application (`javafx.application.Application`) class static
    method `setUserAgentStylesheet(String URL)` method, which styles all the application
    hierarchy, including every scene and all child nodes in a JavaFX application.
    It is used as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can use JavaFX 8''s two style sheets that currently come preshipped,
    Caspian and Modena, and we can switch between them using the same method as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are invoking `setUserAgentStylesheet(null)` by passing a null value,
    the default look and feel will be loaded (in this case, Modena) whereas, if you
    are using JavaFX 2.x Caspian, the default one will be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using scene''s `getStylesheets().add(String URL)` method will style the individual
    scene and its child node automatically as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Basically, the default theme (Modena) will be loaded, as `Application.setUserAgentStylesheet(null)`
    is called. It then sets the scene's additional styling by invoking the `getStylesheets().add()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Styles are first applied to the parent and then to its children. A node is styled
    after it is added to the scene graph, regardless of whether it's shown or not.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaFX CSS implementation applies the following order of precedence – a
    style from a user agent style sheet has lower priority than a value set from code,
    which has lower priority than a Scene or Parent style sheet.
  prefs: []
  type: TYPE_NORMAL
- en: Inline styles have the highest precedence. Style sheets from a Parent instance
    are considered to be more specific than styles from Scene style sheets.
  prefs: []
  type: TYPE_NORMAL
- en: Scene Builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For most complex and sophisticated UI requirements, wouldn't it be easier for
    designers to use a tool to design their UI with a WYSIWYG interface, without writing
    any code, and then load the result (`FXML` file) into their JavaFX application
    logic?
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, you need JavaFX Scene Builder; it is a visual layout tool that allows
    you to easily lay out your UI controls so that you can quickly prototype your
    application with effects and animations. Scene Builder (version 2.0 upwards) is
    the compatible version for JavaFX 8.
  prefs: []
  type: TYPE_NORMAL
- en: At any time during the creation of your project, you can preview your work to
    check its real appearance before deploying it.
  prefs: []
  type: TYPE_NORMAL
- en: It is open source and therefore it integrates with most IDEs, but more tightly
    with the NetBeans IDE. It is also a cross-platform, self-contained application
    that runs on most platforms.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to supporting CSS, it allows you to easily apply custom theming
    to your prototype.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and launching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the beginning of 2015, Oracle release JavaFX Scene Builder tool version 2.0,
    and announced that it will no longer be providing builds of the JavaFX Scene Builder
    tool (in compiled form).
  prefs: []
  type: TYPE_NORMAL
- en: A company called **Gluon** ([http://gluonhq.com](http://gluonhq.com)) understands
    that tools can make or break a coding experience. So they have decided to begin
    providing builds, based on a fork they will maintain in a publicly accessible
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Gluon provides IDE plugins, as well as improved builds of the JavaFX Scene Builder
    tool based on the latest sources from OpenJFX, with additional improvements based
    on community involvement and a desire to better support third party projects such
    as **ControlsFX** ([http://www.controlsfx.org/](http://www.controlsfx.org/)),
    **FXyz** ([https://github.com/FXyz/FXyz](https://github.com/FXyz/FXyz)), and **DataFX**
    ([http://www.datafx.io/](http://www.datafx.io/)).
  prefs: []
  type: TYPE_NORMAL
- en: To get started let's download the tool from the following URL [http://gluonhq.com/products/downloads/](http://gluonhq.com/products/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: 'After downloading version 8.0 and installing it, launch it and the Scene Builder
    tool should open as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Downloading and launching](img/B03998_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The JavaFX 8 Scene Builder tool.
  prefs: []
  type: TYPE_NORMAL
- en: FXML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While adding components and building your beautiful UI layout, Scene Builder
    under the hood generates a FXML - and XML-based markup file for you automatically,
    which will be used later to be bind your UI to your Java application logic.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main advantages FXML provide is separation of concerns, as it decouples
    UI layer (*view*) from logic (*Controller*); this means you can alter UI at anytime
    without changing underlying logic. Since the FXML file is not compiled, it can
    be dynamically loaded at runtime without any required compilation. This means
    it helps you with rapid prototyping.
  prefs: []
  type: TYPE_NORMAL
- en: Loading FXML into JavaFX applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is very easy task to add your UI design after generating it from the Scene
    Builder tool. Shown here is code to load an FXML file in a `start()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, I am using the static method load on the `javafx.fxml.FXMLLoaderclass`,
    The `load()` method will load (`deserialize`) the FXML file that was created by
    the Scene Builder tool.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a custom UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the final part of this chapter, we are going to develop a custom UI component
    based on JavaFX 8 built-in controls.
  prefs: []
  type: TYPE_NORMAL
- en: We will develop this custom UI with concepts discussed before that are based
    on FXML; the primary advantage is the separation of concerns to customize the
    component later on without altering its functionality and any other logic bound
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: The Login dialog custom UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use most of the previously covered tools and techniques to develop
    our custom UI: the Login Dialog, which is a necessary component in every Enterprise
    application. Our UI component will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Login dialog custom UI](img/B03998_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Login custom UI component
  prefs: []
  type: TYPE_NORMAL
- en: Structure of the Login dialog custom UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most common structure and stages in custom component development based
    on FXML markup are these:'
  prefs: []
  type: TYPE_NORMAL
- en: Develop the UI inside the Scene Builder tool; then export the result to the
    FXML-based file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract the controller skeleton from the Scene builder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a controller that binds the UI (view) to its logic and extends either
    a control or a layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load the FXML file inside the Controller constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an initialization method that makes sure that all FXML controls are initialized
    and loaded successfully
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expose public attributes to get and set control data and action methods that
    need our implementation logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop a separate CSS file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the custom component inside your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding the Login dialog custom UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s code and develop our custom UI, the Login Dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Scene Builder tool and create the UI. Its properties are as shown in
    the following figure:![Coding the Login dialog custom UI](img/B03998_02_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The login dialog layout hierarchy will be as shown here:![Coding the Login dialog
    custom UI](img/B03998_02_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It consists of a Pane layout as the top and root layout node. Then, `GridPane(1,4)`
    is used to lay out the controls in a grid of one column and four rows using these:'
  prefs: []
  type: TYPE_NORMAL
- en: The **first** row contains the `HBox` layout control at location (`0,0`) to
    lay out the controls horizontally. It consists of the `ImageView` control to show
    the logo and Label for the title.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **second** row lays out the username `TextField` for the username attribute,
    at location (`0,1`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **third** row lays out the password `PasswordField` for password attribute,
    at location (`0,2`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **last** row, at location (`0,3`), has a root layout control `HBox`, and
    it lays out another HBox that contains the `CheckBox` and `Label` (for showing
    errors and other messages) controls aligned to the center-left. We then have two
    button controls, **Reset** and **Login**, which are aligned to the center-right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the Code tab, add a proper **fx:id** name to all of the controls in the
    dialog, and a name to `onAction` for buttons and checkbox events as in the following
    screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Coding the Login dialog custom UI](img/B03998_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Login button properties
  prefs: []
  type: TYPE_NORMAL
- en: From the Scene Builder **Preview** menu, choose **Show preview in windows**.
    Your layout will pop up. If everything is okay and you are satisfied with the
    resulting design, from the menu bar, click on **File**, then **Save**, and enter
    the file name as `LoginUI.fxml`. Congratulations! You have created your first
    JavaFX UI layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we will open NetBeans to set up a JavaFX FXML project, so launch NetBeans,
    and from the **File** menu, choose **New Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **JavaFX** category, choose **JavaFX FXML Application**. Click on **Next**.
    Then name the project **LoginControl**, change **FXML name** to `LoginUI`, and
    click on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure that the JavaFX platform is Java SE 8.
  prefs: []
  type: TYPE_NORMAL
- en: NetBeans will create a project structure as shown here:![Coding the Login dialog
    custom UI](img/B03998_02_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Login Control NetBeans project structure.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure to *clean and build* your project before running it, to avoid any
    problems you may face, especially when running your application and possibility
    loading the `*.fxml` file during runtime may return `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Scene Builder tool and, from **View**, select **Show sample controller
    skeleton**. The window shown in the following screenshot will open, which we will
    copy to replace `LoginUIController.java` (this which extends the `Pane` class
    content code with the copied content in NetBeans) and then fix the missing imports.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the previously generated and saved `LoginUI.fxml` file from Scene Builder
    with one already created by NetBeans.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `LoginController.java` file, choose **Refactor**, then **Rename**,
    and rename it to `Main.java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, add the following code in the `start(Stage stage)` method of `Main.java
    class` as shown here. We are creating a new instance of the login component as
    a root node of our scene and adding it to the stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![Coding the Login dialog custom UI](img/B03998_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `LoginUIController.java` class, right-click under the class name and
    choose **Insert Code**; then choose **Constructor** and finally add the following
    code inside the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code loads our `LoginUI.fxml` document and returns it as the Pane layout
    with its hierarchy. It then binds it to the current controller instance as the
    Controller and root node at the same time. Note that the controller extends Pane
    as the root element definition in `LoginUI.fxml`.
  prefs: []
  type: TYPE_NORMAL
- en: From NetBeans, choose **Clean and Build** and then right-click on the project
    and choose **Run**. The same screen we saw earlier should appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While the program is running, enter any credentials and click on the **Login**
    button; an error message will appear in red as shown in the following screenshot:![Coding
    the Login dialog custom UI](img/B03998_02_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Login Control invalid login.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the right credentials (user: *tamanm*, pass: *Tamanm*) are entered, the
    green message appears with "*Valid Credentials*", as shown in the following figure.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the **Reset** button is clicked, then all controls return to the default
    values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations! You have successfully created and implemented a UI custom control.
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding the Login dialog custom UI](img/B03998_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered a lot of ground – getting started with a brief
    introduction about JavaFX 8 architecture components that act as the foundation
    layer to run your JavaFX application smoothly and efficiently. Then followed we
    explored how to render graphics on the scene with a brief explanation about the
    most common layouts and UI controls.
  prefs: []
  type: TYPE_NORMAL
- en: You were introduced to new features in Java SE 8 such as lambda expressions
    and functional interfaces, which was supported by examples showing the power of
    each.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to style your application with custom CSS files by using the
    `setUserAgentStylesheet(String URL)` and `getStylesheets().add(String URL)` methods.
    Next, you took a short look at the Scene Builder and how to load FXML into a scene.
    Finally, you learned about custom UI components in JavaFX and how to create them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to create a desktop application that
    consists of multiple scenes and then how to package it. Additionally, we will
    learn how to interact with the Web and develop web applications using JavaFX 8.
  prefs: []
  type: TYPE_NORMAL
