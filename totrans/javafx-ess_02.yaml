- en: Chapter 2. JavaFX 8 Essentials and Creating a Custom UI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting to know the essentials of JavaFX will definitely help you to easily
    build complicated and complex UI solutions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will get a brief introduction about JavaFX 8 architecture,
    so you get an idea of how JavaFX architecture components and engines interconnect
    together with your JavaFX application efficiently and render its graphics smoothly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to render graphics on the JavaFX scene and, for that, we
    will create a basic application using a scene, some controls, and styling.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: We will touch upon the fundamentals of Java SE 8 features (such as **Lambda**
    and **functional interfaces**) to help increase code readability, quality, and
    productivity.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Once we have our first structured JavaFX 8 application, wouldn't it be nice
    if you could change the UI of your application without altering its functionality?
    You will learn about theming by having a glance at the fundamentals of JavaFX
    CSS styling.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will find out how to use Scene Builder to create and define UI
    screens graphically and save them as a JavaFX FXML-formatted file. And you will
    get hands-on experience of creating *custom controls*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Understanding JavaFX architecture components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JavaFX components to set up the UI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Java SE 8, Lambda expressions, and other features
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Theming your application to target different platforms
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the application UI with CSS
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Scene Builder tool to create the UI visually
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a custom UI with FXML
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick review of the JavaFX 8 architecture
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To better understand how the framework's components and engines interact together
    to run your JavaFX application, this section gives a high-level description of
    the JavaFX architecture and ecosystem.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The following figure illustrates the JavaFX platform's architectural components.
    It displays each component and how each of them interconnects.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The engine that is responsible for running your JavaFX application code lies
    below the JavaFX public APIs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: This engine is composed of subcomponents. These include **Prism**, a JavaFX
    high-performance graphics engine; the Glass toolkit, a small and efficient windowing
    system; a media engine; and a web engine.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While these components are not exposed through public APIs, we will describe
    them so you have a better idea of what makes JavaFX applications run successfully
    in an efficient way.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![Quick review of the JavaFX 8 architecture](img/B03998_02_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: JavaFX architecture diagram
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: For more information and a description of the JavaFX architecture and ecosystem,
    visit [http://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-architecture.htm](http://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-architecture.htm).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Scene graphs
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every application has a starting root point to construct a UI hierarchy, and
    the starting point for JavaFX applications is the *scene graph*. In the preceding
    screenshot, it is shown as part of the top layer in blue. It is the root tree
    of nodes that represents all of the visual elements of the application's user
    interface. It also tracks and handles any user input and can be rendered, as it
    is itself a UI node.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '*Node* is any single element in the scene graph tree. Each node has these properties
    by default – an ID for identification, a list of style classes for changing its
    visual properties, and a bounding volume to fit correctly on the scene with other
    components and inside its parent layout container node, with the exception of
    the root node of a scene graph.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Each node in a scene graph tree has a single parent but could have zero or
    more children; however, the scene root has no parent (is null). Moreover, JavaFX
    has a mechanism to ensure a node could have only a single parent; it can also
    have the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Visual effects, such as blurs and shadows
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling components transparency via opacity
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU-accelerated 2D transforms, transitions, and rotations
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3D transforms such as transitions, scaling, and rotations
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event handlers (such as mouse events, key events, or other input methods such
    as touch events)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An application-specific state
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows the relationship between the stage, scene, UI nodes,
    and graphical tree:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![Scene graphs](img/B03998_02_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: JavaFX UI tree hierarchy relationship
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: The graphics primitives also are an integral part of the JavaFX scene graph,
    such as lines, rectangles, and text in addition to images, media, UI controls,
    and layout containers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to delivering complex and rich UIs for customers, scene graphs
    simplify this task. Also, you can use the `javafx.animation` APIs to quickly and
    easily animate various graphics in the scene graph.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these features, the `javafx.scene` API allows the creation and
    specification of several content types as the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '**Nodes**: Any node element represented as UI controls, charts, groups, containers,
    embedded web browser, shapes (2-D and 3-D), images, media, and text'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Effects**: These are simple objects that, when applied to a UI node, change
    its appearance on the scene graph node, such as blurs, shadows, and color adjustment'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State**: Any application-specific state such as transforms (positioning and
    orientation of nodes) and visual effects'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java public APIs for JavaFX features
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is your Swiss-knife toolkit provided as a complete set of Java public APIs
    that support rich client application development.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: These APIs provide you with unprecedented flexibility to construct your rich
    client UI applications by combining the best capabilities of the Java SE platform
    with comprehensive, immersive media functionality into an intuitive and comprehensive
    one-stop development environment at hand.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'These Java APIs for JavaFX allow you to do the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Use the powerful features of Java SE, from generics, annotations, and multithreading,
    to new Lambda Expressions (introduced in Java SE 8).
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides an easier way for web developers to use JavaFX from other JVM-based
    dynamic languages, such as *JavaScript*.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing large and complex JavaFX applications by integrating other system languages,
    such as *Groovy*.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding your UI controls to your controller attributes for automatic notifications
    and updates to be reflected from your model to bound UI nodes. Binding includes
    support for high-performance lazy binding, binding expressions, bound sequence
    expressions, and partial bind reevaluation. We will see this in action and more
    in [Chapter 3](ch03.html "Chapter 3. Developing a JavaFX Desktop and Web Application"),
    *Developing a JavaFX Desktop and Web Application*.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing observable lists and maps, which allow applications to wire UIs
    to data models to observe the changes in those data models and update the corresponding
    UI control accordingly by extending the Java collections library.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphics System
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JavaFX Graphics System, shown in Purple in the preceding figure, supports
    both 2D and 3D scene graphs to run smoothly on the JavaFX scene graph layer. As
    it is the implementation detail beneath this layer, it provides the rendering
    software stack when running on a system that doesn't have sufficient graphics
    hardware to support hardware-accelerated rendering.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'The JavaFX platform has two graphics-accelerated pipelines that implement:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '**Prism**: This is the engine that processes all render jobs. It can run on
    both hardware and software renderers, including 3D. Rasterization and rendering
    of JavaFX scenes are taken care of by this engine. Based on the device being used,
    the following multiple render paths are possible:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DirectX 9 on Windows XP and Vista, and DirectX 11 on Windows 7
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenGL on Linux, Mac, and Embedded
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software rendering when hardware acceleration is not possible
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quantum Toolkit**: This is responsible for linking the Prism engine and Glass
    Windowing Toolkit together to make them available to the JavaFX layer above them
    in the stack. This is in addition to managing any threading rules related to rendering
    versus event handling.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Glass Windowing Toolkit
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Glass Windowing Toolkit, shown in red in the middle portion of the preceding
    figure, serves as the platform-dependent layer that connects the JavaFX platform
    to the native operating system.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: As its main responsibility is to provide native operating services, such as
    managing the timers, windows, and surfaces, its position in the rendering stack
    is the lowest.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: JavaFX threads
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Normally, the system runs two or more of the following threads at any given
    time:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaFX application thread**: This is the main and primary thread used by
    the JavaFX application to run.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prism render thread**: This handles rendering separately from the event dispatcher.
    It renders frame N while frame N +1 is being prepared to process next. Its big
    advantage is the ability to perform concurrent processing, especially on modern
    systems that have multiple processors.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Media thread**: This runs in the background and synchronizes the latest frames
    through the scene graph by using the JavaFX application thread.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pulse**: This enables you to have a way to handle events asynchronously.
    It helps you manage synchronization between the JavaFX scene graph elements state
    and an event of the scene graph with the Prism engine. When it is fired, the state
    of the elements on the scene graph is synchronized to the rendering layer.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any Layout nodes and CSS are also tied to pulse events.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The *Glass Windowing Toolkit* executes all pulse events using high-resolution
    native timers to make the execution.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Media and images
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JavaFX `javafx.scene.media` APIs provide media functionality. JavaFX supports
    both visual and audio media. For audio files, it supports `MP3`, `AIFF`, and `WAV`
    files and `FLV` video files.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: You can access your media functionalities through three main separate components
    provided by JavaFX media – the `Media` object represents a media file, `MediaPlayer`
    plays a media file, and `MediaView` is a node that displays the media into your
    scene graph.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Media Engine component, shown in orange in the preceding figure, has been
    designed carefully with stability and performance in mind to provide a consistent
    behavior across all supported platforms.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Web component
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The web engine component, shown in green in the preceding figure, is one of
    the most important JavaFX UI controls and is built based on the WebKit engine,
    which is an open source web browser engine that supports HTML5, JavaScript, CSS,
    DOM rendering, and SVG graphics. It provides a web viewer and full browsing functionality
    through its API. We will dive deep into this in [Chapter 3](ch03.html "Chapter 3. Developing
    a JavaFX Desktop and Web Application"), *Developing a JavaFX Desktop and Web Application*,
    when developing web applications.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'It allows you to add and implement the following features in your Java applications:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Render any HTML content from a local or remote URL
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide Back and Forward navigation, and support history
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reload the content for any updates
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animate and apply CSS effects to the web component
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide rich editing control for HTML content
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can execute JavaScript commands and handle web control events
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layout components
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When building a rich and complex UI, we need a way to allow for flexible and
    dynamic arrangements of the UI controls within the JavaFX application. This is
    the best place to use Layout containers or panes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'The Layout API includes the following container classes that automate common
    layout UI patterns:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '**BorderPane**: This lays out its content nodes in the top, bottom, right,
    left, or center region'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HBox**: This arranges its content nodes horizontally in a single row'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VBox**: This arranges its content nodes vertically in a single column'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**StackPane**: This places its content nodes in a back-to-front single stack
    at the center of the pane'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GridPane**: This enable the creation of a flexible grid of rows and columns
    in which to lay out content nodes'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FlowPane**: This arranges its content nodes in either a horizontal or vertical
    flow, wrapping at the specified width (for horizontal) or height (for vertical)
    boundaries'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TilePane**: This places its content nodes in uniformly sized layout cells
    or tiles'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AnchorPane**: This enables the creation of anchor nodes to the top, bottom,
    left-hand side, or center of the layout, and we can freely position its child
    nodes'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Different containers can be nested within a JavaFX application; to achieve the
    desired layout structure, we will see this in action next when developing our
    Custom UI.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: JavaFX controls
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaFX controls are the building blocks of your UI layout, and they reside in
    the `javafx.scene.control` package as a set of JavaFX APIs. They are built by
    using nodes in the scene graph. They can be themed and skinned by JavaFX CSS.
    They are portable *across different platforms*. They take full advantage of the
    visually rich features of the JavaFX platform.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'This figure shows some of the UI controls that are currently supported and
    there are more not shown here as well:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![JavaFX controls](img/B03998_02_03.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: JavaFX UI controls sample
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more detailed information about all the available JavaFX UI controls, see
    the official tutorial at [http://docs.oracle.com/javase/8/javafx/user-interface-tutorial/ui_controls.htm#JFXUI336](http://docs.oracle.com/javase/8/javafx/user-interface-tutorial/ui_controls.htm#JFXUI336)
    and the API documentation for the `javafx.scene.control` package.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Java SE 8 features
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will scratch the surface of Java SE 8 to understand two of the most important
    features – lambda or lambda expressions and functional interfaces, which make
    the lambdas available to us, to help write better, concise, and low-boilerplate
    JavaFX 8 code. However, keep in mind that we will not address every lambda detail
    in this book, as this is not a Java SE 8 book.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get a better idea of Java''s lambda roadmap, visit the following official
    tutorial: [http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html](http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The primary goal of project **lambda** in the Java language is to address the
    lack of functional programming and provide a way to do functional programming
    easily by creating anonymous (unnamed) functions in a similar manner to creating
    anonymous objects instead of methods in Java.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'As you saw in the example from [Chapter 1](ch01.html "Chapter 1. Getting Started
    with JavaFX 8"), *Getting Started with JavaFX 8*, we talked about the usual approach
    for defining a handler for the pressed event on a JavaFX button by using an anonymous
    inner class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code is very verbose as compared to just wiring up a single line of code
    that sets the `text` attribute of the message text field in a button action. Wouldn't
    it be nice to be able to rewrite this block of code containing your logic without
    the need of so much boilerplate code?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Java SE 8 solves this with a Lambda expressions as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Beyond making your code more concise and easy to read, lambda expressions make
    your code perform better as well.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Syntax
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two ways to write lambda expressions, and the general form is as
    shown in the following figure:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![Syntax](img/B03998_02_04.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: Lambda expression general form – creating a new thread as an example
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'These two ways are as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '`(param1, param2, ...) -> expression;`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(param1, param2, ...) -> { /* code statements */ };`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first form, the expression form, is used when we assign only one line of
    code or just a simple expression. While the second one, the block form, is a body
    of single or multiple lines of code, with a return statement, so we need to wrap
    them with curly braces.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'The following three statements are equivalent:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '`btn.setOnAction((ActionEvent event) -> {message.setText("Hello World!");});`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`btn.setOnAction( (event) -> message.setText("Hello World!"));`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`btn.setOnAction(event -> message.setText("Hello World!"));`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To dive deeper into the new lambda expressions and their related features alongside
    the Java SE 8 features, I encourage you to try this articles series – Java SE
    8 new features tour: [http://tamanmohamed.blogspot.com/2014/06/java-se-8-new-features-tour-big-change.html](http://tamanmohamed.blogspot.com/2014/06/java-se-8-new-features-tour-big-change.html)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Functional interfaces
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lambda expression is fantastic, isn't it?, but you may be wondering what its
    exact type is, so it can be assigned to variables and passed to methods.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The answer is in the power of functional interfaces. How? Functional interfaces,
    cleverly created by Java language designers/architects as closures, use the concept
    of **Single Abstract Method** (**SAM**), providing an interface with just one
    abstract method, and the `@FunctionalInterface` annotation. The single abstract
    method pattern is an integral part of Java SE 8's lambda expressions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s clear things up with an example to illustrate the concept of both functional
    interfaces and lambda expressions. I have created a functional interface called
    `Calculator.java` containing a single abstract method, `calculate()`. Once it
    is created, you can declare and assign variables to lambda expressions. The following
    is the functional interface:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we are ready to create variables and assign them lambda expressions. The
    following code creates and assigns lambda expressions to our functional interface
    variables:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of the code should be as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Theming
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with designers and UX/UI specialists, you will hear about skinning
    the application or changing its appearance. Both terms are often interchangeable,
    and both of them reflect the basic concept of *theming*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The idea of theming is to change the entire application style by changing its
    control appearance and without altering its underlying functionality.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: In JavaFX, you have the ability to create, modify, or use existing themes to
    skin your applications, scene, or even just a UI control.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: CSS
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaFX **Cascading Style Sheets** (**CSS**) can be applied to any node in the
    JavaFX scene graph; they are applied to the nodes asynchronously. Styles can also
    be easily assigned to the scene at runtime, allowing an application's appearance
    to change dynamically.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: It is based on the W3C CSS version 2.1 specifications, and is currently compatible
    with some additions from the current work on version 3\. The JavaFX CSS support
    and extensions have been designed to allow JavaFX CSS style sheets to be parsed
    cleanly by any compliant CSS parser. This enables the mixing of CSS styles for
    JavaFX and for other purposes (such as for HTML pages) into a single style sheet.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: All JavaFX property names are prefixed with an extension of `-fx-`, including
    those that might looks compatible with standard HTML CSS, because some JavaFX
    values have slightly different semantics from standard ones.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more about JavaFX CSS, see the Skinning JavaFX Applications with CSS document
    and the reference guide at [http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html](http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Applying CSS theme
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is a custom simple JavaFX CSS rule, `ButtonStyle.css`, that is to be used
    in our theming process to theme a button:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We have two ways to apply CSS style sheets to change the look-and-feel theming
    of our JavaFX applications:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a JavaFX Application (`javafx.application.Application`) class static
    method `setUserAgentStylesheet(String URL)` method, which styles all the application
    hierarchy, including every scene and all child nodes in a JavaFX application.
    It is used as follows:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now you can use JavaFX 8''s two style sheets that currently come preshipped,
    Caspian and Modena, and we can switch between them using the same method as shown
    here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以使用JavaFX 8当前预装的两个样式表，Caspian和Modena，我们可以使用与此处相同的方法在它们之间切换：
- en: '[PRE7]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are invoking `setUserAgentStylesheet(null)` by passing a null value,
    the default look and feel will be loaded (in this case, Modena) whereas, if you
    are using JavaFX 2.x Caspian, the default one will be loaded.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过传递空值来调用`setUserAgentStylesheet(null)`，则将加载默认的外观和感觉（在这种情况下为Modena），而如果您使用JavaFX
    2.x Caspian，则将加载默认的外观和感觉。
- en: 'Using scene''s `getStylesheets().add(String URL)` method will style the individual
    scene and its child node automatically as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用场景的`getStylesheets().add(String URL)`方法将自动为个别场景及其子节点设置样式，如下所示：
- en: '[PRE8]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Basically, the default theme (Modena) will be loaded, as `Application.setUserAgentStylesheet(null)`
    is called. It then sets the scene's additional styling by invoking the `getStylesheets().add()`
    method.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，将加载默认主题（Modena），因为调用了`Application.setUserAgentStylesheet(null)`。然后通过调用`getStylesheets().add()`方法设置场景的额外样式。
- en: Styles are first applied to the parent and then to its children. A node is styled
    after it is added to the scene graph, regardless of whether it's shown or not.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先应用样式到父级，然后应用到其子级。节点在添加到场景图后进行样式设置，无论它是否显示。
- en: The JavaFX CSS implementation applies the following order of precedence – a
    style from a user agent style sheet has lower priority than a value set from code,
    which has lower priority than a Scene or Parent style sheet.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX CSS实现应用以下优先顺序 - 用户代理样式表的样式优先级低于从代码设置的值，后者优先级低于场景或父级样式表。
- en: Inline styles have the highest precedence. Style sheets from a Parent instance
    are considered to be more specific than styles from Scene style sheets.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 内联样式具有最高优先级。来自父级实例的样式表被认为比场景样式表的样式更具体。
- en: Scene Builder
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scene Builder
- en: For most complex and sophisticated UI requirements, wouldn't it be easier for
    designers to use a tool to design their UI with a WYSIWYG interface, without writing
    any code, and then load the result (`FXML` file) into their JavaFX application
    logic?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数复杂和复杂的UI需求，设计师使用工具在WYSIWYG界面中设计他们的UI，而无需编写任何代码，然后将结果（`FXML`文件）加载到他们的JavaFX应用程序逻辑中会更容易吗？
- en: Therefore, you need JavaFX Scene Builder; it is a visual layout tool that allows
    you to easily lay out your UI controls so that you can quickly prototype your
    application with effects and animations. Scene Builder (version 2.0 upwards) is
    the compatible version for JavaFX 8.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您需要JavaFX Scene Builder；它是一个可视化布局工具，可以让您轻松地布置UI控件，以便您可以快速地使用效果和动画原型化您的应用程序。Scene
    Builder（2.0及以上版本）是JavaFX 8的兼容版本。
- en: At any time during the creation of your project, you can preview your work to
    check its real appearance before deploying it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目创建过程中的任何时候，您都可以预览您的工作，以检查其真实外观，然后再部署它。
- en: It is open source and therefore it integrates with most IDEs, but more tightly
    with the NetBeans IDE. It is also a cross-platform, self-contained application
    that runs on most platforms.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 它是开源的，因此与大多数IDE集成，但与NetBeans IDE更紧密。它还是一个跨平台的、独立的应用程序，可以在大多数平台上运行。
- en: In addition to supporting CSS, it allows you to easily apply custom theming
    to your prototype.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了支持CSS，它还允许您轻松地将自定义主题应用于您的原型。
- en: Downloading and launching
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载和启动
- en: At the beginning of 2015, Oracle release JavaFX Scene Builder tool version 2.0,
    and announced that it will no longer be providing builds of the JavaFX Scene Builder
    tool (in compiled form).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年初，Oracle发布了JavaFX Scene Builder工具2.0版本，并宣布将不再提供JavaFX Scene Builder工具的构建（已编译形式）。
- en: A company called **Gluon** ([http://gluonhq.com](http://gluonhq.com)) understands
    that tools can make or break a coding experience. So they have decided to begin
    providing builds, based on a fork they will maintain in a publicly accessible
    repository.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一家名为**Gluon**（[http://gluonhq.com](http://gluonhq.com)）的公司意识到工具可以改善或破坏编码体验。因此，他们决定开始提供基于他们将在公开可访问的存储库中维护的分支的构建。
- en: Gluon provides IDE plugins, as well as improved builds of the JavaFX Scene Builder
    tool based on the latest sources from OpenJFX, with additional improvements based
    on community involvement and a desire to better support third party projects such
    as **ControlsFX** ([http://www.controlsfx.org/](http://www.controlsfx.org/)),
    **FXyz** ([https://github.com/FXyz/FXyz](https://github.com/FXyz/FXyz)), and **DataFX**
    ([http://www.datafx.io/](http://www.datafx.io/)).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Gluon提供IDE插件，以及基于OpenJFX最新源代码的JavaFX Scene Builder工具的改进版本，还有基于社区参与和更好地支持第三方项目（如**ControlsFX**
    ([http://www.controlsfx.org/](http://www.controlsfx.org/))、**FXyz** ([https://github.com/FXyz/FXyz](https://github.com/FXyz/FXyz))和**DataFX**
    ([http://www.datafx.io/](http://www.datafx.io/))）的额外改进。
- en: To get started let's download the tool from the following URL [http://gluonhq.com/products/downloads/](http://gluonhq.com/products/downloads/).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下URL下载工具开始[http://gluonhq.com/products/downloads/](http://gluonhq.com/products/downloads/)。
- en: 'After downloading version 8.0 and installing it, launch it and the Scene Builder
    tool should open as in the following screenshot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下载版本8.0并安装后，启动它，Scene Builder工具应该如下截图所示打开：
- en: '![Downloading and launching](img/B03998_02_05.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![下载和启动](img/B03998_02_05.jpg)'
- en: The JavaFX 8 Scene Builder tool.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX 8 Scene Builder工具。
- en: FXML
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FXML
- en: While adding components and building your beautiful UI layout, Scene Builder
    under the hood generates a FXML - and XML-based markup file for you automatically,
    which will be used later to be bind your UI to your Java application logic.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加组件和构建美丽的UI布局时，Scene Builder在幕后自动生成一个FXML - 基于XML的标记文件，以便稍后将其绑定到Java应用程序逻辑的UI。
- en: One of the main advantages FXML provide is separation of concerns, as it decouples
    UI layer (*view*) from logic (*Controller*); this means you can alter UI at anytime
    without changing underlying logic. Since the FXML file is not compiled, it can
    be dynamically loaded at runtime without any required compilation. This means
    it helps you with rapid prototyping.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Loading FXML into JavaFX applications
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is very easy task to add your UI design after generating it from the Scene
    Builder tool. Shown here is code to load an FXML file in a `start()` method:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, I am using the static method load on the `javafx.fxml.FXMLLoaderclass`,
    The `load()` method will load (`deserialize`) the FXML file that was created by
    the Scene Builder tool.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Developing a custom UI
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the final part of this chapter, we are going to develop a custom UI component
    based on JavaFX 8 built-in controls.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: We will develop this custom UI with concepts discussed before that are based
    on FXML; the primary advantage is the separation of concerns to customize the
    component later on without altering its functionality and any other logic bound
    to it.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The Login dialog custom UI
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use most of the previously covered tools and techniques to develop
    our custom UI: the Login Dialog, which is a necessary component in every Enterprise
    application. Our UI component will be as shown in the following screenshot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![The Login dialog custom UI](img/B03998_02_06.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: Login custom UI component
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Structure of the Login dialog custom UI
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most common structure and stages in custom component development based
    on FXML markup are these:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Develop the UI inside the Scene Builder tool; then export the result to the
    FXML-based file
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract the controller skeleton from the Scene builder
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a controller that binds the UI (view) to its logic and extends either
    a control or a layout
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load the FXML file inside the Controller constructor
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an initialization method that makes sure that all FXML controls are initialized
    and loaded successfully
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expose public attributes to get and set control data and action methods that
    need our implementation logic
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop a separate CSS file
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the custom component inside your application
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding the Login dialog custom UI
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s code and develop our custom UI, the Login Dialog:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Open the Scene Builder tool and create the UI. Its properties are as shown in
    the following figure:![Coding the Login dialog custom UI](img/B03998_02_07.jpg)
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The login dialog layout hierarchy will be as shown here:![Coding the Login dialog
    custom UI](img/B03998_02_08.jpg)
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It consists of a Pane layout as the top and root layout node. Then, `GridPane(1,4)`
    is used to lay out the controls in a grid of one column and four rows using these:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The **first** row contains the `HBox` layout control at location (`0,0`) to
    lay out the controls horizontally. It consists of the `ImageView` control to show
    the logo and Label for the title.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **second** row lays out the username `TextField` for the username attribute,
    at location (`0,1`).
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **third** row lays out the password `PasswordField` for password attribute,
    at location (`0,2`).
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **last** row, at location (`0,3`), has a root layout control `HBox`, and
    it lays out another HBox that contains the `CheckBox` and `Label` (for showing
    errors and other messages) controls aligned to the center-left. We then have two
    button controls, **Reset** and **Login**, which are aligned to the center-right.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the Code tab, add a proper **fx:id** name to all of the controls in the
    dialog, and a name to `onAction` for buttons and checkbox events as in the following
    screenshot:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Coding the Login dialog custom UI](img/B03998_02_09.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: Login button properties
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: From the Scene Builder **Preview** menu, choose **Show preview in windows**.
    Your layout will pop up. If everything is okay and you are satisfied with the
    resulting design, from the menu bar, click on **File**, then **Save**, and enter
    the file name as `LoginUI.fxml`. Congratulations! You have created your first
    JavaFX UI layout.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Scene Builder的**预览**菜单中，选择**在窗口中显示预览**。您的布局将弹出。如果一切正常，并且您对结果设计满意，从菜单栏中单击**文件**，然后单击**保存**，并输入文件名为`LoginUI.fxml`。恭喜！您已经创建了您的第一个JavaFX
    UI布局。
- en: Now we will open NetBeans to set up a JavaFX FXML project, so launch NetBeans,
    and from the **File** menu, choose **New Project**.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将打开NetBeans来设置一个JavaFX FXML项目，因此启动NetBeans，并从**文件**菜单中选择**新建项目**。
- en: In the **JavaFX** category, choose **JavaFX FXML Application**. Click on **Next**.
    Then name the project **LoginControl**, change **FXML name** to `LoginUI`, and
    click on **Finish**.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**JavaFX**类别中，选择**JavaFX FXML应用程序**。单击**下一步**。然后将项目命名为**LoginControl**，将**FXML名称**更改为`LoginUI`，然后单击**完成**。
- en: Tip
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Make sure that the JavaFX platform is Java SE 8.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 确保JavaFX平台是Java SE 8。
- en: NetBeans will create a project structure as shown here:![Coding the Login dialog
    custom UI](img/B03998_02_10.jpg)
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NetBeans将创建如下的项目结构：![编码登录对话框自定义UI](img/B03998_02_10.jpg)
- en: Login Control NetBeans project structure.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 登录控制NetBeans项目结构。
- en: Note
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure to *clean and build* your project before running it, to avoid any
    problems you may face, especially when running your application and possibility
    loading the `*.fxml` file during runtime may return `null`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行项目之前，请确保*清理和构建*您的项目，以避免可能出现的任何问题，特别是在运行应用程序和可能在运行时加载`*.fxml`文件时可能返回`null`。
- en: Go to the Scene Builder tool and, from **View**, select **Show sample controller
    skeleton**. The window shown in the following screenshot will open, which we will
    copy to replace `LoginUIController.java` (this which extends the `Pane` class
    content code with the copied content in NetBeans) and then fix the missing imports.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到Scene Builder工具，并从**视图**中选择**显示示例控制器骨架**。将打开如下截图所示的窗口，我们将复制以替换`LoginUIController.java`（这将扩展`Pane`类内容代码与NetBeans中复制的内容）然后修复缺少的导入。
- en: Replace the previously generated and saved `LoginUI.fxml` file from Scene Builder
    with one already created by NetBeans.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用NetBeans已经创建的一个替换之前生成并保存的`LoginUI.fxml`文件。
- en: Right-click on the `LoginController.java` file, choose **Refactor**, then **Rename**,
    and rename it to `Main.java`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`LoginController.java`文件，选择**重构**，然后选择**重命名**，将其重命名为`Main.java`。
- en: 'Finally, add the following code in the `start(Stage stage)` method of `Main.java
    class` as shown here. We are creating a new instance of the login component as
    a root node of our scene and adding it to the stage:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`Main.java类`的`start(Stage stage)`方法中添加以下代码，如下所示。我们正在创建登录组件的新实例作为我们场景的根节点，并将其添加到舞台上：
- en: '[PRE10]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Coding the Login dialog custom UI](img/B03998_02_11.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![编码登录对话框自定义UI](img/B03998_02_11.jpg)'
- en: 'In the `LoginUIController.java` class, right-click under the class name and
    choose **Insert Code**; then choose **Constructor** and finally add the following
    code inside the constructor:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LoginUIController.java`类中，在类名下右键单击选择**插入代码**；然后选择**构造函数**，最后在构造函数中添加以下代码：
- en: '[PRE11]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code loads our `LoginUI.fxml` document and returns it as the Pane layout
    with its hierarchy. It then binds it to the current controller instance as the
    Controller and root node at the same time. Note that the controller extends Pane
    as the root element definition in `LoginUI.fxml`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码加载我们的`LoginUI.fxml`文档，并将其作为Pane布局与其层次结构返回。然后将其绑定到当前控制器实例作为控制器和根节点。请注意，控制器扩展了Pane作为`LoginUI.fxml`中根元素定义。
- en: From NetBeans, choose **Clean and Build** and then right-click on the project
    and choose **Run**. The same screen we saw earlier should appear.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从NetBeans中选择**清理和构建**，然后右键单击项目选择**运行**。应该出现与之前看到的相同的屏幕。
- en: While the program is running, enter any credentials and click on the **Login**
    button; an error message will appear in red as shown in the following screenshot:![Coding
    the Login dialog custom UI](img/B03998_02_12.jpg)
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序运行时，输入任何凭据并单击**登录**按钮；如下截图所示，将出现红色的错误消息：![编码登录对话框自定义UI](img/B03998_02_12.jpg)
- en: Login Control invalid login.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 登录控制无效登录。
- en: 'If the right credentials (user: *tamanm*, pass: *Tamanm*) are entered, the
    green message appears with "*Valid Credentials*", as shown in the following figure.'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入正确的凭据（用户：*tamanm*，密码：*Tamanm*），则将显示绿色消息“*有效凭据*”，如下图所示。
- en: If the **Reset** button is clicked, then all controls return to the default
    values.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果单击**重置**按钮，则所有控件都将返回默认值。
- en: Congratulations! You have successfully created and implemented a UI custom control.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功创建并实现了一个UI自定义控件。
- en: '![Coding the Login dialog custom UI](img/B03998_02_13.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![编码登录对话框自定义UI](img/B03998_02_13.jpg)'
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered a lot of ground – getting started with a brief
    introduction about JavaFX 8 architecture components that act as the foundation
    layer to run your JavaFX application smoothly and efficiently. Then followed we
    explored how to render graphics on the scene with a brief explanation about the
    most common layouts and UI controls.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容-简要介绍了JavaFX 8架构组件，这些组件作为基础层来顺利高效地运行JavaFX应用程序。然后我们探讨了如何在场景上呈现图形，并简要解释了最常见的布局和UI控件。
- en: You were introduced to new features in Java SE 8 such as lambda expressions
    and functional interfaces, which was supported by examples showing the power of
    each.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解了Java SE 8中的新功能，例如lambda表达式和函数接口，这些功能得到了示例的支持，展示了每个功能的强大之处。
- en: You learned how to style your application with custom CSS files by using the
    `setUserAgentStylesheet(String URL)` and `getStylesheets().add(String URL)` methods.
    Next, you took a short look at the Scene Builder and how to load FXML into a scene.
    Finally, you learned about custom UI components in JavaFX and how to create them.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to create a desktop application that
    consists of multiple scenes and then how to package it. Additionally, we will
    learn how to interact with the Web and develop web applications using JavaFX 8.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
