- en: Data Serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 73\. Serializing and deserializing data to/from XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a program that can serialize a list of movies to an XML file, and deserialize
    an XML file with a list of movies. Each movie has a numerical identifier, title,
    release year, length in minutes, a list of directors, a list of writers, and a
    list of casting roles with actor name and character name. Such an XML may look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 74\. Selecting data from XML using XPath
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider an XML file with a list of movies as described for the previous problem.
    Write a program that can select and print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The title of all the movies released after a given year
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the last actor in the casting list for each movie in the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 75\. Serializing data to JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a program that can serialize a list of movies, as defined for the previous
    problems, to a JSON file. Each movie has a numerical identifier, title, release
    year, length in minutes, a list of directors, a list of writers, and a list of
    casting roles with actor name and character name. The following is an example
    of the expected JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 76\. Deserializing data from JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider a JSON file with a list of movies as shown in the previous problem.
    Write a program that can deserialize its content.
  prefs: []
  type: TYPE_NORMAL
- en: 77\. Printing a list of movies to a PDF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a program that can print to a PDF file a list of movies in a tabular
    form, with the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: There must be a heading to the list with the content *List of movies*. This
    must appear only on the first page of the document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each movie, it should display the title, the release year, and the length.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The title, followed by the release year in parentheses, must be left-aligned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The length, in hours and minutes (for example, 2:12), must be right-aligned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There must be a line above and below the movie listing on each page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of such a PDF output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6def28ce-9395-44d5-b5b3-c7a46fe3ad37.png)'
  prefs: []
  type: TYPE_IMG
- en: 78\. Creating a PDF from a collection of images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that can create a PDF document that contains images from a user-specified
    directory. The images must be displayed one after another. If an image does not
    fit on the remainder of a page, it must be placed on the next page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of such a PDF file, created from several images
    of Albert Einstein (these pictures are featured along with the source code accompanying
    the book):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f6d3dea-1a46-46b2-b101-17bf5e55aa1c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 73\. Serializing and deserializing data to/from XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ standard library does not have any support for XML, but there are multiple
    open source, cross-platform libraries that you can use. Some libraries are lightweight,
    supporting a set of basic XML features, while others are more complex and rich
    in functionality. It is up to you to decide which is most suitable for a particular
    project.
  prefs: []
  type: TYPE_NORMAL
- en: The list of libraries you may want to consider should include *Xerces-C++*,
    *libxml++*, *tinyxml* or *tinyxml2*, *pugixml*, *gSOAP*, and *RapidXml*. For solving
    this particular task I will choose *pugixml*. This is a cross-platform, lightweight
    library, with a fast, although non-validating, XML parser. It has a DOM-like interface
    with rich traversal/modification capabilities, with support for Unicode and XPath
    1.0\. On the limitations of the library, it should be mentioned that it lacks
    support for schema validation. The pugixml library is available at [https://pugixml.org/](https://pugixml.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To represent the movies, as described in the problem, we shall use the following
    structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To create an XML document you must use the `pugi::xml_document` class. After
    constructing the DOM tree you can save it to a file by calling `save_file()`.
    Nodes can be added by calling `append_child()`, and attributes with `append_attribute()`.
    The following method serializes a list of movies in the requested format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For the opposite operation, you can load the content of the XML file into a `pugi::xml_document`
    by calling its `load_file()` method. You can access nodes by calling methods such
    as `child()` and `next_sibling()`, and attributes by calling `attribute()`. The
    `deserialize()` method, shown as follows, reads the DOM tree and constructs a
    list of movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of how these functions can be used is shown in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 74\. Selecting data from XML using XPath
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Navigation through the elements and attributes of an XML file can be done with
    *XPath*. XPath uses XPath expressions for that purpose and there is a long list
    of built-in functions for that. *pugixml* supports XPath expressions and you can
    use the `select_nodes()` method from the `xml_document` class for that purpose.
    Note that, if an error occurs during the XPath selection, an `xpath_exception`
    is thrown. The following XPath expressions can be used for selecting the nodes
    according to the problem requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For all movies released after a given year (in this example that year is 1995):
    `/movies/movie[@year>1995]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the last casting role of each movie: `/movies/movie/cast/role[last()]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following program loads an XML document from a string buffer and then performs
    node selection using the XPath expressions listed earlier. The XML document is
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The selection of the requested data can be done in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 75\. Serializing data to JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with XML, no standard support for JSON exists. However, there are a large
    number of cross-platform libraries for this purpose. At the time of writing, the
    *nativejson-benchmark* project, available at [https://github.com/miloyip/nativejson-benchmark](https://github.com/miloyip/nativejson-benchmark), lists
    more than 40 libraries. This project is a benchmark that evaluates the conformance
    and performance (speed, memory, and code size) of open source C/C++ libraries
    with JSON parsing/generation capabilities. This makes it perhaps a bit hard to
    choose the right library, although top contenders may include `RapidJSON`, `NLohmann`,
    `taocpp/json`, `Configuru`, `json_spirit`, `jsoncpp`. For solving this task we
    will use here the `nlohmann/json` library. It is a cross-platform, header only
    library for C++11, with an intuitive syntax and good documentation. This library
    is available at [https://github.com/nlohmann/json](https://github.com/nlohmann/json).
  prefs: []
  type: TYPE_NORMAL
- en: We will use the same data structures to represent movies that we used for the
    problem *Serializing and deserializing data to/from XML*. The `nlohmann` library
    uses `nlohmann::json` as its main data type for representing JSON objects. Although
    you can create JSON values with a more explicit syntax, there are also implicit
    conversions to and from scalar types and standard containers. In addition, you
    can also enable this implicit conversion to and from your custom types by providing
    a `to_json()` and `from_json()` method in the namespace of the type to be converted.
    There are some requirements for these functions that you can read about in the
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, this is the chosen approach. Since the `movie` and `casting_role` types
    were defined in the global namespace, the `to_json()` overloads that serialize
    these types are also defined in the global namespace. On the other hand, the type
    `movie_list` is actually a type alias for `std::vector<movie>` and can be serialized
    and deserialized directly because, as mentioned earlier, the library supports
    implicit conversion to and from standard containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `serialize()` can be used as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 76\. Deserializing data from JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For solving this task we will use the `nlohmann/json` library again. Instead
    of writing `from_json()` functions, as was mentioned in the solution to the previous
    problem, we will take a more explicit approach. The content of a JSON file can
    be loaded into an `nlohmann::json` object using the overloaded `operator>>`. To
    access the object values, you should use the `at()` method rather than `operator[]`,
    because the former throws an exception if the key does not exist (an exception
    that you can handle), while the latter exhibits undefined behavior. To retrieve
    an object value as a particular `T` object, use the `get<T>()` method. However,
    this requires the type `T` to be default constructible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `deserialize()` function shown here returns an `std::vector<movie>` constructed
    from the content of a specified JSON file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This deserialization function can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 77\. Printing a list of movies to a PDF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are various C++ libraries for working with PDF files. *HaHu*, *PoDoFo*,
    *JagPDF*, and *PDF-Writer* (also known as *Hummus*) are some of the open source
    and cross-platform libraries that you could use for this purpose. In this book,
    I will use *PDF-Writer*, available at [https://github.com/galkahana/PDF-Writer](https://github.com/galkahana/PDF-Writer).
    This is a free, fast, and extensible library with a basic feature set that includes
    support for text, images, and shapes with both PDF operators and higher-level
    functions (which I will use for the solution to this problem).
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `print_pdf()`, shown as follows, implements the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new PDF document with `PDFWriter::StartPDF()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print at most 25 movies on each page. Each page is represented by a `PDFPage()`
    object and has a `PageContentContext` object, which is created with `PDFPage::StartPageContentContext()` and
    used to draw items on the page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the first page, put a heading with the content *List of movies*. Text is
    written on the page using `PageContentContext::WriteText()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Movie information is written using different fonts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lines are drawn on the top and bottom of the movie list on each page using `PageContentContext::DrawPath()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDFWriter::EndPageContentContext()` and `PDFWriter::WritePageAndRelease()`
    must be called after finishing writing content to a page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDFWriter::EndPDF()` must be called when finishing writing the PDF document:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For information about the types and methods used in the following code, as well
    as more information about creating PDF documents and working with text, shapes,
    and images, see the project documentation available at [https://github.com/galkahana/PDF-Writer/wiki](https://github.com/galkahana/PDF-Writer/wiki).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `print_pdf()` function can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 78\. Creating a PDF from a collection of images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To solve this problem we will use the same *PDF-Writer* library we used for
    the previous problem. I recommend that you look at and implement the previous
    problem first, if you have not done that already, before continuing with this
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `get_images()` function returns a vector of strings that represent
    the path of all JPG images from a specified directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `print_pdf()` function creates a PDF document with all the JPG images from
    a specified directory. It implements the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new PDF document with `PDFWriter::StartPDF()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a page and its content and put as many images as can fit on the page,
    arranged vertically one after the other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a new image does not fit in the current page, close the page with `PDFWriter::EndPageContentContext()`
    and `PDFWriter::SavePageAndRelease()` and start a new page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write images on the page content using `PageContentContext::DrawImage()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End the document by calling `PDFWriter::EndPDF()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `print_pdf()` can be used as in the following example, where `sample.pdf`
    is the name of the output, and `res` is the name of the folder that contains the
    images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
