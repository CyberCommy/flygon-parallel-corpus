- en: Managing Collections and Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The classes that we will be discussing in this chapter allow us to create, initialize,
    and modify objects of Java collections and arrays. They also allow the creation
    of unmodifiable and immutable collections. Some of these classes belong to Java
    standard libraries, others to popular Apache Commons libraries. Knowledge of these
    classes and familiarity with their methods are essential for any Java programmer.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following areas of functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The list of the overviewed classes includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.util.Collections`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.apache.commons.collections4.CollectionUtils`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.Arrays`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.apache.commons.lang3.ArrayUtils`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will review how collection objects can be created and initialized,
    what immutable collections are, and how to perform basic operations over collections—copy,
    sort, and shuffle, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen a few examples of collection constructors without parameters.
    Now, we are going to see other ways to create and initialize collection objects.
  prefs: []
  type: TYPE_NORMAL
- en: Collection constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each of the collection classes has a constructor that accepts a collection
    of elements of the same type. For example, here is how an object of class `ArrayList` can
    be created using the `ArrayList(Collection collection)` constructor and how an
    object of class `HashSet` can be created using the `HashSet<Collection collection)` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list1 = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list1.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: list1.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list2 = new ArrayList<>(list1);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list2);      //prints: [s1, s1]'
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> set = new HashSet<>(list1);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set);        //prints: [s1]'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list3 = new ArrayList<>(set);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list3);      //prints: [s1]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We will show more examples of using such constructors in the *Using other objects
    and streams* subsection later.
  prefs: []
  type: TYPE_NORMAL
- en: Instance initializer (double brace)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to use a double brace initializer for the collection initialization.
    It fits especially well when the collection is the value of an instance field,
    so it is initialized automatically during object creation. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class ManageCollections {
  prefs: []
  type: TYPE_NORMAL
- en: private List<String> list = new ArrayList<>() {
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: add(null);
  prefs: []
  type: TYPE_NORMAL
- en: add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: add("s3");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: public List<String> getThatList(){
  prefs: []
  type: TYPE_NORMAL
- en: return this.list;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String... args){
  prefs: []
  type: TYPE_NORMAL
- en: ManageCollections mc = new ManageCollections();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(mc.getThatList());    //prints: [null, s2, s3]'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have added a getter and use it when the `main()` method runs. Unfortunately,
    the double brace initializer does not save any time typing compared with the traditional
    collection initialization in a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class ManageCollections {
  prefs: []
  type: TYPE_NORMAL
- en: private List<String> list = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: public ManageCollections(){
  prefs: []
  type: TYPE_NORMAL
- en: list.add(null);
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s3");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public List<String> getThatList(){
  prefs: []
  type: TYPE_NORMAL
- en: return this.list;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String... args){
  prefs: []
  type: TYPE_NORMAL
- en: ManageCollections mc = new ManageCollections();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(mc.getThatList());    //prints: [null, s2, s3]'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The only difference is that you need to type the `list` variable for each call
    of `add()` method. Besides, the double brace initializer has an overhead of creating
    an anonymous class with just an instance initializer and references to the enclosing
    class. It also has potentially more problems, so should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is that there is a much shorter and more convenient way to initialize
    a collection as the field value or as a local variable value:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: private List<String> list = Arrays.asList(null, "s2", "s3");
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The static method `asList()` of the `java.util.Arrays` class is very popular
    (we will talk about the `Arrays` class in more detail shortly). The only potential
    drawback is that such a list does not allow the addition of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = Arrays.asList(null, "s2", "s3");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s4");    // throws UnsupportedOperationException
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'But, we can always create a new collection by passing the initialized list
    into a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = new ArrayList(Arrays.asList(null, "s2", "s3"));
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s4");   //works just fine
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> set = new HashSet<>(Arrays.asList(null, "s2", "s3"));
  prefs: []
  type: TYPE_NORMAL
- en: set.add("s4");   //works just fine as well
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the constructors of collection classes accept any object that implements
    the `Collection` interface. It allows lists to be created from sets, and vice
    versa. But, the `Map` interface does not extend `Collection`, so `Map` implementations
    only allow a map to be created from another map:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, String> map = new HashMap<>();
  prefs: []
  type: TYPE_NORMAL
- en: map.put(1, null);
  prefs: []
  type: TYPE_NORMAL
- en: map.put(2, "s2");
  prefs: []
  type: TYPE_NORMAL
- en: map.put(3, "s3");
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, String> anotherMap = new HashMap<>(map);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The types of keys and values of the new map have to be either the same as in
    the provided map or have to be parents of the types of the provided map:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class A{}
  prefs: []
  type: TYPE_NORMAL
- en: class B extends A{}
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, B> mb = new HashMap<>();
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, A> ma = new HashMap<>(mb);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this is an acceptable assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, String> map1 = new HashMap<>();
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, Object> map2 = new HashMap<>(map1);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'That is because the `HashMap` constructor limits the types just to the children
    of the map elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: HashMap(Map<? extends K,? extends V> map)
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a similar problem with the following code too:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class A {}
  prefs: []
  type: TYPE_NORMAL
- en: class B extends A {}
  prefs: []
  type: TYPE_NORMAL
- en: List<A> l1 = Arrays.asList(new B());
  prefs: []
  type: TYPE_NORMAL
- en: List<B> l2 = Arrays.asList(new B());
  prefs: []
  type: TYPE_NORMAL
- en: //List<B> l3 = Arrays.asList(new A()); //compiler error
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code makes sense, doesn''t it? `class B` has (inherits) all the
    non-private methods and fields of `class A`, but can have other non-private methods
    and fields that are not available in `class A`. Even if both classes are empty
    today, as in our example, tomorrow we may decide to add some methods to `class
    B`. So, the compiler protects us from such a case and does not allow a collection
    with elements of a parent type to be assigned to the collection of children. And
    that is the meaning of the generics in the following constructor definitions,
    as you see them in the Java Standard Library API''s `java.util` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ArrayList(Collection<? extends E> collection)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`HashSet(Collection<? extends E> collection)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`HashMap(Map<? extends K,? extends V> map)`'
  prefs: []
  type: TYPE_NORMAL
- en: We hope that by now, you have become more comfortable with such generics. If
    in doubt, read the sections about generics in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Static initialization block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a similar solution for static field initialization. The static block
    can include the code necessary to generate values that have to be used for static
    field initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class SomeClass{
  prefs: []
  type: TYPE_NORMAL
- en: public String getThatString(){
  prefs: []
  type: TYPE_NORMAL
- en: return "that string";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public class ManageCollections {
  prefs: []
  type: TYPE_NORMAL
- en: private static Set<String> set = new HashSet<>();
  prefs: []
  type: TYPE_NORMAL
- en: static {
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass someClass = new SomeClass();
  prefs: []
  type: TYPE_NORMAL
- en: set.add(someClass.getThatString());
  prefs: []
  type: TYPE_NORMAL
- en: set.add("another string");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String... args){
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set); //prints: [that string, another string]'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `set` is a static field, it cannot be initialized in a constructor because
    a constructor is called only when an instance is created, while a static field
    can be accessed without creating an instance. We also could rewrite the preceding
    code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: private static Set<String> set =
  prefs: []
  type: TYPE_NORMAL
- en: new HashSet<>(Arrays.asList(new SomeClass().getThatString(),
  prefs: []
  type: TYPE_NORMAL
- en: '"another string"));'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: But, you can argue that it looks somewhat awkward and difficult to read. So,
    the static initialization block might be a better choice if it allows more readable
    code to be written.
  prefs: []
  type: TYPE_NORMAL
- en: Factory methods of()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since Java 9, yet another option for creating and initializing a collection
    is available in each of the interfaces, including `Map`—the `of()` factory methods.
    They are called *factory* because they produce objects. There are eleven such
    methods, which accept from 0 to 10 parameters, each parameter being an element
    that has to be added to the collection, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> iList0 = List.of();
  prefs: []
  type: TYPE_NORMAL
- en: List<String> iList1 = List.of("s1");
  prefs: []
  type: TYPE_NORMAL
- en: List<String> iList2 = List.of("s1", "s2");
  prefs: []
  type: TYPE_NORMAL
- en: List<String> iList3 = List.of("s1", "s2", "s3");
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> iSet1 = Set.of("s1", "s2", "s3", "s4");
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> iSet2 = Set.of("s1", "s2", "s3", "s4", "s5");
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> iSet3 = Set.of("s1", "s2", "s3", "s4", "s5", "s6",
  prefs: []
  type: TYPE_NORMAL
- en: '"s7", "s8", "s9", "s10");'
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, String> iMap = Map.of(1, "s1", 2, "s2", 3, "s3", 4, "s4");
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note how the map is constructed: from a pair of values up to 10 such
    pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: We have decided to start the identificators for the above variables with "`i`"
    to indicate that these collections are immutable. We will talk about this in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another feature of these factory methods is that they do not allow `null` as
    an element value. If added, `null` element will cause an error (`NullPointerException`)
    at runtime. The reason `null` is not allowed is because it had to be banned from
    most collections a long time ago. This issue is especially important for `Set` because
    a set provides keys to `Map` while the `null` key does not make much sense, does
    it? Look at the following code, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, String> map = new HashMap<>();
  prefs: []
  type: TYPE_NORMAL
- en: map.put(null, "s1");
  prefs: []
  type: TYPE_NORMAL
- en: map.put(2, "s2");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map.get(null));     //prints: s1'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: You may also recall that the `put()` method of the `Map` interface returns `null`
    if there was no value associated with the key provided, or if the old value was
    `null`. This ambiguity is annoying, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: That's why the authors of Java 9 decided to start squeezing out `null` from
    the collections. There will probably always be special implementations of collections
    that allow `null`, but the most often used collections will eventually not allow
    `null`, and the factory methods we are describing now are the first step in that
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another long-awaited feature added along with these factory methods is randomization
    of the order of the set elements. It means that the order is different every time
    the same set creation is executed. For example, if we run these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> iSet3 = Set.of("s1", "s2", "s3", "s4", "s5", "s6",
  prefs: []
  type: TYPE_NORMAL
- en: '"s7", "s8", "s9", "s10");'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(iSet3);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output may be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fad692b-4ec9-4098-af18-134dcffba2ce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But, if we run the same two lines again, the output will be different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2824cd6d-1f51-407f-8ae6-7739de2b3619.png)'
  prefs: []
  type: TYPE_IMG
- en: And every execution of set creation results in a different order of its elements.
    This is the randomization in action. It helps to uncover early the incorrect programmer's
    reliance on a certain element's order in places where order is not guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: Using other objects and streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the *Constructor* subsection, we demonstrated how the `List<T> Arrays.asList(T...a)` method can
    be used to generate a list of values, which can then be passed in a constructor
    of any class that implements the `Collection` interface (or any interface that
    extends the `Collection`, such as `List` and `Set`, for example). As a reminder,
    we would like to mention that the `(T...a)` notation is called varargs and means
    that the parameter can be passed in any of the following two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: As an unlimited comma-separated sequence of values of type T
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an array of type T of any size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, both the following statements create equal lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> x1 = Arrays.asList(null, "s2", "s3");
  prefs: []
  type: TYPE_NORMAL
- en: String[] array = {null, "s2", "s3"};
  prefs: []
  type: TYPE_NORMAL
- en: List<String> x2 = Arrays.asList(array);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(x1.equals(x2));       //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to create a collection was added with Java 8, which introduced
    streams. Here is one possible example of a list and set objects generation (we
    will talk about streams more in [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml),
    *Streams and Pipelines*):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list2 = Stream.of(null, "s2", "s3")
  prefs: []
  type: TYPE_NORMAL
- en: .collect(Collectors.toList());
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list2);               //prints: [null, s2, s3]'
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> set2 = Stream.of(null, "s2", "s3")
  prefs: []
  type: TYPE_NORMAL
- en: .collect(Collectors.toSet());
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set2);               //prints: [null, s2, s3]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: If you read the documentation about the `Collectors.toList()` or `Collectors.toSet()`
    methods, you will find it says that "<q>there are no guarantees on the type, mutability,
    serializability, or thread-safety of the List returned; if more control over the
    returned List is required, use toCollection(Supplier).</q>" They refer to the
    `toCollection(Supplier<C> collectionFactory)` method of the `Collectors` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `Supplier<C>` notation describes a function that takes no parameters and
    produces a value of type `C`, hence the name.
  prefs: []
  type: TYPE_NORMAL
- en: 'In many cases (if not most), we do not care which class (implementation of
    `List` or `Set`) is returned. That is exactly the beauty of coding to an interface.
    But if we do, here is an example of how to use the `toCollection()` method which,
    according to the previous recommendation, is a better option than `toList()` or
    `toSet()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list3 = Stream.of(null, "s2", "s3")
  prefs: []
  type: TYPE_NORMAL
- en: .collect(Collectors.toCollection(ArrayList::new));
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list3);               //prints: [null, s2, s3]'
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> set3 = Stream.of(null, "s2", "s3")
  prefs: []
  type: TYPE_NORMAL
- en: .collect(Collectors.toCollection(HashSet::new));
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set3);               //prints: [null, s2, s3]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: If it looks strange to you that we create a collection, then stream it and reproduce
    the same collection again, but bear in mind that in real-life programming, you
    might be getting the `Stream` object only, while we create a stream in order for
    the example to work and also to show you which values to expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of `Map`, the following code is also mentioned in the documentation
    as having "<q>no guarantees on the type</q>":'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, String> m = new HashMap<>();
  prefs: []
  type: TYPE_NORMAL
- en: m.put(1, null);
  prefs: []
  type: TYPE_NORMAL
- en: m.put(2, "s2");
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, String> map2 = m.entrySet().stream()
  prefs: []
  type: TYPE_NORMAL
- en: '.map(e -> e.getValue() == null ? Map.entry(e.getKey(), "") : e)'
  prefs: []
  type: TYPE_NORMAL
- en: .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map2);    //prints: {1=, 2=s2}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note how we are handling `null` by replacing it with an empty `String`
    literal, "", so as to avoid the dreaded `NullPointerException`. And here is the
    code that, similar to the `toCollection()` method previously, produces a map with
    the implementation of our choice, the `HashMap` class in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, String> map3 = m.entrySet().stream()
  prefs: []
  type: TYPE_NORMAL
- en: '.map(e -> e.getValue() == null ? Map.entry(e.getKey(), "") : e)'
  prefs: []
  type: TYPE_NORMAL
- en: .collect(Collectors.toMap(e -> e.getKey(), e -> e.getValue(),
  prefs: []
  type: TYPE_NORMAL
- en: (k,v) -> v, HashMap::new));
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map3);    //prints: {1=, 2=s2}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the examples provided look too complex to you, you are correct; they are
    complex even for experienced programmers. And there are two reasons for that:'
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming is a different way of writing code than the one used
    in Java for the first twenty years of its existence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It was introduced in Java only recently and there are not many utility methods
    built around it to make the code look simpler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The good news is that after some time, you will get used to it, and streams
    and functional programming will start looking simple to you. There is even a good
    chance you will prefer it over the traditional object-oriented code because using
    functions and streams makes the code more compact and yet more powerful and cleaner,
    especially when a lot of data (big data) has to be processed efficiently, which
    seems to be the current trend, stretching far into the future.
  prefs: []
  type: TYPE_NORMAL
- en: We will talk more about this in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambda
    Expressions and Functional Programming;* in [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml),
    *Streams and Pipelines*; and in [Chapter 19](aa01584a-ae53-454d-b59b-395d484b4c94.xhtml),
    *Reactive Systems*.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In everyday language, the adjectives *immutable* and *unmodifiable* are used
    interchangeably. But in the case of Java collections, an unmodifiable collection
    can be changed. Well, it also depends on what kind of meaning you give to the
    word *change*. Here is what we mean by this.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable versus unmodifiable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are eight static methods in the `Collections` class that make a collection
    *unmodifiable*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Set<T>  unmodifiableSet(Set<? extends T> set)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<T>  unmodifiableList(List<? extends T> list)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map<K,V>  unmodifiableMap(Map<? extends K, ? extends V> map)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<T> unmodifiableCollection (Collection<? extends T> collection)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SortedSet<T>  unmodifiableSortedSet(SortedSet<T> sortdedSet)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SortedMap<K,V>  unmodifiableSortedMap(SortedMap<K,? extends V> sortedMap)`,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NavigableSet<T>  unmodifiableNavigableSet(NavigableSet<T> navigableSet)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NavigableMap<K,V> unmodifiableNavigableMap(NavigableMap<K,? extends V> navigableMap)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of code that creates an unmodifiable list:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = Arrays.asList("s1", "s1");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list);          //prints: [s1, s1]'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> unmodfifiableList = Collections.unmodifiableList(list);
  prefs: []
  type: TYPE_NORMAL
- en: //unmodfifiableList.set(0, "s1"); //UnsupportedOperationException
  prefs: []
  type: TYPE_NORMAL
- en: //unmodfifiableList.add("s2");    //UnsupportedOperationException
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you have probably expected, we can neither change the value of an element
    nor add a new element to an unmodifiable list. Nevertheless, we can change the
    underlying list because we still hold the reference to it. And this change will
    be picked up by the unmodifiable list created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(unmodfifiableList);      //prints: [s1, s1]'
  prefs: []
  type: TYPE_NORMAL
- en: list.set(0, "s0");
  prefs: []
  type: TYPE_NORMAL
- en: //list.add("s2");       //UnsupportedOperationException
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(unmodfifiableList);      //prints: [s0, s1]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, by changing the original list, we have managed to change the
    value of the element in the unmodifiable list created earlier. And that is the
    weakness of this way of creating unmodifiable collections, because they are basically
    just wrappers around regular ones.
  prefs: []
  type: TYPE_NORMAL
- en: The `of()`  collection of factory methods do not have this weakness because
    they do not have two-step collection creation as in the case of unmodifiable collections.
    That is why there is no way to change the collection created by the `of` factory
    method. It is not possible to change either the collection composition nor any
    of its elements. The collections created this way are called "immutable." That
    is the difference between *unmodifiable* and *immutable* in the world of Java
    collections.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable without methods of()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be fair, there are ways to create an immutable collection even without using
    the `of()` factory methods. Here is one way to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> iList =
  prefs: []
  type: TYPE_NORMAL
- en: Collections.unmodifiableList(new ArrayList<>() {{
  prefs: []
  type: TYPE_NORMAL
- en: add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: '}});'
  prefs: []
  type: TYPE_NORMAL
- en: //iList.set(0, "s0");       //UnsupportedOperationException
  prefs: []
  type: TYPE_NORMAL
- en: //iList.add("s2");          //UnsupportedOperationException
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(iList);  //prints: [s1, s1]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The trick is not to have a reference to the original collection (the source
    of values) used to create the unmodifiable collection, so it cannot be used to
    change the underlying source.
  prefs: []
  type: TYPE_NORMAL
- en: 'And here is another way to create an immutable collection without using the `of()` factory
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String[] source = {"s1", "s2"};
  prefs: []
  type: TYPE_NORMAL
- en: List<String> iList2 =
  prefs: []
  type: TYPE_NORMAL
- en: Arrays.stream(source).collect(Collectors.toList());
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(iList2);      //prints: [s1, s2]'
  prefs: []
  type: TYPE_NORMAL
- en: source[0]="s0";
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(iList2);      //prints: [s1, s2]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: It looks as if we have here the `source` reference to the original values. But,
    the stream does not maintain the reference between the value and its source. It
    copies each value before processing them, thus breaking the value's connection
    with its source. That is why our attempt to change the element of `iList2` by
    changing an element of the `source` array did not succeed. We will talk more about
    streams in [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml), *Streams
    and Pipelines*.
  prefs: []
  type: TYPE_NORMAL
- en: The need for immutable collections arises from an effort to protect the collection
    object from modification when it is passed as a parameter into a method. As we
    have mentioned already, such modification would be a side effect that may introduce
    unexpected and difficult-to-trace defects.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the `of()` factory methods without parameters create empty
    immutable collections. They also might be needed when you need to call a method
    that requires a collection as a parameter, but you do not have data for it and
    also do not want to give the method a chance to modify the passed-in collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also three constants in the `Collections` class that provide immutable
    empty collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list1 = Collections.EMPTY_LIST;
  prefs: []
  type: TYPE_NORMAL
- en: //list1.add("s1");       //UnsupportedOperationException
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> set1 = Collections.EMPTY_SET;
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, String> map1 = Collections.EMPTY_MAP;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, there are seven methods in the `Collections` class that create
    immutable empty collections too:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list2 = Collections.emptyList();
  prefs: []
  type: TYPE_NORMAL
- en: //list2.add("s1");       //UnsupportedOperationException
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> set2 = Collections.emptySet();
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, String> map2 = Collections.emptyMap();
  prefs: []
  type: TYPE_NORMAL
- en: SortedSet<String> set3 = Collections.emptySortedSet();
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, String> map3 = Collections.emptySortedMap();
  prefs: []
  type: TYPE_NORMAL
- en: NavigableSet<String> set4 = Collections.emptyNavigableSet();
  prefs: []
  type: TYPE_NORMAL
- en: NavigableMap<Integer, String> map4 = Collections.emptyNavigableMap();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And the following methods of the `Collections` class create immutable collections
    with one element only:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Set<T> singleton(T object)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<T> singletonList(T object)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map<K,V> singletonMap(K key, V value)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see how it works in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> singletonS1 = Collections.singletonList("s1");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(singletonS1);
  prefs: []
  type: TYPE_NORMAL
- en: //singletonS1.add("s1");        //UnsupportedOperationException
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: All of these can be done using the `of()` factory methods. We have described
    it just for you to have a complete picture of the options available for immutable
    collection creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the `List<T> nCopies(int n, T object)` methodof the `Collections` class creates
    an immutable list of `n` copies of the same object in a more compact manner than
    the `of()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> nList = Collections.nCopies(3, "s1");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(nList);
  prefs: []
  type: TYPE_NORMAL
- en: //nList.add("s1");        //UnsupportedOperationException
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar code that uses the `of()` method is more verbose:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> nList = List.of("s1", "s1", "s1");
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: If that does not look too bad for you, imagine that you need to create a list
    of 100 of the same objects.
  prefs: []
  type: TYPE_NORMAL
- en: Methods add() and put() confusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one aspect of immutable collection use that is a source of occasional
    confusion. You have seen from our examples that the immutable collections, like
    any Java collection, have the `add()` or `put()` methods. The compiler does not
    generate an error, only JVM at runtime does so. So, code that uses immutable collections
    should be well tested to avoid this kind of error in production.
  prefs: []
  type: TYPE_NORMAL
- en: java.util.Collections class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All methods of the `java.util.Collections` class are static and stateless. The
    latter means that they do not maintain any state anywhere, and that their results
    do not depend on the history of calls but only on the values passed in as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: There are many methods in the `Collections` class and you have seen some of
    them already in the previous section. We encourage you to look up the online documentation
    of this class. Here, we have grouped some of them for your convenience, so you
    can have a better overview of the methods of the `Collections` class.
  prefs: []
  type: TYPE_NORMAL
- en: Copy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `void copy(List<T> dest, List<T> src)` method copies elements of the `src` list to
    the `dest` list and preserves the element order. This method is very useful in
    case you need to make one list a sublist of another list:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list1 = Arrays.asList("s1","s2");
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list2 = Arrays.asList("s3", "s4", "s5");
  prefs: []
  type: TYPE_NORMAL
- en: Collections.copy(list2, list1);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list2);    //prints: [s1, s2, "s5"]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'While doing this, the `copy()` method does not consume additional memory -
    it just copies the values over the already allocated memory. It makes this method
    helpful for cases where the traditional way of copying lists of equal sizes is
    not acceptable:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list1 = Arrays.asList("s1","s2");
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list2 = Arrays.asList("s3", "s4");
  prefs: []
  type: TYPE_NORMAL
- en: list2 = new ArrayList(list1);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list2);    //prints: [s1, s2]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This code abandons the values originally assigned to `list2` and allocates new
    memory for `list2` to hold a copy of `list1` values. The abandoned values sit
    in the memory until the garbage collector removes them and allows the reuse of
    the memory. Imagine these lists are of a substantial size, and you can appreciate
    that using `Collections.copy()`, which in this case removes a lot of overhead.
    It also helps to avoid the `OutOfMemory` exception.
  prefs: []
  type: TYPE_NORMAL
- en: Sort and equals()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The two static sorting methods of the `Collections` class are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void sort(List<T> list)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void sort(List<T> list, Comparator<T> comparator)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first `sort(List<T>)` method accepts only lists with elements that implement
    the `Comparable` interface, which requires implementation of the `compareTo(T)` method.
    The order established by the `compareTo(T)` method implemented by each element
    is called *natural ordering*.
  prefs: []
  type: TYPE_NORMAL
- en: The second `sort()` method does not require the list elements to implement any
    particular interface. It uses the passed-in object of the class `Comparator` to
    establish the required order using the `Comparator.compare(T o1, T o2)` method. If
    the elements of the list implement `Comparable`, then their method `compareTo(T)` is
    ignored and the order is established by the method `Comparator.compare(T o1, T
    o2)` only.
  prefs: []
  type: TYPE_NORMAL
- en: The order defined by the `Comparator` object (the `compare(T o1, T o2)` method)
    overrides the natural order defined by the `Comparable` interface (the method `compareTo(T)`).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is how the class `String` implements the interface `Comparable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> no = Arrays.asList("a","b", "Z", "10", "20", "1", "2");
  prefs: []
  type: TYPE_NORMAL
- en: Collections.sort(no);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(no);     //prints: [1, 10, 2, 20, Z, a, b]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: For many people, the fact that `10` is placed in front of `2` and a capital
    `Z` is placed in front of the lowercase `a` probably does not look *natural*,
    but this term is not based on human perception. It is based on how the objects
    are going to be sorted when no comparator is provided. In such cases, they are
    ordered based on the implemented method, `compareTo(T)`. This implemented method
    can be considered to be *built into* the elements. That is why such an ordering
    is called *natural*.
  prefs: []
  type: TYPE_NORMAL
- en: A natural ordering is one defined by the implementation of the interface `Comparable` (the
    method `compareTo(T)`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it looks somewhat unexpected for humans, the `String` implementation
    of the `compareTo(T)` method is very helpful in many ordering cases. For example,
    we can use it for the implementation of the `Comparable` interface in our class  `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class Person implements Comparable<Person>{
  prefs: []
  type: TYPE_NORMAL
- en: private String firstName = "", lastName = "";
  prefs: []
  type: TYPE_NORMAL
- en: public Person(String firstName, String lastName) {
  prefs: []
  type: TYPE_NORMAL
- en: this.firstName = firstName;
  prefs: []
  type: TYPE_NORMAL
- en: this.lastName = lastName;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public String getFirstName() { return firstName; }
  prefs: []
  type: TYPE_NORMAL
- en: public String getLastName() { return lastName; }
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public int compareTo(Person person){
  prefs: []
  type: TYPE_NORMAL
- en: int result = this.firstName.compareTo(person.firstName);
  prefs: []
  type: TYPE_NORMAL
- en: if(result == 0) {
  prefs: []
  type: TYPE_NORMAL
- en: return this.lastName.compareTo(person.lastName);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return result;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We compare first names first, and if they are equal, compare last names. This
    means that we would like `Person` objects to be ordered by first name, then by
    last name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `String` implementation of the `compareTo(T)` method returns the difference
    between the ordering positions of the first (or this) and the second objects.
    For example, the difference between the ordering positions of `a` and `c` is `2`,
    and here is the result of their comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("a".compareTo("c"));   //prints: -2'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("c".compareTo("a"));   //prints: 2'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes sense: `a` is placed before `c`, so its position is smaller when
    we count it from left to right.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice, though, that the `Integer` implementation of `compareTo(T)` does not
    return the difference in the ordering position. Instead, it returns `0` when objects
    are equal, `-1` when this object is smaller than the method parameter, and `1`
    otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Integer.valueOf(3)
  prefs: []
  type: TYPE_NORMAL
- en: '.compareTo(Integer.valueOf(3))); //prints: 0'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Integer.valueOf(3)
  prefs: []
  type: TYPE_NORMAL
- en: '.compareTo(Integer.valueOf(4))); //prints: -1'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Integer.valueOf(3)
  prefs: []
  type: TYPE_NORMAL
- en: '.compareTo(Integer.valueOf(5))); //prints: -1'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Integer.valueOf(5)
  prefs: []
  type: TYPE_NORMAL
- en: '.compareTo(Integer.valueOf(4))); //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Integer.valueOf(5)
  prefs: []
  type: TYPE_NORMAL
- en: '.compareTo(Integer.valueOf(3))); //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We get the same results using `Comparator` and its method `compare(T o1, T
    o2)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Comparator<String> compStr = Comparator.naturalOrder();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(compStr.compare("a", "c"));  //prints: -2'
  prefs: []
  type: TYPE_NORMAL
- en: Comparator<Integer> compInt = Comparator.naturalOrder();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(compInt.compare(3, 5));     //prints: -1'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'But, beware that the documentation of the methods `Comparable.compareTo(T)`
    and `Compartor.compare(T o1, T o2)` defines only the following return:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0` when the objects are equal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-1` when the first object is smaller than the second one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` when the first object is bigger than the second one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of `String`, `smaller`, and `bigger` are defined according to their
    ordering position—smaller is placed in front of bigger in the ordered list. As
    you can see, the API documentation does not guarantee that the difference in the
    ordering position is returned for all types of objects.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to make sure that the method `equals()` is aligned with the
    method `Comparable.compareTo(T)` so that for equal objects, the method `Comparable.compareTo(T)` returns
    0\. Otherwise, one may get unpredictable sorting results.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is why we add the following method `equals()` to our class `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public boolean equals(Object other) {
  prefs: []
  type: TYPE_NORMAL
- en: if (other == null) return false;
  prefs: []
  type: TYPE_NORMAL
- en: if (this == other) return true;
  prefs: []
  type: TYPE_NORMAL
- en: if (!(other instanceof Person)) return false;
  prefs: []
  type: TYPE_NORMAL
- en: final Person that = (Person) other;
  prefs: []
  type: TYPE_NORMAL
- en: return this.firstName.equals(that.getFirstName()) &&
  prefs: []
  type: TYPE_NORMAL
- en: this.lastName.equals(that.getLastName());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the method `equals()` is aligned with the method `compareTo(T)`, so that
    `compareTo(T)` returns 0 when used for equal `Person` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person joe1 = new Person("Joe", "Smith");
  prefs: []
  type: TYPE_NORMAL
- en: Person joe2 = new Person("Joe", "Smith");
  prefs: []
  type: TYPE_NORMAL
- en: Person bob = new Person("Bob", "Smith");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(joe1.equals(joe2));    //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(joe1.compareTo(joe2)); //prints: 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(joe1.equals(bob));     //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(joe1.compareTo(bob));  //prints: 8'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(joe2.compareTo(bob));  //prints: 8'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The value `8` is returned because that is the difference between the positions
    of `B` and `J` in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also added the following `toString()` method to our class `Person`
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public String toString(){
  prefs: []
  type: TYPE_NORMAL
- en: return this.firstName + " " + this.lastName;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'It will allow us to demonstrate ordering results better, and that is what we
    are going to do now. Here is the demo code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person p1 = new Person("Zoe", "Arnold");
  prefs: []
  type: TYPE_NORMAL
- en: Person p2 = new Person("Alex", "Green");
  prefs: []
  type: TYPE_NORMAL
- en: Person p3 = new Person("Maria", "Brown");
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> list7 = Arrays.asList(p1, p2, p3);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list7);  //[Zoe Arnold, Alex Green, Maria Brown]
  prefs: []
  type: TYPE_NORMAL
- en: Collections.sort(list7);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list7);  //[Alex Green, Maria Brown, Zoe Arnold]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the order of the elements after sorting (the last line of the
    previous example) matches the one defined in the `compareTo(T)` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a comparator that sorts objects of class `Person` differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class OrderByLastThenFirstName implements Comparator<Person> {
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public int compare(Person p1, Person p2){
  prefs: []
  type: TYPE_NORMAL
- en: return (p1.getLastName() + p1.getFirstName())
  prefs: []
  type: TYPE_NORMAL
- en: .compareTo(p2.getLastName() + p2.getFirstName());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the preceding comparator establishes an order based on the
    natural order of the last names first, and then the natural order of the first
    names. If we use this comparator with the same list and objects, we will get the
    following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Collections.sort(list7, new OrderByLastThenFirstName());
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list7);  //[Zoe Arnold, Maria Brown, Alex Green]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As was expected, the `compareTo(T)` method was ignored and the passed-in `Comparator` object's
    order was enforced.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse and rotate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three static reverse-related, and one rotate-related, methods in
    the class `Collections`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void reverse(List<?> list)`: Reverses the current order of elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void rotate(List<?> list, int distance) `: Rotates the order of the elements
    by moving each of them to the right for the specified number of positions (distance)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Comparator<T> reverseOrder()`: Returns a comparator that creates an order
    that is the reverse of the natural ordering; applies only to elements that implement
    the `Comparable` interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Comparator<T> reverseOrder(Comparator<T> comparator)`: Returns a comparator
    that reverses the order defined by the passed-in comparator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And here is the code that demonstrates the listed methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person p1 = new Person("Zoe", "Arnold");
  prefs: []
  type: TYPE_NORMAL
- en: Person p2 = new Person("Alex", "Green");
  prefs: []
  type: TYPE_NORMAL
- en: Person p3 = new Person("Maria", "Brown");
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> list7 = Arrays.asList(p1,p2,p3);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list7);  //[Zoe Arnold, Alex Green, Maria Brown]
  prefs: []
  type: TYPE_NORMAL
- en: Collections.reverse(list7);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list7);  //[Maria Brown, Alex Green, Zoe Arnold]
  prefs: []
  type: TYPE_NORMAL
- en: Collections.rotate(list7, 1);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list7);  //[Zoe Arnold, Maria Brown, Alex Green]
  prefs: []
  type: TYPE_NORMAL
- en: Collections.sort(list7, Collections.reverseOrder());
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list7);  //[Zoe Arnold, Maria Brown, Alex Green]
  prefs: []
  type: TYPE_NORMAL
- en: Collections.sort(list7, new OrderByLastThenFirstName());
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list7);  //[Zoe Arnold, Maria Brown, Alex Green]
  prefs: []
  type: TYPE_NORMAL
- en: Collections.sort(list7,
  prefs: []
  type: TYPE_NORMAL
- en: Collections.reverseOrder(new OrderByLastThenFirstName()));
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list7);  //[Alex Green, Maria Brown, Zoe Arnold]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Search and equals()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are five static search-related methods in the class `Collections`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int binarySearch(List<Comparable<T>> list, T key)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int binarySearch(List<T> list, T key, Comparator<T> comparator)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int indexOfSubList(List<?> source, List<?> target) `'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int lastIndexOfSubList(List<?> source, List<?> target)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int frequency(Collection<?> collection, Object object)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `binarySearch()` methods search for the `key` value in the provided list.
    The important thing to notice is that the provided list must be *sorted* in *ascending*
    order because of the nature of the binary search. The algorithm compares the key
    to the middle element of the list; if they are unequal, the half in which the
    key cannot belong is ignored and the algorithm compares the key to the middle
    element of the other half of the list. The search continues until the element
    equal to the key is found or only one element is left to search and it is not
    equal to the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `indexOfSubList()` and `lastIndexOfSubList()` methods return the position
    of the provided sublist in the provided list:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list1 = List.of("s3","s5","s4","s1");
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list2 = List.of("s4","s5");
  prefs: []
  type: TYPE_NORMAL
- en: int index = Collections.indexOfSubList(list1, list2);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(index);  //prints: -1'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list3 = List.of("s5","s4");
  prefs: []
  type: TYPE_NORMAL
- en: index = Collections.indexOfSubList(list1, list3);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(index);   //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Please notice that the sublist should be exactly in the same order. Otherwise,
    it will not be found.
  prefs: []
  type: TYPE_NORMAL
- en: 'And the last method, `frequency(Collection, Object)`, returns the number of
    times the provided object appears in the provided collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list4 = List.of("s3","s4","s4","s1");
  prefs: []
  type: TYPE_NORMAL
- en: int count = Collections.frequency(list4, "s4");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(count);         //prints: 2'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are going to use these methods (or any other methods that search collections
    for that matter) and if the collections include objects of custom classes, you
    have to have the method `equals()` implemented. A typical search algorithm uses
    the method `equals()` for the identification of the object. If you do not implement
    the method `equals()` in your custom class, the method `equals()` from the base
    class `Object` is going to be used, which compares only the object references,
    not their states (values of their fields). Here is a demonstration of this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class A{}
  prefs: []
  type: TYPE_NORMAL
- en: class B extends A{}
  prefs: []
  type: TYPE_NORMAL
- en: List<A> list5 = List.of(new A(), new B());
  prefs: []
  type: TYPE_NORMAL
- en: int c = Collections.frequency(list5, new A());
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(c);         //prints: 0'
  prefs: []
  type: TYPE_NORMAL
- en: A a = new A();
  prefs: []
  type: TYPE_NORMAL
- en: List<A> list6 = List.of(a, new B());
  prefs: []
  type: TYPE_NORMAL
- en: c = Collections.frequency(list6, a);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(c);         //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the object of class `A` is found only if it is literally the
    same object. But if we implement the method `equals()`, then the object of class
    A is found according to the criteria we have put in the method `equals()` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class A{
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public boolean equals(Object o){
  prefs: []
  type: TYPE_NORMAL
- en: if (o == null) return false;
  prefs: []
  type: TYPE_NORMAL
- en: return (o instanceof A);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class B extends A{}
  prefs: []
  type: TYPE_NORMAL
- en: List<A> list5 = List.of(new A(), new B());
  prefs: []
  type: TYPE_NORMAL
- en: int c = Collections.frequency(list5, new A());
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(c);         //prints: 2'
  prefs: []
  type: TYPE_NORMAL
- en: A a = new A();
  prefs: []
  type: TYPE_NORMAL
- en: List<A> list6 = List.of(a, new B());
  prefs: []
  type: TYPE_NORMAL
- en: c = Collections.frequency(list6, a);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(c);         //prints: 2'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Now, the count of objects `A` in each case is `2` because `B` extends `A` and
    thus has two types, `B` and `A`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we prefer to identify the object by exactly the current class name and not
    include its parent class in the consideration, we should implement the method
    `equals()` differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class A{
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public boolean equals(Object o){
  prefs: []
  type: TYPE_NORMAL
- en: if (o == null) return false;
  prefs: []
  type: TYPE_NORMAL
- en: return o.getClass().equals(this.getClass());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class B extends A{}
  prefs: []
  type: TYPE_NORMAL
- en: List<A> list5 = List.of(new A(), new B());
  prefs: []
  type: TYPE_NORMAL
- en: int c = Collections.frequency(list5, new A());
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(c);         //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: A a = new A();
  prefs: []
  type: TYPE_NORMAL
- en: List<A> list6 = List.of(a, new B());
  prefs: []
  type: TYPE_NORMAL
- en: c = Collections.frequency(list6, a);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(c);         //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The method `getClass()` returns the class name used when the object was created
    by the operator `new`. That is why the count in both cases is now `1`.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of this chapter, we are going to assume that the method `equals()`
    is implemented in the elements of the collections and arrays. Most of the time,
    we are going to use objects of the class `String` in our example. As we have mentioned
    earlier in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml), *Operators,
    Expressions, and Statements*, the class `String` has an `equals()` method implementation
    based on the string literal value, not on object reference only. And, as we have
    explained in the previous subsection, the class `String` also implements the interface
    `Comparable` so that it provides natural ordering.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing two collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is one straightforward static method for comparing two collections in
    the class `Collections`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean disjoint(Collection<?> c1, Collection<?> c2)`: Returns `true` if none
    of the elements of one collection equal any element of another collection'
  prefs: []
  type: TYPE_NORMAL
- en: As you probably guessed, this method uses the method `equals()` to identify
    equal elements.
  prefs: []
  type: TYPE_NORMAL
- en: Min and max elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following `Collections` class methods can be used to select the *biggest* and
    the *smallest* element of the provided collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '`T min(Collection<? extends T> collection)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T max(Collection<? extends T>collection)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T min(Collection<? extends T>collection, Comparator<T> comparator)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T max(Collection<? extends T>collection, Comparator<T> comparator)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two methods require the collection elements to implement `Comparable` (the
    method `compareTo(T)`), while the other two methods use an object of the class `Comparator` to
    compare the elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The smallest element is the one that is first in the sorted list; the biggest
    is on the opposite end of the sorted list. Here is the demonstration code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person p1 = new Person("Zoe", "Arnold");
  prefs: []
  type: TYPE_NORMAL
- en: Person p2 = new Person("Alex", "Green");
  prefs: []
  type: TYPE_NORMAL
- en: Person p3 = new Person("Maria", "Brown");
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> list7 = Arrays.asList(p1,p2,p3);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list7);  //[Zoe Arnold, Alex Green, Maria Brown]
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Collections.min(list7)); //prints: Alex Green'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Collections.max(list7)); //prints: Zoe Arnold'
  prefs: []
  type: TYPE_NORMAL
- en: Person min = Collections.min(list7, new OrderByLastThenFirstName());
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(min);                    //[Zoe Arnold]
  prefs: []
  type: TYPE_NORMAL
- en: Person max = Collections.max(list7, new OrderByLastThenFirstName());
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(max);                    //[Alex Green]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The first two methods use natural ordering to establish the order, while the
    second two use the comparator passed in as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Add and replace elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are three static methods of the class `Collections` that add
    or replace elements in a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean addAll(Collection<T> c, T... elements)`: Adds all the provided elements
    to the provided collection; if the provided element is `Set`, only unique elements
    are added. It performs significantly faster than the `addAll()` method of the
    corresponding collection type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean replaceAll(List<T> list, T oldVal, T newVal)`: Replaces every element
    in the provided list that is equal to `oldValue` with the `newValue`; when `oldValue` is
    `null`, the method replaces every `null` value in the provided list with the `newValue`.
    It returns `true` if at least one element was replaced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void fill(List<T> list, T object)`: Replaces every element in the provided
    list with the provided object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shuffle and swap elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following three static methods of the class `Collections` shuffle and swap
    elements of the provided list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void shuffle(List<?> list)`: Uses the default source of randomness to shuffle
    the positions of the elements in the provided list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void shuffle(List<?> list, Random random)`: Uses the provided source of randomness
    (we will talk about such sources in a corresponding section later) to shuffle
    the positions of the elements in the provided list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void swap(List<?> list, int i, int j)` : Swaps the element at position `i`
    in the provided list with the element at position j'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting to a checked collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following nine static methods of the class `Collections` convert the provided
    collection from a raw type (one without generics) to a certain type of element.
    The name *checked* implies that after the transformation, the type of each newly
    added element will be checked:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Set<E> checkedSet(Set<E> s, Class<E> type)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<E> checkedList(List<E> list, Class<E> type)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Queue<E> checkedQueue(Queue<E> queue, Class<E> type)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<E> checkedCollection(Collection<E> collection, Class<E> type)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map<K,V> checkedMap(Map<K,V> map, Class<K> keyType, Class<V> valueType)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SortedSet<E> checkedSortedSet(SortedSet<E> set, Class<E> type)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NavigableSet<E> checkedNavigableSet(NavigableSet<E> set, Class<E> type)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SortedMap<K,V> checkedSortedMap(SortedMap<K,V> map, Class<K> keyType, Class<V>
    valueType)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NavigableMap<K,V> checkedNavigableMap(NavigableMap<K,V> map, Class<K> keyType,
    Class<V> valueType)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the demonstration code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List list = new ArrayList();
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: list.add(42);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list);    //prints: [s1, s2, 42]'
  prefs: []
  type: TYPE_NORMAL
- en: List cList = Collections.checkedList(list, String.class);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list);   //prints: [s1, s2, 42]'
  prefs: []
  type: TYPE_NORMAL
- en: list.add(42);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list);   //prints: [s1, s2, 42, 42]'
  prefs: []
  type: TYPE_NORMAL
- en: //cList.add(42);           //throws ClassCastException
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: You can observe that conversion does not affect the current elements of the
    collection. We have added objects of the `String` class and an object of the `Integer`
    class to the same list and were able to convert it to a checked list `cList` without
    any problem. We can continue adding to the original list objects of different
    types, but the attempt to add a non-String object to the checked list generates
    `ClassCastException` at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Convert to a thread-safe collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are eight static methods in the class `Collections` that convert a regular
    collection to a thread-safe one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Set<T> synchronizedSet(Set<T> set)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<T> synchronizedList(List<T> list)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map<K,V> synchronizedMap(Map<K,V> map)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<T> synchronizedCollection(Collection<T> collection)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SortedSet<T> synchronizedSortedSet(SortedSet<T> set)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> map)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NavigableSet<T> synchronizedNavigableSet(NavigableSet<T> set)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NavigableMap<K,V> synchronizedNavigableMap(NavigableMap<K,V> map)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A thread-safe collection is constructed so that two application threads can only modify
    it sequentially without stepping on each other's temporary results. But, multithreaded
    processing is outside the scope of this book, so we'll leave it at that.
  prefs: []
  type: TYPE_NORMAL
- en: Convert to another collection type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The four static methods that convert one type of collection into another include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ArrayList<T> list(Enumeration<T> e)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Enumeration<T> enumeration(Collection<T> c)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Queue<T> asLifoQueue(Deque<T> deque)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set<E> newSetFromMap(Map<E,Boolean> map)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interface `java.util.Enumeration` is a legacy interface that came with Java
    1, along with the legacy classes `java.util.Hashtable` and `java.util.Vector` that
    use it. It is very similar to the `Iterator` interface. In fact, an `Enumeration`
    type object can be converted into an `Iterator` type by using the `Enumeration.asIterator()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: All these methods are rarely used in mainstream programming, so we are listing
    them here only for completeness.
  prefs: []
  type: TYPE_NORMAL
- en: Create enumeration and iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are also not-often-used static methods that allow the creation
    of an empty `Enumeration`, `Iterator`, and `ListIterator` - all are interfaces
    of the `java.util` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Iterator<T> empty iterator``()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListIterator<T> emptyListIterator()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Enumeration<T> emptyEnumeration()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class collections4.CollectionUtils
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The class `org.apache.commons.collections4.CollectionUtils` in the Apache Commons
    project contains static stateless methods that compliment the methods of the class
    `java.util.Collections`. They help to search, process, and compare Java collections.
    To use this class, you would need to add the following dependency to the Maven
    configuration file `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: <dependency>
  prefs: []
  type: TYPE_NORMAL
- en: <groupId>org.apache.commons</groupId>
  prefs: []
  type: TYPE_NORMAL
- en: <artifactId>commons-collections4</artifactId>
  prefs: []
  type: TYPE_NORMAL
- en: <version>4.1</version>
  prefs: []
  type: TYPE_NORMAL
- en: </dependency>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: There are many methods in this class, and more methods will probably be added
    over time. The just-reviewed `Collections` class will probably cover most of your
    needs, especially when you are just entering the field of Java programming. So,
    we are not going to spend time on explaining the purpose of each method, as we
    have done for the `Collections` class. Besides, the methods of `CollectionUtils`
    are created in addition to the methods of `Collections`, so they are more complex
    and nuanced and do not fit the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give you an idea of the methods available in the class `CollectionUtils`,
    we have grouped them by related functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods that retrieve an element:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object get(Object object, int index)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map.Entry<K,V> get(Map<K,V> map, int index)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map<O,Integer> getCardinalityMap(Iterable<O> collection)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods that add an element or a group of elements to a collection:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean addAll(Collection<C> collection, C[] elements)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean addIgnoreNull(Collection<T> collection, T object)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean addAll(Collection<C> collection, Iterable<C> iterable)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean addAll(Collection<C> collection, Iterator<C> iterator)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean addAll(Collection<C> collection, Enumeration<C> enumeration)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods that merge `Iterable` elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<O> collate(Iterable<O> a, Iterable<O> b)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<O> collate(Iterable<O> a, Iterable<O> b, Comparator<O> c)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<O> collate(Iterable<O> a, Iterable<O> b, boolean includeDuplicates)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<O> collate(Iterable<O> a, Iterable<O> b, Comparator<O> c, boolean includeDuplicates)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods that remove or retain elements with or without criteria:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<O> subtract(Iterable<O> a, Iterable<O> b)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '``Collection<O> subtract(Iterable<O> a, Iterable<O> b, Predicate<O> p)``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<E> removeAll(Collection<E> collection, Collection<?> remove)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<E> removeAll(Iterable<E> collection, Iterable<E> remove, Equator<E>
    equator)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<C> retainAll(Collection<C> collection, Collection<?> retain)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<E> retainAll(Iterable<E> collection, Iterable<E> retain, Equator<E>
    equator)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods that compare two collections:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean containsAll(Collection<?> coll1, Collection<?> coll2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean containsAny(Collection<?> coll1, Collection<?> coll2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isEqualCollection(Collection<?> a, Collection<?> b)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isEqualCollection(Collection<E> a, Collection<E> b, Equator<E> equator)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isProperSubCollection(Collection<?> a, Collection<?> b)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods that transform a collection:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<List<E>> permutations(Collection<E> collection)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void transform(Collection<C> collection, Transformer<C,C> transformer)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<E> transformingCollection(Collection<E> collection, Transformer<E,E>
    transformer)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<O> collect(Iterator<I> inputIterator, Transformer<I,O> transformer)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<O> collect(Iterable<I> inputCollection, Transformer<I,O> transformer)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<O> R collect(Iterator<I> inputIterator, Transformer<I,O> transformer,
    R outputCollection)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<O> R collect(Iterable<I> inputCollection, Transformer<I,O> transformer,
    R outputCollection)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods that select and filter a collection:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '``Collection<O> select(Iterable<O> inputCollection, Predicate<O> predicate)``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<O> R select(Iterable<O> inputCollection, Predicate<O> predicate,
    R outputCollection)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<O> R select(Iterable<O> inputCollection, Predicate<O> predicate,
    R outputCollection, R rejectedCollection)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<O> selectRejected(Iterable<O> inputCollection, Predicate<O> predicate)`,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<O> R selectRejected(Iterable<O> inputCollection, Predicate<O> predicate,
    R outputCollection)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E extractSingleton(Collection<E> collection)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean filter(Iterable<T> collection, Predicate<T> predicate)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean filterInverse(Iterable<T> collection, Predicate<T> predicate)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<C> predicatedCollection(Collection<C> collection, Predicate<C>
    predicate)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods that generate a union, an intersection, or a difference of two collections:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<O> union(Iterable<O> a, Iterable<O> b)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<O> disjunction(Iterable<O> a, Iterable<O> b)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<O> intersection(Iterable<O> a, Iterable<O> b)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods that create an immutable empty collection:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<T> Collection<T> emptyCollection()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<T> emptyIfNull(Collection<T> collection)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods that check collection size and emptiness:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int size(Object object)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean sizeIsEmpty(Object object)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int maxSize(Collection<Object> coll)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isEmpty(Collection<?> coll)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isNotEmpty(Collection<?> coll)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isFull(Collection<Object> coll)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Method that reverses an array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void reverseArray(Object[] array)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This last method should probably belong to the utility class that handles arrays,
    and that is what we are going to discuss now.
  prefs: []
  type: TYPE_NORMAL
- en: Manage arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will review how array objects can be created and initialized,
    and where you can find methods that allow us to perform some operations over arrays—copy,
    sort, and compare, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Although arrays have their place in some algorithms and legacy code, in practice
    an `ArrayList()` can do everything an array can do and does not require setting
    the size upfront. In fact, an `ArrayList` is using an array to store its elements
    at the back. So, the performance of an array and `ArrayList` is comparable too.
  prefs: []
  type: TYPE_NORMAL
- en: So, we are not going to discuss array management too much beyond the basics
    of creation and initialization. We will provide a short overview and references
    on where to find the array utility methods in case you need them.
  prefs: []
  type: TYPE_NORMAL
- en: Initialize arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen already a few examples of array construction. Now, we are going
    to review them and present other ways to create and initialize array objects.
  prefs: []
  type: TYPE_NORMAL
- en: Creation expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An array creation expression includes:'
  prefs: []
  type: TYPE_NORMAL
- en: The array element type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of levels of nested arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The length of the array for at least the first of the levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are one-level array creation examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int[] ints = new int[10];
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(ints[0]);     //prints: 0'
  prefs: []
  type: TYPE_NORMAL
- en: Integer[] intW = new Integer[10];
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(intW[0]);     //prints: null'
  prefs: []
  type: TYPE_NORMAL
- en: boolean[] bs = new boolean[10];
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(bs[0]);       //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: Boolean[] bW = new Boolean[10];
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(bW[0]);       //prints: 0'
  prefs: []
  type: TYPE_NORMAL
- en: String[] strings = new String[10];
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(strings[0]);  //prints: null'
  prefs: []
  type: TYPE_NORMAL
- en: A[] as = new A[10];
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(as[0]);       //prints: null'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(as.length);   //prints: 10'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As we have shown in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java
    Language Elements and Types*, every Java type has a default initialization value,
    used during object creation when no value is assigned explicitly. Because an array
    is a class, its elements are initialized—like the instance fields of any class
    - even if a programmer does not assign values to them explicitly. The numeral
    primitive types have a default value of 0, and the `boolean` primitive type `false`,
    while all reference types have the default value `null`. The class `A` used in
    the previous example is defined as `class A {}`. And the length of the array is
    captured in the final public property, `length`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The multi-level nested initialization looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: //A[][] as2 = new A[][10];             //compilation error
  prefs: []
  type: TYPE_NORMAL
- en: A[][] as2 = new A[10][];
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(as2.length);        //prints: 10'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(as2[0]);            //prints: null'
  prefs: []
  type: TYPE_NORMAL
- en: //System.out.println(as2[0].length);   //NullPointerException
  prefs: []
  type: TYPE_NORMAL
- en: //System.out.println(as2[0][0]);       //NullPointerException
  prefs: []
  type: TYPE_NORMAL
- en: as2 = new A[2][3];
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(as2[0]); //prints: ManageArrays$A;@282ba1e'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(as2[0].length); //prints: 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(as2[0][0]);     //prints: null'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to notice is that an attempt to create an array without defining
    the length of the first-level array generates a compilation error. The second
    observation is that the `length` property of the multi-level array captures the
    length of the array of the first (top) level. The third is that every element
    of the top-level array is an array. The elements of the next-level array are also
    arrays if that is not the last level.
  prefs: []
  type: TYPE_NORMAL
- en: In our previous example, we did not set the second-level array length, so each
    element of the top-level array was initialized to `null` because that is the default
    value of any reference type (and an array is a reference type too). That is why
    an attempt to get the length or any value of the second-level array generated
    `NullPointerException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as we set the length of the second-level array to three, we were able
    to get its length and the value of its first element (`null` because that is the
    default value). The strange printout `ManageArrays$A;@282ba1e` is the array binary
    reference because the object array does not have a `toString()` method implemented.
    The closest you can get is a static method, `toString()`, of the utility class
    `java.util.Arrays` (see the next section). It returns a `String` representation
    of all array elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Arrays.toString(as2));
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: [[ManageArrays$A;@282ba1e, [ManageArrays$A;@13b6d03]'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Arrays.toString(as2[0])); //[null, null, null]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'It works just fine for the last (the deepest) nested array, but still prints
    a binary reference for the higher-level arrays. If you want to print out all the
    elements of all the nested arrays, use the `Arrays.deepToString(Object[])` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Arrays.deepToString(as2));
  prefs: []
  type: TYPE_NORMAL
- en: '//the above prints: [[null, null, null], [null, null, null]]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Please note that if array elements do not implement the `toString()` method,
    then the binary reference will be printed for those elements that are not `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Array initializer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An array initializer consists of a comma-separated list of expressions, enclosed
    in braces `{}`. The comma after the last expression is allowed and ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String[] arr = {"s0", "s1", };
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Arrays.toString(arr)); //prints: [s0, s1]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We often use this way of initializing an array in our examples because it is
    the most compact way to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Static initialization block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As in the case of collections too, a static block can be used to initialize
    an array static property when some code has to be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class ManageArrays {
  prefs: []
  type: TYPE_NORMAL
- en: private static A[] AS_STATIC;
  prefs: []
  type: TYPE_NORMAL
- en: static {
  prefs: []
  type: TYPE_NORMAL
- en: AS_STATIC = new A[2];
  prefs: []
  type: TYPE_NORMAL
- en: for(int i = 0; i< AS_STATIC.length; i++){
  prefs: []
  type: TYPE_NORMAL
- en: AS_STATIC[i] = new A();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: AS_STATIC[0] = new A();
  prefs: []
  type: TYPE_NORMAL
- en: AS_STATIC[1] = new A();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //... the rest of class code goes here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in the static block is executed every time a class is loaded, even
    before the constructor is called. But if the field is not static, the same initialization
    code can be placed in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class ManageArrays {
  prefs: []
  type: TYPE_NORMAL
- en: private A[] as;
  prefs: []
  type: TYPE_NORMAL
- en: public ManageArrays(){
  prefs: []
  type: TYPE_NORMAL
- en: as = new A[2];
  prefs: []
  type: TYPE_NORMAL
- en: for(int i = 0; i< as.length; i++){
  prefs: []
  type: TYPE_NORMAL
- en: as[i] = new A();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: as[0] = new A();
  prefs: []
  type: TYPE_NORMAL
- en: as[1] = new A();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //the reat of class code goes here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: From collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If there is a collection that can be used as the source for the array values,
    it has the method `toArray()`, which can be called as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<Integer> list = List.of(0, 1, 2, 3);
  prefs: []
  type: TYPE_NORMAL
- en: Integer[] arr1 = list.toArray(new Integer[list.size()]);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Arrays.toString(arr1)); //prints: [0, 1, 2, 3]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Other possible methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a different context, there may be some other methods used to create and
    initialize an array. It is also a matter of the style you prefer. Here are examples
    of the variety of array creation and initialization methods you can choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String[] arr2 = new String[3];
  prefs: []
  type: TYPE_NORMAL
- en: Arrays.fill(arr2, "s");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Arrays.toString(arr2));      //prints: [s, s, s]'
  prefs: []
  type: TYPE_NORMAL
- en: String[] arr3 = new String[5];
  prefs: []
  type: TYPE_NORMAL
- en: Arrays.fill(arr3, 2, 3, "s");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Arrays.toString(arr3));
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: [null, null, s, null, null]'
  prefs: []
  type: TYPE_NORMAL
- en: String[] arr4 = {"s0", "s1", };
  prefs: []
  type: TYPE_NORMAL
- en: String[] arr4Copy = Arrays.copyOf(arr4, 5);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Arrays.toString(arr4Copy));
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: [s0, s1, null, null, null]'
  prefs: []
  type: TYPE_NORMAL
- en: String[] arr5 = {"s0", "s1", "s2", "s3", "s4" };
  prefs: []
  type: TYPE_NORMAL
- en: String[] arr5Copy = Arrays.copyOfRange(arr5, 1, 3);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Arrays.toString(arr5Copy));    //prints: [s1, s2]'
  prefs: []
  type: TYPE_NORMAL
- en: Integer[] arr6 = {0, 1, 2, 3, 4 };
  prefs: []
  type: TYPE_NORMAL
- en: Object[] arr6Copy = Arrays.copyOfRange(arr6,1, 3, Object[].class);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Arrays.toString(arr6Copy));      //prints: [1, 2]'
  prefs: []
  type: TYPE_NORMAL
- en: String[] arr7 = Stream.of("s0", "s1", "s2").toArray(String[]::new);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Arrays.toString(arr7));    //prints: [s0, s1, s2]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Out of six examples above, five used the class `java.util.Arrays` (see the next
    section) to fill or copy an array. And all of them used the method `Arrays.toString()`
    to print elements of the resulting array.
  prefs: []
  type: TYPE_NORMAL
- en: The first example assigns to all the elements of an array `arr2` values `s`.
  prefs: []
  type: TYPE_NORMAL
- en: The second example assigns the value `s` only to the elements from index 2 to
    index 3\. Notice that the second index is not inclusive. That's why only one element
    of an array `arr3` is assigned the value.
  prefs: []
  type: TYPE_NORMAL
- en: The third example copies the `arr4` array and makes the new array longer in
    size. That is why the rest of the new array elements are initialized to the default
    value of `String`, which is `null`. Notice that we have put a trailing comma in
    the `arr4` array initializer to demonstrate that it is allowed and ignored. It
    does not look like a very important feature. We have pointed it out just in case
    you see it in other people's code and wonder how it works.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth example creates a copy of an array using its elements from index
    1 to 3\. Again, the second index is not included, so only two elements are copied.
  prefs: []
  type: TYPE_NORMAL
- en: The fifth example not only creates a copy of the range of the elements but also
    converts them to the `Object` type, which is possible because the source array
    is of reference type.
  prefs: []
  type: TYPE_NORMAL
- en: And the last example is using the `Stream` class, which we are going to discuss
    in [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml), *Streams and Pipelines*.
  prefs: []
  type: TYPE_NORMAL
- en: Class java.util.Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have used the class `java.util.Arrays` already several times. It is the
    primary tool for array management. But, it used to be very popular with those
    who use collections too because the method `asList(T...a)` was the most compact
    way of creating and initializing a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = Arrays.asList("s0", "s1");
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> set = new HashSet<>(Arrays.asList("s0", "s1");
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'But after a factory method, `of()`, was introduced in each of the collections,
    the popularity of the `Arrays` class dropped substantially. The following is a
    more natural way to create a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = List.of("s0", "s1");
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> set = Set.of("s0", "s1");
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'This collection''s objects are immutable. But if a mutable one is needed, it
    can be created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = new ArrayList<>(List.of("s0", "s1"));
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> set1 = new HashSet<>(list);
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> set2 = new HashSet<>(Set.of("s0", "s1"));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We talked about this in great detail in the *Manage collections* section previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'But if your code manages arrays, then you definitely need to use the class
    `Arrays`. It contains more than 160 methods. Most of them are overloaded with
    different parameters and array types. If we group them by method name, there will
    be 21 groups. And if we group them further by functionality, only the following
    10 groups will cover all the `Arrays` class''s functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '`asList()`: Creates an `ArrayList` object based on the provided array (see
    examples in the previous section)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binarySearch()`: Allows the searching of an array or just a part of it specified
    (by the range of indices)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compare()`, `mismatch()`, `equals()`, and `deepEquals()`: Compare two arrays
    or their parts (by the range of indices)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copyOf()` and `copyOfRange()`: Copy all arrays or just a part of them (by
    the range of indices)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hashcode()` and `deepHashCode()`: Generate a hash code value based on the
    provided array content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toString()` and `deepToString()`: Create a `String` representation of an array
    (see examples in the previous section)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fill()`, `setAll()`, `parallelPrefix()`, and `parallelSetAll()`: Set the value
    (fixed or generated by the provided function) of every element of an array or those
    specified by the range of indices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sort()` and `parallelSort()`: Sort elements of an array or only part of it
    (specified by the range of indices)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`splititerator()`: Returns a `Splititerator` object for parallel processing
    of an array or part of it (specified by the range of indices)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stream()`: Generates a stream of array elements or some of them (specified
    by the range of indices); see [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml),
    *Streams and pipelines*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these methods are helpful, but we would like to attract your attention
    to the `equals(a1, a2)` and `deepEquals(a1, a2)` methods. They are particularly
    helpful for array comparison because an array object does not allow to implement
    a custom method `equals(a)` and thus always uses the implementation of the class
    `Object` that compares only references.
  prefs: []
  type: TYPE_NORMAL
- en: 'By contrast, both `equals(a1, a2)` and `deepEquals(a1, a2)` methods compare
    not just references `a1` and `a2`, but, in the case of arrays, use the method
    `equals(a)` to compare elements. This means that non-nested arrays are compared
    by values of their elements and considered equal when either both arrays are `null`
    or they have equal length and the method `a1[i].equals(a2[i])` returns `true`
    for each index:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Integer[] as1 = {1,2,3};
  prefs: []
  type: TYPE_NORMAL
- en: Integer[] as2 = {1,2,3};
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(as1.equals(as2));               //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Arrays.equals(as1, as2));       //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Arrays.deepEquals(as1, as2));   //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As for nested arrays, the `equals(a1, a2)` method uses the method `equals(a)`
    to compare elements of the next level. But the elements of the nested array are
    arrays, so they are compared by reference only, not by the value of their elements.
    If you need to compare values of the elements on all nested levels, use the method `deepEquals(a1,
    a2)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Integer[][] aas1 = {{1,2,3}, {4,5,6}};
  prefs: []
  type: TYPE_NORMAL
- en: Integer[][] aas2 = {{1,2,3}, {4,5,6}};
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Arrays.equals(aas1, aas2));       //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Arrays.deepEquals(aas1, aas2));   //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: Integer[][][] aaas1 = {{{1,2,3}, {4,5,6}}, {{7,8,9}, {10,11,12}}};
  prefs: []
  type: TYPE_NORMAL
- en: Integer[][][] aaas2 = {{{1,2,3}, {4,5,6}}, {{7,8,9}, {10,11,12}}};
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Arrays.deepEquals(aaas1, aaas2)); //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Class lang3.ArrayUtils
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The class `org.apache.commons.lang3.ArrayUtils` is a compliment to the class
    `java.util.Arrays`. It adds new methods to the array managing toolkit and the
    ability to handle `null` in cases when otherwise `NullPointerException` could
    be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly to the`Arrays` class , the `ArrayUtils` class has many (around 300)
    overloaded methods that can be collected into 12 groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add()`, `addAll()`, and `insert()`: Add elements to an array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clone()`: Clones an array, similar to the method `copyOf()` in  `java.util.Arrays` and
    the method `arraycopy()` of `java.lang.System`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getLength()`: Returns an array length and handles `null` (while the attempt
    to read the property `length` when an array is `null` throws `NullPointerException`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hashCode()`: Calculates the hash value of an array, including nested arrays'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contains()`, `indexOf()`, and `lastIndexOf()`: Search an array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isSorted()`,  `isEmpty`, and `isNotEmpty()`: Check an array and handle `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isSameLength()` and `isSameType()`: Compare arrays'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nullToEmpty()`: Converts a `null` array to an empty one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove()`, `removeAll()`, `removeElement()`, `removeElements()`, and `removeAllOccurances()`:
    Remove elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reverse()`, `shift()`, `shuffle()`, and `swap()`: Change the order of array
    elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subarray()`: Extracts part of an array by the range of indices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toMap()`, `toObject()`, `toPrimitive()`, `toString()`, and `toStringArray()`:
    Convert an array to another type and handle `null` values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise – Sort list of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Name two methods that allow sorting a list of objects, and the prerequisites
    for their use.
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two static methods of the class `java.util.Collections`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void sort(List<T> list)`: Sorts a list of objects that implement the interface
    `Comparable` (the `compareTo(T)` method),'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void sort(List<T> list, Comparator<T> comparator)`: Sorts objects according
    to the `Comparator` provided (the `compare(T o1, T o2)` method)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the reader to the classes from the Java Standard
    Library and Apache Commons that allow the manipulating of collections and arrays.
    Every Java programmer has to know the capabilities of the classes `java.util.Collections`,
    `java.util.Arrays`, `org.acpache.commons.collections4.CollectionUtils`, and `org.acpache.commons.lang3.ArrayUtils`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to discuss classes that, together with classes
    discussed in this chapter, belong to a group of the most popular utilities that
    every programmer has to master in order to become an effective coder.
  prefs: []
  type: TYPE_NORMAL
