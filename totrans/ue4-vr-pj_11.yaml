- en: Taking VR Further - Extending Unreal Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the major factors that differentiates professional developers from the
    newbies is how they leverage existing tools and libraries to accelerate their
    work. Very often, new developers try to do everything themselves, either because
    they're unaware of resources that could help them or because they think that leaning
    on an existing library is somehow *cheating*. It isn't. If you're a photographer,
    you're not cheating if you didn't build your own camera in your garage—you're
    focusing on the part of your art that actually matters to you. Don't be afraid
    to make use of tools and libraries that can accelerate your development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the rub though: to make effective use of another developer''s work,
    you need to put in the effort to understand what they''re doing. Don''t simply
    paste in someone else''s code without really understanding why it works—you''re
    just asking for difficult-to-find bugs if you do this. Do your homework and find
    code you can rely on, but consider it part of your homework to understand how
    it''s built so you can make deliberate choices about how you use it.'
  prefs: []
  type: TYPE_NORMAL
- en: Sooner or later in your development career, you'll encounter the phrase *cargo
    cult programming*. This term, commonly attributed to the physicist Richard Feynman,
    refers to aboriginal religious practices observed in some islands of the South
    Pacific after World War II, whereby the natives built replica airfields in an
    attempt to lure back the god-like cargo planes that had supplied the islands during
    the war. In doing this, they were reproducing the forms, but they didn't understand
    how those forms worked and didn't understand why they weren't working now. Don't
    let this describe how you develop software. For anything you include in the project
    you're building, you should be able to give a clear answer when another engineer
    points to any part of it and asks, *What is this doing*? This won't be possible
    in all cases, of course, but in general, consider that your work isn't finished
    until you've spent the time to understand how the library or plugin is doing what
    it's doing.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to focus primarily on one of the most useful plugins
    available for VR Developers: Joshua (MordenTral) Statzer's **VRExpansion** plugin.
    It's licensed under the MIT license (we're going to talk about licenses shortly—they're
    important), which means that it can be used freely in both non-commercial and
    commercial software. It doesn't cost anything, but it represents absolutely outstanding
    professional-caliber work, so if you use it, seriously consider supporting his
    Patreon to allow the project to continue.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to learn how to make effective use of an advanced
    plugin such as the VR Expansion plugin, and use the example Blueprints from its
    sample project to learn how it's intended to be used. We'll learn strategies for
    exploring and making sense of unfamiliar code, and ways of using debugging tools
    to show us how code runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we''ll learn to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Install and build plugins to extend the capabilities of the engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use documentation and sample projects to learn a plugin's capabilities and intended
    use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make use of new native classes provided by the plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use strategies to read complicated blueprints and make sense of their structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use debugging tools to help us to explore unfamiliar blueprints and learn their
    execution flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter is going to involve less direct Blueprint-building than those that
    came before it, and that's deliberate. The real focus here is on helping you to
    develop strategies to learn how unfamiliar code works so you can leverage it for
    your own development and use it to learn advanced techniques. This is one of the
    most important skills you can cultivate as a developer. It's fairly easy to find
    tutorials for basic topics, but once you get into more advanced territory, you
    mostly need to learn by looking at other advanced work. It's not as daunting as
    it might seem at first. We're going to learn a number of strategies to do this
    effectively.
  prefs: []
  type: TYPE_NORMAL
- en: With that, let's add to the engine and learn how to make it do things it couldn't
    do before.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project to house our plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin by creating a new blank project:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Blueprint project using the Blank template, and set its hardware
    target to Mobile / Tablet, and its graphics target to Scalable 3D or 2D, No starter
    content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing the VRExpansion plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we've created our project, we're going to add the VRExpansion plugin to
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do before we can install any plugin to our project
    is create a place to put it. Plugins must live in a directory named `Plugins`
    in your project directory or in the `Engine` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the directory containing your new project file. You should see your `.uproject`
    file here, along with your `Config` and `Content` directories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new directory here named `Plugins`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0b79cacd-6685-4290-88ac-40ea82cbc786.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we've created a `Plugins` directory for our project, let's add the
    VRExpansion plugin to it. There are a few ways we can do this.
  prefs: []
  type: TYPE_NORMAL
- en: Installing using precompiled binaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest way to get the plugin is to navigate to its forum discussion, [https://forums.unrealengine.com/development-discussion/vr-ar-development/89050-vr-expansion-plugin](https://forums.unrealengine.com/development-discussion/vr-ar-development/89050-vr-expansion-plugin),
    and use the Plugin Pre-built Downloads link for your engine version:'
  prefs: []
  type: TYPE_NORMAL
- en: Hit the Full Binaries and Source Package link for your engine version and download
    the zipped plugin
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the download has completed, open the `.zip` file and drag the `VRExpansionPlugin`
    directory contained within it into your `Plugins` directory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's it. As long as you installed the plugin version that was built for your
    engine version, you're ready to go and can open up your project.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling your own plugin binaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you need newer code for the plugin than what''s included in the pre-built
    binaries (which you will if you''re running a preview version of the engine),
    you''re going to need to build your plugin binaries on their own. This isn''t
    hard to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the VRExpansionPlugin depot on BitBucket here: [https://bitbucket.org/mordentral/vrexpansionplugin](https://bitbucket.org/mordentral/vrexpansionplugin)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit the Downloads link and hit the Download repository link to download a zipped
    version of the depot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's also possible to clone the plugin's Git depot directly into your project's
    plugins directory, but unless you're working on the bleeding edge and need absolutely
    up-to-date code, you don't really need to do this. You will want to do this if
    you're planning to contribute your own changes to the plugin. For most users,
    though, it's easier to download the zipped repository.
  prefs: []
  type: TYPE_NORMAL
- en: Now open up the `.zip` file you just downloaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll see a folder inside it named something like `mordentral-vrexpansionplugin-9c1737a17bef`
    (the hash at the end will be different)—drag this into your new `Plugins` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the name of the directory you just extracted to `VRExpansionPlugin`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3640ba69-20cb-4b39-abca-58d50bc2ff46.png)'
  prefs: []
  type: TYPE_IMG
- en: Now launch your project, or if it was already open, close it and re-open it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A dialog should now appear indicating that you need to build your plugin binaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7bc58fe-e057-43f2-a48b-2d9be7d295fb.png)'
  prefs: []
  type: TYPE_IMG
- en: If you set up Visual Studio Community 2017 as directed in [Chapter 2](24157dc8-09e6-4ff8-9ba2-3e0d0e4709b6.xhtml),
    *Setting Up Your Development Environment*, this isn't a problem. (If you didn't,
    jump back there now and follow the directions to set it up. It's always worth
    it to have a working compiler set up on your system because you will sometimes
    need it.) Say Yes and let Visual Studio build new binaries for you.
  prefs: []
  type: TYPE_NORMAL
- en: Your plugin should build successfully, but if it doesn't, navigate to the plugin's
    home page at [https://bitbucket.org/mordentral/vrexpansionplugin](https://bitbucket.org/mordentral/vrexpansionplugin)
    and follow the instructions under *Basic Installation Step-By-Step*, which will
    take you through the manual build process. As mentioned earlier, you also have
    the option to download pre-built binaries from here: [https://forums.unrealengine.com/development-discussion/vr-ar-development/89050-vr-expansion-plugin](https://forums.unrealengine.com/development-discussion/vr-ar-development/89050-vr-expansion-plugin).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you hit Show Log on the build dialog, you should be able to see your build
    progress. Expect it to take a few minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7d29455-8f0b-48c8-b9f6-f7bffae5ed8e.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the build finishes, your project will open.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the plugins in your project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regardless of how you downloaded and installed the plugin, it should now be
    available to you once you've opened the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'On opening the project, you should see two indicators in the lower-right corner
    indicating that you have new plugins available and asking whether you want to
    update your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20ee2192-5b15-4ef8-94ee-0a8de82ec578.png)'
  prefs: []
  type: TYPE_IMG
- en: Hit Manage Plugins... to open the plugins list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see two entries for the VRExpansion plugin, and they should both
    be enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9948cdb0-158e-43df-9035-33fbaf476014.png)'
  prefs: []
  type: TYPE_IMG
- en: This is as it should be, so we can close this window.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's update our project file by hitting the Update button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that your `.uproject` file is really just a text file telling Unreal
    a few basic things about your project. If you open it up in a text editor, you''ll
    see that new entries were added indicating that this project now relies on the
    VRExpansion plugin and its companion OpenVRExpansion plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41e2d270-b5d6-48a0-b8a2-65902c7cf7a0.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a text comparison of the .uproject file before and after we added the
    VRExpansion plugin
  prefs: []
  type: TYPE_NORMAL
- en: That's it. We're ready to start developing using the plugin, but before we do,
    let's talk a little bit about what we just did.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Plugins are an important part of the Unreal ecosystem. They can contain content,
    blueprints, native code, and anything else that affects what Unreal Engine can
    do and how it does it. They can save you tremendous amounts of time and extend
    the engine's capabilities almost infinitely.
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, you really don't need to know much about how Unreal handles
    plugins to use them—they pretty much just work, but if you want to be able to
    fix things if something goes wrong, or if you need to update a plugin to accommodate
    a new engine version, it is helpful to know a little bit about where they live
    and how they're put together. We're not going to go too deep into the weeds here,
    but there are a few quick things to point out that will help you in your future
    development. (If you do need to get deeper into how plugins are developed, begin
    with the documentation here: [https://docs.unrealengine.com/en-us/Programming/Plugin](https://docs.unrealengine.com/en-us/Programming/Plugins))
  prefs: []
  type: TYPE_NORMAL
- en: Where plugins live
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, it's important to know where to put new plugins that you want to install
    to a project or the engine and to know where plugins downloaded from the Epic
    Games launcher will be placed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any plugin you install will live in one of two places: in a `Plugins` directory
    in your project for plugins that are installed just to that specific project or
    in an `Engine\Plugins` directory for plugins that are installed to the engine
    and apply to all projects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a moment to look at your currently-installed engine plugins as given in
    the following step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the directory where you installed Unreal Engine (by default, this will
    be in `C:\Program Files\Epic Games`), and open the `Engine\Plugins` subdirectory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4c960396-7c47-40fb-bbe8-c3f5dc0ef038.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here you''ll notice something interesting: many features of the engine, even
    those we think of as core engine capabilities, such as effects editors, are really
    plugins living within the Unreal framework. That''s worth remembering. Plugins
    aren''t second-class citizens in Unreal Engine. Adding something to the engine
    through a plugin is really not meaningfully different than writing it directly
    into the engine code, except that it''s easier to replace it or to turn it on
    or off if it''s set up this way.'
  prefs: []
  type: TYPE_NORMAL
- en: Plugins you download through the Epic Games launcher will appear in the Marketplace
    subdirectory of your `Engine\Plugins` directory. In general, the Epic Games launcher
    will alert you when a plugin you've installed from the launcher has an update
    available, and you can update it directly from within the launcher. You'll rarely,
    if ever, need to open your `Engine\Plugins` directory, but it's worth knowing
    that it's there.
  prefs: []
  type: TYPE_NORMAL
- en: Installing plugins from the Marketplace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install a plugin using the Epic Games launcher, select the plugin you want
    from the Marketplace or from your Library, and hit the Install to Engine button,
    or if the plugin has been configured as an asset pack, hit the Add to Project button
    instead. Install to Engine will put the plugin in your engine install''s `Engine\Plugins\Marketplace`
    directory, while Add to Project will put it in your project''s `Plugins` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/875a3ba1-e363-4b64-9660-8847a04f445f.png)'
  prefs: []
  type: TYPE_IMG
- en: The Epic Games launcher will alert you automatically if a plugin you've installed
    using the tool has an update available.
  prefs: []
  type: TYPE_NORMAL
- en: What's inside a plugin?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know a bit about where plugins live in Unreal Engine, let's take
    a look at what they're made of.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we''re going to do a quick exploration of the VRExpansion plugin
    we installed to our project''s `Plugins` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up your project's `Plugins` directory, and open up the `VRExpansionPlugin`
    directory within it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''ll see that VRExpansion actually consists of two separate plugins within
    this directory: `VRExpansionPlugin` and `OpenVRExpansionPlugin`. The latter exists
    to support Valve Software''s OpenVR SDK. For our purposes here, we''re not going
    to worry about it and we''ll just focus on VRExpansion.'
  prefs: []
  type: TYPE_NORMAL
- en: There are two files here that we should take a moment to mention.
  prefs: []
  type: TYPE_NORMAL
- en: The first is the `README.md` file. Take a moment to open it up. This is a markdown
    file containing some basic information about the plugin.
  prefs: []
  type: TYPE_NORMAL
- en: If you have Visual Studio Code installed on your system, you can use VSCode
    to open markdown files. Once the file is open, you can right-click on its tab
    in the viewing area and select Open Preview, or just hit *Ctrl* + *Shift* + *V*
    to view the markdown with formatting.
  prefs: []
  type: TYPE_NORMAL
- en: You'll see that this `readme` file basically recreates the text on the main
    BitBucket page here: [https://bitbucket.org/mordentral/vrexpansionplugin](https://bitbucket.org/mordentral/vrexpansionplugin)
    and links to instruction and information pages. Many plugins will come with documentation
    or `readme` files that tell you where to find the documentation. It's worth it
    to take a look.
  prefs: []
  type: TYPE_NORMAL
- en: About licenses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The other file we should look at here is the `LICENSE.txt` file. If you're going
    to include a plugin in your project, it's important to know how you're allowed
    to use it.
  prefs: []
  type: TYPE_NORMAL
- en: If you've downloaded a plugin through the Marketplace, you don't need to worry
    about it. All plugins distributed through Epic's Marketplace are licensed for
    non-commercial or commercial use and don't place any additional restrictions on
    how they can be used.
  prefs: []
  type: TYPE_NORMAL
- en: If you need more information about licensing for plugins on the Marketplace,
    the details live here: [https://www.unrealengine.com/en-US/marketplace-distribution-agreement](https://www.unrealengine.com/en-US/marketplace-distribution-agreement).
  prefs: []
  type: TYPE_NORMAL
- en: If you're downloading a plugin directly from the net, as we did previously,
    you need to check the license and make sure the author allows you to use the plugin
    in the way you want to use it. Most plugin authors will not put restrictions on
    the way you use the software, but always read the license and make sure. You don't
    want to build a project with a plugin at its foundation only to discover when
    it's time to sell the software that you're not actually allowed to do so. Read
    the license first.
  prefs: []
  type: TYPE_NORMAL
- en: Be especially careful of software licensed under the GNU **General Public License**
    (**GPL**)—this license places significant restrictions on the software in which
    it can be used and isn't compatible with Unreal Engine's licensing terms. The
    much more permissive **MIT** and **Apache** licenses, however, are fine, and you'll
    encounter many Unreal plugins that use them.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the license for VRExpansion plugin allows you to do pretty much
    anything you want (other than removing the license file and trying to pretend
    that the work was your own), including modifying the plugin's code. It places
    no restrictions on the kind of project you use it for in terms of content or commercial
    versus non-commercial use. This is ideal. Whether we're making our project for
    sale as a commercial game, using it for live performance, just building as a hobby,
    or whatever, we're fine.
  prefs: []
  type: TYPE_NORMAL
- en: Inside a plugin directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we now open up the `VRExpansionPlugin` directory within the outer `VRExpansionPlugin`
    directory, we'll see a directory structure that looks a lot like the structure
    for an Unreal project. This isn't accidental. You can pretty much think of plugins
    almost as though they are mini projects being inserted into your project. They
    can contain code, blueprints, or assets and other content just as a project can.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re not going to worry about the contents of this directory except to take
    a look at one thing:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up the `VRExpansionPlugin.uplugin` file in a text editor
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''ll see that this file, just like your `.uproject` files, is just a text
    file containing information about your plugin. It''s rare that you''re ever going
    to need to open this file up, but just as with your `.uproject` files, you should
    know about it if you ever need to debug something or change something by hand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the information in here is just descriptive, but there''s one important
    detail: the `Plugins` block is used to specify dependencies between a plugin and
    other plugins. In this case, we can see that the `VRExpansion` plugin requires
    the `PhysXVehicles` plugin to be enabled. This shouldn''t be a problem because
    it''s on by default, but if you ever run into an instance where a plugin isn''t
    working, take a look at what it depends on and make sure those plugins are present
    as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s one other property you''ll sometimes run into. Some plugins specify
    an engine version that they''re allowed to work with, using an `EngineVersion` entry
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If a plugin contains this entry, Unreal will only allow it to load with the
    engine version specified here. (You can *sometimes* get around this by modifying
    this value by hand in your `.uplugin` file, but whether the plugin will compile
    and work will depend entirely on what's in it and what's changed in the engine
    version for which you're trying to compile it.)
  prefs: []
  type: TYPE_NORMAL
- en: Finishing our brief tour
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This has been a quick look at how Unreal plugins are installed and what's inside
    them. As we mentioned earlier, through most of your development, you won't need
    to mess with any of this, but when you do need to figure out what's going on with
    your software, it can be invaluable to know where to begin looking.
  prefs: []
  type: TYPE_NORMAL
- en: With this, then, let's move on and start working in VR.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the VRExpansion example project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we jump back into our own project, we're going to take one more detour
    to look at the example project maintained alongside the VRExpansion plugin, so
    we can see what sorts of things this plugin is going to let us do. We're also
    going to accelerate some of our development through this chapter by using blueprints
    from this project, so don't skip this step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by downloading it from here: [https://bitbucket.org/mordentral/vrexppluginexample/downloads/](https://bitbucket.org/mordentral/vrexppluginexample/downloads/).
    Follow the given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Hit the Download repository link to download a zipped version of the project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip the downloaded project to wherever you keep your Unreal example projects
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up the project directory, right-click `VRExpPluginExample.uproject`, and
    from the context menu, select Switch Unreal Engine version...
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set it to your current Unreal Engine version
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because this project was created as a C++ project, a Visual Studio solution
    file will also be created for you when you set a new engine version association.
    You don't need to work in C++ to use this plugin. Everything in the project itself
    was created using blueprints on top of the plugin, and this is how we're going
    to build our project as well, but if you're interested in digging deeper into
    the C++ classes and seeing how the plugin was built, this solution file offers
    a good way to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Try launching the project. It may ask you to build its included plugins. Let
    it. (Again, be sure you installed and set up Visual Studio according to the directions
    in [Chapter 2](24157dc8-09e6-4ff8-9ba2-3e0d0e4709b6.xhtml), *Setting Up Your Development
    Environment*.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the project launches, let it compile the shaders, and then explore a bit
    to see what it offers. It should become apparent fairly quickly that VRExpansion
    offers a tremendous leg-up to VR developers. It''s a treasure trove of professionally-written
    code and Blueprint examples of things you can do in VR, and numerous professionally-made
    and released games have used this plugin or parts of it in their development:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f4aabf0-9b7e-4d52-93ea-ee17077d47ec.png)'
  prefs: []
  type: TYPE_IMG
- en: A view of the VR Expansion Plugin's test project. You'll find a wealth of useful
    VR development examples in here.
  prefs: []
  type: TYPE_NORMAL
- en: Play around in here. We're not going to cover everything in this example project,
    since we're about to begin building our own, but you won't be wasting your time
    to explore enough to come away with a good sense of what's included and what you
    could re-purpose for your own applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few tips to get you started:'
  prefs: []
  type: TYPE_NORMAL
- en: Your controller's D-Pad or thumbstick triggers teleport movement, just as it
    did in our own examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Squeezing the controller grips when you don't have an object in your hand changes
    your movement modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We strongly encourage you now to spend some time experimenting with each movement
    mode. Teleportation and DPadPress-ControllerOrient modes will be familiar to you
    from the locomotion project we built earlier. Others will be new to you. Play
    with them and get ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: Many objects can be gripped and used. Use the triggers to grip.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: White objects can be gripped and climbed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player character does a nice job of handling cases where players shove their
    heads through walls. Try it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Barf Platform lives up to its name. (If you recall our discussions from
    [Chapter 1](8ad5a719-9b05-467c-ba9b-4467ce678145.xhtml), *Th**inking in VR*, you'll
    understand why.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider this example project to be a major resource as you learn what this
    plugin allows you to do. As a result of the work you've done in this book, you
    should be set up well to understand what you're seeing in the blueprints and to
    use them as starting points to develop further.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's jump in and build our own project using this plugin as a basis for
    our own work.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing our project setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our project set up, the VRExpansion plugin installed, and a
    basic understanding of what plugins are, let's jump back into building content.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, of course, we need to set our project settings appropriately for VR:'
  prefs: []
  type: TYPE_NORMAL
- en: Project | Description | Settings | Start in VR: False
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engine | Rendering | Forward Renderer | Forward Shading: True
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engine | Rendering | Default Settings | Ambient Occlusion Static Fraction: False
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engine | Rendering | Default Settings | Anti-Aliasing Method: MSAA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engine | Rendering | VR | Instanced Stereo: True
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engine | Rendering | VR | Round Robin Occlusion Queries: True
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s give ourselves an environment to play in:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the soul: Cave environment pack in the marketplace and add it to your
    new project. (It''s fine to do this while your project is open.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the environment pack has finished downloading, open up your project if
    it wasn't already open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under `Content/SoulCave/Maps`, find the LV_Soul_Cave_Mobile level and open it.
    Let your shaders compile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While this is happening, let''s set this as your project''s default level:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Settings | Project Settings | Project | Maps & Modes, and set Editor Startup
    Map and Game Default Map to LV_Soul_Cave_Mobile
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once your shaders have finished compiling, we can get down to work.
  prefs: []
  type: TYPE_NORMAL
- en: Using VRExpansion classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to use this project both as a review of the things we need to do
    when we set up a scene for VR and as an introduction to the VRExpansion classes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we're going to need to do, of course, now that we have our environment,
    is set it up with a nav mesh so we'll have the option to use teleport locomotion
    and so AI characters can navigate through it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by checking your collision environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Hit *Alt* + *C* (or the from the viewport, Show | Collision) to visualize your
    collision environment and make sure it looks sensible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The collision here looks good, so let's add a Nav Mesh Bounds Volume to the
    scene.
  prefs: []
  type: TYPE_NORMAL
- en: Drag a Nav Mesh Bounds Volume into the scene and scale it to encompass the areas
    where you want your player to be able to navigate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following values work reasonably well: Location (X= -11420.0, Y= -3790.0,
    Z= -490.0), and Scale (X= 100.0, Y= 160.0, Z= 20.0).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember that you can make your life easier when setting up volumes by using
    the viewport's top and side views to make sense of what you're doing.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting navmesh is going to cover a lot of spots where you're not going
    to want players to navigate, so remember to use Nav Modifier Volumes to block
    out undesirable teleport destinations.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a game mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As always, we''re going to want to set up a game mode for our project to specify
    which classes to load and to handle any rules we want to apply to our game:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory for your project inside the `Content` directory, and then
    create a blueprints directory inside this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Blueprint Class inside this directory and use Game Mode Base as
    its parent. Name it `BP_VRExpansionGameMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open Settings | Project Settings | Project | Maps & Modes, and set the Default
    GameMode to the new game mode you just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the World Settings for your map and reset Game Mode | GameMode Override
    to clear it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll be revisiting our new game mode multiple times as we add new classes based
    on the VRExpansion classes.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the PlayerStart class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The VRExpansion plugin provides a new player start class that''s scaled more
    accurately for the `VRCharacter` we''re going to spawn, so it represents more
    accurately where the player can fit. We''re going to use it here:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag a VRPlayerStart into your scene near the existing `PlayerStart` actor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the old `PlayerStart` Details, right-click its Transform | Location, and
    copy the value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the old `PlayerStart`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the VRPlayerStart and in its Details, right-click its Transform | Location,
    and paste in the value you copied from the old one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move it down a bit to place it on the floor. (X= -20220.0, Y= -13080.0, Z= -2118.0)
    works pretty well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a VR character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it''s time to add a VR-enabled character to our project. The `VRExpansion`
    plugin gives us two new classes from which we can derive a character for use in
    VR:'
  prefs: []
  type: TYPE_NORMAL
- en: '`VRSimpleCharacter` is a base class for VR-enabled characters that automatically
    sets up two `GripControllers`, a network-replicated VR camera, and implements
    a movement component specifically designed for use in VR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VRCharacter` includes everything found in `VRSimpleCharacter`, but adds a
    few additional methods to offset the collision by neck location and support more
    significant re-scaling of the character''s collision capsule.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, unless you're sure you need to use the neck collision offset or
    you're going to be radically changing the collision capsule size, use `VRSimpleCharacter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do this now:'
  prefs: []
  type: TYPE_NORMAL
- en: From within the blueprints directory where you placed your GameMode, right-click
    to create a new Blueprint Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the All Classes expander, and in the search box, type `vr char`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''ll see the `VRCharacter` and VRSimpleCharacter classes listed. Select
    VRSimpleCharacter. Name the new blueprint `BP_VRCharacter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d5266a44-3f4c-4da0-bab0-eb7bc953275f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, open up your Game Mode and set `BP_VRCharacter` as its Default Pawn Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the map. You won't be able to move around yet, but you should be properly
    registered to the floor.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our character is in place and our game mode has been told to spawn
    it, let's allow our player to control it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''re going to need to map some inputs. If we wanted to do this by
    hand, we would do this through Settings | Project Settings | Engine | Input, but
    to save a bit of time here, let''s just copy the `DefaultInput.ini` file from
    the VRExpansion sample project into ours:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the directory where you unzipped the VRExpansion example project, and copy
    the `DefaultInput.ini` file from its `Config` directory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your current project directory and paste `DefaultInput.ini` into it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Re-open your working project. Of course, if we were building our own game, we
    would design our own input scheme for it, but this gives us a quick way to have
    a few inputs already mapped and ready to go for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your VR character using example assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, ordinarily we would walk through the process of building this character
    from the ground up, but we have a lot of material to get through here, so we're
    going to save ourselves a bit of time by migrating the example character from
    the VRExpansion example project into our own, and then we're going to dig into
    how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Making effective use of example assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This brings up a point worth mentioning about using plugins and example assets
    and code. Very often, libraries and plugins will ship with example assets that
    have already been designed to work with them. It's always a good idea to get familiar
    with these, as they show you the author's intention for how they expect their
    code to be used. It's often the case, too, that these assets will be pretty close
    right out of the box to what you need them to be, though they'll rarely be exactly
    what you need.
  prefs: []
  type: TYPE_NORMAL
- en: There are two approaches you can take when making use of someone's example assets
    or code—you can incorporate the example wholesale, and then modify or remove anything
    that works differently than the way you want it to work, or you can build your
    own assets from scratch, using the example for guidance to see how the author
    recommends that you use their code. There are benefits and drawbacks to each approach.
    The first approach tends to get you working much earlier, but you'll often wind
    up with a lot of extra stuff that you don't need that then needs to be cleaned
    out. (Remember that we don't believe in cargo-cult programming here—you're not
    simply going to dump this code into your project and walk away without understanding
    it.) The second approach can take a more time, but gives you a clean class that
    does exactly what you need and only what you need, and that you understand fairly
    well because you wrote it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a middle road too, which is the path we recommend. Remember Kent Beck''s
    advice: *Make it work; make it right; make it fast*? Consider using an existing
    example asset or class as part of your *make it work* phase. During this phase,
    you''re experimenting with the class as the author wrote it, and learning how
    it works and how it''s meant to be used. Then, once you have a handle on things,
    start pulling out the stuff you now know you don''t need, and changing things
    that need to work differently, until you have a version that does what you need
    it to do. Now, move into your *make it right* phase. Is it OK as it is? Could
    it be maintained easily? Would another engineer, or future-you, a year from now,
    be able to read this blueprint and understand what''s going on? Consider in light
    of these questions whether you want to write a new, parallel version of the class
    now that you have a workable template for how it should be built.'
  prefs: []
  type: TYPE_NORMAL
- en: Migrating the example pawn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In light of this approach, let''s migrate the example project''s VR character
    blueprint into our project so we can start experimenting with it and learn how
    it''s built:'
  prefs: []
  type: TYPE_NORMAL
- en: From the `VRExpPluginExample` project, find the `Vive_PawnCharacter` blueprint
    in `Content/VRExpansion/Vive`, and migrate it into your new project's `Content`
    folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don't worry about the Vive-centric name. This character works fine with the
    Oculus Rift and Windows Mixed Reality headsets as well. When this plugin was first
    written, only the Vive supported room-scale VR. Once Oculus added this support,
    the plugin was updated to accommodate it, but the example names were never changed.
  prefs: []
  type: TYPE_NORMAL
- en: Return to your new project, and switch your Game Mode's Default Pawn Class to
    the `Vive_PawnCharacter` we just migrated in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We wanted to create the other VR character as an example to demonstrate that
    new classes introduced in plugins can be used just like any other engine class,
    but for the work we're actually going to do here, we're going to use the migrated
    character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test it out. You should now be able to navigate through the environment using
    teleport, and you should be able to use the grip buttons to change your movement
    mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ddae8f2f-d912-48e8-9302-33cc4160b97f.png)'
  prefs: []
  type: TYPE_IMG
- en: Play around a bit with this, and then we're going to take a look under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Making sense of complicated blueprints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the basics working, let's do some digging and understand how
    this class was built. You should find, as we do this, that many of the techniques
    you'll see in this blueprint will make more sense as a result of the work you've
    done so far in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The techniques we're going to explore here are valuable. If you work professionally
    in software development, or even if you work as a hobbyist, sooner or later, you're
    going to encounter an existing piece of code and you're going to need to figure
    out how it works. We're going to guide you through a few strategies to make this
    a far less-daunting task than it might at first seem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get to it:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Content/VRExpansion/Vive`, and find the `Vive_PawnCharacter` blueprint.
    Open it up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open its Event Graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yikes! There's a lot of stuff in here.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/966de70f-524f-4afc-a471-74d8769d2e27.png)'
  prefs: []
  type: TYPE_IMG
- en: The example project's Vive_PawnCharacter Blueprint contains a lot of Blueprint
    code. Digging through it isn't as daunting as it may seem at first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the thing though: as daunting as this may seem at first, you''re going
    to appreciate this soon enough. This class is an incredible compendium of useful
    techniques for developing VR characters. On its own, this would be a thing of
    beauty, but what makes it even more amazingly useful is that the blueprints written
    here and the underlying C++ code have been written with network replication in
    mind, so if you''re planning to write a networked VR experience, this class will
    help you right out of the box.'
  prefs: []
  type: TYPE_NORMAL
- en: To make use of it, however, you need some sense of where to begin. Let's learn
    how to approach a new class and figure it out.
  prefs: []
  type: TYPE_NORMAL
- en: Begin by checking the parent class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing you want to do any time you're looking at a new blueprint is
    check the upper-right corner of the interface, and see what its parent class is.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we can see that this blueprint derives from `VRCharacter`. `VRCharacter`
    is a native class written in C++. If you follow the link provided by the parent
    class indicator, it will open Visual Studio to this class, and you can explore
    its native implementation to learn more about it. For our purposes here, we're
    going to stay in Blueprints, but it's worth knowing that this is a thing you can
    do.
  prefs: []
  type: TYPE_NORMAL
- en: (If we were to burrow through this class in its native implementation, we would
    see that it derives from a `VRBaseCharacter` class, which in turn derives from
    `Character`. So, this class is essentially an Unreal character as described here: [https://docs.unrealengine.com/en-US/Gameplay/Framework/Pawn/Character](https://docs.unrealengine.com/en-US/Gameplay/Framework/Pawn/Character).
    But it has additional VR-specific modifications to replicate the camera and hand-controller
    positions, and handle movement in ways that make sense for VR.)
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the components to see what they're made of
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next thing to look at for any new class you''re exploring is its Components
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d8d230f-ff8d-4c2d-aebd-703744ac24fc.png)'
  prefs: []
  type: TYPE_IMG
- en: Looking at this components list tells us a lot about this character class and
    what it can do. It's worth doing this with the viewport active so you can see
    which components have visible representations. Roll over each component to see
    what type of component it is, and allow this to build an overall sense of the
    whole class in your mind.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the `VRCharacter` supports a static mesh for the head, a static
    mesh for the body, and two motion controllers with text renderers, grab-detection
    spheres, and skeletal meshes attached. (This motion controller setup should feel
    somewhat familiar to the work we did on grip interactions.) We can also see that
    it provides a character movement component and some support for VOIP communication.
  prefs: []
  type: TYPE_NORMAL
- en: You don't need to agonize over every detail when you're doing this. The point
    at this stage of the process is to build an overall mental model of what's in
    the class and how the parts fit together.
  prefs: []
  type: TYPE_NORMAL
- en: Look for known events and see what happens when they run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another useful starting point for getting information about a blueprint is to
    begin with events we know are likely to be implemented and see what they do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most classes will do some sort of setup work on Event BeginPlay, and most will
    do some work on Event Tick, so these are generally smart starting points:'
  prefs: []
  type: TYPE_NORMAL
- en: Hit *Ctrl* + *F* to activate the Find Results panel and type `beginplay` into
    the search bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hit *Enter*, since we''re just interested in searching inside this blueprint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4df34041-d73e-4cb0-a596-7df2468c25fa.png)'
  prefs: []
  type: TYPE_IMG
- en: Event BeginPlay appears on the Find Results list. We can double-click it to
    jump to that event in the blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at BeginPlay, we can see that it only handles this event on clients
    from the server; it uses a SetupOnPossession custom event instead. We can see
    that it's setting up grip components for the locally-controlled player; it's adjusting
    the tracking origin and spectator screen, and then for every body it's going to
    spawn and set up a pair of `BP_Teleport_Controller` actors, which get attached
    to the motion controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We may not know everything yet about this pawn, but just from looking at its
    BeginPlay, we''ve learned a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: This pawn has been set up to be used in network play—it's executing different
    paths depending on whether it has the authority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pawn handles some things differently depending on whether it's running locally
    or controlled by another player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teleport handling is managed by a separate class from the pawn. We'll want to
    look at this
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s do the same thing for Event Tick:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Search for `Tick`, and double-click the Event Tick entry that comes up in the
    results:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/3788e1d2-aab8-448a-85fa-24ef3fa96fa7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, this tells us a few things right off the bat:'
  prefs: []
  type: TYPE_NORMAL
- en: Remote pawns don't do anything on the tick at all. This is good.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tick is handling movement for the most part, but climbing movement was moved
    to a separate event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grip animations and teleport rotations are being handled on the tick too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's not necessary to do a deep dig at this stage of the process yet. Your intention
    here is to give yourself a broad view of what parts this class contains and when
    and how they do their work. This way, when you're looking for details later on,
    you'll have a good sense of where to look.
  prefs: []
  type: TYPE_NORMAL
- en: This process has given us a bit of information so far. Just by knowing the parent
    class, the components it contains, and two of its known events, we can already
    intuit a fair bit about what this class can do. Now it's time to get more specific
    and begin with a simple question—what happens when the player tries to teleport?
  prefs: []
  type: TYPE_NORMAL
- en: Using inputs as a way to find a starting point in your blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could try to answer this question by looking through this huge event graph
    and trying to find what we're looking for (and in this instance, that would work
    out reasonably well for us because the graph is well-organized and the author
    has done a good job of documenting it), but there's an easier way.
  prefs: []
  type: TYPE_NORMAL
- en: Start with a thing you know, and follow the execution from there to see what
    happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we know that the player executes the teleport by hitting one of
    the Dpads or thumbsticks, depending on whether they''re on a Vive, an Oculus,
    or some other device. That''s going to be mapped as an input. Let''s find it:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Settings | Project Settings | Engine | Input, and expand the Action Mappings
    expander.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There''s an input here named TeleportRight that sounds promising. If we expand
    it, we can see that it''s mapped to the right thumbstick, or FaceButton 1 (which
    is on the Vive is the Dpad''s top quadrant). That''s the one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de743c61-b7d4-4a0d-b019-7ade40639dc0.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have an input name to look for, we'll search for TeleportRight in
    our blueprints, and we're probably going to find something. (Some projects handle
    their inputs in the native C++ environment, but it's much more common to do it
    in blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: Jump back to your event graph and hit *Ctrl* + *F* to bring up the Find Results
    panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type `TeleportRight` in the search box and hit the binoculars symbol to the
    right of the box to run the search in all blueprints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3748c1ed-3b46-453c-982b-c0c46c252305.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There it is. Our character is handling that input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fe78abf-ac43-4e84-9a61-b1f2e0084490.png)'
  prefs: []
  type: TYPE_IMG
- en: Another useful strategy when you're looking for inputs is simply to type inputaction
    into your search box. Any input that's been mapped using the project's Inputs
    settings (which are written to DefaultInput.ini) will begin with this prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click the entry for InputAction TeleportRight, and you''ll be taken
    to that event handler in the event graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b53ae1c1-b260-4951-80f6-c7da504b070f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we have something to look at. We can use a breakpoint to confirm that we're
    looking at the right thing.
  prefs: []
  type: TYPE_NORMAL
- en: Setting breakpoints and tracing execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to use a breakpoint to verify that the code we think is going
    to execute when we trigger the input is really what executes. This is a common
    technique for understanding someone else''s code. When you''re not sure about
    its execution path, put breakpoints at locations you expect to be hit, and then
    see which ones really trip. This will give you a starting point from which to
    begin exploring the software:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the InputAction TeleportRight node, and hit *F9* to put a breakpoint
    on it, or right-click and select Toggle breakpoint from the context menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cb2dcc73-a9e9-44ed-b885-57bd2285c398.png)'
  prefs: []
  type: TYPE_IMG
- en: When a breakpoint is active on a blueprint node, it instructs the editor to
    pause the blueprint's execution when it reaches the node containing the breakpoint.
    You can then step through execution one action at a time and see what the blueprint
    is doing. Let's test this now.
  prefs: []
  type: TYPE_NORMAL
- en: With the breakpoint still set on InputAction TeleportRight, launch a VR Preview
    session (you don't really need to put on your headset for this—we're going to
    be back out of it in a second), and activate the right teleport input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The game should appear to freeze on you, and your VR headset will stop displaying
    the environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look now at the InputAction TeleportRight node. You''ll see a red arrow
    indicating that the blueprint simulation has paused at this node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4c957c4f-7d28-4913-876d-c1ef0e0ce9d1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take note of a few other things here too. You can see that the blueprint
    display is ringed with a yellow indicator to indicate that it''s currently simulating,
    and you can see from the title line that the graph is currently in a read-only
    state. You''re not allowed to change a blueprint while you''re simulating it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d32e937-713b-4d16-8013-8047eff116cd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s also take a look at the execution controls that have appeared on our
    toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: The Resume button will resume normal execution. (This is dicey when running
    VR—your headset may not properly wake back up from the paused state.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Frame Skip button allows a single frame to execute and returns to a paused
    state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Stop button will shut down your **Play-in-Editor** (**PIE**) session and
    return to the editor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Find Node button takes you back to the node at which execution is currently
    stopped.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These next three nodes are the important ones for stepping through code, and
    you should memorize their hotkeys because you''ll use them all of the time:'
  prefs: []
  type: TYPE_NORMAL
- en: Step Into (*F11*) steps to the next executed node, and jumps into a function's
    implementation if the node represents a blueprint function call or a macro.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see this in action before we move on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hit *F11* now. See how we''ve now jumped to the Switch on MovementMode node:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Roll over the selection input of Switch on MovementMode node. The rollover
    tooltip indicates the input''s type and its current value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3360295a-3b4c-460a-b356-40fd9d19e608.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that Movement Mode Right is currently set to Teleport, so the first
    branch of the switch statement is going to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Hit *F11* again, and execution steps to the `Branch` statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rolling over its input value, we can see that, because we're not hand-climbing,
    out of body, or in a movement-disabled state, this value is false and the false
    branch is going to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Hitting *F11* again takes us to the SetTeleporterActive node as we expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit *F11* again, and this time something interesting happened. Instead of jumping
    to the next node in the event graph, we jumped inside of the `Set Teleporter Active`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the difference between Step Into (*F11*) and Step Over (*F10*). *Step
    into* will take you wherever execution goes, even into function calls or macros,
    while *F10* will step over a function call without taking us inside it.
  prefs: []
  type: TYPE_NORMAL
- en: Continue hitting *F11* until we step inside of the Is Valid macro.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're not actually interested in the contents of this macro, so we'd like to
    step back out so we can continue looking at our `SetTeleporterActive` function.
  prefs: []
  type: TYPE_NORMAL
- en: Hit *Alt* + *Shift* + *F11*, or the Step Out button to get back to the `SetTeleporterActive`
    graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you've seen each of these three navigation operations in action. Practice
    them and get used to using their hotkeys. Stepping through blueprints like this
    is one of the fastest and most effective ways of seeing how a complex blueprint
    runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*F11* (Step Into) steps to the next executed node, even if it''s inside another
    function or macro.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*F10* (Step Over) steps to the next executed node in the current context, but
    does not step inside functions or macros that get called from that context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Alt* + *Shift* + *F11* (Step Out) steps back out of a function or macro to
    the context that called it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memorize these keys. You'll be happy you did.
  prefs: []
  type: TYPE_NORMAL
- en: These hotkeys—*F9* to toggle a breakpoint, *F10* to step over, and *F11* to
    step in, also work pretty much exactly the same way in Visual Studio when tracing
    through C++ code, and the same general techniques—find a known point in the code,
    set a breakpoint, and then step through to see how it works, and apply it there
    too. Use *Shift* + *F11* to step out of a method in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Hit *F11* until execution jumps into the `Activate Teleporter` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take a look at your tab bar and you'll see that you've now jumped into a different
    class altogether. The VRExpansion plugin's example project uses a separate Blueprint
    actor called `BP_TeleportController` to handle drawing the teleport beam and the
    target indicator. This is useful information.
  prefs: []
  type: TYPE_NORMAL
- en: This is also a smart way to design this system. Keeping a system such as this
    bundled together into its own object makes it easier in the long run to swap things
    out, to add it to a new character class, or to find what you're looking for if
    you need to debug. What you're seeing here is a more advanced organizational principle,
    but it's worth learning to think in these terms.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the execution trace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say we were stepping through a blueprint and we realized we needed to
    jump back a few steps to see what values drove a branch or a switch. To do this,
    we can make use of the Debug panel''s Execution Trace:'
  prefs: []
  type: TYPE_NORMAL
- en: Select Window | Debug to bring up the Debug panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the panel's Execution Trace section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Continue stepping through your blueprint and watch what happens here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f265f7c7-f8b3-417a-8346-d03025d52168.png)'
  prefs: []
  type: TYPE_IMG
- en: The execution trace will build a list of breadcrumbs showing where we've been
    so far as we step through execution. Any time you need to revisit a previous execution
    step, you can click it, and you'll be taken to that section of the graph, where
    you can see what inputs were driving it and what outputs it produced.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one of the most effective ways you can learn a new blueprint: set breakpoints
    and see how it runs. You''ll develop a very clear sense of how the class is built
    this way.'
  prefs: []
  type: TYPE_NORMAL
- en: As you progress through your development career and get good at figuring out
    and leveraging existing code, you're probably going to be surprised by how many
    developers you encounter who hold themselves back by failing to learn to do this
    effectively and wind up doing things the hard way, if they get anything done at
    all. Some of this, you'll find, is what developers call the *not-invented-here* syndrome
    (generally a fear of doing the work masked as an ego), and some of it is simply
    lack of knowledge. The time you spend doing your research and learning what's
    already been figured out about the problem you're trying to solve is never wasted
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Managing breakpoints with the Debug window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to do another exploration in a moment, but, first, we''re going
    to clear our breakpoints out of the Vive_PawnCharacter blueprint:'
  prefs: []
  type: TYPE_NORMAL
- en: Hit the Stop button to end the simulation and return to the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tab back to the Vive_PawnCharacter blueprint, and if it isn't still open, select
    Window | Debug.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This time, we''re interested in the Breakpoints list displayed on this panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e2e7e37-02c4-49f4-bf1b-76ddf2123f37.png)'
  prefs: []
  type: TYPE_IMG
- en: In this screenshot, I've added a few more breakpoints to make the example clearer.
  prefs: []
  type: TYPE_NORMAL
- en: You can click any breakpoint in the list to jump to its location in the blueprint,
    and you can right-click to disable or remove a breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling a breakpoint turns the breakpoint off without removing it. This is
    useful if you want to omit a breakpoint temporarily but still want to be able
    to re-enable it later for further debugging.
  prefs: []
  type: TYPE_NORMAL
- en: You can also toggle any breakpoint on or off by selecting a blueprint node and
    hitting *F9*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s clear them all out of our class for now:'
  prefs: []
  type: TYPE_NORMAL
- en: Hit Debug | Delete All Breakpoints (or use *Ctrl* + *Shift* + *F9*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will remove the breakpoint we set on the input action earlier, along with
    any other breakpoints we might have set in this blueprint. This menu also gives
    you the option to disable and enable all breakpoints in a class, as well.
  prefs: []
  type: TYPE_NORMAL
- en: Using the call stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's do another experiment now. We've seen how we can begin stepping through
    execution at an input event to see what happens when the event gets called, but
    what if we're interested in a particular function, and we want to see when it
    gets called and who calls it? We have a few powerful tools to help us here too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we were seeing a camera fade happen in-game and we wanted to find
    out who was calling it. Maybe we''re not even sure what the name of the call is
    going to be, but we''re guessing it might have the word *fade* in its name:'
  prefs: []
  type: TYPE_NORMAL
- en: Hit *Ctrl* + *F* to activate the Find Results window, and type `fade` into the
    search bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the binoculars to find in all blueprints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ddc5211e-48f5-4a3c-84df-295fb039c4ba.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see a number of entries here, but most of them are variables. Clearly,
    the stuff in the fog sheet isn't what we're looking for, but these Start Camera
    Fade calls in Vive_PawnCharacter look promising.
  prefs: []
  type: TYPE_NORMAL
- en: Double-click the first Start Camera Fade entry to jump to its location in the
    graph, and hit *F9* to set a breakpoint on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this for the other three.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch a VR Preview session and activate a teleport.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execution will stop at one of the Start Camera Fade nodes. This time, though,
    instead of stepping through the code to see what happens next, we want to see
    how we got here.
  prefs: []
  type: TYPE_NORMAL
- en: Hit Window | Developer Tools | Blueprint Debugger to open up Blueprint Debugger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''ll see that the first of the three displayed tabs is labeled Call Stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83f2aa82-6431-4211-adaa-c587a01ac1af.png)'
  prefs: []
  type: TYPE_IMG
- en: The Call Stack is a list of all of the events and functions that led to where
    the execution has currently been paused. This gives you an enormous amount of
    information. The top of a call stack represents where execution is currently paused,
    and the entry right below it is the function or event that called it. The entry
    below that one is whatever called that function, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at this stack, we can see that a C++ routine detected the button-press
    and triggered InputAction TeleportRight. Then, a call was made from the event
    graph. Let''s double-click this entry in the Call Stack to see it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5cdb9e3-ffc5-476a-a4e2-9712953097fd.png)'
  prefs: []
  type: TYPE_IMG
- en: It's an Execute Teleportation call triggered by the input action's Released
    event.
  prefs: []
  type: TYPE_NORMAL
- en: We can double-click the next call—the `ExecuteTeleportation` event, and see
    the graph that leads to the camera fade we were looking for.
  prefs: []
  type: TYPE_NORMAL
- en: This is a powerful technique, and you should get into the habit of using it.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on using Unreal's blueprint debugging tools, look here: [https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/Debugging](https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/Debugging).
  prefs: []
  type: TYPE_NORMAL
- en: Do a bit of exploring through the blueprint using this tool, and then hit Stop
    to return to the editor.
  prefs: []
  type: TYPE_NORMAL
- en: Finding variable references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Going back to our teleport example, what if we wanted to know what changes that
    `Movement Mode` variable that drives the `switch` statements from InputAction
    TeleportRight?
  prefs: []
  type: TYPE_NORMAL
- en: 'This is easy to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the Movement Mode Right variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click it and select Find References, or hit *Alt* + *Shift* + *F*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7fa3ecd8-cd80-4425-baeb-20290d5124df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that this variable is used in a number of places, but it''s only
    set in two locations. This is what we''re interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23491156-c90f-4b70-ae71-12d5b920f801.png)'
  prefs: []
  type: TYPE_IMG
- en: Double-click on of the Set MovementModeRight entries in your Find Results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This takes us to the location where this variable is set, and we can see that
    this is taking place in a function called `Cycle Movement Modes`. We could then
    use the strategies we've learned to see when and how this function gets called,
    and what else happens along with it.
  prefs: []
  type: TYPE_NORMAL
- en: You can use *Alt* + Shift + *F* with functions as well as variables. Practice
    doing this.
  prefs: []
  type: TYPE_NORMAL
- en: Making sense of someone else's code is like untying a complicated knot. You'll
    discourage yourself if you try to make sense of it all at once. Instead, you find
    a single strand and start following it and pulling it apart, and the structure
    of it becomes clear as you go. These tools can help you to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Using more of the VRExpansion plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**VRExpansion** is a large plugin, and it provides a great deal of functionality
    to VR developers. Now that you have some strategies in place for exploring it
    and figuring out how it works and how you can use it, you''re going to be able
    to unlock enormous potential.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the character we've just explored, this plugin provides a VR-enabled
    player controller, an AI controller, stereo widgets, buttons, levers, and much
    more.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''d like to get a better sense of what this plugin includes (there''s
    far too much to fit within this chapter), hit the View Options popout in your
    content browser, turn on Show Plugin Content, and make sure Show C++ Classes is
    visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/199df761-7872-4dc1-a1c2-38ecd9b5c26e.png)'
  prefs: []
  type: TYPE_IMG
- en: Browse through the class directory and see what's in there. If you double-click
    any of these classes, its native source will open in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: One of your best resources though is the VR Expansion Plugin forum at UnrealEngine.com,
    found here: [https://forums.unrealengine.com/development-discussion/vr-ar-development/89050-vr-expansion-plugin](https://forums.unrealengine.com/development-discussion/vr-ar-development/89050-vr-expansion-plugin).
  prefs: []
  type: TYPE_NORMAL
- en: The plugin's author, Joshua Statzer (mordentral) is very active on the forum
    and is surrounded by a community of helpful developers who are very willing to
    help new developers to get on their feet.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter took a bit of a different turn from the tutorials we've done up
    to this point, as its intention really is to help you to get to a point where
    you can explore the numerous plugins, templates, examples, and other projects
    you find within the Unreal ecosystem and learn how to use them to accelerate your
    work and learn new techniques. This is one of the most valuable skills you can
    teach yourself as a developer. If you get comfortable exploring code you find
    in the wild, you'll develop much more powerful software in a much shorter time
    and learn more advanced techniques by seeing how experienced developers have approached
    the problem you're trying to solve. This will make you a better developer faster.
  prefs: []
  type: TYPE_NORMAL
