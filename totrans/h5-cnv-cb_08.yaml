- en: Chapter 8. Saving the World with Game Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating sprite sheets for the hero and enemies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating level images and boundary maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an Actor class for the hero and enemies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Level class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Health Bar class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Controller class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Model class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a View class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the HTML document and starting the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I wouldn''t be surprised if some of you bought this book solely for this chapter—after
    all, what fun is it to master the HTML5 canvas without being able to create your
    own video games? Of all the chapters in this book, this chapter was by far my
    favorite (with the next chapter being a close second). We might not actually be
    able to save the world with game development, but it sure is fun to create our
    own virtual worlds and save those instead. In this chapter, we''re going to pull
    all of our new found knowledge together to create Canvas Hero, a side-scroller
    action game starring the Canvas Hero, who can run, jump, levitate, and punch through
    a futuristic world full of menacing bad guys. Here are some of the features of
    the game:'
  prefs: []
  type: TYPE_NORMAL
- en: The hero can run left, run right, jump, and punch to attack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The level will look futuristic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The level will be full of enemies running around looking for trouble
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The level will have a foreground image that moves to the left and to the right
    as the player moves, and will also have a stationary background image to create
    depth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player can jump high enough to jump over bad guys and avoid getting punched
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When either the player or the enemies are hit, they will flash white to show
    that they have sustained damage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gravity will act on the player at all times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player cannot fall through the floor, run through walls, or jump through
    the ceilin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the hero can jump very high, there will be strategically placed levitation
    pods throughout the level to give the player a vertical boost so that he can reach
    high-up platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The game is over when the player's health drops to zero or if the player falls
    into a hole
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player wins the game when all of the bad guys have been defeated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And here are a few screenshots to give you an idea of what the game will look
    like when we''re done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/1369_08_13.jpg)![Introduction](img/1369_08_01.jpg)![Introduction](img/1369_08_03.jpg)![Introduction](img/1369_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first two recipes of this chapter cover techniques for creating the sprite
    sheets for the hero and bad guys as well as the level image and boundary map image.
    The next three recipes cover steps for creating classes for the hero, bad guys,
    level, and health bar objects. Recipes after that cover the **MVC** (**model**,
    **view**, **controller**) architecture of the game, and the last recipe will cover
    the HTML markup. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Creating sprite sheets for the heroes and enemies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sprite sheets are image files that contain snapshots of different motions for
    different players and enemies that will appear in the game. Sprite sheets are
    an alternative to working with dozens or hundreds of individual images which can
    impact the initial loading time and also become a nightmare for graphic artists
    to maintain. Canvas Hero contains a sprite sheet for the hero, a sprite sheet
    for the bad guys, and also a set of white sprite sheets used when either the hero
    or the bad guys sustain damage.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we get started, it's worth noting that even the most talented of game
    artists can spend more time creating game graphics than the time it takes to code
    a game, which is something that's often times overlooked. For Canvas Hero, we
    can make life easier for ourselves by downloading some sprites from my favorite
    sprite resource, [http://www.spriters-resource.com](http://www.spriters-resource.com),
    which is a free website containing a huge collection of sprite sheets and level
    images of classic old-school games.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we find suitable sprite sheets for the hero and the bad guys, we can crop
    out the sprites we need and then put together a sprite sheet using Adobe Photoshop,
    Gimp, or some other image editing software. Here''s the finished hero sprite sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/1369_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the hero sprite sheet contains four motions, one for standing,
    one for jumping, one for running, and one for punching (from top to bottom). When
    creating a sprite sheet, it's important that all of the sprite images fit inside
    a defined sprite size. For Canvas Hero, each sprite image fits inside a square
    that's 144 x 144 px. We should also ensure that each sprite image is facing the
    same direction because we can programmatically flip these images horizontally
    when we want to render a sprite that's facing the other direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, we can use this same process to create a sprite sheet for the bad
    guys as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/1369_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You'll notice that the bad guy sprite sheet is much simpler than the hero sprite
    sheet, simply because their movements are limited to running around and fighting
    (they never stand still or jump). For consistency, we can make the bad guy sprites
    144 x 144 px as well.
  prefs: []
  type: TYPE_NORMAL
- en: Creating level images and boundary maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have sprite sheets for the hero and the bad guys, it's time to create
    a virtual world for them to live in. In Canvas Hero, our virtual world will be
    a single level that moves left and right as the player moves through it, which
    will contain walls, a ceiling, a floor, platforms, and holes. In this recipe,
    we'll go over the steps for making a level image as well as a boundary map image
    that graphically contains information about the bounds of the level and also identifies
    special zones with different colors.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create the level image for Canvas Hero, we can use some prebuilt graphics
    downloaded from [http://www.spriters-resource.com](http://www.spriters-resource.com)
    and add in new platforms, holes, and levitators using Photoshop, Gimp, or some
    other image editor of your choice. To keep the level somewhat small in size, we
    can create a foreground level image that''s 6944 x 600 px. The canvas, which is
    900 x 600 px, will act as a viewing window to the level. Here''s a snapshot of
    a portion of the level which contains a transparent foreground and a couple of
    levitator pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1369_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we can create a background image to create the illusion of depth. Here''s
    the finished background image for Canvas Hero:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1369_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And here''s how the foreground and background images look together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1369_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once we have the foreground and background images completed, our next step is
    to create a boundary map. A boundary map is a graphical way to bound the player
    inside certain areas and also define special zones.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the boundary map for Canvas Hero, we can start with a black background
    juxtaposed on top of the level image, and then draw magenta rectangles where the
    actors can run freely, and also add cyan rectangles to represent levitation zones.
    Keeping the background image a solid color helps reduce the boundary map image
    size and cuts down on the image loading time. The following image is a section
    of the boundary map that corresponds to the preceding image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1369_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To better understand how boundary maps work, let''s walk through the player''s
    steps as he navigates through the preceding screen from left to right. Also keep
    in mind that the player''s x ,y position is in the center of the sprite image
    which is about level with the hero''s hip:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the left, notice that the magenta portion, RGB (255, 0, 255),
    of the boundary map is extremely thin (only about 10 px or so). This region corresponds
    to the small space that the player can reside beneath the low hanging ceiling
    above his head. If the player were to jump while in this region, his vertical
    ascent would be prevented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the hero walks past the low hanging ceiling, he'll come up to a levitation
    pod. Notice that there is plenty of vertical magenta space for him to jump upwards
    and into the levitation zone, which is cyan, RGB (0, 255, 255).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the player is inside of a cyan zone, he'll begin to float upwards until
    he can reach the platform in the middle of the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the player is on the platform, the ceiling is right above his head which
    prevents him from jumping.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player can continue walking to the right and then fall off the platform
    towards the ground.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once on the ground, the player can jump into a second levitation zone identified
    by the cyan rectangle, which boosts him up onto the next platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's more to it!
  prefs: []
  type: TYPE_NORMAL
- en: Boundary map alternative
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you'd rather not use a boundary map to define the level boundaries, you might
    consider constructing a large array of boundary points that define zones in space
    where the player can reside. The downside of this approach is that as the levels
    become large and complex, maintenance of the array can be quite time consuming.
    Additionally, this method can incur a significant performance overhead by constantly
    looping through the array and performing boundary calculations for each animation
    frame.
  prefs: []
  type: TYPE_NORMAL
- en: Level image alternatives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To keep this chapter as simple as possible, we chose to create the level with
    one large image. This image, unfortunately, is the main bottleneck when loading
    the game. Although the other images are small in size, including the boundary
    map, the level image is about 1.6 MB and can take a few seconds to load. If your
    levels are large, or you''re simply trying to make the game load as fast as possible,
    you might consider one of these alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lazy Loader**—A lazy loader will request sections of the level based on the
    player''s location such that only the visible and surrounding blocks of a level
    are downloaded rather than downloading the entire level image at once. The upside
    of this approach is an improved initial loading time, and the downside of this
    approach is that you have to programmatically manage which sections of the level
    are downloaded at which times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tiled Layout**—A tiled layout is a level that''s constructed from tile images.
    In other words, you could create small tiled images (say 30 x 30 px) that make
    up the textures for the floor, the walls, the ceilings, the levitator pods, and
    so on, and then use those images to build the level. The upside of this approach
    is that there''s virtually no loading time since the images are so small, and
    the downside is that the levels can start to look a litte redundant and uninteresting
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an Actor class for the hero and enemies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have all the main images set up and ready to go, it's time for the
    fun part (at least in my opinion) as we bring our virtual world to life with JavaScript
    and HTML5 canvas. Our first order of business is to create an Actor class which
    contains properties and methods for both the hero and the bad guys. In other words,
    both the hero and the bad guys will be instances of the Actor class. The Actor
    class will be responsible for directing the actors with methods such as `moveRight()`
    and `moveLeft()` , and is also responsible for rendering the actors by animating
    them with sprite sheets.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create an Actor class which can be used to instantiate
    the hero or the bad guys:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `Actor` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `attack()` method which triggers an attack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `stop()` method which stops the actor from moving:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `isFacingRight()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `moveRight()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `moveLeft()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `jump()` method which triggers the actor to jump:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `draw()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `fade()` method which fades the actor when he''s defeated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `updateSpriteMotion()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `updateSpriteSeqNum()` method which increments or resets the sprite
    sequence number for each sprite interval:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `damage()` method which decrements the actor''s health and sets
    the sprite sheet to the hit sprite sheet, causing the actor to flash white for
    a brief moment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `getCenter()` method which returns the position of the center of
    the actor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The idea of the `Actor` class is to create a class that can be used to instantiate
    both the hero and the bad guys. It includes methods for controlling the actor,
    such as `moveRight()`, `moveLeft()`, `jump()`, and `attack()`, that either the
    game engine can call or a human player can call. The game engine will use these
    methods to control the bad guys, and a human player will use these methods to
    control the hero by pressing keys on the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to controls, the `Actor` class also manages the sprite animation
    by updating the sprite motion with the `updateSpriteMotion()` method and also
    increments or cycles the sprite sequence number with the `updateSpriteSeqNum()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `draw()` method picks out the sprite image corresponding to the
    actor's motion, flips the image horizontally if the actor is facing to the right,
    and then draws the actor on the screen using the `drawImage()` method of the canvas
    context.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Cropping an image* in [Chapter 3](ch03.html "Chapter 3. Working with Images
    and Videos")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Translating the canvas context* in [Chapter 4](ch04.html "Chapter 4. Mastering
    Transformations")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a mirror transform* in [Chapter 4](ch04.html "Chapter 4. Mastering
    Transformations")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Level class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll create a Level class which will be used to render the
    level and provide an API to the bundary map.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a Level class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `Level` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `setBoundsData()` method which extracts the zone data from the boundary
    map image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `draw()` method which draws the background image and the level image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `getZoneInfo()` method which returns zone information about a point
    in the boundary map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the heavy lifting in the `Level` class is done in the `setBoundsData()`
    method and the `getZoneInfo()` method. The `setBoundsData()` method takes the
    boundary map image and converts it into an array of pixel data using the `getImageData()`
    method of the canvas context. The `getZoneInfo()` method is used to access a point
    in the boundary map and then return the corresponding zone information.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Canvas Hero, the zone information object contains two flags: `inBounds`
    and `levitating`. If the corresponding pixel in the boundary map is cyan, then
    this point corresponds to a zone that''s in bounds and is also inside a levitation
    zone. If the corresponding pixel in the boundary map is magenta, then this point
    corresponds to a zone that''s in bounds but not in a levitation zone. Finally,
    if the corresponding pixel in the boundary map is black, this means that the point
    is not in bounds or in a levitation zone.'
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Drawing an image* in [Chapter 3](ch03.html "Chapter 3. Working with Images
    and Videos")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting image data* in [Chapter 3](ch03.html "Chapter 3. Working with Images
    and Videos")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Health Bar class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll create a Health Bar class which is used to update and
    render the hero's health display.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a health bar class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `HealthBar` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `setHealth()` method which sets the health value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `draw()` method which draws the health bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `HealthBar` object has a simple constructor that initializes the position
    and size of the health bar, and it also contains two methods, `setHealth()` and
    `draw()`. The `setHealth()` method sets the `health` property of the `HealthBar`
    object, and the `draw()` method draws the health bar using the `rect()` method
    of the canvas context.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Controller class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have all of the images and classes for the objects in the game,
    our next order of business is to build the game engine. Canvas Hero is built with
    a standard MVC architecture, which separates the data, the presentation, and the
    control methods. In this recipe, we'll create a Controller class which is responsible
    for instantiating the model and view, initializing the game, controlling the game
    state, and managing keyboard events.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create the controller for Canvas Hero:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `Controller` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `loadImages()` method which loads all of the game images and then
    calls `initGame()` when they''ve all loaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `addKeyboardListeners()` method which attaches keyboard event listeners
    to the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `handleKeyUp()` method which is fired when a key is released:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `handleKeyDown()` method which is fired when a key is pressed down:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `initGame()` method which initializes the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `resetGame()` method which resets the game by reinitializing the
    game objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important role of a game controller is to control the flow of the game
    through game states. In Canvas Hero, the first game state is the loading state.
    This is the state where the player can read about how to play the game as the
    game loads. Once the game has finished loading, the controller is responsible
    for changing the game state to the ready state. While in this state, the game
    waits for the user to press enter to continue. Once the user presses enter, the
    controller now changes the game state to the play game state.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this moment, the actual game begins and the user has full control over the
    hero. If the player''s health drops to zero, or if the player falls into a hole,
    the controller will change the game state to the game over state. If, on the other
    hand, the player succeeds in defeating all of the enemies, the controller changes
    the game state to the win state, congratulating the hero on his awesome feat.
    Take a look at the following state machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1369_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In addition to controlling the game state, the controller is also responsible
    for managing keyboard events. The keyboard events are attached with the `addKeyboardListeners()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Model class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll create a Model class which is responsible for initializing
    and updating the hero, the bad guys, the level, and the health bar. These objects
    can be seen as the "data" of our game.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create the model for Canvas Hero:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `Model` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `removeDefeatedBadGuys()` method which loops through the bad guy
    array and then removes the ones that are no longer alive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `updateBadGuys()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `updateStage()` method which updates all of the game objects for
    each animation frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `initHealthBar()` method which initializes the health bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `initLevel()` method which initializes the level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `initHero()` method which initializes the hero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `initBadGuys()` method which initializes an array of bad guys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `moveBadGuys()` method which serves as a simple AI engine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `updateLevel()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `updateHeroCanvasPos()` method which updates the position of the
    hero relative to the canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `updateActor()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `updateActorVY()` method which uses the downward force of gravity
    and the upward force of the levitation pods to update the vertical velocity of
    an actor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `updateActorY()` method which updates the y position of the actor
    based on his vertical velocity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `updateActorX()` method which updates the actor''s x position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `nearby()` method which determines whether or not two actors are
    near each other:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an MVC architecture, the model is considered to be the "meat" of the architecture,
    because it represents the data layer. As Canvas Hero is a game, our data consists
    of the hero, bad guys, the level, and the health bar objects. Each of these objects
    contain properties which must be updated and accessed during each animation frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The model for Canvas Hero has three key responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the game objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the game objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling the bad guy AI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quite arguably, the most interesting method in our model is the `moveBadGuys()`
    method. This method can be thought of as the "AI" for our game engine. I've put
    the "AI" in quotes because in all honesty, the bad guys in Canvas Hero are pretty
    dumb. The `moveBadGuys()` method loops through all of the bad guy objects, determines
    whether they are close to a wall using the `getZoneInfo()` method of the `Level`
    object, and then changes their direction if they're about to run into one.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you're wanting to create a more challenging game, you might consider beefing
    up the `moveBadGuys()` method by giving the bad guys an ability to jump or even
    use the levitation pods.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating an Animation class* in [Chapter 5](ch05.html "Chapter 5. Bringing
    the Canvas to Life with Animation")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a View class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll create the View class, which is the simplest of the three
    MVC classes. The View class is responsible for drawing state screen images and
    also renders each animation frame by calling the `draw()` method for the level,
    each of the bad guys, the hero, and the health bar. In addition, the View class
    also renders a handy FPS display in the top-right cornerof the screen so we can
    see how well the game is performing.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create the view for Canvas Hero:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `View` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `drawScreen()` method which draws the loading, ready, game over,
    or win state screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `drawBadGuys()` method which draws the bad guys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `drawFps()` method which draws the FPS value of the game in the
    top-right corner of the screen so that we can see how well the game is performing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `stage()` method which draws all of the objects on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned earlier, the main responsibility of the `View` class is to draw
    state screens and draw the game screen. Canvas Hero has four different state screens:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ready state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game over state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Win state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Whenever the game state changes and a state screen is neede, the controller
    calls the `drawScreen()` method of the `View` object. Here''s a screenshot for
    eac of the game state screens:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1369_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Ready state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1369_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Game over state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1369_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Win state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1369_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Stressing the canvas and displaying the FPS* in [Chapter 5](ch05.html "Chapter 5. Bringing
    the Canvas to Life with Animation")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the HTML document and starting the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have all of the pieces for our game, including the graphics, the
    classes for the actors, the level, the health bar, and a completed game engine,
    it's time to tie it all together by setting up the HTML document and starting
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to set up the HTML document and start the game:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Link to the JavaScript files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the canvas inside the body of the HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, the HTML markup is quite simple. It's purpose is purely to link
    to required JavaScript files, embed the canvas tag, and initialize the controller.
    The controller initializes the model and the view. The model initializes the hero,
    the bad guys, the level, and the health bar. Once the images have loaded and the
    game state is changed to the ready state, the player presses the enter key and
    the game begins.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You're now ready to play the game and save the world! If you initialized the
    hero and the bad guys with a health of three units as defined in the model recipe,
    the hero can take up to three hits before game over, and each of the bad guys
    require three hits to be defeated. I've found that it's easiest to defeat the
    bad guys by jumping over them and repeatedly hitting them in the back until they're
    toast (cheap I know, but it works). It's also really fun to jump into the levitator
    pods and float in the air for a while, wait for just the right moment, and attack
    a bad guy from above like a ninja.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use this chapter as a foundation for your own side-scroller game, here
    are some other features that you might consider adding:'
  prefs: []
  type: TYPE_NORMAL
- en: Sound effects for jumping, landing, and punching using the HTML5 audio tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pause feature that freezes the game until it's resumed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timer and top scores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More levels, enemies, and bosses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Power-ups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An option to save the game state with HTML5 local storage or by saving the state
    in an online database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything else you can imagine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating an Animation class* in [Chapter 5](ch05.html "Chapter 5. Bringing
    the Canvas to Life with Animation")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
