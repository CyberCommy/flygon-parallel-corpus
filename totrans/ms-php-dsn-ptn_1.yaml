- en: Chapter 1. Why "Good PHP Developer" Isnt an Oxymoron
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in 2010, MailChimp published a post on their blog, entitled *Ewww, You
    Use PHP?* In this blog post, they described the horror when they explained their
    choice of PHP to developers who consider the phrase *good PHP programmer* an oxymoron.
    In their rebuttal they argued that their PHP wasn't *your grandfathers PHP* and
    that they use a sophisticated framework. I tend to judge the quality of PHP on
    the basis of, not only how it functions, but how secure it is and how it is architected.
    This book focuses on ideas of how you should architect your code. The design of
    software allows for developers to ease the extension of the code beyond its original
    purpose, in a bug-free and elegant fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'As Martin Fowler put it:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Any fool can write code that a computer can understand. Good programmers
    write code that humans can understand."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This isn't just limited to code style, but how developers architect and structure
    their code. I've encountered many developers with their noses constantly stuck
    in the documentation, copying and pasting bits of code until it works; hacking
    snippets together until it works. Moreover, I far too often see the software development
    process rapidly deteriorate as developers ever more tightly couple their classes
    with functions of ever increasing length.
  prefs: []
  type: TYPE_NORMAL
- en: Software engineers mustn't just code software; they must know how to design
    it. Indeed often a good software engineer, when interviewing other software engineers
    will ask questions about the design of the code itself. It is trivial to get a
    piece of code that will execute, and it is also benign to question a developer
    as to whether `strtolower` or `str2lower` is the correct name of a function (for
    the record, it's `strtolower`). Knowing the difference between a class and an
    object doesn't make you a competent developer; a better interview question would,
    for example, be how one could apply subtype polymorphism to a real software development
    challenge. Failure to assess software design skills dumbs down an interview and
    results in there being no way to differentiate between those who are good at it,
    and those who aren't. These advanced topics will be discussed throughout this
    book, by learning these tactics, you will better understand what the right questions
    to ask are when discussing software architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moxie Marlinspike once tweeted the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"As a software developer, I envy writers, musicians, and filmmakers. Unlike
    software, when they create something it is really done, forever".*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When developing software, we mustn't forget we are authors, not just of instructions
    for a machine, but we are also authoring something that we later expect others
    to extend upon. Therefore, our code mustn't just be targeted at machines, but
    humans also. Code isn't just poetry for a machine, it should be poetry for humans
    also.
  prefs: []
  type: TYPE_NORMAL
- en: This is, of course, better said than done. In PHP, this may be found especially
    difficult given the freedom PHP offers developers on how they may architect and
    structure their code. By the very nature of freedom, it may be both used and abused,
    so it is true with the freedom offered in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it is increasingly important that developers understand proper software
    design practices to ensure their code maintains the long term maintainability.
    Indeed, another key skill lies in *refactoring* code, improving the design of
    existing code to make it easier to extend in the long term.
  prefs: []
  type: TYPE_NORMAL
- en: '**Technical debt**, the eventual consequence of poor system design, is something
    that I''ve found comes with the career of a PHP developer. This has been true
    for me whether it has been dealing with systems that provide advanced functionality
    or simple websites. It usually arises because a developer elects to implement
    a bad design for a variety of reasons; this is when adding functionality to an
    existing codebase or taking poor design decisions during the initial construction
    of software. Refactoring can help us address these issues.'
  prefs: []
  type: TYPE_NORMAL
- en: SensioLabs (the creators of the Symfony framework) have a tool called  **Insight**
    that allows developers to calculate the technical debt in their own code. In 2011,
    they did an evaluation of technical debt in various projects using this tool;
    rather unsurprisingly they found that WordPress 4.1 topped the chart of all platforms
    they evaluated with them claiming it would take 20.1 years to resolve the technical
    debt that the project contains.
  prefs: []
  type: TYPE_NORMAL
- en: Those familiar with the WordPress core may not be surprised by this, but this
    issue of course is not only associated to WordPress. In my career of working with
    PHP, from working with security critical cryptography systems to working with
    systems that work with mission critical embedded systems, dealing with technical
    debt comes with the job. Dealing with technical debt is not something to be ashamed
    of for a PHP developer, indeed some may consider it courageous. Dealing with technical
    debt is no easy task, especially in the face of an ever more demanding user base,
    client, or project manager; constantly demanding more functionality without being
    familiar with the technical debt the project has associated to it.
  prefs: []
  type: TYPE_NORMAL
- en: I recently e-mailed the PHP Internals group as to whether they should consider
    deprecating the error suppression operator `@`. When any PHP function is prepended
    by an @ symbol, the function will suppress an error returned by it. This can be
    brutal, especially where that function renders a fatal error that stops the execution
    of the script, making debugging a tough task. If the error is suppressed, the
    script may fail to execute without providing developers a reason as to why this
    is. Usage of this operator may be described as an anti-pattern in some situations,
    something we will cover in [Chapter 4](ch04.html "Chapter 4. Structural Design
    Patterns"), *Structural Design Patterns.*
  prefs: []
  type: TYPE_NORMAL
- en: Despite the fact that no one objected to the fact that there were better ways
    of handling errors (`try`/`catch`, `proper validation`) than abusing the error
    suppression operator and that deprecation should be an eventual aim of PHP, it
    is the case that some functions return needless warnings even though they already
    have a success/failure value. This means that due to technical debt in the PHP
    core itself, this operator cannot be deprecated until a lot of other prerequisite
    work is done. In the meantime, it is down to developers to decide the best methodologies
    of handling errors. Until the inherent problem of unnecessary error reporting
    is addressed, this operator cannot be deprecated. Therefore, it is down to developers
    to be educated as to the proper methodologies that should be used to address error
    handling and not to constantly resort to using an `@` symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentally, technical debt slows down development of a project and often
    leads to code being deployed that is broken as developers try and work on a fragile
    project.
  prefs: []
  type: TYPE_NORMAL
- en: When starting a new project, never be afraid to discuss architecture as architecture
    meetings are vital to developer collaboration; as one Scrum Master I've worked
    with said in the face of criticism that "meetings are a great alternative to work",
    he said "meetings are work...how much work would you be doing without meetings?".
  prefs: []
  type: TYPE_NORMAL
- en: 'In the rest of this chapter, we will cover the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Coding style - the PSR standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revising object-oriented programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the environment with Composer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Who are the Gang of Four?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding style - the PSR standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to coding style, I would like to introduce you to the PSR standards
    created by the PHP Framework Interop Group. Namely, the two standards that apply
    to coding standards are PSR-1 (Basic Coding Style) and PSR-2 (Coding Style Guide).
    In addition to this, there are PSR standards that cover additional areas, for
    example, as of today; the PSR-4 standard is the most up-to-date autoloading standard
    published by the group. You can find out more about the standards at [http://www.php-fig.org/](http://www.php-fig.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Coding style being used to enforce consistency throughout a code base is something
    I strongly believe in. It does make a difference to your code readability throughout
    a project. It is especially important when you are starting a project (chances
    are you may be reading this book to find out how to do that right) as your coding
    style determines the style the developers following you in working on this project
    will adopt. Using a global standard such as PSR-1 or PSR-2 means that developers
    can easily switch between projects without having to reconfigure their code style
    in their IDE. Good code style can make formatting errors easier to spot. Needless
    to say that coding styles will develop as time progresses, to date I elect to
    work with the PSR standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'I am a strong believer in the phrase: a*lways code as if the guy who ends up
    maintaining your code will be a violent psychopath who knows where you live*.
    It isn''t known who wrote this phrase originally, but it''s widely thought that
    it could have been John Woods or potentially Martin Golding.'
  prefs: []
  type: TYPE_NORMAL
- en: I would strongly recommend familiarizing yourself with these standards before
    proceeding in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Revising object-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object-oriented programming is more than just classes and objects; it's a whole
    programming paradigm based around *objects* (data structures) that contain data
    fields and methods. It is essential to understand this; using classes to organize
    a bunch of unrelated methods together is not object orientation.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming you're aware of classes (and how to instantiate them), allow me to
    remind you of a few different bits and pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Polymorphism is a fairly long word for a fairly simple concept. Essentially,
    polymorphism means the same *interface* is used with a different underlying code.
    So multiple classes could have a draw function, each accepting the same arguments,
    but at an underlying level, the code is implemented differently.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I would like to talk about Subtype Polymorphism in particular
    (also known as Subtyping or Inclusion Polymorphism).
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we have animals as our supertype; our subtypes may well be cats, dogs,
    and sheep.
  prefs: []
  type: TYPE_NORMAL
- en: In PHP, interfaces allow you to define a set of functionality that a class that
    implements it must contain, as of PHP 7 you can also use scalar type hints to
    define the return types we expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'So for example, suppose we defined the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We could then implement this interface in our own class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to run this code without defining the classes we would get an error
    message as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Essentially, we are required to implement the methods we defined in our interface,
    so now let''s go ahead and create a class that implements these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve implemented these methods, we can then just instantiate the
    class we are after and use the functions contained in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'So where does polymorphism come into this? Suppose we had another class for
    a dog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s suppose we have multiple different types of animals in a `pets`
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can now actually go ahead and loop through all these pets individually in
    order to run the `talk` function. We don't care about the type of pet because
    the `talk` method that is implemented in every class we get is by virtue of us
    having extended the Animals interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s suppose we wanted to have all our animals run the `talk` method.
    We could just use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: No need for unnecessary `switch`/`case` blocks in order to wrap around our classes,
    we just use software design to make things easier for us in the long-term.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes work in a similar way, except for the fact that abstract classes
    can contain functionality where interfaces cannot.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that any class that defines one or more abstract classes
    must also be defined as abstract. You cannot have a normal class defining abstract
    methods, but you can have normal methods in abstract classes. Let''s start off
    by refactoring our interface to be an abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You might have noticed that I have also added a `walk` method as an ordinary,
    non-abstract method; this is a standard method that can be used or extended by
    any classes that inherit the parent abstract class. They already have their implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Note that it is impossible to instantiate an abstract class (much like it's
    not possible to instantiate an interface). Instead, we must extend it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in our `Cat` class let''s remove the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will replace it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all we need to refactor in order to get classes to extend the `Animal`
    abstract class. We must implement the abstract functions in the classes as we
    outlined for the interfaces, plus we can use the ordinary functions without needing
    to implement them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As of PHP 5.4 it has also become possible to instantiate a class and access
    a property of it in one system. PHP.net advertised it as: *Class member access
    on instantiation has been added, e.g. (new Foo)->bar().* You can also do it with
    individual properties, for example, `(new Cat)->legs`. In our example, we can
    use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Just to recap a few other points about how PHP implemented OOP, the `final`
    keyword before a class declaration or indeed a function declaration means that
    you cannot override such classes or functions after they've been defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s try extending a class we have named as `final`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, let''s do the same except at a function level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Traits (multiple inheritance)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Traits** were introduced in PHP as a mechanism for introducing Horizontal
    Reuse. PHP conventionally acts as a single inheritance language, because of the
    fact that you can''t inherit more than one class into a script.'
  prefs: []
  type: TYPE_NORMAL
- en: Traditional multiple inheritance is a controversial process that is often looked
    down upon by software engineers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me give you an example of using Traits first hand; let''s define an abstract
    `Animal` class that we want to extend into another class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: So now let's suppose we have a function to name our class, but we don't want
    it to apply to all our classes that extend the `Animal` class, we want it to apply
    to certain classes irrespective of whether they inherit the properties of the
    abstract `Animal` class or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we''ve defined our functions like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem now is that there is no place we can put them without using Horizontal
    Reuse, apart from copying and pasting different bits of code or resorting to using
    conditional inheritance. This is where Traits come to the rescue; let''s start
    off by wrapping these methods in a Trait called `Name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'So now that we''ve defined our Trait, we can just tell PHP to use it in our
    `Cat` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the use of the `Name` statement? That''s where the magic happens. Now
    you can call the functions in that Trait without any problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'All put together, the new code block looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Scalar type hints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let me take this opportunity to introduce you to a PHP 7 concept known as **scalar
    type hinting**; it allows you to define the return types (yes, I know this isn't
    strictly under the scope of OOP; deal with it).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at this function; firstly you will notice that before each
    of the arguments we define the type of variable we want to receive; in this case,
    it''s int (or integer). Next up, you''ll notice there''s a bit of code after the
    function definition `: int`, which defines our return type so our function can
    only receive an integer.'
  prefs: []
  type: TYPE_NORMAL
- en: If you don't provide the right type of variable as a function argument or don't
    return the right type of the variable from the function; you will get a `TypeError`
    exception. In strict mode, PHP will also throw a `TypeError` exception in the
    event that strict mode is enabled and you also provide the incorrect number of
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible in PHP to define `strict_types`; let me explain why you
    might want to do this. Without `strict_types`, PHP will attempt to automatically
    convert a variable to the defined type in very limited circumstances. For example,
    if you pass a string containing solely numbers it will be converted to an integer,
    a string that's non-numeric, however, will result in a `TypeError` exception.
    Once you enable `strict_types` this all changes, you can no longer have this automatic
    casting behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking our previous example, without `strict_types`, you could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Trying it again after enabling `strict_types`, you will find that PHP throws
    a `TypeError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'This configuration only applies on an individual file basis, putting it before
    you include other files will not result in this configuration being inherited
    to those files. There are multiple benefits of why PHP chose to go down this route;
    they are listed very clearly in version 0.5.3 of the RFC that implemented scalar
    type hints called **PHP RFC: Scalar Type Declarations**. You can read about it
    by going to [http://www.wiki.php.net](http://www.wiki.php.net) (the wiki, not
    the main PHP website) and searching for `scalar_type_hints_v5`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to enable it, make sure you put this as the very first statement in
    your PHP script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This will not work unless you define `strict_types` as the very first statement
    in a PHP script; no other usages of this definition are permitted. Indeed, if
    you try to define it later on, your script PHP will throw a fatal error.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in the interests of the rage-induced PHP core fanatic reading this
    book in its coffee stained form, I should mention that there are other valid types
    that can be used in type hinting. For example, PHP 5.1.0 introduced this with
    arrays and PHP 5.0.0 introduced the ability for a developer to do this with their
    own classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me give you a quick example of how this would work in practice, suppose
    we had an `Address` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then type the hint of the `Address` class that we inject into a `Customer`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is how it all can come together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Limiting debug access to private/protected properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you define a class which contains private or protected variables, you will
    notice an odd behavior if you were to `var_dump` the object of that class. You
    will notice that when you wrap the object in a `var_dump` it reveals all variables;
    be they protected, private, or public.
  prefs: []
  type: TYPE_NORMAL
- en: PHP treats `var_dump` as an internal debugging function, meaning all data becomes
    visible.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there is a workaround for this. PHP 5.6 introduced the `__debugInfo`
    magic method. Functions in classes preceded by a double underscore represent magic
    methods and have special functionality associated with them. Every time you try
    to `var_dump` an object that has the `__debugInfo` magic method set, the `var_dump`
    will be overridden with the result of that function call instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me show you how this works in practice, let''s start by defining a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s instantiate this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we were to try and access the private variable that is `hasPaws`, we
    would get a fatal error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding call would result in the following fatal error being thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'That is the expected output, we don''t want a `private` property visible outside
    its object. That being said, if we wrap the object with a `var_dump` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We would then get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our `private` property is marked as `private`, but nevertheless
    it is visible. So how would we go about preventing this?
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s redefine our class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, after we instantiate our class and `var_dump` the resulting object, we
    get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The script all put together looks like this now, you will notice I''ve added
    an extra `public` property called `growls`, which I have set to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to `var_dump` this script (with both `public` and `private` property
    to play with), we would get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, only the `public` property is visible. So what is the moral
    of the story from this little experiment? Firstly, that `var_dumps` exposes private
    and protected properties inside objects, and secondly, that this behavior can
    be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment with Composer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Composer** is a dependency manager for PHP, strongly inspired by Node''s
    NPM and Bundler. It has now become integral to multiple PHP projects, including
    Laravel and Symfony. Why it is useful for us, however, is that it contains autoload
    functionality that is compliant with the PSR-0 and PSR-4 standards. You can download
    and install Composer from [http://getcomposer.org](http://getcomposer.org).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to install Composer globally on Mac OS X or Linux, first you can run
    the installer:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**curl -sS https://getcomposer.org/installer | php**`'
  prefs: []
  type: TYPE_NORMAL
- en: 'And then you can move Composer to install it globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**mv composer.phar /usr/local/bin/composer**`'
  prefs: []
  type: TYPE_NORMAL
- en: If the command preceding fails due to a permissions issue, rerun the command
    except putting `sudo` at the very start. You'll be asked to enter your password
    after you type the command, just enter it and hit *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've installed Composer by following the preceding steps, you can run
    it simply by running the `composer` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to install Composer on Windows it is easiest to just run the installer
    on the Composer website; currently you can find it at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://getcomposer.org/Composer-Setup.exe](https://getcomposer.org/Composer-Setup.exe).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Composer is fairly easy to update, just run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**Composer self-update**`'
  prefs: []
  type: TYPE_NORMAL
- en: Composer works by using the configuration in a file called `composer.json`,
    where you can outline external dependencies and your autoloading style. Once Composer
    has installed dependencies listed in this file, it writes a `composer.lock` file
    that details the exact versions it has installed. When using version control it
    is important that you commit this file (alongside the `composer.json` file), don't
    add it to your .`gitignore` file if you're on Git. This is very important because
    the lock file details the exact version of a package that was installed at a particular
    time in your version control system. You can, however, exclude a directory called
    `vendor`, I'll explain what that does later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start off by creating a file called `composer.json` in our project directory.
    This file is structured in JSON, so let me just remind you of how JSON works:'
  prefs: []
  type: TYPE_NORMAL
- en: JSON consists of key/value pairs of data, think of it like a set of variables
    being defined in a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A key value pair is comma separated, for example, `"key" : "value"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Curly brackets hold objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Square brackets hold arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple pieces of data must be comma separated, without leaving a trailing
    comma at the end of the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keys and values that include strings must be wrapped in quotes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A backslash `\` is the escape key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So now we can add the following markup to the `composer.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: So let me explain what this file does; it tells Composer to `autoload` everything
    in the `src/` directory into the `IcyApril\ChapterOne` namespace using the PSR-4
    standard.
  prefs: []
  type: TYPE_NORMAL
- en: So, the next step is to create our `src` directory where we include the code
    we want to autoload. Done that? Right, now let's open up our command line and
    move into the directory where we've put our `composer.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: In order to install everything in the `composer.json` file in your project just
    run the `composer install` command. For subsequent updates, the `composer update`
    command will update to the latest versions of all dependencies as defined in `composer.json`.
    If you don't want to do this, though, there is an alternative; running the `composer
    dump-autoload` command will solely regenerate the list of the PSR-0/PSR-4 classes
    that need to be included in the project (for example, you add, delete, or rename
    some of your classes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let me cover how you will actually go about creating a class. So, let''s
    create an `src` directory in our project and in that `src` directory create a
    new class called `Book`. You can do this by creating a file called `Book.php`.
    In that file, add something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is a standard class, except we're just defining a constructor that will
    echo `Hello world!` when the class is instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have noticed, we''ve followed a few naming conventions; firstly,
    the PSR-1 standard declares that class names must be declared in StudlyCaps. PSR-2
    has a few extra requirements; to name a few: four spaces instead of a tab, one
    blank space after a namespace or use declarations, and placing brackets on new
    lines. It''s definitely worth taking the time to read these standards if you haven''t
    already. You might not agree with every standard, you might have a subjective
    preference to how you format your own code; my advice is to put these preferences
    aside for the greater good. Having code that is standardized by means of utilizing
    the PSR standards offers great advantages when collaborating on common code bases.
    The benefit of having an external standard, built by an organization such as the
    PHP-FIG group, is that you have your configuration pre-built into your IDE (for
    example, PHPStorm supports PSR-1/PSR-2 out of the box). Not only this but, when
    it comes to formatting arguments you have a concrete impartial document that outlines
    how things should be done, which is great for stopping religious code formatting
    arguments during code reviews.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've created the class we can go ahead and run the `composer dump-autoload`
    command in order to refresh our autoloader script.
  prefs: []
  type: TYPE_NORMAL
- en: So, we've configured our Composer autoloader and we've also got a test class
    to play around with, but the next question is how we can implement this. So, let's
    go ahead and implement this. In the same directory where we've implemented our
    `composer.json` file, let's add our `index.php` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The line after you put in your PHP opening tag, we need to pull in our autoloader
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can instantiate our `Book` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Set up your web server, point your document root to the folder we created, direct
    your web browser to your chosen web server and you should see Hello world! pop
    up on screen. Now you can take apart the code and play around with it.
  prefs: []
  type: TYPE_NORMAL
- en: The completed code sample is available alongside this book, so you can open
    it up and play around with it directly from there, just in case you need any help
    debugging your code.
  prefs: []
  type: TYPE_NORMAL
- en: Whether your classes are abstract classes or mere interfaces, when autoloading
    we treat them all as classes.
  prefs: []
  type: TYPE_NORMAL
- en: The Gang of Four (GoF)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The architect Christopher Alexander, who mentioned how patterns can be used
    to address common design issues, originally documented the concept. The idea came
    about from Alexander; he proposes that design issues can be documented rigorously,
    alongside their proposed solution. Design patterns have most notably been applied
    to resolving architectural issues in software design.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Christopher Alexander''s own words:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"The elements of this language are entities called patterns. Each pattern
    describes a problem that occurs over and over again in our environment, and then
    describes the core of the solution to that problem, in such a way that you can
    use this solution a million times over, without ever doing it the same way twice."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Alexander wrote his own book, predating the Gang of Four called, *A Pattern
    Language*. In this book, Alexander created his own language, he coined the phrase
    *pattern language* to describe this; this language was formed from the building
    blocks of Architectural patterns. By utilizing these Architectural patterns the
    book proposes that ordinary people can use this language as a framework to improve
    their neighborhoods and towns.
  prefs: []
  type: TYPE_NORMAL
- en: 'One such pattern that is documented in the book is *Pattern 12*, known as the
    Community of 7000; the book documents this pattern by stating the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Individuals have no effective voice in any community of more than 5,000-10,000
    persons."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: By using problems such as this one with their documented solution; the book
    ultimately forms patterns, these patterns seek to act as the building blocks for
    making communities better.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned, Alexander predated the Gang of Four; but his work was essential
    for sowing the seeds for software design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's turn directly on to the authors known as *The Gang of Four*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nope, we''re not referring to the 1981 defectors from the British Labour party
    or an English post-punk band; but we are talking about the authors of a book called
    *Design Patterns: Elements of Reusable Object-Oriented Software*. This book has
    been highly influential in the realm of software development and is well known
    in the software engineering field.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first chapter of the book, the authors discuss object-oriented software
    development from their own personal experience; this includes arguing how software
    developers should program for an interface and not an implementation. This leads
    to code ultimately utilizing central functions of object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: It is a common misconception that the book contains only four design patterns,
    this isn't true; it covers 23 design patterns from three fundamental categories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s cover what these categories are:'
  prefs: []
  type: TYPE_NORMAL
- en: Creational
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavioral
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let's break each one of these down.
  prefs: []
  type: TYPE_NORMAL
- en: Creational design patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creational design patterns concern the creation of objects themselves. Basic
    instantiation of classes without using a design pattern can result in needless
    complexity, but also in significant design problems.
  prefs: []
  type: TYPE_NORMAL
- en: The main usage of Creational design patterns is to separate the instantiation
    of a class from the usage of that instance. Failure to use Creational design patterns
    can mean your code is harder to understand and test.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Dependency injection** is the process whereby you can actually input dependencies
    that your application needs directly into the object itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'John Munsch left an answer on Stack Overflow called *Dependency injection for
    five year olds*, this answer was republished in the book *Mark Seeman''s Dependency
    Injection in .NET*:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you go and get things out of the refrigerator for yourself, you can cause
    problems. You might leave the door open, you might get something Mommy or Daddy
    doesn't want you to have. You might even be looking for something we don't even
    have or which has expired.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What you should be doing is stating a need, "I need something to drink with
    lunch," and then we will make sure you have something when you sit down to eat.
  prefs: []
  type: TYPE_NORMAL
- en: When writing a class, it's natural to use other dependencies; perhaps a database
    model class. So with dependency injection, instead of a class having its database
    model created in itself, you can create it outside that object and inject it in.
    In short, we separate our client's behavior from our client's dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'When thinking of dependency injection, let''s outline the four separate roles
    involved:'
  prefs: []
  type: TYPE_NORMAL
- en: The service to be injected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client that depends on the service being injected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interface that determines how the client can use the service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The injector that is responsible for instantiating the service and injecting
    it into the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural design patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Structural design patterns are fairly easy to explain, they act as interconnectors
    between entities. It serves as a blueprint for how basic classes can be combined
    to form bigger entities, all Structural design patterns involve the interconnections
    between objects.
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral design patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Behavioral design patterns work to explain how objects interact with each other;
    how they can send messages between each of the objects and how you can divide
    the steps of various tasks up among classes.
  prefs: []
  type: TYPE_NORMAL
- en: Structural patterns describe the static architecture of a design; Behavioral
    patterns are more fluid and describe a flowing process.
  prefs: []
  type: TYPE_NORMAL
- en: Architectural patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is not strictly a *design pattern* (but the Gang of Four didn't cover Architectural
    patterns in their book); but it is incredibly relevant for PHP developers due
    to the web-oriented nature of PHP. Architectural patterns address various different
    constraints in computer systems through addressing performance limitations, high
    availability, and also minimization of business risk.
  prefs: []
  type: TYPE_NORMAL
- en: Most developers will be familiar with the Model-View-Controller architecture
    when it comes to web frameworks, more recently other architectures have started
    to emerge; for example, a microservices architecture works by a set of RESTful
    APIs that are independent and interconnected. Some people believe microservices
    move problems from the software development layer to the systems architecture
    layer. The opposite of microservices often referred to as a monolithic architecture,
    is where all the code is together in one application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we revised some PHP principles, including OOP principles. We
    also revised some PHP syntax basics. We have seen how you can use Composer for
    dependency management in PHP. In addition to this, we also discussed PSR standards
    and how you can implement them in your own code to make your code more readable
    by others, and also comply with some other important standards (be they autoloading
    or HTTP messaging). Finally, we introduced design patterns and the Gang of Four
    with the history behind design patterns.
  prefs: []
  type: TYPE_NORMAL
