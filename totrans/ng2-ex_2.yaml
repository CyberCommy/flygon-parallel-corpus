- en: Chapter 2.  Building Our First App - 7 Minute Workout
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。构建我们的第一个应用程序-7分钟锻炼
- en: I hope the first chapter was intriguing enough and you want to learn more about
    Angular. Believe me, we have just scratched the surface! The framework has a lot
    to offer, and it strives to make frontend development using JavaScript more organized
    and hence manageable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望第一章足够引人入胜，你想更多地了解Angular。相信我，我们只是触及了表面！这个框架有很多可提供的，它致力于使使用JavaScript进行前端开发更有条理，因此更易管理。
- en: Keeping up with the theme of this book, we will be building a new app in Angular,
    and in the process, developing a better understanding of the framework. This app
    will also help us explore some new capabilities of the framework.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 跟着本书的主题，我们将在Angular中构建一个新的应用程序，并在此过程中更好地理解这个框架。这个应用程序还将帮助我们探索框架的一些新功能。
- en: 'The topics that we will cover in this chapter include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主题包括以下内容：
- en: '**7 Minute Workout problem description**: We detail the functionality of the
    app that we build in this chapter.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7分钟锻炼问题描述：我们详细介绍了本章中构建的应用程序的功能。
- en: '**Code organization**: For our first real app, we will try to explain how to
    organize code, specifically Angular code.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码组织：对于我们的第一个真正的应用程序，我们将尝试解释如何组织代码，特别是Angular代码。
- en: '**Designing the model**: One of the building blocks of our app is its model.
    We design the app model based on the app''s requirements.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模型：我们应用程序的构建块之一是其模型。我们根据应用程序的要求设计应用程序模型。
- en: '**Understanding the data binding infrastructure**: While building the *7 Minute
    Workout* view, we will look at the data binding capabilities of the framework,
    which include *property*, *attribute*, *class*, *style*, and *event* bindings.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解数据绑定基础设施：在构建*7分钟锻炼*视图时，我们将研究框架的数据绑定能力，包括*属性*、*属性*、*类*、*样式*和*事件*绑定。
- en: '**Exploring the Angular platform directives**: Some of the directives that
    we will cover are `ngFor`, `ngIf`, `ngClass`, `ngStyle`, and `ngSwitch`.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Angular平台指令：我们将涵盖的一些指令包括`ngFor`、`ngIf`、`ngClass`、`ngStyle`和`ngSwitch`。
- en: '**Cross-component communication with input properties**: Having built some
    child components, we learn how *input **properties* can be used to pass data from
    the parent to its child components.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用输入属性进行跨组件通信：构建了一些子组件后，我们学习了如何使用*输入属性*将数据从父组件传递给其子组件。
- en: '**Cross-component communication with events**: Angular components can subscribe
    to and raise events. We get introduced to event binding support in Angular.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件进行跨组件通信：Angular组件可以订阅和触发事件。我们将介绍Angular中的事件绑定支持。
- en: '**Angular pipes**: Angular pipes provide a mechanism to format view content.
    We explore some standard Angular pipes and build our own pipe too to support conversions
    from seconds to hh:mm:ss.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular管道：Angular管道提供了一种格式化视图内容的机制。我们将探索一些标准的Angular管道，并构建我们自己的管道，以支持从秒转换为hh:mm:ss。
- en: Let's get started! The first thing we will do is define theof our *7 Minute
    Workout* app.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！我们要做的第一件事是定义我们的*7分钟锻炼*应用程序的模型。
- en: What is 7 Minute Workout?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是7分钟锻炼？
- en: We want everyone reading this book to be physically fit. Therefore, this book
    should serve a dual purpose; it should not only simulate your grey matter but
    also urge you to look after your physical fitness. What better way to do it than
    to build an app that targets physical fitness!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望每个阅读本书的人都能保持身体健康。因此，这本书应该具有双重目的；它不仅应该激发你的思维，还应该督促你关注自己的身体健康。有什么比构建一个针对身体健康的应用程序更好的方式呢！
- en: '*7 Minute Workout* is an exercise/workout plan that requires us to perform
    a set of twelve exercises in quick succession within the seven minute time span.
    *7 Minute Workout* has become quite popular due to its benefits and the short
    duration of the workout. We cannot confirm or refute the claims but doing any
    form of strenuous physical activity is better than doing nothing at all. If you
    are interested to know more about the workout, then check out [http://well.blogs.nytimes.com/2013/05/09/the-scientific-7-minute-workout/](http://well.blogs.nytimes.com/2013/05/09/the-scientific-7-minute-workout/).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*7分钟锻炼*是一种锻炼/训练计划，要求我们在七分钟的时间内快速连续进行一组十二个练习。由于其益处和短暂的锻炼时间，*7分钟锻炼*变得非常受欢迎。我们无法证实或否认这些说法，但进行任何形式的剧烈体育活动总比什么都不做要好。如果您对这项锻炼感兴趣，可以查看[http://well.blogs.nytimes.com/2013/05/09/the-scientific-7-minute-workout/](http://well.blogs.nytimes.com/2013/05/09/the-scientific-7-minute-workout/)了解更多信息。'
- en: The technicalities of the app include performing a set of 12 exercises, dedicating
    30 seconds for each of the exercises. This is followed by a brief rest period
    before starting the next exercise. For the app that we are building, we will be
    taking rest periods of 10 seconds each. So, the total duration comes out be a
    little more than 7 minutes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序的技术细节包括进行一组12个练习，每个练习需要30秒。然后是一个简短的休息时间，然后开始下一个练习。对于我们正在构建的应用程序，我们将每次休息10秒。因此，总持续时间略长于7分钟。
- en: 'At the end of the chapter, we will have the *7 Minute Workout* app ready, which
    will look something like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的结尾，我们将准备好*7分钟锻炼*应用程序，它将看起来像这样：
- en: '![What is 7 Minute Workout?](../Images/image00436.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![什么是7分钟锻炼？](../Images/image00436.jpeg)'
- en: Downloading the code base
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载代码库
- en: The code for this app can be downloaded from the GitHub site [https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample)
    dedicated to this book. Since we are building the app incrementally, we have created
    multiple checkpoints that map to **GitHub branches** such as `checkpoint2.1`,
    `checkpoint2.2`, and so on. During the narration, we will highlight the branch
    for reference. These branches will contain the work done on the app up to that
    point in time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序的代码可以从GitHub网站[https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample)下载，该网站专门为本书创建。由于我们正在逐步构建应用程序，我们创建了多个检查点，这些检查点映射到**GitHub分支**，如`checkpoint2.1`，`checkpoint2.2`等。在叙述过程中，我们将突出显示用于参考的分支。这些分支将包含截至该时间点的应用程序工作。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *7 Minute Workout* code is available inside the repository folder named
    `trainer`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*7分钟锻炼*代码位于名为`trainer`的存储库文件夹中。'
- en: So let's get started!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们开始吧！
- en: Setting up the build
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立构建
- en: Remember that we are building on a modern platform for which browsers still
    lack support. Therefore, directly referencing script files in HTML is out of question
    (while common, it's a dated approach that we should avoid anyway). The current
    browsers do not understand **TypeScript**; as a matter of fact, even **ES 2015**
    (also known as ES6) is not supported. This implies that there has to be a process
    that converts code written in TypeScript into standard **JavaScript (ES5)**, which
    browsers can work with.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们正在构建一个现代平台，对于这个平台，浏览器仍然缺乏支持。因此，在HTML中直接引用脚本文件是不可能的（虽然常见，但这是一种过时的方法，我们无论如何都应该避免）。当前的浏览器不理解**TypeScript**；事实上，甚至**ES
    2015**（也称为ES6）也不受支持。这意味着必须有一个过程将用TypeScript编写的代码转换为标准的**JavaScript（ES5）**，以便浏览器可以使用。
- en: Hence, having a build setup for almost any Angular 2 app becomes imperative.
    Having a build process may seem like overkill for a small application, but it
    has some other advantages as well.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于几乎任何Angular 2应用程序来说，建立构建过程变得至关重要。对于小型应用程序来说，构建过程可能看起来有些多余，但它也有其他一些优势。
- en: If you are a frontend developer working on the web stack, you cannot avoid **Node.js**.
    This is the most widely used platform for Web/JavaScript development. So, no prizes
    for guessing that the Angular 2 build setup too is supported over Node.js with
    tools such as **Grunt**, **Gulp**, **JSPM**, and **webpack**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个在Web堆栈上工作的前端开发人员，你无法避免**Node.js**。这是最广泛使用的Web/JavaScript开发平台。因此，毫无疑问，Angular
    2的构建设置也支持Node.js，使用诸如**Grunt**、**Gulp**、**JSPM**和**webpack**等工具。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since we are building on the Node.js platform, install Node.js before starting.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是在Node.js平台上构建的，请在开始之前安装Node.js。
- en: While there are quite elaborate build setup options available online, we go
    for a minimal setup using **Gulp**. The reason is that there is no one size fits
    all solution out there. Also, the primary aim here is to learn about Angular 2
    and not to worry too much about the intricacies of setting up and running a build.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在线上有相当复杂的构建设置选项，但我们选择使用**Gulp**进行最小化设置。原因是因为没有一个适合所有情况的解决方案。此外，这里的主要目的是学习Angular
    2，而不是过多担心设置和运行构建的复杂性。
- en: 'Some of the notable starter sites plus build setups created by the community
    are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 社区创建的一些值得注意的起始站点和构建设置如下：
- en: '| **Start site** | **Location** |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **开始网站** | **位置** |'
- en: '| `angular2-webpack-starter` | [http://bit.ly/ng2webpack](http://bit.ly/ng2webpack)
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `angular2-webpack-starter` | [http://bit.ly/ng2webpack](http://bit.ly/ng2webpack)
    |'
- en: '| `angular2-seed` | [http://bit.ly/ng2seed](http://bit.ly/ng2seed) |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `angular2-seed` | [http://bit.ly/ng2seed](http://bit.ly/ng2seed) |'
- en: '| `angular-cli`-We touched upon this tool in [Chapter 1](part0018.xhtml#H5A42-edca168d36254bda8a21f611a95615c3
    "Chapter 1. Getting Started"), *Getting Started*. It allows us to generate the
    initial code setup, including the build configurations, and has good scaffolding
    capabilities too. | [http://bit.ly/ng2-cli](http://bit.ly/ng2-cli) |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `angular-cli`-我们在[第1章](part0018.xhtml#H5A42-edca168d36254bda8a21f611a95615c3
    "Chapter 1. Getting Started")中提到过这个工具，*入门*。它允许我们生成初始的代码设置，包括构建配置，并且还具有良好的脚手架能力。
    | [http://bit.ly/ng2-cli](http://bit.ly/ng2-cli) |'
- en: 'A natural question arises if you are very new to **Node.js** or the overall
    build process: what does a typical Angular build involve? It depends! To get an
    idea about this process, it would be beneficial if we look at the build setup
    defined for our app. Let''s set up the app''s build locally then. Follow these
    steps to have the boilerplate Angular 2 app up and running:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对**Node.js**或整个构建过程非常陌生，自然会有一个问题：一个典型的Angular构建包括什么？这取决于情况！要了解这个过程，如果我们看一下为我们的应用定义的构建设置，会很有益。然后让我们在本地设置应用的构建。按照以下步骤让这个样板Angular
    2应用运行起来：
- en: 'Download the base version of this app from [http://bit.ly/ng2be-base](http://bit.ly/ng2be-base)
    and unzip it to a location on your machine. If you are familiar with how Git works,
    you can just clone the repository and checkout the branch `base`:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://bit.ly/ng2be-base](http://bit.ly/ng2be-base)下载这个应用的基本版本，并解压到您机器上的一个位置。如果你熟悉Git的工作原理，你可以直接克隆存储库并检出`base`分支：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code serves as the starting point for our app.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码作为我们应用的起点。
- en: 'Navigate to the `trainer` folder from the command line and execute these commands:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行导航到`trainer`文件夹并执行以下命令：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first command installs Gulp (and typings) globally so that you can invoke
    the **Gulp** command line tool from anywhere and execute *Gulp tasks*. A **Gulp
    task** is an activity that Gulp performs during the build execution. If we look
    at the Gulp build script (which we will do shortly), we realize that it is nothing
    but a sequence of tasks performed whenever a build occurs. The second command
    installs the app's dependencies (in the form of `npm` packages). **Packages**
    in the Node.js world are third-party libraries that are either used by the app
    or support the app's building process. For example, Gulp itself is a Node.js package.
    The **npm** is a command-line tool for pulling these packages from a central repository.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令全局安装了Gulp（和typings），这样你就可以在任何地方调用**Gulp**命令行工具并执行*Gulp任务*。**Gulp任务**是Gulp在构建执行期间执行的活动。如果我们查看Gulp构建脚本（我们很快就会做），我们会意识到它只是在构建发生时执行的一系列任务。第二个命令安装了应用程序的依赖项（以`npm`包的形式）。在Node.js世界中，**包**是第三方库，它们要么被应用程序使用，要么支持应用程序的构建过程。例如，Gulp本身就是一个Node.js包。**npm**是一个从中央存储库中拉取这些包的命令行工具。
- en: 'Once Gulp is installed and npm pulls dependencies from the npm store, we are
    ready to build and run the application. From the command line, enter the following
    command:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦安装了Gulp并且npm从npm存储库中拉取了依赖项，我们就可以构建和运行应用程序了。从命令行输入以下命令：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This compiles and runs the app. If the build process goes fine, the default
    browser window/tab will open with a rudimentary Hello World page (`http://localhost:9000/index.html`).
    We are all set to begin developing our app in Angular 2!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将编译并运行应用程序。如果构建过程顺利进行，将会打开默认的浏览器窗口/标签，显示一个简单的Hello World页面（`http://localhost:9000/index.html`）。我们已经准备好开始在Angular
    2中开发我们的应用程序了！
- en: But before we do that, it would be interesting to know what has happened under
    the hood.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们这样做之前，了解一下幕后发生了什么将会很有趣。
- en: The build internals
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建内部机制
- en: Even if you are new to Gulp, looking at `gulpfile.js` gives you a fair idea
    about what the build process is doing. A Gulp build is a set of tasks performed
    in a predefined order. The end result of such a process is some form of package
    code that is ready to be run. And if we are building our apps using *TypeScript*/*ES2015*
    or some other similar language that browsers do not understand natively, then
    we need an additional build step, called **transpilation**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你是Gulp的新手，看一下`gulpfile.js`也能让你对构建过程有一个大致的了解。Gulp构建是按预定义顺序执行的一系列任务。这样一个过程的最终结果是一些形式的包代码，可以直接运行。如果我们使用*TypeScript*/*ES2015*或者其他浏览器不原生支持的类似语言来构建我们的应用程序，那么我们需要一个额外的构建步骤，称为**转译**。
- en: Code transpiling
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码转译
- en: As it stands in 2016, browsers still cannot run *ES2015* code. While we are
    quick to embrace languages that hide the not-so-good parts of JavaScript (ES5),
    we are still limited by the browser's capabilities. When it comes to language
    features, **ES5** is still the safest bet as all browsers support it. Clearly,
    we need a mechanism to convert our *TypeScript* code into plain JavaScript (**ES5**).
    Microsoft has a TypeScript compiler that does this job.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2016年，浏览器仍然无法运行*ES2015*代码。虽然我们很快就会接受隐藏JavaScript（ES5）不太好的部分的语言，但我们仍然受到浏览器能力的限制。在语言特性方面，**ES5**仍然是最安全的选择，因为所有浏览器都支持它。显然，我们需要一种机制将我们的*TypeScript*代码转换为纯JavaScript（**ES5**）。微软有一个TypeScript编译器来完成这项工作。
- en: The TypeScript compiler takes the TypeScript code and converts it into ES5-format
    code that can run in all browsers. This process is commonly referred to as **transpiling**,
    and since the TypeScript compiler does it, it's called a **transpiler**.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器将TypeScript代码转换为可以在所有浏览器中运行的ES5格式代码。这个过程通常被称为**转译**，由于TypeScript编译器执行，所以它被称为**转译器**。
- en: 'Interestingly, transpilation can happen at both build/compile time and runtime:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，转译可以在构建/编译时和运行时都发生：
- en: '**Build-time transpilation**: Transpilation as part of the build process takes
    the script files (in our case, TypeScript `.ts` files) and compiles them into
    plain JavaScript. Our build setup uses build-time transpilation.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建时转译**：作为构建过程的一部分进行转译，将脚本文件（在我们的例子中是 TypeScript 的 `.ts` 文件）编译成普通的 JavaScript。我们的构建设置使用构建时转译。'
- en: '**Runtime transpilation**: This happens in the browser at runtime. We include
    the raw language-specific script files (`.ts` in our case), and the TypeScript
    compiler, which is loaded in the browser beforehand, compiles these script files
    on the fly. While runtime transpilation simplifies the build setup process, as
    a recommendation, it should be limited to development workflows only, considering
    the additional performance overhead involved in loading the transpiler and transpiling
    the code on the fly. The example in [Chapter 1](part0018.xhtml#H5A42-edca168d36254bda8a21f611a95615c3
    "Chapter 1. Getting Started"), *Getting Started*, used runtime transpilation,
    and hence it did not require any build setup. Go check it out again!'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时转译**：这发生在浏览器中的运行时。我们包括原始的特定语言脚本文件（在我们的例子中是 `.ts` 文件），以及 TypeScript 编译器，它在浏览器中预先加载，动态地编译这些脚本文件。虽然运行时转译简化了构建设置过程，但建议仅限于开发工作流程，考虑到加载转译器和动态转译代码所涉及的额外性能开销。[第1章](part0018.xhtml#H5A42-edca168d36254bda8a21f611a95615c3
    "第1章. 入门")中的示例，*入门*，使用了运行时转译，因此不需要任何构建设置。再去看一遍吧！'
- en: The process of transpiling is not limited to TypeScript. Every language targeted
    towards the Web, such as **CoffeeScript**, **ES2015**, or any other language that
    is not inherently understood by a browser, needs transpilation. There are transpilers
    for most languages, and the prominent ones (other than TypeScript) are **tracuer**
    and **babel**.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 转译的过程不仅限于 TypeScript。每种面向 Web 的语言，如 **CoffeeScript**、**ES2015** 或任何其他浏览器本身无法理解的语言，都需要转译。大多数语言都有转译器，其中一些著名的（除了
    TypeScript 之外）还有 **tracuer** 和 **babel**。
- en: 'To compile TypeScript files, we can install the TypeScript compiler manually
    from the command line using this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译 TypeScript 文件，我们可以使用以下命令行手动安装 TypeScript 编译器：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once installed, we can compile any TypeScript file into ES5 format using the
    compiler (`tsc.exe`).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装，我们可以使用编译器（`tsc.exe`）将任何 TypeScript 文件编译成 ES5 格式。
- en: But for our build setup, this process is automated using the `ts2js` Gulp task
    (check out `gulpfile.js`). And if you are wondering when we installed TypeScript...
    well, we did it as part of the `npm install` step, when setting up the code for
    the first time. The `gulp-typescript` package downloads the TypeScript compiler
    as a dependency.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于我们的构建设置，这个过程是通过 `ts2js` Gulp 任务自动化的（查看 `gulpfile.js`）。如果你想知道我们何时安装了 TypeScript...
    好吧，我们是在第一次设置代码时作为 `npm install` 步骤的一部分来安装的。`gulp-typescript` 包会将 TypeScript 编译器作为依赖项下载。
- en: 'With this basic understanding of transpilation, we can summarize what happens
    with our build setup:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有了对转译的基本理解，我们可以总结一下我们的构建设置发生了什么：
- en: The `gulp play` command kicks off the build process. This command tells Gulp
    to start the build process by invoking the `play` task.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gulp play` 命令启动构建过程。这个命令告诉 Gulp 通过调用 `play` 任务开始构建过程。'
- en: Since the `play` task has a dependency on the `ts2js` task, `ts2js` is executed
    first. The `ts2js` compiles the TypeScript files (`.ts`) located in `src` folder
    and outputs them to the `dist` folder at the root.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 `play` 任务依赖于 `ts2js` 任务，`ts2js` 会首先执行。`ts2js` 编译位于 `src` 文件夹中的 TypeScript
    文件（`.ts`）并将它们输出到根目录下的 `dist` 文件夹中。
- en: Post build, a static file server is started that serves all the app files, including
    static files (images, videos, and HTML) and script files (check `gulp.play` task).
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建后，启动了一个静态文件服务器，用于提供所有应用程序文件，包括静态文件（图像、视频和 HTML）和脚本文件（检查`gulp.play`任务）。
- en: Thenceforth, the build process keeps a watch on any script file changes (the
    `gulp.watch` task) you make and recompiles the code on the fly.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此后，构建过程将监视您所做的任何脚本文件更改（`gulp.watch`任务），并在飞行中重新编译代码。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **livereload** has also been set up for the app. Any changes to the code
    refresh the browser running the app automatically. In case automatic browser refresh
    fails, we can always do a manual refresh.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**livereload** 也已为应用程序设置。对代码的任何更改都会自动刷新运行应用程序的浏览器。如果自动浏览器刷新失败，我们总是可以手动刷新。'
- en: This is a rudimentary build setup required to run an Angular app. For complex
    build requirements, we can always look at the starter/seed projects that have
    a more complete and robust build setup, or build something of our own.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行 Angular 应用所需的基本构建设置。对于复杂的构建需求，我们可以随时查看具有更完整和健壮的构建设置的起始/种子项目，或者构建我们自己的项目。
- en: Next let's look at the boilerplate app code already there and the overall code
    organization.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们看一下已经存在的样板应用代码以及整体的代码组织。
- en: Organizing code
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织代码
- en: 'This is how we are going to organize our code and other assets for the app:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将组织应用程序的代码和其他资产的方式：
- en: '![Organizing code](../Images/image00437.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![组织代码](../Images/image00437.jpeg)'
- en: The `trainer` folder is the root folder for the app and it has a folder (`static`)
    for the static content (such as images, CSS, audio files, and others) and a folder
    (`src`) for the app's source code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`trainer`文件夹是应用程序的根文件夹，它有一个文件夹（`static`）用于静态内容（如图像、CSS、音频文件等），以及一个文件夹（`src`）用于应用程序的源代码。'
- en: The organization of the app's source code is heavily influenced by the design
    of Angular and the Angular style guide ([http://bit.ly/ng2-style-guide](http://bit.ly/ng2-style-guide))
    released by the Angular team. As we saw in [Chapter 1](part0018.xhtml#H5A42-edca168d36254bda8a21f611a95615c3
    "Chapter 1. Getting Started"), *Getting Started*, among the primary building blocks
    of Angular 2 are **components**. The `components` folder hosts all the components
    that we create. We will be creating subfolders in this folder for every major
    component of the application. Each component folder will contain artifacts related
    to that component, which includes its template, its implementation, and other
    related items. We will also keep adding more top-level folders (inside the `src`
    folder) as we build the application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序源代码的组织受到 Angular 的设计和 Angular 团队发布的 Angular 风格指南（[http://bit.ly/ng2-style-guide](http://bit.ly/ng2-style-guide)）的影响。正如我们在[第1章](part0018.xhtml#H5A42-edca168d36254bda8a21f611a95615c3
    "第1章。入门")中看到的，*入门*，在 Angular 2 的主要构建模块中包括**组件**。`components`文件夹托管了我们创建的所有组件。我们将为应用程序的每个主要组件在这个文件夹中创建子文件夹。每个组件文件夹将包含与该组件相关的工件，包括其模板、实现和其他相关项目。随着我们构建应用程序，我们还将在`src`文件夹中添加更多的顶级文件夹。
- en: If we look at the code now, the `components/app` folder has defined a *root
    level component* `TrainerAppComponent` and root level module `AppModule`. The
    `bootstrap.ts` file contains code to bootstrap/load the application module (`AppModule`).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在看一下代码，`components/app`文件夹已经定义了一个*根级组件* `TrainerAppComponent` 和根级模块 `AppModule`。`bootstrap.ts`文件包含了用于引导/加载应用模块（`AppModule`）的代码。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*7 Minute Workout* uses **Just-in-time (JIT) compilation** to compile Angular
    views. This implies that views are compiled just before they are rendered in the
    browser. Angular has a compiler running in the browser that compiles these views.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*7分钟锻炼*使用**即时（JIT）编译**来编译 Angular 视图。这意味着视图在在浏览器中呈现之前才被编译。Angular 在浏览器中运行一个编译器来编译这些视图。'
- en: Angular also supports the **Ahead-of-time (AoT) compilation** model. With AoT,
    the views are compiled on the server side using a server version of the Angular
    compiler. The views returned to the browser are precompiled and ready to be used.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Angular也支持**提前编译（AoT）**模型。通过AoT，视图在服务器端使用Angular编译器的服务器版本进行编译。返回给浏览器的视图是预编译的，可以立即使用。
- en: For *7 Minute Workout*, we stick to the JIT compilation model just because it
    is easy to set up as compared to AoT, which requires server-side tweaks and package
    installation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*7分钟锻炼*，我们坚持使用JIT编译模型，因为与需要服务器端调整和包安装的AoT相比，它更容易设置。
- en: We highly recommend that you use AoT compilation for production apps due the
    numerous benefits it offers. AoT can improve the application's initial load time
    and reduce its size too. Look at the AoT platform documentation (*cookbook*) at
    [http://bit.ly/ng2-aot](http://bit.ly/ng2-aot) to understand how AoT compilation
    can benefit you.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议您在生产应用中使用AoT编译，因为它提供了许多好处。 AoT可以改善应用程序的初始加载时间，也可以减小应用程序的大小。请查看AoT平台文档（*食谱*）[http://bit.ly/ng2-aot](http://bit.ly/ng2-aot)
    了解AoT编译如何使您受益。
- en: Time to start working on our first focus area, which is the app's model!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始我们的第一个重点领域了，那就是应用的模型！
- en: The 7 Minute Workout model
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7分钟锻炼模型
- en: 'Designing the model for this app requires us to first detail the functional
    aspects of the *7 Minute Workout* app, and then derive a model that satisfies
    those requirements. Based on the problem statement defined earlier, some of the
    obvious requirements are as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 设计这个应用的模型需要我们首先详细说明*7分钟锻炼*应用的功能方面，然后得出一个满足这些要求的模型。根据之前定义的问题陈述，一些明显的要求如下：
- en: Being able to start the workout.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够开始锻炼。
- en: 'Providing a visual clue about the current exercise and its progress. This includes
    the following:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供关于当前锻炼及其进度的视觉提示。这包括以下内容：
- en: Providing a visual depiction of the current exercise
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供当前锻炼的视觉描述。
- en: Providing step-by-step instructions on how to do a specific exercise
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供如何进行特定锻炼的逐步说明
- en: The time left for the current exercise
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前锻炼剩余的时间
- en: Notifying the user when the workout ends.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在锻炼结束时通知用户。
- en: 'Some other valuable features that we will add to this app are as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这个应用添加一些其他有价值的功能，如下所示：
- en: The ability to pause the current workout.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停当前的锻炼。
- en: Providing information about the next exercise to follow.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供关于接下来要进行的锻炼的信息。
- en: 'Providing audio clues so that the user can perform the workout without constantly
    looking at the screen. This includes:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供音频提示，使用户可以在不断地盯着屏幕的情况下进行锻炼。这包括：
- en: A timer click sound
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计时器点击声
- en: Details about the next exercise
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个锻炼的细节
- en: Signaling that the exercise is about to start
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发出锻炼即将开始的信号
- en: Showing related videos for the exercise in progress and the ability to play
    them.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示正在进行的锻炼相关的视频，并能够播放它们。
- en: As we can see, the central theme for this app is **workout** and **exercise**.
    Here, a workout is a set of exercises performed in a specific order for a particular
    duration. So, let's go ahead and define the model for our workout and exercise.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这个应用的中心主题是**锻炼**和**运动**。在这里，锻炼是按特定顺序进行的一系列锻炼，持续一段特定时间。因此，让我们继续定义我们的锻炼和运动的模型。
- en: 'Based on the requirements just mentioned, we will need the following details
    about an exercise:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 根据刚才提到的要求，我们将需要关于一项锻炼的以下细节：
- en: The name. This should be unique.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称。这应该是唯一的。
- en: The title. This is shown to the user.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题。这将显示给用户。
- en: The description of the exercise.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锻炼的描述。
- en: Instructions on how to perform the exercise.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于如何进行锻炼的说明。
- en: Images for the exercise.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锻炼的图片。
- en: The name of the audio clip for the exercise.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锻炼的音频剪辑名称。
- en: Related videos.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关视频。
- en: With TypeScript, we can define the classes for our model.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TypeScript，我们可以为我们的模型定义类。
- en: Create a folder called `workout-runner` inside the `src/components` folder and
    copy the `model.ts` file from the checkpoint2.1 branch folder `workout-runner`([http://bit.ly/ng2be-2-1-model-ts](https://github.com/chandermani/angular2byexample/blob/checkpoint2.1/trainer/src/components/workout-runner/model.ts))
    to the corresponding local folder. `model.ts` contains the model definition for
    our app.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/components`文件夹内创建一个名为`workout-runner`的文件夹，并将`checkpoint2.1`分支文件夹`workout-runner`（[http://bit.ly/ng2be-2-1-model-ts](https://github.com/chandermani/angular2byexample/blob/checkpoint2.1/trainer/src/components/workout-runner/model.ts)）中的`model.ts`文件复制到相应的本地文件夹中。
    `model.ts`包含了我们应用程序的模型定义。
- en: 'The `Exercise` class looks like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exercise`类看起来是这样的：'
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**TypeScript tips** Passing constructor parameters with `public` or `private`
    is a shorthand for creating and initializing class members at one go. The `?`
    suffix after `nameSound`, `procedure`, and `videos` implies that these are optional
    parameters.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**TypeScript提示** 使用`public`或`private`传递构造函数参数是一种快捷方式，可以一次创建和初始化类成员。在`nameSound`，`procedure`和`videos`后面的`?`后缀意味着这些是可选参数。'
- en: 'For the workout, we need to track the following properties:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于锻炼，我们需要跟踪以下属性：
- en: The name. This should be unique.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称。这应该是唯一的。
- en: The title. This is shown to the user.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题。这将显示给用户。
- en: The exercises that are part of the workout.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为锻炼一部分的练习。
- en: The duration for each exercise.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个练习的持续时间。
- en: The rest duration between two exercises.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个练习之间的休息时间。
- en: 'So, the model class (`WorkoutPlan`) looks like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，模型类（`WorkoutPlan`）看起来是这样的：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `totalWorkoutDuration` function returns the total duration of the workout
    in seconds.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`totalWorkoutDuration`函数返回锻炼的总持续时间（以秒为单位）。'
- en: '`WorkoutPlan` has a reference to another class in the preceding definition: `ExercisePlan`.
    It tracks the exercise and the duration of the exercise in a workout, which is
    quite apparent once we look at the definition of `ExercisePlan`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutPlan`在前述定义中引用了另一个类：`ExercisePlan`。它跟踪了锻炼和锻炼的持续时间，一旦我们查看`ExercisePlan`的定义，这就显而易见了：'
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These three classes constitute our base model, and we will decide in the future
    whether or not we need to extend this model as we start implementing the app's
    functionality.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个类构成了我们的基本模型，我们将在将来决定是否需要在实现应用程序功能时扩展这个模型。
- en: Since we have started with a preconfigured and basic Angular app, you just need
    to understand how this app bootstrapping is occurring.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经从预配置和基本的Angular应用程序开始，您只需要了解这个应用程序是如何引导的。
- en: App bootstrapping
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序引导
- en: '[Chapter 1](part0018.xhtml#H5A42-edca168d36254bda8a21f611a95615c3 "Chapter 1. Getting
    Started"), *Getting Started*, had a good introduction to the app bootstrapping
    process. The app bootstrapping process for *7 Minute Workout* remains the same,
    look at the `src` folder. There is a `bootstrap.ts` file with only the execution
    bit (other than `imports`):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](part0018.xhtml#H5A42-edca168d36254bda8a21f611a95615c3 "第1章。入门")，“入门”，对应用程序引导过程进行了很好的介绍。
    *7分钟锻炼*的应用程序引导过程保持不变，查看`src`文件夹。有一个`bootstrap.ts`文件，除了`imports`之外只有执行位：'
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `boostrapModule` function call actually bootstraps the application by loading
    the root module, `AppModule`. The process is triggered by this call in `index.html`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`boostrapModule`函数调用实际上通过加载根模块`AppModule`引导应用程序。这个过程是由`index.html`中的这个调用触发的：'
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `System.import` statement sets off the app bootstrapping process by loading
    the first module from `bootstrap.ts`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.import`语句通过从`bootstrap.ts`加载第一个模块来启动应用程序引导过程。'
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Modules defined in the context of Angular 2, (using `@NgModule` decorator) are
    different from modules SystemJS loads. SystemJS modules are JavaScript modules,
    which can be in different formats adhering to *CommonJS*, *AMD*, or *ES2015* specifications.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 2 的上下文中定义的模块（使用 `@NgModule` 装饰器）与 SystemJS 加载的模块是不同的。SystemJS 模块是
    JavaScript 模块，可以采用符合 *CommonJS*、*AMD* 或 *ES2015* 规范的不同格式。
- en: Angular modules are constructs used by Angular to segregate and organize its
    artifacts.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 模块是 Angular 用来分隔和组织其构件的构造。
- en: Unless the context of discussion is SystemJS, any reference to *module* implies
    *Angular module*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 除非讨论的上下文是 SystemJS，否则对 *模块* 的任何引用都意味着 *Angular 模块*。
- en: The next section details how SystemJS loads our Angular app. Remember all references
    to module in the next section are JavaScript module. If you want you can skip
    this section as it does not directly relate to Angular development.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分详细介绍了 SystemJS 如何加载我们的 Angular 应用程序。请记住，下一部分中对模块的所有引用都是 JavaScript 模块。如果你愿意，你可以跳过这一部分，因为它与
    Angular 开发没有直接关系。
- en: App loading with SystemJS
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SystemJS 加载应用程序
- en: SystemJS starts loading the JavaScript module with the call to `System.import('app')`
    in `index.html`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: SystemJS 通过在 `index.html` 中调用 `System.import('app')` 来开始加载 JavaScript 模块。
- en: SystemJS starts by loading `bootstrap.ts` first. The imports defined inside
    `bootstrap.ts` cause SystemJS to then load the imported modules. If these module
    imports have further `import` statements, SystemJS loads them too, recursively.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: SystemJS 首先加载 `bootstrap.ts`。在 `bootstrap.ts` 中定义的导入会导致 SystemJS 加载这些导入的模块。如果这些模块导入还有进一步的
    `import` 语句，SystemJS 也会递归加载它们。
- en: And finally the `platformBrowserDynamic().bootstrapModule(AppModule);` function
    gets executed once all the imported modules are loaded.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦所有导入的模块都加载完毕，`platformBrowserDynamic().bootstrapModule(AppModule);` 函数就会被执行。
- en: 'For the SystemJS `import` function to work, it needs to know where the modules
    are located. We define this in the file, `systemjs.config.js`, and reference it
    in `index.html`, before the `System.import` script:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: SystemJS `import` 函数需要知道模块的位置才能工作。我们在文件 `systemjs.config.js` 中定义这一点，并在 `index.html`
    中引用它，在 `System.import` 脚本之前：
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This configuration file contains all of the necessary configuration for SystemJS
    to work correctly.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置文件包含了 SystemJS 正确工作所需的所有配置。
- en: 'Open `systemjs.config.js`, the `app` parameter to `System.import` function
    points to a folder `dist` as defined on the `map` object:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `systemjs.config.js`，`System.import` 函数的 `app` 参数指向一个名为 `dist` 的文件夹，如 `map`
    对象中所定义的：
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And the next variable, `packages`, contains settings that hint to SystemJS
    how to load a module from a package when no filename/extension is specified. For
    `app`, the default module is `bootstrap.js`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的变量 `packages` 包含了一些设置，提示 SystemJS 在没有指定文件名/扩展名时如何加载一个包中的模块。对于 `app`，默认模块是
    `bootstrap.js`：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Are you wondering what the `dist` folder has to do with our application? Well,
    this is where our transpiled scripts end up. As we build our app in TypeScript,
    the TypeScript compiler converts these `.ts` script files in the `src` folder
    to JavaScript modules and deposits them into the `dist` folder. SystemJS then
    loads these compiled JavaScript modules. The transpiled code location has been
    configured as part of the build definition in `gulpfile.js`. Look for this excerpt
    in `gulpfile.ts`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否想知道 `dist` 文件夹与我们的应用程序有什么关系？嗯，这就是我们转译后的脚本所在的地方。因为我们的应用程序是用 TypeScript 构建的，TypeScript
    编译器将 `src` 文件夹中的 `.ts` 脚本文件转换为 JavaScript 模块，并将它们存放在 `dist` 文件夹中。然后 SystemJS 加载这些编译后的
    JavaScript 模块。转译后的代码位置已经作为构建定义的一部分在 `gulpfile.js` 中配置好了。在 `gulpfile.ts` 中找到这一节：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The module specification used by our app can again be verified in `gulpfile.js`.
    Take a look at this line:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序使用的模块规范可以在 `gulpfile.js` 中再次验证。看一下这一行：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These are TypeScript compiler options, with one being `module`, that is, the
    target module definition format.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是TypeScript编译器选项，其中一个是`module`，即目标模块定义格式。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `system` module type is a new module format designed to support the exact
    semantics of ES2015 modules within ES5.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`system`模块类型是一种新的模块格式，旨在支持ES5中ES2015模块的确切语义。'
- en: Once the scripts are *transpiled* and the module definitions created (in the
    target format), SystemJS can load these modules and their dependencies.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦脚本被*转译*并且模块定义被创建（以目标格式），SystemJS可以加载这些模块及其依赖项。
- en: It's time to get into the thick of action; let's build our first component.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候投入行动了；让我们构建我们的第一个组件。
- en: Our first component - WorkoutRunnerComponent
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个组件 - WorkoutRunnerComponent
- en: To implement the `WorkoutRunnerComponent`, we need to outline the behavior of
    the application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`WorkoutRunnerComponent`，我们需要概述应用程序的行为。
- en: 'What we are going to do in the `WorkoutRunnerComponent` implementation is as
    follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`WorkoutRunnerComponent`实现中要做的是：
- en: Start the workout.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始锻炼。
- en: Show the workout in progress and show the progress indicator.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示进行中的锻炼并显示进度指示器。
- en: After the time elapses for an exercise, show the next exercise.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在锻炼时间结束后，显示下一个锻炼。
- en: Repeat this process until all the exercises are over.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复此过程，直到所有锻炼结束。
- en: Let's start with the implementation. The first thing that we will create is
    the `WorkoutRunnerComponent` implementation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现开始。我们将首先创建`WorkoutRunnerComponent`的实现。
- en: 'Open the `workout-runner` folder in the `src/components` folder and add a new
    code file called `workout-runner.component.ts` to it. Add this chunk of code to
    the file:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/components`文件夹中打开`workout-runner`文件夹，并向其中添加一个名为`workout-runner.component.ts`的新代码文件。将以下代码块添加到文件中：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `import` module declaration allows us to reference the classes defined in
    the `model.ts` file in `WorkoutRunnerComponent`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`模块声明允许我们引用`model.ts`文件中定义的类在`WorkoutRunnerComponent`中。'
- en: 'We first need to set up the workout data. Let''s do that by adding a constructor
    and related class properties to the `WorkoutRunnerComponent` class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要设置锻炼数据。让我们通过向`WorkoutRunnerComponent`类添加构造函数和相关类属性来做到这一点：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `buildWorkout` on `WorkoutRunnerComponent` sets up the complete workout,
    as we will see shortly. We also initialize a `restExercise` variable to track
    even the rest periods as exercise (note that `restExercise` is an object of type
    `ExercisePlan`).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent`上的`buildWorkout`设置完整的锻炼计划，我们很快就会看到。我们还初始化了一个`restExercise`变量来跟踪休息期间的锻炼（注意`restExercise`是`ExercisePlan`类型的对象）。'
- en: 'The `buildWorkout` function is a lengthy function, so it''s better if we copy
    the implementation from the workout runner''s implementation available in Git
    branch checkpoint2.1 ([http://bit.ly/ng2be-2-1-workout-runner-component-ts](http://bit.ly/ng2be-2-1-workout-runner-component-ts)).
    The `buildWorkout` code looks like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildWorkout`函数是一个冗长的函数，所以最好是从Git分支checkpoint2.1（[http://bit.ly/ng2be-2-1-workout-runner-component-ts](http://bit.ly/ng2be-2-1-workout-runner-component-ts)）中的锻炼运行器的实现中复制实现。`buildWorkout`代码如下：'
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code builds the `WorkoutPlan` object and pushes the exercise data into
    the exercises array (an array of `ExercisePlan` objects), returning the newly
    built workout.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码构建了`WorkoutPlan`对象并将锻炼数据推送到锻炼数组中（一个`ExercisePlan`对象数组），返回新构建的锻炼计划。
- en: 'The initialization is complete; now, it''s time to actually implement the start
    workout. Add a `start` function to the `WorkoutRunnerComponent` implementation,
    as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化完成；现在是时候实际实现开始锻炼了。在`WorkoutRunnerComponent`实现中添加一个`start`函数，如下所示：
- en: '[PRE17]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then declare the new variables used in the function at the top, with other
    variable declarations:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在函数顶部声明新变量，与其他变量声明一起：
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `workoutTimeRemaining` variable tracks the total time remaining for the
    workout, and `currentExerciseIndex` tracks the currently executing exercise index.
    The call to `startExercise` actually starts an exercise. This is how the code
    for `startExercise` looks:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`workoutTimeRemaining`变量跟踪训练剩余的总时间，`currentExerciseIndex`跟踪当前执行的练习索引。调用`startExercise`实际上开始了一项练习。这是`startExercise`的代码：'
- en: '[PRE19]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We start by initializing `currentExercise` and `exerciseRunningDuration`. The
    `currentExercise` variable tracks the exercise in progress and `exerciseRunningDuration`
    tracks its duration. These two variables also need to be declared at the top:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先初始化`currentExercise`和`exerciseRunningDuration`。`currentExercise`变量跟踪正在进行的练习，`exerciseRunningDuration`跟踪其持续时间。这两个变量也需要在顶部声明：
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We use the `setInterval` JavaScript function with a delay of 1 second (1,000
    milliseconds) to track the exercise progress by incrementing `exerciseRunningDuration`.
    The `setInterval` invokes the callback every second. The `clearInterval` call
    stops the timer once the exercise duration lapses.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`setInterval` JavaScript函数，延迟1秒（1,000毫秒）来通过递增`exerciseRunningDuration`来跟踪练习进度。`setInterval`每秒调用一次回调函数。`clearInterval`调用在练习持续时间结束后停止计时器。
- en: Tip
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**TypeScript Arrow functions** The callback parameter passed to `setInterval`
    (`()=>{...}`) is a **lambda function** (or an **arrow function** in ES 2015).
    Lambda functions are short-form representations of anonymous functions, with added
    benefits. You can learn more about them at [https://basarat.gitbooks.io/typescript/content/docs/arrow-functions.html](https://basarat.gitbooks.io/typescript/content/docs/arrow-functions.html).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**TypeScript箭头函数**传递给`setInterval`的回调参数（`()=>{...}`）是一个**lambda函数**（或ES 2015中的**箭头函数**）。Lambda函数是匿名函数的简写形式，具有附加的好处。您可以在[https://basarat.gitbooks.io/typescript/content/docs/arrow-functions.html](https://basarat.gitbooks.io/typescript/content/docs/arrow-functions.html)了解更多信息。'
- en: As of now, we have a `WorkoutRunnerComponent` class. We need to convert it into
    an *Angular component* and define the component view. We did something similar
    in [Chapter 1](part0018.xhtml#H5A42-edca168d36254bda8a21f611a95615c3 "Chapter 1. Getting
    Started"), *Getting Started*, too.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个`WorkoutRunnerComponent`类。我们需要将其转换为*Angular组件*并定义组件视图。我们在[第1章](part0018.xhtml#H5A42-edca168d36254bda8a21f611a95615c3
    "第1章。入门")中也做过类似的事情，*入门*。
- en: 'Add the import for `Component` and a component decorator (highlighted code):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`Component`的导入和组件装饰器（高亮代码）：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There is not much to explain here, as you already know how to create an Angular
    component. You understand the role of the `@Component` decorator, what `selector`
    does, and how the `template` is used.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多需要解释的，因为您已经知道如何创建一个Angular组件。您了解`@Component`装饰器的作用，`selector`的作用，以及如何使用`template`。
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The JavaScript generated for the `@Component` decorator contains enough metadata
    about the component. This allows Angular framework to instantiate the correct
    component at runtime.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Component`装饰器生成的JavaScript包含有关组件的足够元数据。这使得Angular框架能够在运行时实例化正确的组件。'
- en: Strings enclosed in **backticks** (`` ``) are a new addition to ES2015\. Also
    called **template literals**, such string literals can be multiline and allow
    expressions to be embedded inside (not to be confused with Angular expressions).
    Look at the MDN article here at [http://bit.ly/template-literals](http://bit.ly/template-literals)
    for more details.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 用**反引号**（`` ``）括起来的字符串是ES2015的一个新添加。也称为**模板文字**，这样的字符串文字可以是多行的，并允许嵌入表达式（不要与Angular表达式混淆）。在这里查看MDN文章
    [http://bit.ly/template-literals](http://bit.ly/template-literals) 获取更多详情。
- en: 'The preceding template HTML will render the raw `ExercisePlan` object and the
    exercise time remaining. It has an interesting expression inside the first interpolation:
    `currentExercise | json`. The `currentExercise` property is defined in `WorkoutRunnerComponent`,
    but what about the `|` symbol and what follows it (`json`)? In the Angular 2 world,
    it is called a **pipe**. *The sole purpose of a pipe is to transform/format template
    data*. The `json` pipe here does JSON data formatting. You will learn more about
    pipes later in this chapter, but to get a general sense of what the `json` pipe
    does, we can remove the `json` pipe plus the `|` symbol and render the template;
    we are going to do this next.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的模板HTML将呈现原始的`ExercisePlan`对象和剩余的锻炼时间。在第一个插值内有一个有趣的表达式：`currentExercise |
    json`。`currentExercise`属性在`WorkoutRunnerComponent`中定义，但是`|`符号和其后的内容（`json`）呢？在Angular
    2世界中，它被称为**管道**。*管道的唯一目的是转换/格式化模板数据*。这里的`json`管道执行JSON数据格式化。在本章后面你会学到更多关于管道的知识，但是为了对`json`管道的作用有一个大致的了解，我们可以移除`json`管道和`|`符号并渲染模板；我们接下来要做这个。
- en: 'As we saw in [Chapter 1](part0018.xhtml#H5A42-edca168d36254bda8a21f611a95615c3
    "Chapter 1. Getting Started"), *Getting Started*, before we can use `WorkoutRunnerComponent`,
    we need to declare it inside a module. Since our app currently has only one module
    (`AppModule`), we add the `WorkoutRunnerComponent` declaration to it. Update `app.module.ts`
    by adding the highlighted code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](part0018.xhtml#H5A42-edca168d36254bda8a21f611a95615c3 "第1章. 入门")中看到的，*入门*，在我们可以使用`WorkoutRunnerComponent`之前，我们需要在一个模块中声明它。由于我们的应用目前只有一个模块（`AppModule`），我们将`WorkoutRunnerComponent`的声明添加到其中。通过添加下面突出显示的代码来更新`app.module.ts`：
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now `WorkoutRunnerComponent` can be referenced in the root component so that
    it can be rendered. Modify `src/components/app/app.component.ts` as highlighted
    in the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`WorkoutRunnerComponent`可以在根组件中引用，以便渲染它。按照下面的代码在`src/components/app/app.component.ts`中进行修改：
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have changed the root component template and added the `workout-runner` element
    to it. This will render the `WorkoutRunnerComponent` inside our root component.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经改变了根组件模板，并在其中添加了`workout-runner`元素。这将在我们的根组件中渲染`WorkoutRunnerComponent`。
- en: While the implementation may look complete, there is a crucial piece missing.
    Nowhere in the code do we actually start the workout. The workout should start
    as soon as we load the page.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然实现看起来很完整，但关键部分缺失了。在代码中我们实际上并没有开始锻炼。锻炼应该在我们加载页面时立即开始。
- en: '**Component life cycle hooks** are going to rescue us!'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件生命周期钩子**将拯救我们！'
- en: Component life cycle hooks
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件生命周期钩子
- en: 'The life of an Angular component is eventful. Components get created, change
    state during their lifetime, and finally they are destroyed. Angular provides
    some **life cycle hooks/functions** that the framework invokes (on the component)
    when such an event occurs. Consider these examples:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Angular组件的生命周期是充满事件的。组件被创建，它们在其生命周期中改变状态，最后被销毁。当这样的事件发生时，Angular提供了一些**生命周期钩子/函数**，框架会在组件上调用它们。考虑以下例子：
- en: When component is initialized, Angular invokes `ngOnInit`
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当组件初始化时，Angular会调用`ngOnInit`
- en: When a component's input properties change, Angular invokes `ngOnChanges`
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当组件的输入属性发生变化时，Angular会调用`ngOnChanges`
- en: When a component is destroyed, Angular invokes `ngOnDestroy`
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当组件被销毁时，Angular会调用`ngOnDestroy`
- en: As developers, we can tap into these key moments and perform some custom logic
    inside the respective component.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们可以利用这些关键时刻，在各自的组件内执行一些自定义逻辑。
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Angular has TypeScript interfaces for each of these hooks that can be applied
    to the component class to clearly communicate the intent. For example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Angular为每个这些钩子都有TypeScript接口，可以应用到组件类中，以清晰地传达意图。例如：
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The interface name can be derived by removing the prefix `ng` from the function
    names.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接口名称可以通过从函数名称中删除前缀`ng`来派生。
- en: The hook we are going to utilize here is `ngOnInit`. The `ngOnInit` function
    gets fired when the component's data-bound properties are initialized but before
    the view initialization starts.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要在这里使用的钩子是`ngOnInit`。`ngOnInit`函数在组件的数据绑定属性初始化后但视图初始化开始之前触发。
- en: 'Add the `ngOnInit` function to the `WorkoutRunnerComponent` class with a call
    to start the workout:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将`ngOnInit`函数添加到`WorkoutRunnerComponent`类中，并调用开始锻炼的方法：
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And implement the `OnInit` interface on `WorkoutRunnerComponent`; it defines
    the `ngOnInit` method:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 并在`WorkoutRunnerComponent`上实现`OnInit`接口；它定义了`ngOnInit`方法：
- en: '[PRE26]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are a number of other life cycle hooks, including `ngOnDestroy`, `ngOnChanges`,
    and `ngAfterViewInit`, that components support; but we are not going to dwell
    into any of them here. Look at the developer guide ([http://bit.ly/ng2-lifecycle](http://bit.ly/ng2-lifecycle))
    on *Life Cycle Hooks* to learn more about other such hooks.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他生命周期钩子，包括`ngOnDestroy`、`ngOnChanges`和`ngAfterViewInit`，组件都支持；但我们不会在这里深入讨论它们中的任何一个。查看开发者指南（[http://bit.ly/ng2-lifecycle](http://bit.ly/ng2-lifecycle)）上的*生命周期钩子*，了解更多关于其他钩子的信息。
- en: 'Time to run our app! Open the command line, navigate to the `trainer` folder,
    and type this line:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行我们的应用程序了！打开命令行，导航到`trainer`文件夹，并输入以下命令：
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If there are no compilation errors and the browser automatically loads the
    app (`http://localhost:9000/index.html`), we should see the following output:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有编译错误，并且浏览器自动加载应用程序（`http://localhost:9000/index.html`），我们应该看到以下输出：
- en: '![Component life cycle hooks](../Images/image00438.jpeg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![组件生命周期钩子](../Images/image00438.jpeg)'
- en: The model data updates with every passing second! Now you'll understand why
    interpolations (`{{ }}`) are a great debugging tool.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 模型数据每秒都在更新！现在你会明白为什么插值（`{{ }}`）是一个很好的调试工具。
- en: Note
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This will also be a good time to try rendering `currentExercise` without the
    `json` pipe (use `{{currentExercise}}`), and see what gets rendered.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在也是一个尝试渲染`currentExercise`而不使用`json`管道（使用`{{currentExercise}}`）的好时机，看看会渲染出什么。
- en: We are not done yet! Wait long enough on the `index.html` page and you will
    realize that the timer stops after 30 seconds. The app does not load the next
    exercise data. Time to fix it!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成！在`index.html`页面上等待足够长的时间，你会意识到计时器在30秒后停止。应用程序没有加载下一个锻炼数据。是时候修复它了！
- en: 'Update the code inside the `setInterval` `if` condition:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`setInterval`的`if`条件内的代码：
- en: '[PRE28]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `if` condition `if (this.exerciseRunningDuration >= this.currentExercise.duration)`
    is used to transition to the next exercise once the time duration of the current
    exercise lapses. We use `getNextExercise` to get the next exercise and call `startExercise`
    again to repeat the process. If no exercise is returned by the `getNextExercise`
    call, the workout is considered complete.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`条件`if (this.exerciseRunningDuration >= this.currentExercise.duration)`用于在当前锻炼的时间持续时间结束后过渡到下一个锻炼。我们使用`getNextExercise`来获取下一个锻炼，并再次调用`startExercise`来重复这个过程。如果`getNextExercise`调用没有返回任何锻炼，那么锻炼被视为完成。'
- en: During exercise transitioning, we increment `currentExerciseIndex` only if the
    next exercise is not a rest exercise. Remember that the original workout plan
    does not have a rest exercise. For the sake of consistency, we have created a
    rest exercise and are now swapping between rest and the standard exercises that
    are part of the workout plan. Therefore, `currentExerciseIndex` does not change
    when the next exercise is rest.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行锻炼过渡期间，只有在下一个锻炼不是休息锻炼时，我们才会增加`currentExerciseIndex`。请记住，原始的锻炼计划中没有休息锻炼。为了保持一致，我们创建了一个休息锻炼，并且现在在休息和锻炼计划中的标准锻炼之间进行切换。因此，当下一个锻炼是休息时，`currentExerciseIndex`不会改变。
- en: 'Let''s quickly add the `getNextExercise` function too. Add the function to
    the `WorkoutRunnerComponent` class:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速添加 `getNextExercise` 函数。将该函数添加到 `WorkoutRunnerComponent` 类中：
- en: '[PRE29]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `WorkoutRunnerComponent.getNextExercise` returns the next exercise that
    needs to be performed.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent.getNextExercise` 返回需要执行的下一个练习。'
- en: Note
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the returned object for `getNextExercise` is an `ExercisePlan` object
    that internally contains the exercise details and the duration for which the exercise
    runs.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`getNextExercise` 返回的对象是一个 `ExercisePlan` 对象，其中包含了练习的细节和练习运行的持续时间。
- en: The implementation is quite self-explanatory. If the current exercise is rest,
    take the next exercise from the `workoutPlan.exercises` array (based on `currentExerciseIndex`);
    otherwise, the next exercise is rest, given that we are not on the last exercise
    (the `else if` condition check).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相当不言自明。如果当前练习是休息，从 `workoutPlan.exercises` 数组中获取下一个练习（基于 `currentExerciseIndex`）；否则，下一个练习是休息，前提是我们不在最后一个练习上（`else
    if` 条件检查）。
- en: With this, we are ready to test our implementation. So go ahead and refresh
    `index.html`. Exercises should flip after every 10 or 30 seconds. Great!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经准备好测试我们的实现了。所以继续刷新 `index.html`。每隔 10 或 30 秒后，练习应该会翻转。太棒了！
- en: Note
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The current build setup automatically compiles any changes made to the script
    files when the files are saved; it also refreshes the browser post these changes.
    But just in case the UI does not update or things do not work as expected, refresh
    the browser window.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的构建设置会在保存文件时自动编译对脚本文件所做的任何更改；它还会在这些更改后刷新浏览器。但是，如果 UI 没有更新或事情不如预期地工作，刷新浏览器窗口。
- en: If you are having a problem with running the code, look at the Git branch `checkpoint2.1`
    for a working version of what we have done thus far.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在运行代码时遇到问题，请查看 Git 分支 `checkpoint2.1`，以获取到目前为止我们所做的工作的可工作版本。
- en: Or if you are not using Git, download the snapshot of Checkpoint 2.1 (a ZIP file)
    from [http://bit.ly/ng2be-checkpoint2-1](http://bit.ly/ng2be-checkpoint2-1). Refer
    to the `README.md` file in the `trainer` folder when setting up the snapshot for
    the first time.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您不使用 Git，请从 [http://bit.ly/ng2be-checkpoint2-1](http://bit.ly/ng2be-checkpoint2-1)
    下载 Checkpoint 2.1 的快照（ZIP 文件）。在首次设置快照时，请参考 `trainer` 文件夹中的 `README.md` 文件。
- en: We have done enough work on the controller for now, let's build the view.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在控制器上做了足够的工作，现在让我们构建视图。
- en: Building the 7 Minute Workout view
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 7 分钟锻炼视图
- en: Most of the hard work has already been done while defining the model and implementing
    the component. Now we just need to skin the HTML using the super-awesome data
    binding capabilities of Angular. It's going to be simple, sweet, and elegant!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义模型和实现组件时，大部分工作已经完成。现在我们只需要使用 Angular 的超级数据绑定功能来设计 HTML。这将会简单、甜美且优雅！
- en: 'For the *7 Minute Workout* view, we need to show the exercise name, the exercise
    image, a progress indicator, and the time remaining. Copy the `workout-runner.html`
    file from the Git branch `checkpoint2.2`, the `workout-runner` folder (or download
    it from [http://bit.ly/ng2be-2-2-workout-runner-html](http://bit.ly/ng2be-2-2-workout-runner-html)),
    to the corresponding folder locally. The view HTML looks like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *7 分钟锻炼* 视图，我们需要显示练习名称、练习图片、进度指示器和剩余时间。从 Git 分支 `checkpoint2.2` 的 `workout-runner`
    文件夹中复制 `workout-runner.html` 文件（或从 [http://bit.ly/ng2be-2-2-workout-runner-html](http://bit.ly/ng2be-2-2-workout-runner-html)
    下载），并将其保存到本地相应的文件夹中。视图 HTML 如下所示：
- en: '[PRE30]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Before we take a deep dive into the view HTML, we still need to reference the
    view. The `WorkoutRunnerComponent` currently uses an inline template. We need
    to externalize it by pointing to the above HTML file. Update the `workout-runner.component.ts`
    file by replacing the `template` property with property `templateUrl`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究视图HTML之前，我们仍然需要引用视图。`WorkoutRunnerComponent`目前使用内联模板。我们需要通过指向上述HTML文件来将其外部化。通过用`templateUrl`属性替换`template`属性来更新`workout-runner.component.ts`文件：
- en: '[PRE31]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The decorator property, `templateUrl`, allows us to reference an external file
    for the view HTML.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器属性`templateUrl`允许我们引用视图HTML的外部文件。
- en: Tip
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Inline versus External templates**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**内联与外部模板**'
- en: 'We just saw two ways of defining a view template: using `template` (inline)
    and using the `templateUrl` (external) property. Which one is preferred?'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了定义视图模板的两种方式：使用`template`（内联）和使用`templateUrl`（外部）属性。哪种更受青睐？
- en: Well, considering the way in which components are envisioned in Angular2, as
    self-contained building blocks, for our app, inline templating makes sense. Everything
    that is required by the component is available in a single file. However, inline
    templates have a disadvantage; formatting HTML becomes difficult and IDE support
    is very limited as the content is treated as a string literal. When we externalize
    HTML, we can develop a template as a normal HTML document.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，考虑到在Angular2中构想组件的方式，作为独立的构建模块，对于我们的应用程序来说，内联模板是有意义的。组件所需的一切都在单个文件中。然而，内联模板有一个缺点；格式化HTML变得困难，IDE支持非常有限，因为内容被视为字符串文字。当我们将HTML外部化时，我们可以像开发普通HTML文档一样开发模板。
- en: One possible solution that allows us to have the best of both worlds would be
    to define our HTML templates in separate files during development and reference
    them using the standard `templateUrl` property. But as part of a production release,
    configure the build process to inline the template HTML into the component definition.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 允许我们同时拥有最佳解决方案的一种可能的解决方案是在开发过程中将HTML模板定义为单独的文件，并使用标准的`templateUrl`属性引用它们。但作为生产发布的一部分，配置构建过程以将模板HTML内联到组件定义中。
- en: Before we understand the Angular pieces in the view, let's just run the app
    again. Save the changes in `workout-runner.component.ts`. If `gulp play` is already
    running, just refresh the page and see the workout app in its full glory!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解视图中的Angular部分之前，让我们再次运行应用程序。保存`workout-runner.component.ts`中的更改。如果`gulp
    play`已经在运行，请刷新页面，看到完整的锻炼应用程序！
- en: '![Building the 7 Minute Workout view](../Images/image00439.jpeg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![构建7分钟锻炼视图](../Images/image00439.jpeg)'
- en: We have our basic app running. The exercise image and title show up, the progress
    indicator shows the progress, and exercise transitioning occurs when the exercise
    time lapses. This surely feels great!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本应用程序正在运行。锻炼图片和标题显示出来，进度指示器显示进度，并且当锻炼时间结束时进行锻炼过渡。这确实感觉很棒！
- en: Note
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are having a problem with running the code, look at the Git branch `checkpoint2.2`
    for a working version of what we have done thus far. You can also download the
    snapshot of `checkpoint2.2` (a zip file) from this GitHub location: [http://bit.ly/ng2be-checkpoint2-2](http://bit.ly/ng2be-checkpoint2-2).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在运行代码时遇到问题，请查看Git分支`checkpoint2.2`，以获取到目前为止我们所做的工作的可运行版本。您还可以从GitHub位置下载`checkpoint2.2`的快照（zip文件）：[http://bit.ly/ng2be-checkpoint2-2](http://bit.ly/ng2be-checkpoint2-2)。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: If we look back at the view HTML, we see that other than the styling done using
    *bootstrap* CSS and some custom CSS, there are some interesting Angular pieces
    that need our attention. Also, since everything ties into the Angular binding
    infrastructure, it's time to dig deeper into this infrastructure and explore its
    capabilities.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下视图HTML，除了使用*bootstrap* CSS和一些自定义CSS进行样式设置之外，还有一些有趣的Angular片段需要我们的注意。而且，由于一切都与Angular绑定基础设施相关，现在是时候深入了解这个基础设施并探索其能力了。
- en: The Angular 2 binding infrastructure
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 2绑定基础设施
- en: Any modern JavaScript framework comes with strong model-view binding support,
    and Angular is no different. The primary aim of any binding infrastructure is
    to reduce the boilerplate code that we need to write to keep the view and the
    model in sync. A robust binding infrastructure is always declarative and terse.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 任何现代JavaScript框架都具有强大的模型-视图绑定支持，Angular也不例外。任何绑定基础设施的主要目标都是减少我们需要编写的样板代码，以保持视图和模型的同步。强大的绑定基础设施总是声明性和简洁的。
- en: 'The Angular binding infrastructure allows us to transform a template (raw)
    HTML into a live view that is bound to model data. Based on the binding constructs
    used, data can flow and be synced in both directions: from model to view and view
    to model.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Angular绑定基础设施允许我们将模板（原始）HTML转换为绑定到模型数据的实时视图。根据使用的绑定构造，数据可以在两个方向上流动并同步：从模型到视图和从视图到模型。
- en: Angular established a link between the model data on the component and the view
    using the `template` or `templateUrl` property of the `@Component` decorator.
    With the exception of the `script` tag, almost any piece of HTML can act as a
    template for the Angular binding infrastructure.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Angular使用`@Component`装饰器的`template`或`templateUrl`属性在组件和视图之间建立了模型数据的链接。除了`script`标签之外，几乎任何HTML片段都可以作为Angular绑定基础设施的模板。
- en: To make this binding magic work, Angular needs to take the view template, compile
    it, link it to the model data, and keep it in sync with model updates without
    the need for any boilerplate synchronization code.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这种绑定魔法生效，Angular需要获取视图模板，编译它，将其链接到模型数据，并在不需要任何样板同步代码的情况下保持与模型更新的同步。
- en: 'Based on the data flow direction, these bindings can be of three categories:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数据流方向，这些绑定可以分为三类：
- en: '*One-way binding from model to view*: In model-to-view binding, changes to
    model are kept in sync with the view. Interpolations, property, attribute, class,
    and style bindings fall in this category.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从模型到视图的单向绑定*：在模型到视图绑定中，对模型的更改与视图保持同步。插值、属性、属性、类和样式绑定属于这一类别。'
- en: '*One-way binding from view to model*: In this category, view changes flow towards
    the model. Event bindings fall in this category.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从视图到模型的单向绑定*：在这个类别中，视图更改流向模型。事件绑定属于这一类别。'
- en: '*Two-way/bidirectional binding*: Two-way binding, as the name suggests, keeps
    the view and model in sync. There is a special binding construct used for two-way
    binding, `ngModel`.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*双向绑定*：双向绑定，顾名思义，保持视图和模型同步。有一个专门用于双向绑定的特殊绑定构造，`ngModel`。'
- en: 'Let''s understand how to utilize the binding capabilities of Angular to support
    view templatization. Angular provides these binding constructs:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解如何利用Angular的绑定能力来支持视图模板化。Angular提供了这些绑定构造：
- en: Interpolations
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插值
- en: Property binding
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性绑定
- en: Attribute binding
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性绑定
- en: Class binding
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类绑定
- en: Style binding
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式绑定
- en: Event binding
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件绑定
- en: The *7 Minute Workout* view uses some of these constructs, so this is a good
    time to learn about them. **Interpolation** is the first one.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*7分钟锻炼*视图使用了一些这些构造，所以现在是学习它们的好时机。**插值**是第一个。'
- en: Interpolations
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插值
- en: '**Interpolations** are quite simple. The expression inside the interpolation
    symbols (`{{ }}`) is evaluated in the context of the model (or the component class
    members), and the outcome of the evaluation is embedded in HTML. We have seen
    these all along in [Chapter 1](part0018.xhtml#H5A42-edca168d36254bda8a21f611a95615c3
    "Chapter 1. Getting Started"), *Getting Started*, and in the workout runner view.
    We render the exercise title and the exercise time remaining using interpolation:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 插值很简单。插值符号（`{{ }}`）中的表达式在模型的上下文中进行评估，评估的结果嵌入到HTML中。我们在[第1章](part0018.xhtml#H5A42-edca168d36254bda8a21f611a95615c3
    "第1章。入门") *入门* 和训练运行器视图中一直看到这些。我们使用插值来呈现练习标题和剩余练习时间：
- en: '[PRE32]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Remember that interpolations synchronize model changes with the view. This is
    one way of binding from a model to a view.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，插值会同步模型的变化与视图。这是从模型到视图的一种绑定方式。
- en: Interpolations in fact are a special case of property binding, which allows
    us to bind HTML element/custom component properties to a model. We shortly discuss
    how an interpolation can be written using property binding syntax. We can consider
    interpolation as syntactical sugar over property binding.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，插值是属性绑定的一种特殊情况，它允许我们将HTML元素/自定义组件的属性绑定到模型上。我们很快讨论一下如何使用属性绑定语法编写插值。我们可以将插值视为属性绑定的语法糖。
- en: Property binding
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性绑定
- en: 'Look at this view excerpt:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这个视图摘录：
- en: '[PRE33]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It seems that we are setting the `src` attribute of `img` to an expression that
    gets evaluated at runtime when the app runs. Not true!
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们正在将`img`的`src`属性设置为在应用运行时评估的表达式。这是不正确的！
- en: What seems to be an **attribute binding** is, in fact, a **property binding**.
    Moreover, since many of us are not aware of the difference between an HTML element's
    *property* and its *attribute*, this statement is very confusing. Therefore, before
    we look at how property bindings work, let's try to grasp the difference between
    an element's *property* and its *attribute*.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来是**属性绑定**的东西，实际上是**属性绑定**。而且，由于我们许多人不了解HTML元素的*属性*和*属性*之间的区别，这个说法非常令人困惑。因此，在我们看属性绑定如何工作之前，让我们试着理解一下元素的*属性*和*属性*之间的区别。
- en: Property versus attribute
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性与属性的区别
- en: 'Take any DOM element API and you will find *attributes*, *properties*, *functions*,
    and *events*. While events and functions are self-explanatory, it is difficult
    to understand the difference between *properties* and *attributes*. We use these
    words interchangeably, which does not help much either. Take, for example, this
    line of code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 拿任何DOM元素API，你会发现*属性*、*属性*、*函数*和*事件*。虽然事件和函数是不言自明的，但很难理解*属性*和*属性*之间的区别。我们通常可以互换使用这些词，这也没有太大帮助。例如，这行代码：
- en: '[PRE34]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When the browser creates a DOM element (`HTMLInputElement` to be precise) for
    this input textbox, it uses the `value` attribute on `input` to set the initial
    state of the `input`'s `value` property to `Awesome Angular2`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器为这个输入文本框创建DOM元素（确切地说是`HTMLInputElement`）时，它使用`input`上的`value`属性来设置`input`的`value`属性的初始状态为`Awesome
    Angular2`。
- en: Post this initialization, any changes to `input ` `value` property do not reflect
    on the `value` attribute; the attribute always has `Awesome Angular2` (unless
    set explicitly again). This can be confirmed by querying the `input` state.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化之后，对`input`的`value`属性的任何更改都不会反映在`value`属性上；该属性始终为`Awesome Angular2`（除非再次明确设置）。这可以通过查询`input`状态来确认。
- en: 'Suppose we change the `input` data to `Angular2 rocks!` and query the `input`
    element state:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将`input`数据更改为`Angular2 rocks!`并查询`input`元素状态：
- en: '[PRE35]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `value` property always returns the current input content, which is `"Angular2
    rocks!"`. Whereas this DOM API function:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`value`属性始终返回当前的输入内容，即`"Angular2 rocks!"`。而这个DOM API函数：'
- en: '[PRE36]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Returns the `value` attribute, and is always `Awesome Angular2` set initially.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`value`属性，并且最初始终设置为`Awesome Angular2`。
- en: The primary role of an element attribute is to initialize the state of the element
    when the corresponding DOM object is created.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 元素属性的主要作用是在创建相应的DOM对象时初始化元素的状态。
- en: 'There are a number of other nuances that add to this confusion. These include
    the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他细微差别增加了这种混淆。这些包括以下内容：
- en: '*Attribute* and *property* synchronization is not consistent across properties.
    As we saw in the preceding example, changes to the `value` *property* on `input`
    do not affect the `value` *attribute*, but this is not true for all property-value
    pairs. The `src` property of an image element is a prime example of this; changes
    to property or attribute value are always kept in sync.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*属性*和*属性*的同步在不同属性之间不一致。正如我们在前面的例子中看到的，对`input`上的`value` *属性*的更改不会影响`value`
    *属性*，但对于所有属性-值对来说并非如此。图像元素的`src`属性就是一个很好的例子；属性或属性值的更改始终保持同步。'
- en: It's surprising to learn that the mapping between attributes and properties
    is also not one-to-one. There are a number of properties that do not have any
    backing attribute (such as `innerHTML`), and there are also attributes that do
    not have a corresponding property defined on the DOM (such as `colspan`).
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令人惊讶的是，属性和属性之间的映射也不是一对一的。有许多属性没有任何支持属性（例如`innerHTML`），也有一些属性在DOM上没有相应的属性定义（例如`colspan`）。
- en: 'Attribute and property mapping too adds to this confusion as it does not follow
    a consistent pattern. An excellent example of this is available in the Angular
    2 developer''s guide, which we are going to reproduce here verbatim:'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性和属性映射也增加了这种混淆，因为它没有遵循一致的模式。Angular 2开发者指南中有一个很好的例子，我们将在这里逐字复制：
- en: '*The `disabled` attribute is another peculiar example. A button''s `disabled`
    property is `false` by default so the button is enabled. When we add the disabled
    attribute, its presence alone initializes the button''s `disabled` property to
    true so the button is disabled. Adding and removing the disabled attribute disables
    and enables the button. The value of the attribute is irrelevant which is why
    we cannot enable a button by writing `<button disabled="false">Still Disabled</button>`.*'
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*`disabled`属性是另一个特殊的例子。按钮的`disabled`属性默认为`false`，因此按钮是启用的。当我们添加disabled属性时，仅其存在就会将按钮的`disabled`属性初始化为true，因此按钮被禁用。添加和删除disabled属性会禁用和启用按钮。属性的值是无关紧要的，这就是为什么我们不能通过编写`<button
    disabled="false">Still Disabled</button>`来启用按钮。*'
- en: The aim of this discussion is to make sure that you understand the difference
    between the properties and attributes of a DOM element. This new mental model
    will help you as we continue to explore the framework's property and attribute
    binding capabilities. Let's get back to our discussion on property binding.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 本次讨论的目的是确保您了解DOM元素的属性和属性之间的区别。这种新的思维模式将在我们继续探索框架的属性和属性绑定能力时帮助您。让我们回到我们对属性绑定的讨论。
- en: Property binding continued...
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性绑定继续...
- en: 'Now that we understand the difference between a property and an attribute,
    let''s look at the binding example again:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们了解了属性和属性之间的区别，让我们再次看一下绑定的例子：
- en: '[PRE37]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `[propertName]` square bracket syntax is used to bind the `img.src` property
    to an Angular expression.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`[propertName]`方括号语法用于将`img.src`属性绑定到Angular表达式。'
- en: 'The general syntax for property binding looks like this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定的一般语法如下：
- en: '[PRE38]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the case of property binding, the **target** is a property on the DOM element
    or component. The target can also be an event, as we will see shortly when we
    perform event binding.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性绑定的情况下，**目标**是DOM元素或组件上的属性。目标也可以是事件，我们将很快看到当我们执行事件绑定时。
- en: Binding source and target
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定源和目标
- en: Tip
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is important to understand the difference between source and target in an
    Angular binding.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Angular绑定中源和目标之间的区别很重要。
- en: The property appearing inside [] is a **target**, sometimes called **binding
    target**. The target is the consumer of the data and always refers to a property
    on the component/element. The **source** expression constitutes the data source
    that provides data to the target.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 出现在[]内的属性是**目标**，有时被称为**绑定目标**。目标是数据的消费者，始终指的是组件/元素上的属性。**源**表达式构成了提供数据给目标的数据源。
- en: At runtime, the expression is evaluated in the context of the component's/element's
    property (the `WorkoutRunnerComponent.currentExercise.exercise.image` property
    in the preceding case).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，表达式在组件/元素属性的上下文中进行评估（在前面的例子中是`WorkoutRunnerComponent.currentExercise.exercise.image`属性）。
- en: Tip
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Property binding, event binding, and attribute binding do not use the interpolation
    symbol. The following is invalid: `[src]="{{''/static/images/'' + currentExercise.exercise.image}}"`
    If you have worked on Angular 1, property binding to any DOM property allows Angular
    2 to get rid of a number of directives, such as `ng-disable`, `ng-src`, `ng-key*`,
    `ng-mouse*`, and a few others.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定、事件绑定和属性绑定不使用插值符号。以下是无效的：`[src]="{{'/static/images/' + currentExercise.exercise.image}}"`
    如果您曾经使用过Angular 1，将属性绑定到任何DOM属性允许Angular 2摆脱许多指令，如`ng-disable`、`ng-src`、`ng-key*`、`ng-mouse*`等。
- en: 'Property binding works on component properties too! Components can define input
    and output properties that can be bound to the view, such as this:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定也适用于组件属性！组件可以定义输入和输出属性，这些属性可以绑定到视图，例如：
- en: '[PRE39]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This hypothetical snippet binds the `exerciseRestDuration` property on the `WorkoutRunnerComponent`
    class to the `restDuration` property defined on the container component (parent),
    allowing us to pass the rest duration as a parameter to the `WorkoutRunnerComponent`.
    As we enhance our app and develop new components, you will learn how to define
    custom properties and events on a component.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这个假设的片段将`WorkoutRunnerComponent`类上的`exerciseRestDuration`属性绑定到容器组件（父级）上定义的`restDuration`属性，允许我们将休息时间作为参数传递给`WorkoutRunnerComponent`。随着我们增强应用程序并开发新组件，您将学习如何在组件上定义自定义属性和事件。
- en: Note
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We can enable property binding using the `bind-` syntax, which is a *canonical
    form* of property binding. This implies that: `[src]="''/static/images/'' + currentExercise.exercise.image"`
    Is equivalent to the following: `bind-src="''/static/images/'' + currentExercise.exercise.image"`'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`bind-`语法启用属性绑定，这是属性绑定的*规范形式*。这意味着：`[src]="'/static/images/' + currentExercise.exercise.image"`
    等同于以下内容：`bind-src="'/static/images/' + currentExercise.exercise.image"`
- en: Property binding, like interpolation, is unidirectional, from the component/element
    source to the view. Changes to the model data are kept in sync with the view.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定，就像插值一样，是单向的，从组件/元素源到视图。对模型数据的更改与视图保持同步。
- en: Note
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When we concluded the last section by describing interpolation as syntactical
    sugar over property binding, the intent was to highlight how both can be used
    interchangeably.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过描述插值为属性绑定的语法糖来结束上一节时，意图是强调两者如何可以互换使用。
- en: 'The interpolation syntax is terser than property binding and hence very useful.
    This is how Angular interprets an interpolation: `<h3>Main heading - {{heading}}</h3>`
    `<h3 [text-content]="'' Main heading - ''+heading"></h3>` Angular translates the
    interpolation in the first statement into the `textContent` property binding (second
    statement).'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 插值语法比属性绑定更简洁，因此非常有用。这是Angular解释插值的方式：`<h3>主标题 - {{heading}}</h3>` `<h3 [text-content]="'
    主标题 - '+heading"></h3>` Angular将第一个语句中的插值转换为`textContent`属性绑定（第二个语句）。
- en: While property binding makes it easy for us to bind any expression to the target
    property, we should be careful with the expression we employ. This is also because
    of the fact that Angular's change detection system will evaluate your expression
    binding multiple times during the life cycle of the application, while your component
    is alive. Therefore, while binding an expression to a property target, keep these
    two guidelines in mind.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然属性绑定使我们能够将任何表达式绑定到目标属性，但我们在使用表达式时应该小心。这也是因为Angular的变更检测系统会在应用程序的生命周期中多次评估您的表达式绑定，而组件是活动的。因此，在将表达式绑定到属性目标时，请牢记这两个准则。
- en: Quick expression evaluation
  id: totrans-326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 快速表达式评估
- en: 'A property binding expression should evaluate quickly. Slow evaluation can
    happen when a function is used as an expression. Consider this binding:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定表达式应该快速评估。当函数被用作表达式时，评估速度会变慢。考虑这个绑定：
- en: '[PRE40]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This interpolation binds the return value of `doLotsOfWork` to the `div`. This
    function then gets called every time Angular performs a change detection run,
    which Angular does quite often based on some internal heuristics. Hence it becomes
    imperative that the expressions we use evaluate quickly.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这种插值将`doLotsOfWork`的返回值绑定到`div`上。这个函数在每次Angular执行变更检测运行时都会被调用，根据一些内部启发式算法，Angular会经常执行变更检测。因此，我们使用的表达式必须快速评估。
- en: Side-effect-free binding expressions
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无副作用的绑定表达式
- en: 'If a function is used in a binding expression, it should be side-effect-free.
    Consider yet another binding:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数在绑定表达式中使用，它应该是无副作用的。再考虑另一个绑定：
- en: '[PRE41]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And the underlying function, `getContent`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 而底层函数`getContent`：
- en: '[PRE42]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `getContent` call changes the state of the component by updating the `timesContentRequested`
    property every time it is called. If this property is used in view such as:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`getContent`调用通过更新`timesContentRequested`属性来改变组件的状态，每次调用时都会更新。如果这个属性在视图中被使用，比如：'
- en: '[PRE43]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Angular throws errors such as:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Angular会抛出诸如：
- en: '[PRE44]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Angular framework works in two modes, *dev* and *production*. If we enable production
    mode in the application, the preceding error does not show up.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Angular框架有两种模式，*开发*和*生产*。如果我们在应用程序中启用生产模式，上述错误就不会出现。
- en: Look at the framework documentation at http://bit.ly/enableProdMode for more
    details.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 查看http://bit.ly/enableProdMode的框架文档以获取更多详细信息。
- en: The bottom line is that your expression used inside property binding should
    be side-effect-free.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 底线是，在属性绑定中使用的表达式应该是无副作用的。
- en: Let's now look at some interesting behavior related to the square bracket syntax
    used for property binding. The target specified in `[]` is not limited to a component/element
    property. To understand *target selection*, we need to introduce a new concept: **directives**.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一些与用于属性绑定的方括号语法相关的有趣行为。`[]`中指定的目标不仅限于组件/元素属性。要理解*目标选择*，我们需要介绍一个新概念：**指令**。
- en: Angular directives
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Angular指令
- en: As a framework, Angular tries to enhance the HTML **DSL** (short for **Domain-Specific
    Language**).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个框架，Angular试图增强HTML **DSL**（**特定领域语言**的缩写）。
- en: '*Components* are referenced in HTML using custom tags such as `<workout-runner></workout-runner>`
    (not part of standard HTML constructs). This highlights the first extension point.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '*组件*在HTML中使用自定义标签引用，例如`<workout-runner></workout-runner>`（不是标准HTML构造的一部分）。这突显了第一个扩展点。'
- en: The use of `[]` and `()` for property and event binding defines the second.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`[]`和`()`进行属性和事件绑定定义了第二个。
- en: And then there is the third one, called **attribute directives**.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 然后还有第三种，称为**属性指令**。
- en: 'While components come with their own view, attribute directives are there to
    enhance the appearance and/or behavior of existing elements/components. The `ngStyle`
    directive used in workout-runner''s view is a good example of an attribute directive:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然组件有自己的视图，但属性指令是用来增强现有元素/组件的外观和/或行为。在workout-runner的视图中使用的`ngStyle`指令就是一个很好的例子：
- en: '[PRE45]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `ngStyle` directive does not have its own view; instead it allows us to
    set multiple styles on an HTML element using binding expressions. We will be covering
    a number of framework attribute directives later in this book.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngStyle`指令没有自己的视图；相反，它允许我们使用绑定表达式在HTML元素上设置多个样式。我们将在本书的后面涵盖许多框架属性指令。'
- en: There is also another class of directives, called **structural directives**.
    Again, structural directives do not have their own view; they change the DOM layout
    of the elements on which they are applied. The `ngFor` and `ngIf` directives fall
    into this category. We dedicate a complete section later in the chapter to understanding
    these structural directives.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一类指令，称为**结构指令**。同样，结构指令没有自己的视图；它们改变应用它们的元素的DOM布局。`ngFor`和`ngIf`指令属于这一类。我们在本章后面专门介绍了解这些结构指令的完整部分。
- en: Tip
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Directive nomenclature**'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**指令命名法**'
- en: '"Directives" is an umbrella term used for component directives (also known
    as components), attribute directives, and structural directives. Throughout the
    book, when we use the term "directive," we will be referring to either an attribute
    directive or a structural directive depending on the context. Component directives
    are always referred to as *components*.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '"指令"是一个用于组件指令（也称为组件）、属性指令和结构指令的总称。在本书中，当我们使用术语"指令"时，我们将根据上下文指的是属性指令或结构指令。组件指令总是被称为*组件*。'
- en: With this understanding of the different types of directives that Angular has,
    we can comprehend the process of target selection for binding.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对Angular具有不同类型指令的理解，我们可以理解绑定的目标选择过程。
- en: Target selection for binding
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定的目标选择
- en: 'As described earlier, the target specified in `[]` is not limited to a component/element
    property. While the property name is a common target, the Angular templating engine
    actually does a heuristics to decide the target type. Angular first searches the
    registered known directives (*attribute* or *structural*) that have matching selectors
    before looking for a property that matches the target expression. Consider this
    view fragment:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在`[]`中指定的目标不仅限于组件/元素属性。虽然属性名是一个常见的目标，但Angular模板引擎实际上会进行启发式来决定目标类型。在寻找与目标表达式匹配的已注册已知指令（*属性*或*结构*）之前，Angular首先搜索具有匹配选择器的已知指令，然后再寻找与目标表达式匹配的属性。考虑这个视图片段：
- en: '[PRE46]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The search starts for a directive having selector `ngStyle` first. Since Angular
    already has an `ngStyle` directive, it becomes the target. If Angular did not
    have a built-in `ngStyle` directive, the binding engine would have looked for
    a property called `ngStyle` on the underlying component.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 首先搜索具有选择器`ngStyle`的指令。由于Angular已经有了`ngStyle`指令，它成为了目标。如果Angular没有内置的`ngStyle`指令，绑定引擎将会在底层组件上寻找一个名为`ngStyle`的属性。
- en: If the nothing matches the target expression, an *unknown directive* error is
    thrown.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有匹配目标表达式，就会抛出*未知指令*错误。
- en: That covers most of Angular's property binding capabilities. Next, let's look
    at attribute binding and understand what role it plays.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了大部分Angular的属性绑定能力。接下来，让我们看看属性绑定，并理解它的作用。
- en: Attribute binding
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性绑定
- en: The only reason attribute binding exists in Angular is that there are HTML attributes
    that do not have a backing DOM property. The `colspan` and `aria` attributes are
    some good examples of attributes without backing properties. The progress bar
    div in our view uses attribute binding.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: Angular中存在属性绑定的唯一原因是有一些HTML属性没有对应的DOM属性。`colspan`和`aria`属性就是一些没有对应属性的很好的例子。我们视图中的进度条div使用了属性绑定。
- en: 'It may seem that we can use standard interpolation syntax to set an attribute,
    but that does not work! Open `workout-runner.html` and replace the two aria attributes
    `attr.aria-valuenow` and `attr.aria-valuemax` enclosed in [], with this highlighted
    code:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们可以使用标准的插值语法来设置属性，但那是行不通的！打开`workout-runner.html`，用这个高亮代码替换两个包含在[]中的aria属性`attr.aria-valuenow`和`attr.aria-valuemax`：
- en: '[PRE47]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Save and refresh the page. Then, Angular will throw an interesting error:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并刷新页面。然后，Angular将抛出一个有趣的错误：
- en: '[PRE48]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Angular is trying to search for a property called `ariaValuenow` in the `div`
    that does not exist! Remember, interpolations are actually property binding.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Angular试图在不存在的`div`中搜索一个名为`ariaValuenow`的属性！记住，插值实际上是属性绑定。
- en: 'We hope that this gets the point across: *to bind to an attribute, use attribute
    binding*.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 希望能传达这一点：*要绑定属性，请使用属性绑定*。
- en: Tip
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Angular binds to properties by default and not to attributes.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: Angular默认绑定到属性而不是属性。
- en: 'To support attribute binding, Angular uses a prefix notation, `attr`, within
    `[]`. An attribute binding looks like this:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持属性绑定，Angular在`[]`内使用前缀表示法`attr`。属性绑定看起来像这样：
- en: '[PRE49]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Revert to the original aria setup to make attribute binding work:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复到原始的aria设置以使属性绑定起作用：
- en: '[PRE50]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Tip
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that unless an explicit `attr.` prefix is attached, attribute binding
    does not work.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，除非附加了显式的`attr.`前缀，否则属性绑定不起作用。
- en: While we have not used style- and class-based binding in our workout view, these
    are some binding capabilities that can come in handy. Hence, they are worth exploring.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在锻炼视图中没有使用样式和类绑定，但这些是一些有用的绑定能力。因此，值得探索。
- en: Style and class binding
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样式和类绑定
- en: 'We use **class binding** to set and remove a specific class based on the component
    state, as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**类绑定**根据组件状态设置和移除特定类，如下所示：
- en: '[PRE51]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This adds `class-name` when `expression` is `true` and removes it when it is
    `false`. A simple example can look like this:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当`expression`为`true`时，添加`class-name`，当`expression`为`false`时，移除它。一个简单的例子可以是这样的：
- en: '[PRE52]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Use **style bindings** to set inline styles based on the component state:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**样式绑定**根据组件状态设置内联样式：
- en: '[PRE53]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'While we have used the `ngStyle` While we have used the ngStyle directive for
    the workout view, we could have easily used *style binding* as well, as we are
    dealing with a single style. With style binding, the same `ngStyle` expression
    would become the following:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在锻炼视图中使用了`ngStyle`指令，但我们也可以使用*样式绑定*，因为我们处理的是单个样式。使用样式绑定，相同的`ngStyle`表达式将变成以下内容：
- en: '[PRE54]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`width` is a style, and since it takes units too, we extend our target expression
    to include the `%` symbol.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`width`是一个样式，因为它也需要单位，所以我们扩展我们的目标表达式以包括`%`符号。'
- en: 'Remember that `style.` and `class.` are convenient bindings for setting a single
    class or style. For more flexibility, there are corresponding attribute directives:
    `ngClass` and `ngStyle`. It''s time now to formally introduce you to attribute
    directives.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Attribute directives
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attribute directives are HTML extensions that change the behavior of a component/element.
    As described in the section on *Angular directives*, these directives do not define
    their own view.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Other than `ngStyle` and `ngClass` directives, there are a few more attribute
    directives that are part of the core framework. `ngValue`, `ngModel`, `ngSelectOptions`,
    `ngControl`, and `ngFormControl` are some of the attribute directives Angular
    provides.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: While the next section is dedicated to learning how to use the `ngClass` and
    `ngStyle` attribute directives, it is not until [Chapter 6](part0066.xhtml#aid-1UU542
    "Chapter 6.  Angular 2 Directives in Depth"), *Angular 2 Directives in Depth*,
    that we learn how to create our own attribute directives.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Styling HTML with ngClass and ngStyle
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular has two excellent directives that allow us to dynamically set styles
    on any element and toggle CSS classes. For the bootstrap progress bar, we use
    the **ngStyle** directive to dynamically set the element''s style, `width`, as
    the exercise progresses:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`ngStyle` allows us to bind one or more styles to component properties at once.
    It takes an object as a parameter. Each property name on the object is the style
    name, and the value is the Angular expression bound to that property, such as
    the following:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The styles can not only bind to component properties (`componentWidth` and `componentHeight`
    above) but also be set to a constant value (`larger`). The expression parser also
    allows the use of the ternary operator (`?:`); check out `isRequired`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'If styles become unwieldy in HTML, we also have the option of writing in our
    component a function that returns the object hash, and setting that as an expression:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Moreover, `getStyles` on the component looks like this:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `ngClass` too works on the same lines, except that it is used to toggle
    one or multiple classes. For example, check out the following code:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `required` class is applied when `inputRequired` is true, and is removed
    when it evaluates to `false`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Directives (custom or platform), like components, have to be registered on a
    module before they can be used.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Well! That covers everything we had to explore for our newly developed view.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: And as described earlier, if you are having a problem with running the code,
    look at the Git branch `checkpoint2.2`.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所述，如果您在运行代码时遇到问题，请查看Git分支`checkpoint2.2`。
- en: If not using Git, download the snapshot of `checkpoint2.2` (a zip file) from
    [http://bit.ly/ng2be-checkpoint2-2](http://bit.ly/ng2be-checkpoint2-2). Refer
    to the `README.md` file in the `trainer` folder when setting up the snapshot for
    the first time.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用Git，请从[http://bit.ly/ng2be-checkpoint2-2](http://bit.ly/ng2be-checkpoint2-2)下载`checkpoint2.2`的快照（zip文件）。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: Time to add some enhancement and learn a bit more about the framework!
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候添加一些增强并更多地了解这个框架了！
- en: To start with, we are going to create a new module dedicated to workout runner.
    Everything that related to workout runner, including `WorkoutRunnerComponent`,
    goes into this module. This gives us a great opportunity to revisit Angular modules
    in great details.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个专门用于锻炼运行的新模块。与锻炼运行相关的所有内容，包括`WorkoutRunnerComponent`，都放入此模块。这给了我们一个很好的机会，以极大的细节重新审视Angular模块。
- en: Exploring Angular modules
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Angular模块
- en: As the *7 Minute Workout* app grows and we add new components/directives/pipes/other
    artifacts to it, a need arises to organize these items. Each of these items needs
    to be part of an Angular module.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 随着*7分钟锻炼*应用程序的增长，我们需要为其添加新的组件/指令/管道/其他构件，因此需要组织这些项目。每个项目都需要成为Angular模块的一部分。
- en: A naÃ¯ve approach would be to declare everything in our app's root module (`AppModule`),
    as we did with `WorkoutRunnerComponent`, but this defeats the whole purpose of
    Angular modules.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 一个天真的方法是在我们应用程序的根模块（`AppModule`）中声明所有东西，就像我们在`WorkoutRunnerComponent`中所做的那样，但这违背了Angular模块的整体目的。
- en: To understand why a single-module approach is never a good idea, let's revisit
    Angular modules.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么单一模块方法永远不是一个好主意，让我们重新审视一下Angular模块。
- en: Comprehending Angular modules
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Angular模块
- en: In Angular, **modules** are a way to organize code into chunks that belong together
    and work as a cohesive unit. Modules are Angular's way of grouping and organizing
    code.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，**模块**是一种将代码组织成属于一起并作为一个统一单元工作的方式。模块是Angular分组和组织代码的方式。
- en: 'An Angular module primarily defines:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: Angular模块主要定义：
- en: The components/directives/pipes it owns
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它拥有的组件/指令/管道
- en: The components/directives/pipes it makes public for other modules to consume
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它公开供其他模块消耗的组件/指令/管道
- en: Other modules that it depends on
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它依赖的其他模块
- en: Services that the module wants to make available application wide
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块希望在整个应用程序中提供的服务
- en: Any decent-sized Angular app will have modules interlinked with each other: some
    modules consuming artifacts from other, some providing artifacts to others, and
    some modules doing both.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 任何规模较大的Angular应用程序都会有模块彼此相互关联：一些模块消耗其他模块的构件，一些模块向其他模块提供构件，一些模块两者都做。
- en: 'As a standard practice, module segregation is *feature-based*. One divides
    the app into features or sub features (for large features) and modules are created
    for each of the features. Even the framework adheres to this guideline as all
    of the framework constructs are divided across modules:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 作为标准做法，模块分离是*基于特性*的。将应用程序分成特性或子特性（对于大特性），并为每个特性创建模块。即使框架也遵循此准则，因为所有框架构造都分布在各个模块中：
- en: There is the omnipresent `BrowserModule` that aggregates the standard framework
    constructs used in every browser-based Angular app
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有无处不在的`BrowserModule`，它聚合了每个基于浏览器的Angular应用程序中使用的标准框架构造
- en: There is the `RouterModule` if we want to use the Angular routing framework
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想使用Angular路由框架，就会有`RouterModule`
- en: There is the `HtppModule` if our app needs to communicate with the server over
    HTTP
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们的应用程序需要通过HTTP与服务器通信，就会有`HtppModule`
- en: Angular modules are created by applying the `@NgModule` decorator to a TypeScript
    class, something we learned in [Chapter 1](part0018.xhtml#H5A42-edca168d36254bda8a21f611a95615c3
    "Chapter 1. Getting Started"), *Getting Started*. The decorator definition exposes
    enough metadata allowing Angular to load everything the module refers to.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`@NgModule`装饰器应用于TypeScript类来创建Angular模块，这是我们在[第1章](part0018.xhtml#H5A42-edca168d36254bda8a21f611a95615c3
    "第1章。入门")中学到的内容，*入门*。装饰器定义公开了足够的元数据，允许Angular加载模块引用的所有内容。
- en: 'The decorator has multiple attributes that allow us to define:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器具有多个属性，允许我们定义：
- en: External dependencies (using `imports`)
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部依赖项（使用`imports`）
- en: Module artifacts (using `declarations`)
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的构件（使用`declarations`）
- en: Module exports (using `exports`)
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的导出（使用`exports`）
- en: The services defined inside the module that need to be registered globally (using
    `providers`)
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模块内定义的需要全局注册的服务（使用`providers`）
- en: 'This diagram highlights the internals of a module and how they link to each
    other:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 该图表突出显示了模块的内部以及它们之间的链接：
- en: '![Comprehending Angular modules](../Images/image00440.jpeg)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![理解Angular模块](../Images/image00440.jpeg)'
- en: 'We hope one thing is clear from all this discussion: creating a single application-wide
    module is not the right use of Angular modules, unless you are building something
    rudimentary.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望从所有这些讨论中有一件事是清楚的：创建一个单一的应用程序范围模块并不是正确使用Angular模块的方式，除非你正在构建一些基本的东西。
- en: Adding a new module to 7 Minute Workout
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向7分钟锻炼添加新模块
- en: We are going to add more modules to *7 Minute Workout* too (hey, we do what
    we preach!). To start with, we are going to create a new module, `WorkoutRunnerModule`,
    and declare the `WorkoutRunnerComponent` in it. Henceforth, every component/directive/pipe
    we create specifically for workout execution goes into `WorkoutRunnerModule`.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也将向*7分钟锻炼*添加更多模块（嘿，我们言传身教！）。首先，我们将创建一个新模块，`WorkoutRunnerModule`，并在其中声明`WorkoutRunnerComponent`。从现在开始，我们为锻炼执行专门创建的每个组件/指令/管道都放入`WorkoutRunnerModule`。
- en: 'Create a new file, `workout-runner.module.ts`, inside the `workout-runner`
    folder, and add this module definition:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在`workout-runner`文件夹内创建一个新文件`workout-runner.module.ts`，并添加此模块定义：
- en: '[PRE60]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The module looks similar to `AppModule`. Interestingly, `WorkoutRunnerComponent`
    is a part of both module declarations and exports. Without the export, we cannot
    use `WorkoutRunnerComponent` outside `WorkoutRunnerModule`.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块看起来类似于`AppModule`。有趣的是，`WorkoutRunnerComponent`既是模块声明和导出的一部分。如果没有导出，我们就无法在`WorkoutRunnerModule`之外使用`WorkoutRunnerComponent`。
- en: Tip
  id: totrans-446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Only an exported component/directive/pipe can be used across modules.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 只有导出的组件/指令/管道才能在模块之间使用。
- en: '`BrowserModule` is the module that we import often. The `BrowserModule` module
    declares all the common framework directives (such `NgIf`, `NgFor`, and others),
    pipes, and services that any browser-based app requires.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`BrowserModule`是我们经常导入的模块。`BrowserModule`模块声明了任何基于浏览器的应用程序所需的所有常见框架指令（如`NgIf`，`NgFor`等），管道和服务。'
- en: Now that we have `WorkoutRunnerModule`, we need to reference this module in
    `AppModule` and remove any direct references to `WorkoutRunnerComponent` in `AppModule`.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`WorkoutRunnerModule`，我们需要在`AppModule`中引用此模块，并删除`AppModule`中对`WorkoutRunnerComponent`的任何直接引用。
- en: 'Open `app.module.ts` and remove the import and declaration specific to `WorkoutRunnerComponent`.
    Next, import the `WorkoutRunnerModule` by appending it to the existing module
    imports and add the necessary import references. See the highlighted code here:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`app.module.ts`，删除特定于`WorkoutRunnerComponent`的导入和声明。接下来，通过将其附加到现有模块导入并添加必要的导入引用来导入`WorkoutRunnerModule`。请参见此处的突出显示的代码：
- en: '[PRE61]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: And we are good to go! Behaviorally nothing has changed, but we are now a bit
    more organized.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备就绪了！行为上没有任何改变，但我们现在更有条理了。
- en: Are you wondering what happens if we leave the `WorkoutRunnerComponent` declaration
    in `AppModule` too? Remember, `WorkoutRunnerModule` also declares `WorkoutRunnerComponent`.
    Let's try. Go ahead; add `WorkoutRunnerComponent` back to the `AppModule` `declarations`
    section and run the application.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否想知道如果我们也将`WorkoutRunnerComponent`声明留在`AppModule`中会发生什么？记住，`WorkoutRunnerModule`也声明了`WorkoutRunnerComponent`。让我们试试。继续吧，将`WorkoutRunnerComponent`添加回`AppModule`的`declarations`部分并运行应用程序。
- en: 'The application throws this error in the browser console:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在浏览器控制台中抛出此错误：
- en: '*Type WorkoutRunnerComponent is part of the declarations of 2 modules: WorkoutRunnerModule
    and AppModule! Please consider moving WorkoutRunnerComponent to a higher module
    that imports WorkoutRunnerModule and AppModule. You can also create a new NgModule
    that exports and includes WorkoutRunnerComponent then import that NgModule in
    WorkoutRunnerModule and AppModule.*'
  id: totrans-455
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*类型WorkoutRunnerComponent是2个模块的声明的一部分：WorkoutRunnerModule和AppModule！请考虑将WorkoutRunnerComponent移动到导入WorkoutRunnerModule和AppModule的更高级模块中。您还可以创建一个新的NgModule，导出并包含WorkoutRunnerComponent，然后在WorkoutRunnerModule和AppModule中导入该NgModule。*'
- en: 'This leads to very important conclusion:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了一个非常重要的结论：
- en: '*A component/directive/pipe can only belong to a single module.*'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个组件/指令/管道只能属于一个模块。*'
- en: We are not allowed to re-declare a component once it is a part of a module.
    To use a component that is a part of a specific module, we should import the respective
    module instead of re-declaring the component.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦组件成为模块的一部分，我们就不允许重新声明它。要使用特定模块的组件，我们应该导入相应的模块，而不是重新声明组件。
- en: Importing dependencies through modules presents another challenge too. Circular
    dependency is not allowed. `ModuleA` cannot import `ModuleB` if `ModuleB` already
    imports `ModuleA`. This can happen if `ModuleA` wants to use some component from
    `ModuleB` and at the same time `ModuleB` is dependent on a component from `ModuleA`.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 通过模块导入依赖项也会带来另一个挑战。循环依赖是不允许的。如果`ModuleB`已经导入了`ModuleA`，那么`ModuleA`就不能导入`ModuleB`。如果`ModuleA`想要使用`ModuleB`中的某个组件，同时`ModuleB`又依赖于`ModuleA`中的某个组件，就会出现这种情况。
- en: In such a case, as the preceding error describes, the common dependency should
    be moved into another Angular module, `ModuleC`, and both the modules, `ModuleA`
    and `ModuleB`, should reference it.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，正如前面的错误描述的那样，共同的依赖项应该移动到另一个Angular模块`ModuleC`中，并且两个模块`ModuleA`和`ModuleB`都应该引用它。
- en: That is enough on Angular modules for now. Let's add some more enhancements
    to the app.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 现在关于Angular模块的内容就够了。让我们为应用程序添加一些更多的增强功能。
- en: Learning more about an exercise
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解更多关于练习的信息
- en: For people who are doing this workout for the first time, it will be good to
    detail the steps involved in each exercise. We can also add references to some
    YouTube videos for each exercise to help the user understand the exercise better.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一次进行这项锻炼的人来说，详细说明每个练习涉及的步骤将是很好的。我们还可以为每个练习添加一些YouTube视频的引用，以帮助用户更好地理解练习。
- en: We are going to add the exercise description and instructions in the left panel
    and call it the **description panel**. We will add a reference to YouTube videos
    in the right panel, which is **the video panel**. To make things more modular
    and learn some new concepts, we are going to create independent components for
    each description panel and video panel.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在左侧面板中添加练习描述和说明，并称之为**描述面板**。我们将在右侧面板中添加对YouTube视频的引用，这就是**视频面板**。为了使事情更加模块化并学习一些新概念，我们将为每个描述面板和视频面板创建独立的组件。
- en: The model data for this is already available. The `description` and `procedure`
    properties in the `Exercise` class (see `model.ts`) provide the necessary details
    about the exercise. The `videos` array contains some related YouTube video IDs,
    that will be used to fetch these videos.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型数据已经可用。`Exercise`类（参见`model.ts`）中的`description`和`procedure`属性提供了有关练习的必要细节。`videos`数组包含一些相关的YouTube视频ID，将用于获取这些视频。
- en: Adding descriptions and video panels
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加描述和视频面板
- en: 'An Angular app is nothing but a hierarchy of components, similar to a tree
    structure. As of now, *7 Minute Workout* has two components, the root component,
    `TrainerAppComponent`, and its child, `WorkoutRunnerComponent`, in line with the
    HTML component layout, which now looks like this:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: Angular应用程序只是一个组件层次结构，类似于树结构。目前，*7 Minute Workout*有两个组件，根组件`TrainerAppComponent`和其子组件`WorkoutRunnerComponent`，与HTML组件布局一致，现在看起来像这样：
- en: '[PRE62]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We are going to add two new components to `WorkoutRunnerComponent`, one each
    to support the exercise description and exercise videos. While we could have added
    some HTML directly to the `WorkoutRunnerComponent` view, what we are hoping here
    is to learn a bit more about cross-component communication. Let's start with adding
    the description panel on the left and understand how a component can accept inputs.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向`WorkoutRunnerComponent`添加两个新组件，一个用于支持练习描述，另一个用于支持练习视频。虽然我们可以直接向`WorkoutRunnerComponent`视图添加一些HTML，但我们希望在这里学习一些关于跨组件通信的知识。让我们首先添加左侧的描述面板，并了解组件如何接受输入。
- en: Providing component inputs
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供组件输入
- en: 'Create a folder called `exercise-description` (inside the `components/workout-runner`
    folder) and add a new file, `exercise-description.component.ts` to it. Add this
    piece of code to the file:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`exercise-description`的文件夹（在`components/workout-runner`文件夹内），并在其中添加一个新文件`exercise-description.component.ts`。将以下代码添加到文件中：
- en: '[PRE63]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Before we discuss the role of the `@Input` decorator, let's integrate the component
    into `WorkoutRunnerComponent`.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论`@Input`装饰器的作用之前，让我们将组件集成到`WorkoutRunnerComponent`中。
- en: 'Copy the corresponding view HTML, `exercise-description.html`, from the Git
    branch `checkpoint2.3`, folder `workout-runner/exercise-description` (GitHub location:
    [http://bit.ly/ng2be-2-3-exercise-description-html](http://bit.ly/ng2be-2-3-exercise-description-html)).
    To understand the role of `@Input`, let''s highlight the relevant parts of the
    `exercise-description` HTML:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 从Git分支`checkpoint2.3`的文件夹`workout-runner/exercise-description`（GitHub位置：[http://bit.ly/ng2be-2-3-exercise-description-html](http://bit.ly/ng2be-2-3-exercise-description-html)）中复制相应的视图HTML`exercise-description.html`。为了理解`@Input`的作用，让我们突出显示`exercise-description`
    HTML的相关部分：
- en: '[PRE64]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The preceding interpolation refers to the input properties of the `ExerciseDescriptionComponent`:
    `description` and `steps`. The `@Input` decorator signifies that the component
    property is available for view binding.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的插值是指`ExerciseDescriptionComponent`的输入属性：`description`和`steps`。`@Input`装饰器表示该组件属性可用于视图绑定。
- en: The component definition is complete. Now, we just need to reference `ExerciseDescriptionComponent`
    in `WorkoutRunnerComponent` and provide values for `description` and `steps` for
    the `ExerciseDescriptionComponent` view to render correctly.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 组件定义已经完成。现在，我们只需要在`WorkoutRunnerComponent`中引用`ExerciseDescriptionComponent`，并为`ExerciseDescriptionComponent`的`description`和`steps`提供值，以便正确渲染`ExerciseDescriptionComponent`视图。
- en: '`WorkoutRunnerComponent` can use `ExerciseDescriptionComponent` only if:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent`只能使用`ExerciseDescriptionComponent`，如果：'
- en: Either `ExerciseDescriptionComponent` is registered with the module that `WorkoutRunnerComponent`
    belongs to
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要么`ExerciseDescriptionComponent`已在`WorkoutRunnerComponent`所属的模块中注册
- en: Or `ExerciseDescriptionComponent` has been imported (using `imports`) from another
    module into the module that `WorkoutRunnerComponent` belongs to
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者`ExerciseDescriptionComponent`已经被导入（使用`imports`）到`WorkoutRunnerComponent`所属的另一个模块中
- en: For this case, we are going to register `ExerciseDescriptionComponent` with
    `WorkoutRunnerModule`, which already has `WorkoutRunnerComponent`.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，我们将在`WorkoutRunnerModule`中注册`ExerciseDescriptionComponent`，该模块已经有`WorkoutRunnerComponent`。
- en: 'Open `workout-runner.module.ts` and append `ExerciseDescriptionComponent` to
    the `declarations` array. Check out the highlighted code:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`workout-runner.module.ts`，并将`ExerciseDescriptionComponent`追加到`declarations`数组中。查看突出显示的代码：
- en: '[PRE65]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can now use `ExerciseDescriptionComponent`. Open `workout-runner.html` and
    update the HTML fragments as highlighted in the following code. Add a new div
    called `description-panel` before the `exercise-pane` div and adjust some styles
    on `exercise-pane` div, as follows:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`ExerciseDescriptionComponent`。打开`workout-runner.html`并根据以下代码中的突出显示部分更新HTML片段。在`exercise-pane`之前添加一个名为`description-panel`的新div，并调整`exercise-pane`
    div上的一些样式，如下所示：
- en: '[PRE66]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Make sure that `gulp play` is running and refresh the page. The description
    panel should show up on the left with the relevant exercise details.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`gulp play`正在运行并刷新页面。描述面板应该显示在左侧，并显示相关的练习详情。
- en: Look at the `exercise-description` declaration in the preceding view. We are
    referring to the `description` and `steps` properties in the same manner as we
    did with the HTML element properties earlier in the chapter (`<img [src]='expression'
    ...`). Simple, intuitive, and very elegant!
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 查看前面视图中的`exercise-description`声明。我们以与本章前面的HTML元素属性相同的方式引用`description`和`steps`属性。简单，直观，非常优雅！
- en: The Angular data binding infrastructure makes sure that whenever the `currentExercise.exercise.description`
    and `currentExercise.exercise.procedure` properties on `WorkoutRunnerComponent`
    change, the bound properties on `ExerciseDescriptionComponent`, `description`
    and `steps`, are also updated .
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: Angular数据绑定基础设施确保每当`WorkoutRunnerComponent`上的`currentExercise.exercise.description`和`currentExercise.exercise.procedure`属性发生变化时，`ExerciseDescriptionComponent`上的绑定属性`description`和`steps`也会更新。
- en: Note
  id: totrans-489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `@Input` decoration can take a **property alias** as a parameter, which
    means the following; consider a property declaration such as this: `@Input("myAwesomeProperty")
    myProperty:string;`'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Input`装饰可以接受**属性别名**作为参数，这意味着以下内容；考虑这样的属性声明：`@Input("myAwesomeProperty")
    myProperty:string;`'
- en: 'It can be referenced in the view as follows: `<my-component [myAwesomeProperty]="expression"....`'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以在视图中如下引用：`<my-component [myAwesomeProperty]="expression"....`
- en: The power of the Angular binding infrastructure allows us to use any component
    property as a bindable property by attaching the `@Input` decorator (and `@Output`
    too) to it. We are not limited to basic data types such as `string`, `number`,
    and `boolean`; there can be complex objects too, which we will see next as we
    add the video panel.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: Angular绑定基础设施的强大之处在于，我们可以通过将`@Input`装饰器（还有`@Output`）附加到任何组件属性上，将其用作可绑定属性。我们不仅限于基本数据类型，如`string`、`number`和`boolean`；也可以是复杂对象，接下来我们将在添加视频面板时看到。
- en: 'Copy `video-player.component.ts` and `video-player.html` from the Git branch
    `checkpoint2.3` folder in `trainer/src/components/workout-runner/video-player`
    (GitHub location: http://bit.ly/ng2be-2-3-video-player).'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 从`trainer/src/components/workout-runner/video-player`的Git分支`checkpoint2.3`文件夹中复制`video-player.component.ts`和`video-player.html`（GitHub位置：http://bit.ly/ng2be-2-3-video-player）。
- en: 'Let''s look at the implementation for a video player. Open `video-player.component.ts`
    and check out the `VideoPlayerComponent` class:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下视频播放器的实现。打开`video-player.component.ts`并查看`VideoPlayerComponent`类：
- en: '[PRE67]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `videos` input property here takes an array of strings (YouTube video codes).
    While we take the `videos` array as input, we do not use this array directly in
    video player view; instead we transform the input array into a new array of `safeVideoUrls`
    and bind it. This can be confirmed by looking at the view implementation:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`videos`输入属性接受一个字符串数组（YouTube视频代码）。虽然我们将`videos`数组作为输入，但我们并不直接在视频播放器视图中使用这个数组；相反，我们将输入数组转换为一个新的`safeVideoUrls`数组并进行绑定。可以通过查看视图实现来确认：
- en: '[PRE68]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The view uses a new Angular directive called `ngFor` to bind to the `safeVideoUrls`
    array. The `ngFor` directive belongs to a class of directives called *structural
    directives*. The directive's job is to take an HTML fragment and regenerate it
    based on the number of elements in the bound collection.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 视图使用一个名为`ngFor`的新的Angular指令来绑定到`safeVideoUrls`数组。`ngFor`指令属于一类称为*结构指令*的指令。该指令的作用是根据绑定集合中的元素数量重新生成HTML片段。
- en: If you are confused about how the `ngFor` directive works with `safeVideoUrls`
    and why we need to generate `safeVideoUrls` instead of using the `videos` input
    array, wait for a while as we are shortly going to address these queries. But
    let's first complete the integration of `VideoPlayerComponent` with `WorkoutRunnerComponent`
    to see the final outcome.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对`ngFor`指令如何与`safeVideoUrls`一起工作以及为什么我们需要生成`safeVideoUrls`而不是使用`videos`输入数组感到困惑，请稍等片刻，因为我们很快将解决这些问题。但首先让我们完成`VideoPlayerComponent`与`WorkoutRunnerComponent`的集成，以查看最终结果。
- en: As we did with the `ExerciseDescriptionComponent`, we need to add `VideoPlayerComponent`
    to `WorkoutRunnerModule` as well. We will leave this exercise to the reader.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ExerciseDescriptionComponent`一样，我们还需要将`VideoPlayerComponent`添加到`WorkoutRunnerModule`中。我们将把这个练习留给读者。
- en: 'Next, update the `WorkoutRunnerComponent` view by adding the component declaration
    after the `exercise-pane` div:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`exercise-pane` div之后添加组件声明，更新`WorkoutRunnerComponent`视图。
- en: '[PRE69]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `VideoPlayerComponent`'s `videos` property binds to the exercise's videos
    collection.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '`VideoPlayerComponent`的`videos`属性绑定到练习的视频集合。'
- en: Start/refresh the app and the video thumbnails should show up on the right.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 启动/刷新应用程序，视频缩略图应该会显示在右侧。
- en: Note
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are having a problem with running the code, look at the Git branch `checkpoint2.3`
    for a working version of what we have done thus far.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在运行代码时遇到问题，请查看Git分支`checkpoint2.3`，以获取我们迄今为止所做的工作版本。
- en: You can also download the snapshot of `checkpoint2.3` (a zip file) from [http://bit.ly/ng2be-checkpoint2-3](http://bit.ly/ng2be-checkpoint2-3).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从[http://bit.ly/ng2be-checkpoint2-3](http://bit.ly/ng2be-checkpoint2-3)下载`checkpoint2.3`的快照（zip文件）。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: 'Now it''s time to go back and look at the parts of the `VideoPlayerComponent`
    implementation that we skipped earlier. We specifically need to understand:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候回过头来看一下我们之前跳过的`VideoPlayerComponent`实现的部分。我们特别需要理解：
- en: How the `ngFor` directive works
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngFor`指令的工作原理'
- en: Why there is a need to transform the input `videos` array into `safeVideoUrls`
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么需要将输入的`videos`数组转换为`safeVideoUrls`
- en: The significance of the Angular component life cycle event `OnChanges`
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular组件生命周期事件`OnChanges`的重要性
- en: To start with it's time to formally introduce the `ngFor` and the class of directives
    it belongs to: *structural directives*.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们正式介绍`ngFor`和它所属的指令类：*结构指令*。
- en: Structural directives
  id: totrans-513
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构指令
- en: The third categorization of directives, **structural directives**, work on the
    components/elements to manipulate their layout.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 第三类指令**结构指令**如何在组件/元素上工作以操纵它们的布局。
- en: 'The Angular documentation describes structural directives in a succinct manner:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: Angular文档简洁地描述了结构指令：
- en: '*Instead of defining and controlling a view like a Component Directive, or
    modifying the appearance and behavior of an element like an Attribute Directive,
    the Structural Directive manipulates the layout by adding and removing entire
    element sub-trees.*'
  id: totrans-516
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*与组件指令一样，不是定义和控制视图，或者像属性指令一样修改元素的外观和行为，结构指令通过添加和移除整个元素子树来操作布局。*'
- en: Since we have already touched upon *component directives* (such as `workout-runner`
    and `exercise-description`) and *attribute directives* (such as `ngClass` and
    `ngStyle`), we can very well contrast their behaviors against *structural directives*.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经涉及了*组件指令*（比如`workout-runner`和`exercise-description`）和*属性指令*（比如`ngClass`和`ngStyle`），我们可以很好地对比它们与*结构指令*的行为。
- en: The `ngFor` directive belongs to this class. We can identify such directives
    by the `*` prefix. Other than `ngFor`, Angular comes with some other structural
    directives such as `ngIf` and `ngSwitch`.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngFor`指令属于这一类。我们可以通过`*`前缀来识别这些指令。除了`ngFor`，Angular还有一些其他结构指令，比如`ngIf`和`ngSwitch`。'
- en: The ever-so-useful NgFor
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如此有用的NgFor
- en: Every templating language has constructs that allow the templating engine to
    generate HTML (by repetition). Angular has **ngFor**. The ngFor directive is a
    super useful directive used to duplicate a piece of an HTML fragment *n* number
    of times.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 每种模板语言都有构造，允许模板引擎生成HTML（通过重复）。Angular有**ngFor**。ngFor指令是一个非常有用的指令，用于将HTML片段的一部分重复*n*次。
- en: 'The preceding code repeats the div fragment for each exercise video (using
    the `videos` array). The `let video of videos` string expression is interpreted
    as follows: take each video in the videos array and assign it to a **template
    input variable**, `video`. This input variable can now be referenced inside the
    `ngFor` template HTML, as we do when we set the `src` property binding.'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码针对每个练习视频（使用`videos`数组）重复了div片段。`let video of videos`字符串表达式被解释为：取出videos数组中的每个视频，并将其赋值给**模板输入变量**`video`。现在可以在`ngFor`模板HTML中引用这个输入变量，就像我们在设置`src`属性绑定时所做的那样。
- en: 'To provide more details about the iteration context, the `ngFor` directive
    provides an optional `index` that increases from 0 to the length of the array
    for each iteration, something similar to a `for` loop, which we all are familiar
    with. This `index` too can be captured into a *template input variable* and used
    inside the template:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供更多关于迭代上下文的细节，`ngFor`指令提供了一个可选的`index`，它在每次迭代时从0增加到数组的长度，类似于我们熟悉的`for`循环。这个`index`也可以被捕获到*模板输入变量*中，并在模板内部使用：
- en: '[PRE70]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Other than `index`, there is some more iteration context information available,
    which includes `first`, `last`, `even`, and `odd`. This information can come in
    handy as we can do some nifty stuff with it. Consider this example:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`index`之外，还有一些更多的迭代上下文信息可用，包括`first`、`last`、`even`和`odd`。这些信息可能会派上用场，因为我们可以做一些巧妙的事情。考虑这个例子：
- en: '[PRE71]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: It applies a `special` class to the first video `div`.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 它将`special`类应用于第一个视频`div`。
- en: 'The `ngFor` directive can be applied to HTML elements as well as our custom
    components. This is a valid use of ngFor:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngFor`指令可以应用于HTML元素以及我们的自定义组件。这是`ngFor`的一个有效用法：'
- en: '[PRE72]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note
  id: totrans-529
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `*` prefix is a terser format to represent a structural directive. In reality,
    the `ngFor` directive used with the preceding `videos` array expands to: `<template
    ngFor let-video [ngForOf]="videos">` `<div>` `<iframe width="330" height="220"`
    `[src]="''//www.youtube.com/embed/'' + video" ...>` `</iframe>` `</div>` `</template>` 
    The `template` tag has a declaration for `ngFor`, a *template input variable*
    (`video`), and a property (`ngForOf`) that points to the `videos` array.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: NgFor performance
  id: totrans-531
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since `NgFor` generates HTML-based on collection elements, it is notorious for
    causing performance issues. But we cannot blame the directive. It does what it
    is supposed to do: iterate and generate elements! UI rendering performance can
    take a hit if the backing collection is huge or there is repeated re-rendering
    of DOM due to the bound collection changing often.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: One of the performance tweaks for `NgFor` allows us to alter the behavior of
    this directive when it comes to creating and destroying DOM elements (when the
    underlying collection elements are added or removed).
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a scenario where we frequently get an array of objects from the server
    and bind it to the view using `NgFor`. The default behavior of `NgFor` is to regenerate
    the DOM every time we refresh the list (since Angular does a standard object equality
    check). However, as developers, we may very well know not much has changed. Some
    new objects may have been added, some removed, and maybe some modified. But Angular
    just regenerates the complete DOM.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: 'To alleviate this situation, Angular allows us to specify a custom **tracking
    function**, which lets Angular know when two objects being compared are equal.
    Have a look at the following function:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: A function such as this can be used in the `NgFor` template to tell Angular
    to compare the *user* object based on its `id` property instead of doing a reference
    equality check.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we then use the preceding function in the `NgFor` template:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`NgFor` *will now avoid recreating DOM for users with IDs already rendered.*'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember, Angular may still update the existing DOM elements if the bound
    properties of a user* *have changed.*'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: That's enough on the `ngFor` directive; let's move ahead.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: We still need to understand the role of the `safeVideoUrls` and the `OnChange`
    life cycle event in the `VideoPlayerComponent` implementation. Let's tackle the
    former first and understand the need for `safeVideoUrls`.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 security
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The easiest way to understand why we need to bind to `safeVideoUrls` instead
    of the `videos` input property is by trying it out. Replace the existing `ngFor`
    fragment HTML with this:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'And look at the browsers console log (a page refresh may be required). There
    are a bunch of errors thrown by the framework, such as:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '**Error: unsafe value used in a resource URL context (see http://g.co/ng/security#xss)**'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: No prize for guessing what is happening! Angular is trying to safeguard our
    application against a *Cross-Site Scripting (XSS)* attack.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: Such an attack enables the attacker to inject malicious code into our web pages.
    Once injected, the malicious code can read data from the current site context.
    This allows it to steal confidential data and also impersonate the logged-in user,
    hence gaining access to privileged resources.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: Angular has been designed to block these attacks by sanitizing any external
    code/script that is injected into an Angular view. Remember, content can be injected
    into a view through number of mechanisms, including *property/attribute/style
    bindings* or *interpolation*.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: Interpolations escape any content that we bind to them.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `innerHTML` property of an HTML element (*property binding*),
    while the HTML content is emitted, any unsafe content (*script*) embedded in the
    HTML is stripped. We will shortly see an example of it when we format the exercise
    steps as HTML instead of plain text.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: But what about *Iframes*? In our preceding example, Angular is blocking property
    binding to Iframe's `src` property too. This is a warning against third-party
    content being embedded in our own site using Iframe. Angular prevents this too.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: 'All in all, the framework defines four security contexts around content sanitization.
    These include:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: HTML content sanitization, when HTML content is bound using the `innerHTML`
    property.
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Style sanitization, when binding CSS into the `style` property.
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: URL sanitization, when URLs are used with tags such as `anchor` and `img.`
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resource sanitization when using `Iframes` or `script` tag. In this case, content
    cannot be sanitized and hence it is blocked by default.
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Angular is trying its best to keep us out of danger. But at times, we know that
    the content is safe to render and hence want to circumvent the default sanitization
    behavior.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: Trusting safe content
  id: totrans-561
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To let Angular know that the content being bound is safe, we use the **DomSanitizer** and
    call the appropriate method based on the security contexts just described. The
    available functions are:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '`bypassSecurityTrustHtml`'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bypassSecurityTrustScript`'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bypassSecurityTrustStyle`'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bypassSecurityTrustUrl`'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bypassSecurityTrustResourceUrl`'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our video player implementation, we use `bypassSecurityTrustResourceUrl`;
    it converts the video URL into a trusted `SafeResourceUrl` object:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `map` method transforms the videos array into a collection of `SafeResourceUrl`
    objects and assigns it to `safeVideoUrls`.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: Each of the methods listed previously takes a *string parameter*. This is the
    content we want Angular to know is safe. The return object, which could be any
    of `SafeStyle`, `SafeHtml`, `SafeScript`, `SafeUrl`, or `SafeResourceUrl`, can
    then be bound to the view.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-572
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A comprehensive treatment of this topic is available in the framework security
    guide available at http://bit.ly/ng2-security. A highly recommended read!
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: 'The last question to answer is: why do this in the `OnChanges` Angular life
    cycle event?'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '*The* `OnChanges` *life cyle event is triggered whenever the component''s inputs
    change*. In the case of `VideoPlayerComponent`, it is the `videos` array input
    property. We use this life cycle event to recreate the `safeVideoUrls` array and
    re-bind it to the view. Simple!'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: Video panel implementation is now complete. Let's add a few more minor enhancements
    and explore a bit more in Angular.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: Formatting exercise steps with innerHTML binding
  id: totrans-577
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the sore points in the current app is the formatting of the exercise
    steps. It's a bit difficult to read these steps.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps should either have a line break (`<br>`) or be formatted as an HTML
    `list` for easy readability. This seems to be a straightforward task, and we can
    just go ahead and change the data that is bounded to the step interpolation, or
    write a pipe that can add some HTML formatting using the line delimiting convention
    (`.`). For a quick verification, let''s update the first exercise steps in `workout-runner.component.ts`
    by adding a break (`<br>`) after each line:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now refresh the workout page. The output does not match our expectations, as
    shown here:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '![Formatting exercise steps with innerHTML binding](../Images/image00441.jpeg)'
  id: totrans-582
  prefs: []
  type: TYPE_IMG
- en: The break tags were literally rendered in the browser. Angular did not render
    the interpolation as HTML; instead, it escaped the HTML characters, and we know
    why!
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: How to fix it? Easy! Replace the interpolation with the property binding to
    bind step data to the element's `innerHTML` property (in `exercise-description.html`),
    and you are done!
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Refresh the workout page to confirm.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-587
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Preventing Cross-Site Scripting Security (XSS) issues**'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: As discussed earlier, Angular by default sanitizes the input HTML when injected
    dynamically. This safeguards our app against XSS attacks. Still if you want to
    dynamically inject styles/script into HTML, use the **DomSanitizer** to bypass
    this sanitization check.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: Time for another enhancement! It's time to learn about Angular pipes.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the remaining workout duration using pipes
  id: totrans-591
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It will be nice if we can tell the user the time left to complete the workout
    and not just the duration of the exercise in progress. We can add a countdown
    timer somewhere in the exercise pane to show the overall time remaining.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: The approach that we are going to take here is to define a component property
    called `workoutTimeRemaining`. This property will be initialized with the total
    time at the start of the workout, and will reduce with every passing second until
    it reaches zero. Since `workoutTimeRemaining` is a numeric value but we want to
    display a timer in the `hh:mm:ss` format, we need to make a conversion between
    the seconds' data and the time format. **Angular pipes** are a great option for
    implementing such a feature.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: Angular pipes
  id: totrans-594
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The primary aim of a pipe is to format the value of an expression displayed
    in the view. The framework comes with multiple predefined pipes, such as `date`,
    `currency`, `lowercase`, `uppercase`, and others. This is how we use a pipe in
    a view:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'An expression is followed by the *pipe symbol* (`|`), which is followed by
    the pipe name and then an optional parameter (`inputParam1`) separated by a colon
    (`:`). If the pipe takes multiple inputs, they can be placed one after another
    separated by a colon, like the inbuilt `slice` pipe, which can slice an array
    or string:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The parameter passed to the filter can be a constant or a property from the
    underlying component, such as this:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Here are some examples of the use of the `date` pipe, as described in the Angular
    `date` documentation. Assume that `dateObj` is initialized to June 15, 2015 21:43:11
    and locale is *en-US*:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Some of the most commonly used pipes are the following:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: '**date**: As we just saw, the date filter is used to format the date in a specific
    manner. This filter supports quite a number of formats and is locale-aware too.
    To know about the other formats supported by the date pipe, check out the framework
    documentation at [http://bit.ly/ng2-date](http://bit.ly/ng2-date).'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**uppercase** and **lowercase**: These two pipes, as the name suggests, change
    the case of the string input.'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**decimal** and **percent**: `decimal` and `percent` pipes are there to format
    decimal and percentage values based on the current browser locale.'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**currency**: This is used to format numeric values as a currency based on
    the current browser locale.'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '**json**: This is a handy pipe for debugging that can transform any input into
    a string using `JSON.stringify`. We made good use of it at the start of this chapter
    to render the `WorkoutPlan` object (see the Checkpoint 2.1 code).'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another really powerful feature of pipes is that they can be chained, wherein
    the output from one pipe can serve as the input to another pipe. Consider this
    example:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The first pipe slices the first 20 characters of `fullName` and the second pipe
    transforms them to uppercase.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen what pipes are and how to use them, why not implement
    one for *7 Minute Workout* app: a **seconds to time** pipe?
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a custom pipe - SecondsToTimePipe
  id: totrans-614
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SecondsToTimePipe` converts a numeric value into the `hh:mm:ss` format.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `seconds-to-time.pipe.ts` in the `workout-runner` folder
    and add the following pipe definition (the definition can also be downloaded from
    the Git branch `checkpoint.2.4` on the GitHub site at [http://bit.ly/ng2be-2-4-seconds-to-time-pipe-ts](http://bit.ly/ng2be-2-4-seconds-to-time-pipe-ts)):'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: In an Angular pipe, the implementation logic goes into the `transform` function.
    Defined as part of the `PipeTransform` interface, the preceding `transform` function
    transforms the input seconds' value into an *hh:mm:ss* string. The first parameter
    to the `transform` function is the pipe input. The subsequent parameters, if provided,
    are the arguments to pipe, passed using colon separator (`pipe:argument1:arugment2..`)
    from the view. We do not make use of any pipe argument as the implementation does
    not require it.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: The implementation is quite straightforward, as we convert seconds into hours,
    minutes, and seconds. Then we concatenate the result into a string value and return
    the value. The addition of 0 on the left for each of the `hours`, `minutes`, and
    `seconds` variables is done to format the value with a leading 0 in case the calculated
    value for hours, minutes, or seconds is less than 10.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: The pipe that we just created is a standard TypeScript class. Unless we apply
    the `@Pipe` decorator to it, it does not qualify as an Angular pipe.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the necessary `import` statement and the `@Pipe` decorator to the `seconds-to-time.pipe.ts`
    file just before the class definition:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The pipe definition is complete, but before we can use `SecondsToTimePipe` in
    `WorkoutRunnerComponent`, the pipe needs to be declared in `WorkoutRunnerModule`.
    This is something we did for `ExerciseDescriptionComponent` and `VideoPlayerComponent`
    earlier.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `workout-runner.module.ts`, and add the highlighted code:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Finally, we just need to add the pipe in the view. Update `workout-runner.html`
    by adding the highlighted fragment:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Surprisingly the implementation is still not complete! We have a pipe definition,
    and we have referenced it in the view, but `workoutTimeRemaining` needs to update
    with each passing second for `SecondsToTimePipe` to be of any use.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already initialized the `WorkoutRunnerComponent`''s `workoutTimeRemaining`
    property in the `start` function with the total workout time:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now the question is: how to update the `workoutTimeRemaining` variable with
    each passing second? Remember that we already have a `setInterval` setup that
    updates `exerciseRunningDuration`. While we can write another `setInterval` implementation
    for `workoutTimeRemaining`, it will be better if a single `setInterval` setup
    can take care of both the requirements.'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a function called `startExerciseTimeTracking` to `WorkoutRunnerComponent`;
    it looks like this:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: As you can see, the primary purpose of the function is to track the exercise
    progress and flip the exercise once it is complete. However, it also tracks `workoutTimeRemaining`
    (it decrements this counter). The first `if` condition setup just makes sure that
    we clear the timer once all the exercises are done. The inner `if` conditions
    are used to keep `currentExerciseIndex` in sync with the running exercise.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: This function uses an instance variable called `exerciseTrackingInterval`. Add
    it to the class declaration section. We are going to use this variable later to
    implement an exercise pausing behavior.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: Remove the complete `setInterval` setup from `startExercise` and replace it
    with a call to `this.startExerciseTimeTracking();`. We are all set to test our
    implementation. Refresh the browser and verify the implementation.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing a custom pipe - SecondsToTimePipe](../Images/image00442.jpeg)'
  id: totrans-638
  prefs: []
  type: TYPE_IMG
- en: The next section is about another inbuilt Angular directive, `ngIf`, and another
    small enhancement.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: Adding the next exercise indicator using ngIf
  id: totrans-640
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It will be nice for the user to be told what the next exercise is during the
    short rest period between exercises. This will help them prepare for the next
    exercise. So let's add it.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this feature, we can simply output the title of the next exercise
    in line from the `workoutPlan.exercises` array. We show the title next to the
    `Time Remaining` countdown section. Change the workout div (`class="workout-display-div"`)
    to include the highlighted content, and remove `Time Remaining` `h1`:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We wrap the existing `Time Remaining h1` and add another `h3` tag to show the
    next exercise inside a new `div` with some style updates. Also, there is a new
    directive, `ngIf`, in the second `h3`. The `*` prefix implies that it belongs
    to the same set of directives that `ngFor` belongs: structural directives.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: 'The **ngIf** directive is used to add or remove a specific section of the DOM
    based on whether the expression provided to it returns `true` or `false`. The
    DOM element is added when the expression evaluates to `true` and destroyed otherwise.
    Isolate the `ngIf` declaration from the preceding view:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The expression then checks whether we are currently at the rest phase and the
    directive accordingly shows or hides the linked `h3`.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: Other than this, in the same `h3`, we have an interpolation that shows the name
    of the exercise from the `workoutPlan.exercises` array.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: 'A word of caution here: `ngIf` adds and destroys the DOM element, and hence
    it is not similar to the visibility constructs that we employed to show and hide
    elements. While the end result of `style`, `display:none` is the same as that
    of `ngIf`, the mechanism is entirely different:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Versus this line:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: With `ngIf`, whenever the expression changes from `false` to `true`, a complete
    re-initialization of the content occurs. Recursively, new elements/components
    are created and data binding is set up, starting from the parent down to the children.
    The reverse happens when the expression changes from `true` to `false`: all of
    this is destroyed. Therefore, using `ngIf` can sometimes become an expensive operation
    if it wraps a large chunk of content and the expression attached to it changes
    very often. But otherwise, wrapping a view in `ngIf` is more performant than using
    css/style-based show or hide, as neither the DOM is created nor the data binding
    expressions are set up when the `ngIf` expression evaluates to `false`.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another directive that belongs in this league: **ngSwitch**. When
    defined on the parent HTML, it can swap the child HTML elements based on the `ngSwitch`
    expression. Consider this example:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We bind the `userType` expression to `ngSwitch`. Based on the value of `userType`
    (`admin` , `powerUser` , or any other `userType`), one of the inner div elements
    will be rendered. The `ngSwitchDefault` directive is a wildcard match/fallback
    match, and it gets rendered when `userType` is neither `admin` nor `powerUser`.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have not realized it yet, note that there are three directives working
    together here to achieve switch-case-like behavior:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: '`ngSwitch`'
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngSwitchCase`'
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngSwitchDefault`'
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Coming back to our next exercise implementation, we are ready to verify the
    implementation, so we refresh the page and wait for the rest period. There should
    be a mention of the next exercise during the rest phase, as shown here:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the next exercise indicator using ngIf](../Images/image00443.jpeg)'
  id: totrans-662
  prefs: []
  type: TYPE_IMG
- en: The app is shaping up well. If you have used the app and done some physical
    workouts along with it, you will be missing the exercise pause functionality badly.
    The workout just does not stop until it reaches the end. We need to fix this behavior.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: Pausing an exercise
  id: totrans-664
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To pause an exercise, we need to stop the timer. We also need to add a button
    somewhere in the view that allows us to pause and resume the workout. We plan
    to do this by drawing a button overlay over the exercise area in the center of
    the page. When clicked on, it will toggle the exercise state between paused and
    running. We will also add keyboard support to pause and resume the workout using
    the key binding **p** or **P**. Let's update the component.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `WorkoutRunnerComponent` class, add these three functions, and add
    a declaration for the `workoutPaused` variable:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The implementation for pausing is simple. The first thing we do is cancel the
    existing `setInterval` setup by calling `clearInterval(this.exerciseTrackingInterval);`.
    While resuming, we again call `startExerciseTimeTracking`, which again starts
    tracking the time from where we left off.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just need to invoke the `pauseResumeToggle` function for the view. Add
    the following content to `workout-runner.html`:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The `click` event handler on the div toggles the workout running state, and
    the `ngClass` directive is used to toggle the class between `glyphicon-pause`
    and `glyphicon-play`-standard Angular stuff. What is missing now is the ability
    to pause and resume on a **p** or **P** key press.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: 'We can apply a `keyup` event handler on the div:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'But the `div` element does not have a concept of focus, so we also need to
    add the `tabIndex` attribute on the div to make it work. Even then, it works only
    when we have clicked on the div at least once. There is a better way to implement
    this; attach the event handler to the global `window` event `keyup`. This is how
    the event binding will look now:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Make note of the special `window:` prefix before the `keyup` event. We can
    use this syntax to attach events to any global object, such as `document`. The
    `onKeyPressed` event handler needs to be added to `WorkoutRunnerComponent`. Add
    this function to the class:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The `$event` object is the standard **DOM event object** that Angular makes
    available for manipulation. Since this is a keyboard event, the specialized class
    is `KeyboardEvent`. The `which` property is matched to ASCII values of `p` or
    `P`. Refresh the page and you should see the play/pause icon when your mouse hovers
    over the exercise image, like this:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: '![Pausing an exercise](../Images/image00444.jpeg)'
  id: totrans-679
  prefs: []
  type: TYPE_IMG
- en: While we are on event binding, it would be a good opportunity to explore Angular's
    event binding infrastructure
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: The Angular event binding infrastructure
  id: totrans-681
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular event binding allows a component to communicate with its parent through
    events.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: If we look back at the app implementation, what we have encountered thus far
    are the property/attribute bindings. Such bindings allow a component/element to
    take inputs from the outside world. The data flows into the component.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: Event bindings are the reverse of property bindings. They allow a component/element
    to inform the outside world about any state change.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw in the pause/resume implementation, event binding employs *round
    brackets* (`()`) to specify the target event:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This attaches a `click` event handler to the `div` that invokes the expression
    `pauseResumeToggle()` when the `div` is clicked.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-688
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like properties, there is a canonical form for events too. Instead of using
    round brackets, the `on-` prefix can be used: `on-click="pauseResumeToggle()"`'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular supports all types of events. Events related to keyboard inputs, mouse
    movements, button clicks, and touches. The framework even allows us to define
    our own event for the components we create, such as:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: We will be covering custom component events in the next chapter, where we will
    add audio support to *7 Minute Workout*.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: It is expected that events have side effects; in other words, an event handler
    may change the state of the component, which in turn may trigger a chain reaction
    in which multiple components react to the state change and change their own state.
    This is unlike a property binding expression, which should be side-effect-free.
    Even in our implementation, clicking on the `div` element toggles the exercise
    run state.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: Event bubbling
  id: totrans-694
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When Angular attaches event handlers to standard HTML element events, the event
    propagation works in the same way as standard DOM event propagation works. This
    is also called **event bubbling**. Events on child elements are propagated upwards,
    and hence event binding is also possible on a parent element, like this:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Clicking on either of the divs results in the invocation of the `doWork` function.
    Moreover, `$event.target` contains the reference to the `div` that dispatched
    the event.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-698
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Custom events created on Angular components do not support event bubbling.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: 'Event bubbling stops if the expression assigned to the target evaluates to
    a `falsey` value (such as `void`, `false`). Therefore, to continue propagation,
    the expression should evaluate to `true`:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Here too, the `$event` object deserves some special attention.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: Event binding an $event object
  id: totrans-703
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Angular makes an `$event` object available whenever the target event is triggered.
    This `$event` contains the details of the event that occurred.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to note here is that the shape of the `$event` object is
    decided based on the event type. For HTML elements, it is a DOM event object ([https://developer.mozilla.org/en-US/docs/Web/Events](https://developer.mozilla.org/en-US/docs/Web/Events)),
    which may vary based on the actual event.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: But if it is a custom component event, what is passed in the `$event` object
    is decided by the component implementation. We will return to this discussion
    again, in the next chapter.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: We have now covered most of the data binding capabilities of Angular, with the
    exception of two-way binding. A quick introduction to the two-way binding constructs
    is warranted before we conclude the chapter.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: Two-way binding with ngModel
  id: totrans-708
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Two-way binding** helps us keep the model and view in sync. Changes to the
    model update the view and changes to the view update the model. The obvious area
    where two-way binding is applicable is *form input*. Let''s look at a simple example:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The `ngModel` directive here sets a two-way binding between the `input`'s `value`
    property and the `workout.name` property on the underlying component. Anything
    that the user enters in the above `input` is synced with `workout.name`, and any
    changes to `workout.name` are reflected back on the preceding `input`.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly we can achieve the same result without using the `ngModel` directive
    too, by combining both *property * *and event binding * *syntax*. Consider the
    next example; it works in the same way as `input` before:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: There is a property binding set up on the `value` property and an event binding
    set up on the `input` event that make the bidirectional sync work.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: We get into more details on two-way binding in [Chapter 4](part0045.xhtml#1AT9A1-edca168d36254bda8a21f611a95615c3
    "Chapter 4.  Personal Trainer"), *Building Personal Trainer*, where we build our
    own custom workouts.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created a diagram that summarizes the data flow patterns for all the
    bindings that we have discussed thus far. A handy illustration to help you memorize
    each of the binding constructs and how data flows is as follows:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: '![Two-way binding with ngModel](../Images/image00445.jpeg)'
  id: totrans-717
  prefs: []
  type: TYPE_IMG
- en: We now have a fully functional *7 Minute Workout*, with some bells and whistles
    too, and hopefully it was fun creating the app. It's time to conclude the chapter
    and summarize the lessons.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-719
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are having a problem with running the code, look at the Git branch `checkpoint2.4`
    for a working version of what we have done thus far.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also download a snapshot of `checkpoint2.4` (a zip file) from this
    GitHub location: [http://bit.ly/ng2be-checkpoint2-4](http://bit.ly/ng2be-checkpoint2-4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-722
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter with the aim of creating an Angular app that is more
    complex than the sample we created in the first chapter. The *7 Minute Workout*
    app fitted the bill, and you learned a lot about the Angular framework while building
    this app.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: We started by defining the functional specifications of the *7 Minute Workout*
    app. We then focused our efforts on defining the code structure for the app.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: To build the app, we started off by defining the model of the app. Once the
    model was in place, we started the actual implementation, by building an **Angular
    component**. Angular components are nothing but classes that are decorated with
    a framework-specific decorator, `@Component`.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about **Angular modules** and how Angular uses them to organize
    code artifacts.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: Once we had a fully functional component, we created a supporting view for the
    app. We also explored the *data binding capabilities* of the framework, including
    **property**, **attribute**, **class**, **style,** and **event binding**. Plus,
    we highlighted how **interpolations** are a special case of *property binding*.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: Components are a special class of directives that have an attached view. We
    touched upon what directives are and the special classes of directives, including
    **attribute** and **structural directives**.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to perform cross-component communication using **input properties**.
    The two child components that we put together (`ExerciseDescriptionComponent`
    and `VideoPlayerComponent`) derived their inputs from the parent `WorkoutRunnerComponent`
    using input properties.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: We then covered another core construct of Angular, **pipes**. We saw how to
    use pipes such as the *date pipe* and how to create one of our own.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout the chapter, we touched upon a number of Angular directives, including
    the following:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: '`ngClass/ngStyle`: For applying multiple styles and classes using Angular binding
    capabilities'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngFor`: For generating dynamic HTML content using a looping construct'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngIf`: For conditionally creating/destroying DOM elements.'
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngSwitch`: For creating/destroying DOM elements using the switch-case construct'
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We now have a basic 7 Minute Workout app. For a better user experience, we have
    added a number of small enhancements to it too, but we are still missing some
    good-to-have features that would make our app more usable. From the framework
    perspective, we have purposefully ignored some core/advanced concepts such as
    **change detection**, **dependency injection**, **component ** **routing**, as
    well as data flow patterns, which we plan to cover in the next chapter.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
