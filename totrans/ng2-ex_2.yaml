- en: Chapter 2.  Building Our First App - 7 Minute Workout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope the first chapter was intriguing enough and you want to learn more about
    Angular. Believe me, we have just scratched the surface! The framework has a lot
    to offer, and it strives to make frontend development using JavaScript more organized
    and hence manageable.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping up with the theme of this book, we will be building a new app in Angular,
    and in the process, developing a better understanding of the framework. This app
    will also help us explore some new capabilities of the framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that we will cover in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**7 Minute Workout problem description**: We detail the functionality of the
    app that we build in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code organization**: For our first real app, we will try to explain how to
    organize code, specifically Angular code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Designing the model**: One of the building blocks of our app is its model.
    We design the app model based on the app''s requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understanding the data binding infrastructure**: While building the *7 Minute
    Workout* view, we will look at the data binding capabilities of the framework,
    which include *property*, *attribute*, *class*, *style*, and *event* bindings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exploring the Angular platform directives**: Some of the directives that
    we will cover are `ngFor`, `ngIf`, `ngClass`, `ngStyle`, and `ngSwitch`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-component communication with input properties**: Having built some
    child components, we learn how *input **properties* can be used to pass data from
    the parent to its child components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-component communication with events**: Angular components can subscribe
    to and raise events. We get introduced to event binding support in Angular.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular pipes**: Angular pipes provide a mechanism to format view content.
    We explore some standard Angular pipes and build our own pipe too to support conversions
    from seconds to hh:mm:ss.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started! The first thing we will do is define theof our *7 Minute
    Workout* app.
  prefs: []
  type: TYPE_NORMAL
- en: What is 7 Minute Workout?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want everyone reading this book to be physically fit. Therefore, this book
    should serve a dual purpose; it should not only simulate your grey matter but
    also urge you to look after your physical fitness. What better way to do it than
    to build an app that targets physical fitness!
  prefs: []
  type: TYPE_NORMAL
- en: '*7 Minute Workout* is an exercise/workout plan that requires us to perform
    a set of twelve exercises in quick succession within the seven minute time span.
    *7 Minute Workout* has become quite popular due to its benefits and the short
    duration of the workout. We cannot confirm or refute the claims but doing any
    form of strenuous physical activity is better than doing nothing at all. If you
    are interested to know more about the workout, then check out [http://well.blogs.nytimes.com/2013/05/09/the-scientific-7-minute-workout/](http://well.blogs.nytimes.com/2013/05/09/the-scientific-7-minute-workout/).'
  prefs: []
  type: TYPE_NORMAL
- en: The technicalities of the app include performing a set of 12 exercises, dedicating
    30 seconds for each of the exercises. This is followed by a brief rest period
    before starting the next exercise. For the app that we are building, we will be
    taking rest periods of 10 seconds each. So, the total duration comes out be a
    little more than 7 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the chapter, we will have the *7 Minute Workout* app ready, which
    will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is 7 Minute Workout?](../Images/image00436.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Downloading the code base
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this app can be downloaded from the GitHub site [https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample)
    dedicated to this book. Since we are building the app incrementally, we have created
    multiple checkpoints that map to **GitHub branches** such as `checkpoint2.1`,
    `checkpoint2.2`, and so on. During the narration, we will highlight the branch
    for reference. These branches will contain the work done on the app up to that
    point in time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *7 Minute Workout* code is available inside the repository folder named
    `trainer`.
  prefs: []
  type: TYPE_NORMAL
- en: So let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember that we are building on a modern platform for which browsers still
    lack support. Therefore, directly referencing script files in HTML is out of question
    (while common, it's a dated approach that we should avoid anyway). The current
    browsers do not understand **TypeScript**; as a matter of fact, even **ES 2015**
    (also known as ES6) is not supported. This implies that there has to be a process
    that converts code written in TypeScript into standard **JavaScript (ES5)**, which
    browsers can work with.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, having a build setup for almost any Angular 2 app becomes imperative.
    Having a build process may seem like overkill for a small application, but it
    has some other advantages as well.
  prefs: []
  type: TYPE_NORMAL
- en: If you are a frontend developer working on the web stack, you cannot avoid **Node.js**.
    This is the most widely used platform for Web/JavaScript development. So, no prizes
    for guessing that the Angular 2 build setup too is supported over Node.js with
    tools such as **Grunt**, **Gulp**, **JSPM**, and **webpack**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we are building on the Node.js platform, install Node.js before starting.
  prefs: []
  type: TYPE_NORMAL
- en: While there are quite elaborate build setup options available online, we go
    for a minimal setup using **Gulp**. The reason is that there is no one size fits
    all solution out there. Also, the primary aim here is to learn about Angular 2
    and not to worry too much about the intricacies of setting up and running a build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the notable starter sites plus build setups created by the community
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Start site** | **Location** |'
  prefs: []
  type: TYPE_TB
- en: '| `angular2-webpack-starter` | [http://bit.ly/ng2webpack](http://bit.ly/ng2webpack)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `angular2-seed` | [http://bit.ly/ng2seed](http://bit.ly/ng2seed) |'
  prefs: []
  type: TYPE_TB
- en: '| `angular-cli`-We touched upon this tool in [Chapter 1](part0018.xhtml#H5A42-edca168d36254bda8a21f611a95615c3
    "Chapter 1. Getting Started"), *Getting Started*. It allows us to generate the
    initial code setup, including the build configurations, and has good scaffolding
    capabilities too. | [http://bit.ly/ng2-cli](http://bit.ly/ng2-cli) |'
  prefs: []
  type: TYPE_TB
- en: 'A natural question arises if you are very new to **Node.js** or the overall
    build process: what does a typical Angular build involve? It depends! To get an
    idea about this process, it would be beneficial if we look at the build setup
    defined for our app. Let''s set up the app''s build locally then. Follow these
    steps to have the boilerplate Angular 2 app up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the base version of this app from [http://bit.ly/ng2be-base](http://bit.ly/ng2be-base)
    and unzip it to a location on your machine. If you are familiar with how Git works,
    you can just clone the repository and checkout the branch `base`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code serves as the starting point for our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the `trainer` folder from the command line and execute these commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first command installs Gulp (and typings) globally so that you can invoke
    the **Gulp** command line tool from anywhere and execute *Gulp tasks*. A **Gulp
    task** is an activity that Gulp performs during the build execution. If we look
    at the Gulp build script (which we will do shortly), we realize that it is nothing
    but a sequence of tasks performed whenever a build occurs. The second command
    installs the app's dependencies (in the form of `npm` packages). **Packages**
    in the Node.js world are third-party libraries that are either used by the app
    or support the app's building process. For example, Gulp itself is a Node.js package.
    The **npm** is a command-line tool for pulling these packages from a central repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Gulp is installed and npm pulls dependencies from the npm store, we are
    ready to build and run the application. From the command line, enter the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This compiles and runs the app. If the build process goes fine, the default
    browser window/tab will open with a rudimentary Hello World page (`http://localhost:9000/index.html`).
    We are all set to begin developing our app in Angular 2!
  prefs: []
  type: TYPE_NORMAL
- en: But before we do that, it would be interesting to know what has happened under
    the hood.
  prefs: []
  type: TYPE_NORMAL
- en: The build internals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even if you are new to Gulp, looking at `gulpfile.js` gives you a fair idea
    about what the build process is doing. A Gulp build is a set of tasks performed
    in a predefined order. The end result of such a process is some form of package
    code that is ready to be run. And if we are building our apps using *TypeScript*/*ES2015*
    or some other similar language that browsers do not understand natively, then
    we need an additional build step, called **transpilation**.
  prefs: []
  type: TYPE_NORMAL
- en: Code transpiling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As it stands in 2016, browsers still cannot run *ES2015* code. While we are
    quick to embrace languages that hide the not-so-good parts of JavaScript (ES5),
    we are still limited by the browser's capabilities. When it comes to language
    features, **ES5** is still the safest bet as all browsers support it. Clearly,
    we need a mechanism to convert our *TypeScript* code into plain JavaScript (**ES5**).
    Microsoft has a TypeScript compiler that does this job.
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript compiler takes the TypeScript code and converts it into ES5-format
    code that can run in all browsers. This process is commonly referred to as **transpiling**,
    and since the TypeScript compiler does it, it's called a **transpiler**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, transpilation can happen at both build/compile time and runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build-time transpilation**: Transpilation as part of the build process takes
    the script files (in our case, TypeScript `.ts` files) and compiles them into
    plain JavaScript. Our build setup uses build-time transpilation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime transpilation**: This happens in the browser at runtime. We include
    the raw language-specific script files (`.ts` in our case), and the TypeScript
    compiler, which is loaded in the browser beforehand, compiles these script files
    on the fly. While runtime transpilation simplifies the build setup process, as
    a recommendation, it should be limited to development workflows only, considering
    the additional performance overhead involved in loading the transpiler and transpiling
    the code on the fly. The example in [Chapter 1](part0018.xhtml#H5A42-edca168d36254bda8a21f611a95615c3
    "Chapter 1. Getting Started"), *Getting Started*, used runtime transpilation,
    and hence it did not require any build setup. Go check it out again!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process of transpiling is not limited to TypeScript. Every language targeted
    towards the Web, such as **CoffeeScript**, **ES2015**, or any other language that
    is not inherently understood by a browser, needs transpilation. There are transpilers
    for most languages, and the prominent ones (other than TypeScript) are **tracuer**
    and **babel**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile TypeScript files, we can install the TypeScript compiler manually
    from the command line using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once installed, we can compile any TypeScript file into ES5 format using the
    compiler (`tsc.exe`).
  prefs: []
  type: TYPE_NORMAL
- en: But for our build setup, this process is automated using the `ts2js` Gulp task
    (check out `gulpfile.js`). And if you are wondering when we installed TypeScript...
    well, we did it as part of the `npm install` step, when setting up the code for
    the first time. The `gulp-typescript` package downloads the TypeScript compiler
    as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this basic understanding of transpilation, we can summarize what happens
    with our build setup:'
  prefs: []
  type: TYPE_NORMAL
- en: The `gulp play` command kicks off the build process. This command tells Gulp
    to start the build process by invoking the `play` task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the `play` task has a dependency on the `ts2js` task, `ts2js` is executed
    first. The `ts2js` compiles the TypeScript files (`.ts`) located in `src` folder
    and outputs them to the `dist` folder at the root.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Post build, a static file server is started that serves all the app files, including
    static files (images, videos, and HTML) and script files (check `gulp.play` task).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thenceforth, the build process keeps a watch on any script file changes (the
    `gulp.watch` task) you make and recompiles the code on the fly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **livereload** has also been set up for the app. Any changes to the code
    refresh the browser running the app automatically. In case automatic browser refresh
    fails, we can always do a manual refresh.
  prefs: []
  type: TYPE_NORMAL
- en: This is a rudimentary build setup required to run an Angular app. For complex
    build requirements, we can always look at the starter/seed projects that have
    a more complete and robust build setup, or build something of our own.
  prefs: []
  type: TYPE_NORMAL
- en: Next let's look at the boilerplate app code already there and the overall code
    organization.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is how we are going to organize our code and other assets for the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Organizing code](../Images/image00437.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `trainer` folder is the root folder for the app and it has a folder (`static`)
    for the static content (such as images, CSS, audio files, and others) and a folder
    (`src`) for the app's source code.
  prefs: []
  type: TYPE_NORMAL
- en: The organization of the app's source code is heavily influenced by the design
    of Angular and the Angular style guide ([http://bit.ly/ng2-style-guide](http://bit.ly/ng2-style-guide))
    released by the Angular team. As we saw in [Chapter 1](part0018.xhtml#H5A42-edca168d36254bda8a21f611a95615c3
    "Chapter 1. Getting Started"), *Getting Started*, among the primary building blocks
    of Angular 2 are **components**. The `components` folder hosts all the components
    that we create. We will be creating subfolders in this folder for every major
    component of the application. Each component folder will contain artifacts related
    to that component, which includes its template, its implementation, and other
    related items. We will also keep adding more top-level folders (inside the `src`
    folder) as we build the application.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the code now, the `components/app` folder has defined a *root
    level component* `TrainerAppComponent` and root level module `AppModule`. The
    `bootstrap.ts` file contains code to bootstrap/load the application module (`AppModule`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*7 Minute Workout* uses **Just-in-time (JIT) compilation** to compile Angular
    views. This implies that views are compiled just before they are rendered in the
    browser. Angular has a compiler running in the browser that compiles these views.'
  prefs: []
  type: TYPE_NORMAL
- en: Angular also supports the **Ahead-of-time (AoT) compilation** model. With AoT,
    the views are compiled on the server side using a server version of the Angular
    compiler. The views returned to the browser are precompiled and ready to be used.
  prefs: []
  type: TYPE_NORMAL
- en: For *7 Minute Workout*, we stick to the JIT compilation model just because it
    is easy to set up as compared to AoT, which requires server-side tweaks and package
    installation.
  prefs: []
  type: TYPE_NORMAL
- en: We highly recommend that you use AoT compilation for production apps due the
    numerous benefits it offers. AoT can improve the application's initial load time
    and reduce its size too. Look at the AoT platform documentation (*cookbook*) at
    [http://bit.ly/ng2-aot](http://bit.ly/ng2-aot) to understand how AoT compilation
    can benefit you.
  prefs: []
  type: TYPE_NORMAL
- en: Time to start working on our first focus area, which is the app's model!
  prefs: []
  type: TYPE_NORMAL
- en: The 7 Minute Workout model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Designing the model for this app requires us to first detail the functional
    aspects of the *7 Minute Workout* app, and then derive a model that satisfies
    those requirements. Based on the problem statement defined earlier, some of the
    obvious requirements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Being able to start the workout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Providing a visual clue about the current exercise and its progress. This includes
    the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a visual depiction of the current exercise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing step-by-step instructions on how to do a specific exercise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time left for the current exercise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notifying the user when the workout ends.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some other valuable features that we will add to this app are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to pause the current workout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing information about the next exercise to follow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Providing audio clues so that the user can perform the workout without constantly
    looking at the screen. This includes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A timer click sound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details about the next exercise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signaling that the exercise is about to start
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing related videos for the exercise in progress and the ability to play
    them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see, the central theme for this app is **workout** and **exercise**.
    Here, a workout is a set of exercises performed in a specific order for a particular
    duration. So, let's go ahead and define the model for our workout and exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the requirements just mentioned, we will need the following details
    about an exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: The name. This should be unique.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The title. This is shown to the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The description of the exercise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instructions on how to perform the exercise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Images for the exercise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the audio clip for the exercise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Related videos.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With TypeScript, we can define the classes for our model.
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder called `workout-runner` inside the `src/components` folder and
    copy the `model.ts` file from the checkpoint2.1 branch folder `workout-runner`([http://bit.ly/ng2be-2-1-model-ts](https://github.com/chandermani/angular2byexample/blob/checkpoint2.1/trainer/src/components/workout-runner/model.ts))
    to the corresponding local folder. `model.ts` contains the model definition for
    our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Exercise` class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**TypeScript tips** Passing constructor parameters with `public` or `private`
    is a shorthand for creating and initializing class members at one go. The `?`
    suffix after `nameSound`, `procedure`, and `videos` implies that these are optional
    parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the workout, we need to track the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: The name. This should be unique.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The title. This is shown to the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exercises that are part of the workout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The duration for each exercise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest duration between two exercises.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, the model class (`WorkoutPlan`) looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `totalWorkoutDuration` function returns the total duration of the workout
    in seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkoutPlan` has a reference to another class in the preceding definition: `ExercisePlan`.
    It tracks the exercise and the duration of the exercise in a workout, which is
    quite apparent once we look at the definition of `ExercisePlan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These three classes constitute our base model, and we will decide in the future
    whether or not we need to extend this model as we start implementing the app's
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have started with a preconfigured and basic Angular app, you just need
    to understand how this app bootstrapping is occurring.
  prefs: []
  type: TYPE_NORMAL
- en: App bootstrapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 1](part0018.xhtml#H5A42-edca168d36254bda8a21f611a95615c3 "Chapter 1. Getting
    Started"), *Getting Started*, had a good introduction to the app bootstrapping
    process. The app bootstrapping process for *7 Minute Workout* remains the same,
    look at the `src` folder. There is a `bootstrap.ts` file with only the execution
    bit (other than `imports`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `boostrapModule` function call actually bootstraps the application by loading
    the root module, `AppModule`. The process is triggered by this call in `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `System.import` statement sets off the app bootstrapping process by loading
    the first module from `bootstrap.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modules defined in the context of Angular 2, (using `@NgModule` decorator) are
    different from modules SystemJS loads. SystemJS modules are JavaScript modules,
    which can be in different formats adhering to *CommonJS*, *AMD*, or *ES2015* specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Angular modules are constructs used by Angular to segregate and organize its
    artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: Unless the context of discussion is SystemJS, any reference to *module* implies
    *Angular module*.
  prefs: []
  type: TYPE_NORMAL
- en: The next section details how SystemJS loads our Angular app. Remember all references
    to module in the next section are JavaScript module. If you want you can skip
    this section as it does not directly relate to Angular development.
  prefs: []
  type: TYPE_NORMAL
- en: App loading with SystemJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SystemJS starts loading the JavaScript module with the call to `System.import('app')`
    in `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: SystemJS starts by loading `bootstrap.ts` first. The imports defined inside
    `bootstrap.ts` cause SystemJS to then load the imported modules. If these module
    imports have further `import` statements, SystemJS loads them too, recursively.
  prefs: []
  type: TYPE_NORMAL
- en: And finally the `platformBrowserDynamic().bootstrapModule(AppModule);` function
    gets executed once all the imported modules are loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the SystemJS `import` function to work, it needs to know where the modules
    are located. We define this in the file, `systemjs.config.js`, and reference it
    in `index.html`, before the `System.import` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This configuration file contains all of the necessary configuration for SystemJS
    to work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `systemjs.config.js`, the `app` parameter to `System.import` function
    points to a folder `dist` as defined on the `map` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And the next variable, `packages`, contains settings that hint to SystemJS
    how to load a module from a package when no filename/extension is specified. For
    `app`, the default module is `bootstrap.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Are you wondering what the `dist` folder has to do with our application? Well,
    this is where our transpiled scripts end up. As we build our app in TypeScript,
    the TypeScript compiler converts these `.ts` script files in the `src` folder
    to JavaScript modules and deposits them into the `dist` folder. SystemJS then
    loads these compiled JavaScript modules. The transpiled code location has been
    configured as part of the build definition in `gulpfile.js`. Look for this excerpt
    in `gulpfile.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The module specification used by our app can again be verified in `gulpfile.js`.
    Take a look at this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: These are TypeScript compiler options, with one being `module`, that is, the
    target module definition format.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `system` module type is a new module format designed to support the exact
    semantics of ES2015 modules within ES5.
  prefs: []
  type: TYPE_NORMAL
- en: Once the scripts are *transpiled* and the module definitions created (in the
    target format), SystemJS can load these modules and their dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to get into the thick of action; let's build our first component.
  prefs: []
  type: TYPE_NORMAL
- en: Our first component - WorkoutRunnerComponent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To implement the `WorkoutRunnerComponent`, we need to outline the behavior of
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we are going to do in the `WorkoutRunnerComponent` implementation is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the workout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show the workout in progress and show the progress indicator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the time elapses for an exercise, show the next exercise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this process until all the exercises are over.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's start with the implementation. The first thing that we will create is
    the `WorkoutRunnerComponent` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `workout-runner` folder in the `src/components` folder and add a new
    code file called `workout-runner.component.ts` to it. Add this chunk of code to
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `import` module declaration allows us to reference the classes defined in
    the `model.ts` file in `WorkoutRunnerComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to set up the workout data. Let''s do that by adding a constructor
    and related class properties to the `WorkoutRunnerComponent` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `buildWorkout` on `WorkoutRunnerComponent` sets up the complete workout,
    as we will see shortly. We also initialize a `restExercise` variable to track
    even the rest periods as exercise (note that `restExercise` is an object of type
    `ExercisePlan`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `buildWorkout` function is a lengthy function, so it''s better if we copy
    the implementation from the workout runner''s implementation available in Git
    branch checkpoint2.1 ([http://bit.ly/ng2be-2-1-workout-runner-component-ts](http://bit.ly/ng2be-2-1-workout-runner-component-ts)).
    The `buildWorkout` code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This code builds the `WorkoutPlan` object and pushes the exercise data into
    the exercises array (an array of `ExercisePlan` objects), returning the newly
    built workout.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initialization is complete; now, it''s time to actually implement the start
    workout. Add a `start` function to the `WorkoutRunnerComponent` implementation,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then declare the new variables used in the function at the top, with other
    variable declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `workoutTimeRemaining` variable tracks the total time remaining for the
    workout, and `currentExerciseIndex` tracks the currently executing exercise index.
    The call to `startExercise` actually starts an exercise. This is how the code
    for `startExercise` looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by initializing `currentExercise` and `exerciseRunningDuration`. The
    `currentExercise` variable tracks the exercise in progress and `exerciseRunningDuration`
    tracks its duration. These two variables also need to be declared at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We use the `setInterval` JavaScript function with a delay of 1 second (1,000
    milliseconds) to track the exercise progress by incrementing `exerciseRunningDuration`.
    The `setInterval` invokes the callback every second. The `clearInterval` call
    stops the timer once the exercise duration lapses.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**TypeScript Arrow functions** The callback parameter passed to `setInterval`
    (`()=>{...}`) is a **lambda function** (or an **arrow function** in ES 2015).
    Lambda functions are short-form representations of anonymous functions, with added
    benefits. You can learn more about them at [https://basarat.gitbooks.io/typescript/content/docs/arrow-functions.html](https://basarat.gitbooks.io/typescript/content/docs/arrow-functions.html).'
  prefs: []
  type: TYPE_NORMAL
- en: As of now, we have a `WorkoutRunnerComponent` class. We need to convert it into
    an *Angular component* and define the component view. We did something similar
    in [Chapter 1](part0018.xhtml#H5A42-edca168d36254bda8a21f611a95615c3 "Chapter 1. Getting
    Started"), *Getting Started*, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the import for `Component` and a component decorator (highlighted code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There is not much to explain here, as you already know how to create an Angular
    component. You understand the role of the `@Component` decorator, what `selector`
    does, and how the `template` is used.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The JavaScript generated for the `@Component` decorator contains enough metadata
    about the component. This allows Angular framework to instantiate the correct
    component at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Strings enclosed in **backticks** (`` ``) are a new addition to ES2015\. Also
    called **template literals**, such string literals can be multiline and allow
    expressions to be embedded inside (not to be confused with Angular expressions).
    Look at the MDN article here at [http://bit.ly/template-literals](http://bit.ly/template-literals)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding template HTML will render the raw `ExercisePlan` object and the
    exercise time remaining. It has an interesting expression inside the first interpolation:
    `currentExercise | json`. The `currentExercise` property is defined in `WorkoutRunnerComponent`,
    but what about the `|` symbol and what follows it (`json`)? In the Angular 2 world,
    it is called a **pipe**. *The sole purpose of a pipe is to transform/format template
    data*. The `json` pipe here does JSON data formatting. You will learn more about
    pipes later in this chapter, but to get a general sense of what the `json` pipe
    does, we can remove the `json` pipe plus the `|` symbol and render the template;
    we are going to do this next.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw in [Chapter 1](part0018.xhtml#H5A42-edca168d36254bda8a21f611a95615c3
    "Chapter 1. Getting Started"), *Getting Started*, before we can use `WorkoutRunnerComponent`,
    we need to declare it inside a module. Since our app currently has only one module
    (`AppModule`), we add the `WorkoutRunnerComponent` declaration to it. Update `app.module.ts`
    by adding the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `WorkoutRunnerComponent` can be referenced in the root component so that
    it can be rendered. Modify `src/components/app/app.component.ts` as highlighted
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We have changed the root component template and added the `workout-runner` element
    to it. This will render the `WorkoutRunnerComponent` inside our root component.
  prefs: []
  type: TYPE_NORMAL
- en: While the implementation may look complete, there is a crucial piece missing.
    Nowhere in the code do we actually start the workout. The workout should start
    as soon as we load the page.
  prefs: []
  type: TYPE_NORMAL
- en: '**Component life cycle hooks** are going to rescue us!'
  prefs: []
  type: TYPE_NORMAL
- en: Component life cycle hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The life of an Angular component is eventful. Components get created, change
    state during their lifetime, and finally they are destroyed. Angular provides
    some **life cycle hooks/functions** that the framework invokes (on the component)
    when such an event occurs. Consider these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: When component is initialized, Angular invokes `ngOnInit`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a component's input properties change, Angular invokes `ngOnChanges`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a component is destroyed, Angular invokes `ngOnDestroy`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As developers, we can tap into these key moments and perform some custom logic
    inside the respective component.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Angular has TypeScript interfaces for each of these hooks that can be applied
    to the component class to clearly communicate the intent. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The interface name can be derived by removing the prefix `ng` from the function
    names.
  prefs: []
  type: TYPE_NORMAL
- en: The hook we are going to utilize here is `ngOnInit`. The `ngOnInit` function
    gets fired when the component's data-bound properties are initialized but before
    the view initialization starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ngOnInit` function to the `WorkoutRunnerComponent` class with a call
    to start the workout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And implement the `OnInit` interface on `WorkoutRunnerComponent`; it defines
    the `ngOnInit` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of other life cycle hooks, including `ngOnDestroy`, `ngOnChanges`,
    and `ngAfterViewInit`, that components support; but we are not going to dwell
    into any of them here. Look at the developer guide ([http://bit.ly/ng2-lifecycle](http://bit.ly/ng2-lifecycle))
    on *Life Cycle Hooks* to learn more about other such hooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to run our app! Open the command line, navigate to the `trainer` folder,
    and type this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are no compilation errors and the browser automatically loads the
    app (`http://localhost:9000/index.html`), we should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Component life cycle hooks](../Images/image00438.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The model data updates with every passing second! Now you'll understand why
    interpolations (`{{ }}`) are a great debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This will also be a good time to try rendering `currentExercise` without the
    `json` pipe (use `{{currentExercise}}`), and see what gets rendered.
  prefs: []
  type: TYPE_NORMAL
- en: We are not done yet! Wait long enough on the `index.html` page and you will
    realize that the timer stops after 30 seconds. The app does not load the next
    exercise data. Time to fix it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the code inside the `setInterval` `if` condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `if` condition `if (this.exerciseRunningDuration >= this.currentExercise.duration)`
    is used to transition to the next exercise once the time duration of the current
    exercise lapses. We use `getNextExercise` to get the next exercise and call `startExercise`
    again to repeat the process. If no exercise is returned by the `getNextExercise`
    call, the workout is considered complete.
  prefs: []
  type: TYPE_NORMAL
- en: During exercise transitioning, we increment `currentExerciseIndex` only if the
    next exercise is not a rest exercise. Remember that the original workout plan
    does not have a rest exercise. For the sake of consistency, we have created a
    rest exercise and are now swapping between rest and the standard exercises that
    are part of the workout plan. Therefore, `currentExerciseIndex` does not change
    when the next exercise is rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly add the `getNextExercise` function too. Add the function to
    the `WorkoutRunnerComponent` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `WorkoutRunnerComponent.getNextExercise` returns the next exercise that
    needs to be performed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the returned object for `getNextExercise` is an `ExercisePlan` object
    that internally contains the exercise details and the duration for which the exercise
    runs.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation is quite self-explanatory. If the current exercise is rest,
    take the next exercise from the `workoutPlan.exercises` array (based on `currentExerciseIndex`);
    otherwise, the next exercise is rest, given that we are not on the last exercise
    (the `else if` condition check).
  prefs: []
  type: TYPE_NORMAL
- en: With this, we are ready to test our implementation. So go ahead and refresh
    `index.html`. Exercises should flip after every 10 or 30 seconds. Great!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The current build setup automatically compiles any changes made to the script
    files when the files are saved; it also refreshes the browser post these changes.
    But just in case the UI does not update or things do not work as expected, refresh
    the browser window.
  prefs: []
  type: TYPE_NORMAL
- en: If you are having a problem with running the code, look at the Git branch `checkpoint2.1`
    for a working version of what we have done thus far.
  prefs: []
  type: TYPE_NORMAL
- en: Or if you are not using Git, download the snapshot of Checkpoint 2.1 (a ZIP file)
    from [http://bit.ly/ng2be-checkpoint2-1](http://bit.ly/ng2be-checkpoint2-1). Refer
    to the `README.md` file in the `trainer` folder when setting up the snapshot for
    the first time.
  prefs: []
  type: TYPE_NORMAL
- en: We have done enough work on the controller for now, let's build the view.
  prefs: []
  type: TYPE_NORMAL
- en: Building the 7 Minute Workout view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the hard work has already been done while defining the model and implementing
    the component. Now we just need to skin the HTML using the super-awesome data
    binding capabilities of Angular. It's going to be simple, sweet, and elegant!
  prefs: []
  type: TYPE_NORMAL
- en: 'For the *7 Minute Workout* view, we need to show the exercise name, the exercise
    image, a progress indicator, and the time remaining. Copy the `workout-runner.html`
    file from the Git branch `checkpoint2.2`, the `workout-runner` folder (or download
    it from [http://bit.ly/ng2be-2-2-workout-runner-html](http://bit.ly/ng2be-2-2-workout-runner-html)),
    to the corresponding folder locally. The view HTML looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we take a deep dive into the view HTML, we still need to reference the
    view. The `WorkoutRunnerComponent` currently uses an inline template. We need
    to externalize it by pointing to the above HTML file. Update the `workout-runner.component.ts`
    file by replacing the `template` property with property `templateUrl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The decorator property, `templateUrl`, allows us to reference an external file
    for the view HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Inline versus External templates**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We just saw two ways of defining a view template: using `template` (inline)
    and using the `templateUrl` (external) property. Which one is preferred?'
  prefs: []
  type: TYPE_NORMAL
- en: Well, considering the way in which components are envisioned in Angular2, as
    self-contained building blocks, for our app, inline templating makes sense. Everything
    that is required by the component is available in a single file. However, inline
    templates have a disadvantage; formatting HTML becomes difficult and IDE support
    is very limited as the content is treated as a string literal. When we externalize
    HTML, we can develop a template as a normal HTML document.
  prefs: []
  type: TYPE_NORMAL
- en: One possible solution that allows us to have the best of both worlds would be
    to define our HTML templates in separate files during development and reference
    them using the standard `templateUrl` property. But as part of a production release,
    configure the build process to inline the template HTML into the component definition.
  prefs: []
  type: TYPE_NORMAL
- en: Before we understand the Angular pieces in the view, let's just run the app
    again. Save the changes in `workout-runner.component.ts`. If `gulp play` is already
    running, just refresh the page and see the workout app in its full glory!
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the 7 Minute Workout view](../Images/image00439.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We have our basic app running. The exercise image and title show up, the progress
    indicator shows the progress, and exercise transitioning occurs when the exercise
    time lapses. This surely feels great!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are having a problem with running the code, look at the Git branch `checkpoint2.2`
    for a working version of what we have done thus far. You can also download the
    snapshot of `checkpoint2.2` (a zip file) from this GitHub location: [http://bit.ly/ng2be-checkpoint2-2](http://bit.ly/ng2be-checkpoint2-2).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  prefs: []
  type: TYPE_NORMAL
- en: If we look back at the view HTML, we see that other than the styling done using
    *bootstrap* CSS and some custom CSS, there are some interesting Angular pieces
    that need our attention. Also, since everything ties into the Angular binding
    infrastructure, it's time to dig deeper into this infrastructure and explore its
    capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular 2 binding infrastructure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any modern JavaScript framework comes with strong model-view binding support,
    and Angular is no different. The primary aim of any binding infrastructure is
    to reduce the boilerplate code that we need to write to keep the view and the
    model in sync. A robust binding infrastructure is always declarative and terse.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular binding infrastructure allows us to transform a template (raw)
    HTML into a live view that is bound to model data. Based on the binding constructs
    used, data can flow and be synced in both directions: from model to view and view
    to model.'
  prefs: []
  type: TYPE_NORMAL
- en: Angular established a link between the model data on the component and the view
    using the `template` or `templateUrl` property of the `@Component` decorator.
    With the exception of the `script` tag, almost any piece of HTML can act as a
    template for the Angular binding infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: To make this binding magic work, Angular needs to take the view template, compile
    it, link it to the model data, and keep it in sync with model updates without
    the need for any boilerplate synchronization code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the data flow direction, these bindings can be of three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '*One-way binding from model to view*: In model-to-view binding, changes to
    model are kept in sync with the view. Interpolations, property, attribute, class,
    and style bindings fall in this category.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*One-way binding from view to model*: In this category, view changes flow towards
    the model. Event bindings fall in this category.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Two-way/bidirectional binding*: Two-way binding, as the name suggests, keeps
    the view and model in sync. There is a special binding construct used for two-way
    binding, `ngModel`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s understand how to utilize the binding capabilities of Angular to support
    view templatization. Angular provides these binding constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: Interpolations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attribute binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Style binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *7 Minute Workout* view uses some of these constructs, so this is a good
    time to learn about them. **Interpolation** is the first one.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Interpolations** are quite simple. The expression inside the interpolation
    symbols (`{{ }}`) is evaluated in the context of the model (or the component class
    members), and the outcome of the evaluation is embedded in HTML. We have seen
    these all along in [Chapter 1](part0018.xhtml#H5A42-edca168d36254bda8a21f611a95615c3
    "Chapter 1. Getting Started"), *Getting Started*, and in the workout runner view.
    We render the exercise title and the exercise time remaining using interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Remember that interpolations synchronize model changes with the view. This is
    one way of binding from a model to a view.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolations in fact are a special case of property binding, which allows
    us to bind HTML element/custom component properties to a model. We shortly discuss
    how an interpolation can be written using property binding syntax. We can consider
    interpolation as syntactical sugar over property binding.
  prefs: []
  type: TYPE_NORMAL
- en: Property binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Look at this view excerpt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It seems that we are setting the `src` attribute of `img` to an expression that
    gets evaluated at runtime when the app runs. Not true!
  prefs: []
  type: TYPE_NORMAL
- en: What seems to be an **attribute binding** is, in fact, a **property binding**.
    Moreover, since many of us are not aware of the difference between an HTML element's
    *property* and its *attribute*, this statement is very confusing. Therefore, before
    we look at how property bindings work, let's try to grasp the difference between
    an element's *property* and its *attribute*.
  prefs: []
  type: TYPE_NORMAL
- en: Property versus attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Take any DOM element API and you will find *attributes*, *properties*, *functions*,
    and *events*. While events and functions are self-explanatory, it is difficult
    to understand the difference between *properties* and *attributes*. We use these
    words interchangeably, which does not help much either. Take, for example, this
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When the browser creates a DOM element (`HTMLInputElement` to be precise) for
    this input textbox, it uses the `value` attribute on `input` to set the initial
    state of the `input`'s `value` property to `Awesome Angular2`.
  prefs: []
  type: TYPE_NORMAL
- en: Post this initialization, any changes to `input ` `value` property do not reflect
    on the `value` attribute; the attribute always has `Awesome Angular2` (unless
    set explicitly again). This can be confirmed by querying the `input` state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we change the `input` data to `Angular2 rocks!` and query the `input`
    element state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `value` property always returns the current input content, which is `"Angular2
    rocks!"`. Whereas this DOM API function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Returns the `value` attribute, and is always `Awesome Angular2` set initially.
  prefs: []
  type: TYPE_NORMAL
- en: The primary role of an element attribute is to initialize the state of the element
    when the corresponding DOM object is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of other nuances that add to this confusion. These include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Attribute* and *property* synchronization is not consistent across properties.
    As we saw in the preceding example, changes to the `value` *property* on `input`
    do not affect the `value` *attribute*, but this is not true for all property-value
    pairs. The `src` property of an image element is a prime example of this; changes
    to property or attribute value are always kept in sync.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's surprising to learn that the mapping between attributes and properties
    is also not one-to-one. There are a number of properties that do not have any
    backing attribute (such as `innerHTML`), and there are also attributes that do
    not have a corresponding property defined on the DOM (such as `colspan`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Attribute and property mapping too adds to this confusion as it does not follow
    a consistent pattern. An excellent example of this is available in the Angular
    2 developer''s guide, which we are going to reproduce here verbatim:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The `disabled` attribute is another peculiar example. A button''s `disabled`
    property is `false` by default so the button is enabled. When we add the disabled
    attribute, its presence alone initializes the button''s `disabled` property to
    true so the button is disabled. Adding and removing the disabled attribute disables
    and enables the button. The value of the attribute is irrelevant which is why
    we cannot enable a button by writing `<button disabled="false">Still Disabled</button>`.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The aim of this discussion is to make sure that you understand the difference
    between the properties and attributes of a DOM element. This new mental model
    will help you as we continue to explore the framework's property and attribute
    binding capabilities. Let's get back to our discussion on property binding.
  prefs: []
  type: TYPE_NORMAL
- en: Property binding continued...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we understand the difference between a property and an attribute,
    let''s look at the binding example again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `[propertName]` square bracket syntax is used to bind the `img.src` property
    to an Angular expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general syntax for property binding looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the case of property binding, the **target** is a property on the DOM element
    or component. The target can also be an event, as we will see shortly when we
    perform event binding.
  prefs: []
  type: TYPE_NORMAL
- en: Binding source and target
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to understand the difference between source and target in an
    Angular binding.
  prefs: []
  type: TYPE_NORMAL
- en: The property appearing inside [] is a **target**, sometimes called **binding
    target**. The target is the consumer of the data and always refers to a property
    on the component/element. The **source** expression constitutes the data source
    that provides data to the target.
  prefs: []
  type: TYPE_NORMAL
- en: At runtime, the expression is evaluated in the context of the component's/element's
    property (the `WorkoutRunnerComponent.currentExercise.exercise.image` property
    in the preceding case).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Property binding, event binding, and attribute binding do not use the interpolation
    symbol. The following is invalid: `[src]="{{''/static/images/'' + currentExercise.exercise.image}}"`
    If you have worked on Angular 1, property binding to any DOM property allows Angular
    2 to get rid of a number of directives, such as `ng-disable`, `ng-src`, `ng-key*`,
    `ng-mouse*`, and a few others.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Property binding works on component properties too! Components can define input
    and output properties that can be bound to the view, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This hypothetical snippet binds the `exerciseRestDuration` property on the `WorkoutRunnerComponent`
    class to the `restDuration` property defined on the container component (parent),
    allowing us to pass the rest duration as a parameter to the `WorkoutRunnerComponent`.
    As we enhance our app and develop new components, you will learn how to define
    custom properties and events on a component.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can enable property binding using the `bind-` syntax, which is a *canonical
    form* of property binding. This implies that: `[src]="''/static/images/'' + currentExercise.exercise.image"`
    Is equivalent to the following: `bind-src="''/static/images/'' + currentExercise.exercise.image"`'
  prefs: []
  type: TYPE_NORMAL
- en: Property binding, like interpolation, is unidirectional, from the component/element
    source to the view. Changes to the model data are kept in sync with the view.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we concluded the last section by describing interpolation as syntactical
    sugar over property binding, the intent was to highlight how both can be used
    interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interpolation syntax is terser than property binding and hence very useful.
    This is how Angular interprets an interpolation: `<h3>Main heading - {{heading}}</h3>`
    `<h3 [text-content]="'' Main heading - ''+heading"></h3>` Angular translates the
    interpolation in the first statement into the `textContent` property binding (second
    statement).'
  prefs: []
  type: TYPE_NORMAL
- en: While property binding makes it easy for us to bind any expression to the target
    property, we should be careful with the expression we employ. This is also because
    of the fact that Angular's change detection system will evaluate your expression
    binding multiple times during the life cycle of the application, while your component
    is alive. Therefore, while binding an expression to a property target, keep these
    two guidelines in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Quick expression evaluation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A property binding expression should evaluate quickly. Slow evaluation can
    happen when a function is used as an expression. Consider this binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This interpolation binds the return value of `doLotsOfWork` to the `div`. This
    function then gets called every time Angular performs a change detection run,
    which Angular does quite often based on some internal heuristics. Hence it becomes
    imperative that the expressions we use evaluate quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Side-effect-free binding expressions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a function is used in a binding expression, it should be side-effect-free.
    Consider yet another binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And the underlying function, `getContent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getContent` call changes the state of the component by updating the `timesContentRequested`
    property every time it is called. If this property is used in view such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Angular throws errors such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Angular framework works in two modes, *dev* and *production*. If we enable production
    mode in the application, the preceding error does not show up.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the framework documentation at http://bit.ly/enableProdMode for more
    details.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that your expression used inside property binding should
    be side-effect-free.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at some interesting behavior related to the square bracket syntax
    used for property binding. The target specified in `[]` is not limited to a component/element
    property. To understand *target selection*, we need to introduce a new concept: **directives**.
  prefs: []
  type: TYPE_NORMAL
- en: Angular directives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a framework, Angular tries to enhance the HTML **DSL** (short for **Domain-Specific
    Language**).
  prefs: []
  type: TYPE_NORMAL
- en: '*Components* are referenced in HTML using custom tags such as `<workout-runner></workout-runner>`
    (not part of standard HTML constructs). This highlights the first extension point.'
  prefs: []
  type: TYPE_NORMAL
- en: The use of `[]` and `()` for property and event binding defines the second.
  prefs: []
  type: TYPE_NORMAL
- en: And then there is the third one, called **attribute directives**.
  prefs: []
  type: TYPE_NORMAL
- en: 'While components come with their own view, attribute directives are there to
    enhance the appearance and/or behavior of existing elements/components. The `ngStyle`
    directive used in workout-runner''s view is a good example of an attribute directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `ngStyle` directive does not have its own view; instead it allows us to
    set multiple styles on an HTML element using binding expressions. We will be covering
    a number of framework attribute directives later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: There is also another class of directives, called **structural directives**.
    Again, structural directives do not have their own view; they change the DOM layout
    of the elements on which they are applied. The `ngFor` and `ngIf` directives fall
    into this category. We dedicate a complete section later in the chapter to understanding
    these structural directives.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Directive nomenclature**'
  prefs: []
  type: TYPE_NORMAL
- en: '"Directives" is an umbrella term used for component directives (also known
    as components), attribute directives, and structural directives. Throughout the
    book, when we use the term "directive," we will be referring to either an attribute
    directive or a structural directive depending on the context. Component directives
    are always referred to as *components*.'
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding of the different types of directives that Angular has,
    we can comprehend the process of target selection for binding.
  prefs: []
  type: TYPE_NORMAL
- en: Target selection for binding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As described earlier, the target specified in `[]` is not limited to a component/element
    property. While the property name is a common target, the Angular templating engine
    actually does a heuristics to decide the target type. Angular first searches the
    registered known directives (*attribute* or *structural*) that have matching selectors
    before looking for a property that matches the target expression. Consider this
    view fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The search starts for a directive having selector `ngStyle` first. Since Angular
    already has an `ngStyle` directive, it becomes the target. If Angular did not
    have a built-in `ngStyle` directive, the binding engine would have looked for
    a property called `ngStyle` on the underlying component.
  prefs: []
  type: TYPE_NORMAL
- en: If the nothing matches the target expression, an *unknown directive* error is
    thrown.
  prefs: []
  type: TYPE_NORMAL
- en: That covers most of Angular's property binding capabilities. Next, let's look
    at attribute binding and understand what role it plays.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The only reason attribute binding exists in Angular is that there are HTML attributes
    that do not have a backing DOM property. The `colspan` and `aria` attributes are
    some good examples of attributes without backing properties. The progress bar
    div in our view uses attribute binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'It may seem that we can use standard interpolation syntax to set an attribute,
    but that does not work! Open `workout-runner.html` and replace the two aria attributes
    `attr.aria-valuenow` and `attr.aria-valuemax` enclosed in [], with this highlighted
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Save and refresh the page. Then, Angular will throw an interesting error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Angular is trying to search for a property called `ariaValuenow` in the `div`
    that does not exist! Remember, interpolations are actually property binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'We hope that this gets the point across: *to bind to an attribute, use attribute
    binding*.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Angular binds to properties by default and not to attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support attribute binding, Angular uses a prefix notation, `attr`, within
    `[]`. An attribute binding looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Revert to the original aria setup to make attribute binding work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that unless an explicit `attr.` prefix is attached, attribute binding
    does not work.
  prefs: []
  type: TYPE_NORMAL
- en: While we have not used style- and class-based binding in our workout view, these
    are some binding capabilities that can come in handy. Hence, they are worth exploring.
  prefs: []
  type: TYPE_NORMAL
- en: Style and class binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use **class binding** to set and remove a specific class based on the component
    state, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This adds `class-name` when `expression` is `true` and removes it when it is
    `false`. A simple example can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Use **style bindings** to set inline styles based on the component state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'While we have used the `ngStyle` While we have used the ngStyle directive for
    the workout view, we could have easily used *style binding* as well, as we are
    dealing with a single style. With style binding, the same `ngStyle` expression
    would become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`width` is a style, and since it takes units too, we extend our target expression
    to include the `%` symbol.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that `style.` and `class.` are convenient bindings for setting a single
    class or style. For more flexibility, there are corresponding attribute directives:
    `ngClass` and `ngStyle`. It''s time now to formally introduce you to attribute
    directives.'
  prefs: []
  type: TYPE_NORMAL
- en: Attribute directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attribute directives are HTML extensions that change the behavior of a component/element.
    As described in the section on *Angular directives*, these directives do not define
    their own view.
  prefs: []
  type: TYPE_NORMAL
- en: Other than `ngStyle` and `ngClass` directives, there are a few more attribute
    directives that are part of the core framework. `ngValue`, `ngModel`, `ngSelectOptions`,
    `ngControl`, and `ngFormControl` are some of the attribute directives Angular
    provides.
  prefs: []
  type: TYPE_NORMAL
- en: While the next section is dedicated to learning how to use the `ngClass` and
    `ngStyle` attribute directives, it is not until [Chapter 6](part0066.xhtml#aid-1UU542
    "Chapter 6.  Angular 2 Directives in Depth"), *Angular 2 Directives in Depth*,
    that we learn how to create our own attribute directives.
  prefs: []
  type: TYPE_NORMAL
- en: Styling HTML with ngClass and ngStyle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular has two excellent directives that allow us to dynamically set styles
    on any element and toggle CSS classes. For the bootstrap progress bar, we use
    the **ngStyle** directive to dynamically set the element''s style, `width`, as
    the exercise progresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`ngStyle` allows us to bind one or more styles to component properties at once.
    It takes an object as a parameter. Each property name on the object is the style
    name, and the value is the Angular expression bound to that property, such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The styles can not only bind to component properties (`componentWidth` and `componentHeight`
    above) but also be set to a constant value (`larger`). The expression parser also
    allows the use of the ternary operator (`?:`); check out `isRequired`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If styles become unwieldy in HTML, we also have the option of writing in our
    component a function that returns the object hash, and setting that as an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, `getStyles` on the component looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ngClass` too works on the same lines, except that it is used to toggle
    one or multiple classes. For example, check out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `required` class is applied when `inputRequired` is true, and is removed
    when it evaluates to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Directives (custom or platform), like components, have to be registered on a
    module before they can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Well! That covers everything we had to explore for our newly developed view.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: And as described earlier, if you are having a problem with running the code,
    look at the Git branch `checkpoint2.2`.
  prefs: []
  type: TYPE_NORMAL
- en: If not using Git, download the snapshot of `checkpoint2.2` (a zip file) from
    [http://bit.ly/ng2be-checkpoint2-2](http://bit.ly/ng2be-checkpoint2-2). Refer
    to the `README.md` file in the `trainer` folder when setting up the snapshot for
    the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Time to add some enhancement and learn a bit more about the framework!
  prefs: []
  type: TYPE_NORMAL
- en: To start with, we are going to create a new module dedicated to workout runner.
    Everything that related to workout runner, including `WorkoutRunnerComponent`,
    goes into this module. This gives us a great opportunity to revisit Angular modules
    in great details.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Angular modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the *7 Minute Workout* app grows and we add new components/directives/pipes/other
    artifacts to it, a need arises to organize these items. Each of these items needs
    to be part of an Angular module.
  prefs: []
  type: TYPE_NORMAL
- en: A naÃ¯ve approach would be to declare everything in our app's root module (`AppModule`),
    as we did with `WorkoutRunnerComponent`, but this defeats the whole purpose of
    Angular modules.
  prefs: []
  type: TYPE_NORMAL
- en: To understand why a single-module approach is never a good idea, let's revisit
    Angular modules.
  prefs: []
  type: TYPE_NORMAL
- en: Comprehending Angular modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Angular, **modules** are a way to organize code into chunks that belong together
    and work as a cohesive unit. Modules are Angular's way of grouping and organizing
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'An Angular module primarily defines:'
  prefs: []
  type: TYPE_NORMAL
- en: The components/directives/pipes it owns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The components/directives/pipes it makes public for other modules to consume
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other modules that it depends on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services that the module wants to make available application wide
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any decent-sized Angular app will have modules interlinked with each other: some
    modules consuming artifacts from other, some providing artifacts to others, and
    some modules doing both.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a standard practice, module segregation is *feature-based*. One divides
    the app into features or sub features (for large features) and modules are created
    for each of the features. Even the framework adheres to this guideline as all
    of the framework constructs are divided across modules:'
  prefs: []
  type: TYPE_NORMAL
- en: There is the omnipresent `BrowserModule` that aggregates the standard framework
    constructs used in every browser-based Angular app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is the `RouterModule` if we want to use the Angular routing framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is the `HtppModule` if our app needs to communicate with the server over
    HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular modules are created by applying the `@NgModule` decorator to a TypeScript
    class, something we learned in [Chapter 1](part0018.xhtml#H5A42-edca168d36254bda8a21f611a95615c3
    "Chapter 1. Getting Started"), *Getting Started*. The decorator definition exposes
    enough metadata allowing Angular to load everything the module refers to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The decorator has multiple attributes that allow us to define:'
  prefs: []
  type: TYPE_NORMAL
- en: External dependencies (using `imports`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module artifacts (using `declarations`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module exports (using `exports`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The services defined inside the module that need to be registered globally (using
    `providers`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This diagram highlights the internals of a module and how they link to each
    other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Comprehending Angular modules](../Images/image00440.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We hope one thing is clear from all this discussion: creating a single application-wide
    module is not the right use of Angular modules, unless you are building something
    rudimentary.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new module to 7 Minute Workout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to add more modules to *7 Minute Workout* too (hey, we do what
    we preach!). To start with, we are going to create a new module, `WorkoutRunnerModule`,
    and declare the `WorkoutRunnerComponent` in it. Henceforth, every component/directive/pipe
    we create specifically for workout execution goes into `WorkoutRunnerModule`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `workout-runner.module.ts`, inside the `workout-runner`
    folder, and add this module definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The module looks similar to `AppModule`. Interestingly, `WorkoutRunnerComponent`
    is a part of both module declarations and exports. Without the export, we cannot
    use `WorkoutRunnerComponent` outside `WorkoutRunnerModule`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Only an exported component/directive/pipe can be used across modules.
  prefs: []
  type: TYPE_NORMAL
- en: '`BrowserModule` is the module that we import often. The `BrowserModule` module
    declares all the common framework directives (such `NgIf`, `NgFor`, and others),
    pipes, and services that any browser-based app requires.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have `WorkoutRunnerModule`, we need to reference this module in
    `AppModule` and remove any direct references to `WorkoutRunnerComponent` in `AppModule`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `app.module.ts` and remove the import and declaration specific to `WorkoutRunnerComponent`.
    Next, import the `WorkoutRunnerModule` by appending it to the existing module
    imports and add the necessary import references. See the highlighted code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: And we are good to go! Behaviorally nothing has changed, but we are now a bit
    more organized.
  prefs: []
  type: TYPE_NORMAL
- en: Are you wondering what happens if we leave the `WorkoutRunnerComponent` declaration
    in `AppModule` too? Remember, `WorkoutRunnerModule` also declares `WorkoutRunnerComponent`.
    Let's try. Go ahead; add `WorkoutRunnerComponent` back to the `AppModule` `declarations`
    section and run the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application throws this error in the browser console:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Type WorkoutRunnerComponent is part of the declarations of 2 modules: WorkoutRunnerModule
    and AppModule! Please consider moving WorkoutRunnerComponent to a higher module
    that imports WorkoutRunnerModule and AppModule. You can also create a new NgModule
    that exports and includes WorkoutRunnerComponent then import that NgModule in
    WorkoutRunnerModule and AppModule.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This leads to very important conclusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A component/directive/pipe can only belong to a single module.*'
  prefs: []
  type: TYPE_NORMAL
- en: We are not allowed to re-declare a component once it is a part of a module.
    To use a component that is a part of a specific module, we should import the respective
    module instead of re-declaring the component.
  prefs: []
  type: TYPE_NORMAL
- en: Importing dependencies through modules presents another challenge too. Circular
    dependency is not allowed. `ModuleA` cannot import `ModuleB` if `ModuleB` already
    imports `ModuleA`. This can happen if `ModuleA` wants to use some component from
    `ModuleB` and at the same time `ModuleB` is dependent on a component from `ModuleA`.
  prefs: []
  type: TYPE_NORMAL
- en: In such a case, as the preceding error describes, the common dependency should
    be moved into another Angular module, `ModuleC`, and both the modules, `ModuleA`
    and `ModuleB`, should reference it.
  prefs: []
  type: TYPE_NORMAL
- en: That is enough on Angular modules for now. Let's add some more enhancements
    to the app.
  prefs: []
  type: TYPE_NORMAL
- en: Learning more about an exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For people who are doing this workout for the first time, it will be good to
    detail the steps involved in each exercise. We can also add references to some
    YouTube videos for each exercise to help the user understand the exercise better.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to add the exercise description and instructions in the left panel
    and call it the **description panel**. We will add a reference to YouTube videos
    in the right panel, which is **the video panel**. To make things more modular
    and learn some new concepts, we are going to create independent components for
    each description panel and video panel.
  prefs: []
  type: TYPE_NORMAL
- en: The model data for this is already available. The `description` and `procedure`
    properties in the `Exercise` class (see `model.ts`) provide the necessary details
    about the exercise. The `videos` array contains some related YouTube video IDs,
    that will be used to fetch these videos.
  prefs: []
  type: TYPE_NORMAL
- en: Adding descriptions and video panels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An Angular app is nothing but a hierarchy of components, similar to a tree
    structure. As of now, *7 Minute Workout* has two components, the root component,
    `TrainerAppComponent`, and its child, `WorkoutRunnerComponent`, in line with the
    HTML component layout, which now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We are going to add two new components to `WorkoutRunnerComponent`, one each
    to support the exercise description and exercise videos. While we could have added
    some HTML directly to the `WorkoutRunnerComponent` view, what we are hoping here
    is to learn a bit more about cross-component communication. Let's start with adding
    the description panel on the left and understand how a component can accept inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Providing component inputs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a folder called `exercise-description` (inside the `components/workout-runner`
    folder) and add a new file, `exercise-description.component.ts` to it. Add this
    piece of code to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Before we discuss the role of the `@Input` decorator, let's integrate the component
    into `WorkoutRunnerComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the corresponding view HTML, `exercise-description.html`, from the Git
    branch `checkpoint2.3`, folder `workout-runner/exercise-description` (GitHub location:
    [http://bit.ly/ng2be-2-3-exercise-description-html](http://bit.ly/ng2be-2-3-exercise-description-html)).
    To understand the role of `@Input`, let''s highlight the relevant parts of the
    `exercise-description` HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding interpolation refers to the input properties of the `ExerciseDescriptionComponent`:
    `description` and `steps`. The `@Input` decorator signifies that the component
    property is available for view binding.'
  prefs: []
  type: TYPE_NORMAL
- en: The component definition is complete. Now, we just need to reference `ExerciseDescriptionComponent`
    in `WorkoutRunnerComponent` and provide values for `description` and `steps` for
    the `ExerciseDescriptionComponent` view to render correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkoutRunnerComponent` can use `ExerciseDescriptionComponent` only if:'
  prefs: []
  type: TYPE_NORMAL
- en: Either `ExerciseDescriptionComponent` is registered with the module that `WorkoutRunnerComponent`
    belongs to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or `ExerciseDescriptionComponent` has been imported (using `imports`) from another
    module into the module that `WorkoutRunnerComponent` belongs to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this case, we are going to register `ExerciseDescriptionComponent` with
    `WorkoutRunnerModule`, which already has `WorkoutRunnerComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `workout-runner.module.ts` and append `ExerciseDescriptionComponent` to
    the `declarations` array. Check out the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use `ExerciseDescriptionComponent`. Open `workout-runner.html` and
    update the HTML fragments as highlighted in the following code. Add a new div
    called `description-panel` before the `exercise-pane` div and adjust some styles
    on `exercise-pane` div, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that `gulp play` is running and refresh the page. The description
    panel should show up on the left with the relevant exercise details.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the `exercise-description` declaration in the preceding view. We are
    referring to the `description` and `steps` properties in the same manner as we
    did with the HTML element properties earlier in the chapter (`<img [src]='expression'
    ...`). Simple, intuitive, and very elegant!
  prefs: []
  type: TYPE_NORMAL
- en: The Angular data binding infrastructure makes sure that whenever the `currentExercise.exercise.description`
    and `currentExercise.exercise.procedure` properties on `WorkoutRunnerComponent`
    change, the bound properties on `ExerciseDescriptionComponent`, `description`
    and `steps`, are also updated .
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `@Input` decoration can take a **property alias** as a parameter, which
    means the following; consider a property declaration such as this: `@Input("myAwesomeProperty")
    myProperty:string;`'
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be referenced in the view as follows: `<my-component [myAwesomeProperty]="expression"....`'
  prefs: []
  type: TYPE_NORMAL
- en: The power of the Angular binding infrastructure allows us to use any component
    property as a bindable property by attaching the `@Input` decorator (and `@Output`
    too) to it. We are not limited to basic data types such as `string`, `number`,
    and `boolean`; there can be complex objects too, which we will see next as we
    add the video panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy `video-player.component.ts` and `video-player.html` from the Git branch
    `checkpoint2.3` folder in `trainer/src/components/workout-runner/video-player`
    (GitHub location: http://bit.ly/ng2be-2-3-video-player).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the implementation for a video player. Open `video-player.component.ts`
    and check out the `VideoPlayerComponent` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `videos` input property here takes an array of strings (YouTube video codes).
    While we take the `videos` array as input, we do not use this array directly in
    video player view; instead we transform the input array into a new array of `safeVideoUrls`
    and bind it. This can be confirmed by looking at the view implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The view uses a new Angular directive called `ngFor` to bind to the `safeVideoUrls`
    array. The `ngFor` directive belongs to a class of directives called *structural
    directives*. The directive's job is to take an HTML fragment and regenerate it
    based on the number of elements in the bound collection.
  prefs: []
  type: TYPE_NORMAL
- en: If you are confused about how the `ngFor` directive works with `safeVideoUrls`
    and why we need to generate `safeVideoUrls` instead of using the `videos` input
    array, wait for a while as we are shortly going to address these queries. But
    let's first complete the integration of `VideoPlayerComponent` with `WorkoutRunnerComponent`
    to see the final outcome.
  prefs: []
  type: TYPE_NORMAL
- en: As we did with the `ExerciseDescriptionComponent`, we need to add `VideoPlayerComponent`
    to `WorkoutRunnerModule` as well. We will leave this exercise to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, update the `WorkoutRunnerComponent` view by adding the component declaration
    after the `exercise-pane` div:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The `VideoPlayerComponent`'s `videos` property binds to the exercise's videos
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: Start/refresh the app and the video thumbnails should show up on the right.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are having a problem with running the code, look at the Git branch `checkpoint2.3`
    for a working version of what we have done thus far.
  prefs: []
  type: TYPE_NORMAL
- en: You can also download the snapshot of `checkpoint2.3` (a zip file) from [http://bit.ly/ng2be-checkpoint2-3](http://bit.ly/ng2be-checkpoint2-3).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to go back and look at the parts of the `VideoPlayerComponent`
    implementation that we skipped earlier. We specifically need to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: How the `ngFor` directive works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why there is a need to transform the input `videos` array into `safeVideoUrls`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The significance of the Angular component life cycle event `OnChanges`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To start with it's time to formally introduce the `ngFor` and the class of directives
    it belongs to: *structural directives*.
  prefs: []
  type: TYPE_NORMAL
- en: Structural directives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The third categorization of directives, **structural directives**, work on the
    components/elements to manipulate their layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular documentation describes structural directives in a succinct manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Instead of defining and controlling a view like a Component Directive, or
    modifying the appearance and behavior of an element like an Attribute Directive,
    the Structural Directive manipulates the layout by adding and removing entire
    element sub-trees.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Since we have already touched upon *component directives* (such as `workout-runner`
    and `exercise-description`) and *attribute directives* (such as `ngClass` and
    `ngStyle`), we can very well contrast their behaviors against *structural directives*.
  prefs: []
  type: TYPE_NORMAL
- en: The `ngFor` directive belongs to this class. We can identify such directives
    by the `*` prefix. Other than `ngFor`, Angular comes with some other structural
    directives such as `ngIf` and `ngSwitch`.
  prefs: []
  type: TYPE_NORMAL
- en: The ever-so-useful NgFor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every templating language has constructs that allow the templating engine to
    generate HTML (by repetition). Angular has **ngFor**. The ngFor directive is a
    super useful directive used to duplicate a piece of an HTML fragment *n* number
    of times.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code repeats the div fragment for each exercise video (using
    the `videos` array). The `let video of videos` string expression is interpreted
    as follows: take each video in the videos array and assign it to a **template
    input variable**, `video`. This input variable can now be referenced inside the
    `ngFor` template HTML, as we do when we set the `src` property binding.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide more details about the iteration context, the `ngFor` directive
    provides an optional `index` that increases from 0 to the length of the array
    for each iteration, something similar to a `for` loop, which we all are familiar
    with. This `index` too can be captured into a *template input variable* and used
    inside the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Other than `index`, there is some more iteration context information available,
    which includes `first`, `last`, `even`, and `odd`. This information can come in
    handy as we can do some nifty stuff with it. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: It applies a `special` class to the first video `div`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ngFor` directive can be applied to HTML elements as well as our custom
    components. This is a valid use of ngFor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `*` prefix is a terser format to represent a structural directive. In reality,
    the `ngFor` directive used with the preceding `videos` array expands to: `<template
    ngFor let-video [ngForOf]="videos">` `<div>` `<iframe width="330" height="220"`
    `[src]="''//www.youtube.com/embed/'' + video" ...>` `</iframe>` `</div>` `</template>` 
    The `template` tag has a declaration for `ngFor`, a *template input variable*
    (`video`), and a property (`ngForOf`) that points to the `videos` array.'
  prefs: []
  type: TYPE_NORMAL
- en: NgFor performance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since `NgFor` generates HTML-based on collection elements, it is notorious for
    causing performance issues. But we cannot blame the directive. It does what it
    is supposed to do: iterate and generate elements! UI rendering performance can
    take a hit if the backing collection is huge or there is repeated re-rendering
    of DOM due to the bound collection changing often.
  prefs: []
  type: TYPE_NORMAL
- en: One of the performance tweaks for `NgFor` allows us to alter the behavior of
    this directive when it comes to creating and destroying DOM elements (when the
    underlying collection elements are added or removed).
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a scenario where we frequently get an array of objects from the server
    and bind it to the view using `NgFor`. The default behavior of `NgFor` is to regenerate
    the DOM every time we refresh the list (since Angular does a standard object equality
    check). However, as developers, we may very well know not much has changed. Some
    new objects may have been added, some removed, and maybe some modified. But Angular
    just regenerates the complete DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'To alleviate this situation, Angular allows us to specify a custom **tracking
    function**, which lets Angular know when two objects being compared are equal.
    Have a look at the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: A function such as this can be used in the `NgFor` template to tell Angular
    to compare the *user* object based on its `id` property instead of doing a reference
    equality check.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we then use the preceding function in the `NgFor` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '`NgFor` *will now avoid recreating DOM for users with IDs already rendered.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember, Angular may still update the existing DOM elements if the bound
    properties of a user* *have changed.*'
  prefs: []
  type: TYPE_NORMAL
- en: That's enough on the `ngFor` directive; let's move ahead.
  prefs: []
  type: TYPE_NORMAL
- en: We still need to understand the role of the `safeVideoUrls` and the `OnChange`
    life cycle event in the `VideoPlayerComponent` implementation. Let's tackle the
    former first and understand the need for `safeVideoUrls`.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The easiest way to understand why we need to bind to `safeVideoUrls` instead
    of the `videos` input property is by trying it out. Replace the existing `ngFor`
    fragment HTML with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'And look at the browsers console log (a page refresh may be required). There
    are a bunch of errors thrown by the framework, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Error: unsafe value used in a resource URL context (see http://g.co/ng/security#xss)**'
  prefs: []
  type: TYPE_NORMAL
- en: No prize for guessing what is happening! Angular is trying to safeguard our
    application against a *Cross-Site Scripting (XSS)* attack.
  prefs: []
  type: TYPE_NORMAL
- en: Such an attack enables the attacker to inject malicious code into our web pages.
    Once injected, the malicious code can read data from the current site context.
    This allows it to steal confidential data and also impersonate the logged-in user,
    hence gaining access to privileged resources.
  prefs: []
  type: TYPE_NORMAL
- en: Angular has been designed to block these attacks by sanitizing any external
    code/script that is injected into an Angular view. Remember, content can be injected
    into a view through number of mechanisms, including *property/attribute/style
    bindings* or *interpolation*.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolations escape any content that we bind to them.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `innerHTML` property of an HTML element (*property binding*),
    while the HTML content is emitted, any unsafe content (*script*) embedded in the
    HTML is stripped. We will shortly see an example of it when we format the exercise
    steps as HTML instead of plain text.
  prefs: []
  type: TYPE_NORMAL
- en: But what about *Iframes*? In our preceding example, Angular is blocking property
    binding to Iframe's `src` property too. This is a warning against third-party
    content being embedded in our own site using Iframe. Angular prevents this too.
  prefs: []
  type: TYPE_NORMAL
- en: 'All in all, the framework defines four security contexts around content sanitization.
    These include:'
  prefs: []
  type: TYPE_NORMAL
- en: HTML content sanitization, when HTML content is bound using the `innerHTML`
    property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Style sanitization, when binding CSS into the `style` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: URL sanitization, when URLs are used with tags such as `anchor` and `img.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resource sanitization when using `Iframes` or `script` tag. In this case, content
    cannot be sanitized and hence it is blocked by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Angular is trying its best to keep us out of danger. But at times, we know that
    the content is safe to render and hence want to circumvent the default sanitization
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Trusting safe content
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To let Angular know that the content being bound is safe, we use the **DomSanitizer** and
    call the appropriate method based on the security contexts just described. The
    available functions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bypassSecurityTrustHtml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bypassSecurityTrustScript`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bypassSecurityTrustStyle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bypassSecurityTrustUrl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bypassSecurityTrustResourceUrl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our video player implementation, we use `bypassSecurityTrustResourceUrl`;
    it converts the video URL into a trusted `SafeResourceUrl` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The `map` method transforms the videos array into a collection of `SafeResourceUrl`
    objects and assigns it to `safeVideoUrls`.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the methods listed previously takes a *string parameter*. This is the
    content we want Angular to know is safe. The return object, which could be any
    of `SafeStyle`, `SafeHtml`, `SafeScript`, `SafeUrl`, or `SafeResourceUrl`, can
    then be bound to the view.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A comprehensive treatment of this topic is available in the framework security
    guide available at http://bit.ly/ng2-security. A highly recommended read!
  prefs: []
  type: TYPE_NORMAL
- en: 'The last question to answer is: why do this in the `OnChanges` Angular life
    cycle event?'
  prefs: []
  type: TYPE_NORMAL
- en: '*The* `OnChanges` *life cyle event is triggered whenever the component''s inputs
    change*. In the case of `VideoPlayerComponent`, it is the `videos` array input
    property. We use this life cycle event to recreate the `safeVideoUrls` array and
    re-bind it to the view. Simple!'
  prefs: []
  type: TYPE_NORMAL
- en: Video panel implementation is now complete. Let's add a few more minor enhancements
    and explore a bit more in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting exercise steps with innerHTML binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the sore points in the current app is the formatting of the exercise
    steps. It's a bit difficult to read these steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps should either have a line break (`<br>`) or be formatted as an HTML
    `list` for easy readability. This seems to be a straightforward task, and we can
    just go ahead and change the data that is bounded to the step interpolation, or
    write a pipe that can add some HTML formatting using the line delimiting convention
    (`.`). For a quick verification, let''s update the first exercise steps in `workout-runner.component.ts`
    by adding a break (`<br>`) after each line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now refresh the workout page. The output does not match our expectations, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Formatting exercise steps with innerHTML binding](../Images/image00441.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The break tags were literally rendered in the browser. Angular did not render
    the interpolation as HTML; instead, it escaped the HTML characters, and we know
    why!
  prefs: []
  type: TYPE_NORMAL
- en: How to fix it? Easy! Replace the interpolation with the property binding to
    bind step data to the element's `innerHTML` property (in `exercise-description.html`),
    and you are done!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Refresh the workout page to confirm.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Preventing Cross-Site Scripting Security (XSS) issues**'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed earlier, Angular by default sanitizes the input HTML when injected
    dynamically. This safeguards our app against XSS attacks. Still if you want to
    dynamically inject styles/script into HTML, use the **DomSanitizer** to bypass
    this sanitization check.
  prefs: []
  type: TYPE_NORMAL
- en: Time for another enhancement! It's time to learn about Angular pipes.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the remaining workout duration using pipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It will be nice if we can tell the user the time left to complete the workout
    and not just the duration of the exercise in progress. We can add a countdown
    timer somewhere in the exercise pane to show the overall time remaining.
  prefs: []
  type: TYPE_NORMAL
- en: The approach that we are going to take here is to define a component property
    called `workoutTimeRemaining`. This property will be initialized with the total
    time at the start of the workout, and will reduce with every passing second until
    it reaches zero. Since `workoutTimeRemaining` is a numeric value but we want to
    display a timer in the `hh:mm:ss` format, we need to make a conversion between
    the seconds' data and the time format. **Angular pipes** are a great option for
    implementing such a feature.
  prefs: []
  type: TYPE_NORMAL
- en: Angular pipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The primary aim of a pipe is to format the value of an expression displayed
    in the view. The framework comes with multiple predefined pipes, such as `date`,
    `currency`, `lowercase`, `uppercase`, and others. This is how we use a pipe in
    a view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'An expression is followed by the *pipe symbol* (`|`), which is followed by
    the pipe name and then an optional parameter (`inputParam1`) separated by a colon
    (`:`). If the pipe takes multiple inputs, they can be placed one after another
    separated by a colon, like the inbuilt `slice` pipe, which can slice an array
    or string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter passed to the filter can be a constant or a property from the
    underlying component, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples of the use of the `date` pipe, as described in the Angular
    `date` documentation. Assume that `dateObj` is initialized to June 15, 2015 21:43:11
    and locale is *en-US*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the most commonly used pipes are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**date**: As we just saw, the date filter is used to format the date in a specific
    manner. This filter supports quite a number of formats and is locale-aware too.
    To know about the other formats supported by the date pipe, check out the framework
    documentation at [http://bit.ly/ng2-date](http://bit.ly/ng2-date).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**uppercase** and **lowercase**: These two pipes, as the name suggests, change
    the case of the string input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**decimal** and **percent**: `decimal` and `percent` pipes are there to format
    decimal and percentage values based on the current browser locale.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**currency**: This is used to format numeric values as a currency based on
    the current browser locale.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '**json**: This is a handy pipe for debugging that can transform any input into
    a string using `JSON.stringify`. We made good use of it at the start of this chapter
    to render the `WorkoutPlan` object (see the Checkpoint 2.1 code).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another really powerful feature of pipes is that they can be chained, wherein
    the output from one pipe can serve as the input to another pipe. Consider this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The first pipe slices the first 20 characters of `fullName` and the second pipe
    transforms them to uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen what pipes are and how to use them, why not implement
    one for *7 Minute Workout* app: a **seconds to time** pipe?
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a custom pipe - SecondsToTimePipe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SecondsToTimePipe` converts a numeric value into the `hh:mm:ss` format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `seconds-to-time.pipe.ts` in the `workout-runner` folder
    and add the following pipe definition (the definition can also be downloaded from
    the Git branch `checkpoint.2.4` on the GitHub site at [http://bit.ly/ng2be-2-4-seconds-to-time-pipe-ts](http://bit.ly/ng2be-2-4-seconds-to-time-pipe-ts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: In an Angular pipe, the implementation logic goes into the `transform` function.
    Defined as part of the `PipeTransform` interface, the preceding `transform` function
    transforms the input seconds' value into an *hh:mm:ss* string. The first parameter
    to the `transform` function is the pipe input. The subsequent parameters, if provided,
    are the arguments to pipe, passed using colon separator (`pipe:argument1:arugment2..`)
    from the view. We do not make use of any pipe argument as the implementation does
    not require it.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation is quite straightforward, as we convert seconds into hours,
    minutes, and seconds. Then we concatenate the result into a string value and return
    the value. The addition of 0 on the left for each of the `hours`, `minutes`, and
    `seconds` variables is done to format the value with a leading 0 in case the calculated
    value for hours, minutes, or seconds is less than 10.
  prefs: []
  type: TYPE_NORMAL
- en: The pipe that we just created is a standard TypeScript class. Unless we apply
    the `@Pipe` decorator to it, it does not qualify as an Angular pipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the necessary `import` statement and the `@Pipe` decorator to the `seconds-to-time.pipe.ts`
    file just before the class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The pipe definition is complete, but before we can use `SecondsToTimePipe` in
    `WorkoutRunnerComponent`, the pipe needs to be declared in `WorkoutRunnerModule`.
    This is something we did for `ExerciseDescriptionComponent` and `VideoPlayerComponent`
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `workout-runner.module.ts`, and add the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we just need to add the pipe in the view. Update `workout-runner.html`
    by adding the highlighted fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Surprisingly the implementation is still not complete! We have a pipe definition,
    and we have referenced it in the view, but `workoutTimeRemaining` needs to update
    with each passing second for `SecondsToTimePipe` to be of any use.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already initialized the `WorkoutRunnerComponent`''s `workoutTimeRemaining`
    property in the `start` function with the total workout time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the question is: how to update the `workoutTimeRemaining` variable with
    each passing second? Remember that we already have a `setInterval` setup that
    updates `exerciseRunningDuration`. While we can write another `setInterval` implementation
    for `workoutTimeRemaining`, it will be better if a single `setInterval` setup
    can take care of both the requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a function called `startExerciseTimeTracking` to `WorkoutRunnerComponent`;
    it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the primary purpose of the function is to track the exercise
    progress and flip the exercise once it is complete. However, it also tracks `workoutTimeRemaining`
    (it decrements this counter). The first `if` condition setup just makes sure that
    we clear the timer once all the exercises are done. The inner `if` conditions
    are used to keep `currentExerciseIndex` in sync with the running exercise.
  prefs: []
  type: TYPE_NORMAL
- en: This function uses an instance variable called `exerciseTrackingInterval`. Add
    it to the class declaration section. We are going to use this variable later to
    implement an exercise pausing behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Remove the complete `setInterval` setup from `startExercise` and replace it
    with a call to `this.startExerciseTimeTracking();`. We are all set to test our
    implementation. Refresh the browser and verify the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing a custom pipe - SecondsToTimePipe](../Images/image00442.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The next section is about another inbuilt Angular directive, `ngIf`, and another
    small enhancement.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the next exercise indicator using ngIf
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It will be nice for the user to be told what the next exercise is during the
    short rest period between exercises. This will help them prepare for the next
    exercise. So let's add it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this feature, we can simply output the title of the next exercise
    in line from the `workoutPlan.exercises` array. We show the title next to the
    `Time Remaining` countdown section. Change the workout div (`class="workout-display-div"`)
    to include the highlighted content, and remove `Time Remaining` `h1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: We wrap the existing `Time Remaining h1` and add another `h3` tag to show the
    next exercise inside a new `div` with some style updates. Also, there is a new
    directive, `ngIf`, in the second `h3`. The `*` prefix implies that it belongs
    to the same set of directives that `ngFor` belongs: structural directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **ngIf** directive is used to add or remove a specific section of the DOM
    based on whether the expression provided to it returns `true` or `false`. The
    DOM element is added when the expression evaluates to `true` and destroyed otherwise.
    Isolate the `ngIf` declaration from the preceding view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The expression then checks whether we are currently at the rest phase and the
    directive accordingly shows or hides the linked `h3`.
  prefs: []
  type: TYPE_NORMAL
- en: Other than this, in the same `h3`, we have an interpolation that shows the name
    of the exercise from the `workoutPlan.exercises` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'A word of caution here: `ngIf` adds and destroys the DOM element, and hence
    it is not similar to the visibility constructs that we employed to show and hide
    elements. While the end result of `style`, `display:none` is the same as that
    of `ngIf`, the mechanism is entirely different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Versus this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: With `ngIf`, whenever the expression changes from `false` to `true`, a complete
    re-initialization of the content occurs. Recursively, new elements/components
    are created and data binding is set up, starting from the parent down to the children.
    The reverse happens when the expression changes from `true` to `false`: all of
    this is destroyed. Therefore, using `ngIf` can sometimes become an expensive operation
    if it wraps a large chunk of content and the expression attached to it changes
    very often. But otherwise, wrapping a view in `ngIf` is more performant than using
    css/style-based show or hide, as neither the DOM is created nor the data binding
    expressions are set up when the `ngIf` expression evaluates to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another directive that belongs in this league: **ngSwitch**. When
    defined on the parent HTML, it can swap the child HTML elements based on the `ngSwitch`
    expression. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: We bind the `userType` expression to `ngSwitch`. Based on the value of `userType`
    (`admin` , `powerUser` , or any other `userType`), one of the inner div elements
    will be rendered. The `ngSwitchDefault` directive is a wildcard match/fallback
    match, and it gets rendered when `userType` is neither `admin` nor `powerUser`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have not realized it yet, note that there are three directives working
    together here to achieve switch-case-like behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ngSwitch`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngSwitchCase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngSwitchDefault`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Coming back to our next exercise implementation, we are ready to verify the
    implementation, so we refresh the page and wait for the rest period. There should
    be a mention of the next exercise during the rest phase, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the next exercise indicator using ngIf](../Images/image00443.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The app is shaping up well. If you have used the app and done some physical
    workouts along with it, you will be missing the exercise pause functionality badly.
    The workout just does not stop until it reaches the end. We need to fix this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Pausing an exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To pause an exercise, we need to stop the timer. We also need to add a button
    somewhere in the view that allows us to pause and resume the workout. We plan
    to do this by drawing a button overlay over the exercise area in the center of
    the page. When clicked on, it will toggle the exercise state between paused and
    running. We will also add keyboard support to pause and resume the workout using
    the key binding **p** or **P**. Let's update the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `WorkoutRunnerComponent` class, add these three functions, and add
    a declaration for the `workoutPaused` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The implementation for pausing is simple. The first thing we do is cancel the
    existing `setInterval` setup by calling `clearInterval(this.exerciseTrackingInterval);`.
    While resuming, we again call `startExerciseTimeTracking`, which again starts
    tracking the time from where we left off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just need to invoke the `pauseResumeToggle` function for the view. Add
    the following content to `workout-runner.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The `click` event handler on the div toggles the workout running state, and
    the `ngClass` directive is used to toggle the class between `glyphicon-pause`
    and `glyphicon-play`-standard Angular stuff. What is missing now is the ability
    to pause and resume on a **p** or **P** key press.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can apply a `keyup` event handler on the div:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'But the `div` element does not have a concept of focus, so we also need to
    add the `tabIndex` attribute on the div to make it work. Even then, it works only
    when we have clicked on the div at least once. There is a better way to implement
    this; attach the event handler to the global `window` event `keyup`. This is how
    the event binding will look now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Make note of the special `window:` prefix before the `keyup` event. We can
    use this syntax to attach events to any global object, such as `document`. The
    `onKeyPressed` event handler needs to be added to `WorkoutRunnerComponent`. Add
    this function to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$event` object is the standard **DOM event object** that Angular makes
    available for manipulation. Since this is a keyboard event, the specialized class
    is `KeyboardEvent`. The `which` property is matched to ASCII values of `p` or
    `P`. Refresh the page and you should see the play/pause icon when your mouse hovers
    over the exercise image, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pausing an exercise](../Images/image00444.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: While we are on event binding, it would be a good opportunity to explore Angular's
    event binding infrastructure
  prefs: []
  type: TYPE_NORMAL
- en: The Angular event binding infrastructure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular event binding allows a component to communicate with its parent through
    events.
  prefs: []
  type: TYPE_NORMAL
- en: If we look back at the app implementation, what we have encountered thus far
    are the property/attribute bindings. Such bindings allow a component/element to
    take inputs from the outside world. The data flows into the component.
  prefs: []
  type: TYPE_NORMAL
- en: Event bindings are the reverse of property bindings. They allow a component/element
    to inform the outside world about any state change.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw in the pause/resume implementation, event binding employs *round
    brackets* (`()`) to specify the target event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: This attaches a `click` event handler to the `div` that invokes the expression
    `pauseResumeToggle()` when the `div` is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like properties, there is a canonical form for events too. Instead of using
    round brackets, the `on-` prefix can be used: `on-click="pauseResumeToggle()"`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular supports all types of events. Events related to keyboard inputs, mouse
    movements, button clicks, and touches. The framework even allows us to define
    our own event for the components we create, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: We will be covering custom component events in the next chapter, where we will
    add audio support to *7 Minute Workout*.
  prefs: []
  type: TYPE_NORMAL
- en: It is expected that events have side effects; in other words, an event handler
    may change the state of the component, which in turn may trigger a chain reaction
    in which multiple components react to the state change and change their own state.
    This is unlike a property binding expression, which should be side-effect-free.
    Even in our implementation, clicking on the `div` element toggles the exercise
    run state.
  prefs: []
  type: TYPE_NORMAL
- en: Event bubbling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When Angular attaches event handlers to standard HTML element events, the event
    propagation works in the same way as standard DOM event propagation works. This
    is also called **event bubbling**. Events on child elements are propagated upwards,
    and hence event binding is also possible on a parent element, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Clicking on either of the divs results in the invocation of the `doWork` function.
    Moreover, `$event.target` contains the reference to the `div` that dispatched
    the event.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Custom events created on Angular components do not support event bubbling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Event bubbling stops if the expression assigned to the target evaluates to
    a `falsey` value (such as `void`, `false`). Therefore, to continue propagation,
    the expression should evaluate to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Here too, the `$event` object deserves some special attention.
  prefs: []
  type: TYPE_NORMAL
- en: Event binding an $event object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Angular makes an `$event` object available whenever the target event is triggered.
    This `$event` contains the details of the event that occurred.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to note here is that the shape of the `$event` object is
    decided based on the event type. For HTML elements, it is a DOM event object ([https://developer.mozilla.org/en-US/docs/Web/Events](https://developer.mozilla.org/en-US/docs/Web/Events)),
    which may vary based on the actual event.
  prefs: []
  type: TYPE_NORMAL
- en: But if it is a custom component event, what is passed in the `$event` object
    is decided by the component implementation. We will return to this discussion
    again, in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We have now covered most of the data binding capabilities of Angular, with the
    exception of two-way binding. A quick introduction to the two-way binding constructs
    is warranted before we conclude the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Two-way binding with ngModel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Two-way binding** helps us keep the model and view in sync. Changes to the
    model update the view and changes to the view update the model. The obvious area
    where two-way binding is applicable is *form input*. Let''s look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: The `ngModel` directive here sets a two-way binding between the `input`'s `value`
    property and the `workout.name` property on the underlying component. Anything
    that the user enters in the above `input` is synced with `workout.name`, and any
    changes to `workout.name` are reflected back on the preceding `input`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly we can achieve the same result without using the `ngModel` directive
    too, by combining both *property * *and event binding * *syntax*. Consider the
    next example; it works in the same way as `input` before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: There is a property binding set up on the `value` property and an event binding
    set up on the `input` event that make the bidirectional sync work.
  prefs: []
  type: TYPE_NORMAL
- en: We get into more details on two-way binding in [Chapter 4](part0045.xhtml#1AT9A1-edca168d36254bda8a21f611a95615c3
    "Chapter 4.  Personal Trainer"), *Building Personal Trainer*, where we build our
    own custom workouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created a diagram that summarizes the data flow patterns for all the
    bindings that we have discussed thus far. A handy illustration to help you memorize
    each of the binding constructs and how data flows is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Two-way binding with ngModel](../Images/image00445.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We now have a fully functional *7 Minute Workout*, with some bells and whistles
    too, and hopefully it was fun creating the app. It's time to conclude the chapter
    and summarize the lessons.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are having a problem with running the code, look at the Git branch `checkpoint2.4`
    for a working version of what we have done thus far.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also download a snapshot of `checkpoint2.4` (a zip file) from this
    GitHub location: [http://bit.ly/ng2be-checkpoint2-4](http://bit.ly/ng2be-checkpoint2-4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter with the aim of creating an Angular app that is more
    complex than the sample we created in the first chapter. The *7 Minute Workout*
    app fitted the bill, and you learned a lot about the Angular framework while building
    this app.
  prefs: []
  type: TYPE_NORMAL
- en: We started by defining the functional specifications of the *7 Minute Workout*
    app. We then focused our efforts on defining the code structure for the app.
  prefs: []
  type: TYPE_NORMAL
- en: To build the app, we started off by defining the model of the app. Once the
    model was in place, we started the actual implementation, by building an **Angular
    component**. Angular components are nothing but classes that are decorated with
    a framework-specific decorator, `@Component`.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about **Angular modules** and how Angular uses them to organize
    code artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: Once we had a fully functional component, we created a supporting view for the
    app. We also explored the *data binding capabilities* of the framework, including
    **property**, **attribute**, **class**, **style,** and **event binding**. Plus,
    we highlighted how **interpolations** are a special case of *property binding*.
  prefs: []
  type: TYPE_NORMAL
- en: Components are a special class of directives that have an attached view. We
    touched upon what directives are and the special classes of directives, including
    **attribute** and **structural directives**.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to perform cross-component communication using **input properties**.
    The two child components that we put together (`ExerciseDescriptionComponent`
    and `VideoPlayerComponent`) derived their inputs from the parent `WorkoutRunnerComponent`
    using input properties.
  prefs: []
  type: TYPE_NORMAL
- en: We then covered another core construct of Angular, **pipes**. We saw how to
    use pipes such as the *date pipe* and how to create one of our own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout the chapter, we touched upon a number of Angular directives, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ngClass/ngStyle`: For applying multiple styles and classes using Angular binding
    capabilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngFor`: For generating dynamic HTML content using a looping construct'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngIf`: For conditionally creating/destroying DOM elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngSwitch`: For creating/destroying DOM elements using the switch-case construct'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We now have a basic 7 Minute Workout app. For a better user experience, we have
    added a number of small enhancements to it too, but we are still missing some
    good-to-have features that would make our app more usable. From the framework
    perspective, we have purposefully ignored some core/advanced concepts such as
    **change detection**, **dependency injection**, **component ** **routing**, as
    well as data flow patterns, which we plan to cover in the next chapter.
  prefs: []
  type: TYPE_NORMAL
