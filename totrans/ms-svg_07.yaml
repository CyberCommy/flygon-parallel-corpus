- en: Common JavaScript Libraries and SVG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you've taken a look at the raw DOM interface to SVG, it's time to look
    at the interface between SVG and some of the more common JavaScript libraries
    and frameworks. Taking the lessons learned from [Chapter 6](042dd9c1-7b3e-4b8e-a3f6-f719dd8ae77c.xhtml), *JavaScript
    and SVG*, we'll look at some of the quirks present in getting SVG to work properly
    with jQuery, AngularJS (1.*), Angular (2+), and ReactJS. These examples will not
    be very deep, but should all illustrate the basic issues present in working with
    SVG and these other codebases. The goal here won't be to introduce you fully to
    these libraries and frameworks. There will be just enough of an introduction to
    get you up and running, and then each section will deal with the specifics of
    that library, or framework and SVG.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with the ever-popular jQuery library and SVG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interface between Angular 1 and Angular (2+) and SVG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SVG and ReactJS, the popular library from Facebook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating SVG with jQuery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first library we'll look at is jQuery. jQuery isn't as hot as it once was,
    but it's still the most popular JavaScript library on the planet, and understanding
    the quirks of using SVG with jQuery is still potentially useful.
  prefs: []
  type: TYPE_NORMAL
- en: Since jQuery functions as a friendly replacement for common DOM interactions,
    this section will feature a jQuery-based rewrite of the DOM manipulator demo we
    worked on in [Chapter 6](042dd9c1-7b3e-4b8e-a3f6-f719dd8ae77c.xhtml), JavaScript
    and SVG.
  prefs: []
  type: TYPE_NORMAL
- en: It uses the exact same markup, so the only place we need to look at in this
    chapter is the script block at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: This code will be written in idiomatic jQuery/ES5.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we'll look at is the function we'll fire on jQuery's equivalent
    of the `DOMContentLoaded` event, `$(document).ready()`. `$(document).ready()`
    takes a function as an argument. As the name implies, that function will be executed
    when the document's DOM content has finished loading.
  prefs: []
  type: TYPE_NORMAL
- en: While you could pass in a function expression, we're going to define a traditionally-named
    function called `init` to pass into `$(document).ready()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In it, we set a few event handlers. The first is a `click` event handler for
    our buttons. It fires the `loadCursor` function. The second through fourth event
    handlers create `save` events for each of the different SVG element types. The
    last one adds the `add` function to the `#canvas` element so that clicks on the
    canvas element will know to drop the chosen SVG elements onto the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've taken a look at the function that kicks off the application,
    let's look at the other functions in turn. First we'll look at the new version
    of the `add` function. `add` has one major wrinkle and then several smaller ones.
  prefs: []
  type: TYPE_NORMAL
- en: We start off by grabbing a loaded jQuery reference to the `$("#canvas")` SVG
    element. After that, the initialization is similar to the vanilla JavaScript Version
    of the function.
  prefs: []
  type: TYPE_NORMAL
- en: This includes one major wrinkle, where the expected behavior from jQuery fails.
    While the common jQuery element creation methods like `$("<rect>")` work with
    SVG elements and will insert the `<rect>` element into the page, they still need
    to be created with the proper namespace. Without the namespace, as you learned
    in the previous chapter, they will be treated by browsers like arbitrary HTML
    elements and won't render as expected. So, like the vanilla JS example, we need
    to add the namespace to the element creation. So we do that with the same `elem
    = doc.createElementNS(NS, "rect");` pattern we used in the JavaScript-only example.
    Once the element is created, it can be inserted into the DOM and manipulated with
    jQuery as normal.
  prefs: []
  type: TYPE_NORMAL
- en: After the elements are created, the individual options for the `square`, `circle`,
    and `text` are all handled similarly to the JavaScript-only example. In this case
    we just use the jQuery convenience methods `$().hasClass()` and `$().attr()` to
    test the class name and set the various attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we use a few more jQuery convenience methods to add the element to
    the `$canvas` element, remove the `"active"` class, and add the `click` event
    handler to edit the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The three edit functions again follow the same pattern as the vanilla JS example.
    In each function we get a loaded jQuery reference to the `target` element and
    store it as `$elem`. We then use the jQuery method `$().prop`, which looks up
    object properties, to test for the `nodeName` of the calling object. We then show
    the correct modal, with the Bootstrap modal method called with the `"show"` argument,
    and set the current element with the jQuery `$().data` method. `$().data`, as
    you''ll remember from [Chapter 6](042dd9c1-7b3e-4b8e-a3f6-f719dd8ae77c.xhtml), *JavaScript
    and SVG*, gets and sets arbitrary data on an element. We then use a combination
    of the `$().val()`  method, which gets or sets the value of form inputs, and the
    `$().attr()` method, which gets or sets an element attribute, to populate the
    form values. `$().val()` is used here to set the values of the forms by reading
    the value of the SVG elements with `$().attr()`, called a `getter` (with no arguments)
    and using that value as `$().val()`''s  argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the various `save` methods. These follow the same pattern
    as the previous examples. It''s the same basic workflow as the vanilla JS example,
    but once again we are able to use the full suite of jQuery convenience methods
    against our SVG elements: using the Bootstrap method to hide the modal, grabbing
    a reference to the current element using the `$().data()` method, and then setting
    attributes with the `$().attr()` method, called a `setter`, and `$().val()` called
    a `getter`, as the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, with the exception of element creation, working with SVG and
    jQuery is straightforward. Element creation requires using a standard DOM method,
    but every other interaction with SVG elements can use the appropriate jQuery methods.
  prefs: []
  type: TYPE_NORMAL
- en: Working with AngularJS and SVG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it's time to look at using SVG inside more complete application frameworks.
    We're going to start with AngularJS, the original Version of Google's wildly popular
    application framework. While AngularJS (Angular  1.*) is old in the context of
    web frameworks, it remains popular and in use in many environments. It's also
    familiar to many people and is widely deployed, so taking a brief look at how
    to work with SVG inside an AngularJS application is useful from multiple perspectives.
  prefs: []
  type: TYPE_NORMAL
- en: This and the following examples will be simpler than the jQuery and pure JavaScript
    demos. There are two reasons for this. The first is that you've seen a lot of
    details, under the hood, about how SVG and JavaScript interact in the DOM. You're
    actually ready to tackle SVG DOM manipulation on your own, so going over a wide
    number of variations in the different frameworks might not even be that beneficial.
    Covering the basics should give you enough to go off on your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, we don''t want too much detail about the actual libraries and frameworks.
    Keeping the introduction to each to a minimum means we can focus on the SVG portion
    of the discussion. To that end, we''ll look at the simplest possible demo that
    will show the two most important aspects of working with an element in an application:
    inserting dynamic SVG elements into the DOM, and manipulating them via user interaction.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The demos will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78f442d6-4ff8-45d9-bad1-4181bb70b9c4.png)'
  prefs: []
  type: TYPE_IMG
- en: This code will be written in idiomatic ES5.
  prefs: []
  type: TYPE_NORMAL
- en: The code follows. All the code for this example is in a single HTML file. This
    isn't normally the way that you'd build an AngularJS application, but it works
    fine for this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The document `head` sets the application up with the necessary scripts and
    styles. We link to Bootstrap, jQuery and Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The interesting stuff starts with the `body` element. That's where we set up
    our Angular application. The `ng-app` attribute indicates that Angular should
    process the `body` element and all of its children, applying Angular's special
    parsing rules to the markup contained within. We'll see more about what the `ng-app`
    value `"angularSVG"` references shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The markup that follows is where we wire up the UI to use Angular features and
    functionality. Angular uses a combination of special attributes and custom HTML
    elements to create dynamic interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The most important piece, from our perspective, is the use of the `ng-attr`
    prefix to `fill`, `cx`, `cy`, and `r` attributes. Angular allows you to reference
    variables in the current controller's scope in the markup and, as long as it's
    wrapped in the `{{}}` pattern, Angular will replace that reference with the value
    from the model. It's a live reference and it will automatically update in a regular
    cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'This very convenient feature *does not*play well with certain SVG attributes.
    While the following will eventually work after you play around with the applicationand
    the values are converted from the Angular tokens to numerical values,it will *error*
    when the document loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The error can be seen in the following screenshot. The SVG parser is expecting
    a `length` value and is instead getting a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e81c74fe-a429-4888-844f-5b0231f501e3.png)'
  prefs: []
  type: TYPE_IMG
- en: Fixing this requires the use of the `ng-attr` prefix. This prefix indicates
    to Angular that the `allOrNothing` flag should be used during the interpolation
    step. In plain English, this means that if the value of the attribute is `undefined`,
    the attribute is not rendered into the document. Once it has a value it is rendered
    as normal.
  prefs: []
  type: TYPE_NORMAL
- en: The second interesting part of this markup is the custom HTML element, `angular-rect`. `angular-rect`
    is what's called a **directive** in Angular. A directive is Angular's mechanism
    for creating custom HTML elements and attributes that allow you to expand and
    enhance common HTML elements and documents with reusable code blocks of your own
    design. While this one will be very simple, as you'll see shortly, this custom
    element will succinctly illustrate the way that Angular directives work with SVG.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only other interesting part of the markup is the use of the `ng-model`
    attribute to bind JavaScript variable values to the elements in the form field.
    This special AngularJS attribute wires up two-way data-binding between the markup
    and the Angular controller. We''ll soon see the way these variables are set in
    the controller, but just keep in mind the idea that once this connection is set,
    AngularJS keeps it alive and will update the values in the SVG elements whenever
    the `form` field is updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The JavaScript is very simple. Just a few lines of JavaScript allow you to wire
    up the values of the form fields to dynamically adjust the height, width, and
    fill color of the circle. The first piece, the `angular.module()` method call,
    creates an Angular app called `"angularSVG"`. It's this reference that Angular
    looks for in the markup in order to know whether or not there's an Angular app
    on the page. If it finds that value in an `ng-app`, it parses that markup and
    applies Angular-based magic to the page.
  prefs: []
  type: TYPE_NORMAL
- en: Following that, there's our small controller definition, `circleController`.
    `circleController` has one argument, the angular `$scope` variable. `$scope`,
    if you're not familiar with Angular, can be thought of as a managed alias for
    the `this` value of a function. It's the internal state of the controller, and
    the properties and methods in `$scope` are available to both the JavaScript code
    and to the Angular aware markup.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the controller, all we do is set some variables on the `$scope`. These
    serve as our baseline values for the circle, and because they're bound to the
    Angular `$scope`, they automatically become live, two-way links to the corresponding
    values in both the circle, and the form fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that we create a simple Angular directive, `angularRect`, which does
    nothing but insert a `rect` element into the SVG DOM. We won''t go into the complexities
    of Angular directives here, but there is one specific detail that is important
    for SVG elements. The `templateNamespace` property of the return object indicates
    to Angular that the directive should be treated as SVG. Without it, like jQuery''s
    common DOM creation pattern and the DOM method `document.createElement`, the directive will
    be inserted into the document, but it will not be created as a proper SVG element.
    It''ll be there, but it won''t actually show up as a square when it''s rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: Angular uses the JavaScript friendly camelCase inside JavaScript and then kebab
    case when the elements are inserted into the document.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Running that in the browser and then adjusting the values looks like the following
    screenshots. The initial screenshot shows the demo loaded with the initial values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/679721ca-ec4c-472c-8dab-93db93e873f8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This second screenshot shows the values adjusted and the circle element changed
    in a corresponding manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61019910-73f6-4104-a8fe-b2d9f22c609b.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we've looked at AngularJS, let's take a look at the new evolution of
    Angular, Angular 2.+. Known as just Angular, this iteration of the framework is
    very different and very powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a quick look.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating SVG with Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving on from AngularJS, let's take a look at the modern evolution of Angular.
    Angular 2.+ (referred to *just as Angular*) is a thoroughly modern framework.
    It's traditionally written in TypeScript, a super-set of JavaScript that adds
    optional features that Angular takes advantage of to add some incredibly convenient
    features and functionality to the library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Angular is a newer framework and has a much larger footprint, we'll go
    through a little bit of the setup to get you going. The code in the downloaded
    examples will work, but knowing how you get there is pretty useful. So, let's
    get set up.
  prefs: []
  type: TYPE_NORMAL
- en: This Angular example will replicate the exact same demo that the AngularJS example
    provided redone using Angular code. As you've probably already sensed and will
    continue to learn, the basic issues with dynamic SVG are the same no matter what
    library or framework you're using; the solutions are just slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: You can use whatever text editor you like for the Angular sample, but I suggest
    using Microsoft's VS Code. It's free, well-supported, updated frequently, and
    plays very well with TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node, npm, and Angular Cli
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you can start to work with Angular, you need to be set up with the tools
    needed to actually run the code. The foundation of everything is Node.js and Node's
    package manager, `npm`. So you should install those first if you haven't already.
    The easiest way to do that is to head on over to [nodejs.org](http://nodejs.org)
    and download the installer for your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve done that, you can go ahead and install the Angular **Command
    Line Utility** (**CLI**). Angular CLI makes it very easy to get up and running
    with an Angular project, as you''ll see in short order. The following command
    will install Angular CLI globally on your machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6996342-dc66-40a8-aeca-cacbb33cd7b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once it''s installed, it''s time to create a project using the `ng new` command.
    `ng new` will create a new folder with everything you need to get an Angular project
    up and running. We won''t go into all the details but after running this command,
    you should be all set to start working with your application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/69ce9e39-72c3-4440-91bb-e24b1e65ee66.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to go into the folder you just created and run `npm install`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4260a2d0-c0bf-4637-8a08-bce5d90db340.png)'
  prefs: []
  type: TYPE_IMG
- en: '`npm install` will ensure that all your dependencies are installed in `node_modules`
    and your application will be ready to run.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot from VS Code shows the layout of the application after
    it''s been initialized and `npm` install has been run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a23bd629-8d25-487a-b286-285ec1c0a6de.png)'
  prefs: []
  type: TYPE_IMG
- en: Since we're using Bootstrap for this Version of the Demo as well, we need to
    make sure that it's available. That's done by running
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'which will install Bootstrap into your `node_modules`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9e8b949-b4ea-493c-ba95-60fb6ede1ca3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can then wire it up in `angular-cli.json`. `angular-cli.json` is where
    you configure different aspects of your Angular CLI installation. In this case
    all we need to do is add Bootstrap CSS to the styles property so that it will
    be bundled with the rest of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, Angular CLI uses Webpack to bundle scripts and styles and process
    them in a number of ways to ready them for delivery to your development server
    as well as to production environments. One of the greatest benefits of using Angular
    CLI is that it smoothes out the complexity of working with Webpack. Webpack is
    incredibly powerful but has a steep learning curve. Angular CLI makes it just
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the application in this simple state will allow us to start developing
    the application and testing against a development server running locally. This
    is done using the `ng serve` command. It''s called here with the `--open` option
    which will open a web browser after the code is compiled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1be8b908-3865-4ae3-852d-ab260405e18a.png)'
  prefs: []
  type: TYPE_IMG
- en: This will auto-reload the code in the browser whenever changes are made to the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: So, with that, it's time to actually start writing some TypeScript and interacting
    with SVG.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we''ll do is edit the main module for the application. `app.module.ts`
    is the root module for the application and it''s where all the parts of the application
    are wired together. Most of this is automatically wired up by `Angular CLI`. All
    we need to do is import the `FormsModule` from an Angular core, using the new
    ES6 module pattern (`import` `module from src`). Then we add it to the `imports`
    array of the `@NgModule` decorator. This allows the directives and properties
    of the `FormsModule` to be available inside this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Following that, we''ll completely edit the `app.component.ts` file to represent
    our (simple) component. In it, we import `Component` and `FormsModule` from Angular,
    do some standard housekeeping in the `@Component` decorator, and then we export
    the `AppComponent` class which ships with four properties set. This pattern deserves
    some explanation since it''s probably familiar but different enough that it might
    be a head-scratcher. For starters, all of these are created with the `public`
    keyword. That indicates that these properties should be available outside the
    scope of the class. Next is the variable name itself, followed by a colon and
    a type annotation, indicating the expected type of the variable. TypeScript allows
    you to create custom types based on other TypeScript classes, but for our purposes,
    we''re just using standard JavaScript primitives, `number` and `string`. Finally
    we set default values for all of them so that our application has something to
    hang onto:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Next we have the markup, which is similar to the previous example. It's all
    contained in `app.component.html`. There are some similarities to the AngularJS
    Version. For example the dynamic attributes have to be similarly handled, you
    still can't bind directly to SVG attributes without causing an error, so you still
    have to manage them explicitly. In this case you use the `attr.` prefix instead
    of the `ng-attr-` prefix you used in AngularJS. You'll also notice the square
    brackets surrounding the attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the simple square brackets `[]` indicates that this is a one-way data
    binding; the template reads from the component properties we previously defined.
    Later on, in the inputs, we see an example of explicit two-way data binding with
    the square bracket/parenthesis `[()]`  syntax surrounding the attribute. `ngModel`
    is the directive we were importing with `FormsModule`. It allows us to do two-way
    data binding from a form element to the properties of a component. This way the
    entries in the form are, once again, represented in the attributes of the SVG
    `circle` element and it displays changes as updates are made to the `form` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s only one more thing we need to do to get this Angular example to match
    the previous example in AngularJS, and that is to add a sub-component that represents
    the small blue `rect` element. There are a couple of interesting wrinkles with
    this. The first is an illustration of the power of Angular CLI. With Angular CLI
    if you need to wire up a  component, you can do so with the `ng new` command.
    In our case we''ll run `ng new component angular-rect`, which will generate the
    various files that make up an Angular component and will actually wire the component
    up into `app.module.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e746339-5776-421b-9d45-09f97e6b244b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see what `app.module.ts` looks like in the following updated code sample
    where the new `AngularRectComponent` component is imported and added to the `@NgModule`
    declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple more wrinkles, related directly to SVG, that need pointing
    out to get this custom element onto the page. The first is the requirement of
    adding the `svg:` prefix to the elements in the `angular-rect` component. This
    indicates to Angular that, you guessed it, it should use the SVG namespace when
    creating these elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The next wrinkle is a two-parter. With a component made up of simple HTML elements,
    you could do something like this, which is similar to what you saw in AngularJS.
    You would add the element to the page as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Which will render, in the live view in the Web Inspector, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: That looks fine from a markup perspective, but in the browser, the blue rectangle
    is missing. The whole element isn't rendering, even though it's in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: In HTML5, this sort of thing will work because the HTML5 parser has been designed
    to be forgiving of unknown elements (as well as poorly formed markup) and you
    can manipulate custom elements with CSS.  SVG, on the other hand, remains a strict
    XML grammar, so unless the element is in the SVG specification, or you can point
    to an XML-based **Document Type Definition** (**DTD**) that defines that particular
    element, it won't render properly. Thankfully, there's an SVG-shaped solution
    that works perfectly well with a feature of Angular components. You can use Angular's
    ability to bind custom components to attributes with the generic `g` element to
    create much the same effect.
  prefs: []
  type: TYPE_NORMAL
- en: The following code sample shows how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at the `angular-rect` component itself. The only thing to
    note, as most of the file is just boilerplate, is that the selector in the `@Component`
    decorator is wrapped in square brackets `[]`. Since it''s wrapped in square brackets,
    that indicates to the parser that it''s an attribute selector, as opposed to the
    common element selector you saw with the app component itself. That means that
    Angular will look for the presence of `angular-rect` as an attribute of an element
    and will replace that with our new custom component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll see how that works with the markup. We, once again, add the `svg:`
    prefix to the `g` element and then we simply add the `angular-rect` attribute
    and the component renders properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: And that's that for Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Working with React and SVG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final library we're going to look at is React. React is a very popular library
    that came along just as AngularJS was getting long in the tooth and before Angular
    was ready for prime-time. It's very popular in some circles. It's based on ES6
    with some extensions specific to React.
  prefs: []
  type: TYPE_NORMAL
- en: Much of it will look familiar to you, just based on what you've seen so far
    in this chapter and especially if you've done any serious web application development.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with React is less straightforward than getting up and running
    with Angular. Angular, under the hood, is probably more complicated, but Angular
    CLI smooth out a lot of the issues so you never (or rarely) actually see the complexity
    as a developer. React is more of a library than a complete framework, so you can
    end up having to make a lot more decisions in order to get up and running. Thankfully,
    while there are many ways to get there and none are as central to the project
    as Angular CLI is to Angular (they're tightly coupled in the documentation and
    community), there are ways to do it just as simply as Angular CLI. Perhaps even
    simpler since there's nothing to even install.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming you have Node Version >6 installed on your machine, all you need to
    do to create the simple application used in the demo code is to run a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`create-react-app` is a utility from Facebook that spins up a fully functional
    React app. Running it looks like the following two screenshots (the full scroll
    would take up many pages of the book).'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s very cool. It creates the folder, downloads all of the dependencies and
    installs everything, giving you a series of commands to run in order to interact
    with your newly minted React application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6f94d94-1a97-46a0-8436-e2e5318f92d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Continued result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fe0854b-769e-4e42-9028-6600aa34dd1f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Looking deeper, it creates a directory that looks like the following screenshot.
    It contains the `node_modules` folder with all of the dependencies, `public`,
    which is where the transpiled files live (and are served from when you browse
    your working code) and `src`, which is where all the source files for your application
    live. The other files are all standard files for a `git/npm/yarn-based project`:'
  prefs: []
  type: TYPE_NORMAL
- en: Yarn is an alternative to `npm`. We won't go into the details of the differences
    between the two because it's out of the scope of this book and, to be honest,
    isn't all that interesting. Suffice to say, yarn is a parallel tool to `npm` so
    you will do the same things you would do with `npm` with yarn. The syntax is occasionally
    different and there is a different file created when doing `yarn install` (`yarn.lock`).
    But for the sake of this book you don't need to concern yourself with the differences.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8d327e3-5bdf-48bf-9436-adf481b64ec3.png)'
  prefs: []
  type: TYPE_IMG
- en: As previously mentioned, the application code is in `src`. You can see the layout
    of that folder in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '`App.css`, `App.js`, and `App.test.js` are where the heart of your application
    will live. The `index.js` file is the main entry point to your application and
    they Bootstrap your React application. `registerServiceWorker.js` is a file provided
    by the framework that serves assets from a local cache. However, you won''t actually
    touch it in this simple app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d1c8368-67d7-4232-a3a3-9a3ab354ee50.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Running `yarn start` from the root of the project folder will compile all of
    the React code, and CSS, and will spin up a development server available at localhost:`3000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39ac6a11-a210-4555-bddb-b0f7b913ad87.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The starter app looks as follows, in case you were wondering. We will quickly
    blow that away:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22df7d11-f3c3-4a30-b55a-1b1f8f0c707a.png)'
  prefs: []
  type: TYPE_IMG
- en: Before we get started with our dive into SVG and React, let's take a look at
    the basic React component spit out by `create-react-app`. You've seen it rendered
    previously; let's look at how it works.
  prefs: []
  type: TYPE_NORMAL
- en: The basic format of a React component is as follows. It's an ES6 module, with
    `import` statements, a class, and an export. There's one element specific to React
    that's worth noting.
  prefs: []
  type: TYPE_NORMAL
- en: The top of the file shows the ES6 imports. This can include CSS files (as we'll
    see in a minute) and SVG images. Webpack actually reads those import statements
    and optimizes those imports, much like Webpack worked with Angular decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Following that we have the one class in the file. `App`, which extends the base
    `Component` class from React. It's got one method, `render()`, which uses an extension
    to JavaScript called JSX. JSX allows you to mix XML and JavaScript together. I
    honestly have never much liked this format and was practically shocked by it when
    they released it, but I've grown to appreciate the intent, even if I don't like
    it. JSX attributes are parsed as strings if they're quoted. Otherwise, they are
    treated as JavaScript expressions. In this case, the path to `logo.svg` is converted
    to a useful path and the logo is rendered in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we export the default class, `App`, which can then be imported by
    other applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Quickly, since there's not a lot that we actually do with it, let's take a look
    at `index.js`. This will show us how the application gets loaded.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ES6 module imports at the top of the file. React and ReactDOM
    are core, driving the basic React library and adding in the ReactDOM interface.
    They drive the majority of what we're going to do with this little demo.
  prefs: []
  type: TYPE_NORMAL
- en: The imports also include the `index.css` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than that, we import two pieces of JavaScript: `App`, which is the module
    we''re going to do our work in, and the previously mentioned `registerServiceWorker`,
    which we won''t work with at all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once everything is imported, we run two small functions. `ReactDOM.render`
    is called with two arguments, `<App />`, indicating the custom element created
    by the App component, and `document.getElementById("root")`, which indicates the
    node that should receive the new element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've taken a quick look at the basic React architecture, let's take
    a look at our demo.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the basic React app, Bootstrap is also installed into this project
    by running the following command. We are going to do another version of the simple
    form / SVG demo we''ve been doing and it makes sense to continue to use the same
    markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at our `App.js`. It starts with a couple of import statements. We
    pull in `React` and `component` from React. Then we pull in two CSS files, our
    own custom `App.css` and the `Bootstrap CSS` we just installed, linking to the
    files in the project's `node_modules`. Finally, we import our standalone `ReactRect`
    component from the `rect` module.
  prefs: []
  type: TYPE_NORMAL
- en: Then we have the `App` class definition. It's really got just a couple of things
    going on. In the constructor, we create a base `state` object with default values
    of our standard SVG properties, `cx`, `cy`, `r`, and `color`.  And then we set
    a method, `handleChange`, to handle changes to the underlying model.
  prefs: []
  type: TYPE_NORMAL
- en: The method is simple. It takes the `event` object in, creates a `target` constant
    with the `event.target`, and then further inspects that object to get the `name`
    and `value` of the input. It then uses the method `setState` (inherited from `props`)
    to set the value of the application's state.
  prefs: []
  type: TYPE_NORMAL
- en: Following that is the `render` function.
  prefs: []
  type: TYPE_NORMAL
- en: Looking through it you'll notice there's not much that you need to do to get
    React to properly render the SVG.
  prefs: []
  type: TYPE_NORMAL
- en: First we set local variables for the various properties using the ES6 destructuring
    assignment pattern. Once those variables are set it's a simple matter of adding
    the variables that we need to have interpreted by React into bracket pairs `{}`
    in the appropriate attribute. The variable references in both the SVG elements
    and the form inputs are handled exactly the same way and don't require any special
    handling.
  prefs: []
  type: TYPE_NORMAL
- en: We simply bind the `handleChange` method to the `onChange` event, directly in
    the markup, and everything behaves as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '`ReactRect`, which we imported, is added to the SVG element. React handles
    importing that component, which we''ll see shortly, and rendering it into the
    document:'
  prefs: []
  type: TYPE_NORMAL
- en: Custom components need to start with a capital letter. Markup starting with
    a lowercase letter is interpreted as an HTML element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Our custom element is very simple. It''s just a plain React component that
    returns our `rect` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, working with dynamic SVG and React is very straightforward.
    There was a concerted effort by the React team to ensure that SVG elements and
    attributes all worked, so this is down to their hard work. Thanks, React team!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you worked with four common libraries and frameworks, integrating
    these powerful tools with SVG.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with jQuery and working your way through AngularJS, Angular, and React,
    you now have basic experience at integrating SVG with four of the most popular
    libraries and frameworks on the planet.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, you learned about setting up applications with each of the frameworks,
    how to create dynamic components that feature SVG elements and attributes, and
    how to manipulate those attributes in a dynamic way.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned about the multiple gotchas when working with SVG and these
    libraries, including ways to ensure that elements are created properly in jQuery
    and ensuring that dynamic attributes are properly handled in the Angular frameworks.
  prefs: []
  type: TYPE_NORMAL
