- en: Miscellaneous Information and How-Tos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This appendix has four sections:'
  prefs: []
  type: TYPE_NORMAL
- en: How to build and run Go projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to propose changes to Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FP Resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minggatu-Catalan Number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build and run Go projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are various ways to build and run Go applications. In this section, I'll
    show you what I used to build the example Go projects for this book.
  prefs: []
  type: TYPE_NORMAL
- en: TL;DR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the `cd` command to direct to your project root directory. Run `. init`
    once.
  prefs: []
  type: TYPE_NORMAL
- en: Ready to run your app? Did you change a (non-standard library) import statement?
    If so, run `glide-update`.
  prefs: []
  type: TYPE_NORMAL
- en: To run your app, execute `go-run`.
  prefs: []
  type: TYPE_NORMAL
- en: Development workflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is what our development workflow looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99611dc3-7dc1-42c4-93c3-1dc7baaa676b.png)'
  prefs: []
  type: TYPE_IMG
- en: We put `cd` into our project source code root directory and run `init`. Then,
    we updated code, run the `glide-update` and `go-run` commands, and repeat until
    done. Note that if we only added imports for packages from Go's standard library,
    we won't need to run the `glide-update` command, though running the `glide-update` command
    won't hurt.
  prefs: []
  type: TYPE_NORMAL
- en: Dot init features and benefits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *dot init* solution will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a link to this project root directory in your `MY_DEV_DIR` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that you are running the correct version of Go.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that you have a `src` directory (it will create one if you don't have
    one).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Simplify references to project-local packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that you have a `toml` config file (if you set `USES_TOML_CONFIG_YN`
    to yes).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create aliases for your convenience.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that you have glide installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In *step 1*, it's nice to have one place to go `MY_DEV_DIR`, for example, `~/myprojects`
    to see all the projects I've worked on. I can sort by date and easily delete the
    links to inactive projects.
  prefs: []
  type: TYPE_NORMAL
- en: Use *step 2* to avoid messing with GOPATH, GOROOT, or GOBIN.
  prefs: []
  type: TYPE_NORMAL
- en: As explained in *step 3*, the `src` directory is where we put our project-local
    package source files. We also have a file (typically named `main.go`) in our project
    root directory with the `main()` function in the main package.
  prefs: []
  type: TYPE_NORMAL
- en: Perform *step 4* so that we no longer need to include the full GitHub repository
    path for project-local packages!
  prefs: []
  type: TYPE_NORMAL
- en: Instead of `".github.comlearn-fp-go/2-design-patterns/ch05-decoration/02_decorator/decorator"`,
    we simply use `". decorator"`. Note that if you just really do not want to use
    *dot init*, you'll need to go through the source code and replace all of the simple
    project-local package references with the full repository path references and
    move the code. You may also need to move the code out of the project-local package's `src`
    directory up a level; it won't conflict with your global GOPATH's `src` directory.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, the `toml` config file ([https://github.com/BurntSushi/toml](https://github.com/BurntSushi/toml))
    is the default config file solution. The `.init` file includes the `toml` config
    file runtime flag automatically (as long as you set this in the `init` script: `USES_TOML_CONFIG_YN=yes`).
  prefs: []
  type: TYPE_NORMAL
- en: Aliases available
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here''re the available alias commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In summary, dot init will allow you to update your dependencies with one command
    (`glide-update`) and compile and run your application with one other command (`go-run`).
    All you have to do to start using it is make sure that the init script exists
    in your project root directory and run `. init` one time. The `.init` initialization reduces
    the code you have to write and maintain, and it keeps building and running your
    Go app as simply as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Functions available
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here''re the functions available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Motivation for using goenv
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you always use the latest version of Go or if do your development work on
    a non-Macintosh computer, you can skip this section.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to support multiple go runtimes, we put our Go project code in different
    directories. To help us manage our go runtime environments, let's look at a little
    utility script named `goenv` and the init script found in our project root directories.
  prefs: []
  type: TYPE_NORMAL
- en: This section assumes that you are using a Mac computer. Manage your Go runtime
    environment with `goenv`; visit: [https://github.com/l3x/goenv](https://github.com/l3x/goenv). For
    more information on the `go` command, visit: [https://golang.org/cmd/go](https://golang.org/cmd/go)
  prefs: []
  type: TYPE_NORMAL
- en: Motivation for using the init script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `init` script and the alias commands that it provides has one purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '*To make building and running our Go apps easy.*'
  prefs: []
  type: TYPE_NORMAL
- en: Managing dependencies (third-party packages) can be a pain. Import statements
    can be too long for our local source files. Always keeping our `GOPATH`, `GOBIN`,
    `PATH`, and so on up to date can also be a pain.
  prefs: []
  type: TYPE_NORMAL
- en: I created the init script to simplify the process of building and running the
    example apps in this book. I found it so useful that I use it for other projects
    too. I hope it works well for you, too.
  prefs: []
  type: TYPE_NORMAL
- en: Ways to manage Go dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are over a dozen ways to manage Go dependencies. We can do so with the
    tools that we will discuss in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The go get tool
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When I started developing in Go, I used the `go get` tool. Here''s a snippet
    from its help message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: I soon learned that it would get the most recent version of all packages. Not
    what I wanted.
  prefs: []
  type: TYPE_NORMAL
- en: I was looking for something more like Ruby's **Gemfile** or the **npm** package
    manager where I could specify the specific version of each package and create
    a `.lock` file to keep it from changing every time I run my build tool.
  prefs: []
  type: TYPE_NORMAL
- en: The Godep tool
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I used Godep for a while. And it worked fine, but it was a hassle to use.
  prefs: []
  type: TYPE_NORMAL
- en: Godep created a `Godeps.json` file in a Godeps directory in the root of my project.
    Godep then created copies of all of my third-party packages into the Godeps directory
    at the root of my project. I typically checked those third-party packages into
    version control with the rest of my code.
  prefs: []
  type: TYPE_NORMAL
- en: Godep requires a number of steps that I find quirky. For example, to update
    a project's dependency, you will have to update it in your `GOPATH` via the `go
    get -u github.com/another-thirdparty/package` command, and then copy it from my
    `$GOPATH` to my project's Godeps directory via the `godep save github.com/another-thirdparty/package`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: In my humble opinion, having to modify a dependency using `$GOPATH` is quirky.
    Modifying dependencies of multiple projects using different versions of dependencies
    concurrently is even more quirky (quirky == more user errors).
  prefs: []
  type: TYPE_NORMAL
- en: I like simple, not quirky.
  prefs: []
  type: TYPE_NORMAL
- en: Vendoring in Go
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Vendoring in Go was introduced in Go 1.5\. It allows Go apps to fetch dependencies
    not only from `$GOPATH/src`, but also from a child folder named vendor, located
    at the root your project. Previously, you had to save your third-party packages
    in the globally shared `$GOPATH` path. Now, you can place your dependencies into
    your project's vendor folder.
  prefs: []
  type: TYPE_NORMAL
- en: I was still looking for a way to pin down the version of each package or to
    specify a `MAJOR.MINOR` version and have my package manager grab the latest `MAJOR.MINOR.PATCH`
    version.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, visit [https://docs.google.com/document/d/1Bz5-UB7g2uPBdOx-rw5t9MxJwkfpx90cqG9AFL0JAYo/edit](https://docs.google.com/document/d/1Bz5-UB7g2uPBdOx-rw5t9MxJwkfpx90cqG9AFL0JAYo/edit)
  prefs: []
  type: TYPE_NORMAL
- en: Glide - the modern package manager
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I found Glide and appreciated its features and the fact that it's under active
    development/improvement. It reminded me of Ruby's Gem package management. It's
    great, but still a lot to remember.
  prefs: []
  type: TYPE_NORMAL
- en: Glide references
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/Masterminds/glide](https://github.com/Masterminds/glide)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://glide.sh/](https://glide.sh/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://glide.readthedocs.io/en/latest/getting-started/](https://glide.readthedocs.io/en/latest/getting-started/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://glide.readthedocs.io/en/latest/commands/](https://glide.readthedocs.io/en/latest/commands/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I just wanted to run one command to build my code and one command to run my
    code. I wanted something simple, so I created the init script and its aliased
    commands to wrap the functionality of Glide.
  prefs: []
  type: TYPE_NORMAL
- en: I find the `init`, `glide-update`, and `go-run` set of commands super easy to
    use. Hopefully, you will too. Granted, when you use it to build very large projects,
    you will initially need to deal with import/dependency errors, as with any dependency
    management tool, but I find Glide to be the best one out there. So, what you see
    in this appendix is a simple set of build and run commands that's built on top
    of the full featured build tool, Glide.
  prefs: []
  type: TYPE_NORMAL
- en: Each dot init step in detail
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, use the `cd` command to direct to the project directory with our source
    code. Let's look at the `01_dependency-rule-good` source code. This happens to
    be the first code project from [Chapter 7](../Text/Ch07.xhtml), *Functional Parameters*.
    Next, let's run `goenv info`, which will inform us about our Go environment.
  prefs: []
  type: TYPE_NORMAL
- en: The cd command to project root directory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before using **dot init**, you might see invalid settings for `GOROOT`, `GOPATH`,
    and `GOBIN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41c404e7-cc83-4bbc-9dc8-f4d01ee0c112.png)'
  prefs: []
  type: TYPE_IMG
- en: The * on the last line of output in the preceding screenshot indicates that
    our Go version is set to version 1.8.3\. Note that running `go version`  returns  `go1.9
    darwin/amd64`, which was the most recent version of Go when our book was published.
  prefs: []
  type: TYPE_NORMAL
- en: We see that our `GOPATH` is not properly set and that we have three versions
    of Go installed.
  prefs: []
  type: TYPE_NORMAL
- en: Using homebrew to install Go
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'On a Mac, we can use homebrew to install and manage our Go installations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding command might return result like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`go`'
  prefs: []
  type: TYPE_NORMAL
- en: '`go@1.4`'
  prefs: []
  type: TYPE_NORMAL
- en: '`go@1.5`'
  prefs: []
  type: TYPE_NORMAL
- en: '`go@1.6`'
  prefs: []
  type: TYPE_NORMAL
- en: '`go@1.7`'
  prefs: []
  type: TYPE_NORMAL
- en: '`go@1.8`'
  prefs: []
  type: TYPE_NORMAL
- en: The checks indicate which versions of Go are already installed. To install go
    version 1.5, we can run `brew install go@1.5`. To install the latest version of
    go (currently 1.9), run  `brew install go`.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the initial directory structure and files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s examine our initial directory structure and files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The init script contents
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we run our `init` script, let''s look at the contents of our init script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'All we need to do is verify that the preceding variables the dotted line are
    correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If we don't change anything, the script will work using go version 1.9 and it
    will create a `~/dev` directory if it does not already exist.
  prefs: []
  type: TYPE_NORMAL
- en: Running the init script
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To get our project ready for development, in our terminal, just run `. init`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94462aca-6c7e-43b7-8d65-4a818e58b0f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that `source` and "."  do the same thing; they run the following command
    in the context of the current shell environment.
  prefs: []
  type: TYPE_NORMAL
- en: Note that our current directory path is shorter. We're in a newly linked directory.
    It's a link file in `MY_DEV_DIR`. A benefit or side-effect of running this script
    is that we can go to our `MY_DEV_DIR` to see what projects we've worked on lately.
    It's also nice not to have such a long path name in our terminal (assuming we
    display our full, current directory path in our shell prompt).
  prefs: []
  type: TYPE_NORMAL
- en: Re-examining the initial directory structure and files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We also ran the tree command to see our project directories and ran the file
    command to see our files.
  prefs: []
  type: TYPE_NORMAL
- en: The only new file the init script created is `PROJECT_DIR_LINK` (in this example,
    `/home/lex/dev/01_dependency-rule-good`).
  prefs: []
  type: TYPE_NORMAL
- en: The goenv shows what's been updated
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'That init script must have done something else for us, right? Let''s run our
    goenv info command again to see what else it did:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ace780a-74ab-4fc4-9884-ccee1c07f9ef.png)'
  prefs: []
  type: TYPE_IMG
- en: We get a warning because the `GOPATH` is actually a path. (Most other vendor
    solutions will not work properly if `GOPATH` is anything other than a single directory.)
    Our `GOPATH` is constructed just like our `PATH` environment variable. It's composed
    of paths appended together, separated by a colon character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `GOPATH` is comprised of two values: the `src` path (with our project source
    files) and the vendors path (with our third-party dependency source files).'
  prefs: []
  type: TYPE_NORMAL
- en: Running glide-update to get third-party dependency files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After we add files to our src directory and have some import statements and
    before we run our Go app, let's ensure that Go has all the source files for our
    dependencies that it requires to build our application.
  prefs: []
  type: TYPE_NORMAL
- en: Anytime we update any import statement (and before we run our application),
    we run `glide-update`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad0fb628-a5b6-4789-be3b-118c79b71ea8.png)'
  prefs: []
  type: TYPE_IMG
- en: We can run our Go application by typing `go-run` . This will compile our application
    (putting the binary in our `GOBIN` directory) and run it. Our application outputs
    two lines with the characters **A** and **B**.
  prefs: []
  type: TYPE_NORMAL
- en: Running `glide-update` will create the typical `vendor` directory and quickly
    rename it to vendors (which is a further indication that this is not a standard
    glide installation). We don't have to be a glide expert to get our dependencies
    managed by glide. Anytime we update dependencies (and change an import statement),
    we just run the glide-update alias and all the dependencies' code will go into
    the vendors directory and our `GOPATH` will know to look there when it compiles.
    Also note that if you use a fancy IDE that requires you to enter your `GOROOT`,
    `GOBIN`, and `GOPATH`, you just need to run `goenv-info` to see what our project
    correct settings are.
  prefs: []
  type: TYPE_NORMAL
- en: If `glide-update` reports any errors, it will be up to us resolve them.
  prefs: []
  type: TYPE_NORMAL
- en: Adding standard library imports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll add the `fmt` package to the import statement in `packagea`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll add the log package to the import statement in `packageb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding our imports, we source init:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e60334a-6164-4431-af90-72783b1fc303.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we update our dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f605043a-b950-4ae8-a2a6-7e94b9def563.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can run our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8712c6c0-cdab-40d8-8e8b-83e6e5a3481a.png)'
  prefs: []
  type: TYPE_IMG
- en: The only difference is that the `log.Println` command adds a time stamp. We
    see that it works, but what about the dependencies? Does the vendor's directory
    now have some files?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3945f73-1f15-4ec7-82e2-227f10ec763d.png)'
  prefs: []
  type: TYPE_IMG
- en: Nope. Still no files. Why?
  prefs: []
  type: TYPE_NORMAL
- en: That's because `fmt` and `log` are both from Go's standard library.
  prefs: []
  type: TYPE_NORMAL
- en: The Go standard library
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Go standard library is a set of core packages that enhance and extend the
    language.
  prefs: []
  type: TYPE_NORMAL
- en: By *core*, we mean that every time we compile our Go app, we'll get that pkg
    directory and it will be filled with the Go standard library packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go standard library packages have the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: They add no extra overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are guaranteed to always exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are guaranteed to always be backwards compatible (won't break between release
    cycles)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using packages from Go's standard library will make our code easier to manage
    and more reliable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example packages include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`log`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fmt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`encoding/json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`database/sql/driver`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net/http`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For details regarding Go's Standard Library, refer to: [https://golang.org/pkg/](https://golang.org/pkg/)
  prefs: []
  type: TYPE_NORMAL
- en: Adding third-party imports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this example, we'll import a simple third-party utility package, `go-goodies/go_utils`.
    I created `go-goodies/go_utils` back in 2015 (when I was still very much learning
    the language). I have not modified much of the code in a while, so that I can
    look back to see how much I've learned. It all should still work properly, but
    in many cases, there are better ways to accomplish things. You've been warned,
    so please don't judge.
  prefs: []
  type: TYPE_NORMAL
- en: Importing statement referencing  go_utils
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's add a third import, `u "github.com/go-goodies/go_utils"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we use the preceding `u` in the `Atask` function to reference the
    `PadLeft` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `grep` command on our source files for `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/398d0073-f2fc-4973-bc7c-c61582779519.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we updated an import statement, we need to run `glide-update` before
    we run our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d001b9b6-d0bc-4dc3-8ae2-aeacba80cd5d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This time, we can see that `glide-update` pulled in the third-party (`go_utils`)
    files under the vendor''s directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bf04c1e-b76d-438e-ba8d-1b6025516ec6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the `go-goodies/go_utils` references the following third-party
    packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://github.com/margnus1/go-deepcopy](http://github.com/margnus1/go-deepcopy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://github.com/nu7hatch/gouuid](http://github.com/nu7hatch/gouuid)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we run our app, we see the effect of using the `PadLeft` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c7e4325-d4d3-41c7-a5ce-25b3654d5090.png)'
  prefs: []
  type: TYPE_IMG
- en: You can use the init script and the aliases it provides with confidence that
    they will not touch your source files (well, except prune-project will comment
    out lines in `./main.go` that reference `mypackage`). The files they modify include
    the soft linked directory file in your `~/dev` directory and the `bin`, `pkg`
    and vendors directories.
  prefs: []
  type: TYPE_NORMAL
- en: Development workflow summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How you manage your dependencies, build, run, and deploy your applications is
    a matter of preference. It's often a good idea to get all of the developers in
    your team to  build applications the same way. The techniques shared in this section
    demonstrate the way I built the demo applications for this book. I kept it simple.
    However, the rest of the story is that I rarely build applications in isolation
    like I did for this book. Nearly every time, I use Docker in my `development/test/deployment`
    workflow. Note that the use of Docker is out of scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting dot init
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is how I resolved the build errors that occurred when converting [Chapter
    4](../Text/Ch04.xhtml), *SOLID Design in Go*, to the dot init technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, I used the `cd` command to direct to the project''s root directory (where
    the `project` is [Chapter 4](../Text/Ch04.xhtml), *SOLID Design in Go*, source
    code):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a36879c6-acf9-4bd6-b2e7-46b99d8abd5b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, I ran `glide-update` to tell Glide to put the dependencies in the vendors
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/805cf76c-27cd-46a8-a41e-c14eb915025a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But, that failed because the `import` statement was incorrect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbef03c3-164f-45ee-80f9-77929617fbfd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s what the imports look like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14547117-0140-47ce-b3ee-da6e1d030dd5.png)'
  prefs: []
  type: TYPE_IMG
- en: Tell Glide to put third-party packages in the vendor's directory.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85da26bf-a648-488c-8c18-3ef752bf2e55.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Compile and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e23bdaa-486f-4575-b3a8-fedab6c2cf13.png)'
  prefs: []
  type: TYPE_IMG
- en: Bummer! `.init` can't find the binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'No worries, just cd back to the original project root directory and re-source
    init:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1a1a47a-72a7-476a-9f90-8f9b76d1614a.png)'
  prefs: []
  type: TYPE_IMG
- en: If you run `go-run` and you see *command not found*, just rerun `init`, `glide-update`,
    and `go-run`.
  prefs: []
  type: TYPE_NORMAL
- en: Still more problems!
  prefs: []
  type: TYPE_NORMAL
- en: 'Oh, right. I forgot to read the init''s message and failed to run `glide-update`.
    Let''s do that next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94c01af8-0e43-4cc6-9d70-2eb95fb81da1.png)'
  prefs: []
  type: TYPE_IMG
- en: Success!
  prefs: []
  type: TYPE_NORMAL
- en: What might happen when we try to run our tests?
  prefs: []
  type: TYPE_NORMAL
- en: 'When we `cd` into our `02_fib` example application and type `go test -bench=.
    ./...`, we might run into a few errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0d14403-85bc-44eb-a136-162a50b05a40.png)'
  prefs: []
  type: TYPE_IMG
- en: This could happen if our `GOROOT` and/or `GOPATH` gets set to an invalid value.
  prefs: []
  type: TYPE_NORMAL
- en: There are two obvious errors here. The environment variables, `GOROOT` and `GOPATH`,
    are both invalid.
  prefs: []
  type: TYPE_NORMAL
- en: 'We find the path for `GOROOT` on a Mac computer by typing `brew info go|grep
    Cellar|grep -v export`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c7d8a00-1c72-428b-b86c-96b9a6dafbda.png)'
  prefs: []
  type: TYPE_IMG
- en: We just happen to know that we need to add the `libexec` directory to the path
    that returned the result as shown in previous screenshot, to set our `GOPATH`.
    We'll set our `GOPATH` to the root directory of our current application, that
    is, our current directory. We also set the `GOBIN` path to tell Go where to store
    the executable file that gets created when we compile our source code.
  prefs: []
  type: TYPE_NORMAL
- en: Since we won't need to handle any third-party packages in this chapter, we don't
    need to deal with dependency management. There are more than a dozen Go dependency
    management tools available. For subsequent chapters, we'll use Glide ([https://github.com/Masterminds/glide](https://github.com/Masterminds/glide))
    for package management and a very lightweight wrapper dot init that further simplifies
    our build and run processes. For details, see the Appendix.
  prefs: []
  type: TYPE_NORMAL
- en: Note that dot init eliminates the possibility of these sort of errors.
  prefs: []
  type: TYPE_NORMAL
- en: That was a lot of information for a tool that is supposed to simplify things.
    True, but nearly every time, all you need to know is in the *TL;DR* section.
  prefs: []
  type: TYPE_NORMAL
- en: How to propose changes to Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I am certain that Generics are not supported in Go (not even in Go 2.0), and
    as mentioned in the summary, I'm okay with that.
  prefs: []
  type: TYPE_NORMAL
- en: However, the feature that we'd benefit most greatly from, if Go had it, is **Tail
    Call Optimization** (**TCO**).
  prefs: []
  type: TYPE_NORMAL
- en: The first step - search specs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Is it possible that Go already supports TCO? Time to find out.
  prefs: []
  type: TYPE_NORMAL
- en: First, I looked at the Go language specification for any mention of a TCO feature
    ([https://golang.org/ref/spec](https://golang.org/ref/spec)).
  prefs: []
  type: TYPE_NORMAL
- en: I found nothing about TCO.
  prefs: []
  type: TYPE_NORMAL
- en: Second step - Google search
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, I did the requisite Google search, and found this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd8626a0-04f0-43b7-9c38-1f659b87cfa1.png)'
  prefs: []
  type: TYPE_IMG
- en: The official Golang change proposal process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Then, I learned about the process of proposing changes to Go ([https://github.com/golang/proposal/](https://github.com/golang/proposal/)).
  prefs: []
  type: TYPE_NORMAL
- en: Search for existing issues
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here's the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, visit [https://github.com/golang/go/issues](https://github.com/golang/go/issues)
     and search the language feature you''d like to be added to go, for example, type `tail
    call optimization`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57a9bbcf-81ab-4f83-b9eb-9f60e9aa4f5a.png)'
  prefs: []
  type: TYPE_IMG
- en: Reading existing proposals
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I clicked on the line (with 13 comments) to see details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0cf166dd-e498-4bd9-bcd8-bcad6dc3a7cd.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the feature that would dramatically improve our recursive function calls,
    for example, the Y-Combinator.
  prefs: []
  type: TYPE_NORMAL
- en: Remember our benchmark test results from running the `SumRecursive` function
    in [Chapter 1](../Text/Ch01.xhtml), *Pure Functional Programming in Go*? It was
    about three times slower that the imperative version. The lack of TCO is the single
    most important reason why using FP on Go today is generally not recommended. Adding
    TCO to the list of Go's compiler features would solve this problem. That is why
    this low impact, high reward feature is so important.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other proposals that included more information in the initial post,
    which is a better way to present our idea. However, when we read the subsequent
    comments, details become more apparent. When I read the following comments, I
    was convinced that this proposal gets my vote:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e6854e6-0cdc-43f7-ae17-cf5d7c7cb027.png)![](img/cb6b8824-8119-482e-9aee-c9bfaf05e34f.png)'
  prefs: []
  type: TYPE_IMG
- en: I think sharing an example of the `@tco` annotation I have in mind could bring
    more attention to this proposal. But it is about a month before my book is published.
    Do I enter the following comment in now and say, "*wait for my book to get all,
    the glory details*." or wait? What the heck, I'm going for it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a comment to the existing TCO proposal
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can read the comment at [https://github.com/golang/go/issues/16798](https://github.com/golang/go/issues/16798).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3a36924-b456-46cd-b5a9-cd86a171cff2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, I wonder if my request warrants a separate proposal for the compiler directive?
    For example, *Proposal: Add compiler hints in the form of comment annotations*.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll just leave that comment as is and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: The comment turned into a new proposal ([https://github.com/golang/go/issues/22624](https://github.com/golang/go/issues/22624)).
  prefs: []
  type: TYPE_NORMAL
- en: The conversation is ongoing as this book goes to the press.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new proposal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If I had not found this existing proposal, this is what I would have done.
    Go to [https://github.com/golang/go/issues/new](https://github.com/golang/go/issues/new)
    to create an issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33a4d7fb-5b63-4e5e-8aef-6cbf94aa4ef5.png)'
  prefs: []
  type: TYPE_IMG
- en: Assuming after writing the proposal, if it becomes obvious from the questions
    that I failed to clearly define the proposal in the proposal message, I could
    then create a design document to help clarify the request.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a design document
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I would go here, [https://github.com/golang/proposal/](https://github.com/golang/proposal/)
     click  on the Create new file button, and save it as  `design/NNNN-tco-annotation.md`, where
    `NNNN` is the GitHub issue number and `tco-annotation` is its short name. For
    example, `15292-generics.md` ([https://github.com/golang/proposal/blob/master/design/15292-generics.md](https://github.com/golang/proposal/blob/master/design/15292-generics.md)).
  prefs: []
  type: TYPE_NORMAL
- en: The design doc should follow the design template format at: [https://github.com/golang/proposal/blob/master/design/TEMPLATE.md](https://github.com/golang/proposal/blob/master/design/TEMPLATE.md).
  prefs: []
  type: TYPE_NORMAL
- en: Sending an email to notify the golang-dev group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After saving the design document, I would post a NEW TOPIC to the  `golang-dev`
    mail group, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cf12e22-a98b-432f-a47c-302b947cad84.png)'
  prefs: []
  type: TYPE_IMG
- en: An example proposal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s an example of the notification email for a well-written proposal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54e64b3f-fea1-4ece-94e2-710d3dfcfbe5.png)'
  prefs: []
  type: TYPE_IMG
- en: Monitoring a proposal until the resolution is reached
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I would monitor my inbox for new messages regarding the proposal  to check whether
    I needed to add clarification. Once comments and revisions on the design doc wind
    down, there will be a final discussion about the proposal and it will either be
    accepted or declined.
  prefs: []
  type: TYPE_NORMAL
- en: FP resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rather than compiling a list of functional programming resources that would
    interest Go developers here, I''ll make a github repo that can be updated over
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[ https://github.com/l3x/fp-resources](https://github.com/l3x/fp-resources)'
  prefs: []
  type: TYPE_NORMAL
- en: If you are aware of any missing links, feel free to submit a pull request so
    that I can update the information for everyone to see.
  prefs: []
  type: TYPE_NORMAL
- en: Minggatu - Catalan number
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](img/b650000a-ba51-4bac-b783-8984968f7ae5.png)'
  prefs: []
  type: TYPE_IMG
- en: The discovery of the Catalan number is generally credited to Eugene Catalan
    in 1844, even though it was actually originally discovered more than 100 years
    earlier by the Chinese mathematician Minggatu  (1730).
  prefs: []
  type: TYPE_NORMAL
- en: 'The nth Catalan number can be represented by the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e26adf67-9406-4d08-901d-04802f18626f.png)'
  prefs: []
  type: TYPE_IMG
- en: The first few Catalan numbers for n = 0, 1, 2, 3, 4, 5, 6 are 1, 1, 2, 5, 14,
    42, 132.
  prefs: []
  type: TYPE_NORMAL
- en: The Catalan numbers are a sequence of numbers that appear in many counting and
    computer science solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way for me to explain the concept is by answering, How many *mountain
    tops* can you form with n upstroke and n downstroke that all stay above the original
    line?
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable C[n] number of mountain tops containing n pairs of matching /\
    characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let's use use textual delimiters (of open and close parenthesis) to represent
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: Catalan numbers are a fundamental concept of containment often used to assist
    the conceptualization and design of new software and hardware architectures based
    in combinatory logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable C[n] is the number of expressions containing n pairs with matching
    parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The connection to lambda calculus is that that combinatory logic of matching
    parenthesis is sufficiently expressive to formalize recursive functions, and we
    know from our study of the Y-Combinator that recursive functions are fundamental.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a better intuition, consider that in most programming languages, code is
    represented internally by the interpreter or compiler using an **abstract syntax
    tree** (**AST**). An AST decomposes blocks of code into its smallest parts, making
    it easy to transform, analyze, or execute the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following AST chart represents the preceding code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0a1d67c-a1ca-49d3-8cdc-e536ac719f09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s about what that code block looks like in LISP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We use parentheses to represent the AST. An open parenthesis, "(", means step
    down a level of the tree, and a close parenthesis, ")", means step back up a level
    of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways we could represent a tree structure in code.
  prefs: []
  type: TYPE_NORMAL
- en: An explanation and call to action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Though this information is directly applicable and meaningful to functional
    programming, it was not placed in the *History of Functional Programming* because
    the discovery dates were not in line with the sequence of events that lead directly
    to the invention/discovery of The Lambda calculus by Alonzo Church.
  prefs: []
  type: TYPE_NORMAL
- en: This serves to show that people often think along the same lines, but for lack
    of communication/collaboration, nobody knows and nobody benefits from each other's
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Today, we are neither bound by distance nor by planes, trains, or automobiles,
    but by human nature.
  prefs: []
  type: TYPE_NORMAL
- en: I believe that if it were up to software engineers and mathematicians, we would
    all share equally and rapidly. We are eager to share what we have learned and
    created (and love), but it's the corporation owners and governments (motivated
    by greed and power) that shut our mouths.
  prefs: []
  type: TYPE_NORMAL
- en: I would like to acknowledge the great thinkers around the world like Minggatu
    and urge my fellow engineers, of all nations, to join in an effort to replace
    the lust for power with our love and passion for science.
  prefs: []
  type: TYPE_NORMAL
- en: '**f(x)** is pure. Humanity can be impure.'
  prefs: []
  type: TYPE_NORMAL
- en: The Lambda Calculus (refer to the Y-Combinator and DNA Double Helix section
    in the last chapter)  is empirical proof that we (Chinese, Russian, Korean, Indian,
    African, Arab, American, and so on) are all more alike than we are different.
  prefs: []
  type: TYPE_NORMAL
- en: We are all created equal. Let's substitute the love for power with the power
    of love. Let's put our differences aside and collaborate, whenever possible, to
    make a better world.
  prefs: []
  type: TYPE_NORMAL
- en: Peace,
  prefs: []
  type: TYPE_NORMAL
- en: Lex
  prefs: []
  type: TYPE_NORMAL
