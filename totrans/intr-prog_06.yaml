- en: Java Language Elements and Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java语言元素和类型
- en: This chapter starts a systematic introduction to Java with a definition of language
    elements—identifiers, variables, literals, keywords, separators, and comments.
    It also describes Java types—primitive types and reference types. Special attention
    is applied to the `String` class, `enum` types, and arrays.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从定义语言元素-标识符、变量、文字、关键字、分隔符和注释开始系统地介绍Java。它还描述了Java类型-原始类型和引用类型。特别关注`String`类、`enum`类型和数组。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What are the Java language elements?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Java语言元素？
- en: Comments
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释
- en: Identifiers and variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符和变量
- en: Reserved and restricted keywords
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留和受限关键字
- en: Separators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分隔符
- en: Primitive types and literals
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始类型和文字
- en: Reference types and String
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型和字符串
- en: Arrays
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Enum types
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举类型
- en: Exercise – Variable declarations and initializations
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习-变量声明和初始化
- en: What are the Java language elements?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Java语言元素？
- en: As with any programming language, Java has a grammar that is applied to the
    language elements. The elements are building blocks used to compose language structures
    that allow the programmer to express intent. Elements themselves have different
    levels of complexity. Lower-level (simpler) elements enable building higher-level
    (more complex) ones. For a more detailed and systematic treatment of Java grammar
    and language elements, please see the Java Specification ([https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何编程语言一样，Java具有适用于语言元素的语法。这些元素是用于构成语言结构的构建块，允许程序员表达意图。元素本身具有不同的复杂性级别。较低级别（更简单）的元素使得构建更高级别（更复杂）的元素成为可能。有关Java语法和语言元素的更详细和系统的处理，请参阅Java规范（[https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)）。
- en: In this book, we start with input elements that belong to one of the lowest
    levels. They are called **input elements** because they serve as input to the
    Java compiler.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们从属于最低级别之一的输入元素开始。它们被称为**输入元素**，因为它们作为Java编译器的输入。
- en: Input elements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入元素
- en: 'Java input elements, according to the Java Specification, can be one of the
    following three:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Java规范，Java输入元素可以是以下三种之一：
- en: '**Whitespace**: This can be one of these ASCII characters--SP (space), HT (horizontal
    tab), or FF (form feed, also called page break)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空白字符：可以是这些ASCII字符之一- SP（空格），HT（水平制表符）或FF（换页符，也称为分页符）
- en: '**Comment**: A free-formed text that is not processed by the compiler but transferred
    into the bytecode as-is, so programmers use a comment to add a human-readable
    explanation to the code as they write it. A comment can include a whitespace,
    but it is not recognized as an input element; it is processed as a part of the
    comment only. We will describe the grammar rules for a comment and show some examples in
    the *Comments* section.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释：一个自由形式的文本，不会被编译器处理，而是原样转换为字节码，因此程序员在编写代码时使用注释来添加人类可读的解释。注释可以包括空格，但不会被识别为输入元素；它只会作为注释的一部分进行处理。我们将在*注释*部分描述注释的语法规则并展示一些示例。
- en: '**Token**: This can be one of the following:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令牌：可以是以下之一：
- en: '**Identifier**: Will be described in the *Identifiers and variables* section.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符：将在*标识符和变量*部分描述。
- en: '**Keyword**: Will be described in the *Reserved and restricted keywords* section.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字：将在*保留和受限关键字*部分描述。
- en: '**Separator**: Will be described in the *Separators* section.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分隔符：将在*分隔符*部分描述。
- en: '**Literal**: Will be described in the *Primitive types and literals* section.
    Some literals can include a whitespace, but it is not recognized as an input element;
    the whitespace is processed as a part of the literal only.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文字：将在*原始类型和文字*部分描述。一些文字可以包括空格，但不会被识别为输入元素；空格只会作为文字的一部分进行处理。
- en: '**Operator**: Will be described in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml),
    *Operators, Expressions, and Statements**. *'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符：将在[第9章](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml)中描述，*运算符、表达式和语句**。*
- en: Input elements are used to compose more complex elements, including types. Some
    of the keywords are used to denote types, and we will also discuss them in this
    chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 输入元素用于构成更复杂的元素，包括类型。一些关键字用于表示类型，我们也将在本章中讨论它们。
- en: Types
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: Java is a strongly typed language, which means that any variable declaration
    must include its type. Type limits the value a variable can hold and how this
    value can be passed around.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Java是一种强类型语言，这意味着任何变量声明必须包括其类型。类型限制了变量可以保存的值以及如何传递这个值。
- en: 'All types in Java are divided into two categories:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的所有类型分为两类：
- en: '**Primitive types**: Described in the *Primitive types and literals* section'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始类型：在*原始类型和文字*部分描述
- en: '**Reference types**: Described in the *Reference types and String* section'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型：在*引用类型和字符串*部分描述
- en: 'Some of the reference types require more attention, either because of their
    complexity or other particulars that have to be explained to avoid future confusion:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一些引用类型需要更多关注，要么是因为它们的复杂性，要么是因为其他细节，必须解释清楚以避免将来的混淆：
- en: '**Arrays**: Described in the *Arrays* section'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组：在*数组*部分描述
- en: '**String** (the uppercase first character indicates it is the name of a class):
    Described in the *Reference types and String* section'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串（大写的第一个字符表示它是一个类的名称）：在*引用类型和字符串*部分描述
- en: '**Enum types**: Described in the *Enum types* section'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举类型：在*枚举类型*部分描述
- en: Comments
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释
- en: 'The Java Specification provides the following information about comments:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Java规范提供了关于注释的以下信息：
- en: '"There are two kinds of comments:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '"有两种注释：'
- en: /* text */
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: /*文本*/
- en: 'A traditional comment: all the text from the ASCII characters /* to the ASCII
    characters */ is ignored (as in C and C++).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 传统注释：从ASCII字符/*到ASCII字符*/的所有文本都被忽略（与C和C++一样）。
- en: // text
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: //文本
- en: 'An end-of-line comment: all the text from the ASCII characters // to the end
    of the line is ignored (as in C++)."'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 行尾注释：从ASCII字符//到行尾的所有文本都被忽略（就像C++中一样）。
- en: 'Here is an example of comments in the `SimpleMath` class that we have written
    already:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们已经编写的`SimpleMath`类中注释的一个例子：
- en: '```java'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class SimpleMath {
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: public class SimpleMath {
- en: /*
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: /*
- en: This method just multiplies any integer by 2
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法只是将任何整数乘以2
- en: and returns the result
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 并返回结果
- en: '*/'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*/'
- en: public int multiplyByTwo(int i){
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: public int multiplyByTwo(int i){
- en: //Should we check if i is bigger than 1/2 of Integer.MAX_VALUE ?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: //我们应该检查i是否大于Integer.MAX_VALUE的1/2吗？
- en: return i * 2; // The magic happens here
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: return i * 2; //魔术发生在这里
- en: '}'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The comments do not affect the code in any way. They are just programmer's notes.
    Also, don't confuse them with JavaDoc or another documentation generating system.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注释不会以任何方式影响代码。它们只是程序员的注释。此外，不要将它们与JavaDoc或其他文档生成系统混淆。
- en: Identifiers and variables
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标识符和变量
- en: Identifiers and variables are among the most often used elements of Java. They
    are closely coupled because every variable has a name and the name of a variable
    is an identifier.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符和变量是Java中最常用的元素之一。它们密切相关，因为每个变量都有一个名称，而变量的名称是一个标识符。
- en: Identifier
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标识符
- en: 'An identifier is the first in the list of Java tokens. It is a sequence of
    symbols, each may be a letter, a dollar sign `$`, an underscore, `_`, or any digit
    0-9. The restrictions are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符是Java标记列表中的第一个。它是一系列符号，每个符号可以是字母、美元符号`$`、下划线`_`或任何数字0-9。限制如下：
- en: The first symbol of an identifier cannot be a digit
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符的第一个符号不能是数字
- en: A single-symbol identifier cannot be an underscore `_`
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个符号标识符不能是下划线`_`
- en: An identifier cannot have the same spelling as a keyword (see the *Reserved
    and restricted keywords* section)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符不能与关键字拼写相同（请参阅*保留和受限关键字*部分）
- en: An identifier cannot be a Boolean literal `true` or `false`
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符不能是布尔文字`true`或`false`
- en: An identifier cannot be spelled as a special type `null`
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符不能拼写为特殊类型`null`
- en: If any of the above restrictions is violated, a compiler generates an error.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果违反上述任何限制，编译器将生成错误。
- en: 'In practice, the letters used for an identifier are usually taken from the
    English alphabet – lowercase or uppercase. But it is possible to use other alphabets,
    too. You can find the formal definition of the letters that can be included in
    the identifier in section 3.8 of the Java Specification ([https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)).
    Here is the list of the examples from that section:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，标识符使用的字母通常来自英文字母表-小写或大写。但也可以使用其他字母表。您可以在Java规范的第3.8节中找到可以包含在标识符中的字母的正式定义（[https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)）。以下是该部分示例的列表：
- en: '`i3`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i3`'
- en: '`αρετη`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`αρετη`'
- en: '`String`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`'
- en: '`MAX_VALUE`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAX_VALUE`'
- en: '`isLetterOrDigit`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isLetterOrDigit`'
- en: 'To show the variety of possibilities, we can add two more examples of legal
    identifiers:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示各种可能性，我们可以再添加两个合法标识符的示例：
- en: '`$`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`'
- en: '`_1`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_1`'
- en: Variable
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: A variable is a storage location, as the Java Specification puts it in the *Variables *section.
    It has a name (an identifier) and an assigned type. A variable refers to the memory
    where a value is stored.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是一个存储位置，正如Java规范在*变量*部分所述。它有一个名称（标识符）和一个分配的类型。变量指的是存储值的内存。
- en: 'The Java Specification has provision for eight kinds of variables:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Java规范规定了八种变量：
- en: '**Class variable**: A static class member that can be used without creating
    an object'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类变量**：可以在不创建对象的情况下使用的静态类成员'
- en: '**Instance variable**: A non-static class member that can be used only via
    an object'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实例变量**：只能通过对象使用的非静态类成员'
- en: '**Array component**: An array element (see the *Arrays* section)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数组成员**：数组元素（参见*数组*部分）'
- en: '**Method parameter**: An argument passed to a method'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法参数**：传递给方法的参数'
- en: '**Constructor parameter**: An argument passed to a constructor when an object
    is created'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数参数**：创建对象时传递给构造函数的参数'
- en: '**Lambda parameter**: An argument passed to a lambda expression. We will talk
    about it in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambda
    Expressions and Functional Programming*'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lambda参数**：传递给lambda表达式的参数。我们将在[第17章](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml)中讨论它，*Lambda表达式和函数式编程*'
- en: '**Exception parameter**: It is created when an exception is caught, we will
    talk about it in [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control
    Flow Statements*'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常参数**：在捕获异常时创建，我们将在[第10章](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml)中讨论它，*控制流语句*'
- en: '**Local variable**: A variable declared inside a method'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部变量**：在方法内声明的变量'
- en: 'From a practical point of view, all eight kinds of variables can be summarized
    as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际角度看，所有八种变量可以总结如下：
- en: A class member, static or not
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类成员，静态或非静态
- en: An array member (also called a component or an element)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组成员（也称为组件或元素）
- en: A parameter of a method, constructor, or lambda expression
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法、构造函数或lambda表达式的参数
- en: An exception parameter of a catch-block
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: catch块的异常参数
- en: A regular local code variable, the most common kind
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常规的局部代码变量，最常见的一种
- en: Most of the time, when programmers talk about a variable, they mean the last
    kind. It can refer to a class member, class instance, parameter, exception object,
    or any other value necessary for the code you are writing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，当程序员谈论变量时，他们指的是最后一种。它可以是类成员、类实例、参数、异常对象或您正在编写的代码所需的任何其他值。
- en: Variable declaration, definition, and initialization
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量声明、定义和初始化
- en: 'Let''s look at the examples first. Let''s assume we have these three lines
    of code consecutively:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看一下例子。假设我们连续有这三行代码：
- en: '```java'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int x;  //declartion of variable x
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: int x; //变量x的声明
- en: x = 1;  //initialization of variable x
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: x = 1; //初始化变量x
- en: x = 2;  //assignment of variable x
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: x = 2; //变量x的赋值
- en: '```'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can guess from the preceding example, variable initialization is assigning
    the first (initial) value to a variable. All subsequent assignments cannot be
    called an initialization.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中可以看出，变量初始化是将第一个（初始）值赋给变量。所有后续的赋值不能称为初始化。
- en: 'A local variable cannot be used until initialized:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本地变量在初始化之前不能使用：
- en: '```java'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int x;
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: int x;
- en: int result = x * 2;  //generates compilation error
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: int result = x * 2;  //生成编译错误
- en: '```'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The second line of the preceding code will generate a compilation error. If
    a variable is a member of a class (static or not) or a component of an array and
    not initialized explicitly, it is assigned a default value that depends on the
    variable's type (see the *Primitive types and literals* and *Reference types and
    String* sections).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的第二行将生成编译错误。如果一个变量是类的成员（静态或非静态）或数组的组件，并且没有显式初始化，它将被赋予一个默认值，该默认值取决于变量的类型（参见*Primitive
    types and literals*和*Reference types and String*部分）。
- en: A declaration creates a new variable. It includes the variable type and name
    (identifier). The word **declaration** is a technical term used in the Java Specification,
    section 6.1 ([https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)).
    But some programmers use word definition as the synonym for declaration because
    the word definition is used in some other programming languages (C and C++, for
    example) for a type of statement that does not exist in Java. So, be aware of
    it and assume they mean declaration when you here *definition* applied to Java.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 声明创建一个新变量。它包括变量类型和名称（标识符）。单词**declaration**是Java规范中使用的一个技术术语，第6.1节（[https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)）。但是一些程序员在Java中使用单词definition作为declaration的同义词，因为在其他一些编程语言（例如C和C++）中，单词definition用于Java中不存在的一种语句类型。因此，要注意这一点，并假设当你听到*definition*应用于Java时，它们指的是declaration。
- en: 'Most of the time, when writing Java code, programmers combine declaration and
    initialization statements in one.  For example, a variable of the `int` type can
    be declared and initialized to hold integer `1`, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写Java代码时，大多数情况下，程序员将声明和初始化语句结合在一起。例如，可以声明并初始化一个`int`类型的变量来保存整数`1`，如下所示：
- en: '```java'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int $ = 1;
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: int $ = 1;
- en: int _1 = 1;
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: int _1 = 1;
- en: int i3 = 1;
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: int i3 = 1;
- en: int αρετη = 1;
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: int αρετη = 1;
- en: int String = 1;
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: int String = 1;
- en: int MAX_VALUE = 1;
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: int MAX_VALUE = 1;
- en: int isLetterOrDigit = 1;
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: int isLetterOrDigit = 1;
- en: '```'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The same identifiers can be used to declare and initialize a variable of the
    `String` type to hold `abs`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的标识符可以用来声明和初始化一个`String`类型的变量来保存`abs`：
- en: '```java'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String $ = "abc";
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: String $ = "abc";
- en: String _1 = "abc";
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: String _1 = "abc";
- en: String i3 = "abc";
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: String i3 = "abc";
- en: String αρετη = "abc";
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: String αρετη = "abc";
- en: String String = "abc";
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: String String = "abc";
- en: String MAX_VALUE = "abc";
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: String MAX_VALUE = "abc";
- en: String isLetterOrDigit = "abc";
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: String isLetterOrDigit = "abc";
- en: '```'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you may have noticed, in the preceding examples, we used the identifiers
    from the examples of the *Identifier* section.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，在前面的例子中，我们使用了*Identifier*部分示例中的标识符。
- en: Final variable (constant)
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: final变量（常量）
- en: 'A final variable is a variable that, once initialized, cannot be assigned to
    another value. It is denoted by the `final` keyword:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: final变量是一旦初始化就不能被赋予另一个值的变量。它由`final`关键字表示：
- en: '```java'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void someMethod(){
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: void someMethod(){
- en: final int x = 1;
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: final int x = 1;
- en: x = 2; //generates compilation error
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: x = 2; //生成编译错误
- en: //some other code
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: //一些其他代码
- en: '}'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Nevertheless, the following code will work just fine:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，以下代码将正常工作：
- en: '```java'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void someMethod(){
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: void someMethod(){
- en: final int x;
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: final int x;
- en: //Any code that does not use variable x can be added here
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: //可以在这里添加任何不使用变量x的代码
- en: x = 2;
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: x = 2;
- en: //some other code
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: //一些其他代码
- en: '}'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: The preceding code does not generate a compilation error because the local variable
    is not initialized to a default value automatically in a declaration statement.
    Only the class, instance variable, or array component is initialized to a default
    value if the variable is not initialized explicitly (see the *Primitive types
    and literals* and *Reference types and String* sections).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码不会生成编译错误，因为在声明语句中，本地变量不会自动初始化为默认值。只有在变量没有显式初始化时，类、实例变量或数组组件才会被初始化为默认值（参见*Primitive
    types and literals*和*Reference types and String*部分）。
- en: When a final variable refers to an object, it cannot be assigned to another
    object, but the state of the object assigned can be changed at any time (see the *Reference
    types and String* section). The same applies to a variable that refers an array,
    because an array is an object (see the* Arrays* section).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个final变量引用一个对象时，它不能被赋值给另一个对象，但是随时可以改变被分配的对象的状态（参见*引用类型和String*部分）。对于引用数组的变量也是一样，因为数组是一个对象（参见*数组*部分）。
- en: 'Since a final variable cannot be changed, it is a constant. It is called a
    constant variable if it has a primitive type or a type of `String`. But Java programmers
    apply the term constant usually to the class-level final static variables, and
    call the local final variable just final variable. The identifier of class-level
    constants by convention is written in capital letters. Here are a few examples:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于final变量不能被更改，它是一个常量。如果它具有原始类型或`String`类型，则称为常量变量。但是Java程序员通常将术语常量应用于类级别的final静态变量，并将本地final变量称为final变量。按照惯例，类级别常量的标识符以大写字母写入。以下是一些示例：
- en: '```java'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: static final String FEBRUARY = "February";
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: static final String FEBRUARY = "February";
- en: static final int DAYS_IN_DECEMBER = 31;
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: static final int DAYS_IN_DECEMBER = 31;
- en: '```'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Such constants look very similar to the following constants:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些常量看起来与以下常量非常相似：
- en: '```java'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Month.FEBRUARY;
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Month.FEBRUARY;
- en: TimeUnit.DAYS;
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: TimeUnit.DAYS;
- en: DayOfWeek.FRIDAY;
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: DayOfWeek.FRIDAY;
- en: '```'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: But the preceding constants are defined in a special kind of class, called `enum`,
    although for all practical purposes, all constants behave similarly in the sense
    that they cannot be changed. One just has to check the type of a constant in order
    to know what methods its class (type) provides.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 但前面的常量是在一种特殊类型的类中定义的，称为`enum`，尽管在所有实际目的上，所有常量的行为都是相似的，因为它们不能被更改。只需检查常量的类型，就可以知道其类（类型）提供了什么方法。
- en: Reserved and restricted keywords
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保留和受限关键字
- en: A keyword is the second of Java tokens listed in the *Input types* section. We
    have seen several Java keywords already—`abstract`, `class`, `final`, `implements`, `int`, `interface`, `new`,
    `package`, `private`, `public`, `return`, `static`, and `void`. Now we will present
    the full list of the reserved keywords. These keywords cannot be used as identifiers.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字是Java标记中列出的第二个，我们已经看到了几个Java关键字——`abstract`, `class`, `final`, `implements`, `int`, `interface`, `new`,
    `package`, `private`, `public`, `return`, `static`, 和 `void`。现在我们将列出所有保留关键字的完整列表。这些关键字不能用作标识符。
- en: Reserved keywords
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保留关键字
- en: 'Here is the list of all 49 keywords of Java 9:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Java 9的所有49个关键字的列表：
- en: '| abstract | class | final | implements | int |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| abstract | class | final | implements | int |'
- en: '| interface | new | package | private | public |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| interface | new | package | private | public |'
- en: '| return | static | void | if | this |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| return | static | void | if | this |'
- en: '| break | double | default | protected | throw |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| break | double | default | protected | throw |'
- en: '| byte | else  | import | synchronized | throws |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| byte | else  | import | synchronized | throws |'
- en: '| case | enum | instanceof | boolean | transient |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| case | enum | instanceof | boolean | transient |'
- en: '| catch | extends | switch | short | try |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| catch | extends | switch | short | try |'
- en: '| char | for | assert | do | finally |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| char | for | assert | do | finally |'
- en: '| continue | float | long | strictfp | volatile |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| continue | float | long | strictfp | volatile |'
- en: '| native | super | while | _ (underscore) |  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| native | super | while | _ (下划线) |  |'
- en: 'The keywords are used for different Java elements and statements, and cannot
    be used as identifiers. The `goto`, `const`, and `_` (underscore) keywords are
    not used as keywords yet, but they might in the future Java releases. For now,
    they are just included in the list of the reserved keywords to prevent their use
    as an identifier. But they can be a part of an identifier among other characters,
    for example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关键字用于不同的Java元素和语句，不能用作标识符。`goto`，`const`和`_`（下划线）关键字尚未用作关键字，但它们可能在未来的Java版本中使用。目前，它们只是包含在保留关键字列表中，以防止它们用作标识符。但它们可以作为标识符的一部分，例如：
- en: '```java'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int _ = 3; //Error, underscore is a reserved keyword
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: int _ = 3; //错误，下划线是一个保留关键字
- en: int __ = 3; //More than 1 underscore as an identifier is OK
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: int __ = 3; //作为标识符的多个下划线是可以的
- en: int _1 = 3;
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: int _1 = 3;
- en: int y_ = 3;
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: int y_ = 3;
- en: int goto_x = 3;
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: int goto_x = 3;
- en: int const1 = 3;
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: int const1 = 3;
- en: '```'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `true` and `false` words look like keywords and cannot be used as identifiers,
    but in fact they are not Java keywords. They are Boolean literals (values). We
    will define what a literal is in the *Primitive types and literals* section.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`true` 和 `false` 看起来像关键字，不能用作标识符，但实际上它们不是Java关键字。它们是布尔字面值（值）。我们将在*基本类型和字面值*部分定义字面值是什么。'
- en: And there is another word that looks like a keyword but is in fact a special
    type—`null` (see the *Reference types and String* section). It also cannot be
    used as an identifier.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个看起来像关键字的词，但实际上是一种特殊类型——`null`（参见*引用类型和字符串*部分）。它也不能用作标识符。
- en: Restricted keywords
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 受限关键字
- en: 'There are ten words that are called restricted keywords: `open`, `module`,
    `requires`, `transitive`, `exports`, `opens`, `to`, `uses`, `provides`, and `with`.
    They are called restricted because they cannot be identifiers in the context of
    a module declaration, which we will not discuss in this book. In all other places,
    it is possible to use them as identifiers. Here is one example of such usage:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有十个词被称为受限关键字：`open`，`module`，`requires`，`transitive`，`exports`，`opens`，`to`，`uses`，`provides`和`with`。它们被称为受限，因为它们在模块声明的上下文中不能作为标识符，我们将不在本书中讨论。在所有其他地方，可以将它们用作标识符。以下是这种用法的一个例子：
- en: '```java'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int to = 1;
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: int to = 1;
- en: int open = 1;
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: int open = 1;
- en: int uses = 1;
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: int uses = 1;
- en: int with = 1;
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: int with = 1;
- en: int opens =1;
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: int opens =1;
- en: int module = 1;
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: int module = 1;
- en: int exports =1;
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: int exports =1;
- en: int provides = 1;
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: int provides = 1;
- en: int requires = 1;
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: int requires = 1;
- en: int transitive = 1;
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: int transitive = 1;
- en: '```'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: However, it is a good practice not to use them as identifiers anywhere. There
    are plenty of other ways to name a variable.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最好不要在任何地方将它们用作标识符。有很多其他方法来命名一个变量。
- en: Separators
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分隔符
- en: 'A separator is the third of the Java tokens listed in the *Input types* section.
    Here are all twelve of them, in no particular order:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔符是Java标记中列出的第三个。以下是它们的全部十二个，没有特定的顺序：
- en: '```java'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: ';  { }  ( )  [ ]  ,  .  ...  ::  @'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ';  { }  ( )  [ ]  ,  .  ...  ::  @'
- en: '```'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Semicolon ";"
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分号";"
- en: 'By now, you are quite familiar with the usage of the separator `;` (semicolon).
    Its only job in Java is to terminate a statement:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经非常熟悉分隔符`;`（分号）的用法。它在Java中的唯一作用是终止语句：
- en: '```java'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int i;  //declaration statement
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: int i;  //声明语句
- en: i = 2;  //assignment statement
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: i = 2;  //赋值语句
- en: if(i == 3){    //flow control statement called if-statement
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: if(i == 3){    //流程控制语句称为if语句
- en: //do something
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: //做一些事情
- en: '}'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: for(int i = 0; i < 10; i++){
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: for(int i = 0; i < 10; i++){
- en: //do something with each value of i
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: //对i的每个值执行一些操作
- en: '}'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Braces "{}"
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大括号“{}”
- en: 'You have seen the separators `{}` (braces) around the class:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了类周围的大括号`{}`：
- en: '```java'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class SomeClass {
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 类SomeClass {
- en: //class body with code
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: //带有代码的类体
- en: '}'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'You have also seen braces around method bodies:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你也看到了方法体周围的大括号：
- en: '```java'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void someMethod(int i){
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: void someMethod(int i){
- en: //...
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: if(i == 2){
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: if(i == 2){
- en: //block of code
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: //代码块
- en: '} else {'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: //another block of code
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: //另一个代码块
- en: '}'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '...'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '}'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The braces are also used to denote a block of code in control-flow statements
    (see [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control Flow Statements*):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号也用于表示控制流语句中的代码块（参见[第10章](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml)，*控制流语句*）：
- en: '```java'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void someMethod(int i){
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: void someMethod(int i){
- en: //...
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: if(i == 2){
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: if(i == 2){
- en: //block of code
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: //another block of code
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'And they are used to initialize arrays (see the *Arrays* section):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: int[] myArray = {2,3,5};
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: There are also a few other rarely used constructs where braces are used.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Parentheses "()"
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have also seen the usage of separators `()` (parentheses) to keep the list
    of method parameters in the method definition and method invocation:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: void someMethod(int i) {
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: //...
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: String s = anotherMethod();
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: //...
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'They are also used in control-flow statements (see [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml),
    *Control Flow Statements*):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: if(i == 2){
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: //...
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'During typecasting (see the *Primitive types and literals* section), they are
    put around the type:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: long v = 23;
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: int i = (int)v;
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'As for setting the precedence of an execution (see [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml),
    *Operators, Expressions, and Statements*), you should be familiar with it from
    basic algebra:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: x = (y + z) * (a + b).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Brackets "[]"
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The separators `[]` (brackets) are used for arrays declaration (see the *Arrays* section):'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: int[] a = new int[23];
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Comma ","
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The comma `,` is used for the separation of method parameters, listed in parentheses:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: void someMethod(int i, String s, int j) {
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: //...
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: String s = anotherMethod(5, 6.1, "another param");
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: //...
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'A comma can also be used to separate variables of the same type in the declaration
    statement:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: int i, j = 2; k;
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, all three variables, `i`, `j`, and `k`, are declared
    to be of the `int` type, but only variable `j` is initialized to `2`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of a comma in a looping statement serves the same purpose of the declaration
    of multiple variables (see [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control
    Flow Statements*):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0; i < 10; i++){
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: //...
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Period "."
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The separator `.` (period) is used to separate parts of the package name, as
    you have seen in the `com.packt.javapath` example.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'You also have seen how the period was used to separate an object reference
    and the method of that object:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: int result = simpleMath.multiplyByTwo(i);
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if a `simpleMath` object had a public property of `a`, it could be
    referred to as `simpleMath.a`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Ellipsis "..."
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The separator `...` (ellipsis) is used only for varargs:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: int someMethod(int i, String s, int... k){
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: //k is an array with elements k[0], k[1], ...
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding method can be called in any of the following ways:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: someMethod(42, "abc");          //array k = null
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: someMethod(42, "abc", 42, 43);  //k[0] = 42, k[1] = 43
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: int[] k = new int[2];
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: k[0] = 42;
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: k[1] = 43;
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: someMethod(42, "abc", k);       //k[0] = 42, k[1] = 43
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java Language Basics*,
    while talking about the `main()` method, we explained the concept of `varargs`
    (variable arguments) in Java.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Colons "::"
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The separator `::` (colons) is used for method reference in lambda expressions
    (see [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambd*a E*xpressions
    and Functional Programming*):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = List.of("1", "32", "765");
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().mapToInt(Integer::valueOf).sum();
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: At sign "@"
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The separator `@` (at sign) is used to denote an annotation:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: int someMethod(String s){
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: //...
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: You have seen several examples of an annotation when we created a unit test
    in [Chapter 4](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml), *Your First Java Project*.
    There are several predefined annotations in the Java standard libraries (`@Deprecated`,
    `@Override`, and `@FunctionalInterface`, to name a few). We are going to use one
    of them (`@FunctionalInterface`) in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambd*a
    E*xpressions and Functional Programming*.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: The annotations are metadata. They describe classes, fields, and methods, but
    they themselves are not executed. The Java compiler and JVM read them and treat
    the described class, field, or method in a certain way depending on the annotation.
    For example, in [Chapter 4](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml), *Your
    First Java Project*, you saw how we used the `@Test` annotation. Adding it in
    front of a public non-static method tells JVM that it is a test method that has
    to be run. So, if you execute this class, the JVM will run only this method.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Or, if you use the `@Override` annotation in front of a method, the compiler
    will check to see whether this method actually overrides a method in a parent
    class or not. If the matching signature of a non-private non-static class is not
    found in any of the class parents, the compiler will raise an error.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to create new custom annotations (JUnit framework does exactly
    that), but this topic is outside the scope of this book.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Primitive types and literals
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java has only two kinds of variable types: primitive types and reference types.
    A primitive type defines what kind of value the variable can hold and how big
    or small this value can be. We will discuss primitive types in this section.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: A reference type allows us to assign only one kind of value to the variable –
    the reference to the memory area where an object is stored. We will discuss the
    reference types in the next section, *Reference types and String*.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'Primitive types can be divided into two groups: the Boolean type and the numeric
    types. The numeric-types group can be split further into integral types (`byte`,
    `short`, `int`, `long`, and `char`) and floating-point types (float and double).'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Each primitive type is defined by a corresponding reserved keyword, listed in the *Reserved
    and restricted keywords* section.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: The Boolean type
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Boolean type allows a variable to have one of two values: `true` or `false`.
    As we mentioned in the *Reserved keywords* section, these values are Boolean literals,
    which means they are values that represent themselves directly – without a variable.
    We will talk more about literals in the *Primitive type literals* section.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a `b` variable declaration and initialization to the
    value `true`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: boolean b = true;
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'And here is another example of assigning a `true` value to the `b` Boolean
    variable using an expression:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: int x = 1, y = 1;
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: boolean b = 2 == ( x + y );
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, in the first line, two variables, `x` and `y`, of
    the `int` primitive type are declared and each assigned a value of `1`. In the
    second line, a Boolean variable is declared and assigned the result of the `2
    == ( x + y )` expression. Parentheses set the precedence of execution as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the sum of values assigned to the `x` and `y` variables
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compare the result with `2`, using the `==` Boolean operator
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will study operators and expressions in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml),
    *Operators, Expressions, and Statements*.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Variables of the Boolean are used in control-flow statements and we will see
    many examples of their usage in [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml),
    *Control Flow Statements*.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Integral types
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Values of Java integral types occupy different amounts of memory:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'byte: 8 bit'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'char: 16 bit'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'short: 16 bit'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'int: 32 bit'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'long: 64 bit'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of them, except `char`, are signed integer. The sign value (`0` for minus
    "`-`" and `1` for plus "`+`") occupies the first bit of the binary representation
    of the value. That is why a signed integer can hold, as a positive number, only
    half of the value an unsigned integer can. But it allows a signed integer to hold
    a negative number, which an unsigned integer cannot do. For example, in case of
    the `byte` type (8 bit), if it were an unsigned integer, the range of the values
    it could hold would be from 0 to 255 (including 0 and 255) because 2 to the power
    of 8 is 256\. But, as we have said, the `byte` type is a signed integer, which
    means the range of values it can hold is from -128 to 127 (including -128, 127,
    and 0).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the `char` type, it can hold values from 0 to 65,535 inclusive because
    it is an unsigned integer. This integer (called a code point) identifies a record
    in the Unicode table ([https://en.wikipedia.org/wiki/List_of_Unicode_characters](https://en.wikipedia.org/wiki/List_of_Unicode_characters)).
    Each Unicode table record has the following columns:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '**Code point**: A decimal value – a numeric representation of the Unicode record'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unicode escape**: A four-digit number with the `\u` prefix'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Printable symbol**: A graphic representation of the Unicode record (not available
    for control codes)'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description:** A human-readable description of the symbol'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are five records from the Unicode table:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '| **Code point** | **Unicode escape** | **Printable symbol** | **Description**
    |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
- en: '| 8 | \u0008 |  | Backspace |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
- en: '| 10 | \u000A |  | Line feed |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
- en: '| 36 | \u0024 | `$` | Dollar sign |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
- en: '| 51 | \u0033 | `3` | Digit three |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
- en: '| 97 | \u0061 | `a` | Latin small letter A |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
- en: The first two are examples of a Unicode that represents control codes that are
    not printable. A control code is used to send a command to a device (a display
    or a printer, for example). There are only 66 such codes in the Unicode set. They
    have code points from 0 to 32 inclusive and from 127 to 159 inclusive. The rest
    of 65,535 Unicode records have a printable symbol – a character that the record
    represents.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting (and often confusing) aspect of the `char` type is that a Unicode
    escape and a code point can be used interchangeably, except when the variable
    of the `char` type is involved in an arithmetic operation. In such a case, the
    value of code point is used. To demonstrate it, let''s look at the following code
    snippet (in the comments, we have captured the output):'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: char a = '3';
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(a);         //  3
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: char b = '$';
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(b);         //  $
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(a + b);     //  87
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(a + 2);     //  53
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: a = 36;
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(a);         //  $
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, variables `a` and `b` of the `char` type represent the `3` and
    `$` symbols and are displayed as these symbols as long as they are not involved
    in an arithmetic operation. Otherwise, only the code point values are used.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the five Unicode records, the `3` character has a code point
    value of 51, while the `$` character has a code point value of 36\. That is why
    adding `a` and `b` produces 87, and adding `2` to `a` results in 53.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: In the last line of the example code, we have assigned a decimal value of 36
    to the `a` variable of the `char` type. It means we have instructed JVM to assign the
    character with a code point of 36, which is the `$` character, to the `a` variable.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: And that is why the `char` type is included in the group of integral types of
    Java – because it acts as a numeric type in arithmetic operations.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'The range of values each of the primitive types can hold is as follows:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '`byte`: From -128 to 127, inclusive'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short`: From -32,768 to 32,767, inclusive'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`: From -2.147.483.648 to 2.147.483.647, inclusive'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long`: From -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807, inclusive'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char`: From ''\u0000'' to ''\uffff'' inclusive, that is, from 0 to 65,535,
    inclusive'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can access the maximum and minimum values of each type any time, using
    a corresponding wrapper class of each primitive type (we will talk about wrapper
    classes in more detail in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml),
    *Operators, Expressions, and Statements*). Here is one way to do it (in the comments,
    we have shown the output):'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以随时使用每种原始类型的相应包装类访问每种类型的最大值和最小值（我们将在[第9章](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml)中更详细地讨论包装类，*运算符，表达式和语句*）。以下是一种方法（在注释中，我们已经显示了输出）：
- en: '```java'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: byte b = Byte.MIN_VALUE;
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: byte b = Byte.MIN_VALUE;
- en: System.out.println(b);     //  -127
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(b);     //  -127
- en: b = Byte.MAX_VALUE;
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: b = Byte.MAX_VALUE;
- en: System.out.println(b);     //   128
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(b);     //   128
- en: short s = Short.MIN_VALUE;
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: short s = Short.MIN_VALUE;
- en: System.out.println(s);      // -32768
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(s);      // -32768
- en: s = Short.MAX_VALUE;
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: s = Short.MAX_VALUE;
- en: System.out.println(s);      //  32767
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(s);      //  32767
- en: int i = Integer.MIN_VALUE;
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: int i = Integer.MIN_VALUE;
- en: System.out.println(i);      // -2147483648
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(i);      // -2147483648
- en: i = Integer.MAX_VALUE;
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: i = Integer.MAX_VALUE;
- en: System.out.println(i);      //  2147483647
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(i);      //  2147483647
- en: long l = Long.MIN_VALUE;
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: long l = Long.MIN_VALUE;
- en: System.out.println(l);      // -9223372036854775808
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(l);      // -9223372036854775808
- en: l = Long.MAX_VALUE;
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: l = Long.MAX_VALUE;
- en: System.out.println(l);      //  9223372036854775807
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(l);      //  9223372036854775807
- en: char c = Character.MIN_VALUE;
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: char c = Character.MIN_VALUE;
- en: System.out.println((int)c); // 0
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println((int)c); // 0
- en: c = Character.MAX_VALUE;
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: c = Character.MAX_VALUE;
- en: System.out.println((int)c); // 65535
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println((int)c); // 65535
- en: '```'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You may have noticed the `(int)c` construct. It is called **casting**, similar
    to what happens during a movie production when an actor is tried for a particular
    role. The value of any primitive numeric types can be converted into the value
    of another primitive numeric type, provided it is not bigger than the maximum
    value of the target type. Otherwise, an error will be generated during program
    execution (such an error is called a runtime error). We will talk more about conversion
    between primitive numeric types in Chapter 9, *Operators, Expressions, and Statements*.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到了`(int)c`构造。它称为**转换**，类似于电影制作期间对演员进行特定角色的尝试。任何原始数值类型的值都可以转换为另一个原始数值类型的值，前提是它不大于目标类型的最大值。否则，在程序执行期间将生成错误（此类错误称为运行时错误）。我们将在第9章*运算符，表达式和语句*中更多地讨论原始数值类型之间的转换。
- en: A casting between numeric types and the `boolean` type is not possible. A compile-time
    error will be generated if you try to do that.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 数值类型和`boolean`类型之间的转换是不可能的。如果您尝试执行此操作，将生成编译时错误。
- en: Floating-point types
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮点类型
- en: 'In the Java Specification, the floating-point types (`float` and `double`)
    are defined as:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java规范中，浮点类型（`float`和`double`）的定义如下：
- en: '"The single-precision 32-bit and double-precision 64-bit format IEEE 754 values."'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '"单精度32位和双精度64位格式IEEE 754值。"'
- en: 'It means that the `float` type occupies 32 bits and the `double` type takes
    64 bits. They represent positive and negative numerical values with a fractional
    part after the dot "`.`": `1.2`, `345.56`, `10.`, `-1.34`.  By default, in Java,
    a numeric value with a dot in it is assumed to be of the `double` type. So, the
    following assignment causes a compilation error:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`float`类型占用32位，`double`类型占用64位。它们表示带有点“。”后的分数部分的正数和负数值：“1.2”，“345.56”，“10.”，“-1.34”。默认情况下，在Java中，带有点的数值被假定为`double`类型。因此，以下赋值会导致编译错误：
- en: '```java'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: float r = 23.4;
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: float r = 23.4;
- en: '```'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'To avoid the error, one has to indicate that the value has to be treated as
    a `float` type by appending the `f` or `F` character at the value, as follows:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免错误，必须通过在值后附加`f`或`F`字符来指示该值必须被视为`float`类型，如下所示：
- en: '```java'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: float r = 23.4f;
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: float r = 23.4f;
- en: or
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 或
- en: float r = 23.4F;
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: float r = 23.4F;
- en: '```'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The values themselves (`23.4f` and `23.4F`) are called literals. We will talk
    more about them in the *Primitive type literals* section.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值（`23.4f`和`23.4F`）本身称为文字。我们将在*原始类型文字*部分中更多地讨论它们。
- en: 'The minimum and maximum value can be found the same way as we did for integral
    numbers. Just run the following snippet of code (in the comments, we have captured
    the output we got on our computer):'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 最小值和最大值可以通过与整数相同的方式找到。只需运行以下代码片段（在注释中，我们捕获了我们在计算机上得到的输出）：
- en: '```java'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: System.out.println(Float.MIN_VALUE);  //1.4E-45
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Float.MIN_VALUE);  //1.4E-45
- en: System.out.println(Float.MAX_VALUE);  //3.4028235E38
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Float.MAX_VALUE);  //3.4028235E38
- en: System.out.println(Double.MIN_VALUE); //4.9E-324
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Double.MIN_VALUE); //4.9E-324
- en: System.out.println(Double.MAX_VALUE); //1.7976931348623157E308
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Double.MAX_VALUE); //1.7976931348623157E308
- en: '```'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The range of negative values is the same as the range of the positive numbers,
    only with the minus sign `-` in front of each number. Zero can be either `0.0`
    or `-0.0`.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 负值的范围与正数的范围相同，只是在每个数字前面加上减号`-`。零可以是`0.0`或`-0.0`。
- en: Default values of primitive types
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始类型的默认值
- en: 'After a variable is declared and before it can be used, a value has to be assigned
    to it. As we have mentioned in the *Variable declaration, definition, and initialization*
    section, a local variable must be initialized or assigned a value explicitly.
    For example:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 声明变量后，在使用之前必须为其分配一个值。正如我们在*变量声明，定义和初始化*部分中提到的，必须显式初始化或分配值给局部变量。例如：
- en: '```java'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int x;
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: int x;
- en: int y = 0;
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: int y = 0;
- en: x = 1;
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: x = 1;
- en: '```'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'But if the variable is declared as a class field (static), an instance (non-static) property,
    or an array component and is not initialized explicitly, it is initialized automatically with
    a default value. The value itself depends on the type of the variable:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果变量被声明为类字段（静态），实例（非静态）属性或数组组件，并且未显式初始化，则会自动使用默认值进行初始化。值本身取决于变量的类型：
- en: For the `byte`,  `short`, `int`, and `long` types, the default value is zero, `0`
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`byte`，`short`，`int`和`long`类型，默认值为零，`0`
- en: For the `float` and `double` types, the default value is positive zero, `0.0`
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`float`和`double`类型，默认值为正零，`0.0`
- en: For the `char` type, the default value is `\u0000` with point code zero
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`char`类型，默认值是`\u0000`，点码为零
- en: For the `boolean` type, the default value is `false`
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`boolean`类型，默认值是`false`
- en: Primitive type literals
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始类型文字
- en: A literal is the fourth of the Java tokens listed in the *Input types* section.
    It is the representation of a value. We will discuss literals of reference types in
    the *Reference types and String* section. And now we will talk about primitive
    type literals, only.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 文字是*输入类型*部分列出的Java标记中的第四个。它是一个值的表示。我们将在*引用类型和字符串*部分讨论引用类型的文字。现在我们只讨论原始类型的文字。
- en: To demonstrate literals of primitive types, we will use a `LiteralsDemo` program
    in the  `com.packt.javapath.ch05demo` package. You can create it by right-clicking
    on the `com.packt.javapath.ch05demo` package, then selecting New | Class, and
    typing the `LiteralsDemo` class name, as we have described in [Chapter 4](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml),
    *Your First Java Project*.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示原始类型的文字，我们将在`com.packt.javapath.ch05demo`包中使用一个`LiteralsDemo`程序。您可以通过右键单击`com.packt.javapath.ch05demo`包，然后选择New
    | Class，并输入`LiteralsDemo`类名来创建它，就像我们在[第4章](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml)中描述的那样，*你的第一个Java项目*。
- en: 'Among primitive types, literals of the `boolean` type are the simplest. They
    are just two: `true` and `false`. We can demonstrate it by running the following
    code:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始类型中，`boolean`类型的文字是最简单的。它们只有两个：`true`和`false`。我们可以通过运行以下代码来演示：
- en: '```java'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class LiteralsDemo {
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: public class LiteralsDemo {
- en: public static void main(String[] args){
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args){
- en: 'System.out.println("boolean literal true: " + true);'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("boolean literal true: " + true);'
- en: 'System.out.println("boolean literal false: " + false);'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("boolean literal false: " + false);'
- en: '}'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The result will look as follows:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/27cb9a73-2087-462e-865c-b651793f84e2.png)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27cb9a73-2087-462e-865c-b651793f84e2.png)'
- en: These are all possible Boolean literals (values).
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是可能的布尔文字（值）。
- en: 'Now, let''s turn to a more complex topic of the literals of the `char` type.
    They can be as follows:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向更复杂的`char`类型文字的话题。它们可以是以下形式：
- en: A single character, enclosed in single quotes
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单个字符，用单引号括起来
- en: An escape sequence, enclosed in single quotes
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个转义序列，用单引号括起来
- en: The single-quote, or apostrophe, is a character with Unicode escape `\u0027` (decimal
    code point 39). We have seen several examples of `char` type literals in the *Integral
    types* section when we demonstrated the `char` type behavior as a numeric type
    in arithmetic operations.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号，或者撇号，是一个具有Unicode转义`\u0027`（十进制代码点39）的字符。当我们在*整数类型*部分演示`char`类型在算术运算中作为数值类型的行为时，我们已经看到了几个`char`类型文字的例子。
- en: 'Here are some other examples of the `char` type literals as single characters:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`char`类型文字作为单个字符的其他示例：
- en: '```java'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'System.out.println("char literal ''a'': " + ''a'');'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("char literal ''a'': " + ''a'');'
- en: 'System.out.println("char literal ''%'': " + ''%'');'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("char literal ''%'': " + ''%'');'
- en: 'System.out.println("char literal ''\u03a9'': " + ''\u03a9''); //Omega'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("char literal ''\u03a9'': " + ''\u03a9''); //Ω'
- en: 'System.out.println("char literal ''™'': " + ''™''); //Trade mark sign'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("char literal ''™'': " + ''™''); //商标符号'
- en: '```'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If you run the preceding code, the output will be as follows:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行上面的代码，输出将如下所示：
- en: '![](img/58d9eba1-c21a-4754-84ef-2ee7419aee0e.png)'
  id: totrans-495
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58d9eba1-c21a-4754-84ef-2ee7419aee0e.png)'
- en: 'Now, let''s talk about the second kind of `char` type literal – an escape sequence.
    It is a combination of characters that acts similarly to control codes. In fact,
    some of the escape sequences include control codes. Here is the full list:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈`char`类型文字的第二种类型 - 转义序列。它是一组类似于控制码的字符组合。实际上，一些转义序列包括控制码。以下是完整列表：
- en: '`\ b` (Backspace BS, Unicode escape `\u0008`)'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\b`（退格BS，Unicode转义`\u0008`）'
- en: '`\ t` (Horizontal tab HT, Unicode escape `\u0009`)'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\t`（水平制表符HT，Unicode转义`\u0009`）'
- en: '`\ n` (Line feed LF, Unicode escape `\u000a`)'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\n`（换行LF，Unicode转义`\u000a`）'
- en: '`\ f` (Form feed FF, Unicode escape  `\u000c`)'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\f`（换页FF，Unicode转义`\u000c`）'
- en: '`\ r` (Carriage return CR, Unicode escape  `\u000d`)'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\r`（回车CR，Unicode转义`\u000d`）'
- en: '`\ "` (Double quote ", Unicode escape  `\u0022`)'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\ "`（双引号"，Unicode转义`\u0022`）'
- en: '`\ ''` (Single quote '', Unicode escape  `\u0027`)'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\``（单引号''，Unicode转义`\u0027`）'
- en: '`\ \` (Backslash \, Unicode escape  `\u005c`)'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\\`（反斜杠\，Unicode转义`\u005c`）'
- en: 'As you can see, an escape sequence always starts with a backslash (`\`). Let''s
    demonstrate some of the escape sequences usages:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，转义序列总是以反斜杠（`\`）开头。让我们演示一些转义序列的用法：
- en: '```java'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: System.out.println("The line breaks \nhere");
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("The line breaks \nhere");
- en: System.out.println("The tab is\there");
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("The tab is\here");
- en: System.out.println("\"");
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("\"");
- en: System.out.println('\'');
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println('\'');
- en: System.out.println('\\');
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println('\\');
- en: '```'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If you run the preceding code, the output will be as follows:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行上面的代码，输出将如下所示：
- en: '![](img/a24ce129-5240-40d3-a07c-bbd43fad874b.png)'
  id: totrans-514
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a24ce129-5240-40d3-a07c-bbd43fad874b.png)'
- en: As you can see, the `\n` and `\t` escape sequences act only as control codes.
    They are not printable themselves but affect the display of the text. Other escape
    sequences allow the printing of a symbol in the context that would not allow it
    to be printed otherwise. Three double or single quotes in a row would be qualified
    as a compiler error, as well as a single backslash character if being used without
    a backslash.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`\n`和`\t`转义序列只作为控制码。它们本身不可打印，但会影响文本的显示。其他转义序列允许在其他情况下无法打印的上下文中打印符号。连续三个双引号或单引号将被视为编译器错误，就像单个反斜杠字符在没有反斜杠的情况下使用时一样。
- en: 'By comparison with the `char` type literals, the float-points literals are
    much more straightforward. As we have mentioned before, by default, a `23.45` literal
    has the `double` type and there is no need to append the letter `d` or `D` to
    the literal if you would like it to be of the `double` type. But you can, if you
    prefer to be more explicit.  A `float` type literal, on the other hand, requires
    appending the letter `f` or `F` at the end. Let''s run the following example (notice
    how we use `\n` escape sequence to add a line break before the output):'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("\nfloat literal 123.456f: " + 123.456f);'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("double literal 123.456d: " + 123.456d);'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: 'The result looks as follows:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f38e82d3-eb09-42d4-946d-6d2e8179e3e2.png)'
  id: totrans-522
  prefs: []
  type: TYPE_IMG
- en: 'The floating-point type literals can also be expressed using `e` or `E` for
    scientific notation (see [https://en.wikipedia.org/wiki/Scientific_notation](https://en.wikipedia.org/wiki/Scientific_notation)):'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("\nfloat literal 1.234560e+02f: " + 1.234560e+02f);'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("double literal 1.234560e+02d: " + 1.234560e+02d);'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the preceding code looks as follows:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9719f0ac-ec78-41a5-885b-bfcdcd35cb4b.png)'
  id: totrans-529
  prefs: []
  type: TYPE_IMG
- en: As you can see, the value remain the same, whether presented in a decimal format
    or a scientific one.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: 'The literals of the `byte`,  `short`, `int`, and `long` integral types have
    the `int` type by default. The following assignments do not cause any compilation
    errors:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: byte b = 10;
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: short s = 10;
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: int i = 10;
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: long l = 10;
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: 'But each of the following lines generates an error:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: byte b = 128;
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: short s = 32768;
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: int i = 2147483648;
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: long l = 2147483648;
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: 'That is because the maximum value the `byte` type can hold is 127, the maximum
    value the `short` type can hold is 32,767, and the maximum value the `int` type
    can hold is 2,147,483,647\. Notice that, although the `long` type can a value
    as big as 9,223,372,036,854,775,807, the last assignment still fails because the 2,147,483,648
    literal has the `int` type by default but exceeds the maximum `int` type value.
    To create a literal of the `long` type, one has to append the letter `l` or `L`
    at the end, so the following assignment works just fine:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: long l = 2147483648L;
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: It is a good practice to use capital `L` for this purpose because lowercase
    letter `l` can be easily confused with the number `1`.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding examples of integral literals are expressed in a decimal number
    system. But the literals of the `byte`,  `short`, `int`, and `long` types can
    also be expressed in the binary (base 2, digits 0-1), octal (base 8, digits 0-7),
    and hexadecimal (base 16, digits 0-9 and a-f) number systems. Here is the demonstration
    code:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("\nPrint literal 12:");
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("- bin 0b1100: "+ 0b1100);'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("- oct    014: "+ 014);'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("- dec     12: "+ 12);'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("- hex    0xc: "+ 0xc);'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the preceding code, the output will be:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/239db86f-5ce2-4211-8ea6-3d63206ac0c1.png)'
  id: totrans-559
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, a binary literal starts with `0b` (or `0B`), followed by the
    value `12` expressed in a binary system: `1100` (=`2^0*0 + 2^1*0 + 2^2*1 + 2^3
    *1`). An octal literal starts with `0`, followed by the value `12` expressed in
    an octal system: `14` (=`8^0*4 + 8^1*1`). The decimal literal is just `12`. The
    hexadecimal literal starts with `0x` (or with `0X`), followed by value 12 expressed
    in a hexadecimal system—`c` (because in the hexadecimal system the symbols `a`
    to `f`  (or `A` to `F`) map to decimal values `10` to `15`).'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a minus sign (`-`) in front of a literal makes the value negative, no
    matter which numeric system is used. Here is a demonstration code:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("\nPrint literal -12:");
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("- bin 0b1100: "+ -0b1100);'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("- oct    014: "+ -014);'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("- dec     12: "+ -12);'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("- hex    0xc: "+ -0xc);'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the preceding code, the output will be as follows:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行上述代码，输出将如下所示：
- en: '![](img/5382f549-f0de-4017-a6f5-cabe01bd18d1.png)'
  id: totrans-570
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5382f549-f0de-4017-a6f5-cabe01bd18d1.png)'
- en: 'And, to complete our discussion of primitive type literals, we would like to
    mention the possible usage of the underscore (`_`) inside a primitive type literal.
    In the case of a long number, breaking it into groups helps to quickly estimate
    its magnitude. Here are a few examples:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，为了完成我们对原始类型文字的讨论，我们想提到原始类型文字中下划线（`_`）的可能用法。在长数字的情况下，将其分成组有助于快速估计其数量级。以下是一些示例：
- en: '```java'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int speedOfLightMilesSec = 299_792_458;
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: int speedOfLightMilesSec = 299_792_458;
- en: float meanRadiusOfEarthMiles = 3_958.8f;
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: float meanRadiusOfEarthMiles = 3_958.8f;
- en: long creditCardNumber = 1234_5678_9012_3456L;
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: long creditCardNumber = 1234_5678_9012_3456L;
- en: '```'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Let''s see what happens when we run the following code:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们运行以下代码时会发生什么：
- en: '```java'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: long anotherCreditCardNumber = 9876____5678_____9012____1234L;
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: long anotherCreditCardNumber = 9876____5678_____9012____1234L;
- en: System.out.println("\n" + anotherCreditCardNumber);
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("\n" + anotherCreditCardNumber);
- en: '```'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The output of the previous code would be as follows:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '![](img/65d2e9fd-81b4-42f8-b3d6-6c0413218765.png)'
  id: totrans-583
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65d2e9fd-81b4-42f8-b3d6-6c0413218765.png)'
- en: As you can see, one or many underscores are ignored if placed between digits
    inside a numeric literal. An underscore in any other location would cause a compilation
    error.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，如果在数字文字中的数字之间放置一个或多个下划线，这些下划线将被忽略。在任何其他位置放置下划线将导致编译错误。
- en: Reference types and String
  id: totrans-585
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用类型和字符串
- en: When an object is assigned to a variable, this variable holds the reference
    to the memory where the object resides. From a practical standpoint, such a variable
    is handled in the code as if it is the object it represents. The type of such
    a variable can be a class, an interface, an array, or a special `null` type. If
    `null` is assigned, the reference to the object is lost and the variable does
    not represent any object. If an object is not used anymore, JVM removes it from
    the memory in the process called **garbage collection**. We will describe this
    process in [Chapter 11](e8c37d86-291d-4500-84ea-719683172477.xhtml), *JVM Processes
    and Garbage Collection*.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象分配给变量时，此变量保存对对象所在内存的引用。从实际的角度来看，这样的变量在代码中被处理，就好像它是所代表的对象一样。这样的变量的类型可以是类、接口、数组或特殊的`null`类型。如果分配了`null`，则对象的引用将丢失，变量不再代表任何对象。如果对象不再使用，JVM将在称为**垃圾收集**的过程中从内存中删除它。我们将在[第11章](e8c37d86-291d-4500-84ea-719683172477.xhtml)中描述这个过程，*JVM进程和垃圾收集*。
- en: There is also a reference type called type variable used for the declaration
    of a type parameter of a generic class, interface, method, or constructor. It
    belongs to the area of Java generic programming that is outside of the scope of
    this book.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种称为类型变量的引用类型，用于声明泛型类、接口、方法或构造函数的类型参数。它属于Java泛型编程的范畴，超出了本书的范围。
- en: All objects, including arrays, inherit all the methods from the `java.lang.Object`
    class described in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java
    Language Basics*.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对象，包括数组，都继承自[第2章](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml)中描述的`java.lang.Object`类的所有方法，*Java语言基础*。
- en: A variable that refers to an object of the `java.lang.String` class (or just
    `String`) is a reference type, too. But, in certain respects, the `String` object
    behaves as a primitive type, which might be confusing at times. That is why we
    will dedicate a section in this chapter to the `String` class.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 引用`java.lang.String`类（或只是`String`）的变量也是引用类型。但在某些方面，`String`对象的行为类似于原始类型，这有时可能会令人困惑。这就是为什么我们将在本章中专门介绍`String`类的原因。
- en: Also, the enum type (a reference type as well) requires special attention and
    we describe it at the end of this section in the *Enum types* subsection.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，枚举类型（也是引用类型）需要特别注意，我们将在本节末尾的*枚举类型*子节中进行描述。
- en: Class types
  id: totrans-591
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类类型
- en: 'A variable of the class type is declared using the corresponding class name:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相应的类名声明类类型的变量：
- en: '```java'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: <Class name> variableName;
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: <类名> variableName;
- en: '```'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'It can be initialized by assigning to it `null` or an object (an instance)
    of the class whose name is used for the declaration. If the class has a superclass
    (also called a parent class) from which it inherits (extends), the name of the
    superclass can be used for the variable declaration. It is possible because of
    Java polymorphism, described in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml),
    *Java Language Basics*. For example, if a `SomeClass` class extends `SomeBaseClass`,
    both of the following declarations and initializations are possible:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以通过将`null`或该类的对象（实例）进行赋值来进行初始化。如果该类有一个超类（也称为父类）从中继承（扩展），则可以使用超类的名称进行变量声明。这是由于Java多态性的存在，该多态性在[第2章](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml)中有所描述，*Java语言基础*。例如，如果`SomeClass`类扩展`SomeBaseClass`，则以下声明和初始化都是可能的：
- en: '```java'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: SomeBaseClass someBaseClass = new SomeBaseClass();
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: SomeBaseClass someBaseClass = new SomeBaseClass();
- en: someBaseClass = new SomeClass();
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: someBaseClass = new SomeClass();
- en: '```'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'And, since every class extends the `java.lang.Object` class by default, the
    following declarations and initializations are possible too:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，由于每个类默认都扩展了`java.lang.Object`类，以下声明和初始化也是可能的：
- en: '```java'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Object someBaseClass = new SomeBaseClass();
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: Object someBaseClass = new SomeBaseClass();
- en: someBaseClass = new SomeClass();
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: someBaseClass = new SomeClass();
- en: '```'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We will talk more about assigning child class object to a base class reference
    in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml), *Operators, Expressions,
    and Statements*.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第9章](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml)中更多地讨论将子类对象分配给基类引用的情况，*运算符、表达式和语句*。
- en: Interface types
  id: totrans-607
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口类型
- en: 'A variable of an interface type is declared using the corresponding interface
    name:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相应的接口名称声明接口类型的变量：
- en: '```java'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: <Interface name> variableName;
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: <接口名称> variableName;
- en: '```'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'It can be initialized by assigning to it `null` or an object (an instance)
    of the class that implemented the interface. Here is an example:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以通过将`null`或实现接口的类的对象（实例）分配给它来进行初始化。这是一个例子：
- en: '```java'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: interface SomeInterface{
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 接口SomeInterface {
- en: void someMethod();
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: void someMethod（）;
- en: '}'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface SomeOtherInterface{
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 接口SomeOtherInterface {
- en: void someOtherMethod();
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: void someOtherMethod（）;
- en: '}'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class SomeClass implements SomeInterface {
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: class SomeClass implements SomeInterface {
- en: void someMethod(){
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: void someMethod（）{
- en: '...'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '}'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class SomeOtherClass implements SomeOtherInterface{
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: class SomeOtherClass implements SomeOtherInterface {
- en: void someOtherMethod(){
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: void someOtherMethod（）{
- en: '...'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '}'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: SomeInterface someInterface = new SomeClass();
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: SomeInterface someInterface = new SomeClass（）;
- en: someInterface = new SomeOtherClass(); //not possible, error
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: someInterface = new SomeOtherClass（）; //不可能，错误
- en: someInterface.someMethod();         //works just fine
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: someInterface.someMethod（）; //运行正常
- en: someInterface.someOtherMethod();   //not possible, error
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: someInterface.someOtherMethod（）; //不可能，错误
- en: '```'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We will talk more about assigning child type to a base type reference in [Chapter
    9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml), *Operators, Expressions, and Statements*.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第9章]（33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml）中更多地讨论将子类型分配给基类型引用。
- en: Arrays
  id: totrans-636
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: An array in Java is a reference type and extends (inherits from) the `Object` class,
    too. An array contains components that have the same type as the declared array
    type or the type whose values can be assigned to the array type. The number of
    components may be zero, in which case the array is an empty array.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，数组是引用类型，并且也扩展（继承自）`Object`类。数组包含与声明的数组类型相同的类型的组件，或者可以将值分配给数组类型的类型。组件的数量可以为零，在这种情况下，数组为空数组。
- en: An array component has no name and is referenced by an index, which is a positive
    integer or zero.  An array with `n` components is said to have *length of n*. Once
    an array object is created, its length never changes.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 数组组件没有名称，并且由索引引用，该索引是正整数或零。说具有*n*长度的`n`个组件的数组。一旦创建数组对象，其长度就永远不会改变。
- en: 'An array declaration starts with a type name and empty brackets `[]`:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 数组声明以类型名称和空括号`[]`开头：
- en: '```java'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: byte[] bs;
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: byte [] bs;
- en: long[][] ls;
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: long [] [] ls;
- en: Object[][] os;
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: Object [] [] os;
- en: SomeClass[][][] scs;
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: SomeClass [] [] [] scs;
- en: '```'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The number of bracket pairs indicates the number of dimensions (or the nesting
    depth) of the array.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 括号对的数量表示数组的维数（或嵌套深度）。
- en: 'There are two ways to create and initialize an array:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种创建和初始化数组的方法：
- en: 'By creation expression, using the `new` keyword, type name, and brackets with
    the length of each dimension in each pair of brackets; for example:'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过创建表达式，使用`new`关键字，类型名称和每个括号中每个维度的长度的括号;例如：
- en: '```java'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: byte[] bs = new byte[100];
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: byte [] bs = new byte [100];
- en: long[][] ls = new long [2][3];
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: long [] [] ls = new long [2] [3];
- en: Object[][] os = new Object[3][2];
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: Object [] [] os = new Object [3] [2];
- en: SomeClass[][][] scs = new SomeClass[3][2][1];
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: SomeClass [] [] [] scs = new SomeClass [3] [2] [1];
- en: '```'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'By array initializer, using a comma-separated list of values of each dimension,
    surrounded by braces, for example:'
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过数组初始化程序，使用由大括号括起来的每个维度的逗号分隔值的列表，例如：
- en: '```java'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[][] is = { { 1, 2, 3 }, { 10, 20 }, { 3, 4, 5, 6 } };
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: int [] [] is = {{1, 2, 3}, {10, 20}, {3, 4, 5, 6}};
- en: float[][] fs = { { 1.1f, 2.2f, 3 }, { 10, 20.f, 30.f } };
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: float [] [] fs = {{1.1f，2.2f，3}，{10，20.f，30.f}};
- en: Object[] oss = { new Object(), new SomeClass(), null, "abc" };
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: Object [] oss = {new Object（），new SomeClass（），null，“abc”};
- en: SomeInterface[] sis = { new SomeClass(), null, new SomeClass() };
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: SomeInterface [] sis = {new SomeClass（），null，new SomeClass（）};
- en: '```'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see from these examples, a multidimensional array can contain arrays
    of different lengths (the `int[][] is` array). Also, a component type value can
    be different from the array type as long as the value can be assigned to the variable
    of the array type (the `float[][] fs`, `Object[] is`, and `SomeInterface[] sis` arrays).
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些示例中可以看出，多维数组可以包含不同长度的数组（`int [] [] is`数组）。此外，只要值可以分配给数组类型的变量（`float [] []
    fs`，`Object [] is`和`SomeInterface [] sis`数组），组件类型值可以与数组类型不同。
- en: 'Because an array is an object, its components are initialized every time an
    array is created. Let''s consider this example:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数组是对象，所以每次创建数组时都会初始化其组件。让我们考虑这个例子：
- en: '```java'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[][] is = new int[2][3];
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: int [] [] is = new int [2] [3];
- en: System.out.println("\nis.length=" + is.length);
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“\ nis.length =” + is.length）;
- en: System.out.println("is[0].length=" + is[0].length);
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“is [0] .length =” + is [0] .length）;
- en: System.out.println("is[0][0].length=" + is[0][0]);
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“is [0] [0] .length =” + is [0] [0]）;
- en: System.out.println("is[0][1].length=" + is[0][1]);
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“is [0] [1] .length =” + is [0] [1]）;
- en: System.out.println("is[0][2].length=" + is[0][2]);
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“is [0] [2] .length =” + is [0] [2]）;
- en: System.out.println("is[1].length=" + is[0].length);
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“is [1] .length =” + is [0] .length）;
- en: System.out.println("is[1][0].length=" + is[1][0]);
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“is [1] [0] .length =” + is [1] [0]）;
- en: System.out.println("is[1][1].length=" + is[1][1]);
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“is [1] [1] .length =” + is [1] [1]）;
- en: System.out.println("is[1][2].length=" + is[1][2]);
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“is [1] [2] .length =” + is [1] [2]）;
- en: '```'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we run the preceding code snippet, the output will be as follows:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码片段，输出将如下所示：
- en: '![](img/a2463ad3-fe53-43ab-9e19-511714b556cf.png)'
  id: totrans-677
  prefs: []
  type: TYPE_IMG
  zh: ！[]（img / a2463ad3-fe53-43ab-9e19-511714b556cf.png）
- en: 'It is possible to create a multidimensional array without initializing some
    of the dimensions:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在不初始化某些维度的情况下创建多维数组：
- en: '```java'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[][] is = new int[2][];
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: int [] [] is = new int [2] [];
- en: System.out.println("\nis.length=" + is.length);
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“\ nis.length =” + is.length）;
- en: System.out.println("is[0]=" + is[0]);
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“is [0] =” + is [0]）;
- en: System.out.println("is[1]=" + is[1]);
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“is [1] =” + is [1]）;
- en: '```'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The result of this code running is as follows:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码运行的结果如下：
- en: '![](img/9c7279b2-2fe4-48b6-aa7e-b42fae6c43e1.png)'
  id: totrans-686
  prefs: []
  type: TYPE_IMG
  zh: ！[]（img / 9c7279b2-2fe4-48b6-aa7e-b42fae6c43e1.png）
- en: 'The missing dimension can be added later:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少的维度可以稍后添加：
- en: '```java'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[][] is = new int[2][];
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: int [] [] is = new int [2] [];
- en: is[0] = new int[3];
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: is [0] = new int [3];
- en: is[1] = new int[3];
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: is [1] = new int [3];
- en: '```'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The important point is that a dimension has to be initialized before it can
    be used.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，必须在使用之前初始化维度。
- en: Default value of a reference type
  id: totrans-694
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用类型的默认值
- en: The default value of a reference type is `null`. It means that if a reference
    type is a static class member or an instance field and not assigned an initial
    value explicitly, it will be initialized automatically and assigned the value
    of `null`. Please note that, in the case of an array, this applies to the array
    itself and to its reference type components.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: Reference type literals
  id: totrans-696
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `null` literal indicates the absence of any assignment to a reference type
    variable. Let''s look at the following code snippet:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass someClass = new SomeClass();
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: someClass.someMethod();
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: someClass = null;
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: someClass.someMethod(); // throws NullPointerException
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: The first statement declares the `someClass` variable and assigns to it a reference
    to the object of the `SomeClass` class. Then a method of this class is called
    using its reference. The next line assigns the `null` literal to the `someClass` variable.
    It removes the reference value from the variable. So, when in the next line, we
    try to call the same method again, we get back `NullPointerException`, which happens
    only when a reference used is assigned the `null` value.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: The `String` type is a reference type, too. This means that the default value
    of a `String` variable is `null`. The `String` class inherits all the methods
    from the `java.lang.Object` class as any other reference type does, too.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: But in some respects, objects of the `String` class behave as if they are of
    a primitive type. We will discuss one such case—when the `String` object is used
    as a method parameter—in the *Passing reference type values as method parameters* section.
    We will discuss other cases of `String` behaving like a primitive type now.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: 'Another feature of the `String` type that makes it look like a primitive type
    is that it is the only reference type that has more literals than just `null`.
    The type `String` can also have a literal of zero or more characters enclosed
    in double quotes—`""`, `"$"`, `"abc"`, and `"12-34"`. The characters of the `String`
    literal may include escape sequences, too. Here are a few examples:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("\nFirst line.\nSecond line.");
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Tab space\tin the line");
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("It is called a \"String literal\".");
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("Latin Capital Letter Y with diaeresis: \u0178");'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: 'If you execute the preceding code snippet, the output will be as follows:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4ff739c-3cd1-4b9a-8900-8273a4536a18.png)'
  id: totrans-715
  prefs: []
  type: TYPE_IMG
- en: 'But, in contrast with the `char` type literals, `String` literals do not behave
    like numbers in an arithmetic operation. The only arithmetic operation applicable
    to the `String` type is an addition, and it behaves like a concatenation:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("s1" + "s2");
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: String s1 = "s1";
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s1 + "s2");
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: String s2 = "s1";
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s1 + s2);
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the preceding code and you will see the following:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d0600b2-bac7-4769-a95f-4e7596b5f802.png)'
  id: totrans-725
  prefs: []
  type: TYPE_IMG
- en: Another particular characteristic of `String` is that an object of the `String` type is
    immutable.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: String immutability
  id: totrans-727
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One cannot change the `String` type value assigned to a variable without changing
    the reference. There are several reasons why JVM authors decided to do that:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: 'All `String` literals are stored in the same common memory area, called string
    pool. Before a new `String` literal is stored, the JVM checks whether such a literal
    is already stored there. If such an object exists already, a new object is not
    created and the reference to the existing object is returned as the reference
    to a new object. The following code demonstrates this situation:'
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("s1" == "s1");
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("s1" == "s2");
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: String s1 = "s1";
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s1 == "s1");
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s1 == "s2");
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: String s2 = "s1";
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s1 == s2);
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, we use the `==` relational operator, which is used to
    compare values of primitive types and references of reference types. If we run
    this code, the result will be as follows:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/728b25a9-08ca-45aa-a329-f818a04f7801.png)'
  id: totrans-740
  prefs: []
  type: TYPE_IMG
- en: You can see that the various comparisons of literals (directly or via a variable)
    consistently yield `true` if two literals have the same spelling, and produce
    `false` if the spelling is different. This way, long `String` literals are not
    duplicated and the memory is used better.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid concurrent modification of the same literal by different methods,
    every time we attempt to change the `String` literal, a copy of the literal with
    the change is created, while the original `String` literal remains untouched.
    Here is the code that demonstrates it:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: String s1 = "\nthe original string";
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: String s2 = s1.concat(" has been changed");
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s2);
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s1);
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: 'The `concat()` method of the `String` class adds another `String` literal to
    the original value of `s1` and assigns the result to the `s1` variable. The output
    of this code is as follows:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9007f810-5f17-47ab-a3f9-2f3a8ae6112a.png)'
  id: totrans-750
  prefs: []
  type: TYPE_IMG
- en: As you can see, the original literal assigned to `s1` did not change.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: Another reason for such a design decision is security – one of the highest-priority
    goals JVM's authors had in mind. `String` literals are widely used as username
    and passwords to access an application, database, and server. Immutability of
    the `String` value makes it less susceptible to an unauthorized modification.
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yet another reason is that there are certain calculation-intensive procedures
    (the `hashCode()` method in the `Object` parent class, for example) that could
    be quite taxing in the case of long `String` values. By making the `String` object
    immutable, such a calculation could be avoided if it was already performed on
    the value with the same spelling.
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is why all methods that modify a `String` value return the `String` type,
    which is the reference to a new `String` object that carries the result. The `concat()` method
    in the preceding code is a typical example of such a method.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: 'The matter becomes a bit more complicated in the case where a `String` object
    is created not from the literal, but using the `String` constructor, `new String("some
    literal")`. In such a case, the `String` object is stored in the same area where
    all objects of all classes are stored, and every time a `new` keyword is used,
    another chunk of memory (with another reference) is allocated. Here is the code
    that demonstrates it:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: String s3 = new String("s");
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: String s4 = new String("s");
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s3 == s4);
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run it, the output will be as follows:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d538290-5e7b-49af-a1e5-48067df41fba.png)'
  id: totrans-762
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, despite the same spelling, the objects have different memory
    references. To avoid confusion and to compare the `String` objects by their spelling
    only, always use the `equals()` method of the `String` class. Here is the code
    that demonstrates its usage:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("s5".equals("s5"));  //true
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("s5".equals("s6"));  //false
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: String s5 = "s5";
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s5.equals("s5"));   //true
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s5.equals("s6"));   //false
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: String s6 = "s6";
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s5.equals(s5));     //true
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s5.equals(s6));     //false
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: String s7 = "s6";
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s7.equals(s6));     //true
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: String s8 = new String("s6");
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s8.equals(s7));     //true
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: String s9 = new String("s9");
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s8.equals(s9));     //false
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run it, the result will be:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5dc62d29-e4c1-47de-99d1-6f0a32eedba6.png)'
  id: totrans-781
  prefs: []
  type: TYPE_IMG
- en: We added the results as the comments to the preceding code for your convenience.
    As you can see, the `equals()` method of the `String` class returns `true` or
    `false` based only on the spelling of the value, so use it all the time when spelling
    comparison is your goal.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, you may remember that the `equals()` method is defined in the `Object` class—the
    parent class of the `String` class. The `String` class has its own `equals()` method
    that overrides the method with the same signature in the parent class as we have
    demonstrated in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java
    Language Basics*. The source code of the `equals()` method of the `String` class
    looks as follows:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: public boolean equals(Object anObject) {
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: if (this == anObject) {
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: return true;
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: if (anObject instanceof String) {
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: String aString = (String)anObject;
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: if (coder() == aString.coder()) {
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: return isLatin1() ?
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: StringLatin1.equals(value, aString.value)
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: ': StringUTF16.equals(value, aString.value);'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: return false;
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it compares references first and, if they point to the same
    object, returns `true`. But, if the references are different, it compares the
    spelling of the values, which actually happens in the `equals()` method of the `StringLatin1`
    and `StringUTF16` classes.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: The point we would like you to take away is that the `equals()` method of the `String` class
    is optimized by performing the comparison of references first and, only if not
    successful, it comparing the values themselves. Which means there is no need to
    compare references in the code. Instead, for `String` type object comparison, always
    use the `equals()` method only.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: With that, we are moving to the last of the reference types we will discuss
    in this chapter—the `enum` type.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: Enum types
  id: totrans-803
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before describing the `enum` type, let''s look at one of the use cases as the
    motivation for having such a type. Let''s assume we would like to create a class
    that describes `TheBlows` family:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: public class TheBlows {
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: private String name, relation, hobby = "biking";
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: private int age;
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: public TheBlows(String name, String relation, int age) {
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: this.name = name;
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: this.relation = relation;
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: this.age = age;
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: public String getName() { return name; }
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: public String getRelation() { return relation; }
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: public int getAge() { return age; }
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: public String getHobby() { return hobby; }
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: public void setHobby(String hobby) { this.hobby = hobby; }
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: We have set the default hobby as `biking` and will allow to change it later,
    but other properties have to be set during object construction. That would fine,
    except we do not want to have more than four members of this family in the system,
    as we know all the members of `TheBlows` family very well.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: 'To impose these restrictions, we decided to create all possible objects of
    the `TheBlows` class up-front and make the constructor private:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: public class TheBlows {
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: public static TheBlows BILL = new TheBlows("Bill", "father", 42);
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: public static TheBlows BECKY = new TheBlows("BECKY", "mother", 37);
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: public static TheBlows BEE = new TheBlows("Bee", "daughter", 5);
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: public static TheBlows BOB = new TheBlows("Bob", "son", 3);
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: private String name, relation, hobby = "biking";
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: private int age;
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: private TheBlows(String name, String relation, int age) {
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: this.name = name;
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: this.relation = relation;
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: this.age = age;
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: public String getName() { return name; }
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: public String getRelation() { return relation; }
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: public int getAge() { return age; }
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: public String getHobby() { return hobby; }
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: public void setHobby(String hobby) { this.hobby = hobby; }
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: 'Now only the four instances of the `TheBlows` class exist and no other object
    of this class can be created. Let''s see what happens if we run the following
    code:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(TheBlows.BILL.getName());
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(TheBlows.BILL.getHobby());
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: TheBlows.BILL.setHobby("fishing");
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(TheBlows.BILL.getHobby());
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: 'We will get the following output:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1cc72d3-55bb-46b8-901b-e202ec027a79.png)'
  id: totrans-851
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, we can create the `TheJohns` family with three family members:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: public class TheJohns {
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: public static TheJohns JOE = new TheJohns("Joe", "father", 42);
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: public static TheJohns JOAN = new TheJohns("Joan", "mother", 37);
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: public static TheJohns JILL = new TheJohns("Jill", "daughter", 5);
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: private String name, relation, hobby = "joggling";
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: private int age;
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: private TheJohns(String name, String relation, int age) {
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: this.name = name;
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: this.relation = relation;
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: this.age = age;
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: public String getName() { return name; }
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: public String getRelation() { return relation; }
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: public int getAge() { return age; }
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: public String getHobby() { return hobby; }
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: public void setHobby(String hobby) { this.hobby = hobby; }
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: 'While doing that, we noticed a lot of commonalities in these two classes and
    decided to create a `Family` base class:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: public class Family {
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: private String name, relation, hobby;
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: private int age;
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: protected Family(String name, String relation, int age, String hobby) {
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: this.name = name;
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: this.relation = relation;
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: this.age = age;
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: this.hobby = hobby;
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: public String getName() { return name; }
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: public String getRelation() { return relation; }
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: public int getAge() { return age; }
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: public String getHobby() { return hobby; }
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: public void setHobby(String hobby) { this.hobby = hobby; }
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the `TheBlows` and `TheJohns` classes can be substantially simplified after
    extending the `Family` class. Here''s how the `TheBlows` class can now look:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: public class TheBlows extends Family {
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: public static TheBlows BILL = new TheBlows("Bill", "father", 42);
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: public static TheBlows BECKY = new TheBlows("Becky", "mother", 37);
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: public static TheBlows BEE = new TheBlows("Bee", "daughter", 5);
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: public static TheBlows BOB = new TheBlows("Bob", "son", 3);
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: private TheBlows(String name, String relation, int age) {
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: super(name, relation, age, "biking");
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: And that is the idea behind the `enum` type—to allow the creating of classes
    with a fixed number of named instances.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: 'The `enum` reference type class extends the `java.lang.Enum` class. It defines
    the set of constants, each of them an instance of the `enum` type it belongs to.
    The declaration of such a set starts with the `enum` keyword. Here is an example:'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: enum Season { SPRING, SUMMER, AUTUMN, WINTER }
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the listed items—`SPRING`, `SUMMER`, `AUTUMN`, and `WINTER`—is an instance
    of `Season`. They are the only four instances of the `Season` class that can exist
    in an application. No other instance of the `Season` class can be created. And
    that is the reason for the creation of the `enum` type: it can be used for cases
    when the list of instances of a class has to be limited to the fixed set, such
    as the list of possible seasons.'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: 'The `enum` declaration can also be written in a camel-case style:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: enum Season { Spring, Summer, Autumn, Winter }
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: But the all-uppercase style is used more often because, as we mentioned earlier,
    the static final constant's identifiers in Java programming are written this way
    by convention, in order to distinguish them from the non-constant variable. And
    `enum` constants are static and final implicitly.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review an example of the `Season` class usage. Here is a method that
    prints different messages, depending on the season:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: void enumDemo(Season season){
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: if(season == Season.WINTER){
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Dress up warmer");
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("You can drees up lighter now");
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens if we run the following two lines:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: enumDemo(Season.WINTER);
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: enumDemo(Season.SUMMER);
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: 'The result will be as follows:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f4d8e93-b7b4-44af-9713-a1a9f6cd14ca.png)'
  id: totrans-929
  prefs: []
  type: TYPE_IMG
- en: 'You probably have noticed that we used an `==` operator that compares references.
    That is because the `enum` instances (as all static variables) exist uniquely
    in memory. And the `equals()` method (implemented in the `java.lang.Enum` parent
    class) brings the same result. Let''s run the following code:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: Season season = Season.WINTER;
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Season.WINTER == season);
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Season.WINTER.equals(season));
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: 'The result will be:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e650d658-2e63-40ec-8205-ff45287ac8aa.png)'
  id: totrans-937
  prefs: []
  type: TYPE_IMG
- en: 'The reason for this is that the `equals()` method of the `java.lang.Enum` class
    is implemented as follows:'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: public final boolean equals(Object other) {
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: return this == other;
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it does exactly the same comparison of two objects references – `this`
    (the reserved keyword that refers the current object) and the reference to another
    object. If you wonder why the parameter has the `Object` type, we would like to
    remind you that all reference types, including `enum` and `String`, extend `java.lang.Object`.
    They do it implicitly.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: 'Other useful methods of `java.lang.Enum` are as follows:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: '`name()`: Returns the enum constant''s identifier as it is spelled when declared.'
  id: totrans-946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ordinal()`: Returns the integer that corresponds to the position of the enum
    constant when declared (the first in the list has an ordinal value of zero).'
  id: totrans-947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valueOf()`: Returns the `enum` constant object by its name.'
  id: totrans-948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toString()`: Returns the same value as the `name()` method by default, but
    can be overridden to return any other `String` value.'
  id: totrans-949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values()`: A static method you will not find in the documentation of the `java.lang.Enum` class. In
    the Java Specification, section 8.9.3 ([https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)),
    it is described as implicitly declared and the Java Tutorial ([https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html))
    states that the compiler *automatically adds some special methods when it creates
    an enum*.'
  id: totrans-950
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Among them, a static `values()` method that returns an array containing all
    of the values of the `enum` in the order they are declared.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of their usage. Here is the `enum` class we will
    use for the demo:'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: enum Season {
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: SPRING, SUMMER, AUTUMN, WINTER;
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: 'And the following is the code that uses it:'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Season.SPRING.name());
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Season.SUMMER.ordinal());
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Enum.valueOf(Season.class, "AUTUMN"));
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Season.WINTER.name());
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding snippet is as follows:'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/739ed513-aced-4e9c-b307-407928949fd4.png)'
  id: totrans-966
  prefs: []
  type: TYPE_IMG
- en: 'The first line is the output of the `name()` method. The second—is the return
    value of the `ordinal()` method: the `SUMMER` constant is the second in the list,
    so its ordinal value is 1\. The third line is the result of the `toString()` method
    applied to the `enum` constant of `AUTUMN` returned by the `valueOf()` method.
    And the last—is the result of the `toString()` method applied to the `WINTER` constant.'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: 'The `equals()`, `name()`, and `ordinal()` methods are declared `final` in `java.lang.Enum`,
    so they cannot be overridden and are used as-is.  The `valueOf()` method is static
    and not associated with any class instance, so it cannot be overridden. The only
    method we can override is the `toString()` method:'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: enum Season {
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: SPRING, SUMMER, AUTUMN, WINTER;
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: public String toString() {
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: return "The best season";
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the preceding code again, the result is as follows:'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19202174-e824-45da-ab53-4ed72a4ae21b.png)'
  id: totrans-978
  prefs: []
  type: TYPE_IMG
- en: 'Now, you can see that the `toString()` method returns the same result for each
    constant. If necessary, the `toString()` method can be overridden for each constant.
    Let''s look at this version of the `Season` class:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: enum Season2 {
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: SPRING,
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: SUMMER,
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: AUTUMN,
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: WINTER { public String toString() { return "Winter"; } };
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: public String toString() {
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: return "The best season";
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: 'We have overridden the `toString()` method for the `WINTER` constant only.
    If we run the same code snippet again, the result will be as follows:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc5ddc24-87cd-450a-ab70-0505e97b4b21.png)'
  id: totrans-992
  prefs: []
  type: TYPE_IMG
- en: As you can see, the old version of `toString()` is used for all constants, except
    `WINTER`.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to add any property (and getters and setters) to `enum`
    constants and associate each of them with corresponding values. Here is one example:'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: enum Season {
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: SPRING("Spring", "warmer than winter", 60),
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: SUMMER("Summer", "the hottest season", 100),
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: AUTUMN("Autumn", "colder than summer", 70),
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: WINTER("Winter", "the coldest season", 40);
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: private String feel, toString;
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: private int averageTemperature;
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: Season(String toString, String feel, int t) {
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: this.feel = feel;
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
- en: this.toString = toString;
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
- en: this.averageTemperature = t;
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
- en: public String getFeel(){ return this.feel; }
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
- en: public int getAverageTemperature(){
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: return this.averageTemperature;
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
- en: public String toString() { return this.toString; }
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we have added three properties to the `Season` class: `feel`,
    `toString`, and `averageTemperature`. We have also created a constructor (a special method
    used to assign the initial values of an object state) that takes these three properties
    and adds getters and `toString()` methods that return values of these properties.
    Then, in parentheses after each constant, we have set the values that are going
    to be passed to the constructor when this constant is created.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a demo method that we are going to use:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: void enumDemo(Season season){
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(season + " is " + season.getFeel());
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(season + " has average temperature around "
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: + season.getAverageTemperature());
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: 'The `enumDemo()` method takes the `enum Season` constant and constructs and
    displays two sentences. Let''s run the preceding code for each season, like this:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: enumDemo2(Season3.SPRING);
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: enumDemo2(Season3.SUMMER);
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: enumDemo2(Season3.AUTUMN);
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: enumDemo2(Season3.WINTER);
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: 'The result will be as follows:'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90d857fd-ef52-4317-97b9-d2435ab70fb9.png)'
  id: totrans-1032
  prefs: []
  type: TYPE_IMG
- en: 'The `enum` class is a very powerful tool that allows us to simplify the code
    and make it better protected from runtime errors because all possible values are
    predictable and can be tested in advance. For example, we can test the `SPRING`
    constant getters using the following unit test:'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: '@DisplayName("Enum Season tests")'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: public class EnumSeasonTest {
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: '@DisplayName("Test Spring getters")'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: void multiplyByTwo(){
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals("Spring", Season.SPRING.toString());
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals("warmer than winter", Season.SPRING.getFeel());
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals(60, Season.SPRING.getAverageTemperature());
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: Granted, the getters don't have much code to make a mistake. But if the `enum`
    class has more complex methods or the list of the fixed values comes from some
    application requirements document, such a test will make sure we have written
    the code as required.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: 'In the standard Java libraries, there are several `enum` classes. Here are
    a few examples of constants from those classes that can give you a hint about
    what is out there:'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: Month.FEBRUARY;
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: TimeUnit.DAYS;
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: TimeUnit.MINUTES;
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: DayOfWeek.FRIDAY;
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: Color.GREEN;
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: Color.green;
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: So, before creating your own `enum`, try to check and see whether the standard
    libraries already provide a class with the values you need.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: Passing reference type values as method parameters
  id: totrans-1057
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One important difference between the reference types and primitive types that
    merits special discussion is the way their values can be used in a method. Let''s
    see the difference by example. First, we create the `SomeClass` class:'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: class SomeClass{
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
- en: private int count;
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: public int getCount() {
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: return count;
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
- en: public void setCount(int count) {
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: this.count = count;
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we create a class that uses it:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: public class ReferenceTypeDemo {
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args) {
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: float f = 1.0f;
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass someClass = new SomeClass();
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("\nBefore demoMethod(): f = " + f +'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: '", count = " + someClass.getCount());'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: demoMethod(f, someClass);
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("After demoMethod(): f = " + f'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: + ", count = " + someClass.getCount());
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: private static void demoMethod(float f, SomeClass someClass){
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: //... some code can be here
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: f = 42.0f;
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: someClass.setCount(42);
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: someClass = new SomeClass();
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: someClass.setCount(1001);
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: Let's look inside `demoMethod()` first. We have made it very simple for demo
    purposes, but assume it does more, and then assigns a new value to the `f` variable
    (parameter) and sets a new count value on the object of the `SomeClass` class.
    Then this method attempts to replace the passed-in reference with a new value
    that points to a new `SomeClass` object with another count value.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main()` method, we declare and initialize the `f` and `someClass` variables with
    some values and print them out, then pass them as the parameters to the `demoMethod()` method and
    print the values of the same variables again. Let''s run the `main()` method and
    see the results that should look like the following:'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fe7f190-7bc0-4bc5-bf1b-90634245d199.png)'
  id: totrans-1093
  prefs: []
  type: TYPE_IMG
- en: 'To understand the difference, we need to take into account these two facts:'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: Values to a method are passed by copy
  id: totrans-1095
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value of a reference type is a reference to a memory where the referred object
    resides
  id: totrans-1096
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is why when the primitive value (or `String`, which is immutable as we
    have explained already) is passed in, the copy of the actual value is created,
    so the original value cannot be affected.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if the reference to an object is passed in, only its copy is accessible
    to the code in the method, so the original reference cannot be changed. That is
    why our attempt to change the original reference value and make it refer another
    object did not succeed, either.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: But the code inside the method is able to access the original object and change
    its count value using the copy of the reference value because the value still
    points to the same memory area where the original object resides. That is why
    code inside the method is able to execute any method of the original object, including
    those methods that change the object's state (values of the instance fields).
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: 'This change of an object state, when it was passed in as a parameter, is called
    a side-effect and is sometimes used, when  the following occurs:'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
- en: A method has to return several values but it is not possible to do it via returned
    construct
  id: totrans-1101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The programmer is not skilled enough
  id: totrans-1102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A third-party library or a framework utilizes the side-effect as the primary
    mechanism of getting back the result
  id: totrans-1103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But the best practices and design principles (the Single Responsibility Principle
    in this case, which we will discuss in [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml),
    *Object-Oriented Design (OOD) Principles*) guide programmers to avoiding side-effects,
    if possible, because side effects often lead to a not-very-readable (for a human) code
    and subtle runtime effects that are difficult to identify and fix.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
- en: One has to distinguish a side effect and a code design pattern called Delegation
    Pattern ([https://en.wikipedia.org/wiki/Delegation_pattern](https://en.wikipedia.org/wiki/Delegation_pattern)),
    when the methods invoked on the passed-in objects are stateless. We will talk
    about design patterns in [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml), *Object-Oriented
    Design (OOD) Principles*.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, a side effect is possible when an array is passed in as a parameter.
    Here is the code that demonstrates it:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
- en: public class ReferenceTypeDemo {
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args) {
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: int[] someArray = {1, 2, 3};
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("\nBefore demoMethod(): someArray[0] = "'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: + someArray[0]);
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: demoMethod(someArray);
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("After demoMethod(): someArray[0] = "'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
- en: + someArray[0]);
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: private static void demoMethod(int[] someArray){
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: someArray[0] = 42;
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
- en: someArray = new int[3];
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: someArray[0] = 43;
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the preceding code execution is as follows:'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4431c564-3f1d-4148-87b7-126c30401e9d.png)'
  id: totrans-1125
  prefs: []
  type: TYPE_IMG
- en: You can see that despite the fact that, inside the method, we were able to assign
    a new array to the passed-in variable, the assignment of value `43` affected only
    the newly created array, but had no effect on the original array. Yet, the change
    of an array component using the passed-in copy of the reference value is possible
    because the copy still points to the same original array.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
- en: 'And, to close the discussion about reference types as method parameters and
    possible side effects of that, we would like to demonstrate that the `String`
    type parameter—because of the `String` value immutability—behaves like a primitive
    type when passed in as a parameter. Here is the demo code:'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
- en: public class ReferenceTypeDemo {
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args) {
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: String someString = "Some string";
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("\nBefore demoMethod(): string = "'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: + someString);
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: demoMethod(someString);
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("After demoMethod(): string = "'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: + someString);
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: private static void demoMethod(String someString){
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: someString = "Some other string";
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code yields the following results:'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c29f1c82-c6e0-4f44-8f20-d3e72a10bcdb.png)'
  id: totrans-1144
  prefs: []
  type: TYPE_IMG
- en: The code inside the method was not able to change the original parameter value.
    The reason for that is not – as in the case of a primitive type – that the parameter
    value was copied before being passed into the method. The copy, in this case,
    still pointed to the same original `String` object. The actual reason is that
    changing a `String` value does not change the value, but creates another `String`
    object with the result of the change. That is the `String` value immutability
    mechanism as we have described it in the *String type and literals* section. The
    reference to this new (changed) `String` object assigned to the copy of the reference
    value passed in and has no effect on the original reference value that still points
    to the original String object.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: With that, we conclude the discussion about Java reference types and String.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – Variable declarations and initializations
  id: totrans-1147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Which of the following statements are correct:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: int x = 'x';
  id: totrans-1149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: int x1 = "x";
  id: totrans-1150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: char x2 = "x";
  id: totrans-1151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: char x4 = 1;
  id: totrans-1152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: String x3 = 1;
  id: totrans-1153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Month.MAY = 5;
  id: totrans-1154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Month month = Month.APRIL;
  id: totrans-1155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answer
  id: totrans-1156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1, 4, 7
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chapter provided the foundation for the discussion of more complex Java
    language constructs. Knowledge of Java elements, such as identifiers, variables,
    literals, keywords, separators, comments and types—primitive and reference—is
    indispensable for Java programming. You also had a chance to learn about several
    areas that can be sources of confusion if not understood properly, such as the
    String type immutability and possible side effects when a reference type is used
    as a method parameter. Arrays and `enum` types were also explained in detail,
    enabling the reader to use these powerful constructs and increase the quality
    of their code.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, the reader will be introduced the most common terms and
    coding solutions of Java programming—**Application Programming Interface** (**API**),
    object factories, method overriding, hiding, and overloading. Then the discussion
    about the design of a software system and the advantage of aggregation (vs inheritance)
    will bring the reader into the realm of best design practices. The overview of
    Java data structures will conclude the chapter, providing the reader with practical
    programming advice and recommendations.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
