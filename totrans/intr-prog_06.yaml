- en: Java Language Elements and Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter starts a systematic introduction to Java with a definition of language
    elements—identifiers, variables, literals, keywords, separators, and comments.
    It also describes Java types—primitive types and reference types. Special attention
    is applied to the `String` class, `enum` types, and arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the Java language elements?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifiers and variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reserved and restricted keywords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primitive types and literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference types and String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enum types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise – Variable declarations and initializations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the Java language elements?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with any programming language, Java has a grammar that is applied to the
    language elements. The elements are building blocks used to compose language structures
    that allow the programmer to express intent. Elements themselves have different
    levels of complexity. Lower-level (simpler) elements enable building higher-level
    (more complex) ones. For a more detailed and systematic treatment of Java grammar
    and language elements, please see the Java Specification ([https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)).
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we start with input elements that belong to one of the lowest
    levels. They are called **input elements** because they serve as input to the
    Java compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Input elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java input elements, according to the Java Specification, can be one of the
    following three:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Whitespace**: This can be one of these ASCII characters--SP (space), HT (horizontal
    tab), or FF (form feed, also called page break)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Comment**: A free-formed text that is not processed by the compiler but transferred
    into the bytecode as-is, so programmers use a comment to add a human-readable
    explanation to the code as they write it. A comment can include a whitespace,
    but it is not recognized as an input element; it is processed as a part of the
    comment only. We will describe the grammar rules for a comment and show some examples in
    the *Comments* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Token**: This can be one of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identifier**: Will be described in the *Identifiers and variables* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keyword**: Will be described in the *Reserved and restricted keywords* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separator**: Will be described in the *Separators* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Literal**: Will be described in the *Primitive types and literals* section.
    Some literals can include a whitespace, but it is not recognized as an input element;
    the whitespace is processed as a part of the literal only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operator**: Will be described in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml),
    *Operators, Expressions, and Statements**. *'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input elements are used to compose more complex elements, including types. Some
    of the keywords are used to denote types, and we will also discuss them in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java is a strongly typed language, which means that any variable declaration
    must include its type. Type limits the value a variable can hold and how this
    value can be passed around.
  prefs: []
  type: TYPE_NORMAL
- en: 'All types in Java are divided into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Primitive types**: Described in the *Primitive types and literals* section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reference types**: Described in the *Reference types and String* section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the reference types require more attention, either because of their
    complexity or other particulars that have to be explained to avoid future confusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrays**: Described in the *Arrays* section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**String** (the uppercase first character indicates it is the name of a class):
    Described in the *Reference types and String* section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enum types**: Described in the *Enum types* section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Java Specification provides the following information about comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '"There are two kinds of comments:'
  prefs: []
  type: TYPE_NORMAL
- en: /* text */
  prefs: []
  type: TYPE_NORMAL
- en: 'A traditional comment: all the text from the ASCII characters /* to the ASCII
    characters */ is ignored (as in C and C++).'
  prefs: []
  type: TYPE_NORMAL
- en: // text
  prefs: []
  type: TYPE_NORMAL
- en: 'An end-of-line comment: all the text from the ASCII characters // to the end
    of the line is ignored (as in C++)."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of comments in the `SimpleMath` class that we have written
    already:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class SimpleMath {
  prefs: []
  type: TYPE_NORMAL
- en: /*
  prefs: []
  type: TYPE_NORMAL
- en: This method just multiplies any integer by 2
  prefs: []
  type: TYPE_NORMAL
- en: and returns the result
  prefs: []
  type: TYPE_NORMAL
- en: '*/'
  prefs: []
  type: TYPE_NORMAL
- en: public int multiplyByTwo(int i){
  prefs: []
  type: TYPE_NORMAL
- en: //Should we check if i is bigger than 1/2 of Integer.MAX_VALUE ?
  prefs: []
  type: TYPE_NORMAL
- en: return i * 2; // The magic happens here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The comments do not affect the code in any way. They are just programmer's notes.
    Also, don't confuse them with JavaDoc or another documentation generating system.
  prefs: []
  type: TYPE_NORMAL
- en: Identifiers and variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Identifiers and variables are among the most often used elements of Java. They
    are closely coupled because every variable has a name and the name of a variable
    is an identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Identifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An identifier is the first in the list of Java tokens. It is a sequence of
    symbols, each may be a letter, a dollar sign `$`, an underscore, `_`, or any digit
    0-9. The restrictions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first symbol of an identifier cannot be a digit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single-symbol identifier cannot be an underscore `_`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An identifier cannot have the same spelling as a keyword (see the *Reserved
    and restricted keywords* section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An identifier cannot be a Boolean literal `true` or `false`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An identifier cannot be spelled as a special type `null`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any of the above restrictions is violated, a compiler generates an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, the letters used for an identifier are usually taken from the
    English alphabet – lowercase or uppercase. But it is possible to use other alphabets,
    too. You can find the formal definition of the letters that can be included in
    the identifier in section 3.8 of the Java Specification ([https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)).
    Here is the list of the examples from that section:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`αρετη`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MAX_VALUE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isLetterOrDigit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To show the variety of possibilities, we can add two more examples of legal
    identifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A variable is a storage location, as the Java Specification puts it in the *Variables *section.
    It has a name (an identifier) and an assigned type. A variable refers to the memory
    where a value is stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java Specification has provision for eight kinds of variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class variable**: A static class member that can be used without creating
    an object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instance variable**: A non-static class member that can be used only via
    an object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Array component**: An array element (see the *Arrays* section)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method parameter**: An argument passed to a method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constructor parameter**: An argument passed to a constructor when an object
    is created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lambda parameter**: An argument passed to a lambda expression. We will talk
    about it in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambda
    Expressions and Functional Programming*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exception parameter**: It is created when an exception is caught, we will
    talk about it in [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control
    Flow Statements*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Local variable**: A variable declared inside a method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From a practical point of view, all eight kinds of variables can be summarized
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A class member, static or not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array member (also called a component or an element)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A parameter of a method, constructor, or lambda expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An exception parameter of a catch-block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A regular local code variable, the most common kind
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the time, when programmers talk about a variable, they mean the last
    kind. It can refer to a class member, class instance, parameter, exception object,
    or any other value necessary for the code you are writing.
  prefs: []
  type: TYPE_NORMAL
- en: Variable declaration, definition, and initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the examples first. Let''s assume we have these three lines
    of code consecutively:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int x;  //declartion of variable x
  prefs: []
  type: TYPE_NORMAL
- en: x = 1;  //initialization of variable x
  prefs: []
  type: TYPE_NORMAL
- en: x = 2;  //assignment of variable x
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can guess from the preceding example, variable initialization is assigning
    the first (initial) value to a variable. All subsequent assignments cannot be
    called an initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'A local variable cannot be used until initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int x;
  prefs: []
  type: TYPE_NORMAL
- en: int result = x * 2;  //generates compilation error
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The second line of the preceding code will generate a compilation error. If
    a variable is a member of a class (static or not) or a component of an array and
    not initialized explicitly, it is assigned a default value that depends on the
    variable's type (see the *Primitive types and literals* and *Reference types and
    String* sections).
  prefs: []
  type: TYPE_NORMAL
- en: A declaration creates a new variable. It includes the variable type and name
    (identifier). The word **declaration** is a technical term used in the Java Specification,
    section 6.1 ([https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)).
    But some programmers use word definition as the synonym for declaration because
    the word definition is used in some other programming languages (C and C++, for
    example) for a type of statement that does not exist in Java. So, be aware of
    it and assume they mean declaration when you here *definition* applied to Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time, when writing Java code, programmers combine declaration and
    initialization statements in one.  For example, a variable of the `int` type can
    be declared and initialized to hold integer `1`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int $ = 1;
  prefs: []
  type: TYPE_NORMAL
- en: int _1 = 1;
  prefs: []
  type: TYPE_NORMAL
- en: int i3 = 1;
  prefs: []
  type: TYPE_NORMAL
- en: int αρετη = 1;
  prefs: []
  type: TYPE_NORMAL
- en: int String = 1;
  prefs: []
  type: TYPE_NORMAL
- en: int MAX_VALUE = 1;
  prefs: []
  type: TYPE_NORMAL
- en: int isLetterOrDigit = 1;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same identifiers can be used to declare and initialize a variable of the
    `String` type to hold `abs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String $ = "abc";
  prefs: []
  type: TYPE_NORMAL
- en: String _1 = "abc";
  prefs: []
  type: TYPE_NORMAL
- en: String i3 = "abc";
  prefs: []
  type: TYPE_NORMAL
- en: String αρετη = "abc";
  prefs: []
  type: TYPE_NORMAL
- en: String String = "abc";
  prefs: []
  type: TYPE_NORMAL
- en: String MAX_VALUE = "abc";
  prefs: []
  type: TYPE_NORMAL
- en: String isLetterOrDigit = "abc";
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, in the preceding examples, we used the identifiers
    from the examples of the *Identifier* section.
  prefs: []
  type: TYPE_NORMAL
- en: Final variable (constant)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A final variable is a variable that, once initialized, cannot be assigned to
    another value. It is denoted by the `final` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void someMethod(){
  prefs: []
  type: TYPE_NORMAL
- en: final int x = 1;
  prefs: []
  type: TYPE_NORMAL
- en: x = 2; //generates compilation error
  prefs: []
  type: TYPE_NORMAL
- en: //some other code
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, the following code will work just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void someMethod(){
  prefs: []
  type: TYPE_NORMAL
- en: final int x;
  prefs: []
  type: TYPE_NORMAL
- en: //Any code that does not use variable x can be added here
  prefs: []
  type: TYPE_NORMAL
- en: x = 2;
  prefs: []
  type: TYPE_NORMAL
- en: //some other code
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code does not generate a compilation error because the local variable
    is not initialized to a default value automatically in a declaration statement.
    Only the class, instance variable, or array component is initialized to a default
    value if the variable is not initialized explicitly (see the *Primitive types
    and literals* and *Reference types and String* sections).
  prefs: []
  type: TYPE_NORMAL
- en: When a final variable refers to an object, it cannot be assigned to another
    object, but the state of the object assigned can be changed at any time (see the *Reference
    types and String* section). The same applies to a variable that refers an array,
    because an array is an object (see the* Arrays* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since a final variable cannot be changed, it is a constant. It is called a
    constant variable if it has a primitive type or a type of `String`. But Java programmers
    apply the term constant usually to the class-level final static variables, and
    call the local final variable just final variable. The identifier of class-level
    constants by convention is written in capital letters. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: static final String FEBRUARY = "February";
  prefs: []
  type: TYPE_NORMAL
- en: static final int DAYS_IN_DECEMBER = 31;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Such constants look very similar to the following constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Month.FEBRUARY;
  prefs: []
  type: TYPE_NORMAL
- en: TimeUnit.DAYS;
  prefs: []
  type: TYPE_NORMAL
- en: DayOfWeek.FRIDAY;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: But the preceding constants are defined in a special kind of class, called `enum`,
    although for all practical purposes, all constants behave similarly in the sense
    that they cannot be changed. One just has to check the type of a constant in order
    to know what methods its class (type) provides.
  prefs: []
  type: TYPE_NORMAL
- en: Reserved and restricted keywords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A keyword is the second of Java tokens listed in the *Input types* section. We
    have seen several Java keywords already—`abstract`, `class`, `final`, `implements`, `int`, `interface`, `new`,
    `package`, `private`, `public`, `return`, `static`, and `void`. Now we will present
    the full list of the reserved keywords. These keywords cannot be used as identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Reserved keywords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the list of all 49 keywords of Java 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '| abstract | class | final | implements | int |'
  prefs: []
  type: TYPE_TB
- en: '| interface | new | package | private | public |'
  prefs: []
  type: TYPE_TB
- en: '| return | static | void | if | this |'
  prefs: []
  type: TYPE_TB
- en: '| break | double | default | protected | throw |'
  prefs: []
  type: TYPE_TB
- en: '| byte | else  | import | synchronized | throws |'
  prefs: []
  type: TYPE_TB
- en: '| case | enum | instanceof | boolean | transient |'
  prefs: []
  type: TYPE_TB
- en: '| catch | extends | switch | short | try |'
  prefs: []
  type: TYPE_TB
- en: '| char | for | assert | do | finally |'
  prefs: []
  type: TYPE_TB
- en: '| continue | float | long | strictfp | volatile |'
  prefs: []
  type: TYPE_TB
- en: '| native | super | while | _ (underscore) |  |'
  prefs: []
  type: TYPE_TB
- en: 'The keywords are used for different Java elements and statements, and cannot
    be used as identifiers. The `goto`, `const`, and `_` (underscore) keywords are
    not used as keywords yet, but they might in the future Java releases. For now,
    they are just included in the list of the reserved keywords to prevent their use
    as an identifier. But they can be a part of an identifier among other characters,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int _ = 3; //Error, underscore is a reserved keyword
  prefs: []
  type: TYPE_NORMAL
- en: int __ = 3; //More than 1 underscore as an identifier is OK
  prefs: []
  type: TYPE_NORMAL
- en: int _1 = 3;
  prefs: []
  type: TYPE_NORMAL
- en: int y_ = 3;
  prefs: []
  type: TYPE_NORMAL
- en: int goto_x = 3;
  prefs: []
  type: TYPE_NORMAL
- en: int const1 = 3;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The `true` and `false` words look like keywords and cannot be used as identifiers,
    but in fact they are not Java keywords. They are Boolean literals (values). We
    will define what a literal is in the *Primitive types and literals* section.
  prefs: []
  type: TYPE_NORMAL
- en: And there is another word that looks like a keyword but is in fact a special
    type—`null` (see the *Reference types and String* section). It also cannot be
    used as an identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Restricted keywords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are ten words that are called restricted keywords: `open`, `module`,
    `requires`, `transitive`, `exports`, `opens`, `to`, `uses`, `provides`, and `with`.
    They are called restricted because they cannot be identifiers in the context of
    a module declaration, which we will not discuss in this book. In all other places,
    it is possible to use them as identifiers. Here is one example of such usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int to = 1;
  prefs: []
  type: TYPE_NORMAL
- en: int open = 1;
  prefs: []
  type: TYPE_NORMAL
- en: int uses = 1;
  prefs: []
  type: TYPE_NORMAL
- en: int with = 1;
  prefs: []
  type: TYPE_NORMAL
- en: int opens =1;
  prefs: []
  type: TYPE_NORMAL
- en: int module = 1;
  prefs: []
  type: TYPE_NORMAL
- en: int exports =1;
  prefs: []
  type: TYPE_NORMAL
- en: int provides = 1;
  prefs: []
  type: TYPE_NORMAL
- en: int requires = 1;
  prefs: []
  type: TYPE_NORMAL
- en: int transitive = 1;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: However, it is a good practice not to use them as identifiers anywhere. There
    are plenty of other ways to name a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Separators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A separator is the third of the Java tokens listed in the *Input types* section.
    Here are all twelve of them, in no particular order:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: ';  { }  ( )  [ ]  ,  .  ...  ::  @'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Semicolon ";"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By now, you are quite familiar with the usage of the separator `;` (semicolon).
    Its only job in Java is to terminate a statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int i;  //declaration statement
  prefs: []
  type: TYPE_NORMAL
- en: i = 2;  //assignment statement
  prefs: []
  type: TYPE_NORMAL
- en: if(i == 3){    //flow control statement called if-statement
  prefs: []
  type: TYPE_NORMAL
- en: //do something
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: for(int i = 0; i < 10; i++){
  prefs: []
  type: TYPE_NORMAL
- en: //do something with each value of i
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Braces "{}"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have seen the separators `{}` (braces) around the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class SomeClass {
  prefs: []
  type: TYPE_NORMAL
- en: //class body with code
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'You have also seen braces around method bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void someMethod(int i){
  prefs: []
  type: TYPE_NORMAL
- en: //...
  prefs: []
  type: TYPE_NORMAL
- en: if(i == 2){
  prefs: []
  type: TYPE_NORMAL
- en: //block of code
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: //another block of code
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The braces are also used to denote a block of code in control-flow statements
    (see [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control Flow Statements*):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void someMethod(int i){
  prefs: []
  type: TYPE_NORMAL
- en: //...
  prefs: []
  type: TYPE_NORMAL
- en: if(i == 2){
  prefs: []
  type: TYPE_NORMAL
- en: //block of code
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: //another block of code
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And they are used to initialize arrays (see the *Arrays* section):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int[] myArray = {2,3,5};
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: There are also a few other rarely used constructs where braces are used.
  prefs: []
  type: TYPE_NORMAL
- en: Parentheses "()"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have also seen the usage of separators `()` (parentheses) to keep the list
    of method parameters in the method definition and method invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void someMethod(int i) {
  prefs: []
  type: TYPE_NORMAL
- en: //...
  prefs: []
  type: TYPE_NORMAL
- en: String s = anotherMethod();
  prefs: []
  type: TYPE_NORMAL
- en: //...
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'They are also used in control-flow statements (see [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml),
    *Control Flow Statements*):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: if(i == 2){
  prefs: []
  type: TYPE_NORMAL
- en: //...
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'During typecasting (see the *Primitive types and literals* section), they are
    put around the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: long v = 23;
  prefs: []
  type: TYPE_NORMAL
- en: int i = (int)v;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As for setting the precedence of an execution (see [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml),
    *Operators, Expressions, and Statements*), you should be familiar with it from
    basic algebra:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: x = (y + z) * (a + b).
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Brackets "[]"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The separators `[]` (brackets) are used for arrays declaration (see the *Arrays* section):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int[] a = new int[23];
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Comma ","
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The comma `,` is used for the separation of method parameters, listed in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void someMethod(int i, String s, int j) {
  prefs: []
  type: TYPE_NORMAL
- en: //...
  prefs: []
  type: TYPE_NORMAL
- en: String s = anotherMethod(5, 6.1, "another param");
  prefs: []
  type: TYPE_NORMAL
- en: //...
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'A comma can also be used to separate variables of the same type in the declaration
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int i, j = 2; k;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, all three variables, `i`, `j`, and `k`, are declared
    to be of the `int` type, but only variable `j` is initialized to `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of a comma in a looping statement serves the same purpose of the declaration
    of multiple variables (see [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control
    Flow Statements*):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0; i < 10; i++){
  prefs: []
  type: TYPE_NORMAL
- en: //...
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Period "."
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The separator `.` (period) is used to separate parts of the package name, as
    you have seen in the `com.packt.javapath` example.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also have seen how the period was used to separate an object reference
    and the method of that object:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int result = simpleMath.multiplyByTwo(i);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if a `simpleMath` object had a public property of `a`, it could be
    referred to as `simpleMath.a`.
  prefs: []
  type: TYPE_NORMAL
- en: Ellipsis "..."
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The separator `...` (ellipsis) is used only for varargs:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int someMethod(int i, String s, int... k){
  prefs: []
  type: TYPE_NORMAL
- en: //k is an array with elements k[0], k[1], ...
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding method can be called in any of the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: someMethod(42, "abc");          //array k = null
  prefs: []
  type: TYPE_NORMAL
- en: someMethod(42, "abc", 42, 43);  //k[0] = 42, k[1] = 43
  prefs: []
  type: TYPE_NORMAL
- en: int[] k = new int[2];
  prefs: []
  type: TYPE_NORMAL
- en: k[0] = 42;
  prefs: []
  type: TYPE_NORMAL
- en: k[1] = 43;
  prefs: []
  type: TYPE_NORMAL
- en: someMethod(42, "abc", k);       //k[0] = 42, k[1] = 43
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java Language Basics*,
    while talking about the `main()` method, we explained the concept of `varargs`
    (variable arguments) in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Colons "::"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The separator `::` (colons) is used for method reference in lambda expressions
    (see [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambd*a E*xpressions
    and Functional Programming*):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = List.of("1", "32", "765");
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().mapToInt(Integer::valueOf).sum();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: At sign "@"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The separator `@` (at sign) is used to denote an annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: int someMethod(String s){
  prefs: []
  type: TYPE_NORMAL
- en: //...
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: You have seen several examples of an annotation when we created a unit test
    in [Chapter 4](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml), *Your First Java Project*.
    There are several predefined annotations in the Java standard libraries (`@Deprecated`,
    `@Override`, and `@FunctionalInterface`, to name a few). We are going to use one
    of them (`@FunctionalInterface`) in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambd*a
    E*xpressions and Functional Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: The annotations are metadata. They describe classes, fields, and methods, but
    they themselves are not executed. The Java compiler and JVM read them and treat
    the described class, field, or method in a certain way depending on the annotation.
    For example, in [Chapter 4](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml), *Your
    First Java Project*, you saw how we used the `@Test` annotation. Adding it in
    front of a public non-static method tells JVM that it is a test method that has
    to be run. So, if you execute this class, the JVM will run only this method.
  prefs: []
  type: TYPE_NORMAL
- en: Or, if you use the `@Override` annotation in front of a method, the compiler
    will check to see whether this method actually overrides a method in a parent
    class or not. If the matching signature of a non-private non-static class is not
    found in any of the class parents, the compiler will raise an error.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to create new custom annotations (JUnit framework does exactly
    that), but this topic is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive types and literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java has only two kinds of variable types: primitive types and reference types.
    A primitive type defines what kind of value the variable can hold and how big
    or small this value can be. We will discuss primitive types in this section.'
  prefs: []
  type: TYPE_NORMAL
- en: A reference type allows us to assign only one kind of value to the variable –
    the reference to the memory area where an object is stored. We will discuss the
    reference types in the next section, *Reference types and String*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Primitive types can be divided into two groups: the Boolean type and the numeric
    types. The numeric-types group can be split further into integral types (`byte`,
    `short`, `int`, `long`, and `char`) and floating-point types (float and double).'
  prefs: []
  type: TYPE_NORMAL
- en: Each primitive type is defined by a corresponding reserved keyword, listed in the *Reserved
    and restricted keywords* section.
  prefs: []
  type: TYPE_NORMAL
- en: The Boolean type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Boolean type allows a variable to have one of two values: `true` or `false`.
    As we mentioned in the *Reserved keywords* section, these values are Boolean literals,
    which means they are values that represent themselves directly – without a variable.
    We will talk more about literals in the *Primitive type literals* section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a `b` variable declaration and initialization to the
    value `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: boolean b = true;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And here is another example of assigning a `true` value to the `b` Boolean
    variable using an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int x = 1, y = 1;
  prefs: []
  type: TYPE_NORMAL
- en: boolean b = 2 == ( x + y );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, in the first line, two variables, `x` and `y`, of
    the `int` primitive type are declared and each assigned a value of `1`. In the
    second line, a Boolean variable is declared and assigned the result of the `2
    == ( x + y )` expression. Parentheses set the precedence of execution as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the sum of values assigned to the `x` and `y` variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compare the result with `2`, using the `==` Boolean operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will study operators and expressions in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml),
    *Operators, Expressions, and Statements*.
  prefs: []
  type: TYPE_NORMAL
- en: Variables of the Boolean are used in control-flow statements and we will see
    many examples of their usage in [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml),
    *Control Flow Statements*.
  prefs: []
  type: TYPE_NORMAL
- en: Integral types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Values of Java integral types occupy different amounts of memory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'byte: 8 bit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'char: 16 bit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'short: 16 bit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'int: 32 bit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'long: 64 bit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of them, except `char`, are signed integer. The sign value (`0` for minus
    "`-`" and `1` for plus "`+`") occupies the first bit of the binary representation
    of the value. That is why a signed integer can hold, as a positive number, only
    half of the value an unsigned integer can. But it allows a signed integer to hold
    a negative number, which an unsigned integer cannot do. For example, in case of
    the `byte` type (8 bit), if it were an unsigned integer, the range of the values
    it could hold would be from 0 to 255 (including 0 and 255) because 2 to the power
    of 8 is 256\. But, as we have said, the `byte` type is a signed integer, which
    means the range of values it can hold is from -128 to 127 (including -128, 127,
    and 0).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the `char` type, it can hold values from 0 to 65,535 inclusive because
    it is an unsigned integer. This integer (called a code point) identifies a record
    in the Unicode table ([https://en.wikipedia.org/wiki/List_of_Unicode_characters](https://en.wikipedia.org/wiki/List_of_Unicode_characters)).
    Each Unicode table record has the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code point**: A decimal value – a numeric representation of the Unicode record'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unicode escape**: A four-digit number with the `\u` prefix'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Printable symbol**: A graphic representation of the Unicode record (not available
    for control codes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description:** A human-readable description of the symbol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are five records from the Unicode table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Code point** | **Unicode escape** | **Printable symbol** | **Description**
    |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | \u0008 |  | Backspace |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | \u000A |  | Line feed |'
  prefs: []
  type: TYPE_TB
- en: '| 36 | \u0024 | `$` | Dollar sign |'
  prefs: []
  type: TYPE_TB
- en: '| 51 | \u0033 | `3` | Digit three |'
  prefs: []
  type: TYPE_TB
- en: '| 97 | \u0061 | `a` | Latin small letter A |'
  prefs: []
  type: TYPE_TB
- en: The first two are examples of a Unicode that represents control codes that are
    not printable. A control code is used to send a command to a device (a display
    or a printer, for example). There are only 66 such codes in the Unicode set. They
    have code points from 0 to 32 inclusive and from 127 to 159 inclusive. The rest
    of 65,535 Unicode records have a printable symbol – a character that the record
    represents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting (and often confusing) aspect of the `char` type is that a Unicode
    escape and a code point can be used interchangeably, except when the variable
    of the `char` type is involved in an arithmetic operation. In such a case, the
    value of code point is used. To demonstrate it, let''s look at the following code
    snippet (in the comments, we have captured the output):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: char a = '3';
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(a);         //  3
  prefs: []
  type: TYPE_NORMAL
- en: char b = '$';
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(b);         //  $
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(a + b);     //  87
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(a + 2);     //  53
  prefs: []
  type: TYPE_NORMAL
- en: a = 36;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(a);         //  $
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, variables `a` and `b` of the `char` type represent the `3` and
    `$` symbols and are displayed as these symbols as long as they are not involved
    in an arithmetic operation. Otherwise, only the code point values are used.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the five Unicode records, the `3` character has a code point
    value of 51, while the `$` character has a code point value of 36\. That is why
    adding `a` and `b` produces 87, and adding `2` to `a` results in 53.
  prefs: []
  type: TYPE_NORMAL
- en: In the last line of the example code, we have assigned a decimal value of 36
    to the `a` variable of the `char` type. It means we have instructed JVM to assign the
    character with a code point of 36, which is the `$` character, to the `a` variable.
  prefs: []
  type: TYPE_NORMAL
- en: And that is why the `char` type is included in the group of integral types of
    Java – because it acts as a numeric type in arithmetic operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The range of values each of the primitive types can hold is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`byte`: From -128 to 127, inclusive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short`: From -32,768 to 32,767, inclusive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`: From -2.147.483.648 to 2.147.483.647, inclusive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long`: From -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807, inclusive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char`: From ''\u0000'' to ''\uffff'' inclusive, that is, from 0 to 65,535,
    inclusive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can access the maximum and minimum values of each type any time, using
    a corresponding wrapper class of each primitive type (we will talk about wrapper
    classes in more detail in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml),
    *Operators, Expressions, and Statements*). Here is one way to do it (in the comments,
    we have shown the output):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: byte b = Byte.MIN_VALUE;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(b);     //  -127
  prefs: []
  type: TYPE_NORMAL
- en: b = Byte.MAX_VALUE;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(b);     //   128
  prefs: []
  type: TYPE_NORMAL
- en: short s = Short.MIN_VALUE;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s);      // -32768
  prefs: []
  type: TYPE_NORMAL
- en: s = Short.MAX_VALUE;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s);      //  32767
  prefs: []
  type: TYPE_NORMAL
- en: int i = Integer.MIN_VALUE;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(i);      // -2147483648
  prefs: []
  type: TYPE_NORMAL
- en: i = Integer.MAX_VALUE;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(i);      //  2147483647
  prefs: []
  type: TYPE_NORMAL
- en: long l = Long.MIN_VALUE;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(l);      // -9223372036854775808
  prefs: []
  type: TYPE_NORMAL
- en: l = Long.MAX_VALUE;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(l);      //  9223372036854775807
  prefs: []
  type: TYPE_NORMAL
- en: char c = Character.MIN_VALUE;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println((int)c); // 0
  prefs: []
  type: TYPE_NORMAL
- en: c = Character.MAX_VALUE;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println((int)c); // 65535
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed the `(int)c` construct. It is called **casting**, similar
    to what happens during a movie production when an actor is tried for a particular
    role. The value of any primitive numeric types can be converted into the value
    of another primitive numeric type, provided it is not bigger than the maximum
    value of the target type. Otherwise, an error will be generated during program
    execution (such an error is called a runtime error). We will talk more about conversion
    between primitive numeric types in Chapter 9, *Operators, Expressions, and Statements*.
  prefs: []
  type: TYPE_NORMAL
- en: A casting between numeric types and the `boolean` type is not possible. A compile-time
    error will be generated if you try to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Floating-point types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Java Specification, the floating-point types (`float` and `double`)
    are defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The single-precision 32-bit and double-precision 64-bit format IEEE 754 values."'
  prefs: []
  type: TYPE_NORMAL
- en: 'It means that the `float` type occupies 32 bits and the `double` type takes
    64 bits. They represent positive and negative numerical values with a fractional
    part after the dot "`.`": `1.2`, `345.56`, `10.`, `-1.34`.  By default, in Java,
    a numeric value with a dot in it is assumed to be of the `double` type. So, the
    following assignment causes a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: float r = 23.4;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid the error, one has to indicate that the value has to be treated as
    a `float` type by appending the `f` or `F` character at the value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: float r = 23.4f;
  prefs: []
  type: TYPE_NORMAL
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: float r = 23.4F;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The values themselves (`23.4f` and `23.4F`) are called literals. We will talk
    more about them in the *Primitive type literals* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The minimum and maximum value can be found the same way as we did for integral
    numbers. Just run the following snippet of code (in the comments, we have captured
    the output we got on our computer):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Float.MIN_VALUE);  //1.4E-45
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Float.MAX_VALUE);  //3.4028235E38
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Double.MIN_VALUE); //4.9E-324
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Double.MAX_VALUE); //1.7976931348623157E308
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The range of negative values is the same as the range of the positive numbers,
    only with the minus sign `-` in front of each number. Zero can be either `0.0`
    or `-0.0`.
  prefs: []
  type: TYPE_NORMAL
- en: Default values of primitive types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After a variable is declared and before it can be used, a value has to be assigned
    to it. As we have mentioned in the *Variable declaration, definition, and initialization*
    section, a local variable must be initialized or assigned a value explicitly.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int x;
  prefs: []
  type: TYPE_NORMAL
- en: int y = 0;
  prefs: []
  type: TYPE_NORMAL
- en: x = 1;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'But if the variable is declared as a class field (static), an instance (non-static) property,
    or an array component and is not initialized explicitly, it is initialized automatically with
    a default value. The value itself depends on the type of the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: For the `byte`,  `short`, `int`, and `long` types, the default value is zero, `0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the `float` and `double` types, the default value is positive zero, `0.0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the `char` type, the default value is `\u0000` with point code zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the `boolean` type, the default value is `false`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primitive type literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A literal is the fourth of the Java tokens listed in the *Input types* section.
    It is the representation of a value. We will discuss literals of reference types in
    the *Reference types and String* section. And now we will talk about primitive
    type literals, only.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate literals of primitive types, we will use a `LiteralsDemo` program
    in the  `com.packt.javapath.ch05demo` package. You can create it by right-clicking
    on the `com.packt.javapath.ch05demo` package, then selecting New | Class, and
    typing the `LiteralsDemo` class name, as we have described in [Chapter 4](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml),
    *Your First Java Project*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among primitive types, literals of the `boolean` type are the simplest. They
    are just two: `true` and `false`. We can demonstrate it by running the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class LiteralsDemo {
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args){
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("boolean literal true: " + true);'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("boolean literal false: " + false);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27cb9a73-2087-462e-865c-b651793f84e2.png)'
  prefs: []
  type: TYPE_IMG
- en: These are all possible Boolean literals (values).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s turn to a more complex topic of the literals of the `char` type.
    They can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A single character, enclosed in single quotes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An escape sequence, enclosed in single quotes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single-quote, or apostrophe, is a character with Unicode escape `\u0027` (decimal
    code point 39). We have seen several examples of `char` type literals in the *Integral
    types* section when we demonstrated the `char` type behavior as a numeric type
    in arithmetic operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some other examples of the `char` type literals as single characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("char literal ''a'': " + ''a'');'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("char literal ''%'': " + ''%'');'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("char literal ''\u03a9'': " + ''\u03a9''); //Omega'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("char literal ''™'': " + ''™''); //Trade mark sign'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the preceding code, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58d9eba1-c21a-4754-84ef-2ee7419aee0e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s talk about the second kind of `char` type literal – an escape sequence.
    It is a combination of characters that acts similarly to control codes. In fact,
    some of the escape sequences include control codes. Here is the full list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\ b` (Backspace BS, Unicode escape `\u0008`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\ t` (Horizontal tab HT, Unicode escape `\u0009`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\ n` (Line feed LF, Unicode escape `\u000a`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\ f` (Form feed FF, Unicode escape  `\u000c`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\ r` (Carriage return CR, Unicode escape  `\u000d`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\ "` (Double quote ", Unicode escape  `\u0022`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\ ''` (Single quote '', Unicode escape  `\u0027`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\ \` (Backslash \, Unicode escape  `\u005c`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, an escape sequence always starts with a backslash (`\`). Let''s
    demonstrate some of the escape sequences usages:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("The line breaks \nhere");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("The tab is\there");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("\"");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println('\'');
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println('\\');
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the preceding code, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a24ce129-5240-40d3-a07c-bbd43fad874b.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the `\n` and `\t` escape sequences act only as control codes.
    They are not printable themselves but affect the display of the text. Other escape
    sequences allow the printing of a symbol in the context that would not allow it
    to be printed otherwise. Three double or single quotes in a row would be qualified
    as a compiler error, as well as a single backslash character if being used without
    a backslash.
  prefs: []
  type: TYPE_NORMAL
- en: 'By comparison with the `char` type literals, the float-points literals are
    much more straightforward. As we have mentioned before, by default, a `23.45` literal
    has the `double` type and there is no need to append the letter `d` or `D` to
    the literal if you would like it to be of the `double` type. But you can, if you
    prefer to be more explicit.  A `float` type literal, on the other hand, requires
    appending the letter `f` or `F` at the end. Let''s run the following example (notice
    how we use `\n` escape sequence to add a line break before the output):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("\nfloat literal 123.456f: " + 123.456f);'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("double literal 123.456d: " + 123.456d);'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f38e82d3-eb09-42d4-946d-6d2e8179e3e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The floating-point type literals can also be expressed using `e` or `E` for
    scientific notation (see [https://en.wikipedia.org/wiki/Scientific_notation](https://en.wikipedia.org/wiki/Scientific_notation)):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("\nfloat literal 1.234560e+02f: " + 1.234560e+02f);'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("double literal 1.234560e+02d: " + 1.234560e+02d);'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the preceding code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9719f0ac-ec78-41a5-885b-bfcdcd35cb4b.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the value remain the same, whether presented in a decimal format
    or a scientific one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The literals of the `byte`,  `short`, `int`, and `long` integral types have
    the `int` type by default. The following assignments do not cause any compilation
    errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: byte b = 10;
  prefs: []
  type: TYPE_NORMAL
- en: short s = 10;
  prefs: []
  type: TYPE_NORMAL
- en: int i = 10;
  prefs: []
  type: TYPE_NORMAL
- en: long l = 10;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'But each of the following lines generates an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: byte b = 128;
  prefs: []
  type: TYPE_NORMAL
- en: short s = 32768;
  prefs: []
  type: TYPE_NORMAL
- en: int i = 2147483648;
  prefs: []
  type: TYPE_NORMAL
- en: long l = 2147483648;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'That is because the maximum value the `byte` type can hold is 127, the maximum
    value the `short` type can hold is 32,767, and the maximum value the `int` type
    can hold is 2,147,483,647\. Notice that, although the `long` type can a value
    as big as 9,223,372,036,854,775,807, the last assignment still fails because the 2,147,483,648
    literal has the `int` type by default but exceeds the maximum `int` type value.
    To create a literal of the `long` type, one has to append the letter `l` or `L`
    at the end, so the following assignment works just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: long l = 2147483648L;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: It is a good practice to use capital `L` for this purpose because lowercase
    letter `l` can be easily confused with the number `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding examples of integral literals are expressed in a decimal number
    system. But the literals of the `byte`,  `short`, `int`, and `long` types can
    also be expressed in the binary (base 2, digits 0-1), octal (base 8, digits 0-7),
    and hexadecimal (base 16, digits 0-9 and a-f) number systems. Here is the demonstration
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("\nPrint literal 12:");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("- bin 0b1100: "+ 0b1100);'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("- oct    014: "+ 014);'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("- dec     12: "+ 12);'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("- hex    0xc: "+ 0xc);'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the preceding code, the output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/239db86f-5ce2-4211-8ea6-3d63206ac0c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, a binary literal starts with `0b` (or `0B`), followed by the
    value `12` expressed in a binary system: `1100` (=`2^0*0 + 2^1*0 + 2^2*1 + 2^3
    *1`). An octal literal starts with `0`, followed by the value `12` expressed in
    an octal system: `14` (=`8^0*4 + 8^1*1`). The decimal literal is just `12`. The
    hexadecimal literal starts with `0x` (or with `0X`), followed by value 12 expressed
    in a hexadecimal system—`c` (because in the hexadecimal system the symbols `a`
    to `f`  (or `A` to `F`) map to decimal values `10` to `15`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a minus sign (`-`) in front of a literal makes the value negative, no
    matter which numeric system is used. Here is a demonstration code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("\nPrint literal -12:");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("- bin 0b1100: "+ -0b1100);'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("- oct    014: "+ -014);'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("- dec     12: "+ -12);'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("- hex    0xc: "+ -0xc);'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the preceding code, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5382f549-f0de-4017-a6f5-cabe01bd18d1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And, to complete our discussion of primitive type literals, we would like to
    mention the possible usage of the underscore (`_`) inside a primitive type literal.
    In the case of a long number, breaking it into groups helps to quickly estimate
    its magnitude. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int speedOfLightMilesSec = 299_792_458;
  prefs: []
  type: TYPE_NORMAL
- en: float meanRadiusOfEarthMiles = 3_958.8f;
  prefs: []
  type: TYPE_NORMAL
- en: long creditCardNumber = 1234_5678_9012_3456L;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens when we run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: long anotherCreditCardNumber = 9876____5678_____9012____1234L;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("\n" + anotherCreditCardNumber);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the previous code would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65d2e9fd-81b4-42f8-b3d6-6c0413218765.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, one or many underscores are ignored if placed between digits
    inside a numeric literal. An underscore in any other location would cause a compilation
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Reference types and String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an object is assigned to a variable, this variable holds the reference
    to the memory where the object resides. From a practical standpoint, such a variable
    is handled in the code as if it is the object it represents. The type of such
    a variable can be a class, an interface, an array, or a special `null` type. If
    `null` is assigned, the reference to the object is lost and the variable does
    not represent any object. If an object is not used anymore, JVM removes it from
    the memory in the process called **garbage collection**. We will describe this
    process in [Chapter 11](e8c37d86-291d-4500-84ea-719683172477.xhtml), *JVM Processes
    and Garbage Collection*.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a reference type called type variable used for the declaration
    of a type parameter of a generic class, interface, method, or constructor. It
    belongs to the area of Java generic programming that is outside of the scope of
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: All objects, including arrays, inherit all the methods from the `java.lang.Object`
    class described in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java
    Language Basics*.
  prefs: []
  type: TYPE_NORMAL
- en: A variable that refers to an object of the `java.lang.String` class (or just
    `String`) is a reference type, too. But, in certain respects, the `String` object
    behaves as a primitive type, which might be confusing at times. That is why we
    will dedicate a section in this chapter to the `String` class.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the enum type (a reference type as well) requires special attention and
    we describe it at the end of this section in the *Enum types* subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Class types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A variable of the class type is declared using the corresponding class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: <Class name> variableName;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be initialized by assigning to it `null` or an object (an instance)
    of the class whose name is used for the declaration. If the class has a superclass
    (also called a parent class) from which it inherits (extends), the name of the
    superclass can be used for the variable declaration. It is possible because of
    Java polymorphism, described in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml),
    *Java Language Basics*. For example, if a `SomeClass` class extends `SomeBaseClass`,
    both of the following declarations and initializations are possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: SomeBaseClass someBaseClass = new SomeBaseClass();
  prefs: []
  type: TYPE_NORMAL
- en: someBaseClass = new SomeClass();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And, since every class extends the `java.lang.Object` class by default, the
    following declarations and initializations are possible too:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Object someBaseClass = new SomeBaseClass();
  prefs: []
  type: TYPE_NORMAL
- en: someBaseClass = new SomeClass();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We will talk more about assigning child class object to a base class reference
    in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml), *Operators, Expressions,
    and Statements*.
  prefs: []
  type: TYPE_NORMAL
- en: Interface types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A variable of an interface type is declared using the corresponding interface
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: <Interface name> variableName;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be initialized by assigning to it `null` or an object (an instance)
    of the class that implemented the interface. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: interface SomeInterface{
  prefs: []
  type: TYPE_NORMAL
- en: void someMethod();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface SomeOtherInterface{
  prefs: []
  type: TYPE_NORMAL
- en: void someOtherMethod();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class SomeClass implements SomeInterface {
  prefs: []
  type: TYPE_NORMAL
- en: void someMethod(){
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class SomeOtherClass implements SomeOtherInterface{
  prefs: []
  type: TYPE_NORMAL
- en: void someOtherMethod(){
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: SomeInterface someInterface = new SomeClass();
  prefs: []
  type: TYPE_NORMAL
- en: someInterface = new SomeOtherClass(); //not possible, error
  prefs: []
  type: TYPE_NORMAL
- en: someInterface.someMethod();         //works just fine
  prefs: []
  type: TYPE_NORMAL
- en: someInterface.someOtherMethod();   //not possible, error
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We will talk more about assigning child type to a base type reference in [Chapter
    9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml), *Operators, Expressions, and Statements*.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An array in Java is a reference type and extends (inherits from) the `Object` class,
    too. An array contains components that have the same type as the declared array
    type or the type whose values can be assigned to the array type. The number of
    components may be zero, in which case the array is an empty array.
  prefs: []
  type: TYPE_NORMAL
- en: An array component has no name and is referenced by an index, which is a positive
    integer or zero.  An array with `n` components is said to have *length of n*. Once
    an array object is created, its length never changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'An array declaration starts with a type name and empty brackets `[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: byte[] bs;
  prefs: []
  type: TYPE_NORMAL
- en: long[][] ls;
  prefs: []
  type: TYPE_NORMAL
- en: Object[][] os;
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass[][][] scs;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The number of bracket pairs indicates the number of dimensions (or the nesting
    depth) of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to create and initialize an array:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By creation expression, using the `new` keyword, type name, and brackets with
    the length of each dimension in each pair of brackets; for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: byte[] bs = new byte[100];
  prefs: []
  type: TYPE_NORMAL
- en: long[][] ls = new long [2][3];
  prefs: []
  type: TYPE_NORMAL
- en: Object[][] os = new Object[3][2];
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass[][][] scs = new SomeClass[3][2][1];
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'By array initializer, using a comma-separated list of values of each dimension,
    surrounded by braces, for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int[][] is = { { 1, 2, 3 }, { 10, 20 }, { 3, 4, 5, 6 } };
  prefs: []
  type: TYPE_NORMAL
- en: float[][] fs = { { 1.1f, 2.2f, 3 }, { 10, 20.f, 30.f } };
  prefs: []
  type: TYPE_NORMAL
- en: Object[] oss = { new Object(), new SomeClass(), null, "abc" };
  prefs: []
  type: TYPE_NORMAL
- en: SomeInterface[] sis = { new SomeClass(), null, new SomeClass() };
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from these examples, a multidimensional array can contain arrays
    of different lengths (the `int[][] is` array). Also, a component type value can
    be different from the array type as long as the value can be assigned to the variable
    of the array type (the `float[][] fs`, `Object[] is`, and `SomeInterface[] sis` arrays).
  prefs: []
  type: TYPE_NORMAL
- en: 'Because an array is an object, its components are initialized every time an
    array is created. Let''s consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int[][] is = new int[2][3];
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("\nis.length=" + is.length);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("is[0].length=" + is[0].length);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("is[0][0].length=" + is[0][0]);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("is[0][1].length=" + is[0][1]);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("is[0][2].length=" + is[0][2]);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("is[1].length=" + is[0].length);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("is[1][0].length=" + is[1][0]);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("is[1][1].length=" + is[1][1]);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("is[1][2].length=" + is[1][2]);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the preceding code snippet, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2463ad3-fe53-43ab-9e19-511714b556cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It is possible to create a multidimensional array without initializing some
    of the dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int[][] is = new int[2][];
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("\nis.length=" + is.length);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("is[0]=" + is[0]);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("is[1]=" + is[1]);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of this code running is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c7279b2-2fe4-48b6-aa7e-b42fae6c43e1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The missing dimension can be added later:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int[][] is = new int[2][];
  prefs: []
  type: TYPE_NORMAL
- en: is[0] = new int[3];
  prefs: []
  type: TYPE_NORMAL
- en: is[1] = new int[3];
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The important point is that a dimension has to be initialized before it can
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: Default value of a reference type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default value of a reference type is `null`. It means that if a reference
    type is a static class member or an instance field and not assigned an initial
    value explicitly, it will be initialized automatically and assigned the value
    of `null`. Please note that, in the case of an array, this applies to the array
    itself and to its reference type components.
  prefs: []
  type: TYPE_NORMAL
- en: Reference type literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `null` literal indicates the absence of any assignment to a reference type
    variable. Let''s look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass someClass = new SomeClass();
  prefs: []
  type: TYPE_NORMAL
- en: someClass.someMethod();
  prefs: []
  type: TYPE_NORMAL
- en: someClass = null;
  prefs: []
  type: TYPE_NORMAL
- en: someClass.someMethod(); // throws NullPointerException
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The first statement declares the `someClass` variable and assigns to it a reference
    to the object of the `SomeClass` class. Then a method of this class is called
    using its reference. The next line assigns the `null` literal to the `someClass` variable.
    It removes the reference value from the variable. So, when in the next line, we
    try to call the same method again, we get back `NullPointerException`, which happens
    only when a reference used is assigned the `null` value.
  prefs: []
  type: TYPE_NORMAL
- en: The `String` type is a reference type, too. This means that the default value
    of a `String` variable is `null`. The `String` class inherits all the methods
    from the `java.lang.Object` class as any other reference type does, too.
  prefs: []
  type: TYPE_NORMAL
- en: But in some respects, objects of the `String` class behave as if they are of
    a primitive type. We will discuss one such case—when the `String` object is used
    as a method parameter—in the *Passing reference type values as method parameters* section.
    We will discuss other cases of `String` behaving like a primitive type now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another feature of the `String` type that makes it look like a primitive type
    is that it is the only reference type that has more literals than just `null`.
    The type `String` can also have a literal of zero or more characters enclosed
    in double quotes—`""`, `"$"`, `"abc"`, and `"12-34"`. The characters of the `String`
    literal may include escape sequences, too. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("\nFirst line.\nSecond line.");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Tab space\tin the line");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("It is called a \"String literal\".");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("Latin Capital Letter Y with diaeresis: \u0178");'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you execute the preceding code snippet, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4ff739c-3cd1-4b9a-8900-8273a4536a18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But, in contrast with the `char` type literals, `String` literals do not behave
    like numbers in an arithmetic operation. The only arithmetic operation applicable
    to the `String` type is an addition, and it behaves like a concatenation:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("s1" + "s2");
  prefs: []
  type: TYPE_NORMAL
- en: String s1 = "s1";
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s1 + "s2");
  prefs: []
  type: TYPE_NORMAL
- en: String s2 = "s1";
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s1 + s2);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the preceding code and you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d0600b2-bac7-4769-a95f-4e7596b5f802.png)'
  prefs: []
  type: TYPE_IMG
- en: Another particular characteristic of `String` is that an object of the `String` type is
    immutable.
  prefs: []
  type: TYPE_NORMAL
- en: String immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One cannot change the `String` type value assigned to a variable without changing
    the reference. There are several reasons why JVM authors decided to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'All `String` literals are stored in the same common memory area, called string
    pool. Before a new `String` literal is stored, the JVM checks whether such a literal
    is already stored there. If such an object exists already, a new object is not
    created and the reference to the existing object is returned as the reference
    to a new object. The following code demonstrates this situation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("s1" == "s1");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("s1" == "s2");
  prefs: []
  type: TYPE_NORMAL
- en: String s1 = "s1";
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s1 == "s1");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s1 == "s2");
  prefs: []
  type: TYPE_NORMAL
- en: String s2 = "s1";
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s1 == s2);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, we use the `==` relational operator, which is used to
    compare values of primitive types and references of reference types. If we run
    this code, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/728b25a9-08ca-45aa-a329-f818a04f7801.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the various comparisons of literals (directly or via a variable)
    consistently yield `true` if two literals have the same spelling, and produce
    `false` if the spelling is different. This way, long `String` literals are not
    duplicated and the memory is used better.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid concurrent modification of the same literal by different methods,
    every time we attempt to change the `String` literal, a copy of the literal with
    the change is created, while the original `String` literal remains untouched.
    Here is the code that demonstrates it:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String s1 = "\nthe original string";
  prefs: []
  type: TYPE_NORMAL
- en: String s2 = s1.concat(" has been changed");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s2);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s1);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `concat()` method of the `String` class adds another `String` literal to
    the original value of `s1` and assigns the result to the `s1` variable. The output
    of this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9007f810-5f17-47ab-a3f9-2f3a8ae6112a.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the original literal assigned to `s1` did not change.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason for such a design decision is security – one of the highest-priority
    goals JVM's authors had in mind. `String` literals are widely used as username
    and passwords to access an application, database, and server. Immutability of
    the `String` value makes it less susceptible to an unauthorized modification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yet another reason is that there are certain calculation-intensive procedures
    (the `hashCode()` method in the `Object` parent class, for example) that could
    be quite taxing in the case of long `String` values. By making the `String` object
    immutable, such a calculation could be avoided if it was already performed on
    the value with the same spelling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is why all methods that modify a `String` value return the `String` type,
    which is the reference to a new `String` object that carries the result. The `concat()` method
    in the preceding code is a typical example of such a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The matter becomes a bit more complicated in the case where a `String` object
    is created not from the literal, but using the `String` constructor, `new String("some
    literal")`. In such a case, the `String` object is stored in the same area where
    all objects of all classes are stored, and every time a `new` keyword is used,
    another chunk of memory (with another reference) is allocated. Here is the code
    that demonstrates it:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String s3 = new String("s");
  prefs: []
  type: TYPE_NORMAL
- en: String s4 = new String("s");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s3 == s4);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run it, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d538290-5e7b-49af-a1e5-48067df41fba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, despite the same spelling, the objects have different memory
    references. To avoid confusion and to compare the `String` objects by their spelling
    only, always use the `equals()` method of the `String` class. Here is the code
    that demonstrates its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("s5".equals("s5"));  //true
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("s5".equals("s6"));  //false
  prefs: []
  type: TYPE_NORMAL
- en: String s5 = "s5";
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s5.equals("s5"));   //true
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s5.equals("s6"));   //false
  prefs: []
  type: TYPE_NORMAL
- en: String s6 = "s6";
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s5.equals(s5));     //true
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s5.equals(s6));     //false
  prefs: []
  type: TYPE_NORMAL
- en: String s7 = "s6";
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s7.equals(s6));     //true
  prefs: []
  type: TYPE_NORMAL
- en: String s8 = new String("s6");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s8.equals(s7));     //true
  prefs: []
  type: TYPE_NORMAL
- en: String s9 = new String("s9");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s8.equals(s9));     //false
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run it, the result will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5dc62d29-e4c1-47de-99d1-6f0a32eedba6.png)'
  prefs: []
  type: TYPE_IMG
- en: We added the results as the comments to the preceding code for your convenience.
    As you can see, the `equals()` method of the `String` class returns `true` or
    `false` based only on the spelling of the value, so use it all the time when spelling
    comparison is your goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, you may remember that the `equals()` method is defined in the `Object` class—the
    parent class of the `String` class. The `String` class has its own `equals()` method
    that overrides the method with the same signature in the parent class as we have
    demonstrated in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java
    Language Basics*. The source code of the `equals()` method of the `String` class
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public boolean equals(Object anObject) {
  prefs: []
  type: TYPE_NORMAL
- en: if (this == anObject) {
  prefs: []
  type: TYPE_NORMAL
- en: return true;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if (anObject instanceof String) {
  prefs: []
  type: TYPE_NORMAL
- en: String aString = (String)anObject;
  prefs: []
  type: TYPE_NORMAL
- en: if (coder() == aString.coder()) {
  prefs: []
  type: TYPE_NORMAL
- en: return isLatin1() ?
  prefs: []
  type: TYPE_NORMAL
- en: StringLatin1.equals(value, aString.value)
  prefs: []
  type: TYPE_NORMAL
- en: ': StringUTF16.equals(value, aString.value);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return false;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it compares references first and, if they point to the same
    object, returns `true`. But, if the references are different, it compares the
    spelling of the values, which actually happens in the `equals()` method of the `StringLatin1`
    and `StringUTF16` classes.
  prefs: []
  type: TYPE_NORMAL
- en: The point we would like you to take away is that the `equals()` method of the `String` class
    is optimized by performing the comparison of references first and, only if not
    successful, it comparing the values themselves. Which means there is no need to
    compare references in the code. Instead, for `String` type object comparison, always
    use the `equals()` method only.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we are moving to the last of the reference types we will discuss
    in this chapter—the `enum` type.
  prefs: []
  type: TYPE_NORMAL
- en: Enum types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before describing the `enum` type, let''s look at one of the use cases as the
    motivation for having such a type. Let''s assume we would like to create a class
    that describes `TheBlows` family:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class TheBlows {
  prefs: []
  type: TYPE_NORMAL
- en: private String name, relation, hobby = "biking";
  prefs: []
  type: TYPE_NORMAL
- en: private int age;
  prefs: []
  type: TYPE_NORMAL
- en: public TheBlows(String name, String relation, int age) {
  prefs: []
  type: TYPE_NORMAL
- en: this.name = name;
  prefs: []
  type: TYPE_NORMAL
- en: this.relation = relation;
  prefs: []
  type: TYPE_NORMAL
- en: this.age = age;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public String getName() { return name; }
  prefs: []
  type: TYPE_NORMAL
- en: public String getRelation() { return relation; }
  prefs: []
  type: TYPE_NORMAL
- en: public int getAge() { return age; }
  prefs: []
  type: TYPE_NORMAL
- en: public String getHobby() { return hobby; }
  prefs: []
  type: TYPE_NORMAL
- en: public void setHobby(String hobby) { this.hobby = hobby; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We have set the default hobby as `biking` and will allow to change it later,
    but other properties have to be set during object construction. That would fine,
    except we do not want to have more than four members of this family in the system,
    as we know all the members of `TheBlows` family very well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To impose these restrictions, we decided to create all possible objects of
    the `TheBlows` class up-front and make the constructor private:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class TheBlows {
  prefs: []
  type: TYPE_NORMAL
- en: public static TheBlows BILL = new TheBlows("Bill", "father", 42);
  prefs: []
  type: TYPE_NORMAL
- en: public static TheBlows BECKY = new TheBlows("BECKY", "mother", 37);
  prefs: []
  type: TYPE_NORMAL
- en: public static TheBlows BEE = new TheBlows("Bee", "daughter", 5);
  prefs: []
  type: TYPE_NORMAL
- en: public static TheBlows BOB = new TheBlows("Bob", "son", 3);
  prefs: []
  type: TYPE_NORMAL
- en: private String name, relation, hobby = "biking";
  prefs: []
  type: TYPE_NORMAL
- en: private int age;
  prefs: []
  type: TYPE_NORMAL
- en: private TheBlows(String name, String relation, int age) {
  prefs: []
  type: TYPE_NORMAL
- en: this.name = name;
  prefs: []
  type: TYPE_NORMAL
- en: this.relation = relation;
  prefs: []
  type: TYPE_NORMAL
- en: this.age = age;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public String getName() { return name; }
  prefs: []
  type: TYPE_NORMAL
- en: public String getRelation() { return relation; }
  prefs: []
  type: TYPE_NORMAL
- en: public int getAge() { return age; }
  prefs: []
  type: TYPE_NORMAL
- en: public String getHobby() { return hobby; }
  prefs: []
  type: TYPE_NORMAL
- en: public void setHobby(String hobby) { this.hobby = hobby; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now only the four instances of the `TheBlows` class exist and no other object
    of this class can be created. Let''s see what happens if we run the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(TheBlows.BILL.getName());
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(TheBlows.BILL.getHobby());
  prefs: []
  type: TYPE_NORMAL
- en: TheBlows.BILL.setHobby("fishing");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(TheBlows.BILL.getHobby());
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1cc72d3-55bb-46b8-901b-e202ec027a79.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, we can create the `TheJohns` family with three family members:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class TheJohns {
  prefs: []
  type: TYPE_NORMAL
- en: public static TheJohns JOE = new TheJohns("Joe", "father", 42);
  prefs: []
  type: TYPE_NORMAL
- en: public static TheJohns JOAN = new TheJohns("Joan", "mother", 37);
  prefs: []
  type: TYPE_NORMAL
- en: public static TheJohns JILL = new TheJohns("Jill", "daughter", 5);
  prefs: []
  type: TYPE_NORMAL
- en: private String name, relation, hobby = "joggling";
  prefs: []
  type: TYPE_NORMAL
- en: private int age;
  prefs: []
  type: TYPE_NORMAL
- en: private TheJohns(String name, String relation, int age) {
  prefs: []
  type: TYPE_NORMAL
- en: this.name = name;
  prefs: []
  type: TYPE_NORMAL
- en: this.relation = relation;
  prefs: []
  type: TYPE_NORMAL
- en: this.age = age;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public String getName() { return name; }
  prefs: []
  type: TYPE_NORMAL
- en: public String getRelation() { return relation; }
  prefs: []
  type: TYPE_NORMAL
- en: public int getAge() { return age; }
  prefs: []
  type: TYPE_NORMAL
- en: public String getHobby() { return hobby; }
  prefs: []
  type: TYPE_NORMAL
- en: public void setHobby(String hobby) { this.hobby = hobby; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'While doing that, we noticed a lot of commonalities in these two classes and
    decided to create a `Family` base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class Family {
  prefs: []
  type: TYPE_NORMAL
- en: private String name, relation, hobby;
  prefs: []
  type: TYPE_NORMAL
- en: private int age;
  prefs: []
  type: TYPE_NORMAL
- en: protected Family(String name, String relation, int age, String hobby) {
  prefs: []
  type: TYPE_NORMAL
- en: this.name = name;
  prefs: []
  type: TYPE_NORMAL
- en: this.relation = relation;
  prefs: []
  type: TYPE_NORMAL
- en: this.age = age;
  prefs: []
  type: TYPE_NORMAL
- en: this.hobby = hobby;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public String getName() { return name; }
  prefs: []
  type: TYPE_NORMAL
- en: public String getRelation() { return relation; }
  prefs: []
  type: TYPE_NORMAL
- en: public int getAge() { return age; }
  prefs: []
  type: TYPE_NORMAL
- en: public String getHobby() { return hobby; }
  prefs: []
  type: TYPE_NORMAL
- en: public void setHobby(String hobby) { this.hobby = hobby; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the `TheBlows` and `TheJohns` classes can be substantially simplified after
    extending the `Family` class. Here''s how the `TheBlows` class can now look:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class TheBlows extends Family {
  prefs: []
  type: TYPE_NORMAL
- en: public static TheBlows BILL = new TheBlows("Bill", "father", 42);
  prefs: []
  type: TYPE_NORMAL
- en: public static TheBlows BECKY = new TheBlows("Becky", "mother", 37);
  prefs: []
  type: TYPE_NORMAL
- en: public static TheBlows BEE = new TheBlows("Bee", "daughter", 5);
  prefs: []
  type: TYPE_NORMAL
- en: public static TheBlows BOB = new TheBlows("Bob", "son", 3);
  prefs: []
  type: TYPE_NORMAL
- en: private TheBlows(String name, String relation, int age) {
  prefs: []
  type: TYPE_NORMAL
- en: super(name, relation, age, "biking");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: And that is the idea behind the `enum` type—to allow the creating of classes
    with a fixed number of named instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `enum` reference type class extends the `java.lang.Enum` class. It defines
    the set of constants, each of them an instance of the `enum` type it belongs to.
    The declaration of such a set starts with the `enum` keyword. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: enum Season { SPRING, SUMMER, AUTUMN, WINTER }
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the listed items—`SPRING`, `SUMMER`, `AUTUMN`, and `WINTER`—is an instance
    of `Season`. They are the only four instances of the `Season` class that can exist
    in an application. No other instance of the `Season` class can be created. And
    that is the reason for the creation of the `enum` type: it can be used for cases
    when the list of instances of a class has to be limited to the fixed set, such
    as the list of possible seasons.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `enum` declaration can also be written in a camel-case style:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: enum Season { Spring, Summer, Autumn, Winter }
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: But the all-uppercase style is used more often because, as we mentioned earlier,
    the static final constant's identifiers in Java programming are written this way
    by convention, in order to distinguish them from the non-constant variable. And
    `enum` constants are static and final implicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review an example of the `Season` class usage. Here is a method that
    prints different messages, depending on the season:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void enumDemo(Season season){
  prefs: []
  type: TYPE_NORMAL
- en: if(season == Season.WINTER){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Dress up warmer");
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("You can drees up lighter now");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens if we run the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: enumDemo(Season.WINTER);
  prefs: []
  type: TYPE_NORMAL
- en: enumDemo(Season.SUMMER);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f4d8e93-b7b4-44af-9713-a1a9f6cd14ca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You probably have noticed that we used an `==` operator that compares references.
    That is because the `enum` instances (as all static variables) exist uniquely
    in memory. And the `equals()` method (implemented in the `java.lang.Enum` parent
    class) brings the same result. Let''s run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Season season = Season.WINTER;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Season.WINTER == season);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Season.WINTER.equals(season));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e650d658-2e63-40ec-8205-ff45287ac8aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The reason for this is that the `equals()` method of the `java.lang.Enum` class
    is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public final boolean equals(Object other) {
  prefs: []
  type: TYPE_NORMAL
- en: return this == other;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it does exactly the same comparison of two objects references – `this`
    (the reserved keyword that refers the current object) and the reference to another
    object. If you wonder why the parameter has the `Object` type, we would like to
    remind you that all reference types, including `enum` and `String`, extend `java.lang.Object`.
    They do it implicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other useful methods of `java.lang.Enum` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name()`: Returns the enum constant''s identifier as it is spelled when declared.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ordinal()`: Returns the integer that corresponds to the position of the enum
    constant when declared (the first in the list has an ordinal value of zero).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valueOf()`: Returns the `enum` constant object by its name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toString()`: Returns the same value as the `name()` method by default, but
    can be overridden to return any other `String` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values()`: A static method you will not find in the documentation of the `java.lang.Enum` class. In
    the Java Specification, section 8.9.3 ([https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)),
    it is described as implicitly declared and the Java Tutorial ([https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html))
    states that the compiler *automatically adds some special methods when it creates
    an enum*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Among them, a static `values()` method that returns an array containing all
    of the values of the `enum` in the order they are declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of their usage. Here is the `enum` class we will
    use for the demo:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: enum Season {
  prefs: []
  type: TYPE_NORMAL
- en: SPRING, SUMMER, AUTUMN, WINTER;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And the following is the code that uses it:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Season.SPRING.name());
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Season.SUMMER.ordinal());
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Enum.valueOf(Season.class, "AUTUMN"));
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Season.WINTER.name());
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/739ed513-aced-4e9c-b307-407928949fd4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first line is the output of the `name()` method. The second—is the return
    value of the `ordinal()` method: the `SUMMER` constant is the second in the list,
    so its ordinal value is 1\. The third line is the result of the `toString()` method
    applied to the `enum` constant of `AUTUMN` returned by the `valueOf()` method.
    And the last—is the result of the `toString()` method applied to the `WINTER` constant.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `equals()`, `name()`, and `ordinal()` methods are declared `final` in `java.lang.Enum`,
    so they cannot be overridden and are used as-is.  The `valueOf()` method is static
    and not associated with any class instance, so it cannot be overridden. The only
    method we can override is the `toString()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: enum Season {
  prefs: []
  type: TYPE_NORMAL
- en: SPRING, SUMMER, AUTUMN, WINTER;
  prefs: []
  type: TYPE_NORMAL
- en: public String toString() {
  prefs: []
  type: TYPE_NORMAL
- en: return "The best season";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the preceding code again, the result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19202174-e824-45da-ab53-4ed72a4ae21b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, you can see that the `toString()` method returns the same result for each
    constant. If necessary, the `toString()` method can be overridden for each constant.
    Let''s look at this version of the `Season` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: enum Season2 {
  prefs: []
  type: TYPE_NORMAL
- en: SPRING,
  prefs: []
  type: TYPE_NORMAL
- en: SUMMER,
  prefs: []
  type: TYPE_NORMAL
- en: AUTUMN,
  prefs: []
  type: TYPE_NORMAL
- en: WINTER { public String toString() { return "Winter"; } };
  prefs: []
  type: TYPE_NORMAL
- en: public String toString() {
  prefs: []
  type: TYPE_NORMAL
- en: return "The best season";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have overridden the `toString()` method for the `WINTER` constant only.
    If we run the same code snippet again, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc5ddc24-87cd-450a-ab70-0505e97b4b21.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the old version of `toString()` is used for all constants, except
    `WINTER`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to add any property (and getters and setters) to `enum`
    constants and associate each of them with corresponding values. Here is one example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: enum Season {
  prefs: []
  type: TYPE_NORMAL
- en: SPRING("Spring", "warmer than winter", 60),
  prefs: []
  type: TYPE_NORMAL
- en: SUMMER("Summer", "the hottest season", 100),
  prefs: []
  type: TYPE_NORMAL
- en: AUTUMN("Autumn", "colder than summer", 70),
  prefs: []
  type: TYPE_NORMAL
- en: WINTER("Winter", "the coldest season", 40);
  prefs: []
  type: TYPE_NORMAL
- en: private String feel, toString;
  prefs: []
  type: TYPE_NORMAL
- en: private int averageTemperature;
  prefs: []
  type: TYPE_NORMAL
- en: Season(String toString, String feel, int t) {
  prefs: []
  type: TYPE_NORMAL
- en: this.feel = feel;
  prefs: []
  type: TYPE_NORMAL
- en: this.toString = toString;
  prefs: []
  type: TYPE_NORMAL
- en: this.averageTemperature = t;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public String getFeel(){ return this.feel; }
  prefs: []
  type: TYPE_NORMAL
- en: public int getAverageTemperature(){
  prefs: []
  type: TYPE_NORMAL
- en: return this.averageTemperature;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public String toString() { return this.toString; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we have added three properties to the `Season` class: `feel`,
    `toString`, and `averageTemperature`. We have also created a constructor (a special method
    used to assign the initial values of an object state) that takes these three properties
    and adds getters and `toString()` methods that return values of these properties.
    Then, in parentheses after each constant, we have set the values that are going
    to be passed to the constructor when this constant is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a demo method that we are going to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void enumDemo(Season season){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(season + " is " + season.getFeel());
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(season + " has average temperature around "
  prefs: []
  type: TYPE_NORMAL
- en: + season.getAverageTemperature());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `enumDemo()` method takes the `enum Season` constant and constructs and
    displays two sentences. Let''s run the preceding code for each season, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: enumDemo2(Season3.SPRING);
  prefs: []
  type: TYPE_NORMAL
- en: enumDemo2(Season3.SUMMER);
  prefs: []
  type: TYPE_NORMAL
- en: enumDemo2(Season3.AUTUMN);
  prefs: []
  type: TYPE_NORMAL
- en: enumDemo2(Season3.WINTER);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90d857fd-ef52-4317-97b9-d2435ab70fb9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `enum` class is a very powerful tool that allows us to simplify the code
    and make it better protected from runtime errors because all possible values are
    predictable and can be tested in advance. For example, we can test the `SPRING`
    constant getters using the following unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '@DisplayName("Enum Season tests")'
  prefs: []
  type: TYPE_NORMAL
- en: public class EnumSeasonTest {
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: '@DisplayName("Test Spring getters")'
  prefs: []
  type: TYPE_NORMAL
- en: void multiplyByTwo(){
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals("Spring", Season.SPRING.toString());
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals("warmer than winter", Season.SPRING.getFeel());
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals(60, Season.SPRING.getAverageTemperature());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Granted, the getters don't have much code to make a mistake. But if the `enum`
    class has more complex methods or the list of the fixed values comes from some
    application requirements document, such a test will make sure we have written
    the code as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the standard Java libraries, there are several `enum` classes. Here are
    a few examples of constants from those classes that can give you a hint about
    what is out there:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Month.FEBRUARY;
  prefs: []
  type: TYPE_NORMAL
- en: TimeUnit.DAYS;
  prefs: []
  type: TYPE_NORMAL
- en: TimeUnit.MINUTES;
  prefs: []
  type: TYPE_NORMAL
- en: DayOfWeek.FRIDAY;
  prefs: []
  type: TYPE_NORMAL
- en: Color.GREEN;
  prefs: []
  type: TYPE_NORMAL
- en: Color.green;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: So, before creating your own `enum`, try to check and see whether the standard
    libraries already provide a class with the values you need.
  prefs: []
  type: TYPE_NORMAL
- en: Passing reference type values as method parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One important difference between the reference types and primitive types that
    merits special discussion is the way their values can be used in a method. Let''s
    see the difference by example. First, we create the `SomeClass` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class SomeClass{
  prefs: []
  type: TYPE_NORMAL
- en: private int count;
  prefs: []
  type: TYPE_NORMAL
- en: public int getCount() {
  prefs: []
  type: TYPE_NORMAL
- en: return count;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public void setCount(int count) {
  prefs: []
  type: TYPE_NORMAL
- en: this.count = count;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we create a class that uses it:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class ReferenceTypeDemo {
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args) {
  prefs: []
  type: TYPE_NORMAL
- en: float f = 1.0f;
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass someClass = new SomeClass();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("\nBefore demoMethod(): f = " + f +'
  prefs: []
  type: TYPE_NORMAL
- en: '", count = " + someClass.getCount());'
  prefs: []
  type: TYPE_NORMAL
- en: demoMethod(f, someClass);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("After demoMethod(): f = " + f'
  prefs: []
  type: TYPE_NORMAL
- en: + ", count = " + someClass.getCount());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: private static void demoMethod(float f, SomeClass someClass){
  prefs: []
  type: TYPE_NORMAL
- en: //... some code can be here
  prefs: []
  type: TYPE_NORMAL
- en: f = 42.0f;
  prefs: []
  type: TYPE_NORMAL
- en: someClass.setCount(42);
  prefs: []
  type: TYPE_NORMAL
- en: someClass = new SomeClass();
  prefs: []
  type: TYPE_NORMAL
- en: someClass.setCount(1001);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look inside `demoMethod()` first. We have made it very simple for demo
    purposes, but assume it does more, and then assigns a new value to the `f` variable
    (parameter) and sets a new count value on the object of the `SomeClass` class.
    Then this method attempts to replace the passed-in reference with a new value
    that points to a new `SomeClass` object with another count value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main()` method, we declare and initialize the `f` and `someClass` variables with
    some values and print them out, then pass them as the parameters to the `demoMethod()` method and
    print the values of the same variables again. Let''s run the `main()` method and
    see the results that should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fe7f190-7bc0-4bc5-bf1b-90634245d199.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To understand the difference, we need to take into account these two facts:'
  prefs: []
  type: TYPE_NORMAL
- en: Values to a method are passed by copy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value of a reference type is a reference to a memory where the referred object
    resides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is why when the primitive value (or `String`, which is immutable as we
    have explained already) is passed in, the copy of the actual value is created,
    so the original value cannot be affected.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if the reference to an object is passed in, only its copy is accessible
    to the code in the method, so the original reference cannot be changed. That is
    why our attempt to change the original reference value and make it refer another
    object did not succeed, either.
  prefs: []
  type: TYPE_NORMAL
- en: But the code inside the method is able to access the original object and change
    its count value using the copy of the reference value because the value still
    points to the same memory area where the original object resides. That is why
    code inside the method is able to execute any method of the original object, including
    those methods that change the object's state (values of the instance fields).
  prefs: []
  type: TYPE_NORMAL
- en: 'This change of an object state, when it was passed in as a parameter, is called
    a side-effect and is sometimes used, when  the following occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: A method has to return several values but it is not possible to do it via returned
    construct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The programmer is not skilled enough
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A third-party library or a framework utilizes the side-effect as the primary
    mechanism of getting back the result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But the best practices and design principles (the Single Responsibility Principle
    in this case, which we will discuss in [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml),
    *Object-Oriented Design (OOD) Principles*) guide programmers to avoiding side-effects,
    if possible, because side effects often lead to a not-very-readable (for a human) code
    and subtle runtime effects that are difficult to identify and fix.
  prefs: []
  type: TYPE_NORMAL
- en: One has to distinguish a side effect and a code design pattern called Delegation
    Pattern ([https://en.wikipedia.org/wiki/Delegation_pattern](https://en.wikipedia.org/wiki/Delegation_pattern)),
    when the methods invoked on the passed-in objects are stateless. We will talk
    about design patterns in [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml), *Object-Oriented
    Design (OOD) Principles*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, a side effect is possible when an array is passed in as a parameter.
    Here is the code that demonstrates it:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class ReferenceTypeDemo {
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args) {
  prefs: []
  type: TYPE_NORMAL
- en: int[] someArray = {1, 2, 3};
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("\nBefore demoMethod(): someArray[0] = "'
  prefs: []
  type: TYPE_NORMAL
- en: + someArray[0]);
  prefs: []
  type: TYPE_NORMAL
- en: demoMethod(someArray);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("After demoMethod(): someArray[0] = "'
  prefs: []
  type: TYPE_NORMAL
- en: + someArray[0]);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: private static void demoMethod(int[] someArray){
  prefs: []
  type: TYPE_NORMAL
- en: someArray[0] = 42;
  prefs: []
  type: TYPE_NORMAL
- en: someArray = new int[3];
  prefs: []
  type: TYPE_NORMAL
- en: someArray[0] = 43;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the preceding code execution is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4431c564-3f1d-4148-87b7-126c30401e9d.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that despite the fact that, inside the method, we were able to assign
    a new array to the passed-in variable, the assignment of value `43` affected only
    the newly created array, but had no effect on the original array. Yet, the change
    of an array component using the passed-in copy of the reference value is possible
    because the copy still points to the same original array.
  prefs: []
  type: TYPE_NORMAL
- en: 'And, to close the discussion about reference types as method parameters and
    possible side effects of that, we would like to demonstrate that the `String`
    type parameter—because of the `String` value immutability—behaves like a primitive
    type when passed in as a parameter. Here is the demo code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class ReferenceTypeDemo {
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args) {
  prefs: []
  type: TYPE_NORMAL
- en: String someString = "Some string";
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("\nBefore demoMethod(): string = "'
  prefs: []
  type: TYPE_NORMAL
- en: + someString);
  prefs: []
  type: TYPE_NORMAL
- en: demoMethod(someString);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("After demoMethod(): string = "'
  prefs: []
  type: TYPE_NORMAL
- en: + someString);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: private static void demoMethod(String someString){
  prefs: []
  type: TYPE_NORMAL
- en: someString = "Some other string";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code yields the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c29f1c82-c6e0-4f44-8f20-d3e72a10bcdb.png)'
  prefs: []
  type: TYPE_IMG
- en: The code inside the method was not able to change the original parameter value.
    The reason for that is not – as in the case of a primitive type – that the parameter
    value was copied before being passed into the method. The copy, in this case,
    still pointed to the same original `String` object. The actual reason is that
    changing a `String` value does not change the value, but creates another `String`
    object with the result of the change. That is the `String` value immutability
    mechanism as we have described it in the *String type and literals* section. The
    reference to this new (changed) `String` object assigned to the copy of the reference
    value passed in and has no effect on the original reference value that still points
    to the original String object.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we conclude the discussion about Java reference types and String.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – Variable declarations and initializations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Which of the following statements are correct:'
  prefs: []
  type: TYPE_NORMAL
- en: int x = 'x';
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: int x1 = "x";
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: char x2 = "x";
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: char x4 = 1;
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: String x3 = 1;
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Month.MAY = 5;
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Month month = Month.APRIL;
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1, 4, 7
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chapter provided the foundation for the discussion of more complex Java
    language constructs. Knowledge of Java elements, such as identifiers, variables,
    literals, keywords, separators, comments and types—primitive and reference—is
    indispensable for Java programming. You also had a chance to learn about several
    areas that can be sources of confusion if not understood properly, such as the
    String type immutability and possible side effects when a reference type is used
    as a method parameter. Arrays and `enum` types were also explained in detail,
    enabling the reader to use these powerful constructs and increase the quality
    of their code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, the reader will be introduced the most common terms and
    coding solutions of Java programming—**Application Programming Interface** (**API**),
    object factories, method overriding, hiding, and overloading. Then the discussion
    about the design of a software system and the advantage of aggregation (vs inheritance)
    will bring the reader into the realm of best design practices. The overview of
    Java data structures will conclude the chapter, providing the reader with practical
    programming advice and recommendations.
  prefs: []
  type: TYPE_NORMAL
