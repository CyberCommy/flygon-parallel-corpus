- en: '*Chapter 5*: Configuring Kubernetes Security Boundaries'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A security boundary separates security domains where a set of entities share
    the same security concerns and access levels, whereas a trust boundary is a dividing
    line where program execution and data change the level of trust. Controls in the
    security boundary ensure that execution moving between boundaries does not elevate
    the trust level without appropriate validation. As data or execution moves between
    security boundaries without appropriate controls, security vulnerabilities show
    up.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll discuss the importance of security and trust boundaries.
    We'll first focus on the introduction to clarify any confusion between security
    and trust boundaries. Then, we'll walk through the security domains and security
    boundaries within the Kubernetes ecosystem. Finally, we'll look at some Kubernetes
    features that enhance security boundaries for an application deployed in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: You should understand the concepts of security domain and security boundaries,
    and also understand the security boundaries built around Kubernetes based on the
    underlying container technology as well as the built-in security features, such
    as PodSecurityPolicy and NetworkPolicy.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to security boundaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security boundaries versus trust boundaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes security domains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes entities as security boundaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security boundaries in the system layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security boundaries in the network layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to security boundaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security boundaries exist in the data layer, the network layer, and the system
    layer. Security boundaries depend on the technologies used by the IT department
    or infrastructure team. For example, companies use virtual machines to manage
    their applications â€“ a hypervisor is the security boundary for virtual machines.
    Hypervisors ensure that code running in a virtual machine does not escape from
    the virtual machine or affect the physical node. When companies start embracing
    microservices and use orchestrators to manage their applications, containers are
    one of the security boundaries. However, compared to hypervisors, containers do
    not provide a strong security boundary, nor do they aim to. Containers enforce
    restrictions at the application layer but do not prevent attackers from bypassing
    these restrictions from the kernel layer.
  prefs: []
  type: TYPE_NORMAL
- en: At the network layer, traditionally, firewalls provide strong security boundaries
    for applications. In a microservices architecture, Pods in Kubernetes can communicate
    with others. Network policies are used to restrict communication among Pods and
    Services.
  prefs: []
  type: TYPE_NORMAL
- en: Security boundaries at the data layer are well known. Kernels limiting write
    access to system or bin directories to only root or system users is a simple example
    of security boundaries at the data layer. In containerized environments, chroot
    prevents containers from tampering with the filesystems of other containers. Kubernetes
    restructures the application deployment in a way that strong security boundaries
    can be enforced on both the network and system layers.
  prefs: []
  type: TYPE_NORMAL
- en: Security boundaries versus trust boundaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security boundary and trust boundary are often used as synonyms. Although similar,
    there is a subtle difference between these two terms. A **trust boundary** is
    where a system changes its level of trust. An execution trust boundary is where
    instructions need different privileges to run. For example, a database server
    executing code in `/bin` is an example of an execution crossing a trust boundary.
    Similarly, a data trust boundary is where data moves between entities with different
    trust levels. Data inserted by an end user into a trusted database is an example
    of data crossing a trust boundary.
  prefs: []
  type: TYPE_NORMAL
- en: Whereas a **security boundary** is a point of demarcation between different
    security domains, a security domain is a set of entities that are within the same
    access level. For example, in traditional web architecture, the user-facing applications
    are part of a security domain and the internal network is part of a different
    security domain. Security boundaries have access controls associated with it.
    Think of trust boundary as a wall and security boundary as a fence around the
    wall.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying security and trust boundaries within an ecosystem is important.
    It helps ensure appropriate validation is done for instructions and data before
    it crosses the boundaries. In Kubernetes, components and objects span across different
    security boundaries. It is important to understand these boundaries to put risk
    mitigation plans in place when an attacker crosses a security boundary. CVE-2018-1002105
    is a prime example of an attack caused by missing validation across trust boundaries;
    proxy request handling in the API server allowed an unauthenticated user to get
    admin privileges to the cluster. Similarly, CVE-2018-18264 allows users to skip
    the authentication process on the dashboard to allow unauthenticated users to
    access sensitive cluster information.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at different Kubernetes security domains.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes security domains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Kubernetes cluster can be broadly split into three security domains:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kubernetes master components**: Kubernetes master components define the control
    plane for the Kubernetes ecosystem. The master components are responsible for
    decisions required for the smooth operation of the cluster, such as scheduling.
    Master components include `kube-apiserver`, `etcd`, the `kube-controller` manager,
    DNS server, and `kube-scheduler`. A breach in the Kubernetes master components
    can compromise the entire Kubernetes cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubernetes worker components**: Kubernetes worker components are deployed
    on every worker node and ensure that Pods and containers are running nicely. Kubernetes
    worker components use authorization and TLS tunneling for communicating with the
    master components. A cluster can function with compromised worker components.
    It is analogous to a rogue node within the environment, which can be removed from
    the cluster when identified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubernetes objects**: Kubernetes objects are persistent entities that represent
    the state of the cluster: deployed applications, volumes, and namespaces. Kubernetes
    objects include Pods, Services, volumes, and namespaces. These are deployed by
    developers or DevOps. Object specification defines additional security boundaries
    for objects: defining a Pod with a SecurityContext, network rules to communicate
    with other Pods, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The high-level security domain division should help you focus on the key assets.
    Keeping that in mind, we'll start looking at Kubernetes entities and the security
    boundaries built around them.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes entities as security boundaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a Kubernetes cluster, the Kubernetes entities (objects and components) you
    interact with have their own built-in security boundaries. The security boundaries
    are derived from the design or implementation of the entities. It is important
    to understand the security boundaries built within or around them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Containers**: Containers are a basic component within a Kubernetes cluster.
    A container provides minimal isolation to the application using cgroups, Linux
    namespaces, AppArmor profiles, and a seccomp profile to the application running
    within the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pods**: A pod is a collection of one or more containers. Pods isolate more
    resources compared to containers, such as a network and IPC. Features such as
    security SecurityContext, NetworkPolicy, and PodSecurityPolicy work at the pod
    level to ensure a higher level of isolation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nodes**: Nodes in Kubernetes are also a security boundary. Pods can be specified
    to run on specific nodes using `nodeSelectors`. Kernels and hypervisors enforce
    security controls for pods running on the nodes. Features such as AppArmor and
    SELinux can help improve the security posture along with other host-hardening
    mechanisms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cluster**: A cluster is a collection of pods, containers, and the components
    on the master node and worker nodes. A cluster provides a strong security boundary.
    Pods and containers running within a cluster are isolated from other clusters
    at the network and the system layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Namespaces**: Namespaces are virtual clusters that isolate pods and services.
    The LimitRanger admission controller is applied at the namespace level to control
    resource utilization and denial-of-service attacks. Network policies can be applied
    to the namespace level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Kubernetes API server**: The Kubernetes API server interacts with all
    Kubernetes components, including `etcd`, `controller-manager`, and `kubelet`,
    which is used by cluster administrators to configure a cluster. It mediates communication
    with master components, so cluster administrators do not have to directly interact
    with cluster components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We discussed three different threat actors in [*Chapter 3*](B15566_03_Final_ASB_ePub.xhtml#_idTextAnchor091),
    *Threat Modeling*: privileged attackers, internal attackers, and end users. These
    threat actors may also interact with the preceding Kubernetes entities. We will
    see what the security boundaries from these entities an attacker is facing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**End user**: An end user interacts with either the ingress, exposed Kubernetes
    services, or directly to the open ports on the node. For the end user, nodes,
    Pods, `kube-apiserver`, and the external firewall protect the cluster components
    from being compromised.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal attacker**: Internal attackers have access to Pods and containers.
    Namespaces and access control enforced by `kube-apiserver` prevent these attackers
    from escalating privileges or compromising the cluster. Network policy and RBAC
    controls can prevent lateral movement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Privileged attacker**: `kube-apiserver` is the only security boundary that
    protects the master components from compromise by privileged attackers. If a privileged
    attacker compromises `kube-apiserver`, it''s game over.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we looked at security boundaries from a user perspective and
    showed you how security boundaries are built in the Kubernetes ecosystem. Next,
    let's look at the security boundaries in the system layer, from a microservice
    perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Security boundaries in the system layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices run inside Pods, where Pods are scheduled to run on worker nodes
    in a cluster. In the previous chapters, we already emphasized that a container
    is a process assigned with dedicated Linux namespaces. A container or Pod consumes
    all the necessary resources provided from the worker node. So, it is important
    to understand the security boundaries from the system's perspective and how to
    fortify it. In this section, we will talk about the security boundaries built
    upon Linux namespaces and Linux capabilities together for microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Linux namespaces as security boundaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linux namespaces are a feature of the Linux kernel to partition resources for
    isolation purposes. With namespaces assigned, a set of processes sees one set
    of resources while another set of processes sees another set of resources. We've
    already introduced Linux namespaces in [*Chapter 2*](B15566_02_Final_ASB_ePub.xhtml#_idTextAnchor049),
    *Kubernetes Networking*. By default, each Pod has its own network namespace and
    IPC namespace. Each container inside the same pod has its own PID namespace so
    that one container has no knowledge about other containers running inside the
    same Pod. Similarly, a Pod does not know other Pods exist in the same worker node.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, the default settings offer pretty good isolation for microservices
    from a security standpoint. However, the host namespace settings are allowed to
    be configured in the Kubernetes workload, and more specifically, in the Pod specification.
    With such settings enabled, the microservice uses host-level namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HostNetwork**: The Pod uses the host''s network namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HostIPC**: The Pod uses the host''s IPC namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HostPID**: The Pod uses the host''s PID namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**shareProcessNamespace**: The containers inside the same Pod will share a
    single PID namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you try to configure your workload to use host namespaces, do ask yourself
    the question: why do you have to do this? When using host namespaces, pods have
    full knowledge of other pods'' activities in the same worker node, but it also
    depends on what Linux capabilities are assigned to the container. Overall, the
    fact is, you''re disarming other microservices'' security boundaries. Let me give
    a quick example. This is a list of processes visible inside a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, inside the `nginx` container, only `nginx` processes and `bash`
    process are visible from the container. This `nginx` pod doesn''t use a host PID
    namespace. Let''s a look at what happens if a pod uses host PID namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output shows the processes running in the worker node from an
    `nginx` container. Among these processes are system processes, `sshd`, `kubelet`,
    `kube-proxy`, and so on. Besides from the Pod using the host PID namespace, you
    can send signals to other microservices' processes, such as `SIGKILL` to kill
    a process.
  prefs: []
  type: TYPE_NORMAL
- en: Linux capabilities as security boundaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Linux capabilities are a concept evolved from the traditional Linux permission
    check: privileged and unprivileged. Privileged processes bypass all kernel permission
    checks. Then, Linux divides privileges associated with Linux superusers into distinct
    units â€“ Linux capabilities. There are network-related capabilities, such as `CAP_NET_ADMIN`,
    `CAP_NET_BIND_SERVICE`, `CAP_NET_BROADCAST`, and `CAP_NET_RAW`. And there are
    audit-related capabilities: `CAP_AUDIT_CONTROL`, `CAP_AUDIT_READ`, and `CAP_AUDIT_WRITE`.
    Of course, there is still an admin-like capability: `CAP_SYS_ADMIN`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned in [*Chapter 4*](B15566_04_Final_ASB_ePub.xhtml#_idTextAnchor108),
    *Applying the Principle of Least Privilege in Kubernetes*, you can configure Linux
    capabilities for containers in a pod. By default, here is a list of capabilities
    that are assigned to containers in Kubernetes clusters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CAP_SETPCAP`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAP_MKNOD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAP_AUDIT_WRITE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAP_CHOWN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAP_NET_RAW`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAP_DAC_OVERRIDE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAP_FOWNER`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAP_FSETID`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAP_KILL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAP_SETGID`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAP_SETUID`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAP_NET_BIND_SERVICE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAP_SYS_CHROOT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAP_SETFCAP`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For most of the microservices, these capabilities should be good enough to
    perform their daily tasks. You should drop all the capabilities and only add the
    required ones. Similar to host namespaces, granting extra capabilities may disarm
    the security boundaries of other microservices. Here is an example output when
    you run the `tcpdump` command in a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output shows that inside a container, there is `tcpdump` listening
    on the network interface, `cali01fb9a4e4b4`, which was created for another pod's
    network communication. With a host network namespace and `CAP_NET_ADMIN` granted,
    you are able to sniff network traffic from the entire worker node inside a container.
    In general, the fewer capabilities granted to containers, the more secure the
    boundaries are for other microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up security boundaries in the system layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The dedicated Linux namespaces and the limited Linux capabilities assigned to
    a container or a Pod by default establish good security boundaries for microservices.
    However, users are still allowed to configure host namespaces or add extra Linux
    capabilities to a workload. This will disarm the security boundaries of other
    microservices running on the same worker node. You should be very careful of doing
    so. Usually, monitoring tools or security tools require access to host namespaces
    in order to do their monitoring job or detection job. And it is highly recommended
    to use `PodSecurityPolicy` to restrict the usage of host namespaces as well as
    extra capabilities so that the security boundaries of microservices are fortified.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's look at the security boundaries set up in the network layer, from
    a microservice's perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Security boundaries in the network layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Kubernetes network policy defines the rules for different groups of Pods that
    are allowed to communicate with each other. In the previous chapter, we briefly
    talked about the egress rule of a Kubernetes network policy, which can be leveraged
    to enforce the principle of least privilege for microservices. In this section,
    we will go through a little more on the Kubernetes network policy and will focus
    on the ingress rule. We will show how the ingress rules of network policies can
    help to establish the trust boundaries among microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Network policies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned in the previous chapter, as per the network model requirement,
    Pods inside a cluster can communicate with each other. But still, from a security
    perspective, you may want to restrict your microservice to being accessed by only
    a few services. How can we achieve that in Kubernetes? Let''s take a quick look
    at the following Kubernetes network policy example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `NetworkPolicy` policy is named `test-network-policy`. A few key attributes
    from the network policy specification worth mentioning are listed here to help
    you understand what the restrictions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`podSelector`: A grouping of Pods to which the policy applies based on the
    Pod labels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ingress`: Ingress rules that apply to the Pods specified in the top-level
    `podSelector`. The different elements under `Ingress` are discussed as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '- `ipBlock`: IP CIDR ranges that are allowed to communicate with ingress sources'
  prefs: []
  type: TYPE_NORMAL
- en: '- `namespaceSelector`: Namespaces that are allowed as ingress sources based
    on namespace labels'
  prefs: []
  type: TYPE_NORMAL
- en: '- `podSelector`: Pods that are allowed as ingress sources based on Pod labels'
  prefs: []
  type: TYPE_NORMAL
- en: '- `ports`: Ports and protocols that all pods should be allowed to communicate
    with'
  prefs: []
  type: TYPE_NORMAL
- en: '`egress`: Egress rules that apply to the Pods specified in the top-level `podSelector`.
    The different elements under `Ingress` are discussed as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '- `ipBlock`: IP CIDR ranges that are allowed to communicate as egress destinations'
  prefs: []
  type: TYPE_NORMAL
- en: '- `namespaceSelector`: Namespaces that are allowed as egress destinations based
    on namespace labels'
  prefs: []
  type: TYPE_NORMAL
- en: '- `podSelector`: Pods that are allowed as egress destination based on Pod labels'
  prefs: []
  type: TYPE_NORMAL
- en: '- `ports`: Destination ports and protocols that all Pods should be allowed
    to communicate with'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, `ipBlock` is used to specify the external IP block that microservices
    are allowed to interact with in the Kubernetes cluster, while the namespace selector
    and Pod selector are used to restrict network communications among microservices
    in the same Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'To strengthen the trust boundaries for microservices from a network aspect,
    you might want to either specify the allowed `ipBlock` from external or allowed
    microservices from a specific namespace. The following is another example to restrict
    the ingress source from certain Pods and namespaces by using `namespaceSelector`
    and `podSelector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there is no `-` in front of the `podSelector` attribute. This means
    the ingress source can only be pods with the label `from: good` in the namespace
    with the label `from: good`. This network policy protects Pods with the label
    `app: web` in the default namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 â€“ Network policy restricting incoming traffic by Pod and namespace
    labels'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15566_05_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 â€“ Network policy restricting incoming traffic by Pod and namespace
    labels
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, the `good` namespace has the label `from: good` while
    the `bad` namespace has the label `from: bad`. It illustrates that only Pods with
    the label `from: good` in the namespace with the label `from: good` can access
    the `nginx-web` service in the default namespace. Other Pods, no matter whether
    they''re from the `good` namespace but without the label `from: good` or from
    other namespaces, cannot access the `nginx-web` service in the default namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the importance of security boundaries. Understanding
    the security domains and security boundaries within the Kubernetes ecosystem helps
    administrators understand the blast radius of an attack and have mitigation strategies
    in place to limit the damage caused in the event of an attack. Knowing Kubernetes
    entities is the starting point of fortifying security boundaries. Knowing the
    security boundaries built into the system layer with Linux namespaces and capabilities
    is the next step. Last but not least, understanding the power of network policies
    is also critical to build security segmentation into microservices.
  prefs: []
  type: TYPE_NORMAL
- en: After this chapter, you should grasp the concept of the security domain and
    security boundaries. You should also know the security domains, common entities
    in Kubernetes, as well as the security boundaries built within or around Kubernetes
    entities. You should know the importance of using built-in security features such
    as PodSecurityPolicy and NetworkPolicy to fortify security boundaries and configure
    the security context of workloads carefully.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about how to secure Kubernetes components.
    In particular, there are some configuration details you should pay attention to.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the security domains in Kubernetes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the common Kubernetes entities you interact with?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you restrict a Kubernetes user to access objects in a specific namespace?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does enable hostPID mean to a pod?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to configure a network policy to protect your service that only allows specific
    Pods as ingress sources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes network policies: [https://kubernetes.io/docs/concepts/services-networking/network-policies/](https://kubernetes.io/docs/concepts/services-networking/network-policies/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CVE-2018-18264: [https://groups.google.com/forum/#!searchin/kubernetes-announce/CVE-2018-18264%7Csort:date/kubernetes-announce/yBrFf5nmvfI/gUO60KIlCAAJ](https://groups.google.com/forum/#!searchin/kubernetes-announce/CVE-2018-18264%7Csort:date/kubernetes-announce/yBrFf5nmvfI/gUO60KIlCAAJ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CVE-2018-1002105: [https://groups.google.com/forum/#!topic/kubernetes-announce/GVllWCg6L88](https://groups.google.com/forum/#!topic/kubernetes-announce/GVllWCg6L88)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
