- en: Chapter 5. Advanced Design Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers advanced design principles that every developer must know
    when designing RESTful services. It also provides pragmatic insights that give
    the developer enough information to build complex applications with REST API.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Rate-limiting patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Response pagination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalization and localization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST pluggability and extensibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional topics for REST API developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different snippets of code are included in the chapter, but the complete samples
    that show these snippets in action are included as part of the book's source code
    download bundle.
  prefs: []
  type: TYPE_NORMAL
- en: As we have done with the prior chapters, we'll attempt to cover the minimal
    level of detail required to empower the reader with a solid general understanding
    of inherently complex topics, while also providing enough of a technical drill-down
    so that the reader will be able to immediately get to work easily.
  prefs: []
  type: TYPE_NORMAL
- en: Rate-limiting patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rate limiting involves restricting the number of requests that can be made by
    a client. A client can be identified based on the access token it uses for the
    request as covered in [Chapter 3](ch03.html "Chapter 3. Security and Traceability"),
    *Security and Traceability*. Another way the client can be identified is the IP
    address of the client.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent abuse of the server, APIs must enforce throttling or rate-limiting
    techniques. Based on the client, the rate-limiting application can decide whether
    to allow the request to go through or not.
  prefs: []
  type: TYPE_NORMAL
- en: The server can decide what the natural rate limit per client should be, say
    for example, 500 requests per hour. The client makes a request to the server via
    an API call. The server checks if the request count is within the limit. If the
    request count is within the limit, the request goes through and the count is increased
    for the client. If the client request count exceeds the limit, the server can
    throw a 429 error.
  prefs: []
  type: TYPE_NORMAL
- en: The server can optionally include a `Retry-After` header, which indicates how
    long the client should wait before it can send the next request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every request from an application can be subjected to two different throttles:
    those with an access token and those without an access token. The quota of requests
    made by an application with an access token can vary from an application without
    an access token.'
  prefs: []
  type: TYPE_NORMAL
- en: Here are the details of the `HTTP 429 Too Many Requests` error code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**429 Too Many Requests (RFC 6585)**'
  prefs: []
  type: TYPE_NORMAL
- en: The user has sent too many requests in a given amount of time. This is intended
    for use with rate-limiting schemes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The response for a `429 Too Many Requests` error may include a `Retry-After`
    header, indicating how long the client needs to wait before making a new request.
    The following is an example code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example of an HTTP response sets a `Retry-After` header to 3600
    seconds to indicate when the client can retry later. Additionally, servers can
    send an `X-RateLimit-Remaining` header that can indicate how many requests are
    pending for this client.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some ideas on what rate limiting is and how the rate-limiting
    error and `Retry-After` and `X-RateLimit-Remaining` headers work, let's get down
    to code with JAX-RS.
  prefs: []
  type: TYPE_NORMAL
- en: The following code in the *The project's layout* section shows how to implement
    a simple rate-limiting filter in JAX-RS.
  prefs: []
  type: TYPE_NORMAL
- en: The project's layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The project's directory layout follows the standard Maven structure, which is
    briefly explained in the following table. This sample produces a WAR file, which
    can be deployed on any Java EE 7-compliant application server such as GlassFish
    4.0.
  prefs: []
  type: TYPE_NORMAL
- en: This sample demonstrates a simple coffee shop service where clients can query
    for a particular order they placed.
  prefs: []
  type: TYPE_NORMAL
- en: '| Source code | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `src/main/java` | This directory contains all the sources required by the
    coffee shop application |'
  prefs: []
  type: TYPE_TB
- en: 'The `CoffeeResource` class is a simple JAX-RS resource, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The project has a `CoffeeResource` class that is used to get details about the
    coffee orders. The `getCoffee` method returns a `Coffee` object that contains
    the details of the order.
  prefs: []
  type: TYPE_NORMAL
- en: To enforce rate limiting, we will add a `RateLimiter` class that is a simple
    servlet filter as shown in the following diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RateLimiter` class will check the IP address of the client and check if
    the number of requests that are made by the client exceeds the limit or not. The
    following diagram depicts the rate-limiting functionality covered by the sample
    in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The project''s layout](img/7963OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows a client making a `GET` request to [http://api.com/foo](http://api.com/foo).
    The **Rate Limit Filter** checks the access count of the client based on the IP
    address. As the client does not exceed the rate limit, the request is forwarded
    to the server. The server can return a JSON or XML or a text response.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram shows the client making a `GET` request to [http://api.com/foo](http://api.com/foo).
    The **Rate Limit Filter** checks the access count of the client based on the IP
    address. Since the client exceeds the rate limit, the request is not forwarded
    to the server, and the Rate Limiter returns an error code of `429 Too Many Requests`
    in the HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: '![The project''s layout](img/7963OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A detailed look at the rate-limiting sample
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement a rate limiter with JAX-RS, we need to implement a `Filter` class.
    This is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet shows an implementation of the `WebFilter` interface of
    the `javax.servlet.annotation` package. The `@WebFilter` annotation indicates
    that this class is a filter for the application.
  prefs: []
  type: TYPE_NORMAL
- en: The `@WebFilter` annotation must have at least one `urlPatterns` or `value`
    attribute in the annotation.
  prefs: []
  type: TYPE_NORMAL
- en: The `REQ_LIMIT` constant stands for the number of requests that can be made
    in a time period. The `TIME_LIMIT` constant stands for the time duration for the
    rate limit after which new requests from a client can be accepted.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, we have smaller limit values in the samples. In real-world scenarios,
    the limits could be, for example, 60 requests per minute or 1,000 requests per
    day. If the request count reaches the limit, the `Retry-After` header will indicate
    the time for which the client will have to wait before the server can process
    the next request.
  prefs: []
  type: TYPE_NORMAL
- en: To keep track of the request count associated with a client, we have created
    a class called `AccessCounter`. Here is the code for the `AccessCounter` class.
    The `AccessCounter` class is a `Singleton` class annotated with `@Singleton`.
    It stores a `ConcurrentHashMap` class that contains IP addresses as the keys and
    data related to the client, known as `AccessData`, as values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AccessData` class is responsible for storing the details for a client,
    such as the number of requests and when the last request was made. It is a simple
    **Plain Old Java Object** (**POJO**), as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding snippet, the `AccessData` class has a field called
    `count` and a field called `lastUpdated`. Whenever a new request arrives, the
    count is incremented, and the `lastUpdated` field is set to the current time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `doFilter()` method of the `RateLimiter` class is used in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows the `doFilter()` method of the `javax.servlet.Filter`
    class, which is overridden in the `RateLimiter` implementation. In this method,
    the IP address of the client is first determined.
  prefs: []
  type: TYPE_NORMAL
- en: If the `accessCounter` class contains the IP address, a check is made to see
    if the request limit has exceeded in the `requestLimitExceeded()` method.
  prefs: []
  type: TYPE_NORMAL
- en: If the rate limit has exceeded, then the `Retry-After` headers are sent in the
    `httpServletResponse` along with a `429 Too Many Requests` error. If there is
    a new request that comes from the same client after some time, and it is greater
    than the `TIME_LIMIT` value, then the counter is reset back to 0, and the request
    from the client can be processed again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the headers for rate limiting that can be sent back in the
    response to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '`X-RateLimit-Limit`: The maximum number of requests that the client can make
    during a specific time period'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-RateLimit-Remaining`: The number of requests remaining in the current rate-limit
    window'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A detailed sample is included with this book. After the sample is deployed on
    an application server, the client can make multiple requests to get order details
    for coffees.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of simplicity, we have enforced the rate limit as 3 and the time
    limit as 10 minutes. The following is a sample `curl` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the rate limit has been crossed, you will see a `429` error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This sample showed how to build your custom filters to implement rate limiting.
    Another option is to use an open source project called **Repose**, which is a
    scalable and extensive rate-limiting implementation. Repose is an open source
    HTTP proxy service that provides rate-limiting, client-authentication, versioning,
    and so on. For more details, check [http://openrepose.org/](http://openrepose.org/).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss the best practices that must be followed
    to avoid reaching rate limits when consuming a REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices to avoid reaching the rate limits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are the best practices that can be followed to avoid reaching rate limits
    when consuming a REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Caching API responses on the server side can help avoid reaching the rate limits.
    Setting reasonable expiry time intervals ensures the database is not thrashed
    with queries, and responses can be sent from the cache if the resource has not
    changed. For example, an application that displays tweets fetched from Twitter
    can cache the response from the Twitter API or use the Twitter Streaming API (covered
    in the following section). Ideally, API consumers should not make identical requests
    more than once a minute. This is generally a waste of bandwidth, as in most cases
    the exact same result will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Not making calls in loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a good practice to not make API requests inside loops. The server API
    should be designed to be as verbose as possible and help the clients by sending
    as much detail as possible in the response. This ensures the consumers can fetch
    a collection of objects in one API operation instead of fetching individual objects
    inside a loop.
  prefs: []
  type: TYPE_NORMAL
- en: Logging requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a good practice to use logging on the client side to see how many requests
    the client is making. Observing the logs will help the clients analyze as to which
    are the non-redundant queries that add to the rate limits and can be eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding polling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Additionally, consumers should not poll for changes. Instead of polling to see
    if the content has changed, the client can use WebHooks ([http://en.wikipedia.org/wiki/Webhook](http://en.wikipedia.org/wiki/Webhook))
    or Push Notifications ([http://en.wikipedia.org/wiki/Push_technology](http://en.wikipedia.org/wiki/Push_technology))
    to receive a notification. More details on WebHooks will be given in [Chapter
    6](ch06.html "Chapter 6. Emerging Standards and the Future of REST"), *Emerging
    Standards and the Future of REST*.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting the streaming API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: API developers can support a streaming API. This can help the client avoid reaching
    the rate limits. The set of streaming APIs offered by Twitter gives developers
    low latency access to Twitter's global stream of tweet data. A streaming client
    does not need to bear the overhead, associated with polling a REST endpoint and
    will get messages indicating tweets and other events that have occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Once applications establish a connection to a streaming endpoint, they are delivered
    a feed of tweets, without worrying about polling or REST API rate limits.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Case study of Twitter REST API rate limits**'
  prefs: []
  type: TYPE_NORMAL
- en: Twitter has a rate limit of 150 requests per hour per unauthenticated client.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth calls are permitted 350 requests per hour based on the access token in
    the request.
  prefs: []
  type: TYPE_NORMAL
- en: An application that exceeds the rate limitations of the Search API will receive
    an HTTP 420 response code. The best practice is to watch for this error condition
    and honor the Retry-After header that is returned. The Retry-After header's value
    is the number of seconds the client application should wait before requesting
    data from the Search API again. In case the client sends more than the allowed
    requests per hour, the client gets a 420 Enhance Your Calm error.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**420 Enhance Your Calm (Twitter)**'
  prefs: []
  type: TYPE_NORMAL
- en: This is not part of the HTTP standard but returned by the Twitter Search and
    Trends API when the client is being rate-limited. Applications should ideally
    implement the `429 Too Many Requests` response code instead.
  prefs: []
  type: TYPE_NORMAL
- en: Response pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST APIs are consumed by other systems from web to mobile clients and hence,
    responses that return multiple items should be paged with a certain number of
    items per page. This is known as Response pagination. Along with the response,
    it is always good to add some additional metadata about the total count of objects,
    the total number of pages, and the links that refer to the next set of results.
    The consumers can specify a page index to query for results and the number of
    results per page.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing and documenting default settings for the number of results per
    page is a recommended practice in case the client does not specify the number
    of results per page. For example, GitHub's REST API sets the default page size
    to 30 records with a maximum of 100, and sets a rate limit on the number of times
    the client can query the API. If the API has a default page size, then the query
    string can just specify the page index.
  prefs: []
  type: TYPE_NORMAL
- en: The following section covers the different types of pagination techniques that
    can be used. API developers may choose to implement one or more of these techniques
    based on their use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Types of pagination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the different techniques of pagination that can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: Offset-based pagination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time-based pagination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cursor-based pagination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offset-based pagination
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Offset-based pagination is the case when the client wants results specified
    by a page number and the number of results per page. For example, if a client
    wants to query all the details of books checked out, or the coffees ordered, they
    can send in a query request as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table details what query parameters the offset-based pagination
    would include:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Query parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `page` | This specifies which page to return |'
  prefs: []
  type: TYPE_TB
- en: '| `limit` | This specifies the number of maximum results per page that can
    be included in the response |'
  prefs: []
  type: TYPE_TB
- en: Time-based pagination
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The time-based pagination technique will be used when the client wants to query
    for a set of results between a specific timeframe.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to get a list of coffees ordered between a specific timeframe,
    a client can send in a query as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table details what query parameters a time-based pagination would
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Query parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `until:` | This is a Unix timestamp that points to the end of the time range
    |'
  prefs: []
  type: TYPE_TB
- en: '| `since` | This is a Unix timestamp that points to the beginning of the time
    range |'
  prefs: []
  type: TYPE_TB
- en: '| `limit` | This specifies the number of max results per page that can be included
    in the response |'
  prefs: []
  type: TYPE_TB
- en: Cursor-based pagination
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The cursor-based pagination is a technique where the results are separated into
    pages by a cursor, and the results can be navigated forwards and backwards using
    the next and previous cursors that are provided in the response.
  prefs: []
  type: TYPE_NORMAL
- en: The cursor-based pagination API avoids returning duplicate records in cases
    where additional resources are added between pagination requests. This is because
    the cursor parameter is a pointer that indicates where to resume the results from,
    for the subsequent call.
  prefs: []
  type: TYPE_NORMAL
- en: Twitter and cursor-based pagination
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is an example of how Twitter uses cursor-based pagination. A query to
    get the IDs of a user who has a large number of followers could be paginated and
    returned in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `next_cursor` value could be passed to the next query to get the next set
    of results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Using the `next_cursor` and the `previous_cursor` values, it is easy to navigate
    between the set of results.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the different pagination techniques, let's go over
    a sample in detail. The following sample shows how to implement a simple offset-based
    pagination technique with JAX-RS.
  prefs: []
  type: TYPE_NORMAL
- en: The project's layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The project's directory layout follows the standard Maven structure, which is
    briefly explained in the following table.
  prefs: []
  type: TYPE_NORMAL
- en: The example used is that of a coffee shop service that can be queried for all
    orders placed so far.
  prefs: []
  type: TYPE_NORMAL
- en: '| Source code | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `src/main/java` | This directory contains all the sources required by the
    coffee shop application |'
  prefs: []
  type: TYPE_TB
- en: 'Here is the `CoffeeResource` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getCoffeeList()` method takes two `QueryParam` values: `page` and `limit`.
    The `page QueryParam` value corresponds to the page index and `limit` corresponds
    to the number of results per page. The `@DefaultValue` annotation specifies the
    default values that can be used if the query parameters are absent.'
  prefs: []
  type: TYPE_NORMAL
- en: Here is the output when the sample is run. The `metadata` element contains details
    of the `totalCount` value that is the total number of records. Additionally, there
    is the `links` attribute of `JSONArray` that contains details such as `self,`
    which is the current page, and `next`, which is the next link to fetch more results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The sample is bundled with this book's downloadable source code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is always a good practice to include the default values for the number of
    results per page in REST API for pagination. Also, it is recommended that the
    API developers add metadata on the response, so consumers of the API can fetch
    additional information easily to get the next set of results.
  prefs: []
  type: TYPE_NORMAL
- en: Internationalization and localization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, services need to operate in a global environment and responses need
    to be tailored based on the country and locale. Localization parameters can be
    specified in one of the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content of the REST response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Language negotiation is similar to content negotiation; the HTTP header `Accept-Language`
    can take different language codes based on any two-letter initial for ISO-3166
    country codes ([http://www.iso.org/iso/country_codes.htm)](http://www.iso.org/iso/country_codes.htm)).
    The `Content-Language` header is similar to the `Content-Type` header and can
    specify the language for the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is a `Content-Language` header sent in the response to a
    request sent by a client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding response sets `Content-Language` to `en` as part of the response.
  prefs: []
  type: TYPE_NORMAL
- en: JAX-RS supports runtime content negotiation using the `javax.ws.rs.core.Variant`
    class and `Request` objects. The `Variant` class may contain a media type, a language,
    and an encoding. The `Variant.VariantListBuilder` class is used to build a list
    of representation variants.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how to create a list of resource representation
    variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet calls the build method of the `VariantListBuilder`
    class with languages `"en"` and `"fr"`.
  prefs: []
  type: TYPE_NORMAL
- en: Query parameters can include locale-specific information so that the server
    can return the information in that language.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This query shows an example that will include the locale in the query parameter
    to get details of books. Additionally, the content of the REST response can contain
    country-specific details such as currency codes, and other details based on the
    HTTP headers or the query parameters sent in the request.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following sections cover some details on miscellaneous topics such as HATEOAS,
    and Extensibility in REST.
  prefs: []
  type: TYPE_NORMAL
- en: HATEOAS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Hypermedia as the Engine of Application State** (**HATEOAS**) is a constraint
    of the REST application architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: A hypermedia-driven API gives details about the APIs that are available and
    the corresponding actions that can be taken by the consumer, by providing hypermedia
    links in the response sent by the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a book representation for a REST resource that contains data such
    as the name and ISBN would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A HATEOAS implementation would return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding sample, the `links` element has the `rel` and `href` JSON objects.
  prefs: []
  type: TYPE_NORMAL
- en: The `rel` attribute in this example is a self-referencing hyperlink. More complex
    systems might include other relationships. For example, a book order might have
    a `"rel":"customer"` relationship, linking the book order to its customer. `href`
    is a complete URL that uniquely defines the resource.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of HATEOAS is that it helps client developers explore the protocol.
    The links give client developers a hint as to what may be the possible next action
    to take. While there is no standard for hypermedia controls, the recommendations
    are to follow the ATOM RFC (4287).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: According to the Richardson Maturity Model, HATEOAS is considered the final
    level of REST. This means that each link is presumed to implement the standard
    REST verbs of `GET`, `POST`, `PUT`, and `DELETE`. Adding details using the `links`
    element as shown in the preceding code snippet gives the client the information
    they need to navigate the service and take the next action.
  prefs: []
  type: TYPE_NORMAL
- en: The PayPal REST API and HATEOAS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PayPal REST API provides HATEOAS support, so with every response, there is a
    collection of links that can help the consumer decide the next action to take.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a sample response from the PayPal REST API includes the JSON objects
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A brief description of the attributes is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`href`: This contains information about URLs that can be used for future REST
    API calls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rel`: This link shows how it is related to the previous REST API calls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`method`: This shows which method is to be used for the REST API calls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more details, check [https://developer.paypal.com/docs/integration/direct/paypal-rest-payment-hateoas-links/](https://developer.paypal.com/docs/integration/direct/paypal-rest-payment-hateoas-links/).
  prefs: []
  type: TYPE_NORMAL
- en: REST and extensibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RESTful applications are more extensible as well as more maintainable over time.
    RESTful applications based on constraints of the design style are easier to understand
    and work with, mainly due to their simplicity. They are also more predictable,
    since it's all about the resources. Also, RESTful applications are easier to work
    with as opposed to an XML-RPC application, where the consumer needs to parse a
    complex WSDL document to even begin to understand what's happening.
  prefs: []
  type: TYPE_NORMAL
- en: Additional topics for the REST API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following section lists additional topics that may be useful for REST developers.
    We have covered topics in earlier chapters, from the designing of RESTful services,
    error handling, validations, authentication, and caching to rate limiting. This
    section focuses on additional utilities to empower the REST API developer with
    better testing and documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Testing RESTful services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is always efficient to have an automated set of tests, which can validate
    responses sent by the server. One such framework to build automated tests for
    RESTful services is REST Assured.
  prefs: []
  type: TYPE_NORMAL
- en: REST Assured is the Java DSL for easy testing of RESTful services. It supports
    `GET`, `PUT`, `POST`, `HEAD`, `OPTIONS`, and `PATCH`, and can be used to validate
    as well as verify responses that the server sends.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of getting a coffee order and verifying the ID
    returned in the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we make a call to get a coffee order and verify that
    the `coffee.id` value is 5.
  prefs: []
  type: TYPE_NORMAL
- en: REST Assured supports specifying and validating, for example, parameters, headers,
    cookies, and body easily. It also supports mapping Java objects to and from JSON
    and XML. For more details, you can check [https://code.google.com/p/rest-assured/](https://code.google.com/p/rest-assured/).
  prefs: []
  type: TYPE_NORMAL
- en: Documenting RESTful services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is always a good practice to provide documentation on the RESTful services
    built for the consumers, whether they are from within the same enterprise or whether
    the consumer is an external application or a mobile client. The following section
    covers some frameworks for providing good documentation for RESTful services.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger is a framework implementation for describing, producing, consuming,
    and visualizing RESTful web services. The documentation of methods, parameters,
    and models are tightly integrated into the server code. Swagger is language-agnostic
    and implementations for Scala, Java, and HTML5 are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tutorial on how to add Swagger to the REST API is found at the following
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/wordnik/swagger-core/wiki/Adding-Swagger-to-your-API](https://github.com/wordnik/swagger-core/wiki/Adding-Swagger-to-your-API)'
  prefs: []
  type: TYPE_NORMAL
- en: Recommended reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following links refer to some of the topics that are covered in this chapter,
    and they will be useful to review and get detailed information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://dev.twitter.com/docs](https://dev.twitter.com/docs): The Twitter API
    documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://dev.twitter.com/console](https://dev.twitter.com/console): The Twitter
    Developer console'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://dev.twitter.com/docs/rate-limiting/1.1](https://dev.twitter.com/docs/rate-limiting/1.1):
    The Twitter API rate limiting in v1.1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://dev.twitter.com/docs/misc/cursoring](https://dev.twitter.com/docs/misc/cursoring):
    The Twitter API and cursoring'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://dev.twitter.com/docs/api/streaming](https://dev.twitter.com/docs/api/streaming):
    The Twitter streaming APIs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developers.facebook.com/docs/reference/ads-api/api-rate-limiting/](https://developers.facebook.com/docs/reference/ads-api/api-rate-limiting/):
    Facebook API rate limiting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.github.com/v3/rate_limit/](https://developer.github.com/v3/rate_limit/):
    GitHub API rate limiting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developers.facebook.com/docs/opengraph/guides/internationalization/](https://developers.facebook.com/docs/opengraph/guides/internationalization/):
    Facebook localization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered advanced topics that every RESTful API developer should
    know. In the beginning, we saw the rate-limiting sample that demonstrated how
    to enforce throttling so that the server is not blasted with API calls. We also
    saw how Twitter, GitHub, and Facebook APIs enforce rate limiting. We covered different
    pagination techniques and a basic pagination sample and best practices. Then,
    we moved on to internationalization and other miscellaneous topics. Finally, we
    covered HATEOAS and how it is the next level of REST API, REST, and extensibility
    topics.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover other emerging standards such as WebSockets, WebHooks,
    and the role of REST in the future of evolving web standards.
  prefs: []
  type: TYPE_NORMAL
