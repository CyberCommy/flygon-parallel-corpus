- en: Creating Our App Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to *Progressive Web Apps with React*!
  prefs: []
  type: TYPE_NORMAL
- en: This book will take you through the entire process of building a React application
    that also functions as a Progressive Web App. We'll cover not only the "how" of
    constructing such an application, but also highlight best practices and how to
    measure your application to ensure successful implementation of PWA features.
  prefs: []
  type: TYPE_NORMAL
- en: Progressive Web Apps are poised to become the future of web applications. They
    promise a bevy of additional functionality, such as push notifications and the
    ability to be installed, which pushes them into the realm of native iOS or Android
    apps. Additionally, a strong focus on performance (taking advantage of cutting-edge
    web technology) means that PWAs create apps that are fast for everyone.
  prefs: []
  type: TYPE_NORMAL
- en: We'll cover each facet of PWAs in depth, as well as the process of converting
    a regular web application into a progressive one. We'll also dive deep into React
    best practices, using libraries such as React Router.
  prefs: []
  type: TYPE_NORMAL
- en: To check your code for this and future chapters, you can view the completed
    project at [https://github.com/scottdomes/chatastrophe/](https://github.com/scottdomes/chatastrophe/).
    The repository includes branches for each chapter. Visit [https://github.com/scottdomes/chatastrophe/tree/chapter1](https://github.com/scottdomes/chatastrophe/tree/chapter1)
    for this chapter's final code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will get started with the basic structure of our application.
    Here''s what we''ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: The use cases of Progressive Web Apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic user stories we want our app to fulfill
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The project structure and basic HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, let's set the scene for our application's journey.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of your friends calls you on the phone, bursting with excitement about his
    latest start-up idea (you know the one). You patiently listen to his description,
    but respectfully decline to be a part of it. He's disappointed, but understands
    and promises to keep you updated on the project details. You murmur your assent.
  prefs: []
  type: TYPE_NORMAL
- en: A few months later, he meets you at your work and announces that he has found
    a group of serious investors, and he needs you to help him build the software
    he promised them. You again decline, but when discussing compensation, he mentions
    a number that you can't refuse. A week later, you're on a plane to San Francisco.
  prefs: []
  type: TYPE_NORMAL
- en: In front of the investors (who are, to your surprise, a rapt audience), your
    friend guides you through the basics of the application. In between the buzzwords
    ("mass interconnection" and "global community"), you gather just enough to summarize
    the application in a sentence.
  prefs: []
  type: TYPE_NORMAL
- en: '"So, it''s a chat room… for everyone in the world… all at once…"'
  prefs: []
  type: TYPE_NORMAL
- en: Your friend smiles. "Yes."
  prefs: []
  type: TYPE_NORMAL
- en: You're bewildered by the image of a million strangers all talking at once on
    the same application, in the same room, but the investors break into applause.
    As you head for the door, your friend again announces how they'd like to compensate
    you… citing an even higher number than before. You sit down.
  prefs: []
  type: TYPE_NORMAL
- en: The problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"The problem," your friend explains, "is that this chat room has to be for
    everyone."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Global community," you say with a knowing nod.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Exactly. Everyone. Even if they have terrible internet in some hut in the
    desert. They should be included."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Mass interconnection," you add.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Exactly! So it needs to be fast. And lightweight. And beautiful. And dynamic."'
  prefs: []
  type: TYPE_NORMAL
- en: '"So everyone will be talking at once? Won’t that be-"'
  prefs: []
  type: TYPE_NORMAL
- en: '"A worldwide collective, yes."'
  prefs: []
  type: TYPE_NORMAL
- en: The other problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"The other problem," your friend declares, "is that our users will mostly be
    on their phones. On the go."'
  prefs: []
  type: TYPE_NORMAL
- en: '"So you want to do an iOS and Android app?"'
  prefs: []
  type: TYPE_NORMAL
- en: Your friend waves his hand. "No, no. No one downloads apps anymore. Especially
    in developing countries; that takes too much bandwidth. Remember, worldwide collective."
  prefs: []
  type: TYPE_NORMAL
- en: '"So a web app."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Yes. A web collective."'
  prefs: []
  type: TYPE_NORMAL
- en: Despite your best instincts, the project intrigues you. How do you craft a web
    application to be as fast as possible? How do you make it work under all network
    conditions? How do you make a chat application with all the conveniences of a
    native app, but for the web?
  prefs: []
  type: TYPE_NORMAL
- en: You sigh and shake his hand. "Let's get to work."
  prefs: []
  type: TYPE_NORMAL
- en: Beginning work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the world of Progressive Web Applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding scenario, the problems your friend was describing are exactly
    the problems **PWAs** (**Progressive Web Applications**) are crafted to solve.
  prefs: []
  type: TYPE_NORMAL
- en: The first problem is that many users will be visiting your web page under poor
    network conditions. They may be a Silicon Valley technocrat on their iPhone in
    a coffee shop with bad WiFi, or they may be a Bangladeshi villager in a remote
    location. Either way, they will not stick around if your site isn't optimized
    for them, for everyone.
  prefs: []
  type: TYPE_NORMAL
- en: How fast your application loads--its performance--thus becomes an accessibility
    concern. PWAs solve this by loading quickly the first time, and even more quickly
    every time after that. We'll talk more about how they do so as the book progresses.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the installation process for mobile apps is an obstacle for users. It
    means that your users need to be extra committed to engaging with your application--enough
    to give up storage space and time, and expose themselves to the possibility of
    malicious and intrusive code, and that's before they even get the chance to try
    the app!
  prefs: []
  type: TYPE_NORMAL
- en: What if we can provide the native app experience without the initial investment?
    PWAs are an attempt to bridge that gap. Again, we'll talk in subsequent chapters
    about how they do so, and how successful they actually are. However, these are
    both worthy challenges, and solving both will be a huge user experience win for
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: Why Progressive Web Apps?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many static web pages do a fantastic job of performance. However, when all you
    need to do is render some HTML, CSS, and a smattering of JavaScript, it's less
    of a struggle to work well under all network conditions.
  prefs: []
  type: TYPE_NORMAL
- en: When we start talking about web applications--large, complex, JavaScript-based
    workhorses--performance becomes a significant challenge. Our frontend will have
    a lot of code. Our user needs to download all that code if they want to use our
    app to its fullest potential. How do we ensure that they're not staring at a blank
    loading screen for ten seconds, as 500 KB of JavaScript initializes?
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, most of our performance enhancements will center around managing
    the JavaScript problem. This is especially true with React.
  prefs: []
  type: TYPE_NORMAL
- en: Why React?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**React** is quickly becoming the go-to solution for frontend web applications.
    Why? This is because it''s fast, elegant, and makes managing large applications
    easy.'
  prefs: []
  type: TYPE_NORMAL
- en: In other words, it makes complexity simple. There's no reason a PWA has to use
    React, though. PWAs can be any web app or site.
  prefs: []
  type: TYPE_NORMAL
- en: React does have one major benefit--its component pattern, where UIs are split
    into distinct pieces. As we'll see, the component pattern lets us break our interface
    into small chunks of code to alleviate the preceding JavaScript downloading issue.
    However, other than that, any frontend framework will work just as well for a
    PWA.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of React is that it is a beautiful and fun way to build frontend
    applications. It's also an in-demand skill. If you pair knowledge of React with
    experience with PWAs, you'll be about as future-ready as one can be in the fast-moving
    web development world.
  prefs: []
  type: TYPE_NORMAL
- en: A rose by any other name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You tell your friend about your learnings on PWAs and React, but before you
    finish, he waves his hand and interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: '"Yeah, yeah. Hey, what do you think the name should be?"'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, you're struck with the unnerving feeling that all of this was a
    mistake, that you never should have jumped on board this questionable venture,
    this potential catastrophe.
  prefs: []
  type: TYPE_NORMAL
- en: '"Chatastrophe," you blurt out.'
  prefs: []
  type: TYPE_NORMAL
- en: Your friend smiles and claps you on the back. "Brilliant. Okay, get Reacting
    or whatever!"
  prefs: []
  type: TYPE_NORMAL
- en: User stories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin building our app, let's take a deeper look at what exactly we
    want to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: We can start with user stories. A user story is a description of a specific
    feature of an application, framed from the perspective of one of our users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the framework, as suggested by *Jon Dobrowolski*:'
  prefs: []
  type: TYPE_NORMAL
- en: Users should be able to _____.
  prefs: []
  type: TYPE_NORMAL
- en: As a user, I want to do ___ because ____.
  prefs: []
  type: TYPE_NORMAL
- en: Given that I'm doing ___, I should be able to ___ in order to ___.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all features require the whole framework, though. Let''s start with some
    basic examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Users should be able to log in and out of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pretty straightforward. I don't think we need to add the justification for this,
    as it is a fairly basic feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to something more advanced:'
  prefs: []
  type: TYPE_NORMAL
- en: Users should be able to view their messages even when offline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I want to be able to check my messages without needing an internet
    connection, because I may need to read them on the go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given that I start the application without internet access, I should be able
    to view all past messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's cover some of the more basic functionality of the app. Users should be
    able to send and receive messages in real-time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Real-time functionality will be key to our application. There''s no point in
    having chat unless it''s fast and fluid:'
  prefs: []
  type: TYPE_NORMAL
- en: Users should be able to view all messages by a given author
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I want to be able to view a list of all messages sent by a given
    user, because I may need to view their contribution to the conversation without
    the noise of others' messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given that I click on a user's email, I should be taken to a profile view with
    all their messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The profile view is a special feature you suggested to the client to manage
    the inevitable chaos of the main chat room.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a couple more PWA-specific user stories:'
  prefs: []
  type: TYPE_NORMAL
- en: Users should receive push notifications when a message is sent by another user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I want to be constantly updated on the progress of the conversation,
    because I don't want to miss anything important
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given that the chat is not open or visible on my screen, I should receive notifications
    for each message sent by another user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And installing:'
  prefs: []
  type: TYPE_NORMAL
- en: Users should be able to install the app on their mobile device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I want to be able to open the application without navigating to the
    URL in my browser, because I want easy access to the chat room
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given that I have signed up to the chat for the first time, I should be prompted
    to install the app on my device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't worry about how we will achieve these goals; we'll cover that in due time.
    For now, let's just continue documenting what we want to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our client was big on performance, so let''s specify some performance-specific
    goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Users should be able to load the app in under 5 seconds, even under shaky network
    conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I want to be able to interact with the app as quickly as possible,
    because I don't want to be stuck waiting for it to load
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given that I have opened the application using a poor internet connection, I
    should still have it load in under 5 seconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load in under 5 seconds is still a bit vague in terms of what that means for
    our application. We'll revisit this story in more depth in the chapters on performance.
  prefs: []
  type: TYPE_NORMAL
- en: The previously mentioned user stories cover the basic functionality of our app.
    Let's talk about the specific challenges these points present.
  prefs: []
  type: TYPE_NORMAL
- en: Application challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With each of the following, I encourage you to think about how you will solve
    these problems within the context of a web application. Hopefully, this will give
    you a better insight into what we try to achieve with PWAs, and the difficulties
    we face.
  prefs: []
  type: TYPE_NORMAL
- en: Instant loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Progressive Web Apps, we aim to provide an experience that is closer to
    a native app (one downloaded from the Apple App Store, Google Play Store, or another
    app store) than your typical web application. One of the advantages native apps
    have, of course, is that all relevant files are predownloaded and installed, while
    each time a user visits a web application, they may have to download all the assets
    again.
  prefs: []
  type: TYPE_NORMAL
- en: The solution? When the user first visits the page, download those assets and
    then save them for later (also known as caching). Then, when the user reopens
    the application, instead of downloading the files again over the internet (slow),
    we simply retrieve them from the user's device (fast).
  prefs: []
  type: TYPE_NORMAL
- en: However, this only works for when the user revisits the application. For the
    initial visit, we still have to download everything. This situation is particularly
    precarious, because when the user first visits Chatastrophe, they're not yet sold
    on its value, and so, are likely to leave (for good) if loading takes too long.
  prefs: []
  type: TYPE_NORMAL
- en: We need to ensure that our assets are as optimized as possible, and we download
    as little as possible on that first visit, so that the user stays around.
  prefs: []
  type: TYPE_NORMAL
- en: In short, fast loading for the first visit, near-instant loading for every subsequent
    visit.
  prefs: []
  type: TYPE_NORMAL
- en: Push notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's no point in a chat application without notifications! Again, we're trying
    to emulate what has traditionally been a native app feature--push notifications
    directly to the user's device.
  prefs: []
  type: TYPE_NORMAL
- en: This problem is trickier than it might seem. Push notifications are only received
    when the app isn't open (that's the whole point, after all). So, if our web application
    isn't open and running, how can we possibly run the code to display a notification?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is to use a third-party service that is engineered to send notifications
    to registered devices. So, rather than the device receiving the message alerting
    its user, the device sending the message alerts our notification service, which
    then notifies all relevant devices.
  prefs: []
  type: TYPE_NORMAL
- en: We also need a piece of code that is constantly "on"--always running and waiting
    to receive notifications from the third-party service and display them. This challenge
    only recently became solvable with web technology, and is one of the reasons PWAs
    are so exciting.
  prefs: []
  type: TYPE_NORMAL
- en: For now, don’t worry if this distinction doesn't "click" yet. We'll go into
    it in greater detail later. For now, the point is that push notifications will
    be an interesting challenge for our web application.
  prefs: []
  type: TYPE_NORMAL
- en: Offline access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even when our user isn't connected to the internet, they should be able to check
    past messages and navigate around our application.
  prefs: []
  type: TYPE_NORMAL
- en: The answer turns out to go hand-in-hand with the earlier discussion on instant
    loading. We simply need to cache everything our app needs to function, and then
    load that on demand; simply, of course, being the operative word.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile-first design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For years, the big buzzword of web design has been responsive--websites that
    look just as good when scaled from desktop to mobile size.
  prefs: []
  type: TYPE_NORMAL
- en: PWAs are, in essence, responsive design on steroids, expanding design for mobile
    to every aspect of the app, from appearance to functionality.
  prefs: []
  type: TYPE_NORMAL
- en: However, at the end of the day, we need to ensure that our app looks great on
    every screen size. It also needs to look good under the restrictions we've already
    discussed. We can't rely too much on big background images or intense graphics.
    We need a simple and good-looking UI, engineered for both looks and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Progressive enhancement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bottleneck of performance with any React application is downloading and
    running the JavaScript. Our entire application code will be contained in JavaScript
    files--and our app won't work until those are executed. That means our users may
    be stuck staring at a white screen (with zero functionality) until that JavaScript
    is ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: '**Progressive enhancement** is a technique that aims to fix that problem. In
    essence, it means that a user''s experience should get progressively better as
    the application downloads, depending on the user''s browser. In other words, the
    application experience improves as time goes on (and more of the application downloads),
    and as a user''s software improves.'
  prefs: []
  type: TYPE_NORMAL
- en: A user with the most modern browser, the fastest internet connection, and the
    application fully downloaded will have the best experience, but a user with an
    outdated browser, a shaky connection, and who just landed on the page will also
    have a quality experience.
  prefs: []
  type: TYPE_NORMAL
- en: This means our `React.js` application needs to have some functionality without
    any JavaScript. This is a fun challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Think of our UX as a series of layers, from good to fantastic, that we build
    up as time goes on.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get going
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope the preceding overview has given you a specific idea of what we're trying
    to accomplish with this application, and also the roadblocks to achieving those
    aims. There are a lot of challenges, but as we work through our user stories,
    we'll deal with them one by one, until we have a fast and functional Progressive
    Web App.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the challenges mentioned, you can see the general trend: good performance
    and user experience under any condition. Certainly a worthy goal, and exactly
    why PWA techniques are applicable to any web app; they simply promise a better
    experience for everyone.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we start building our application, we'll also see that solving these problems
    is still a challenge, but all very achievable with React.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to get everything set up for our application, and create our
    basic folder structure with HTML and CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Our app skeleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First things first. Before we start building our React application, let''s
    get set up with the basic HTML and CSS--the skeleton of our application, if you
    will, upon which we will heap the React muscles:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up your Terminal and switch to whichever directory you want to store your
    project in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we''ll make our app directory with `mkdir chatastrophe`. Let''s go inside
    that folder, make another folder within it named **`public`**, and within **`public`**,
    **`touch index.html`**. If you''re on Windows, use **`type nul > index.html`**
    instead of **`touch`**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Then, open up the whole `chatastrophe` folder in your text editor of choice.
    I'll be using **Sublime Text 3** for this tutorial. Open up the `index.html` file,
    and let's write some HTML!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's start with the basic HTML elements. Create a `<html>` tag, and within
    that, `<head>` and `<body>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This wouldn't be a programming tutorial without a hello world, so within the
    body, let's put `Hello world!` within an `<h1>` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, open up `index.html` within your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our goal by the end of the chapter is to display the exact same as the preceding
    illustration, but using React to render our `<h1>`.
  prefs: []
  type: TYPE_NORMAL
- en: Why did we put our `index.html` inside the public folder? Well, our HTML is
    the first thing our users will download when they hit our page. They will download
    it exactly as we see it here. This is in sharp contrast to our React JavaScript,
    which will be transpiled (more on that in the next chapter) before being served
    to the client. Our React code, as we write it, will be private. Our HTML, as we
    write it, will be public.
  prefs: []
  type: TYPE_NORMAL
- en: This is a distinction that will make more sense as we move into the React world,
    but for now, just know that the convention is to put HTML and static assets in
    the public folder.
  prefs: []
  type: TYPE_NORMAL
- en: CSS and assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our good friend at the start-up (now dubbed Chatastrophe--what have you done?)
    has tapped a designer to provide some basic assets for us. These include a send
    icon for our chat box, and a logo for the application. You're not a fan of the
    style, but *c'est la vie*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go ahead and download the image files from [https://github.com/scottdomes/chatastrophe-assets](https://github.com/scottdomes/chatastrophe-assets).
    You can download them by clicking on the Clone or Download button, and then selecting
    Download as Zip. Then, unzip those into the `public` folder, in a new folder called
    `assets` (all asset files should thus be in `chatastrophe/public/assets`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we continue, we can ensure that our assets look okay by testing them
    in our `index.html`. Above `<h1>`, let''s put in an `img` tag, with the `src`
    set to `/img/logo.png`, and an ID as `test-image`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what it should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is even more beautiful.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do is add our CSS. By the luck of the gods, all of
    our CSS has been mysteriously prepared for us, saving us the cumbersome task of
    styling our application. All we have to do is pull in `assets/app.css`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We include it in our `index.html` with a link tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We should see an immediate change to our page. The background should be a gradiant,
    and the image should now have a slightly pulsing animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It worked! That does it for our main assets. Let's move on to some improvements
    to our HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Meta tags and favicons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application will be mobile-first, as we have already discussed. To ensure
    that our HTML is fully optimized, let's add a bit more markup.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add a `DOCTYPE` declaration to the top of `index.html`. This
    tells the browser what kind of document to expect. In HTML 5 (the newest version
    of HTML), it always looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add a meta tag for `viewport` width. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What does this do? Essentially, it tells the browser to display the web page
    at the same width as its screen. So, if the web page seems to be 960px and our
    device is 320px wide, rather than zooming out and showing the whole page, it'll
    instead squish all the content down until it's 320px.
  prefs: []
  type: TYPE_NORMAL
- en: As you might expect, this is only a good idea if your website is responsive
    and able to adapt to a smaller size. However, since responsiveness is one of our
    main goals, let's do this from the start. Add this tag within the `<head>` of
    our document.
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple more tags to go! The character set we use on our web page can be encoded
    in a couple of different ways: **Unicode** and **ISO-8859-1**. You can look up
    these encodings for more information, but long story short, we''re using Unicode.
    Let''s add it like so, right below the previous `<meta>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'While we''re at it, let''s add the language the HTML is in. On our existing
    `<html>` tag, add `lang="en"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, that about does it for HTML housekeeping. The last thing we need is a
    **favicon**, the little icon displayed next to the title in the browser tab. This
    is included in our assets bundle, so all we have to do is link it up (right underneath
    our `<meta>` tags):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Your browser tab should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With that, we're done!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at how we will include React in our project, and all the other
    dependencies we will need.
  prefs: []
  type: TYPE_NORMAL
- en: What is npm?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A React application is primarily JavaScript. If you have experience working
    with JavaScript, you know that the browser is perfectly capable of parsing and
    executing JavaScript on its own.
  prefs: []
  type: TYPE_NORMAL
- en: In most basic websites, we link to the JavaScript needed for the page in a `<script>`
    tag, and the browser downloads and runs it.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be doing something similar with our React application (with considerable
    complications; more on that in [Chapter 2](part0048.html#1DOR00-7dd7c66301294003b85168009fe95fa4)*,
    Getting Started with Webpack*).
  prefs: []
  type: TYPE_NORMAL
- en: However, JavaScript is no longer confined to the browser. More and more applications
    are using JavaScript on the backend as well, with JavaScript running in its own
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Long story short, JavaScript is now everywhere, and the driving force behind
    this proliferation is `Node.js`, a JavaScript runtime library, which lets you
    run JavaScript outside of a browser environment.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, this is exciting, but why does this matter for our React project?
  prefs: []
  type: TYPE_NORMAL
- en: Node also introduced the idea of packages to JavaScript. Packages are essentially
    third-party libraries of code that you can install to your application and then
    import and use where and when you need them. You can use packages even if your
    application is not a Node application.
  prefs: []
  type: TYPE_NORMAL
- en: React is one such package. Webpack, mentioned earlier, is another one. In short,
    in order to build a complex web application, we will inevitably rely on a lot
    of other people's code, so we need packages, and we need **Node's package manager**
    (shorthand **`npm`**) to install them.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use `npm` to start up our application and do some basic tasks, but
    its primary purpose is to manage packages.
  prefs: []
  type: TYPE_NORMAL
- en: Node setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay, enough said. Let''s go ahead and install Node, which comes bundled with
    `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to [https://nodejs.org](https://nodejs.org) and download the latest stable
    release of Node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, I would choose v6.10.3, the one recommended for most users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once that is installed, open up your terminal and run **`node -v`** just to
    confirm the installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can also confirm that `npm` has been included by running `npm -v`*.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just to reiterate, Node is a JavaScript runtime used to execute JavaScript outside
    of the browser, and `npm` is a method of managing modules of JavaScript code.
    We won't be working with Node directly in this book, but we will be using `npm`
    a lot.
  prefs: []
  type: TYPE_NORMAL
- en: The dark side of npm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the past year, `npm` has come under fire for various reasons.
  prefs: []
  type: TYPE_NORMAL
- en: It can be slow (just try installing large packages over a poor Wi-Fi connection)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its installation process can lead to different results for different developers
    on the same project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn't work offline, even if you've downloaded the package before
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In response to these issues, Facebook came out with a package manager called
    **Yarn.** Yarn is essentially a wrapper around `npm`, giving the same basic functionality
    with an extra layer of goodness. Let's go ahead and install it so that we can
    use it to manage our packages!
  prefs: []
  type: TYPE_NORMAL
- en: Visit [https://yarnpkg.com/en/docs/install](https://yarnpkg.com/en/docs/install)
    for installation instructions. For macOS, note that you'll need **Homebrew** (which
    is like `npm` for macOS packages--packages everywhere!), which you can get at
    [https://brew.sh/.](https://brew.sh/)
  prefs: []
  type: TYPE_NORMAL
- en: Project initiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next thing we need to do is initiate our application as an `npm` project.
    Let''s try it out, and then we''ll discuss why we needed to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside your `project` folder, in your terminal, type `yarn init` and hit enter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’ll ask you a series of questions. The first one is the most important--the
    name of our application. It should just take the name of the current folder (`chatastrophe`).
    If it doesn't, just enter `chatastrophe`. From there, just hit enter to skip the
    rest of the questions, accepting the default answers. These questions would matter
    more if we were planning on publishing our own package, but we're not, so no worries!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you take a look at your project folder after completing the yarn init, you'll
    notice that it added a `package.json` file with our project name and version.
    Our `package.json` is important, in that it will act as a list of our dependencies--the
    package we will install via `yarn`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enough talking about dependencies, though, let's install our first one! What
    better choice than to install React?
  prefs: []
  type: TYPE_NORMAL
- en: Installing React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s try it by running `yarn add react@15.6.1` from within your `project` folder.
  prefs: []
  type: TYPE_NORMAL
- en: We're installing a specific version of React (15.6.1) to ensure compatibility
    with other dependencies, and to ensure that there are no unexpected problems as
    new versions are released.
  prefs: []
  type: TYPE_NORMAL
- en: Once the installation is complete, you should see React added to our `package.json`
    under dependencies. You'll also see that `yarn` generated a `node_modules` folder
    and a `yarn.lock` file.
  prefs: []
  type: TYPE_NORMAL
- en: The `node_modules` folder is where all our packages will live. If you open it
    up, you can see that there are several folders already. We've not only installed
    React, but everything that React depends on--dependencies on dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: As you might imagine, the `node_modules` folder can get quite hefty. So, we
    don't check it into source control. When a new developer joins the team and downloads
    the project files, they can then install the dependencies independently, based
    on the `package.json`; this saves time and space.
  prefs: []
  type: TYPE_NORMAL
- en: However, we need to ensure that they get the same packages as everyone else,
    and the same version; this is where the `yarn.lock` file comes in.
  prefs: []
  type: TYPE_NORMAL
- en: The previously mentioned setup ensures that we are ready to safely use third-party
    libraries. We have the `package.json`, `yarn.lock`, and `node_modules` folders
    in our project. Before we continue, let's ensure that adding React worked.
  prefs: []
  type: TYPE_NORMAL
- en: Using React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's confirm that React is in our project by using it to render a simple element
    to our screen. This will be our first dipping of our feet into React, so go slow
    and ensure that you understand each step.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to import our React package (which we just installed with `yarn`)
    into our `index.html` so that we can use it there.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we add a `<script>` tag with the path to the main React file within
    our `node-modules` folder. This tag looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Place this in your `index.html`, at the bottom of the `body` tag (before the
    closing `</body>`).
  prefs: []
  type: TYPE_NORMAL
- en: Okay, we have React! Let's use it to make a simple `<h1>` tag, just like the
    one we wrote in HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'React has a function called `createElement` for this purpose. It takes three
    arguments: element type, something called props (more on that later), and the
    children (what goes inside the tag).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For us, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This function call creates an element that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To confirm that it will work, let''s `console.log` it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Reload `index.html`, then right-click or control-click and select Inspect to
    open up DevTools in Chrome and switch to the Console tab. There, we see our element…
    or not. Instead of the HTML output, we get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is not the HTML element we might have expected, but we can see that React
    has worked in its own way. We have a JavaScript object with a type field of `h1`.
    Let’s see whether we can transform this into an actual HTML tag on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to ReactDOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here's a secret about React--it's a library for creating UIs, but not a library
    for rendering UIs. In itself, it has no mechanism for rendering a UI to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the creators of React also have a package called **ReactDOM** for
    exactly this purpose. Let's install it and then see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: First, we install it with **`yarn add react-dom@15.6.1`**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, require it in `index.html` in much the same way as React:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'ReactDOM has a function called `render`, which takes two arguments: the React
    element to be rendered to the screen (hey, we have that already!), and the HTML
    element it will be rendered inside.'
  prefs: []
  type: TYPE_NORMAL
- en: So, we have the first argument, but not the second. We need something in our
    existing HTML we can grab and hook into; ReactDOM will inject our React element
    inside of it.
  prefs: []
  type: TYPE_NORMAL
- en: So, below our existing `<h1>` tag, create an empty `div` with the ID `root`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in our `ReactDOM.render` function, we’ll pass in the React element, and
    then use `document.getElementById` to grab our new `div`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what our `index.html` should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Reload the page, and you should see `'Hello from React!'` text in the middle
    of the screen!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Success!
  prefs: []
  type: TYPE_NORMAL
- en: We will be diving deeper (much, much deeper) into both ReactDOM and React in
    the next few chapters. We'll learn how to create elements in a much more intuitive
    way, and also how React makes building UIs a dream.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we have our project skeleton ready to go—the basis of our future application.
    Great work!
  prefs: []
  type: TYPE_NORMAL
- en: Our next step is to finish the last stage of preparation, and take a deep look
    at one of our most important dependencies--a tool called Webpack.
  prefs: []
  type: TYPE_NORMAL
