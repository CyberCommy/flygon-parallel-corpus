- en: Navigating Between Screens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The focus of this chapter is navigating between the screens that make up your
    React Native application. Navigation in native apps is slightly different than
    navigation in web apps—mainly because there isn't any notion of a URL that the
    user is aware of. In prior versions of React Native, there were primitive navigator
    components that you could use to control the navigation between screens. There
    were a number of challenges with these components that resulted in more code to
    accomplish basic navigation tasks.
  prefs: []
  type: TYPE_NORMAL
- en: More recent versions of React Native encourage you to use the `react-navigation`
    package, which will be the focus of this chapter, even though there are several
    other options. You'll learn navigation basics, passing parameters to screens,
    changing the header content, using tab and drawer navigation, and handling state
    with navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start off with the basics of moving from one page to another using `react-navigation`.
    Here''s what the `App` component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `createStackNavigator()` function is all you need to set up your navigation.
    The first argument to this function is a mapping to the screen components that
    can be navigated. The second argument is for more general navigation options—in
    this case, you're telling the navigator that `Home` should be the default screen
    component that's rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the `Home` component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is your typical functional React component. You could use a class-based
    component here, but there's no need since there are no life cycle methods or state.
    It renders a `View` component where the container style is applied. This is followed
    by a `Text` component that labels the screen followed by a `Button` component.
    A screen can be anything you want - it's just a regular React Native component.
    The navigator component handles the routing and the transitions between screens
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: The `onPress` handler for this button navigates to the `Settings` screen when
    clicked. This is done by calling `navigation.navigate('Settings')`. The `navigation`
    property is passed to your screen component by `react-navigation` and contains
    all of the routing functionality you need. In contrast to working with URLs in
    React web apps, here you call navigator API functions and pass them the names
    of screens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s take a look at the `Settings` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This component is just like the `Home` component, except with different text
    and when the button is clicked on, you're taken back to the `Home` screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the home screen looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5afc73f6-11a8-472b-996b-4cc346c11553.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can click the **Settings** button and you''ll be taken to the `Settings`
    screen, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7e83075d-2129-490c-b77a-7d0147bd1aee.png)'
  prefs: []
  type: TYPE_IMG
- en: This screen looks almost identical to the `Home` screen. It has different text
    and a different button that will take you back to the `Home` screen when clicked.
    However, there's another way to get back to the `Home` screen. Take a look at
    the top of the screen and you'll notice a white navigation bar. On the left side
    of the navigation bar, there's a back arrow. This works just like the back button
    in a web browser and will take you back to the previous screen. What's nice about
    `react-navigation` is that it takes care of rendering this navigation bar for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: With this navigation bar in place, you don't have to worry about how your layout
    styles impact the status bar. You only need to worry about the layout within each
    of your screens.
  prefs: []
  type: TYPE_NORMAL
- en: If you run this app in Android, you'll see the same back button in the navigation
    bar. But you can also use the standard back button found outside of the app on
    most Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: Route parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you develop React web applications, some of your routes have dynamic data
    in them. For example, you can link to a details page and within that URL, you
    would have some sort of identifier. The component then has what it needs to render
    specific detailed information. The same concept exists within `react-navigation`.
    Instead of just specifying the name of the screen that you want to navigate to,
    you can pass along additional data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at route parameters in action, starting with the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks just like the preceding example, except instead of a `Settings`
    page, there''s a `Details` page. This is the page that you want to pass data to
    dynamically so it can render the appropriate information. First, let''s take a
    look at the `Home` screen component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Home` screen has three `Button` components that each navigate to the `Details`
    screen. Pay attention to the `navigation.navigate()` calls. In addition to the
    screen name, they each have a second argument. These are objects that contain
    specific data that is passed to the `Details` screen. Next, let''s take a look
    at the `Details` screen and see how it consumes these route parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Although this example is only passing one parameter—`title`—you can pass as
    many parameters to the screen as you need to. You can access these parameters
    using the `navigator.getParam()` function to look up the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the home screen looks like when rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/cb6a4cf6-cf5d-414e-b14f-03ed7cba50eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And if you click on the **First Item** button, you''ll be taken to the Details
    screen that is rendered using route parameter data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e48783cb-16e4-4ef1-90d5-7b221e56b9dd.png)'
  prefs: []
  type: TYPE_IMG
- en: You can click the back button in the navigation bar to get back to the `home`
    screen. If you click on any of the other buttons on the `Home` screen, you'll
    be taken back to the `Details` screen with updated data. Route parameters are
    necessary to avoid having to write duplicate components. You can think of passing
    parameters to `navigator.navigate()` as passing props to a React component.
  prefs: []
  type: TYPE_NORMAL
- en: The navigation header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The navigation bars that you've created so far in this chapter have been sort
    of plain. That's because you haven't configured them to do anything, so `react-navigation`
    will just render a plain bar with a back button. Each screen component that you
    create can configure specific navigation header content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build on the previous example that used buttons to navigate to a details
    page. The `App` component stays the same, so let''s take a look at the `Home`
    component first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing you''ll notice is that each button is passing more route parameters
    to the `Details` component: `content` and `stock`. You''ll see why in a moment.
    It''s the `Home.navigationOptions` value that configures the navigation header
    for you. In this case, the `Home` screen is setting the `title`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Home` screen is a functional component, so you can just set `navigationOptions`
    as a property on the function. If your component is class based because it has
    the state of life cycle methods, you can define it as a static class property:'
  prefs: []
  type: TYPE_NORMAL
- en: '`class MyScreen extends Component { static navigationOptions = {...} ... }`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s take a look at the `Details` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This time, the `Details` component renders the content route parameter. Like
    the `Home` component, it also has a `navigationOptions` property. In this case,
    it's a function instead of an object. This is because you're dynamically changing
    navigation header content based on the parameters that are passed to the screen.
    The function is passed a `navigation` property - this is the same value that's
    passed to the `Details` component. You can call `navigation.getParam()` to get
    the title to change the navigation header based on a route parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `headerRight` option is used to add a `Button` component to the right
    side of the navigation bar. This is where the stock parameter comes into play.
    If this value is 0 because there isn't anything in stock, you want to disable
    the **Buy** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how all of this works now, starting with the `Home` screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f21a99d6-558c-453b-ab3d-d0d302eedd96.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is how header text in the navigation bar, is set by the `Home` screen
    component. Next, try clicking on the **First Item** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3a484181-14ba-4b58-859d-f6131d6b9e5d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The title in the navigation bar is set based on the `title` parameter that''s
    passed to the `Details` component. The **Buy** button that''s rendered on the
    right side of the navigation bar is rendered by the `Details` component as well.
    It''s enabled because the `stock` parameter value is 1\. Now try returning to
    the `Home` screen and clicking on the **Second Item** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9228ad78-b384-4c73-8b65-2bd246a2a282.png)'
  prefs: []
  type: TYPE_IMG
- en: The title and the page content both reflect the new parameter values passed
    to `Details`. But so does the **Buy** button. It is in a disabled state because
    the stock parameter value was 0, meaning that it can't be bought.
  prefs: []
  type: TYPE_NORMAL
- en: Tab and drawer navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each example so far in this chapter has used `Button` components to link to
    other screens in the app. You can use functions from `react-navigation` that will
    create tab or drawer navigation for you automatically based on the screen components
    that you give it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create an example that uses bottom tab navigation on iOS and drawer navigation
    on Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'You aren''t limited to using tab navigation on iOS or drawer navigation on
    Android. I''m just picking these two to demonstrate how to use different modes
    of navigation based on the platform. You can use the exact same navigation mode
    on both platforms if you prefer.Here''s what the `App` component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using the `createStackNavigator()` function to create your navigator,
    you''re importing the `createBottomTabNavigator()` and `createDrawerNavigator()`
    functions from `react-navigation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you''re using the `Platform` utility from `react-native` to decide which
    of these two functions to use. The result, depending on the platform, is assigned
    to `createNavigator()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can call `createNavigator()` and pass it to your screens. The resulting
    tab or drawer navigation will be created and rendered for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s take a look at the `Home` screen component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It sets the `title` in the navigation bar and renders some basic content. The
    `News` and `Settings` components are essentially the same as `Home`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the bottom tab navigation looks like on iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9b570d61-e6ec-48af-9168-3ad8fe4d209e.png)'
  prefs: []
  type: TYPE_IMG
- en: The three screens that make up your app are listed at the bottom. The current
    screen is marked as active and you can click on the other tabs to move around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see what the drawer layout looks like on Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/16c598d2-9a7b-47c4-9ea2-eeacf04e432d.png)'
  prefs: []
  type: TYPE_IMG
- en: To open the drawer, you need to swipe from the left side of the screen. Once
    open, you'll see buttons that will take you to the various screens of your app.
  prefs: []
  type: TYPE_NORMAL
- en: Swiping the drawer open from the left side of the screen is the default mode.
    You can configure the drawer to swipe open from any direction.
  prefs: []
  type: TYPE_NORMAL
- en: Handling state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React applications have state that gets passed down to components that render
    features and require state data. For example, imagine that you're designing an
    app that uses `react-navigation` and different screens depend on the same state
    data. How do you get state data into these screen components? How do they update
    the application state?
  prefs: []
  type: TYPE_NORMAL
- en: To start with, let's think about where to put your application state. The most
    natural place to put it would be the `App` component. So far in this chapter,
    the examples have directly exported calls to `createStackNavigator()`. This function
    is a higher-order function - it returns a new React component. This means that
    you can wrap your own stateful component around the navigation component that's
    returned by `createStackNavigator()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this idea, let''s revisit the example from earlier where you
    have a `Home` screen that lists item buttons that navigate to a `Details` screen.
    Here''s what the new `App` component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'First, you use the `createStackNavigator()` function to create your navigator
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you have a `Nav` component that you can render. Next, you can create a
    regular React component with state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The state used in this component represents the number quantity of each item
    that is available to buy. Next, you have the `updateStock()` function that is
    used to update the stock state for a given item ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The ID that''s passed to this function has its stock state decremented by `1`,
    unless it''s already at 0\. This function can be used when the **Buy** button
    is clicked for the item to check its stuck quantity by `1`. Finally, you have
    the `render()` method, which can render the `Nav` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The state of `App` is passed to `Nav` as props. The `updateStock()` function
    is also passed as a prop so that it can be used by the screen components. Now
    let''s take a look at the `Home` screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, you have the three `Button` components that navigate to the `Details`
    screen and pass route parameters. There''s a new parameter added in this version:
    `id`. The title of each button reflects the stock count of the given item. This
    value is part of the application state and is passed to the screen component via
    properties. However, these properties are all accessed through the `screenProps`
    property.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule of thumb**: If a prop is passed to the navigation component, it''s accessible
    via the `screenProps` property. If a value is passed to the screen via `navigator.navigate()`,
    it''s accessible by calling `navigator.getParam()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `Details` component next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `id` and the `title` route parameters are used to manipulate content in
    the navigation bar. The `title` parameter sets the title. The `id` is used by
    the `onPress` handler of the **Buy** button, by passing it to `updateStock()`,
    and the appropriate item stock count is updated when the button is pressed. The
    `disabled` property also relies on the `id` parameter to look up the stock quantity.
    Just like the `Home` screen, the stock and `updateStock()` props that are passed
    down from the `App` component are accessible through the screenProps app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the `Home` screen looks like when it''s first rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e65820bb-e4dd-4577-8eb5-e7c5d5197054.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The stock quantity is reflected in each item button as a number. Let''s press
    the **First Item** button and navigate to the `Details` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5ecc1b4f-ddf5-4704-9f37-c89bf6490359.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Buy** button in the navigation bar is enabled because the stock quantity
    is 1\. Let''s go ahead and press the Buy button and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c3a28b61-dd7d-4742-8ec8-bc4d61924787.png)'
  prefs: []
  type: TYPE_IMG
- en: After pressing the **Buy** button, it becomes disabled. This is because the
    stock value for this item was 1\. By pressing **Buy**, you caused the `updateStock()`
    function to be called, which updated this value to 0\. As a result of the state
    change, the `App` component re-rendered the `Nav` component, which, in turn re-rendered
    your `Details` screen component with new prop values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the `Home` screen and see what''s changed there as a result
    of the state update:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6c5b95b7-850b-41e2-a085-88e42f8546fa.png)'
  prefs: []
  type: TYPE_IMG
- en: As expected, the stock quantity that is rendered beside the **First Item** button
    text is 0, reflective of the state change that just happened.
  prefs: []
  type: TYPE_NORMAL
- en: This example shows that you can have a top-level `App` component handle the
    application state while passing it down to the individual app screens, along with
    the functions that issue state updates.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned that mobile web applications require navigation
    just like web applications do. Although different, web application and mobile
    application navigation have enough conceptual similarities that mobile app routing
    and navigation doesn't have to be a nuisance.
  prefs: []
  type: TYPE_NORMAL
- en: Older versions of React Native made attempts to provide components to help manage
    navigation within mobile apps, but these never really took hold. Instead, the
    React Native community has dominated this area. One example of this is the `react-navigation`
    library, the focus of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how basic navigation works with react-navigation. You then learned
    how to control the header components within the navigation bar. Next, you learned
    about tab and drawer navigation. These two navigation components can automatically
    render the navigation buttons for your app based on the screen components. Finally,
    you learned how to maintain navigation while still being able to pass state data
    down to screen components from the top level app.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn how to render lists of data.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledege
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's the main difference between navigation in React web apps and React Native
    apps?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no meaningful difference between web and mobile applications in terms
    of navigation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Web applications rely on URLs as the central concept for moving around. Native
    apps have no such concept, so it's up to the developer and the navigation libs
    they use to manage their screens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Native application code uses URLs the same way as with web applications, but
    these just aren't exposed to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What function should be used to navigate to a new screen?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Screen components are passed a navigation property. You should use **`navigation.navigate()`**
    to move to another screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The screen component automatically has navigation methods added to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's a global navigation object that has navigation methods that you can
    use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does react-navigation handle back button functionality for you?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes. Including the built-in back button on Android systems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, you have to implement all back button behavior yourself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you pass data to screens?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can pass a plain object as the second argument to **`navigation.navigate()`**.
    The properties are then accessible to the screen via **`navigation.getParam()`.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have to re-render the screen component, passing it parameters that you get
    as properties from navigation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You don't pass data to screens. Setting application level state is the only
    way to get data into screen components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the following link for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://reactnavigation.org/](https://reactnavigation.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
