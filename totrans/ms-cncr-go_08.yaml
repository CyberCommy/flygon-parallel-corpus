- en: Chapter 8. Concurrent Application Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, we've designed small bits of concurrent programs, primarily in a single
    piece keeping concurrency largely isolated. What we haven't done yet is tie everything
    together to build something a little more robust, complex, and more daunting to
    manage from an administrator's perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Simple chat applications and web servers are fine and dandy. However, you will
    eventually need more complexity and require external software to meet all of the
    more advanced requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we''ll build something that''s satisfied by a few dissonant services:
    a file manager with revision control that supplies web and shell access. Services
    such as Dropbox and Google Drive allow users to keep and share files among peers.
    On the other hand, GitHub and its ilk allow for a similar platform but with the
    critical added benefit of revision control.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many organizations face problems with the following sharing and distribution
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: Limitations on repositories, storage, or number of files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Potential inaccessibility if the services are down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security concerns, particularly for sensitive information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple sharing applications such as Dropbox and Google Drive are great at storing
    data without a large amount of revision control options. GitHub is an excellent
    collaborative revision control and distribution system, but comes with many costs
    and the mistakes by developers can lead to large and potentially serious security
    lapses.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be combining the aims of version control (and the GitHub ideal) with Dropbox's
    / Google Drive's simplicity and openness. This type of application will be perfect
    as an intranet replacement—wholly isolated and accessible with custom authentication
    that doesn't necessarily rely on cloud services. The ability to keep it all in-house
    removes any potential for network security concerns and allows an administrator
    to design permanent backup solutions in a way that fits their organization.
  prefs: []
  type: TYPE_NORMAL
- en: File sharing within the organization will allows forking, backups, file locking,
    and revision control all from the command line but also through a simple web interface.
  prefs: []
  type: TYPE_NORMAL
- en: Designing our concurrent application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When designing a concurrent application, we will have three components running
    in separate processes. A file listener will be alerted to make changes to files
    in specified locations. A web-CLI interface will allow users to augment or modify
    files, and a backup process will be bound to the listener to provide automated
    copies of new file changes. With that in mind, these three processes will look
    a bit like what is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing our concurrent application](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our file listener process will do the following three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep an eye on any file changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Broadcast to our web/CLI servers and the backup process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintain the state of any given file in our database / data store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The backup process will accept any broadcasts from the file listener (#2) and
    create a backup file in an iterative design.
  prefs: []
  type: TYPE_NORMAL
- en: Our general server (web and CLI) will report details on individual files and
    allow versioning forward and backward with a customizable syntax. This part of
    the application will also have to broadcast back to the file listener when new
    files are committed or revisions are requested.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying our requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most critical step in our architectural design process is really zooming
    in on the required features, packages, and technologies that we''ll need to implement.
    For our file management and revision control application, there are a few key
    points that will stand out:'
  prefs: []
  type: TYPE_NORMAL
- en: A web interface that allows file uploads, downloads, and revisions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A command-line interface that allows us to roll back changes and modify files
    directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A filesystem listener that finds changes made to a shared location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A data store system that has strong Go tie-in and allows us to maintain information
    about files and users in a mostly consistent manner. This system will also maintain
    user records.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A concurrent log system that maintains and cycles logs of changed files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''re somewhat complicating things by allowing the following three different
    ways to interface with the overall application:'
  prefs: []
  type: TYPE_NORMAL
- en: Via the Web that requires a user and login. This also allows our users to access
    and modify files even if they happen to be somewhere not connected to the shared
    drive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via the command line. This is archaic but also extremely valuable anytime a
    user is traversing a filesystem, particularly power users not in a GUI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via the filesystem that changes itself. This is the shared drive mechanism wherein
    we assume that any user with access to this will be making valid modifications
    to any files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To handle all of this, we can identify a few critical technologies as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A database or data store to manage revisions to our filesystem. When choosing
    between transactional, ACID-compliant SQL and fast document stores in NoSQL, the
    tradeoff is often performance versus consistency. However, since most of our locking
    mechanism will exist in the application, duplicating locks (even at the row level)
    will add a level of potential slowness and cruft that we don't need. So, we will
    utilize a NoSQL solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This solution will need to play well with concurrency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll be using a web interface, one that brings in powerful and clean routing/muxing
    and plays well with Go's robust built-in templating system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A filesystem notification library that allows us to monitor changes to files
    as well as backing up revisions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any solutions we uncover or build to satisfy these requirements will need to
    be highly concurrent and non-blocking. We'll want to make sure that we do not
    allow simultaneous changes to files, including changes to our internal revisions
    themselves.
  prefs: []
  type: TYPE_NORMAL
- en: With all of this in mind, let's identify our pieces one-by-one and decide how
    they will play in our application.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also present a few alternatives with options that can be swapped without
    compromising the functionality or core requirements. This will allow some flexibility
    in cases where platform or preference makes our primary option unpalatable. Any
    time we're designing an application, it's a good idea to know what else is out
    there in case the software (or terms of its use) change or it is no longer satisfactory
    to use at a future scale.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with our data store.
  prefs: []
  type: TYPE_NORMAL
- en: Using NoSQL as a data store in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the biggest concessions with using NoSQL is, obviously, the lack of standardization
    when it comes to CRUD operations (create, read, update, and delete). SQL has been
    standardized since 1986 and is pretty airtight across a number of databases—from
    MySQL to SQL Server and from Microsoft and Oracle all the way down to PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more about NoSQL and various NoSQL platforms at [http://nosql-database.org/](http://nosql-database.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Martin Fowler has also written a popular introduction to the concept and some
    use cases in his book *NoSQL Distilled* at [http://martinfowler.com/books/nosql.html](http://martinfowler.com/books/nosql.html).
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the NoSQL platform, you can also lose ACID compliance and durability.
    This means that your data is not 100 percent secure—there can be transactional
    loss if a server crashes, if reads happen on outdated or non-existent data, and
    so on. The latter of which is known as a dirty read.
  prefs: []
  type: TYPE_NORMAL
- en: This is all noteworthy as it applies to our application and with concurrency
    specifically because we've talked about one of those big potential third-party
    bottlenecks in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: For our file-sharing application in Go, we will utilize NoSQL to store metadata
    about files as well as the users that modify/interact with those files.
  prefs: []
  type: TYPE_NORMAL
- en: We have quite a few options when it comes to a NoSQL data store to use here,
    and almost all of the big ones have a library or interface in Go. While we're
    going to go with Couchbase here, we'll briefly talk about some of the other big
    players in the game as well as the merits of each.
  prefs: []
  type: TYPE_NORMAL
- en: The code snippets in the following sections should also give you some idea of
    how to switch out Couchbase for any of the others without too much angst. While
    we don't go deeply into any of them, the code for maintaining the file and modifying
    information will be as generic as possible to ensure easy exchange.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MongoDB is one of the most popular NoSQL platforms available. Written in 2009,
    it's also one of the most mature platforms, but comes with a number of tradeoffs
    that have pushed it somewhat out of favor in the recent years.
  prefs: []
  type: TYPE_NORMAL
- en: Even so, Mongo does what it does in a reliable fashion and with a great deal
    of speed. Utilizing indices, as is the case with most databases and data stores,
    improves query speed on reads greatly.
  prefs: []
  type: TYPE_NORMAL
- en: Mongo also allows for some very granular control of guarantees as they apply
    to reads, writes, and consistency. You can think of this as a very vague analog
    to any language and/or engine that supports syntactical dirty reads.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, Mongo supports concurrency easily within Go and is implicitly
    designed to work in distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The biggest Go interface for Mongo is `mgo`, which is available at: [http://godoc.org/labix.org/v2/mgo](http://godoc.org/labix.org/v2/mgo).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Should you wish to experiment with Mongo in Go, it''s a relatively straightforward
    process to take your data store record and inject it into a custom struct. The
    following is a quick and dirty example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: One downside to Mongo compared to other NoSQL solutions is that it does not
    come with any GUI by default. This means we either need to tie in another application
    or web service, or stick to the command line to manage its data store. For many
    applications, this isn't a big deal, but we want to keep this project as compartmentalized
    and provincial as possible to limit points of failure.
  prefs: []
  type: TYPE_NORMAL
- en: Mongo has also gotten a bit of a bad rap as it pertains to fault tolerance and
    data loss, but this is equally true of many NoSQL solutions. In addition, it's
    in many ways a feature of a fast data store—so often catastrophe recovery comes
    at the expense of speed and performance.
  prefs: []
  type: TYPE_NORMAL
- en: It's also fair to say this is a generally overblown critique of Mongo and its
    peers. Can something bad happen with Mongo? Sure. Can it also happen with a managed
    Oracle-based system? Absolutely. Mitigating massive failures in this realm is
    more the responsibility of a systems administrator than the software itself, which
    can only provide the tools necessary to design such a contingency plan.
  prefs: []
  type: TYPE_NORMAL
- en: All that said, we'll want something with a quick and highly-available management
    interface, so Mongo is out for our requirements but could easily be plugged into
    this solution if those are less highly valued.
  prefs: []
  type: TYPE_NORMAL
- en: Redis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Redis is another key/value data store and, as of recently, took the number one
    spot in terms of total usage and popularity. In an ideal Redis world, an entire
    dataset is held in memory. Given the size of many datasets, this isn't always
    possible; however, coupled with Redis' ability to eschew durability, this can
    result in some very high performance results when used in concurrent applications.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful feature of Redis is the fact that it can inherently hold different
    data structures. While you can make abstractions of such data by unmarshalling
    JSON objects/arrays in Mongo (and other data stores), Redis can handle sets, strings,
    arrays, and hashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two major accepted libraries for Redis in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Radix**: This is a minimalist client that''s barebones, quick, and dirty.
    To install Radix, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Redigo**: This more robust and a bit more complex, but provides a lot of
    the more intricate functionality that we''ll probably not need for this project.
    To install Redigo, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll now see a quick example of getting a user''s name from the data store
    of `Users` in Redis using Redigo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking over this, you might note some non programmatic access syntax, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is indeed one of the reasons why Redis in Go will not be our choice for
    this project—both libraries here provide an almost API-level access to certain
    features with some more detailed built-ins for direct interaction. The `Do` command
    passes straight queries directly to Redis, which is fine if you need to use the
    library, but a somewhat inelegant solution across the board.
  prefs: []
  type: TYPE_NORMAL
- en: Both the libraries play very nicely with the concurrent features of Go, and
    you'll have no problem making non-blocking networked calls to Redis through either
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth noting that Redis only supports an experimental build for Windows,
    so this is mostly for use on *nix platforms. The port that does exist comes from
    Microsoft and can be found at [https://github.com/MSOpenTech/redis](https://github.com/MSOpenTech/redis).
  prefs: []
  type: TYPE_NORMAL
- en: Tiedot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you've worked a lot with NoSQL, then the preceding engines all likely seemed
    very familiar to you. Redis, Couch, Mongo, and so on are all virtual stalwarts
    in what is a relatively young technology.
  prefs: []
  type: TYPE_NORMAL
- en: Tiedot, on the other hand, probably isn't as familiar. We're including it here
    only because the document store itself is written in Go directly. Document manipulation
    is handled primarily through a web interface, and it's a JSON document store like
    several other NoSQL solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As document access and handling is governed via HTTP, there''s a somewhat counterintuitive
    workflow, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tiedot](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As that introduces a potential spot for latency or failure, this keeps from
    being an ideal solution for our application here. Keep in mind that this is also
    a feature of a few of the other solutions mentioned earlier, but since Tiedot
    is written in Go, it would be significantly easier to connect to it and read/modify
    data using a package. While this book was being written, this did not exist.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other HTTP- or REST-focused alternatives such as CouchDB, Tiedot relies
    on URL endpoints to dictate actions, not HTTP methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see in the following code how we might handle something like this through
    standard libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This, simply, is a data structure for any record you wish to bring into your
    Go application via data selects, queries, and so on. You saw this in our previous
    usage of SQL servers themselves, and this is not any different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: While not as robust, powerful, or scalable as many of its peers, Tiedot is certainly
    worth playing with or, better yet, contributing to.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find Tiedot at [https://github.com/HouzuoGuo/tiedot](https://github.com/HouzuoGuo/tiedot).
  prefs: []
  type: TYPE_NORMAL
- en: CouchDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CouchDB from Apache Incubator is another one of the big boys in NoSQL big data.
    As a JSON document store, CouchDB offers a great deal of flexibility when it comes
    to your data store approach.
  prefs: []
  type: TYPE_NORMAL
- en: CouchDB supports ACID semantics and can do so concurrently, which provides a
    great deal of performance benefit if one is bound to those properties. In our
    application, that reliance on ACID consistency is somewhat flexible. By design,
    it will be failure tolerant and recoverable, but for many, even the possibility
    of data loss with recoverability is still considered catastrophic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interfacing with CouchDB happens via HTTP, which means there is no need for
    a direct implementation or Go SQL database hook to use it. Interestingly, CouchDB
    uses HTTP header syntax to manipulate data, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GET**: This represents read operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PUT**: This represents creation operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DELETE**: This represents deletion and update operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are, of course, what the header methods were initially intended in HTTP
    1.1, but so much of the Web has focused on GET/POST that these tend to get lost
    in the fray.
  prefs: []
  type: TYPE_NORMAL
- en: 'Couch also comes with a convenient web interface for management. When CouchDB
    is running, you''re able to access this at `http://localhost:5984/_utils/`, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![CouchDB](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: That said, there are a few wrappers that provide a level of abstraction for
    some of the more complicated and advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: Cassandra
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cassandra, another Apache Foundation project, isn't technically a NoSQL solution
    but a clustered (or cluster-able) database management platform.
  prefs: []
  type: TYPE_NORMAL
- en: Like many NoSQL applications, there is a limitation in the traditional query
    methods in Cassandra, for example, subqueries and joins are generally not supported.
  prefs: []
  type: TYPE_NORMAL
- en: We're mentioning it here primarily because of its focus on distributed computing
    as well as the ability to programmatically tune whether data consistency or performance
    is more important. Much of that is equally expressed in our solution, Couchbase,
    but Cassandra has a deeper focus on distributed data stores.
  prefs: []
  type: TYPE_NORMAL
- en: Cassandra does, however, support a subset of SQL that will make it far more
    familiar to developers who have dabbled in MySQL, PostgreSQL, or the ilk. Cassandra's
    built-in handling of highly concurrent integrations makes it in many ways ideal
    for Go, although it is an overkill for this project.
  prefs: []
  type: TYPE_NORMAL
- en: The most noteworthy library to interface with Cassandra is gocql, which focuses
    on speed and a clean connection to the Cassandra connection. Should you choose
    to use Cassandra in lieu of Couchbase (or other NoSQL), you'll find a lot of the
    methods that can be simply replaced.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of connecting to a cluster and writing a simple
    query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Cassandra may be an ideal solution if you plan on rapidly scaling this application,
    distributing it widely, or are far more comfortable with SQL than data store /
    JSON access.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes here, SQL is not a requirement and we value speed over anything
    else, including durability.
  prefs: []
  type: TYPE_NORMAL
- en: Couchbase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Couchbase is a relative newcomer in the field, but it was built by people from
    both CouchDB and memcached. Written in Erlang, it shares many of the same focuses
    on concurrency, speed, and non-blocking behavior that we've come to expect from
    a great deal of our Go applications.
  prefs: []
  type: TYPE_NORMAL
- en: Couchbase also supports a lot of the other features we've discussed in the previous
    chapters, including easy distribution-based installations, tuneable ACID compliance,
    and low-resource consumption.
  prefs: []
  type: TYPE_NORMAL
- en: One caveat on Couchbase is it doesn't run well (or at all) on some lower-resourced
    machines or VMs. Indeed, 64-bit installations require an absolute minimum of 4
    GB of memory and four cores, so forget about launching this on tiny, small, or
    even medium-grade instances or older hardware.
  prefs: []
  type: TYPE_NORMAL
- en: While most NoSQL solutions presented here (or elsewhere) offer performance benefits
    over their SQL counterparts in general, Couchbase has done very well against its
    peers in the NoSQL realm itself.
  prefs: []
  type: TYPE_NORMAL
- en: Couchbase, such as CouchDB, comes with a web-based graphical interface that
    simplifies the process of both setup and maintenance. Among the advanced features
    that you'll have available to you in the setup include your base bucket storage
    engine (Couchbase or memcached), your automated backup process (replicas), and
    the level of read-write concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to configuration and management tools, it also presents some real-time
    monitoring in the web dashboard as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Couchbase](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: While not a replacement for full-scale server management (what happens when
    this server goes down and you have no insight), it's incredibly helpful to know
    exactly where your resources are going without needing a command-line method or
    an external tool.
  prefs: []
  type: TYPE_NORMAL
- en: The vernacular in Couchbase varies slightly, as it tends to in many of these
    solutions. The nascent desire to slightly separate NoSQL from stodgy old SQL solutions
    will pop its head from time to time.
  prefs: []
  type: TYPE_NORMAL
- en: With Couchbase, a database is a data bucket and records are documents. However,
    views, an old transactional SQL standby, bring a bit of familiarity to the table.
    The big takeaway here is views allow you to create more complex queries using
    simple JavaScript, in some cases, replicating otherwise difficult features such
    as joins, unions, and pagination.
  prefs: []
  type: TYPE_NORMAL
- en: Each view created in Couchbase becomes an HTTP access point. So a view that
    you name `select_all_files` will be accessible via a URL such as `http://localhost:8092/file_manager/_design/select_all_files/_view/Select%20All%20Files?connection_timeout=60000&limit=10&skip=0`.
  prefs: []
  type: TYPE_NORMAL
- en: The most noteworthy Couchbase interface library is Go Couchbase, which, if nothing
    else, might save you from some of the redundancy of making HTTP calls in your
    code to access CouchDB.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go Couchbase can be found at [https://github.com/couchbaselabs/go-couchbase](https://github.com/couchbaselabs/go-couchbase).
  prefs: []
  type: TYPE_NORMAL
- en: 'Go Couchbase makes interfacing with Couchbase through a Go abstraction simple
    and powerful. The following code connects and grabs information about the various
    data pools in a lean way that feels native:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Setting up our data store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After installing Couchbase, you can access its administration panel by default
    at localhost and port 8091.
  prefs: []
  type: TYPE_NORMAL
- en: You'll be given an opportunity to set up an administrator, other IPs to connect
    (if you're joining a cluster), and general data store design.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you''ll need to set up a bucket, which is what we''ll use to store
    all information about individual files. Here is what the interface for the bucket
    setup looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up our data store](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In our example, we're working on a single machine, so replicas (also known as
    replication in database vernacular) are not supported. We've named it `file_manager`,
    but this can obviously be called anything that makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: We're also keeping our data usage pretty low—there's no need for much more than
    256 MB of memory when we're storing file operations and logging older ones. In
    other words, we're not necessarily concerned with keeping the modification history
    of `test.txt` in memory forever.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also stick with Couchbase for a storage engine equivalent, although you
    can flip back and forth with memcache(d) without much noticeable change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a seed document: one we''ll delete later, but that
    will represent the schema of our data store. We can create this document with
    an arbitrary JSON structured object, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up our data store](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since everything stored in this data store should be valid JSON, we can mix
    and match strings, integers, bools, arrays, and objects. This affords us some
    flexibility in what data we''re using. The following is an example document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Monitoring filesystem changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it came to NoSQL options, we had a vast variety of solutions at our disposal.
    This is not the case when it comes to applications that monitor filesystem changes.
    While Linux flavors have a fairly good built-in solution in inotify, this does
    restrict the portability of the application.
  prefs: []
  type: TYPE_NORMAL
- en: So it's incredibly helpful that a cross-platform library for handling this exists
    in Chris Howey's fsnotify.
  prefs: []
  type: TYPE_NORMAL
- en: Fsnotify works on Linux, OSX, and Windows and allows us to detect when files
    in any given directory are created, deleted, modified, or renamed, which is more
    than enough for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing fsnotify couldn't be easier, either. Best of all it's all non-blocking,
    so if we throw the listener behind a goroutine, we can have this run as part of
    the primary server application code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows a simple directory listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Managing logfiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like many basic features in a developer's toolbox, Go provides a fairly complete
    solution built-in for logging. It handles many of the basics, such as creating
    timestamp-marked log items and saving to disk or to console.
  prefs: []
  type: TYPE_NORMAL
- en: One thing the basic package misses out on is built-in formatting and log rotation,
    which are key requirements for our file manager application.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that key requirements for our application include the ability to work
    seamlessly in our concurrent environment and be ready to scale to a distributed
    network if need be. This is where the fine **log4go** application comes in handy.
    Log4go allows logging to file, console, and memory and handles log rotation inherently.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Log4go can be found at [https://code.google.com/p/log4go/](https://code.google.com/p/log4go/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Log4go, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a logfile that handles warnings, notices, debug information, and critical
    errors is simple and appending log rotation to that is similarly simple, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Handling configuration files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to configuration files and parsing them, you have a lot of options,
    from simple to complicated.
  prefs: []
  type: TYPE_NORMAL
- en: We could, of course, simply store what we want in JSON, but that format is a
    little tricky to work directly for humans—it will require escaping characters
    and so on, which makes it vulnerable to errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we''ll keep things simple by using a standard `ini config` file library
    in gcfg, which handles `gitconfig` files and traditional, old school `.ini` format,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find gcfg at [https://code.google.com/p/gcfg/](https://code.google.com/p/gcfg/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Essentially, this library takes the values of a config file and pushes them
    into a struct in Go. An example of how we''ll do that is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Detecting file changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we need to focus on our file listener. You may recall this is the part of
    the application that will accept client connections from our web server and our
    backup application and announce any changes to files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic flow of this part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Listen for changes to files in a goroutine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept connections and add to the pool in a goroutine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If any changes are detected, announce them to the entire pool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All three happen concurrently, and the first and the third can happen without
    any connections in the pool, although we assume there will be a connection that
    is always on with both our web server and our backup application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another critical role the file listener will fulfill is analyzing the directory
    on first load and reconciling it with our data store in Couchbase. Since the Go
    Couchbase library handles the get, update, and add operations, we won''t need
    any custom views. In the following code, we''ll examine the file listener process
    and show how we listen on a folder for changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve declared our shared folder as well as a connecting `Client` struct.
    In this application, `Client` is either a web listener or a backup listener, and
    we''ll pass messages in one direction using the following JSON-encoded structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If this looks familiar, it could be because it's also the example document format
    we set up initially.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're not familiar with the syntactical sugar expressed earlier, these are
    known as struct tags. A tag is just a piece of additional metadata that can be
    applied to a struct field for key/value lookups via the `reflect` package. In
    this case, they're used to map our struct fields to JSON fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first look at our overall `Message struct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We compartmentalize our file into a message, which alerts our other two processes
    of changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is a somewhat unreliable method to generate a hash reference to a file
    and will fail if a filename changes. However, it allows us to keep track of files
    that are created, deleted, or modified.
  prefs: []
  type: TYPE_NORMAL
- en: Sending changes to clients
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the broadcast message that goes to all existing connections. We pass
    along our JSON-encoded `Message` struct with the current version, the current
    location, and the hash for reference. Our other servers will then react accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Our backup server will create a copy of that file with the `.[VERSION]` extension
    in the backup folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our web server will simply alert the user via our web interface that the file
    has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Does this code look familiar? We''ve taken almost our exact chat server `Client`
    handler and brought it over here nearly intact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `removeFile` function does one thing only and that''s removing the file
    from our Couchbase data store. As it''s reactive, we don''t need to do anything
    on the file-server side because the file is already deleted. Also, there''s no
    need to delete any backups, as this allows us to recover. Next, let''s look at
    our function that updates an existing file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This function essentially overwrites any values in Couchbase with new ones,
    copying an existing `File` struct and changing the `LastModified` date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we react to any changes to the filesystem in our watched directory. We
    aren''t reacting to renames, but you can handle those as well. Here''s how we''d
    approach the general `updateFile` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Checking records against Couchbase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to checking for existing records against Couchbase, we check
    whether a hash exists in our Couchbase bucket. If it doesn''t, we create it. If
    it does, we do nothing. To handle shutdowns more robustly, we should also ingest
    existing records into our application. The code for doing this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Finally, `main()` handles setting up our connections and goroutines, including
    a file watcher, our TCP server, and connecting to Couchbase.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at another step in the whole process where we will automatically
    create backups of our modified files.
  prefs: []
  type: TYPE_NORMAL
- en: Backing up our files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we're sending our commands on the wire, so to speak, our backup process
    needs to listen on that wire and respond with any changes. Given that modifications
    will be sent via localhost, we should have minimal latency on both the network
    and the file side.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also return some information as to what happened with the file, although
    at this point we''re not doing much with that information. The code for this is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have a separate folder for backups, in this case, on a Windows
    machine. If we happen to accidentally use the same directory, we run the risk
    of infinitely duplicating and backing up files. In the following code snippet,
    we''ll look at the `Message` struct itself and the `backup` function, the core
    of this part of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our basic file operation. Go doesn''t have a one-step copy function;
    instead you need to create a file and then copy the contents of another file into
    it with `io.Copy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is nearly verbatim for our chat client''s `listen()` function, except
    that we take the contents of the streamed JSON data, unmarshal it, and convert
    it to a `Message{}` struct and then a `File{}` struct. Finally, let''s look at
    the `main` function and TCP initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Designing our web interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To interact with the filesystem, we'll want an interface that displays all of
    the current files with the version, last modified time, and alerts to changes,
    and allows drag-and-drop creation/replacement of files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a list of files will be simple, as we'll grab them directly from our
    `file_manager` Couchbase bucket. Changes will be sent through our file manager
    process via TCP, which will trigger an API call, illuminating changes to the file
    for our web user.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few of the methods we''ve used here are duplicates of the ones we used in
    the backup process and could certainly benefit from some consolidation; still,
    the following is the code for the web server, which allows uploads and shows notifications
    for changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This, for example, is the same `File` struct we use in both the file listener
    and the backup process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Page` struct represents generic web data that gets converted into corresponding
    variables for our web page''s template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `md5` hashing method is the same for this application as well. It''s worth
    noting that we derive a `lastChecked` variable that is the Unix-style timestamp
    from each time we get a signal from our file listener. We use this to compare
    with file changes on the client side to know whether to alert the user on the
    Web. Let''s now look at the `updateFile` function for the web interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same function as our backup process, except that instead of creating
    a duplicate file, we simply overwrite our internal `File` struct to allow it represent
    its updated `LastModified` value when the `/api` is next called. And as with our
    last example, let''s check out the `listen()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is where our message is read, unmarshalled, and set to its hashed map''s
    key. This will create a file if it doesn''t exist or update our current one if
    it does. Next, we''ll look at the `main()` function, which sets up our application
    and the web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In our web server component, `main()` takes control of setting up the connection
    to the file listener and Couchbase and creating a web server (with related routing).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you upload a file by dragging it to the **Drop files here to upload** box,
    within a few seconds you''ll see that the file is noted as changed in the web
    interface, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing our web interface](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We haven't included the code for the client side of the web interface; the key
    points, though, are retrieval via an API. We used a JavaScript library called
    `Dropzone.js` that allows a drag-and-drop upload, and jQuery for API access.
  prefs: []
  type: TYPE_NORMAL
- en: Reverting a file's history – command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final component we''d like to add to this application suite is a command-line
    file revision process. We can keep this one fairly simple, as we know where a
    file is located, where its backups are located, and how to replace the former
    with the latter. As with before, we have some global configuration variables and
    a replication of our `generateHash()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This application accepts up to two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-f`: This denotes the filename'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-r`: This denotes the number of versions to revert'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that this itself creates a new version and thus a backup, so -2 would need
    to become -3, and then -6, and so on in order to continuously back up recursively.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, if you wished to revert `example.txt` back three versions, you
    could use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Using Go in daemons and as a service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A minor note on running something like this part of the application—you'll ideally
    wish to keep these applications as active, restartable services instead of standalone,
    manually executed background processes. Doing so will allow you to keep the application
    active and manage its life from external or server processes.
  prefs: []
  type: TYPE_NORMAL
- en: This sort of application suite would be best suited on a Linux box (or boxes)
    and managed with a daemon manager such as daemontools or Ubuntu's built-in Upstart
    service. The reason for this is that any long-term downtime can result in lost
    data and inconsistency. Even storing file data details in the memory (Couchbase
    and memcached) provides a vulnerability for lost data.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the health of our server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of the many ways to check general server health, we''re in a good position
    here without having to build our own system, thanks in great part to Couchbase
    itself. If you visit the Couchbase web admin, under your cluster, server, and
    bucket views, clicking on any will present some real-time statistics, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking the health of our server](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: These areas are also available via REST if you wish to include them in the application
    to make your logging and error handling more comprehensive.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a top to bottom application suite that is highly concurrent, ropes
    in several third-party libraries, and mitigates potential failures with logging
    and catastrophe recovery.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should have no issue constructing a complex package of software
    with a focus on maintaining concurrency, reliability, and performance in Go. Our
    file monitoring application can be easily modified to do more, use alternative
    services, or scale to a robust, distributed environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a closer look at testing our concurrency and
    throughput, explore the value of panic and recover, as well as dealing with logging
    vital information and errors in a safe, concurrent manner in Go.
  prefs: []
  type: TYPE_NORMAL
