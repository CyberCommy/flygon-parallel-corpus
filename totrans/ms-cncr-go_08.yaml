- en: Chapter 8. Concurrent Application Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, we've designed small bits of concurrent programs, primarily in a single
    piece keeping concurrency largely isolated. What we haven't done yet is tie everything
    together to build something a little more robust, complex, and more daunting to
    manage from an administrator's perspective.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Simple chat applications and web servers are fine and dandy. However, you will
    eventually need more complexity and require external software to meet all of the
    more advanced requirements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we''ll build something that''s satisfied by a few dissonant services:
    a file manager with revision control that supplies web and shell access. Services
    such as Dropbox and Google Drive allow users to keep and share files among peers.
    On the other hand, GitHub and its ilk allow for a similar platform but with the
    critical added benefit of revision control.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Many organizations face problems with the following sharing and distribution
    options:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Limitations on repositories, storage, or number of files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Potential inaccessibility if the services are down
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security concerns, particularly for sensitive information
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple sharing applications such as Dropbox and Google Drive are great at storing
    data without a large amount of revision control options. GitHub is an excellent
    collaborative revision control and distribution system, but comes with many costs
    and the mistakes by developers can lead to large and potentially serious security
    lapses.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: We'll be combining the aims of version control (and the GitHub ideal) with Dropbox's
    / Google Drive's simplicity and openness. This type of application will be perfect
    as an intranet replacement—wholly isolated and accessible with custom authentication
    that doesn't necessarily rely on cloud services. The ability to keep it all in-house
    removes any potential for network security concerns and allows an administrator
    to design permanent backup solutions in a way that fits their organization.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: File sharing within the organization will allows forking, backups, file locking,
    and revision control all from the command line but also through a simple web interface.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Designing our concurrent application
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When designing a concurrent application, we will have three components running
    in separate processes. A file listener will be alerted to make changes to files
    in specified locations. A web-CLI interface will allow users to augment or modify
    files, and a backup process will be bound to the listener to provide automated
    copies of new file changes. With that in mind, these three processes will look
    a bit like what is shown in the following diagram:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing our concurrent application](img/00047.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: 'Our file listener process will do the following three things:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Keep an eye on any file changes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Broadcast to our web/CLI servers and the backup process
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintain the state of any given file in our database / data store
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The backup process will accept any broadcasts from the file listener (#2) and
    create a backup file in an iterative design.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Our general server (web and CLI) will report details on individual files and
    allow versioning forward and backward with a customizable syntax. This part of
    the application will also have to broadcast back to the file listener when new
    files are committed or revisions are requested.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Identifying our requirements
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most critical step in our architectural design process is really zooming
    in on the required features, packages, and technologies that we''ll need to implement.
    For our file management and revision control application, there are a few key
    points that will stand out:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: A web interface that allows file uploads, downloads, and revisions.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A command-line interface that allows us to roll back changes and modify files
    directly.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A filesystem listener that finds changes made to a shared location.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A data store system that has strong Go tie-in and allows us to maintain information
    about files and users in a mostly consistent manner. This system will also maintain
    user records.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A concurrent log system that maintains and cycles logs of changed files.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''re somewhat complicating things by allowing the following three different
    ways to interface with the overall application:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Via the Web that requires a user and login. This also allows our users to access
    and modify files even if they happen to be somewhere not connected to the shared
    drive.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via the command line. This is archaic but also extremely valuable anytime a
    user is traversing a filesystem, particularly power users not in a GUI.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via the filesystem that changes itself. This is the shared drive mechanism wherein
    we assume that any user with access to this will be making valid modifications
    to any files.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To handle all of this, we can identify a few critical technologies as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: A database or data store to manage revisions to our filesystem. When choosing
    between transactional, ACID-compliant SQL and fast document stores in NoSQL, the
    tradeoff is often performance versus consistency. However, since most of our locking
    mechanism will exist in the application, duplicating locks (even at the row level)
    will add a level of potential slowness and cruft that we don't need. So, we will
    utilize a NoSQL solution.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This solution will need to play well with concurrency.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll be using a web interface, one that brings in powerful and clean routing/muxing
    and plays well with Go's robust built-in templating system.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A filesystem notification library that allows us to monitor changes to files
    as well as backing up revisions.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any solutions we uncover or build to satisfy these requirements will need to
    be highly concurrent and non-blocking. We'll want to make sure that we do not
    allow simultaneous changes to files, including changes to our internal revisions
    themselves.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: With all of this in mind, let's identify our pieces one-by-one and decide how
    they will play in our application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: We'll also present a few alternatives with options that can be swapped without
    compromising the functionality or core requirements. This will allow some flexibility
    in cases where platform or preference makes our primary option unpalatable. Any
    time we're designing an application, it's a good idea to know what else is out
    there in case the software (or terms of its use) change or it is no longer satisfactory
    to use at a future scale.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with our data store.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Using NoSQL as a data store in Go
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the biggest concessions with using NoSQL is, obviously, the lack of standardization
    when it comes to CRUD operations (create, read, update, and delete). SQL has been
    standardized since 1986 and is pretty airtight across a number of databases—from
    MySQL to SQL Server and from Microsoft and Oracle all the way down to PostgreSQL.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more about NoSQL and various NoSQL platforms at [http://nosql-database.org/](http://nosql-database.org/).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Martin Fowler has also written a popular introduction to the concept and some
    use cases in his book *NoSQL Distilled* at [http://martinfowler.com/books/nosql.html](http://martinfowler.com/books/nosql.html).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the NoSQL platform, you can also lose ACID compliance and durability.
    This means that your data is not 100 percent secure—there can be transactional
    loss if a server crashes, if reads happen on outdated or non-existent data, and
    so on. The latter of which is known as a dirty read.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: This is all noteworthy as it applies to our application and with concurrency
    specifically because we've talked about one of those big potential third-party
    bottlenecks in the previous chapters.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: For our file-sharing application in Go, we will utilize NoSQL to store metadata
    about files as well as the users that modify/interact with those files.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: We have quite a few options when it comes to a NoSQL data store to use here,
    and almost all of the big ones have a library or interface in Go. While we're
    going to go with Couchbase here, we'll briefly talk about some of the other big
    players in the game as well as the merits of each.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择NoSQL数据存储时，我们有很多选择，几乎所有主要的数据存储都在Go中有库或接口。虽然我们在这里选择了Couchbase，但我们也会简要讨论一些其他主要的竞争对手以及每个的优点。
- en: The code snippets in the following sections should also give you some idea of
    how to switch out Couchbase for any of the others without too much angst. While
    we don't go deeply into any of them, the code for maintaining the file and modifying
    information will be as generic as possible to ensure easy exchange.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节中的代码片段也应该让你对如何在不太焦虑的情况下将Couchbase替换为其他任何一个有一些想法。虽然我们不会深入研究其中任何一个，但为了确保易于交换，用于维护文件和修改信息的代码将尽可能通用。
- en: MongoDB
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MongoDB
- en: MongoDB is one of the most popular NoSQL platforms available. Written in 2009,
    it's also one of the most mature platforms, but comes with a number of tradeoffs
    that have pushed it somewhat out of favor in the recent years.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是最受欢迎的NoSQL平台之一。它是在2009年编写的，也是最成熟的平台之一，但也带来了一些权衡，这使得它在近年来有些失宠。
- en: Even so, Mongo does what it does in a reliable fashion and with a great deal
    of speed. Utilizing indices, as is the case with most databases and data stores,
    improves query speed on reads greatly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 即便如此，Mongo以可靠的方式完成了它的任务，并且速度非常快。使用索引，就像大多数数据库和数据存储一样，极大地提高了读取的查询速度。
- en: Mongo also allows for some very granular control of guarantees as they apply
    to reads, writes, and consistency. You can think of this as a very vague analog
    to any language and/or engine that supports syntactical dirty reads.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Mongo还允许对读取、写入和一致性的保证进行非常精细的控制。你可以将其视为对支持语法脏读的任何语言和/或引擎的非常模糊的类比。
- en: Most importantly, Mongo supports concurrency easily within Go and is implicitly
    designed to work in distributed systems.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，Mongo在Go中很容易支持并发，并且隐式地设计用于分布式系统。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The biggest Go interface for Mongo is `mgo`, which is available at: [http://godoc.org/labix.org/v2/mgo](http://godoc.org/labix.org/v2/mgo).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Mongo的最大Go接口是`mgo`，可以在以下网址找到：[http://godoc.org/labix.org/v2/mgo](http://godoc.org/labix.org/v2/mgo)。
- en: 'Should you wish to experiment with Mongo in Go, it''s a relatively straightforward
    process to take your data store record and inject it into a custom struct. The
    following is a quick and dirty example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在Go中尝试Mongo，将数据存储记录注入自定义结构是一个相对简单的过程。以下是一个快速而简单的例子：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: One downside to Mongo compared to other NoSQL solutions is that it does not
    come with any GUI by default. This means we either need to tie in another application
    or web service, or stick to the command line to manage its data store. For many
    applications, this isn't a big deal, but we want to keep this project as compartmentalized
    and provincial as possible to limit points of failure.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他NoSQL解决方案相比，Mongo的一个缺点是它默认没有任何GUI。这意味着我们要么需要绑定另一个应用程序或Web服务，要么坚持使用命令行来管理其数据存储。对于许多应用程序来说，这并不是什么大问题，但我们希望尽可能地将这个项目分隔和局部化，以限制故障点。
- en: Mongo has also gotten a bit of a bad rap as it pertains to fault tolerance and
    data loss, but this is equally true of many NoSQL solutions. In addition, it's
    in many ways a feature of a fast data store—so often catastrophe recovery comes
    at the expense of speed and performance.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Mongo在容错性和数据丢失方面也有点名声不佳，但这同样适用于许多NoSQL解决方案。此外，这在很多方面是一个快速数据存储的特性——因此，灾难恢复往往是以速度和性能为代价的。
- en: It's also fair to say this is a generally overblown critique of Mongo and its
    peers. Can something bad happen with Mongo? Sure. Can it also happen with a managed
    Oracle-based system? Absolutely. Mitigating massive failures in this realm is
    more the responsibility of a systems administrator than the software itself, which
    can only provide the tools necessary to design such a contingency plan.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说这是对Mongo及其同行的一种普遍夸大的批评。Mongo会出现问题吗？当然会。管理的基于Oracle的系统也会出现问题吗？当然会。在这个领域减轻大规模故障更多地是系统管理员的责任，而不是软件本身，后者只能提供设计这样的应急计划所需的工具。
- en: All that said, we'll want something with a quick and highly-available management
    interface, so Mongo is out for our requirements but could easily be plugged into
    this solution if those are less highly valued.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们希望有一个快速和高可用的管理界面，因此Mongo不符合我们的要求，但如果这些要求不那么受重视，它可以很容易地插入到这个解决方案中。
- en: Redis
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redis
- en: Redis is another key/value data store and, as of recently, took the number one
    spot in terms of total usage and popularity. In an ideal Redis world, an entire
    dataset is held in memory. Given the size of many datasets, this isn't always
    possible; however, coupled with Redis' ability to eschew durability, this can
    result in some very high performance results when used in concurrent applications.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Redis是另一个键/值数据存储，最近成为了总使用量和受欢迎程度方面的第一名。在理想的Redis世界中，整个数据集都保存在内存中。鉴于许多数据集的大小，这并不总是可能的；然而，结合Redis的能力来摒弃持久性，当在并发应用程序中使用时，这可能会产生一些非常高性能的结果。
- en: Another useful feature of Redis is the fact that it can inherently hold different
    data structures. While you can make abstractions of such data by unmarshalling
    JSON objects/arrays in Mongo (and other data stores), Redis can handle sets, strings,
    arrays, and hashes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Redis的另一个有用的特性是它可以固有地保存不同的数据结构。虽然你可以通过在Mongo（和其他数据存储）中取消编组JSON对象/数组来对这些数据进行抽象，但Redis可以处理集合、字符串、数组和哈希。
- en: 'There are two major accepted libraries for Redis in Go:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，有两个主要被接受的Redis库：
- en: '**Radix**: This is a minimalist client that''s barebones, quick, and dirty.
    To install Radix, run the following command:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Radix**：这是一个极简主义的客户端，简洁、快速而简单。要安装Radix，请运行以下命令：'
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Redigo**: This more robust and a bit more complex, but provides a lot of
    the more intricate functionality that we''ll probably not need for this project.
    To install Redigo, run the following command:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Redigo**：这更加强大，稍微复杂一些，但提供了许多更复杂的功能，我们可能在这个项目中不需要。要安装Redigo，请运行以下命令：'
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We''ll now see a quick example of getting a user''s name from the data store
    of `Users` in Redis using Redigo:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看一个快速的例子，使用Redigo从Redis的`Users`数据存储中获取用户的名称：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Looking over this, you might note some non programmatic access syntax, such
    as the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查这一点时，您可能会注意到一些非程序访问语法，例如以下内容：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is indeed one of the reasons why Redis in Go will not be our choice for
    this project—both libraries here provide an almost API-level access to certain
    features with some more detailed built-ins for direct interaction. The `Do` command
    passes straight queries directly to Redis, which is fine if you need to use the
    library, but a somewhat inelegant solution across the board.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是为什么Go中的Redis不会成为我们这个项目的选择之一的原因之一——这两个库都提供了对某些功能的几乎API级别的访问，还提供了一些更详细的内置功能，用于直接交互。`Do`命令直接将查询传递给Redis，如果需要使用库，这是可以的，但在整体上是一个不太优雅的解决方案。
- en: Both the libraries play very nicely with the concurrent features of Go, and
    you'll have no problem making non-blocking networked calls to Redis through either
    of them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个库都非常好地与Go的并发特性配合，您在通过它们之一进行非阻塞网络调用到Redis时不会遇到任何问题。
- en: It's worth noting that Redis only supports an experimental build for Windows,
    so this is mostly for use on *nix platforms. The port that does exist comes from
    Microsoft and can be found at [https://github.com/MSOpenTech/redis](https://github.com/MSOpenTech/redis).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Redis仅支持Windows的实验性构建，因此这主要用于*nix平台。现有的端口来自Microsoft，可以在[https://github.com/MSOpenTech/redis](https://github.com/MSOpenTech/redis)找到。
- en: Tiedot
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tiedot
- en: If you've worked a lot with NoSQL, then the preceding engines all likely seemed
    very familiar to you. Redis, Couch, Mongo, and so on are all virtual stalwarts
    in what is a relatively young technology.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经大量使用NoSQL，那么前面提到的引擎对您来说可能都很熟悉。Redis、Couch、Mongo等在这个相对年轻的技术中都是虚拟的支柱。
- en: Tiedot, on the other hand, probably isn't as familiar. We're including it here
    only because the document store itself is written in Go directly. Document manipulation
    is handled primarily through a web interface, and it's a JSON document store like
    several other NoSQL solutions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Tiedot可能不太熟悉。我们在这里包括它，只是因为文档存储本身是直接用Go编写的。文档操作主要通过Web界面处理，它是一个像其他几种NoSQL解决方案一样的JSON文档存储。
- en: 'As document access and handling is governed via HTTP, there''s a somewhat counterintuitive
    workflow, shown as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文档访问和处理是通过HTTP进行的，所以工作流程有点违反直觉，如下所示：
- en: '![Tiedot](img/00048.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![Tiedot](img/00048.jpeg)'
- en: As that introduces a potential spot for latency or failure, this keeps from
    being an ideal solution for our application here. Keep in mind that this is also
    a feature of a few of the other solutions mentioned earlier, but since Tiedot
    is written in Go, it would be significantly easier to connect to it and read/modify
    data using a package. While this book was being written, this did not exist.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这引入了潜在的延迟或故障点，这使得它不是我们这里的理想解决方案。请记住，这也是之前提到的一些其他解决方案的特点，但由于Tiedot是用Go编写的，因此连接到它并使用包读取/修改数据将会更容易。在撰写本书时，这是不存在的。
- en: Unlike other HTTP- or REST-focused alternatives such as CouchDB, Tiedot relies
    on URL endpoints to dictate actions, not HTTP methods.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与CouchDB等基于HTTP或REST的替代方案不同，Tiedot依赖于URL端点来指示操作，而不是HTTP方法。
- en: 'You can see in the following code how we might handle something like this through
    standard libraries:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下代码中看到我们如何通过标准库处理类似的事情：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This, simply, is a data structure for any record you wish to bring into your
    Go application via data selects, queries, and so on. You saw this in our previous
    usage of SQL servers themselves, and this is not any different:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地说，这是您希望通过数据选择、查询等方式引入到Go应用程序中的任何记录的数据结构。您在我们之前使用SQL服务器本身时看到了这一点，这并没有什么不同：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While not as robust, powerful, or scalable as many of its peers, Tiedot is certainly
    worth playing with or, better yet, contributing to.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不像许多同行那样健壮、强大或可扩展，Tiedot肯定值得玩耍，或者更好的是，值得贡献。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find Tiedot at [https://github.com/HouzuoGuo/tiedot](https://github.com/HouzuoGuo/tiedot).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/HouzuoGuo/tiedot](https://github.com/HouzuoGuo/tiedot)找到Tiedot。
- en: CouchDB
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CouchDB
- en: CouchDB from Apache Incubator is another one of the big boys in NoSQL big data.
    As a JSON document store, CouchDB offers a great deal of flexibility when it comes
    to your data store approach.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Apache孵化器的CouchDB是NoSQL大数据中的另一个重要角色。作为一个JSON文档存储，CouchDB在数据存储方法方面提供了很大的灵活性。
- en: CouchDB supports ACID semantics and can do so concurrently, which provides a
    great deal of performance benefit if one is bound to those properties. In our
    application, that reliance on ACID consistency is somewhat flexible. By design,
    it will be failure tolerant and recoverable, but for many, even the possibility
    of data loss with recoverability is still considered catastrophic.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: CouchDB支持ACID语义，并且可以同时执行，这在某种程度上提供了很大的性能优势。在我们的应用程序中，对ACID一致性的依赖性是相对灵活的。从设计上讲，它将是容错和可恢复的，但对于许多人来说，即使是可恢复的数据丢失的可能性仍然被认为是灾难性的。
- en: 'Interfacing with CouchDB happens via HTTP, which means there is no need for
    a direct implementation or Go SQL database hook to use it. Interestingly, CouchDB
    uses HTTP header syntax to manipulate data, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与CouchDB的接口是通过HTTP进行的，这意味着不需要直接实现或Go SQL数据库钩子来使用它。有趣的是，CouchDB使用HTTP头语法来操作数据，如下所示：
- en: '**GET**: This represents read operations'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET**：这代表读取操作'
- en: '**PUT**: This represents creation operations'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PUT**：这代表创建操作'
- en: '**DELETE**: This represents deletion and update operations'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DELETE**：这代表删除和更新操作'
- en: These are, of course, what the header methods were initially intended in HTTP
    1.1, but so much of the Web has focused on GET/POST that these tend to get lost
    in the fray.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些最初是在HTTP 1.1中的标头方法，但是Web的很多部分都集中在GET/POST上，这些方法往往会在混乱中失去。
- en: 'Couch also comes with a convenient web interface for management. When CouchDB
    is running, you''re able to access this at `http://localhost:5984/_utils/`, as
    shown in the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Couch还配备了一个方便的Web界面进行管理。当CouchDB运行时，您可以在`http://localhost:5984/_utils/`访问它，如下面的截图所示：
- en: '![CouchDB](img/00049.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![CouchDB](img/00049.jpeg)'
- en: That said, there are a few wrappers that provide a level of abstraction for
    some of the more complicated and advanced features.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，有一些包装器为一些更复杂和高级的功能提供了一定程度的抽象。
- en: Cassandra
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cassandra
- en: Cassandra, another Apache Foundation project, isn't technically a NoSQL solution
    but a clustered (or cluster-able) database management platform.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra，作为Apache基金会的另一个项目，技术上并不是一个NoSQL解决方案，而是一个集群（或可集群化）的数据库管理平台。
- en: Like many NoSQL applications, there is a limitation in the traditional query
    methods in Cassandra, for example, subqueries and joins are generally not supported.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多NoSQL应用程序一样，Cassandra的传统查询方法存在一些限制，例如，通常不支持子查询和连接。
- en: We're mentioning it here primarily because of its focus on distributed computing
    as well as the ability to programmatically tune whether data consistency or performance
    is more important. Much of that is equally expressed in our solution, Couchbase,
    but Cassandra has a deeper focus on distributed data stores.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里提到它主要是因为它专注于分布式计算以及以编程方式调整数据一致性或性能的能力。Couchbase同样也表达了很多这些内容，但Cassandra更加专注于分布式数据存储。
- en: Cassandra does, however, support a subset of SQL that will make it far more
    familiar to developers who have dabbled in MySQL, PostgreSQL, or the ilk. Cassandra's
    built-in handling of highly concurrent integrations makes it in many ways ideal
    for Go, although it is an overkill for this project.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Cassandra支持一部分SQL，这将使它对于那些涉足过MySQL、PostgreSQL或类似数据库的开发人员来说更加熟悉。Cassandra对高并发集成的内置处理在很多方面使其对Go来说是理想的，尽管对于这个项目来说有些过度。
- en: The most noteworthy library to interface with Cassandra is gocql, which focuses
    on speed and a clean connection to the Cassandra connection. Should you choose
    to use Cassandra in lieu of Couchbase (or other NoSQL), you'll find a lot of the
    methods that can be simply replaced.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与Cassandra进行接口的最值得注意的库是gocql，它专注于速度和与Cassandra连接的清晰性。如果您选择使用Cassandra而不是Couchbase（或其他NoSQL），您会发现许多方法可以简单地替换。
- en: 'The following is an example of connecting to a cluster and writing a simple
    query:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是连接到集群并编写简单查询的示例：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Cassandra may be an ideal solution if you plan on rapidly scaling this application,
    distributing it widely, or are far more comfortable with SQL than data store /
    JSON access.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划快速扩展此应用程序、广泛分发它，或者对SQL比数据存储/JSON访问更熟悉，那么Cassandra可能是一个理想的解决方案。
- en: For our purposes here, SQL is not a requirement and we value speed over anything
    else, including durability.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的来说，SQL不是必需的，我们更看重速度，包括耐久性在内。
- en: Couchbase
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Couchbase
- en: Couchbase is a relative newcomer in the field, but it was built by people from
    both CouchDB and memcached. Written in Erlang, it shares many of the same focuses
    on concurrency, speed, and non-blocking behavior that we've come to expect from
    a great deal of our Go applications.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Couchbase是该领域的一个相对新手，但它是由CouchDB和memcached的开发人员构建的。它是用Erlang编写的，与我们期望从我们的许多Go应用程序中获得的并发性、速度和非阻塞行为有许多相同的关注点。
- en: Couchbase also supports a lot of the other features we've discussed in the previous
    chapters, including easy distribution-based installations, tuneable ACID compliance,
    and low-resource consumption.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Couchbase还支持我们在前几章中讨论的许多其他功能，包括易于分发的安装、可调的ACID兼容性和低资源消耗。
- en: One caveat on Couchbase is it doesn't run well (or at all) on some lower-resourced
    machines or VMs. Indeed, 64-bit installations require an absolute minimum of 4
    GB of memory and four cores, so forget about launching this on tiny, small, or
    even medium-grade instances or older hardware.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Couchbase的一个缺点是它在一些资源较低的机器或虚拟机上运行效果不佳（或根本无法运行）。确实，64位安装至少需要4GB内存和四个核心，所以不要指望在小型、中小型实例或旧硬件上启动它。
- en: While most NoSQL solutions presented here (or elsewhere) offer performance benefits
    over their SQL counterparts in general, Couchbase has done very well against its
    peers in the NoSQL realm itself.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里（或其他地方）提出的大多数NoSQL解决方案通常比它们的SQL对应方案具有性能优势，但Couchbase在NoSQL领域中表现得非常出色。
- en: Couchbase, such as CouchDB, comes with a web-based graphical interface that
    simplifies the process of both setup and maintenance. Among the advanced features
    that you'll have available to you in the setup include your base bucket storage
    engine (Couchbase or memcached), your automated backup process (replicas), and
    the level of read-write concurrency.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Couchbase，如CouchDB一样，配备了一个基于Web的图形界面，简化了设置和维护的过程。在设置中，您可以使用的高级功能包括基本存储引擎（Couchbase或memcached）、自动备份过程（副本）和读写并发级别。
- en: 'In addition to configuration and management tools, it also presents some real-time
    monitoring in the web dashboard as shown in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了配置和管理工具，它还在Web仪表板中提供了一些实时监控，如下面的截图所示：
- en: '![Couchbase](img/00050.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![Couchbase](img/00050.jpeg)'
- en: While not a replacement for full-scale server management (what happens when
    this server goes down and you have no insight), it's incredibly helpful to know
    exactly where your resources are going without needing a command-line method or
    an external tool.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不能完全替代完整的服务器管理（当服务器宕机时，你没有洞察力会发生什么），但知道你的资源究竟去了哪里，而不需要命令行方法或外部工具，这非常有帮助。
- en: The vernacular in Couchbase varies slightly, as it tends to in many of these
    solutions. The nascent desire to slightly separate NoSQL from stodgy old SQL solutions
    will pop its head from time to time.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: With Couchbase, a database is a data bucket and records are documents. However,
    views, an old transactional SQL standby, bring a bit of familiarity to the table.
    The big takeaway here is views allow you to create more complex queries using
    simple JavaScript, in some cases, replicating otherwise difficult features such
    as joins, unions, and pagination.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Each view created in Couchbase becomes an HTTP access point. So a view that
    you name `select_all_files` will be accessible via a URL such as `http://localhost:8092/file_manager/_design/select_all_files/_view/Select%20All%20Files?connection_timeout=60000&limit=10&skip=0`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The most noteworthy Couchbase interface library is Go Couchbase, which, if nothing
    else, might save you from some of the redundancy of making HTTP calls in your
    code to access CouchDB.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go Couchbase can be found at [https://github.com/couchbaselabs/go-couchbase](https://github.com/couchbaselabs/go-couchbase).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Go Couchbase makes interfacing with Couchbase through a Go abstraction simple
    and powerful. The following code connects and grabs information about the various
    data pools in a lean way that feels native:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Setting up our data store
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After installing Couchbase, you can access its administration panel by default
    at localhost and port 8091.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: You'll be given an opportunity to set up an administrator, other IPs to connect
    (if you're joining a cluster), and general data store design.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you''ll need to set up a bucket, which is what we''ll use to store
    all information about individual files. Here is what the interface for the bucket
    setup looks like:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up our data store](img/00051.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: In our example, we're working on a single machine, so replicas (also known as
    replication in database vernacular) are not supported. We've named it `file_manager`,
    but this can obviously be called anything that makes sense.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: We're also keeping our data usage pretty low—there's no need for much more than
    256 MB of memory when we're storing file operations and logging older ones. In
    other words, we're not necessarily concerned with keeping the modification history
    of `test.txt` in memory forever.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: We'll also stick with Couchbase for a storage engine equivalent, although you
    can flip back and forth with memcache(d) without much noticeable change.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a seed document: one we''ll delete later, but that
    will represent the schema of our data store. We can create this document with
    an arbitrary JSON structured object, as shown in the following screenshot:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up our data store](img/00052.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: 'Since everything stored in this data store should be valid JSON, we can mix
    and match strings, integers, bools, arrays, and objects. This affords us some
    flexibility in what data we''re using. The following is an example document:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Monitoring filesystem changes
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it came to NoSQL options, we had a vast variety of solutions at our disposal.
    This is not the case when it comes to applications that monitor filesystem changes.
    While Linux flavors have a fairly good built-in solution in inotify, this does
    restrict the portability of the application.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: So it's incredibly helpful that a cross-platform library for handling this exists
    in Chris Howey's fsnotify.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Fsnotify works on Linux, OSX, and Windows and allows us to detect when files
    in any given directory are created, deleted, modified, or renamed, which is more
    than enough for our purposes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Implementing fsnotify couldn't be easier, either. Best of all it's all non-blocking,
    so if we throw the listener behind a goroutine, we can have this run as part of
    the primary server application code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows a simple directory listener:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Managing logfiles
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like many basic features in a developer's toolbox, Go provides a fairly complete
    solution built-in for logging. It handles many of the basics, such as creating
    timestamp-marked log items and saving to disk or to console.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多开发人员工具箱中的基本功能一样，Go提供了一个相当完整的内置日志记录解决方案。它处理许多基本功能，例如创建时间戳标记的日志项并保存到磁盘或控制台。
- en: One thing the basic package misses out on is built-in formatting and log rotation,
    which are key requirements for our file manager application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 基本包遗漏的一件事是内置格式化和日志轮换，这是我们的文件管理器应用程序的关键要求。
- en: Remember that key requirements for our application include the ability to work
    seamlessly in our concurrent environment and be ready to scale to a distributed
    network if need be. This is where the fine **log4go** application comes in handy.
    Log4go allows logging to file, console, and memory and handles log rotation inherently.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们的应用程序的关键要求包括能够在并发环境中无缝工作，并且在需要时能够准备好扩展到分布式网络。这就是fine **log4go**应用程序派上用场的地方。Log4go允许将日志记录到文件、控制台和内存，并且内在地处理日志轮换。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Log4go can be found at [https://code.google.com/p/log4go/](https://code.google.com/p/log4go/).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Log4go可以在[https://code.google.com/p/log4go/](https://code.google.com/p/log4go/)找到。
- en: 'To install Log4go, run the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Log4go，请运行以下命令：
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Creating a logfile that handles warnings, notices, debug information, and critical
    errors is simple and appending log rotation to that is similarly simple, as shown
    in the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个处理警告、通知、调试信息和关键错误的日志文件很简单，并且将日志轮换附加到其中同样简单，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Handling configuration files
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理配置文件
- en: When it comes to configuration files and parsing them, you have a lot of options,
    from simple to complicated.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理配置文件和解析它们时，您有很多选择，从简单到复杂。
- en: We could, of course, simply store what we want in JSON, but that format is a
    little tricky to work directly for humans—it will require escaping characters
    and so on, which makes it vulnerable to errors.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以简单地将所需内容存储为JSON，但是该格式对于人类来说有点棘手——它需要转义字符等，这使其容易出现错误。
- en: 'Instead, we''ll keep things simple by using a standard `ini config` file library
    in gcfg, which handles `gitconfig` files and traditional, old school `.ini` format,
    as shown in the following code snippet:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将使用gcfg中的标准`ini config`文件库来简化事务，该库处理`gitconfig`文件和传统的旧式`.ini`格式，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find gcfg at [https://code.google.com/p/gcfg/](https://code.google.com/p/gcfg/).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://code.google.com/p/gcfg/](https://code.google.com/p/gcfg/)找到gcfg。
- en: 'Essentially, this library takes the values of a config file and pushes them
    into a struct in Go. An example of how we''ll do that is as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，该库获取配置文件的值并将其推送到Go中的结构体中。我们将如何做到这一点的示例如下：
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Detecting file changes
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测文件更改
- en: Now we need to focus on our file listener. You may recall this is the part of
    the application that will accept client connections from our web server and our
    backup application and announce any changes to files.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要专注于我们的文件监听器。您可能还记得，这是应用程序的一部分，它将接受来自我们的Web服务器和备份应用程序的客户端连接，并通知文件的任何更改。
- en: 'The basic flow of this part is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分的基本流程如下：
- en: Listen for changes to files in a goroutine.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在goroutine中监听文件的更改。
- en: Accept connections and add to the pool in a goroutine.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在goroutine中接受连接并添加到池中。
- en: If any changes are detected, announce them to the entire pool.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果检测到任何更改，则向整个池通知它们。
- en: All three happen concurrently, and the first and the third can happen without
    any connections in the pool, although we assume there will be a connection that
    is always on with both our web server and our backup application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个操作同时发生，第一个和第三个操作可以在池中没有任何连接的情况下发生，尽管我们假设总会有一个连接始终与我们的Web服务器和备份应用程序保持连接。
- en: 'Another critical role the file listener will fulfill is analyzing the directory
    on first load and reconciling it with our data store in Couchbase. Since the Go
    Couchbase library handles the get, update, and add operations, we won''t need
    any custom views. In the following code, we''ll examine the file listener process
    and show how we listen on a folder for changes:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 文件监听器将扮演的另一个关键角色是在首次加载时分析目录并将其与我们在Couchbase中的数据存储进行协调。由于Go Couchbase库处理获取、更新和添加操作，我们不需要任何自定义视图。在下面的代码中，我们将检查文件监听器进程，并展示如何监听文件夹的更改：
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we''ve declared our shared folder as well as a connecting `Client` struct.
    In this application, `Client` is either a web listener or a backup listener, and
    we''ll pass messages in one direction using the following JSON-encoded structure:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了我们的共享文件夹以及一个连接的`Client`结构。在这个应用程序中，`Client`可以是Web监听器或备份监听器，并且我们将使用以下JSON编码结构单向传递消息：
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If this looks familiar, it could be because it's also the example document format
    we set up initially.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来很熟悉，那可能是因为这也是我们最初设置的示例文档格式。
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're not familiar with the syntactical sugar expressed earlier, these are
    known as struct tags. A tag is just a piece of additional metadata that can be
    applied to a struct field for key/value lookups via the `reflect` package. In
    this case, they're used to map our struct fields to JSON fields.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对之前表达的语法糖不熟悉，这些被称为结构标签。标签只是可以应用于结构字段的附加元数据，以便通过`reflect`包进行键/值查找。在这种情况下，它们用于将我们的结构字段映射到JSON字段。
- en: 'Let''s first look at our overall `Message struct`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下我们的整体`Message struct`：
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We compartmentalize our file into a message, which alerts our other two processes
    of changes:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的文件分成一个消息，用于通知我们的其他两个进程发生了更改：
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is a somewhat unreliable method to generate a hash reference to a file
    and will fail if a filename changes. However, it allows us to keep track of files
    that are created, deleted, or modified.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种相对不可靠的方法，用于生成文件的哈希引用，如果文件名更改，它将失败。但是，它允许我们跟踪创建、删除或修改的文件。
- en: Sending changes to clients
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向客户端发送更改
- en: 'Here is the broadcast message that goes to all existing connections. We pass
    along our JSON-encoded `Message` struct with the current version, the current
    location, and the hash for reference. Our other servers will then react accordingly:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our backup server will create a copy of that file with the `.[VERSION]` extension
    in the backup folder.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Our web server will simply alert the user via our web interface that the file
    has changed:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Does this code look familiar? We''ve taken almost our exact chat server `Client`
    handler and brought it over here nearly intact:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `removeFile` function does one thing only and that''s removing the file
    from our Couchbase data store. As it''s reactive, we don''t need to do anything
    on the file-server side because the file is already deleted. Also, there''s no
    need to delete any backups, as this allows us to recover. Next, let''s look at
    our function that updates an existing file:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This function essentially overwrites any values in Couchbase with new ones,
    copying an existing `File` struct and changing the `LastModified` date:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we react to any changes to the filesystem in our watched directory. We
    aren''t reacting to renames, but you can handle those as well. Here''s how we''d
    approach the general `updateFile` function:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Checking records against Couchbase
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to checking for existing records against Couchbase, we check
    whether a hash exists in our Couchbase bucket. If it doesn''t, we create it. If
    it does, we do nothing. To handle shutdowns more robustly, we should also ingest
    existing records into our application. The code for doing this is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, `main()` handles setting up our connections and goroutines, including
    a file watcher, our TCP server, and connecting to Couchbase.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at another step in the whole process where we will automatically
    create backups of our modified files.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Backing up our files
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we're sending our commands on the wire, so to speak, our backup process
    needs to listen on that wire and respond with any changes. Given that modifications
    will be sent via localhost, we should have minimal latency on both the network
    and the file side.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also return some information as to what happened with the file, although
    at this point we''re not doing much with that information. The code for this is
    as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that we have a separate folder for backups, in this case, on a Windows
    machine. If we happen to accidentally use the same directory, we run the risk
    of infinitely duplicating and backing up files. In the following code snippet,
    we''ll look at the `Message` struct itself and the `backup` function, the core
    of this part of the application:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here is our basic file operation. Go doesn''t have a one-step copy function;
    instead you need to create a file and then copy the contents of another file into
    it with `io.Copy`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This code is nearly verbatim for our chat client''s `listen()` function, except
    that we take the contents of the streamed JSON data, unmarshal it, and convert
    it to a `Message{}` struct and then a `File{}` struct. Finally, let''s look at
    the `main` function and TCP initialization:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Designing our web interface
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To interact with the filesystem, we'll want an interface that displays all of
    the current files with the version, last modified time, and alerts to changes,
    and allows drag-and-drop creation/replacement of files.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Getting a list of files will be simple, as we'll grab them directly from our
    `file_manager` Couchbase bucket. Changes will be sent through our file manager
    process via TCP, which will trigger an API call, illuminating changes to the file
    for our web user.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'A few of the methods we''ve used here are duplicates of the ones we used in
    the backup process and could certainly benefit from some consolidation; still,
    the following is the code for the web server, which allows uploads and shows notifications
    for changes:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This, for example, is the same `File` struct we use in both the file listener
    and the backup process:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Our `Page` struct represents generic web data that gets converted into corresponding
    variables for our web page''s template:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Our `md5` hashing method is the same for this application as well. It''s worth
    noting that we derive a `lastChecked` variable that is the Unix-style timestamp
    from each time we get a signal from our file listener. We use this to compare
    with file changes on the client side to know whether to alert the user on the
    Web. Let''s now look at the `updateFile` function for the web interface:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is the same function as our backup process, except that instead of creating
    a duplicate file, we simply overwrite our internal `File` struct to allow it represent
    its updated `LastModified` value when the `/api` is next called. And as with our
    last example, let''s check out the `listen()` function:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here is where our message is read, unmarshalled, and set to its hashed map''s
    key. This will create a file if it doesn''t exist or update our current one if
    it does. Next, we''ll look at the `main()` function, which sets up our application
    and the web server:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In our web server component, `main()` takes control of setting up the connection
    to the file listener and Couchbase and creating a web server (with related routing).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'If you upload a file by dragging it to the **Drop files here to upload** box,
    within a few seconds you''ll see that the file is noted as changed in the web
    interface, as shown in the following screenshot:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing our web interface](img/00053.jpeg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: We haven't included the code for the client side of the web interface; the key
    points, though, are retrieval via an API. We used a JavaScript library called
    `Dropzone.js` that allows a drag-and-drop upload, and jQuery for API access.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Reverting a file's history – command line
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final component we''d like to add to this application suite is a command-line
    file revision process. We can keep this one fairly simple, as we know where a
    file is located, where its backups are located, and how to replace the former
    with the latter. As with before, we have some global configuration variables and
    a replication of our `generateHash()` function:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This application accepts up to two parameters:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '`-f`: This denotes the filename'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-r`: This denotes the number of versions to revert'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that this itself creates a new version and thus a backup, so -2 would need
    to become -3, and then -6, and so on in order to continuously back up recursively.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, if you wished to revert `example.txt` back three versions, you
    could use the following command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Using Go in daemons and as a service
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A minor note on running something like this part of the application—you'll ideally
    wish to keep these applications as active, restartable services instead of standalone,
    manually executed background processes. Doing so will allow you to keep the application
    active and manage its life from external or server processes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: This sort of application suite would be best suited on a Linux box (or boxes)
    and managed with a daemon manager such as daemontools or Ubuntu's built-in Upstart
    service. The reason for this is that any long-term downtime can result in lost
    data and inconsistency. Even storing file data details in the memory (Couchbase
    and memcached) provides a vulnerability for lost data.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Checking the health of our server
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of the many ways to check general server health, we''re in a good position
    here without having to build our own system, thanks in great part to Couchbase
    itself. If you visit the Couchbase web admin, under your cluster, server, and
    bucket views, clicking on any will present some real-time statistics, as shown
    in the following screenshot:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking the health of our server](img/00054.jpeg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
- en: These areas are also available via REST if you wish to include them in the application
    to make your logging and error handling more comprehensive.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a top to bottom application suite that is highly concurrent, ropes
    in several third-party libraries, and mitigates potential failures with logging
    and catastrophe recovery.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有一个从头到尾高度并发的应用程序套件，涉及多个第三方库，并通过记录和灾难恢复来减轻潜在的故障。
- en: At this point, you should have no issue constructing a complex package of software
    with a focus on maintaining concurrency, reliability, and performance in Go. Our
    file monitoring application can be easily modified to do more, use alternative
    services, or scale to a robust, distributed environment.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，你应该没有问题构建一个以Go语言为重点，专注于维护并发性、可靠性和性能的复杂软件包。我们的文件监控应用程序可以很容易地修改以执行更多操作，使用替代服务，或者扩展到一个强大的分布式环境。
- en: In the next chapter, we'll take a closer look at testing our concurrency and
    throughput, explore the value of panic and recover, as well as dealing with logging
    vital information and errors in a safe, concurrent manner in Go.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更仔细地测试我们的并发性和吞吐量，探讨panic和recover的价值，以及在Go语言中以安全并发的方式处理记录重要信息和错误。
