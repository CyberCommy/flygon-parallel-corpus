- en: Chapter 11. Best Practices and Conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will teach you to stand out among the rest of the developers. This
    is possible by developing and executing the strategies learned in this book with
    style, and by following concrete standards.
  prefs: []
  type: TYPE_NORMAL
- en: Code versioning best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over time, your application will evolve and, at some point, you will be at the
    point where you are wondering what you will do with the API of any of your microservices.
    You can keep the changes to a minimum and be transparent to the users of your
    API, or you can create different versions of your code. The best solution is versioning
    your code (API).
  prefs: []
  type: TYPE_NORMAL
- en: 'The well-known and commonly used ways for code versioning are as listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL**: In this method, you add the version of your API inside the URL of
    the requests. For example, the `https://phpmicroservices.com/api/v2/user` URL
    indicates that we are using the `v2` of our API. We used this method in our examples
    throughout the book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom request header**: In this method, we do not specify the version in
    our URL. Instead, we use HTTP headers to specify the version we want to use. For
    instance, we can do a HTTP call to `https://phpmicroservices.com/api/user`, but
    with an extra header, `"api-version: 2"`. In this case, our server will check
    the HTTP header and use the `v2` of our API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accept header**: This method is very similar to the previous one, but instead
    of using a custom header, we will use the `Accept` header. For our example, we
    will make a call to `https://phpmicroservices.com/api/user` but our Accept header
    will be `"Accept: application/vnd.phpmicroservices.v2+json"`. In this case, we
    are indicating that we want version 2 and the data will be on JSON.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can imagine, the easiest way to implement versioning in your code is
    with the version code inside your URL but, unfortunately, that is not considered
    the best option. What most developers consider the best way of versioning your
    code is to use HTTP headers to specify the version you want to use. Our recommendation
    is to use the method that suits your project best. Analyze who will use your APIs
    and how, and you will discover the versioning method you need to use.
  prefs: []
  type: TYPE_NORMAL
- en: Caching best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A cache is a place where you can store temporal data; it is used to increase
    the performance of the applications. Here, you can find some small tips to help
    you with your cache.
  prefs: []
  type: TYPE_NORMAL
- en: Performance impact
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding a cache layer to your application always has a performance impact that
    you need to measure. It does not matter where you are adding the cache layer in
    your application. You need to measure the impact to know if the new cache layer
    is a good choice. First, make some metrics without the cache layer and, as soon
    as you have some stats, enable the cache layer and compare the result. Sometimes
    you can find that the benefit of a cache layer becomes a hell of management to
    keep the cache running. You can use some of the monitoring services we talked
    about in the previous chapters to monitor the performance impact.
  prefs: []
  type: TYPE_NORMAL
- en: Handle cache misses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A cache miss is when a request is not saved in your cache and the application
    needs to get the data from your service/application. Ensure that your code can
    handle cache misses and the consequent updates. To keep track of the rate of missing
    cache hits, you can use any monitoring software or even a logging system.
  prefs: []
  type: TYPE_NORMAL
- en: Group requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever possible, try to group your cache requests as much as possible. Imagine
    that your frontend needs five different elements from your cache server to render
    a page. Instead of doing five calls, you can try to group the requests, saving
    you some time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you are using Redis as your cache layer and want to save some
    values in the `foo` and `bar` variables. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of doing that, you can do both the sets in a single transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example will do both the sets in one commit, saving you some time
    and improving the performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Size of elements to be stored in cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is more efficient to store large items in your cache than storing small items.
    If you start caching loads of small items, the overall performance will decrease.
    In this case, the serialization size, time, cache commit time, and capacity usage
    will grow.
  prefs: []
  type: TYPE_NORMAL
- en: Monitor your cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have decided to add a cache layer, at least keep it monitorized. Keeping
    some stats of your cache will help you know how well it is doing (the cache hit
    ratio) or if it is reaching its capacity limit. Most of the cache software is
    stable and robust, but it does not mean that you will not have any problems if
    you keep it unmanaged.
  prefs: []
  type: TYPE_NORMAL
- en: Choose your cache algorithm carefully
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the cache engines support different algorithms. Each algorithm has its
    benefits and its own problems. Our recommendation is to analyze your requirements
    deeply and not use the default mode of the cache engine of your choice until you
    are sure that it's the correct algorithm for your use case.
  prefs: []
  type: TYPE_NORMAL
- en: Performance best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are reading this book, it is probably because you are interested in
    web development and, in the last few years, the importance of the performance
    of web applications (such as APIs) is becoming more and more relevant. Here are some
    stats to give you an idea:'
  prefs: []
  type: TYPE_NORMAL
- en: Amazon reported years ago that for every 100 ms of increase in the loading time,
    their sales decreased by 1%.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google found that reducing the size of the page from 100 KB to 80 KB diminished
    their traffic by 25%.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 57% of online consumers will abandon a site after waiting for 3 seconds for
    a page to load.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 80% of the people who abandoned the site will not return. About a 50% of these
    people will tell others their negative experience.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the performance of your app can impact your users and even your
    revenues. In this section, we will give you some tips to improve the overall performance
    of your web application.
  prefs: []
  type: TYPE_NORMAL
- en: Minimize HTTP requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each HTTP request has a payload. For this reason, an easy way to increase the
    performance is to reduce the number of HTTP requests. You need to have this idea
    in mind in every aspect of your development. Try to do the minimum external calls
    to other services in your APIs/backends. In your frontends, you can combine files
    to attend to only one request. You only need to have a balance between the number
    of requests and the size of each request.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that your frontend has its CSS split in several different files; instead
    of loading each one every time, you can combine them into a single or a few files.
  prefs: []
  type: TYPE_NORMAL
- en: Another quick and small change you can do with HTTP requests is to try to avoid
    `@import` functions in your CSS files. Using link tags instead of `@import` functions
    will allow your browser to download the CSS file in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Minimize HTML, CSS, and JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As developers, we try to code in a format that is easier for us to read--a human-friendly
    format. By developing this way, we are increasing the size of our plain text files
    with unnecessary characters. Unnecessary characters can include white space, comments,
    and newline characters.
  prefs: []
  type: TYPE_NORMAL
- en: We are not saying that you need to write obfuscated code, but as soon as you
    have everything ready, why don't you remove the inessential characters?
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that the content of one of your JavaScript file (`myapp.js`) is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After the minimization, your code can be saved to a different file (`myapp.min.js`)
    and it can look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the new code, we reduced the size of the file around 60%, a huge saving.
    Note that our repository will have both versions of the file: the human-friendly
    to make our changes, and the minimized one, which we will load in our frontend.'
  prefs: []
  type: TYPE_NORMAL
- en: You can do the minimization with online tools, or you can integrate tools such
    as `gulp` or `grunt` in your pipeline. When you have set up these tools, they
    will track the changes of some specific files (CSS, JS, and others) and as soon
    as you save your changes to any of these files, the tool will minimize the content.
    Another hidden benefit of using tools for the minification is that most of them
    also check the code or rename your variables to keep them even smaller.
  prefs: []
  type: TYPE_NORMAL
- en: Image optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most used assets in web development can be the images. They make
    your website look amazing, but they can make your site painfully slow. The main
    recommendation is to keep the number of images to the minimum, but if you need
    to keep images, at least try to optimize them before they are sent to your users.
    In this section, we will show you some things you can do to optimize your images
    and, as a consequence, the performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Use sprites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A sprite is an image composed by multiple images; later, you can use this image
    and show only the portion you are interested in. Imagine that you have a nice
    website and, on each page, you have some social icons (Facebook, Twitter, Instagram,
    and so on). Instead of having one image for each social icon, you can combine
    them in one and use CSS to show only the part you want for each icon. Doing this,
    you will have all the social icons with only one load, reducing the number of
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: Our recommendation is to keep your sprites small and include only the most used
    and shared images in them.
  prefs: []
  type: TYPE_NORMAL
- en: Use lossless image compression
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Not all image formats are suitable for the Web as some formats are either too
    big or do not support compression. The three most used image types on the Web
    nowadays are as listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JPG**: This is one of the most commonly used method of lossless compression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PNG**: This is the best format with lossless data compression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GIF**: This is an old-school format that supports up to 8 bits per pixel
    for each image and is well known for its animated effects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recommended format for the web at this moment is **PNG**. It is well supported
    by the browsers, easy to create, supports compression, and gives you all the power
    you need to improve the performance of your site to the maximum.
  prefs: []
  type: TYPE_NORMAL
- en: Scale your images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using images and not data URIs, they should be sent at their original
    size. You should avoid resizing your images using CSS and send the image with
    the correct size to the browser. The only case when it is recommended to scale
    images by CSS is with fluid images (responsive design).
  prefs: []
  type: TYPE_NORMAL
- en: You can scale your images easily with PHP libraries like Imagick or GD. With
    these libraries and a few lines of code, you can scale your images in seconds.
    Usually, you do not scale the images on the fly. Most of the time, as soon as
    an image is uploaded to your application, a batch process takes care of the image,
    creating the different sizes needed by your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you can upload images of any size to your application and you
    only show images with a maximum width of `350`px in your frontend. You can easily
    scale the previously stored image with Imagick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will load the `my_uploaded_image.png` file and resize the
    image to a width of `350`px using the Lanczos filter (refer to the PHP Imagick
    documentation to see all the available filters you can use).
  prefs: []
  type: TYPE_NORMAL
- en: That's one way of doing it, another (and maybe even more effective) common way
    is to resize images on demand (that is, when first requested from client side),
    and then store the resized image either in cache or permanent storage.
  prefs: []
  type: TYPE_NORMAL
- en: Use data URIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another quick way of reducing the number of HTTP requests is embedding images
    as data URIs. This way, you will have the image as a string inside your code avoiding
    the request of the image, this method is the best fit for static pages. The best
    way to generate this kind of URIs is with external or online tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example will show you how it will look in your HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Cache, cache, and more cache
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Performance on the Web is all about serving data as fast as possible and, if
    our application already sent data that continues to be valid, why send it again?
    By default, modern browsers try to reduce the number of requests they make to
    the same site, so they keep a copy of some assets/resources in their internal
    cache for their future use. Thanks to this behavior, if you are browsing a website,
    we are not trying to load all the assets again and again as soon as you move between
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can help your browser in specifying each request response with the following
    `Cache-Control` HTTP headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**max-age=[seconds]**: This sets the maximum amount of time that a response
    will be considered fresh. This directive is relative to the time of the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**s-maxage=[seconds]**: This is similar to max-age, but for shared caches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public**: This tag marks the response as cacheable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**private**: This tag allows you to store the response to one user. Shared
    caches are not allowed to store the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**no-cache**: This tag instructs caches to submit the request to the original
    server for validation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**no-store**: This tag instructs caches not to keep a copy of the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**must-revalidate**: This tag tells the caches that they must follow any fresh
    information you give them about a response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**proxy-revalidate**: This is similar to must-revalidate, but for proxy caches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main recommendation is to tag static assets with an expiration of at least
    one week or one day on long-life assets. In the case of assets that change frequently,
    the recommendation is to set the expiration to a couple of days or less. Adjust
    the cache expiration dates of your assets according to their life.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you have one image that changes every 6 hours; in this case, you
    should not set the expiration date to a week, the best choice will be around 6
    hours.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid bad requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is nothing more annoying than bad requests as this kind of requests can
    reduce the performance of your application drastically. As you probably know,
    the browsers have a limited number of concurrent connections that they can manage
    at the same time for the same host. If your website makes a lot of requests, this
    list of available slots for connections can be full and the remaining requests
    are queued.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that your browser can manage up to 10 concurrent connections and your
    web application makes 20 requests. Not all the requests can be attended to at
    the same time and some of them are queued. What happens now if your application
    is trying to get an asset and it does not exist? In this case, the browser will
    waste its time (and slot) waiting for the non-existent asset to be served, but
    it will never happen.
  prefs: []
  type: TYPE_NORMAL
- en: As a recommendation, keep an eye on your browser developer tools (a set of web
    debugging tools built into the browsers you can use to debug and profile your
    site). These tools allow you to spot problematic requests and you can even check
    the amount of time used on each request. In most of the browsers, you can open
    the embedded developer tools pressing the *F12* key but, if your browser do not
    open the tools on pressing this key, check the browser's documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Use Content Delivery Networks (CDNs)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A content delivery network hosts a copy of your assets in servers designed to
    respond quickly and from the closest server possible. That way, if you are moving
    the requests from your servers to the CDN servers, your web servers will be dealing
    with fewer requests, improving the performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you use jQuery in your frontend; if you change your code to load
    the library from an official CDN, the probability of an user having the library
    in their browser cache increases.
  prefs: []
  type: TYPE_NORMAL
- en: Our main recommendation is to use CDNs at least for your CSS, JavaScript, and
    images.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have multiple PHP libraries, frameworks, components, and tools available
    to use in your project. Until a few years ago, PHP did not have a modern way of
    managing project dependencies. At this moment we have Composer, a flexible project
    that was converted into the de facto standard of dependency management.
  prefs: []
  type: TYPE_NORMAL
- en: You are probably familiar with Composer as we were using this tool all over
    the book to install new libraries in the `vendor` folder. At this point, you will
    be wondering whether you should commit the dependencies of your `vendor` folder.
    There is no quick response, but the general recommendation is no, you should not
    commit the `vendor` folder to your repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main disadvantages of committing the vendor folder can be summarized as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Increases the size of your repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duplicates the history of your dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we told you before, not committing the vendor is the main recommendation,
    but if you really need to do it, here are some suggestions:'
  prefs: []
  type: TYPE_NORMAL
- en: Use tagged releases (no dev versions) so that Composer fetches zipped sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `--prefer-dist` flag or set `preferred-install` to `dist` in your config
    file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the `/vendor/**/.git` rule to your `.gitignore` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semantic versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any project you start, you should use semantic versioning on your master
    branch. Semantic versioning is a set of rules you can follow to tag the code of
    your application in your versioning control software. By following these rules,
    you will know the current status of your production environment at any moment.
    Another benefit of using tags in your code is that it allow us to move between
    versions or do roll backs in an easy and quick way.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of having your source code with release tags is that it allows
    you to work with release branches, allowing you to have better planification and
    control of the changes you are making to your code.
  prefs: []
  type: TYPE_NORMAL
- en: How semantic versioning works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On semantic versioning, your code is marked with tags with the **`vX.Y.Z`**
    form, which means the version of your code. Each piece of your tag means something:'
  prefs: []
  type: TYPE_NORMAL
- en: '**X (major)**: An increase in this version number indicates that there are
    big changes in place; they are important enough to be incompatible with the current
    version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Y (minor)**: An increment in this version number indicates that we are adding
    new features to our project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Z (patch)**: An increment in this version number indicates that we added
    a patch to your source code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actualization of the release tag is usually made by the developer who will
    push code to the production environment. Please remember to update the release
    tag before the deployment of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic versioning in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that you start in someone else's project and the master branch is tagged
    as `v1.2.3`. Let's look at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: We have been told to add a new feature to the project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Working on a live project leads to receiving petitions for new features. In
    this case, we are clearly dealing with an increment of the minor version number
    because we are adding new code that is not incompatible with the actual base code.
    In our case, if our master branch is on `v1.2.3`, the new version tag will be
    `v1.3.0`. We have increased the minor version number and also, we reset the patch
    number because we are adding new code.
  prefs: []
  type: TYPE_NORMAL
- en: We have been told that there is a bug in our project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On a day-to-day basis you will be fixing bugs in your code. In this case, we
    are dealing with a small change that the main function is to solve our issue,
    so we need to increase the patch version. In our example, if the current production
    version is `v1.2.3`, the new version tag will be `v1.2.4`. We only increased the
    patch number because our fix does not imply other, bigger changes.
  prefs: []
  type: TYPE_NORMAL
- en: We have been asked for a big change
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine now that we have been asked for a big change to our source code; once
    we apply our change, some parts of our source will be incompatible with the previous
    versions. For example, imagine that you are using `library_a` and we changed to
    using `library_b` and they are mutually exclusive. In this case, we are dealing
    with a very big change that indicates that we need to increase our major version
    number and also, we need to reset the minor and patch numbers. For example, if
    our production code is tagged as `v1.2.3`, the new version code after you apply
    your changes will be `v2.0.0`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, doing semantic versioning will help you keep your source clean
    and makes it easier to know which kind of code changes are being done only by
    looking at the version number.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we throw an exception because something happened during the execution of
    our application, we should give more information to our users or consumers about
    what happened. This is possible by adding describable standard codes, also known
    as status codes. Using these standard codes in your responses will help you (and
    your colleagues) to know quickly if something is going wrong in your application.
    Check the following list to know what are the correct and most common HTTP status
    codes to use them in your API.
  prefs: []
  type: TYPE_NORMAL
- en: Client request successful
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If your application needs to inform the API client that the request was successful,
    you would usually reply with one of the following HTTP status codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**200 - OK**: The request was done successfully'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**201 - Created**: Successfully created the URI specified by the client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**202 - Accepted**: Accepted for processing but the server has not finished
    processing it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**204 - No Content**: Request is complete without any information being sent
    back in the response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request redirected
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When your application needs to reply to a request telling that the request
    was redirected, you will be using one of the following HTTP status codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**301 - Moved Permanently**: Requested resource does not exist on the server.
     A Location header is sent to the client to redirect it to the new URL. Client
    continues to use the new URL in the future requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**302 - Moved Temporarily**: Requested resource has temporarily moved.  A Location
    header is sent to the client to redirect it to the new URL. The client continues
    to use the old URL in the future requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**304 - Not Modified**: Used to respond to the `If-Modified-Since` request
    header. It indicates that the requested document has not been modified since the
    specified date, and the client should use a cached copy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client request incomplete
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the information you need to send to the API client is about an incomplete
    or wrong request, you will be returning one of the following HTTP codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**400 - Bad Request**: The server detected a syntax error in the client''s
    request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**401 - Unauthorized**: The request requires user authentication.  The server
    sends the WWW-Authenticate header to indicate the authentication type and realm
    for the requested resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**402 - Payment Required**: This is reserved for the future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**403 - Forbidden**: Access to the requested resource is forbidden. The request
    should not be repeated by the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**404 - Not Found**: The requested document does not exist on the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**405 - Method Not Allowed**: The request method used by the client is unacceptable.
    The server sends the `Allow` header stating what methods are acceptable to access
    the requested resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**408 - Request Time-Out**: The client has failed to complete its request within
    the request timeout period used by the server. However, the client can re-request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**410 - Gone**: The requested resource is permanently gone from the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**413 - Request Entity Too Large**: The server refuses to process the request
    because its message body is too large. The server can close connection to stop
    the client from continuing the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**414 - Request-URI Too Long**: The server refuses to process the request because
    the specified URI is too long.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**415 - Unsupported Media Type**: The server refuses to process the request
    because it does not support the message body’s format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On the unfortunate event of your application needing to inform the API client
    that there is some problem, you will be returning one of the following HTTP codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**500 - Internal server error**: A server configuration setting or an external
    program has caused an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**501 - Not Implemented**: The server does not support the functionality required
    to fulfill the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**502 - Bad gateway**: The server encountered an invalid response from an upstream
    server or proxy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**503 - Service unavailable**: The service is temporarily unavailable. The
    server can send a `Retry-After` header to indicate when the service may become
    available again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**504 - Gateway Time-Out**: The gateway or proxy has timed out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your code is the heart of your application; therefore, you want to write it
    properly, cleanly, and in an efficient manner. In this section, we will give you
    some hints to improve your code.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the standards of the industry is to use the UTF-8 format in all your
    application levels. If you skip this recommendation, you will be dealing with
    encoding problems all your project's life. At the moment of writing this book,
    PHP does not support Unicode at low level, so you need to be careful when dealing
    with strings, specially with UTF-8\. The following recommendations are only if
    you are working with UTF-8.
  prefs: []
  type: TYPE_NORMAL
- en: In PHP, the basic string operations such as assignation or concatenation don't
    need anything special in UTF-8; in other situations, you can use the core functions
    to deal with your strings. Most of the time, these functions have a counterpart
    (prefixed as `mb_*`) to deal with the Unicode. For example, in the PHP core, you
    can find the `substr()` and `mb_substr()` functions. You must use the multibyte
    functions whenever you operate with Unicode string. Imagine that you need to get
    a part of a UTF-8 string; if you use `substr()` instead of `mb_substr()`, there
    are good chances to get the result you are not expecting.
  prefs: []
  type: TYPE_NORMAL
- en: Single quotes versus double quotes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Single quoted strings are not parsed by PHP, so it doesn't matter what you have
    in your string, PHP will return the string unchanged. In the case of double quoted
    strings, they are parsed by the PHP engine and any variable in the string will
    be evaluated. With double quoted strings, the escaped characters (t or n, for
    example) will also be evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: In real-life applications, the difference of performance of using one or another
    can pass unnoticed but, on high-load applications, the performance can be different.
    Our recommendation is to be consistent and use only double quotes if you need
    variables and escaped characters to be evaluated. In any other case, use single
    quotes.
  prefs: []
  type: TYPE_NORMAL
- en: Spaces versus tabs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a war between developers who use spaces and developers who use tabs
    to tabulate their code. Each approach has its own benefits and inconveniences,
    but the PHP FIG recommendation is to use four spaces. Using only spaces avoids
    problems with diffs, patches, history, and annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In PHP, you have two options to write your regular expressions: the PCRE and
    the POSIX functions. The main recommendation is to use the PCRE functions (prefixed
    by `preg_*`) because the POSIX family of functions have been deprecated in PHP
    5.3.'
  prefs: []
  type: TYPE_NORMAL
- en: Connection and queries to a database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have multiple ways of connecting to a database in PHP but, among all of
    them, the recommended way of connecting is using PDO. One of the benefits of using
    PDO is that it has a standard interface to connect to multiple and different databases,
    allowing you to change your data storage without too much problem. When you are
    making queries against your database, and if you don't want any problem, ensure
    that you always use prepared statements. This way, you will avoid most of the
    SQL injection attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Using the === operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PHP is a loose type programming language, and this flexibility comes with some
    caveats when you are comparing your variables. If you use the `===` operator,
    PHP ensures that you are doing a strict comparison and avoiding false positives.
    Note that `===` is slightly faster than the `is_null()` and `is_bool()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Working with release branches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have our project following semantic versioning, we can start working
    with releases and release branches in our version control system, for example,
    Git. Using releases and release branches allows us to plan and organize the changes
    we will make in our code better.
  prefs: []
  type: TYPE_NORMAL
- en: The work with releases is based on the semantic versioning due to the fact that
    each release branch will be created from master, usually from the latest master
    version that has a tag (for example, v1.2.3).
  prefs: []
  type: TYPE_NORMAL
- en: 'The main benefits of using release branches are as listed:'
  prefs: []
  type: TYPE_NORMAL
- en: Helps you follow a strict methodology for pushing your code to production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helps you easily plan and control the changes you make to your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tries to avoid the common issue of dragging unwanted code to production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows you to block special branches, such as dev or stage, to avoid commits
    without pull requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that it is only a recommendation; each project is different, and this workflow
    can be unsuitable for your project.
  prefs: []
  type: TYPE_NORMAL
- en: Quick example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use releases in your project, you need to work with a release branch and
    another temporal branch where you make the changes to the code. For the following
    example, imagine that our project has the master branch tagged as v1.2.3.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to check whether we already have a release branch against
    which we will be working. If it is not the case, you need to create a new one
    from master:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to decide which will be our following version number; we will
    use all we have learned from the semantic versioning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we know our following version number, we will create a release branch
    from master. The next command will show you how to get the latest master branch
    and create and push a new release branch:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After the preceding steps, our repository will have our release branch clean
    and ready to be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At this point, we have our release branch ready. This means that any code modification
    will be done in a temporal branch created from our release branch:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we need to add a new feature to our project, so we need to create
    a temporal branch from our release branch:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As soon as we have our `feature/my_new_feature`, we can commit all our changes
    to this new branch. Once all our changes are committed and ready, we can merge
    our `feature/my_new_feature` with the release branch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding steps can be repeated any number of times until all the tasks
    you have scheduled for the release are done.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have finished all the release tasks and all your changes have been
    approved, you can merge the release branch with master. As soon as you finish
    the merge with master, remember to update the release tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can summarize our example with the following reminder notes:'
  prefs: []
  type: TYPE_NORMAL
- en: New release branches are always created from master
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Temporal branches are always created from the release branches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to avoid the merge of other temporal branches with the current temporal
    branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to avoid the merge of non-scheduled branches with your release branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the preceding workflow, we recommend using the following branch prefixes
    to know the type of change associated with the branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '`release/*`: This prefix indicates that all the included changes will be deployed
    in the future release with the same version number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`feature/*`: This prefix indicates that any change added to the branch is a
    new feature'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hotfix/*`: This prefix indicates that the included changes are committed to
    fix bugs/issues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working this way, it will be more difficult to push unwanted code to production.
    Feel free to adapt the preceding workflow to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we gave you some bits and bobs about the common best practices
    and conventions you can use in your projects. They are all recommendations, but
    they make the difference to stand out from the rest of the projects.
  prefs: []
  type: TYPE_NORMAL
