- en: Understanding the Customization and Optimization of Nessus and Nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Nmap Script Engine and its customization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Nessus Audit policy and its customization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is clear now from the previous chapters that Nmap Script Engine and Nessus'
    Compliance Audit policy are an important part of both tools to perform comprehensive
    audits and checks. It is very important for a user to understand the workings
    of these components and the various techniques to customize them in order to perform
    specific operations. In this chapter, we will look at the details of Nmap Script
    Engine and Nessus Audit file compositions in order to create custom files and
    perform specific operations.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Nmap Script Engine and its customization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Nmap Script Engine is used to run custom scripts written by users to automate
    network-level actions. Typically, Nmap scripts end with a `.nse` extension. These
    scripts are used to perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Host and port discovery**: The whole purpose of Nmap being so widely used
    is to perform simple tasks to check whether the remote host is live or non-live,
    along with the current status of the ports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version detection**: Nmap has a database of a variety of application and
    service signatures which are checked against the responses received from the ports
    to identify the service running on the port and sometimes the specific version
    as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Affected vulnerabilities**: Nmap Script Engine allows users to determine
    whether a particular port/service is vulnerable to a specific disclosed vulnerability.
    It depends on the script written by the user to query data from the service running
    and sends custom packets based on a response to determine whether the port/service
    is actually vulnerable. The Nmap scripts use the Lua programming language, and
    we will be looking into a few syntax as a part of this recipe to write a custom
    script. All the Nmap scripts are categorized into the following categories:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`auth`: This category of script deals with any authentication-related check,
    for example, default username and password logins, and anonymous and null logins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`broadcast`: This category of script is used to add newly discovered hosts
    dynamically which are to be scanned by Nmap, allowing the user to perform a full
    network discovery and scan at the same time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`brute`: This category of the script is used to perform a brute force attack
    to guess the password for various services such as HTTP, database, FTP, and so
    on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default`: This category of script is run along with all the scans where specific
    scripts are not mentioned in the command line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`discovery`: This category of script is used to obtain further information
    about network services on their shared resources within the network .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dos`: This category of script would be one of the most unwanted in the Nmap
    scripts. These scripts are used to test vulnerabilities which cause **Denial of
    Service** (**DoS**) attacks by crashing the service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exploit`: These scripts are used to exploit specific vulnerabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`external`: This category of script uses external resources to perform the
    given task. For example, for any DNS-related scripts, Nmap will have to query
    the local DNS servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fuzzer`: This category of script is used to generate random payloads to exploit
    a specific service. The response of the service to these payloads can be used
    to determine whether a particular service is vulnerable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`intrusive`: This category of script is used to directly exploit the vulnerability.
    These scans must be used in a later phase after reconnaissance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`malware`: This category of script allows the user to identify if the remote
    host is affected by any malware or has any backdoor open.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`safe`: This category of script is used to grab data which is available to
    everyone in the network such as banners, keys, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version`: This category of script is used to identify and determine the versions
    of the services running on the remote host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vuln`: This category of script is used to verify specific vulnerabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the arguments which are required in an `nmap` command in
    order to execute the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--script <filename>|<category>|<directory>|<expression>`: This argument allows
    the user to specify the script to be executed, where the filename, category, directory,
    and expression follow in order to help the user select the scripts. In order for
    the user to execute these scripts, they need to be present in the scripts folder
    of the Nmap installation directory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/60a02da9-406e-4cc6-8a64-23a31ab3a179.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The generic syntax used here is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`--script-args`: This allows the user to pass inputs to the `nmap` command
    if required. The generic syntax used here is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`--script-args-file`: This allows the user to upload file inputs to the `nmap`
    command. The generic syntax used here is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`--script-help <filename>|<category>|<directory>|<expression>`: This argument
    will allow the user to obtain more information about the scripts which can be
    used. The generic syntax used here is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/70239522-5a6d-4a63-83b3-46fcf5f2cb66.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As the output was huge, we saved it to a file called `output.txt` in the `D`
    drive. Open the `output` file in a text editor to see the help message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea65fd18-b17f-42cf-9223-231847d7fa0e.png)'
  prefs: []
  type: TYPE_IMG
- en: '`--script-trace`: If used, this argument will allow the user to view the network
    communication being performed by the script:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`--script-updatedb`: This is used to update the script''s database, which is
    used by Nmap. The generic syntax used here is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the environment variables used in preparing an Nmap script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SCRIPT_PATH`: This describes the path of the script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SCRIPT_NAME`: This describes the name given to the script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SCRIPT_TYPE`: This variable is used to describe the type of rule which has
    invoked by the script for a remote host'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a structure of a simple Nmap script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Script template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An Nmap script is basically categorized into three sections, which are discussed
    here. We will use the script from [https://svn.nmap.org/nmap/scripts/smtp-enum-users.nse](https://svn.nmap.org/nmap/scripts/smtp-enum-users.nse)
    as an example to define the data in these categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Head`**:** This section holds the descriptive and dependency related data
    to the script, the below arethe various supported components:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: This field acts as metadata to the script and describes important
    information about the script''s function in order for the user to make use of
    it. It attempts to enumerate the users on a SMTP server by issuing the `VRFY`,
    `EXPN`, or `RCPT TO` commands. The goal of this script is to discover all of the
    user accounts in the remote system. The script will output the list of usernames
    that were found. The script will stop querying the SMTP server if authentication
    is enforced. If an error occurs while testing the target host, the error will
    be printed with the list of any combinations that were found prior to the error. The
    user can specify which methods to use and in which order. The script will ignore repeated
    methods. If not specified, the script will use `RCPT` first, then `VRFY` and `EXPN`. An
    example of how to specify the methods to use and the order is shown as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`Categories`: This field allows the user to map the nature of the script by
    mentioning the category it belongs to. As seen in the preceding introduction,
    we can mention the categories by using the following syntax from the `smtp-enum-users.nse`
    script:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`author`: This field allows the author of the script to provide information
    about themselves such as their name, contact information, website, email, and
    so on:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`license`: This field is used to mention any license details required to distribute
    the script, along with the standard Nmap installation:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`dependencies`: This field defines the run level of the script, which means
    if any script is dependent on the output from any other script, the same can be
    mentioned here, allowing the dependent script to be executed first. This output
    can then be passed to script two:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Script libraries**: Nmap Script Engine uses variables to allow different
    scripts to be built upon a similar service. By using dependencies from libraries,
    authors can write comprehensive and small scripts. The following table explains
    some of the scan libraries:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Ajp | cassandra |'
  prefs: []
  type: TYPE_TB
- en: '| Amqp | citrixxml |'
  prefs: []
  type: TYPE_TB
- en: '| asn1 | Comm |'
  prefs: []
  type: TYPE_TB
- en: '| base32 | Creds |'
  prefs: []
  type: TYPE_TB
- en: '| base64 | Cvs |'
  prefs: []
  type: TYPE_TB
- en: '| Bin | Datafiles |'
  prefs: []
  type: TYPE_TB
- en: '| Bit | Dhcp |'
  prefs: []
  type: TYPE_TB
- en: '| Bitcoin | dhcp6 |'
  prefs: []
  type: TYPE_TB
- en: '| Bittorrent | Dns |'
  prefs: []
  type: TYPE_TB
- en: '| Bjnp | Dnsbl |'
  prefs: []
  type: TYPE_TB
- en: '| Brute | Dnssd |'
  prefs: []
  type: TYPE_TB
- en: '| Eigrp | Drda |'
  prefs: []
  type: TYPE_TB
- en: '| ftp | Eap |'
  prefs: []
  type: TYPE_TB
- en: 'For reference, we can look at the script at [https://svn.nmap.org/nmap/scripts/smtp-enum-users.nse](https://svn.nmap.org/nmap/scripts/smtp-enum-users.nse)
    to see how the libraries are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These libraries have various functions defined in them, for which we can pass
    arguments using the following syntax: `<function name>(arg1, arg2, arg3)`. For
    example, `smtp.check_reply("MAIL", response)`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Rules`: The script rules are used to determine whether a remote host is to
    be scanned or not based on the Boolean outcome of true or false. The host is only
    scanned when the rule returns true. Here are the rules which are applied on the
    host by a script:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prerule()`: This rule is executed before the scan is performed on the hosts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hostrule(host),portrule(host, port)`: These rules are executed after each
    set of hosts have been scanned using the provided script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postrule()`: This rule is executed once all the host scans are completed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the rule used in the example script `smtp-enum-users.nse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`Action`: This section consists of the actions to be performed by the script.
    Once the action is executed, it returns a specific result based on which the end
    result seen by the user is determined. The following is the action section from
    the example script `smtp-enum-users.nse`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Some of the libraries require the script to be in specific formats and must
    use the NSEDoc format. We will see how to fit the script into such a format in
    this recipe. In this recipe, we will have a look at creating a script to identify
    whether default Tomcat files are present on a remote host.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to complete this activity, you will have to satisfy the following
    prerequisites on your machine:'
  prefs: []
  type: TYPE_NORMAL
- en: You must have Nmap installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must have network access to the hosts on which the scans are to be performed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to install Nmap, you can follow the instructions provided in [Chapter
    2](888a67bc-261d-466c-bd68-e1f498ac4213.xhtml), *Understanding Network Scanning
    Tools*. This will allow you to download a compatible version of Nmap and install
    all the required plugins. In order to check whether your machine has Nmap installed,
    open the Command Prompt and type `nmap`. If Nmap is installed, you will see a
    screen similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58b4bc25-560e-4230-861a-2eda23875c0b.png)'
  prefs: []
  type: TYPE_IMG
- en: If you do not see the preceding screen, retry the same steps by moving the Command
    Prompt control into the folder where Nmap is installed (`C:\Program Files\Nmap`).
    If you do not see the preceding screen after this, remove and reinstall Nmap.
  prefs: []
  type: TYPE_NORMAL
- en: To populate the open ports on hosts for which the scan is to be done, you are
    required to have network-level access to that particular host. A simple way to
    check whether you have access to the particular host is through ICMP by sending
    ping packets to the host. However, this method only works if ICMP and ping are
    enabled in that network. If ICMP is disabled, live host detection techniques vary.
    We will look at this in more detail in later sections of this book.
  prefs: []
  type: TYPE_NORMAL
- en: In order to obtain the output shown, you are required to install a virtual machine.
    To be able to run a virtual machine, I would recommend using VMware's 30-day trial
    version, which can be downloaded and installed from [https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html](https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'For the test system, readers can download Metasploitable (a vulnerable virtual
    machine by Rapid 7) from [https://information.rapid7.com/download-metasploitable-2017.html](https://information.rapid7.com/download-metasploitable-2017.html).
    Follow these steps to open Metasploitable. This provides various components like
    the operating system, database, and vulnerable applications, which will help us
    test the recipes in this chapter. Follow these instructions to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Unzip the downloaded Metasploitable package
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `.vxm` file using the installed VMware Workstation or VMware Player
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in using `msfadmin`/`msfadmin` as the username and password
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a text editor and define three sections, `Head`, `Rule`, and `Action`,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7234afd7-a4be-4868-8191-d8f5d1f5e9b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start with the `Head` section. The following are the parameters which
    are to be mentioned in the `Head` section with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define the libraries required for the script to function by using
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In order for the script to write port rules, we need to use `shortport` and
    `http`. We use `shortport` to generate the port rule and `http` to simplify communication
    with HTTP and HTTPS pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now start with the rule section by introducing the `shortport` rule
    from the `shortport` library that''s included. This allows Nmap to invoke actions
    if the port is open:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `Head` and `Rule` section are completed, all we have to do is define
    the `action` page to perform the decisive operation and determine whether the
    default Tomcat documents exist at the location mentioned in the URI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the action section, we are defining the URI which needs to be checked for
    default files. We are fetching the response using the `http.get` function and
    saving it in the variable response. Then, we have laid an if condition to check
    whether the HTTP response received from the server consists of HTTP code 200,
    which depicts that the page was fetched successfully. Now, to actually see the
    contents of the web page, we are printing the response received using `response.body`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try and execute the script we have written for now to check whether
    it is working or needs troubleshooting. The following is a screenshot of the script.
    Save it to the Nmap installation directory in the scripts folder with the name
    `apache-default-files.nse`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/645fc1ae-2ab8-499a-944e-74e5c54e979c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Execute the script by using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/54eb4550-9ad3-4ed7-9534-029d37dd3294.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows that the script has been executed successfully
    and the page retrieved is the default page of Apache Tomcat. This means that the
    host is vulnerable. Now, instead of printing such heavy outputs, we can change
    the value of the return variable to vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: It is not always concluded that a 200 response means that the remote host is
    vulnerable, as the response might contain a custom error message. Therefore, it
    is recommended to include regex-based conditions to conclude the same and then
    return the response accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s further decorate the script in the format and write script documentation
    for it by adding the following lines to the script in the `Head` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The script now looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the script in the `scripts` folder of the Nmap installation directory
    and execute it using the following syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/a5c16d9e-47f8-46e9-bd01-6c7c3cff4559.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use similar techniques to create complex scripts by using complex libraries
    and using multiple functions of the Lua language, which supports complex programming.
    These scripts can be executed together based on the port and service available
    by using the `–A` argument. This will reduce the effort of the user in terms of
    mentioning each and every script that's required.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Nessus Audit policy and its customization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Nessus Audit files consist of custom XML-based rules which are needed to
    perform configuration audit for various platforms. These files allow the user
    to perform value and regex-based comparisons of the current configuration and
    determine the gaps present. In general, it is expected that these audit files
    are prepared in line with the industry standard baselines so that the actual compliance
    gaps are shown and the administration team can work on hardening and compliance
    at the same time. A custom audit file is to be saved with the extension `.audit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a generic syntax of a check in the audit files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will look at some of the standard checks for windows so that we can learn
    about various generic and custom checks. All the default checks start with `<item>`
    and all the custom checks start with `<custom_item>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Value data**: The keywords in the audit file can be assigned data based on
    the `value_data` tag. This section describes the different keywords which can
    be defined in the audit file and the values they can hold. The datatype of `value_data`
    is DWORD. `value_data` can also be fed with complex expressions using arithmetic symbols
    such as `||`, `&&`, and so on:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Check_type`: This attribute is used to compare whether the value fetched from
    the remote host is the policy value and returns the result based on the attribute
    configured. Some of the versions of this attribute are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CHECK_EQUAL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CHECK_EQUAL_ANY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CHECK_NOT_EQUAL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CHECK_GREATER_THAN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CHECK_GREATER_THAN_OR_EQUAL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Info**: This is an optional field which is used to add information about
    the check being performed. The syntax for this is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '**Debug**: This keyword can be used to obtain information to troubleshoot a
    check. This generates step-by-step data on the execution of the check, allowing
    the author to understand the errors.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access Control List Format** (**ACL**): This section of the settings contains
    keywords which can hold values to detect whether the required ACL settings have
    been applied on the files. The ACL format supports six different types of access
    list keywords, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File access control checks (`file_acl`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registry access control checks (`registry_acl`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service access control checks (`service_acl`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launch permission control checks (`launch_acl`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access permission control checks (`access_acl`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding keywords can be used to define file permissions for a specific
    user in the following associated types. These categories of permissions might
    have different changes for different keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Acl_inheritance`'
  prefs:
  - PREF_UL
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Acl_apply`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Acl_allow`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Acl_deny`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These keywords have different sets of permissions for folders. The following
    is the syntax in which `file_acl` can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A similar syntax can be used for all the other keywords by just replacing `file_acl`
    with the respective keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '**Item:** An item is of the check type, and can be used to perform predefined
    audit checks. This reduces the syntax as the policy is predefined and is called
    here using the attributes. The following is the structure of an item:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The value can be defined by the user, but the name needs to match the name which
    is listed in the predefined policies. The following are a few of the keywords
    and tags we will use in this recipe to create a custom Windows and Unix audit
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '`check_type`: Each audit file begins with the `check_type` tag, where the operating
    system and the version can be defined. This tag needs to be closed once the audit
    file is complete to mark the end of the audit file:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`name`: The `name` attribute needs to be the same as in the predefined policies
    in order for the logic to be fetched from the predefined policies:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`type`: The type variable holds the name of the policy item which is used for
    a specific check:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`description`: This attribute holds the user-defined name for the check. This
    can be anything that is useful to identify the action that is going on in the
    check:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`info`: This attribute is generally used to hold the logic in order for a user
    to understand the action being performed in the check:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`Value`: This attribute is of the DWORD type and consists of the policy value
    against which the remote value present on the host is to be compared with:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`cmd`: This holds the command which is to be executed on the remote system
    in order to obtain the value of the item being checked:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`regex`: This attribute can be used to perform regular expression-based comparisons
    for the remote value obtained. This can then be compared with the policy value
    to ensure that the check was successful, even if the configuration is stored in
    a different format:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`expect`: This policy item consists of the baseline policy value which is expected
    to be configured on the device. Otherwise, it is used to report the gap in the
    configuration:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`Custom_item`: A custom audit check is something that is defined by the user
    using NASL and is parsed by the Nessus compliance parser as per the instructions
    provided in the checks. These custom items consist of custom attributes and custom
    data values, which will allow the user to define the required policy values and
    prepare the audit files accordingly.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value_type`: This attribute consists of different types of the values which
    are allowed for the current check:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`value_data`: This attribute consists of the types of data that can be entered
    for the checks, such as:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value_data: 0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value_data: [0..20]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '``value_data: [0..MAX]``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Powershell_args`: This attribute consists of arguments which are to be passed
    and executed on `powershell.exe` for a windows system.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ps_encoded_args`: This attribute is used to allow PowerShell arguments or
    files as base 64 strings to PowerShell, for example, `powershell_args`:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this recipe, we will look at creating a windows audit file to check free
    disk space in the system partition.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to complete this activity, you will have to satisfy the following
    prerequisites on your machine:'
  prefs: []
  type: TYPE_NORMAL
- en: You must have Nessus installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must have network access to the hosts on which the scans are to be performed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to install Nessus, you can follow the instructions provided in [Chapter
    2](888a67bc-261d-466c-bd68-e1f498ac4213.xhtml), *Understanding Network Scanning
    Tools*. This will allow you to download a compatible version of Nessus and install
    all the required plugins. In order to check whether your machine has Nessus installed,
    open the search bar and search for `Nessus Web Client`. Once found and clicked
    on, this will be opened in the default browser window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5dc7b848-dfca-4316-887a-23e05f3f02a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you are sure that Nessus has been installed correctly, you can use the [https://localhost:8834](https://localhost:8834)
    URL directly from your browser to open the Nessus Web Client. If you are unable
    to locate the Nessus Web Client, you should remove and reinstall Nessus. For the
    removal of Nessus and installation instructions, refer to [Chapter 2](888a67bc-261d-466c-bd68-e1f498ac4213.xhtml),
    *Understanding Network Scanning Tools*. If you have located the Nessus Web Client
    and are unable to open it in the browser window, you need to check whether the
    Nessus service is running in the Windows Services utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f211ae06-4290-4975-a07d-28364f939dbe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can further start and stop Nessus by using the **Services** utility as
    per your requirements. In order to further confirm the installation using the
    command-line interface, you can navigate to the installation directory to see
    and access Nessus command-line utilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1608a738-cc85-492b-8c6c-b99bec8f9c8e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It is always recommended to have administrator-level or root-level credentials
    to provide the scanner access to all the system files. This will allow the scanner
    to perform a deeper scan and populate better results compared to a non-credentialed
    scan. The policy compliance module is only available in the paid versions of Nessus,
    such as Nessus Professional or Nessus Manager. For this, you will have to purchase
    an activation key from Tenable and update it in the **Settings** page, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e44b9c48-f69e-4854-908b-39593c054a3a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the edit button to open a window and enter the new activation code
    you have purchased from Tenable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ec08ae1-cd0d-422c-aefb-35e6864c8d4a.png)'
  prefs: []
  type: TYPE_IMG
- en: How do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Notepad++ or any text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to create a Windows check for a custom item, we need to begin and
    end the check with the `custom_item` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to identify the required metadata attributes and define them.
    In this case, we will go with `description` and `info`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to define the type of check we need to perform. Nessus executes
    all the NASL windows commands on PowerShell, and so the type of the check would
    be `AUDIT_POWERSHELL`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to define the value type and value data, which are supported by
    the check. In this case, we will go with policy type and set `0` to `MAX`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to pass the command to be executed by PowerShell to obtain free
    space in the `C` drive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are not passing encoded commands to PowerShell, we need to define the
    same with the `ps_encoded_args` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'As it does not require any refining and the output of the command will suffice
    so that we know how much free space we have, we will also define the `only_show_cmd_output:
    YES` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have seen that all the audit files start and end with `check_type`, we
    enclose the preceding code in the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file with the extension `.audit` onto your system and log in to Nessus
    using the credentials created during installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/594ff581-be4b-47af-acd5-1fb956410b23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the Policy tab and click on Create new policy using advanced scan template.
    Fill in the required details such as the policy name and description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/86531ad3-6ac6-476b-a8a8-ea30e3e958c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Navigate to the **Compliance** section and search the custom windows in the
    filter compliance search bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/057a34b4-2e9a-4737-b857-73a25553f5d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the Upload a custom Windows audit file option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f67dd9d9-c8e9-4643-9ef9-95430cc7d5fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Add File and upload the audit file you have created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6e672acf-a813-44b6-830a-b47221880031.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to perform a compliance audit, you will have to enter the Windows
    credentials. Navigate to the credentials section and click on the Windows option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/880a9dcd-36f5-4389-801d-a0743f50a7d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Save the policy and navigate to the My scans page to create a new scan.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to the User Defined policy section and select the custom Windows audit
    policy that we created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/74e2901c-abf7-4207-b995-8713c9e77526.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fill in the required details such as the scan name and affected host, and launch
    the scan:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/529d00e4-6624-4283-ae5f-e34607cf1de1.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These custom audit files can be used to audit multiple platforms, as NASL supports
    key works and attributes for multiple platforms and these values are custom and
    specific to the configuration of these platforms. This allows the user to easily
    create audit files and customize them as per their requirements and their baselines
    to perform the configuration audit and identify these gaps. The following is a
    list of platforms supported by Nessus to perform a configuration audit:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows 2003 Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows 2008 Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows Vista
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unix:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solaris
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FreeBSD/OpenBSD/NetBSD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HP/UX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AIX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS X
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other platforms:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cisco
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SCADA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
