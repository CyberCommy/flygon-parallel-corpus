- en: Standard Template Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: STL overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: STL architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: STL containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unordered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adaptors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look into the STL topics one by one in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The Standard Template Library architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ **Standard Template Library** (**STL**) offers ready-made generic containers,
    algorithms that can be applied to the containers, and iterators to navigate the
    containers. The STL is implemented with C++ templates, and templates allow generic
    programming in C++.
  prefs: []
  type: TYPE_NORMAL
- en: The STL encourages a C++ developer to focus on the task at hand by freeing up
    the developer from writing low-level data structures and algorithms. The STL is
    a time-tested library that allows rapid application development.
  prefs: []
  type: TYPE_NORMAL
- en: 'The STL is an interesting piece of work and architecture. Its secret formula
    is compile-time polymorphism. To get better performance, the STL avoids dynamic
    polymorphism, saying goodbye to virtual functions. Broadly, the STL has the following
    four components:'
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The STL architecture stitches all the aforementioned four components together.
    It has many commonly used algorithms with performance guarantees. The interesting
    part about STL algorithms is that they work seamlessly without any knowledge about
    the containers that hold the data. This is made possible due to the iterators
    that offer high-level traversal APIs, which completely abstracts the underlying
    data structure used within a container. The STL makes use of operator overloading
    quite extensively. Let's understand the major components of STL one by one to
    get a good grasp of the STL conceptually.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The STL algorithms are powered by C++ templates; hence, the same algorithm works
    irrespective of what data type it deals with or independently of how the data
    is organized by a container. Interestingly, the STL algorithms are generic enough
    to support built-in and user-defined data types using templates. As a matter of
    fact, the algorithms interact with the containers via iterators. Hence, what matters
    to the algorithms is the iterator supported by the container. Having said that,
    the performance of an algorithm depends on the underlying data structure used
    within a container. Hence, certain algorithms work only on selective containers,
    as each algorithm supported by the STL expects a certain type of iterator.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An iterator is a design pattern, but interestingly, the STL work started much
    before
  prefs: []
  type: TYPE_NORMAL
- en: '*Gang of Four* published their design patterns-related work to the software
    community. Iterators themselves are objects that allow traversing the containers
    to access, modify, and manipulate the data stored in the containers. Iterators
    do this so magically that we don''t realize or need to know where and how the
    data is stored and retrieved.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image visually represents an iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac27623f-1c3e-4a4b-a210-f2bec635d541.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding image, you can understand that every iterator supports the `begin()`
    API, which returns the first element position, and the `end()` API returns one
    position past the last element in the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The STL broadly supports the following five types of iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: Input iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forward iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bidirectional iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random-access iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The container implements the iterator to let us easily retrieve and manipulate
    the data, without delving much into the technical details of a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table explains each of the five iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **The type of iterator** | **Description                                
                  ** |'
  prefs: []
  type: TYPE_TB
- en: '| Input iterator |'
  prefs: []
  type: TYPE_TB
- en: It is used to read from the pointed element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is valid for single-time navigation, and once it reaches the end of the container,
    the iterator will be invalidated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports pre- and post-increment operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not support decrement operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports dereferencing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports the `==` and `!=` operators to compare with the other iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `istream_iterator` iterator is an input iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the containers support this iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Output iterator |'
  prefs: []
  type: TYPE_TB
- en: It is used to modify the pointed element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is valid for single-time navigation, and once it reaches the end of the container,
    the iterator will be invalidated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports pre- and post-increment operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not support decrement operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports dereferencing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn't support the `==` and `!=` operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ostream_iterator`, `back_inserter`, `front_inserter` iterators are examples
    of output iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the containers support this iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Forward iterator |'
  prefs: []
  type: TYPE_TB
- en: It supports the input iterator and output iterator functionalities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows multi-pass navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports pre-increment and post-increment operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports dereferencing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `forward_list` container supports forward iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Bidirectional iterator |'
  prefs: []
  type: TYPE_TB
- en: It is a forward iterator that supports navigation in both directions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows multi-pass navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports pre-increment and post-increment operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports pre-decrement and post-decrement operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports dereferencing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports the `[]` operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `list`, `set`, `map`, `multiset`, and `multimap` containers support bidirectional
    iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Random-access iterator |'
  prefs: []
  type: TYPE_TB
- en: Elements can be accessed using an arbitrary offset position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports pre-increment and post-increment operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports pre-decrement and post-decrement operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports dereferencing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is the most functionally complete iterator, as it supports all the functionalities
    of the other types of iterators listed previously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `array`, `vector`, and `deque` containers support random-access iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A container that supports random access will naturally support bidirectional
    and other types of iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: STL containers are objects that typically grow and shrink dynamically. Containers
    use complex data structures to store the data under the hood and offer high-level
    functions to access the data without us delving into the complex internal implementation
    details of the data structure. STL containers are highly efficient and time-tested.
  prefs: []
  type: TYPE_NORMAL
- en: Every container uses different types of data structures to store, organize,
    and manipulate data in an efficient way. Though many containers may seem similar,
    they behave differently under the hood. Hence, the wrong choice of containers
    leads to application performance issues and unnecessary complexities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Containers come in the following flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: Sequential
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container adapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The objects stored in the containers are copied or moved, and not referenced.
    We will explore every type of container in the upcoming sections with simple yet
    interesting examples.
  prefs: []
  type: TYPE_NORMAL
- en: Functors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functors are objects that behave like regular functions. The beauty is that
    functors can be substituted in the place of function pointers. Functors are handy
    objects that let you extend or complement the behavior of an STL function without
    compromising the object-oriented coding principles.
  prefs: []
  type: TYPE_NORMAL
- en: Functors are easy to implement; all you need to do is overload the function
    operator. Functors are also referred to as functionoids.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will demonstrate the way a simple functor can be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s quickly compile the program using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We hope you realize how easy and cool a functor is.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The STL supports quite an interesting variety of sequence containers. Sequence
    containers store homogeneous data types in a linear fashion, which can be accessed
    sequentially. The STL supports the following sequence containers:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forward_list `'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: deque
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As the objects stored in an STL container are nothing but copies of the values,
    the STL expects certain basic requirements from the user-defined data types in
    order to hold those objects inside a container. Every object stored in an STL
    container must provide the following as a minimum requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: A default constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A copy constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An assignment operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's explore the sequence containers one by one in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The STL array container is a fixed-size sequence container, just like a C/C++
    built-in array, except that the STL array is size-aware and a bit smarter than
    the built-in C/C++ array. Let''s understand an STL array with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be compiled and the output can be viewed with the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Code walkthrough
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following line declares an array of a fixed size (`5`) and initializes
    the array with five elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The size mentioned can't be changed once declared, just like a C/C++ built-in
    array. The `array::size()` method returns the size of the array, irrespective
    of how many integers are initialized in the initializer list. The `auto pos =
    a.begin()` method declares an iterator of `array<int,5>` and assigns the starting
    position of the array. The `array::end()` method points to one position after
    the last element in the array. The iterator behaves like or mimics a C++ pointer,
    and dereferencing the iterator returns the value pointed by the iterator. The
    iterator position can be moved forward and backwards with `++pos` and `--pos`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly used APIs in an array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows some commonly used array APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **API** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `at( int index )` | This returns the value stored at the position referred
    to by the index. The index is a zero-based index. This API will throw an `std::out_of_range`
    exception if the index is outside the index range of the array. |'
  prefs: []
  type: TYPE_TB
- en: '| `operator [ int index ]` | This is an unsafe method, as it won''t throw any
    exception if the index falls outside the valid range of the array. This tends
    to be slightly faster than `at`, as this API doesn''t perform bounds checking.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `front()` | This returns the first element in the array. |'
  prefs: []
  type: TYPE_TB
- en: '| `back()` | This returns the last element in the array. |'
  prefs: []
  type: TYPE_TB
- en: '| `begin()` | This returns the position of the first element in the array |'
  prefs: []
  type: TYPE_TB
- en: '| `end()`  | This returns one position past the last element in the array |'
  prefs: []
  type: TYPE_TB
- en: '| `rbegin()` | This returns the reverse beginning position, that is, it returns
    the position of the last element in the array |'
  prefs: []
  type: TYPE_TB
- en: '| `rend()` | This returns the reverse end position, that is, it returns one
    position before the first element in the array |'
  prefs: []
  type: TYPE_TB
- en: '| `size()`  | This returns the size of the array |'
  prefs: []
  type: TYPE_TB
- en: The array container supports random access; hence, given an index, the array
    container can fetch a value with a runtime complexity of *O(1)* or constant time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The array container elements can be accessed in a reverse fashion using the
    reverse iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the following command to get the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vector is a quite useful sequence container, and it works exactly as an array,
    except that the vector can grow and shrink at runtime while an array is of a fixed
    size. However, the data structure used under the hood in an array and vector is
    a plain simple built-in C/C++ style array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example to understand vectors better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be compiled and the output can be viewed with the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Code walkthrough
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following line declares a vector and initializes the vector with five elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: However, a vector also allows appending values to the end of the vector by using
    the `vector::push_back<data_type>( value )` API. The `sort()` algorithm takes
    two random access iterators that represent a range of data that must be sorted.
    As the vector internally uses a built-in C/C++ array, just like the STL array
    container, a vector also supports random access iterators; hence the `sort()`
    function is a highly efficient algorithm whose runtime complexity is logarithmic,
    that is, *O(N log2 (N))*.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly used vector APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows some commonly used vector APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **API** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `at ( int index )` | This returns the value stored at the indexed position.
    It throws the `std::out_of_range` exception if the index is invalid. |'
  prefs: []
  type: TYPE_TB
- en: '| `operator [ int index ]` | This returns the value stored at the indexed position.
    It is faster than `at( int index )`, since no bounds checking is performed by
    this function. |'
  prefs: []
  type: TYPE_TB
- en: '| `front()` | This returns the first value stored in the vector. |'
  prefs: []
  type: TYPE_TB
- en: '| `back()`  | This returns the last value stored in the vector. |'
  prefs: []
  type: TYPE_TB
- en: '| `empty()` | This returns true if the vector is empty, and false otherwise.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `size()`  | This returns the number of values stored in the vector. |'
  prefs: []
  type: TYPE_TB
- en: '| `reserve( int size )`  | This reserves the initial size of the vector. When
    the vector size has reached its capacity, an attempt to insert new values requires
    vector resizing. This makes the insertion consume *O(N)* runtime complexity. The
    `reserve()` method is a workaround for the issue described. |'
  prefs: []
  type: TYPE_TB
- en: '| `capacity()` | This returns the total capacity of the vector, while the size
    is the actual value stored in the vector. |'
  prefs: []
  type: TYPE_TB
- en: '| `clear()`  | This clears all the values. |'
  prefs: []
  type: TYPE_TB
- en: '| `push_back<data_type>( value )` | This adds a new value at the end of the
    vector. |'
  prefs: []
  type: TYPE_TB
- en: 'It would be really fun and convenient to read and print to/from the vector
    using `istream_iterator` and `ostream_iterator`. The following code demonstrates
    the use of a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that the output of the program is skipped, as the output depends on the
    input entered by you. Feel free to try the instructions on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Code walkthrough
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Basically, the copy algorithm accepts a range of iterators, where the first
    two arguments represent the source and the third argument represents the destination,
    which happens to be the vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `start_input` iterator instance defines an `istream_iterator` iterator that
    receives input from `istream` and `cin`, and the `end_input` iterator instance
    defines an end-of-file delimiter, which is an empty string by default (`""`).
     Hence, the input can be terminated by typing `""` in the command-line input terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, let''s understand the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The copy algorithm is used to copy the values from a vector, one element at
    a time, to `ostream`, separating the output with a tab character (`\t`).
  prefs: []
  type: TYPE_NORMAL
- en: Pitfalls of a vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every STL container has its own advantages and disadvantages. There is no single
    STL container that works better in all the scenarios. A vector internally uses
    an array data structure, and arrays are fixed in size in C/C++. Hence, when you
    attempt to add new values to the vector at the time the vector size has already
    reached its maximum capacity, then the vector will allocate new consecutive locations
    that can accommodate the old values and the new value in a contiguous location.
    It then starts copying the old values into the new locations. Once all the data
    elements are copied, the vector will invalidate the old location.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever this happens, the vector insertion will take *O(N)* runtime complexity.
    As the size of the vector grows over time, on demand, the *O(N)* runtime complexity
    will show up a pretty bad performance. If you know the maximum size required,
    you could reserve so much initial size upfront in order to overcome this issue.
    However, not in all scenarios do you need to use a vector. Of course, a vector
    supports dynamic size and random access, which has performance benefits in some
    scenarios, but it is possible that the feature you are working on may not really
    need random access, in which case a list, deque, or some other container may work
    better for you.
  prefs: []
  type: TYPE_NORMAL
- en: List
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The list STL container makes use of a doubly linked list data structure internally.
    Hence, a list supports only sequential access, and searching a random value in
    a list in the worst case may take *O(N)* runtime complexity. However, if you know
    for sure that you only need sequential access, the list does offer its own benefits.
    The list STL container lets you insert data elements at the end, in the front,
    or in the middle with a constant time complexity, that is, *O(1)* runtime complexity
    in the best, average, and worst case scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image demonstrates the internal data structure used by the list
    STL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abf7a8f7-caa3-47ee-a981-b3e95cd9be16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s write a simple program to get first-hand experience of using the list
    STL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: I'm sure that by now you have got a taste of the C++ STL, its elegance, and
    its power. Isn't it cool to observe that the syntax remains the same for all the
    STL containers? You may have observed that the syntax remains the same no matter
    whether you are using an array, a vector, or a list. Trust me, you will get the
    same impression when you explore the other STL containers as well.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, the previous code is self-explanatory, as we did pretty much
    the same with the other containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to sort the list, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Did you notice the `sort()` method? Yes, the list container has its own sorting
    algorithms. The reason for a list container to support its own version of a sorting
    algorithm is that the generic `sort()` algorithm expects a random access iterator,
    whereas a list container doesn't support random access. In such cases, the respective
    container will offer its own efficient algorithms to overcome the shortcoming.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, the runtime complexity of the `sort` algorithm supported by a
    list is *O (N log2 N)*.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly used APIs in a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows the most commonly used APIs of an STL list:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **API** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `front()` | This returns the first value stored in the list |'
  prefs: []
  type: TYPE_TB
- en: '| `back() ` | This returns the last value stored in the list |'
  prefs: []
  type: TYPE_TB
- en: '| `size()` | This returns the count of values stored in the list |'
  prefs: []
  type: TYPE_TB
- en: '| `empty()` | This returns `true` when the list is empty, and `false` otherwise
    |'
  prefs: []
  type: TYPE_TB
- en: '| `clear()` | This clears all the values stored in the list |'
  prefs: []
  type: TYPE_TB
- en: '| `push_back<data_type>( value )` | This adds a value at the end of the list
    |'
  prefs: []
  type: TYPE_TB
- en: '| `push_front<data_type>( value )` | This adds a value at the front of the
    list |'
  prefs: []
  type: TYPE_TB
- en: '| `merge( list )` | This merges two sorted lists with values of the same type
    |'
  prefs: []
  type: TYPE_TB
- en: '| `reverse()` | This reverses the list |'
  prefs: []
  type: TYPE_TB
- en: '| `unique()` | This removes duplicate values from the list |'
  prefs: []
  type: TYPE_TB
- en: '| `sort()` | This sorts the values stored in a list |'
  prefs: []
  type: TYPE_TB
- en: Forward list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The STL's `forward_list` container is built on top of a singly linked list data
    structure; hence, it only supports navigation in the forward direction. As `forward_list`
    consumes one less pointer for every node in terms of memory and runtime, it is
    considered more efficient compared with the list container. However, as price
    for the extra edge of performance advantage, `forward_list` had to give up some
    functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the internal data-structure used in `forward_list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f5ce1b8-55ac-4d34-8501-cc9d92362cc3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s explore the following sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output can be viewed with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Code walkthrough
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code declares and initializes the `forward_list` container with
    some unique values and some duplicate values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As the `forward_list` container doesn''t support the `size()` function, we
    used the `distance()` function to find the size of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `forward_list<int>::unique()` function removes the duplicate
    integers and retains only the unique values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Commonly used APIs in a forward_list container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows the commonly used `forward_list` APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **API** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `front()` | This returns the first value stored in the `forward_list` container
    |'
  prefs: []
  type: TYPE_TB
- en: '| `empty()` | This returns true when the `forward_list` container is empty
    and false, otherwise |'
  prefs: []
  type: TYPE_TB
- en: '| `clear()` | This clears all the values stored in `forward_list` |'
  prefs: []
  type: TYPE_TB
- en: '| `push_front<data_type>( value )` | This adds a value to the front of `forward_list`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `merge( list )` | This merges two sorted `forward_list` containers with values
    of the same type |'
  prefs: []
  type: TYPE_TB
- en: '| `reverse()` | This reverses the `forward_list` container |'
  prefs: []
  type: TYPE_TB
- en: '| `unique()` | This removes duplicate values from the `forward_list` container
    |'
  prefs: []
  type: TYPE_TB
- en: '| `sort()` | This sorts the values stored in `forward_list` |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s explore one more example to get a firm understanding of the `forward_list`
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet is an interesting example that demonstrates the practical
    use of the `sort()`, `merge()`, and `unique()` STL algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output can be viewed with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The output and the program are pretty self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: Deque
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The deque container is a double-ended queue and the data structure used could
    be a dynamic array or a vector. In a deque, it is possible to insert an element
    both at the front and back, with a constant time complexity of *O(1)*, unlike
    vectors, in which the time complexity of inserting an element at the back is *O(1)*
    while that for inserting an element at the front is *O(N)*. The deque doesn't
    suffer from the problem of reallocation, which is suffered by a vector. However,
    all the benefits of a vector are there with deque, except that deque is slightly
    better in terms of performance as compared to a vector as there are several rows
    of dynamic arrays or vectors in each row.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the internal data structure used in a deque container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/861700ea-0d37-4ff0-9312-3fe6845d4002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s write a simple program to try out the deque container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output can be viewed with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Commonly used APIs in a deque
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows the commonly used deque APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **API** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `at ( int index )` | This returns the value stored at the indexed position.
    It throws the `std::out_of_range` exception if the index is invalid. |'
  prefs: []
  type: TYPE_TB
- en: '| `operator [ int index ]` | This returns the value stored at the indexed position.
    It is faster than `at( int index )` since no bounds checking is performed by this
    function. |'
  prefs: []
  type: TYPE_TB
- en: '| `front()` | This returns the first value stored in the deque. |'
  prefs: []
  type: TYPE_TB
- en: '| `back() ` | This returns the last value stored in the deque. |'
  prefs: []
  type: TYPE_TB
- en: '| `empty()` | This returns `true` if the deque is empty and `false`, otherwise.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `size() ` | This returns the number of values stored in the deque. |'
  prefs: []
  type: TYPE_TB
- en: '| `capacity()` | This returns the total capacity of the deque, while `size()`
    returns the actual number of values stored in the deque. |'
  prefs: []
  type: TYPE_TB
- en: '| `clear() ` | This clears all the values. |'
  prefs: []
  type: TYPE_TB
- en: '| `push_back<data_type>( value )` | This adds a new value at the end of the
    deque. |'
  prefs: []
  type: TYPE_TB
- en: Associative containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Associative containers store data in a sorted fashion, unlike the sequence containers.
    Hence, the order in which the data is inserted will not be retained by the associative
    containers. Associative containers are highly efficient in searching a value with
    *O( log n )* runtime complexity. Every time a new value gets added to the container,
    the container will reorder the values stored internally if required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The STL supports the following types of associative containers:'
  prefs: []
  type: TYPE_NORMAL
- en: Set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multimap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unordered set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unordered multiset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unordered map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unordered multimap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Associative containers organize the data as key-value pairs. The data will
    be sorted based on the key for random and faster access. Associative containers
    come in two flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: Ordered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unordered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following associative containers come under ordered containers, as they
    are ordered/sorted in a particular fashion. Ordered associative containers generally
    use some form of **Binary Search Tree** (**BST**); usually, a red-black tree is
    used to store the data:'
  prefs: []
  type: TYPE_NORMAL
- en: Set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multimap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following associative containers come under unordered containers, as they
    are not ordered in any particular fashion and they use hash tables:'
  prefs: []
  type: TYPE_NORMAL
- en: Unordered Set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unordered Map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unordered Multiset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unordered Multimap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's understand the previously mentioned containers with examples in the following
    subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A set container stores only unique values in a sorted fashion. A set organizes
    the values using the value as a key. The set container is immutable, that is,
    the values stored in a set can't be modified; however, the values can be deleted.
    A set generally uses a red-black tree data structure, which is a form of balanced
    BST. The time complexity of set operations are guaranteed to be *O ( log N )*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a simple program using a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output can be viewed with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Code walkthrough
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code declares and initializes two sets, `s1` and `s2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line will ensure that the vector has enough room to store the
    values in the resultant vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will print the values in `s1` and `s2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `set_difference()` algorithm will populate the vector `v` with values only
    present in set `s1` but not in `s2`. The iterator, `pos`, will point to the last
    element in the vector; hence, the vector `resize` will ensure that the extra spaces
    in the vector are removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will print the values populated in the vector `v`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `set_union()` algorithm will merge the contents of sets `s1` and `s2` into
    the vector, and the vector is then resized to fit only the merged values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will print the merged values populated in the vector `v`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Commonly used APIs in a set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table describes the commonly used set APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **API** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `insert( value )` | This inserts a value into the set |'
  prefs: []
  type: TYPE_TB
- en: '| `clear()` | This clears all the values in the set |'
  prefs: []
  type: TYPE_TB
- en: '| `size()` | This returns the total number of entries present in the set |'
  prefs: []
  type: TYPE_TB
- en: '| `empty()` | This will print `true` if the set is empty, and returns `false` otherwise
    |'
  prefs: []
  type: TYPE_TB
- en: '| `find()` | This finds the element with the specified key and returns the
    iterator position |'
  prefs: []
  type: TYPE_TB
- en: '| `equal_range()` | This returns the range of elements matching a specific
    key |'
  prefs: []
  type: TYPE_TB
- en: '| `lower_bound()` | This returns an iterator to the first element not less than
    the given key |'
  prefs: []
  type: TYPE_TB
- en: '| `upper_bound()` | This returns an iterator to the first element greater than
    the given key  |'
  prefs: []
  type: TYPE_TB
- en: Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A map stores the values organized by keys. Unlike a set, a map has a dedicated
    key per value.  Maps generally use a red-black tree as an internal data structure,
    which is a balanced BST that guarantees *O( log N )* runtime efficiency for searching
    or locating a value in the map. The values stored in a map are sorted based on
    the key, using a red-black tree. The keys used in a map must be unique. A map
    will not retain the sequences of the input as it reorganizes the values based
    on the key, that is, the red-black tree will be rotated to balance the red-black
    tree height.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a simple program to understand map usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile and check the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Code walkthrough
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following line declares a map with a `string` name as the key and a `long`
    mobile number as the value stored in the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet adds four contacts organized by name as the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line will try to locate the contact with the name, `Sriram`,
    in the contacts map; if `Sriram` is found, then the `find()` function will return
    the iterator pointing to the location of the key-value pair; otherwise it returns
    the `contacts.end()` position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code verifies whether the iterator, `pos`, has reached `contacts.end()`
    and prints the contact number. Since the map is an associative container, it stores
    a `key=>value` pair; hence, `pos->first` indicates the key and `pos->second` indicates
    the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Commonly used APIs in a map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows the commonly used map APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **API** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `at ( key )` | This returns the value for the corresponding key if the key
    is found; otherwise it throws the `std::out_of_range` exception |'
  prefs: []
  type: TYPE_TB
- en: '| `operator[ key ]` | This updates an existing value for the corresponding
    key if the key is found; otherwise it will add a new entry with the respective
    `key=>value` supplied |'
  prefs: []
  type: TYPE_TB
- en: '| `empty()` | This returns `true` if the map is empty, and `false` otherwise
    |'
  prefs: []
  type: TYPE_TB
- en: '| `size()` | This returns the count of the `key=>value` pairs stored in the
    map |'
  prefs: []
  type: TYPE_TB
- en: '| `clear()` | This clears the entries stored in the map |'
  prefs: []
  type: TYPE_TB
- en: '| `count()` | This returns the number of elements matching the given key |'
  prefs: []
  type: TYPE_TB
- en: '| `find()` | This finds the element with the specified key |'
  prefs: []
  type: TYPE_TB
- en: Multiset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A multiset container works in a manner similar to a set container, except for
    the fact that a set allows only unique values to be stored whereas a multiset
    lets you store duplicate values. As you know, in the case of set and multiset
    containers, the values themselves are used as keys to organize the data. A multiset
    container is just like a set; it doesn't allow modifying the values stored in
    the multiset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a simple program using a multiset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The output can be viewed with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, in the preceding output, you can see that the multiset holds
    duplicate values.
  prefs: []
  type: TYPE_NORMAL
- en: Multimap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A multimap works exactly as a map, except that a multimap container will allow
    multiple values to be stored with the same key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the multimap container with a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The program can be compiled and the output can be viewed with the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Unordered sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An unordered set works in a manner similar to a set, except that the internal
    behavior of these containers differs. A set makes use of red-black trees while
    an unordered set makes use of hash tables. The time complexity of set operations
    is *O( log N)* while the time complexity of unordered set operations is *O(1)*;
    hence, the unordered set tends to be faster than the set.
  prefs: []
  type: TYPE_NORMAL
- en: The values stored in an unordered set are not organized in any particular fashion,
    unlike in a set, which stores values in a sorted fashion. If performance is the
    criteria, then an unordered set is a good bet; however, if iterating the values
    in a sorted fashion is a requirement, then set is a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: Unordered maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An unordered map works in a manner similar to a map, except that the internal
    behavior of these containers differs. A map makes use of red-black trees while
    unordered map makes use of hash tables. The time complexity of map operations
    is *O( log N)* while that of unordered map operations is *O(1);* hence, an unordered
    map tends to be faster than a map.
  prefs: []
  type: TYPE_NORMAL
- en: The values stored in an unordered map are not organized in any particular fashion,
    unlike in a map where values are sorted by keys.
  prefs: []
  type: TYPE_NORMAL
- en: Unordered multisets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An unordered multiset works in a manner similar to a multiset, except that the
    internal behavior of these containers differs. A multiset makes use of red-black
    trees while an unordered multiset makes use of hash tables. The time complexity
    of multiset operations is *O( log N)* while that of unordered multiset operations
    is *O(1)*. Hence, an unordered multiset tends to be faster than a multiset.
  prefs: []
  type: TYPE_NORMAL
- en: The values stored in an unordered multiset are not organized in any particular
    fashion, unlike in a multiset where values are stored in a sorted fashion. If
    performance is the criteria, unordered multisets are a good bet; however, if iterating
    the values in a sorted fashion is a requirement, then multiset is a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: Unordered multimaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An unordered multimap works in a manner similar to a multimap, except that the
    internal behavior of these containers differs. A multimap makes use of red-black
    trees while an unordered multimap makes use of hash tables. The time complexity
    of multimap operations is *O( log N)* while that of unordered multimap operations
    is *O(1)*; hence, an unordered multimap tends to be faster than a multimap.
  prefs: []
  type: TYPE_NORMAL
- en: The values stored in an unordered multimap are not organized in any particular
    fashion, unlike in multimaps where values are sorted by keys. If performance is
    the criteria, then an unordered multimap is a good bet; however, if iterating
    the values in a sorted fashion is a requirement, then multimap is a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: Container adapters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Container adapters adapt existing containers to provide new containers. In simple
    terms, STL extension is done with composition instead of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: STL containers can't be extended by inheritance, as their constructors aren't
    virtual. Throughout the STL, you can observe that while static polymorphism is
    used both in terms of operator overloading and templates, dynamic polymorphism
    is consciously avoided for performance reasons. Hence, extending the STL by subclassing
    the existing containers isn't a good idea, as it would lead to memory leaks because
    container classes aren't designed to behave like base classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The STL supports the following container adapters:'
  prefs: []
  type: TYPE_NORMAL
- en: Stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Priority Queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's explore the container adapters in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stack is not a new container; it is a template adapter class. The adapter containers
    wrap an existing container and provide high-level functionalities. The stack adapter
    container offers stack operations while hiding the unnecessary functionalities
    that are irrelevant for a stack. The STL stack makes use of a deque container
    by default; however, we can instruct the stack to use any existing container that
    meets the requirement of the stack during the stack instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: Deques, lists, and vectors meet the requirements of a stack adapter.
  prefs: []
  type: TYPE_NORMAL
- en: A stack operates on the **Last In First Out** (**LIFO**) philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly used APIs in a stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows commonly used stack APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **API** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `top()` | This returns the top-most value in the stack, that is, the value
    that was added last |'
  prefs: []
  type: TYPE_TB
- en: '| `push<data_type>( value )` | This will push the value provided to the top
    of the stack |'
  prefs: []
  type: TYPE_TB
- en: '| `pop()` | This will remove the top-most value from the stack  |'
  prefs: []
  type: TYPE_TB
- en: '| `size()` | This returns the number of values present in the stack |'
  prefs: []
  type: TYPE_TB
- en: '| `empty()` | This returns `true` if the stack is empty; otherwise it returns
    `false` |'
  prefs: []
  type: TYPE_TB
- en: 'It''s time to get our hands dirty; let''s write a simple program to use a stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The program can be compiled and the output can be viewed with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, we can see the LIFO behavior of stack.
  prefs: []
  type: TYPE_NORMAL
- en: Queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A queue works based on the **First In First Out** (**FIFO**) principle. A queue is
    not a new container; it is a templatized adapter class that wraps an existing
    container and provides the high-level functionalities that are required for queue
    operations, while hiding the unnecessary functionalities that are irrelevant for
    a queue. The STL queue makes use of a deque container by default; however, we
    can instruct the queue to use any existing container that meets the requirement
    of the queue during the queue instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: In a queue, new values can be added at the back and removed from the front.
    Deques, lists, and vectors meet the requirements of a queue adapter.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly used APIs in a queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows the commonly used queue APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **API** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `push()` | This appends a new value at the back of the queue |'
  prefs: []
  type: TYPE_TB
- en: '| `pop()` | This removes the value at the front of the queue |'
  prefs: []
  type: TYPE_TB
- en: '| `front()` | This returns the value in the front of the queue |'
  prefs: []
  type: TYPE_TB
- en: '| `back()` | This returns the value at the back of the queue |'
  prefs: []
  type: TYPE_TB
- en: '| `empty()` | This returns `true` when the queue is empty; otherwise it returns
    `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `size()` | This returns the number of values stored in the queue |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s use a queue in the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The program can be compiled and the output can be viewed with the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, you can observe that the values were popped out in
    the same sequence that they were pushed in, that is, FIFO.
  prefs: []
  type: TYPE_NORMAL
- en: Priority queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A priority queue is not a new container; it is a templatized adapter class that
    wraps an existing container and provides high-level functionalities that are required
    for priority queue operations, while hiding the unnecessary functionalities that
    are irrelevant for a priority queue. A priority queue makes use of a vector container
    by default; however, a deque container also meets the requirement of the priority
    queue. Hence, during the priority queue instantiation, you could instruct the
    priority queue to make use of a deque as well.
  prefs: []
  type: TYPE_NORMAL
- en: A priority queue organizes the data in such a way that the highest priority
    value appears first; in other words, the values are sorted in a descending order.
  prefs: []
  type: TYPE_NORMAL
- en: The deque and vector meet the requirements of a priority queue adaptor.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly used APIs in a priority queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows commonly used priority queue APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **API** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `push()` | This appends a new value at the back of the priority queue |'
  prefs: []
  type: TYPE_TB
- en: '| `pop()` | This removes the value at the front of the priority queue |'
  prefs: []
  type: TYPE_TB
- en: '| `empty()` | This returns `true` when the priority queue is empty; otherwise
    it returns `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `size()` | This returns the number of values stored in the priority queue
    |'
  prefs: []
  type: TYPE_TB
- en: '| `top()` | This returns the value in the front of the priority queue |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s write a simple program to understand `priority_queue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The program can be compiled and the output can be viewed with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, you can observe that `priority_queue` is a special
    type of queue that reorders the inputs in such a way that the highest value appears
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter you learned about ready-made generic containers, functors, iterators,
    and algorithms. You also learned set, map, multiset, and multimap associative
    containers, their internal data structures, and common algorithms that can be
    applied on them. Further you learned how to use the various containers with practical
    hands-on code samples.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn template programming, which helps you master
    the essentials of templates.
  prefs: []
  type: TYPE_NORMAL
