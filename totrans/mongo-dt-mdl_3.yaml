- en: Chapter 3. Querying Documents
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a NoSQL database, such as MongoDB, planning queries is a very important task,
    and depending on the query you want to perform, your document can vary greatly.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: As you saw in [Chapter 2](ch02.html "Chapter 2. Data Modeling with MongoDB"),
    *Data Modeling with MongoDB*, the decision to refer or include documents in a
    collection is, in a large part, the result of our planning. It is essential to
    determine whether we will give a preference to reading or writing in a collection.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will see how planning queries can help us create documents in a more
    efficient and effective way, and we will also consider more sensible questions
    such as atomicity and transactions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will focus on the following subjects:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Read operations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write operations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write concerns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bulk writing documents
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the read operations
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read is the most common and fundamental operation in a database. It's very hard
    to imagine a database that is used only to write information, where this information
    is never read. By the way, I have never heard of such an approach.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'In MongoDB, we can execute queries through the `find` interface. The `find`
    interface can accept queries as criteria and projections as parameters. This will
    result in a cursor. Cursors have methods that can be used as modifiers of the
    executed query, such as `limit`, `map`, `skip`, and `sort`. For example, take
    a look at the following query:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This would return the following document:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can use the `find` interface to execute a query in MongoDB. The `find` interface
    will select the documents in a collection and return a cursor for the selected
    documents.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Compared with the SQL language, the `find` interface should be seen as a `select`
    statement. And, similar to a `select` statement where we can determinate clauses
    with expressions and predicates, the `find` interface allows us to use criteria
    and projections as parameters.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned before, we will use JSON documents in these `find` interface parameters.
    We can use the `find` interface in the following way:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '`criteria` is a JSON document that will specify the criteria for the selection
    of documents inside a collection by using some operators'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`projection` is a JSON document that will specify which document''s fields
    in a collection will be returned as the query result'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both are optional parameters, and we will go into more detail regarding these
    later.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s execute the following example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '`{"username": "johnclay"}` is the criteria'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{_id: 1, username: 1, details: 1}` is the projection'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This query will result in this document:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Selecting all documents
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in the previous section, in the `find` interface, both the criteria
    and projection parameters are optional. To use the `find` interface without any
    parameters means selecting all the documents in a collection.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the query result is a cursor with all the selected documents.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'So, a query in the `products` collection executes in this way:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It will return:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Selecting documents using criteria
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite the convenience, selecting all the documents in a collection can turn
    out to be a bad idea due to a given collection's length. If we take as an example
    a collection with hundreds, thousands, or millions of records, it is essential
    to create a criterion in order to select only the documents we want.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: However, nothing prevents the query result from being huge. In this case, depending
    on the chosen drive that is executing the query, we must iterate the returned
    cursor.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that in the mongo shell, the default value of returned records is 20.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the following example query. We want to select the documents where
    the attribute name is `Product 1`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will give us as a result:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding query selects the documents through the equality `{name: "Product
    1"}`. It''s also possible to use operators on the criteria interface.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates how it''s possible to select all documents
    where the price is greater than 10:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This produces as a result:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When we execute a query using the operator `$gt`, only documents that have an
    information price greater than 10 will be returned as a result in the cursor.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: In addition, there are other operators such as comparison, logical, element,
    evaluation, geographical, and arrays.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take, for example, the documents from the `products` collection, shown
    as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Comparison operators
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MongoDB provides us with a way to define equality between values. With comparison
    operators, we can compare BSON type values. Let''s look at these operators:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$gte` operator is responsible for searching values that are equal or greater
    than the value specified in the query. If we execute the query `db.products.find({price:
    {$gte: 20}})`, it will return:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With the `$lt` operator, it''s possible to search for values that are inferior
    to the requested value in the query. The query `db.products.find({price: {$lt:
    20}})` will return:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `$lte` operator searches for values that are less than or equal to the
    requested value in the query. If we execute the query `db.products.find({price:
    {$lte: 20}})`, it will return:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `$in` operator is able to search any document where the value of a field
    equals a value that is specified in the requested array in the query. The execution
    of the query `db.products.find({price:{$in: [5, 10, 15]}})` will return:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `$nin` operator will match values that are not included in the specified
    array. The execution of the `db.products.find({price:{$nin: [10, 20]}})` query
    will produce:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `$ne` operator will match any values that are not equal to the specified
    value in the query. The execution of the `db.products.find({name: {$ne: "Product
    1"}})` query will produce:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Logical operators
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Logical operators are how we define the logic between values in MongoDB. These
    are derived from Boolean algebra, and the truth value of a Boolean value can be
    either `true` or `false`. Let''s look at the logical operators in MongoDB:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$and` operator will make a logical *AND* operation in an expressions array,
    and will return the values that match all the specified criteria. The execution
    of the `db.products.find({$and: [{price: {$lt: 30}}, {name: "Product 2"}]})` query
    will produce:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `$or` operator will make a logical *OR* operation in an expressions array,
    and will return all the values that match either of the specified criteria. The
    execution of the `db.products.find({$or: [{price: {$gt: 50}}, {name: "Product
    3"}]})` query will produce:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `$not` operator inverts the query effect and returns the values that do
    not match the specified operator expression. It is used to negate any operation.
    The execution of the `db.products.find({price: {$not: {$gt: 10}}})` query will
    produce:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `$nor` operator will make a logical *NOR* operation in an expressions array,
    and will return all the values that fail to match all the specified expressions
    in the array. The execution of the `db.products.find({$nor:[{price:{$gt: 35}},
    {price:{$lte: 20}}]})` query will produce:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Element operators
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To query a collection about our documents fields, we can use element operators.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$exists` operator will return all documents that have the specified field
    in the query. The execution of `db.products.find({sku: {$exists: true}})` will
    not return any document, because none of them have the field `sku`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Evaluation operators
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Evaluation operators are how we perform an assessment of an expression in MongoDB.
    We must take care with this kind of operator, especially if there is no index
    for the field we are using on the criteria. Let''s consider the evaluation operator:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$regex` operator will return all values that match a regular expression.
    The execution of `db.products.find({name: {$regex: /2/}})` will return:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Array operators
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we are working with arrays on a query, we should use array operators.
    Let''s consider the array operator:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The `$elemMatch` operator will return all documents where the specified array
    field values have at least one element that match the query criteria conditions.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `db.products.find({review: {$elemMatch: {stars: {$gt: 5}, customer: {email:
    "customer@customer.com"}}}})` query will look at all the collection documents
    where the `review` field has documents, the `stars` field value is greater than
    `5`, and `customer email` is `customer@customer.com`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Besides the presented operators, we have: `$mod`, `$text`, `$where`, `$all`,
    `$geoIntersects`, `$geoWithin`, `$nearSphere`, `$near`, `$size`, and `$comment`.
    You can find more information regarding this in the MongoDB manual reference at
    [http://docs.mongodb.org/manual/reference/operator/query/](http://docs.mongodb.org/manual/reference/operator/query/).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Projections
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until now, we have executed queries where the presented result is the document
    as it is persisted in MongoDB. But, in order to optimize the network overhead
    between MongoDB and its clients, we should use projections.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: As you saw at the beginning of the chapter, the `find` interface allows us to
    use two parameters. The second parameter is projections.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the same sample collection we used in the previous session, an example
    of a query with projection would be:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This query produces:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The projection is a JSON document with all the fields we would like to present
    or hide, followed by `0` or `1`, depending on what we want.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: When a field is followed by a `0`, then this field will not be shown in the
    resulting document. On the other hand, if the field is followed by a `1`, then
    this means that it will be shown in the resulting document.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, the `_id` field has the value `1`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'The `db.products.find({price: {$not: {$gt: 10}}}, {_id: 0, name: 1, "supplier.name":
    1})` query will show the following document:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In fields that have an array as a value, we can use operators such as `$elemMatch`,
    `$split`, `$slice`, and `$`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'The `db.products.find({price: {$gt: 20}}, {review: {$elemMatch: {stars: 5}}})`
    query will produce:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Introducing the write operations
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In MongoDB, we have three kinds of write operations: insert, update, and remove.
    To run these operations, MongoDB provides three interfaces: `db.document.insert`,
    `db.document.update`, and `db.document.remove`. The write operations in MongoDB
    are targeted to a specific collection and are atomic on the level of a single
    document.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: The write operations are as important as the read operations when we are modeling
    documents in MongoDB. The atomicity in a level of a single document can determine
    whether we embed documents or not. We will go into this in a little more detail
    in [Chapter 7](ch07.html "Chapter 7. Scaling"), *Scaling*, but the activity of
    choosing a shard key will be decisive in whether we write an operation's performance
    because, depending on the key choice, we will write in one or many shards.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Also, another determining factor in a writing operations' performance is related
    to the MongoDB physical model. There are many recommendations given by 10gen but
    let's focus on those that have the greatest impact on our development. Due to
    MongoDB's update model, which is based on random I/O operations, it is recommended
    that you use solid state discs, or SSD. The solid state disk has superior performance
    compared to spinning disks, in terms of random I/O operations. Even though spinning
    disks are cheaper, and the cost to scale an infrastructure based on this kind
    of hardware is not that expensive either, the use of SSDs or increasing the RAM
    is still more effective. Studies on this subject show us that SSDs outperform
    spinning disks by 100 times for random I/O operations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to understand about write operations is how the documents
    are actually written on disk by MongoDB. MongoDB uses a journaling mechanism to
    write operations, and this mechanism uses a journal to write the change operation
    before we write it in the data files. This is very useful, especially when we
    have a dirty shutdown. MongoDB will use the journal files to recover the database
    state to a consistent state when the `mongod` process is restarted.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: As stated in [Chapter 2](ch02.html "Chapter 2. Data Modeling with MongoDB"),
    *Data Modeling with MongoDB*, the BSON specification allows us to have a document
    with the maximum size of 16 MB. Since its 2.6 version, MongoDB uses a space allocation
    strategy for a record, or document, named "power of two sized allocation." As
    its name suggests, MongoDB will allocate to each document a size in bytes that
    is its size to the power of two (for example, 32, 64, 128, 256, 512, …), considering
    that the minimum size of a document is 32 bytes. This strategy allocates more
    space than the document really needs, giving it more space to grow.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Inserts
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `insert` interface is one of the possible ways of creating a new document
    in MongoDB. The `insert` interface has the following syntax:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '`document or array of documents` is either a document or an array with one
    or many documents that should be created in the targeted collection.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`writeConcern` is a document expressing the write concern.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ordered` should be a Boolean value, which if true will carry out an ordered
    process on the documents of the array, and if there is an error in a document,
    MongoDB will stop processing it. Otherwise, if the value is false, it will carry
    out an unordered process and it will not stop if an error occurs. By default,
    the value is `true`.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, we can see how an `insert` operation can be used:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As we did not specify a value for the `_id` field, it will be automatically
    generated with a unique `ObjectId` value. The document created by this `insert`
    operation is:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you observed in the first paragraph of this section, the `insert` interface
    is not the only way to create new documents in MongoDB. By using the `upsert`
    option on updates, we could also create new documents. Let's go into more detail
    regarding this now.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Updates
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `update` interface is used to modify previous existing documents in MongoDB,
    or even to create new ones. To select which document we would like to change,
    we will use a criterion. An update can modify the field values of a document or
    an entire document.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: An update operation will modify only one document at a time. If the criterion
    matches more than one document, then it is necessary to pass a document with a
    `multi` parameter with the `true` value to the update interface. If the criteria
    matches no document and the `upsert` parameter is `true`, a new document will
    be created, or else it will update the matching document.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'The `update` interface is represented as:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '`query` is the criteria'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update` is the document containing the modification to be applied'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upsert` is a Boolean value that, if true, creates a new document if the criteria
    does not match any document in the collection'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multi` is a Boolean value that, if true, updates every document that meets
    the criteria'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`writeConcern` is a document expressing the write concern'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the document created in the previous session, a sample update would be:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The modified document is:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `$set` operator allows us to update only the `email` field of the matched
    documents.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, you may have this update:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In this case, the modified document would be:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'That is, without the `$set` operator, we modify the old document with the one
    passed as a parameter on the update. Besides the `$set` operator, we also have
    other important update operators:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '`$inc` increments the value of a field with the specified value:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This update will increment the field `details.age` by 1 in the matched documents.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '`$rename` will rename the specified field:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This update will rename the field `username` to `login` in the matched documents.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '`$unset` will remove the field from the matched document:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This update will remove the `login` field from the matched documents.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: As the write operations are atomic at the level of a single document, we can
    afford to be careless with the use of the preceding operators. All of them can
    be safely used.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Write concerns
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many of the discussions surrounding non-relational databases are related to
    the ACID concept. We, as database professionals, software engineers, architects,
    and developers, are fairly accustomed to the relational universe, and we spend
    a lot of time developing without caring about ACID matters.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, we should understand by now why we really have to take this matter
    into consideration, and how these simple four letters are essential in the non-relational
    world. In this section, we will discuss the letter **D**, which means durability,
    in MongoDB.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Durability in database systems is a property that tells us whether a write operation
    was successful, whether the transaction was committed, and whether the data was
    written on non-volatile memory in a durable medium, such as a hard disk.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Unlike relational database systems, the response to a write operation in NoSQL
    databases is determined by the client. Once again, we have the possibility to
    make a choice on our data modeling, addressing the specific needs of a client.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: In MongoDB, the response of a successful write operation can have many levels
    of guarantee. This is what we call a write concern. The levels vary from weak
    to strong, and the client determines the strength of guarantee. It is possible
    for us to have, in the same collection, both a client that needs a strong write
    concern and another that needs a weak one.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'The write concern levels that MongoDB offers us are:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Unacknowledged
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acknowledged
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Journaled
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replica acknowledged
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unacknowledged
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As its name suggests, with an unacknowledged write concern, the client will
    not attempt to respond to a write operation. If this is possible, only network
    errors will be captured. The following diagram shows that drivers will not wait
    that MongoDB acknowledge the receipt of write operations:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![Unacknowledged](img/B04075_03_01.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: 'In the following example, we have an `insert` operation in the `customers`
    collection with an unacknowledged write concern:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Acknowledged
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With this write concern, the client will have an acknowledgement of the write
    operation, and see that it was written on the in-memory view of MongoDB. In this
    mode, the client can catch, among other things, network errors and duplicate keys.
    Since the 2.6 version of MongoDB, this is the default write concern.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'As you saw earlier, we can''t guarantee that a write on the in-memory view
    of MongoDB will be persisted on the disk. In the event of a failure of MongoDB,
    the data in the in-memory view will be lost. The following diagram shows that
    drivers wait MongoDB acknowledge the receipt of write operations and applied the
    change to the in-memory view of data:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![Acknowledged](img/B04075_03_02.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: 'In the following example, we have an `insert` operation in the `customers`
    collection with an acknowledged write concern:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Journaled
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With a journaled write concern, the client will receive confirmation that the
    write operation was committed in the journal. Thus, the client will have a guarantee
    that the data will be persisted on the disk, even if something happens to MongoDB.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'To reduce the latency when we use a journaled write concern, MongoDB will reduce
    the frequency in which it commits operations to the journal from the default value
    of 100 milliseconds to 30 milliseconds. The following diagram shows that drivers
    will wait MongoDB acknowledge the receipt of write operations only after committing
    the data to the journal:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![Journaled](img/B04075_03_03.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: 'In the following example, we have an `insert` in the `customers` collection
    with a journaled write concern:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们在`customers`集合中使用了一个日志写关注的`insert`：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Replica acknowledged
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 副本已确认
- en: When we are working with replica sets, it is important to be sure that a write
    operation was successful not only in the primary node, but also that it was propagated
    to members of the replica set. For this purpose, we use a replica acknowledged
    write concern.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用副本集时，重要的是要确保写操作不仅在主节点上成功，而且还传播到副本集的成员。为此，我们使用了一个副本已确认的写关注。
- en: 'By changing the default write concern to replica acknowledged, we can determine
    the number of members of the replica set from which we want the write operation
    confirmation. The following diagram shows that drivers will wait that MongoDB
    acknowledge the receipt of write operations on a specified number of the replica
    set members:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将默认写关注更改为副本已确认，我们可以确定我们希望从副本集的成员中获得写操作确认的数量。下图显示了驱动程序将等待MongoDB确认在指定数量的副本集成员上接收写操作：
- en: '![Replica acknowledged](img/B04075_03_04.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![副本已确认](img/B04075_03_04.jpg)'
- en: 'In the following example, we will wait until the write operation propagates
    to the primary and at least two secondary nodes:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将等待写操作传播到主节点和至少两个辅助节点：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We should include a timeout property in milliseconds to avoid that a write operation
    remains blocked in a case of a node failure.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在毫秒级别包含一个超时属性，以避免写操作在节点故障的情况下仍然被阻塞。
- en: 'In the following example, we will wait until the write operation propagates
    to the primary and at least two secondary nodes, with a timeout of three seconds.
    If one of the two secondary nodes from which we are expecting a response fails,
    then the method times out after three seconds:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将等待写操作传播到主节点和至少两个辅助节点，并设置了三秒的超时。如果我们期望响应的两个辅助节点中的一个失败，那么该方法将在三秒后超时：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Bulk writing documents
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 批量编写文档
- en: Sometimes it is quite useful to insert, update, or delete more than one record
    of your collection. MongoDB provides us with the capability to perform bulk write
    operations. A bulk operation works in a single collection, and can be either ordered
    or unordered.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一次插入、更新或删除集合中的多条记录是非常有用的。MongoDB为我们提供了执行批量写操作的能力。批量操作在单个集合中工作，可以是有序的或无序的。
- en: As with the `insert` method, the behavior of an ordered bulk operation is to
    process records serially, and if an error occurs, MongoDB will return without
    processing any of the remaining operations.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与`insert`方法一样，有序批量操作的行为是按顺序处理记录，如果发生错误，MongoDB将返回而不处理任何剩余的操作。
- en: The behavior of an unordered operation is to process in parallel, so if an error
    occurs, MongoDB will still process the remaining operations.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 无序操作的行为是并行处理，因此如果发生错误，MongoDB仍将处理剩余的操作。
- en: We also can determine the level of acknowledgement required for bulk write operations.
    Since its 2.6 version, MongoDB has introduced new bulk methods with which we can
    insert, update, or delete documents. However, we can make a bulk insert only by
    passing an array of documents on the `insert` method.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以确定批量写操作所需的确认级别。自其2.6版本以来，MongoDB引入了新的批量方法，我们可以使用这些方法插入、更新或删除文档。但是，我们只能通过在`insert`方法上传递文档数组来进行批量插入。
- en: 'In the following example, we make a bulk insert using the `insert` method:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们使用`insert`方法进行批量插入：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the following example, we make an unordered bulk insert using the new bulk
    methods:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们使用新的批量方法进行无序批量插入：
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We should use all the power tools MongoDB provides us with, but not without
    paying all our possible attention. MongoDB has a limit of executing a maximum
    of 1,000 bulk operations at a time. So, if this limit is exceeded, MongoDB will
    divide the operations into groups of a maximum of 1,000 bulk operations.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该利用MongoDB提供给我们的所有强大工具，但不要忽视任何可能的注意事项。MongoDB一次最多执行1,000个批量操作的限制。因此，如果超过此限制，MongoDB将把操作分成最多1,000个批量操作的组。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you were hopefully able to better understand the read and write
    operations in MongoDB. Moreover, now, you should also understand why it is important
    that you already know the queries you need to execute even before the document
    modeling process. Finally, you learned how to use the MongoDB properties, such
    as atomicity, at the document level and saw how it can help us to produce better
    queries.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您希望能够更好地理解MongoDB中的读写操作。此外，现在，您还应该明白为什么在文档建模过程之前就已经知道需要执行的查询是很重要的。最后，您学会了如何使用MongoDB的属性，比如原子性，在文档级别上，并看到它如何帮助我们生成更好的查询。
- en: In the next chapter, you will see how a special data structure known as index
    can improve the execution of our queries.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将看到一种称为索引的特殊数据结构如何改进我们查询的执行。
