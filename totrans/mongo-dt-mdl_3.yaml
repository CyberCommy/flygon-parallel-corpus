- en: Chapter 3. Querying Documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a NoSQL database, such as MongoDB, planning queries is a very important task,
    and depending on the query you want to perform, your document can vary greatly.
  prefs: []
  type: TYPE_NORMAL
- en: As you saw in [Chapter 2](ch02.html "Chapter 2. Data Modeling with MongoDB"),
    *Data Modeling with MongoDB*, the decision to refer or include documents in a
    collection is, in a large part, the result of our planning. It is essential to
    determine whether we will give a preference to reading or writing in a collection.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will see how planning queries can help us create documents in a more
    efficient and effective way, and we will also consider more sensible questions
    such as atomicity and transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will focus on the following subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: Read operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bulk writing documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the read operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read is the most common and fundamental operation in a database. It's very hard
    to imagine a database that is used only to write information, where this information
    is never read. By the way, I have never heard of such an approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'In MongoDB, we can execute queries through the `find` interface. The `find`
    interface can accept queries as criteria and projections as parameters. This will
    result in a cursor. Cursors have methods that can be used as modifiers of the
    executed query, such as `limit`, `map`, `skip`, and `sort`. For example, take
    a look at the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This would return the following document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can use the `find` interface to execute a query in MongoDB. The `find` interface
    will select the documents in a collection and return a cursor for the selected
    documents.
  prefs: []
  type: TYPE_NORMAL
- en: Compared with the SQL language, the `find` interface should be seen as a `select`
    statement. And, similar to a `select` statement where we can determinate clauses
    with expressions and predicates, the `find` interface allows us to use criteria
    and projections as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned before, we will use JSON documents in these `find` interface parameters.
    We can use the `find` interface in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`criteria` is a JSON document that will specify the criteria for the selection
    of documents inside a collection by using some operators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`projection` is a JSON document that will specify which document''s fields
    in a collection will be returned as the query result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both are optional parameters, and we will go into more detail regarding these
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s execute the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{"username": "johnclay"}` is the criteria'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{_id: 1, username: 1, details: 1}` is the projection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This query will result in this document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Selecting all documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in the previous section, in the `find` interface, both the criteria
    and projection parameters are optional. To use the `find` interface without any
    parameters means selecting all the documents in a collection.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the query result is a cursor with all the selected documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, a query in the `products` collection executes in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It will return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Selecting documents using criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite the convenience, selecting all the documents in a collection can turn
    out to be a bad idea due to a given collection's length. If we take as an example
    a collection with hundreds, thousands, or millions of records, it is essential
    to create a criterion in order to select only the documents we want.
  prefs: []
  type: TYPE_NORMAL
- en: However, nothing prevents the query result from being huge. In this case, depending
    on the chosen drive that is executing the query, we must iterate the returned
    cursor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that in the mongo shell, the default value of returned records is 20.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the following example query. We want to select the documents where
    the attribute name is `Product 1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding query selects the documents through the equality `{name: "Product
    1"}`. It''s also possible to use operators on the criteria interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates how it''s possible to select all documents
    where the price is greater than 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When we execute a query using the operator `$gt`, only documents that have an
    information price greater than 10 will be returned as a result in the cursor.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, there are other operators such as comparison, logical, element,
    evaluation, geographical, and arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take, for example, the documents from the `products` collection, shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Comparison operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MongoDB provides us with a way to define equality between values. With comparison
    operators, we can compare BSON type values. Let''s look at these operators:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$gte` operator is responsible for searching values that are equal or greater
    than the value specified in the query. If we execute the query `db.products.find({price:
    {$gte: 20}})`, it will return:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `$lt` operator, it''s possible to search for values that are inferior
    to the requested value in the query. The query `db.products.find({price: {$lt:
    20}})` will return:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$lte` operator searches for values that are less than or equal to the
    requested value in the query. If we execute the query `db.products.find({price:
    {$lte: 20}})`, it will return:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$in` operator is able to search any document where the value of a field
    equals a value that is specified in the requested array in the query. The execution
    of the query `db.products.find({price:{$in: [5, 10, 15]}})` will return:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$nin` operator will match values that are not included in the specified
    array. The execution of the `db.products.find({price:{$nin: [10, 20]}})` query
    will produce:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$ne` operator will match any values that are not equal to the specified
    value in the query. The execution of the `db.products.find({name: {$ne: "Product
    1"}})` query will produce:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Logical operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Logical operators are how we define the logic between values in MongoDB. These
    are derived from Boolean algebra, and the truth value of a Boolean value can be
    either `true` or `false`. Let''s look at the logical operators in MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$and` operator will make a logical *AND* operation in an expressions array,
    and will return the values that match all the specified criteria. The execution
    of the `db.products.find({$and: [{price: {$lt: 30}}, {name: "Product 2"}]})` query
    will produce:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$or` operator will make a logical *OR* operation in an expressions array,
    and will return all the values that match either of the specified criteria. The
    execution of the `db.products.find({$or: [{price: {$gt: 50}}, {name: "Product
    3"}]})` query will produce:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$not` operator inverts the query effect and returns the values that do
    not match the specified operator expression. It is used to negate any operation.
    The execution of the `db.products.find({price: {$not: {$gt: 10}}})` query will
    produce:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$nor` operator will make a logical *NOR* operation in an expressions array,
    and will return all the values that fail to match all the specified expressions
    in the array. The execution of the `db.products.find({$nor:[{price:{$gt: 35}},
    {price:{$lte: 20}}]})` query will produce:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Element operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To query a collection about our documents fields, we can use element operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$exists` operator will return all documents that have the specified field
    in the query. The execution of `db.products.find({sku: {$exists: true}})` will
    not return any document, because none of them have the field `sku`.'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluation operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Evaluation operators are how we perform an assessment of an expression in MongoDB.
    We must take care with this kind of operator, especially if there is no index
    for the field we are using on the criteria. Let''s consider the evaluation operator:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$regex` operator will return all values that match a regular expression.
    The execution of `db.products.find({name: {$regex: /2/}})` will return:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Array operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we are working with arrays on a query, we should use array operators.
    Let''s consider the array operator:'
  prefs: []
  type: TYPE_NORMAL
- en: The `$elemMatch` operator will return all documents where the specified array
    field values have at least one element that match the query criteria conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `db.products.find({review: {$elemMatch: {stars: {$gt: 5}, customer: {email:
    "customer@customer.com"}}}})` query will look at all the collection documents
    where the `review` field has documents, the `stars` field value is greater than
    `5`, and `customer email` is `customer@customer.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Besides the presented operators, we have: `$mod`, `$text`, `$where`, `$all`,
    `$geoIntersects`, `$geoWithin`, `$nearSphere`, `$near`, `$size`, and `$comment`.
    You can find more information regarding this in the MongoDB manual reference at
    [http://docs.mongodb.org/manual/reference/operator/query/](http://docs.mongodb.org/manual/reference/operator/query/).'
  prefs: []
  type: TYPE_NORMAL
- en: Projections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until now, we have executed queries where the presented result is the document
    as it is persisted in MongoDB. But, in order to optimize the network overhead
    between MongoDB and its clients, we should use projections.
  prefs: []
  type: TYPE_NORMAL
- en: As you saw at the beginning of the chapter, the `find` interface allows us to
    use two parameters. The second parameter is projections.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the same sample collection we used in the previous session, an example
    of a query with projection would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This query produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The projection is a JSON document with all the fields we would like to present
    or hide, followed by `0` or `1`, depending on what we want.
  prefs: []
  type: TYPE_NORMAL
- en: When a field is followed by a `0`, then this field will not be shown in the
    resulting document. On the other hand, if the field is followed by a `1`, then
    this means that it will be shown in the resulting document.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, the `_id` field has the value `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `db.products.find({price: {$not: {$gt: 10}}}, {_id: 0, name: 1, "supplier.name":
    1})` query will show the following document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In fields that have an array as a value, we can use operators such as `$elemMatch`,
    `$split`, `$slice`, and `$`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `db.products.find({price: {$gt: 20}}, {review: {$elemMatch: {stars: 5}}})`
    query will produce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Introducing the write operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In MongoDB, we have three kinds of write operations: insert, update, and remove.
    To run these operations, MongoDB provides three interfaces: `db.document.insert`,
    `db.document.update`, and `db.document.remove`. The write operations in MongoDB
    are targeted to a specific collection and are atomic on the level of a single
    document.'
  prefs: []
  type: TYPE_NORMAL
- en: The write operations are as important as the read operations when we are modeling
    documents in MongoDB. The atomicity in a level of a single document can determine
    whether we embed documents or not. We will go into this in a little more detail
    in [Chapter 7](ch07.html "Chapter 7. Scaling"), *Scaling*, but the activity of
    choosing a shard key will be decisive in whether we write an operation's performance
    because, depending on the key choice, we will write in one or many shards.
  prefs: []
  type: TYPE_NORMAL
- en: Also, another determining factor in a writing operations' performance is related
    to the MongoDB physical model. There are many recommendations given by 10gen but
    let's focus on those that have the greatest impact on our development. Due to
    MongoDB's update model, which is based on random I/O operations, it is recommended
    that you use solid state discs, or SSD. The solid state disk has superior performance
    compared to spinning disks, in terms of random I/O operations. Even though spinning
    disks are cheaper, and the cost to scale an infrastructure based on this kind
    of hardware is not that expensive either, the use of SSDs or increasing the RAM
    is still more effective. Studies on this subject show us that SSDs outperform
    spinning disks by 100 times for random I/O operations.
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to understand about write operations is how the documents
    are actually written on disk by MongoDB. MongoDB uses a journaling mechanism to
    write operations, and this mechanism uses a journal to write the change operation
    before we write it in the data files. This is very useful, especially when we
    have a dirty shutdown. MongoDB will use the journal files to recover the database
    state to a consistent state when the `mongod` process is restarted.
  prefs: []
  type: TYPE_NORMAL
- en: As stated in [Chapter 2](ch02.html "Chapter 2. Data Modeling with MongoDB"),
    *Data Modeling with MongoDB*, the BSON specification allows us to have a document
    with the maximum size of 16 MB. Since its 2.6 version, MongoDB uses a space allocation
    strategy for a record, or document, named "power of two sized allocation." As
    its name suggests, MongoDB will allocate to each document a size in bytes that
    is its size to the power of two (for example, 32, 64, 128, 256, 512, …), considering
    that the minimum size of a document is 32 bytes. This strategy allocates more
    space than the document really needs, giving it more space to grow.
  prefs: []
  type: TYPE_NORMAL
- en: Inserts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `insert` interface is one of the possible ways of creating a new document
    in MongoDB. The `insert` interface has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`document or array of documents` is either a document or an array with one
    or many documents that should be created in the targeted collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`writeConcern` is a document expressing the write concern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ordered` should be a Boolean value, which if true will carry out an ordered
    process on the documents of the array, and if there is an error in a document,
    MongoDB will stop processing it. Otherwise, if the value is false, it will carry
    out an unordered process and it will not stop if an error occurs. By default,
    the value is `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, we can see how an `insert` operation can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did not specify a value for the `_id` field, it will be automatically
    generated with a unique `ObjectId` value. The document created by this `insert`
    operation is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you observed in the first paragraph of this section, the `insert` interface
    is not the only way to create new documents in MongoDB. By using the `upsert`
    option on updates, we could also create new documents. Let's go into more detail
    regarding this now.
  prefs: []
  type: TYPE_NORMAL
- en: Updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `update` interface is used to modify previous existing documents in MongoDB,
    or even to create new ones. To select which document we would like to change,
    we will use a criterion. An update can modify the field values of a document or
    an entire document.
  prefs: []
  type: TYPE_NORMAL
- en: An update operation will modify only one document at a time. If the criterion
    matches more than one document, then it is necessary to pass a document with a
    `multi` parameter with the `true` value to the update interface. If the criteria
    matches no document and the `upsert` parameter is `true`, a new document will
    be created, or else it will update the matching document.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `update` interface is represented as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`query` is the criteria'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update` is the document containing the modification to be applied'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upsert` is a Boolean value that, if true, creates a new document if the criteria
    does not match any document in the collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multi` is a Boolean value that, if true, updates every document that meets
    the criteria'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`writeConcern` is a document expressing the write concern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the document created in the previous session, a sample update would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The modified document is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `$set` operator allows us to update only the `email` field of the matched
    documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, you may have this update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the modified document would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, without the `$set` operator, we modify the old document with the one
    passed as a parameter on the update. Besides the `$set` operator, we also have
    other important update operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$inc` increments the value of a field with the specified value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This update will increment the field `details.age` by 1 in the matched documents.
  prefs: []
  type: TYPE_NORMAL
- en: '`$rename` will rename the specified field:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This update will rename the field `username` to `login` in the matched documents.
  prefs: []
  type: TYPE_NORMAL
- en: '`$unset` will remove the field from the matched document:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This update will remove the `login` field from the matched documents.
  prefs: []
  type: TYPE_NORMAL
- en: As the write operations are atomic at the level of a single document, we can
    afford to be careless with the use of the preceding operators. All of them can
    be safely used.
  prefs: []
  type: TYPE_NORMAL
- en: Write concerns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many of the discussions surrounding non-relational databases are related to
    the ACID concept. We, as database professionals, software engineers, architects,
    and developers, are fairly accustomed to the relational universe, and we spend
    a lot of time developing without caring about ACID matters.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, we should understand by now why we really have to take this matter
    into consideration, and how these simple four letters are essential in the non-relational
    world. In this section, we will discuss the letter **D**, which means durability,
    in MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Durability in database systems is a property that tells us whether a write operation
    was successful, whether the transaction was committed, and whether the data was
    written on non-volatile memory in a durable medium, such as a hard disk.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike relational database systems, the response to a write operation in NoSQL
    databases is determined by the client. Once again, we have the possibility to
    make a choice on our data modeling, addressing the specific needs of a client.
  prefs: []
  type: TYPE_NORMAL
- en: In MongoDB, the response of a successful write operation can have many levels
    of guarantee. This is what we call a write concern. The levels vary from weak
    to strong, and the client determines the strength of guarantee. It is possible
    for us to have, in the same collection, both a client that needs a strong write
    concern and another that needs a weak one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The write concern levels that MongoDB offers us are:'
  prefs: []
  type: TYPE_NORMAL
- en: Unacknowledged
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acknowledged
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Journaled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replica acknowledged
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unacknowledged
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As its name suggests, with an unacknowledged write concern, the client will
    not attempt to respond to a write operation. If this is possible, only network
    errors will be captured. The following diagram shows that drivers will not wait
    that MongoDB acknowledge the receipt of write operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unacknowledged](img/B04075_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following example, we have an `insert` operation in the `customers`
    collection with an unacknowledged write concern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Acknowledged
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With this write concern, the client will have an acknowledgement of the write
    operation, and see that it was written on the in-memory view of MongoDB. In this
    mode, the client can catch, among other things, network errors and duplicate keys.
    Since the 2.6 version of MongoDB, this is the default write concern.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you saw earlier, we can''t guarantee that a write on the in-memory view
    of MongoDB will be persisted on the disk. In the event of a failure of MongoDB,
    the data in the in-memory view will be lost. The following diagram shows that
    drivers wait MongoDB acknowledge the receipt of write operations and applied the
    change to the in-memory view of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Acknowledged](img/B04075_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following example, we have an `insert` operation in the `customers`
    collection with an acknowledged write concern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Journaled
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With a journaled write concern, the client will receive confirmation that the
    write operation was committed in the journal. Thus, the client will have a guarantee
    that the data will be persisted on the disk, even if something happens to MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reduce the latency when we use a journaled write concern, MongoDB will reduce
    the frequency in which it commits operations to the journal from the default value
    of 100 milliseconds to 30 milliseconds. The following diagram shows that drivers
    will wait MongoDB acknowledge the receipt of write operations only after committing
    the data to the journal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Journaled](img/B04075_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following example, we have an `insert` in the `customers` collection
    with a journaled write concern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Replica acknowledged
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we are working with replica sets, it is important to be sure that a write
    operation was successful not only in the primary node, but also that it was propagated
    to members of the replica set. For this purpose, we use a replica acknowledged
    write concern.
  prefs: []
  type: TYPE_NORMAL
- en: 'By changing the default write concern to replica acknowledged, we can determine
    the number of members of the replica set from which we want the write operation
    confirmation. The following diagram shows that drivers will wait that MongoDB
    acknowledge the receipt of write operations on a specified number of the replica
    set members:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Replica acknowledged](img/B04075_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following example, we will wait until the write operation propagates
    to the primary and at least two secondary nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We should include a timeout property in milliseconds to avoid that a write operation
    remains blocked in a case of a node failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will wait until the write operation propagates
    to the primary and at least two secondary nodes, with a timeout of three seconds.
    If one of the two secondary nodes from which we are expecting a response fails,
    then the method times out after three seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Bulk writing documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes it is quite useful to insert, update, or delete more than one record
    of your collection. MongoDB provides us with the capability to perform bulk write
    operations. A bulk operation works in a single collection, and can be either ordered
    or unordered.
  prefs: []
  type: TYPE_NORMAL
- en: As with the `insert` method, the behavior of an ordered bulk operation is to
    process records serially, and if an error occurs, MongoDB will return without
    processing any of the remaining operations.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of an unordered operation is to process in parallel, so if an error
    occurs, MongoDB will still process the remaining operations.
  prefs: []
  type: TYPE_NORMAL
- en: We also can determine the level of acknowledgement required for bulk write operations.
    Since its 2.6 version, MongoDB has introduced new bulk methods with which we can
    insert, update, or delete documents. However, we can make a bulk insert only by
    passing an array of documents on the `insert` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we make a bulk insert using the `insert` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we make an unordered bulk insert using the new bulk
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We should use all the power tools MongoDB provides us with, but not without
    paying all our possible attention. MongoDB has a limit of executing a maximum
    of 1,000 bulk operations at a time. So, if this limit is exceeded, MongoDB will
    divide the operations into groups of a maximum of 1,000 bulk operations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you were hopefully able to better understand the read and write
    operations in MongoDB. Moreover, now, you should also understand why it is important
    that you already know the queries you need to execute even before the document
    modeling process. Finally, you learned how to use the MongoDB properties, such
    as atomicity, at the document level and saw how it can help us to produce better
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will see how a special data structure known as index
    can improve the execution of our queries.
  prefs: []
  type: TYPE_NORMAL
