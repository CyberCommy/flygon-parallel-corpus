- en: Chapter 8. Tips and Tricks or Flask Wizardry 101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can you wait any longer before trying more advanced topics on Flask? I certainly
    can't! In this chapter, we'll study techniques and modules essential to work better
    and more efficiently with Flask.
  prefs: []
  type: TYPE_NORMAL
- en: What good is high-quality software that takes forever to code or low-quality
    software delivered in a jiffy? Real Web development, the one you get paid for
    at the end of the month, requires maintainability, productivity, and quality to
    be feasible.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed earlier, software quality is closely related to testing. One
    way to measure software quality is verifying how close its features are to what
    is expected of it. This kind of measuring does not take into account the subjective
    side of quality evaluation. A client, per example, may believe the design of his
    latest project is ugly and consider a well tested, feature-adherent Web project
    *crappy*. The most you can do in these cases is charge a few extra bucks for a
    design refactory.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bring your client closer to the development process in order to avoid this kind
    of situation, if it ever happens to you. Try searching for "scrum" in Google or
    DuckDuckGo.
  prefs: []
  type: TYPE_NORMAL
- en: When talking about **productivity** and **maintainability**, the approaches
    are many! You may purchase a nice Integrated Development Environment (IDE) such
    as PyCharm or WingIDE to improve your productivity or hire third-party services
    to help you test your code or control your development schedule, but these can
    do just so much. Good architecture and task automation will be your best friend
    in most projects. Before discussing suggestions on how to organize you code and
    which modules will help you save some typing here and there, let's discuss premature
    optimization and overengineering, two terrible symptoms of an anxious developer/analyst/nosy
    manager.
  prefs: []
  type: TYPE_NORMAL
- en: Overengineering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making software is like making a condo, in a few ways. You'll plan ahead what
    you want to create before starting so that waste is kept to a minimum. Contrary
    to a condo, where it's advisable to plan the whole project before you start, you
    do not have to plan out your software because it will most likely change during
    development, and a lot of the planning may just go to waste.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this "plan just enough" approach is that you don't know what
    to expect in the future, which may transform the little bit of paranoia we all
    have inside into something big. One may end up coding against total system failure
    or complex software requirement scenarios that may never happen. You don't need
    a multilayer architecture, with cache, database integration, signaling system,
    and so on, to create a hello world, nor do you need less than this to create a
    Facebook clone.
  prefs: []
  type: TYPE_NORMAL
- en: 'The message here is: do not make your product more robust or complex than you
    know it needs to be and do not waste time planning for what may, most likely,
    never happen.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always plan for reasonable levels of safety, complexity, and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Premature optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is your software fast enough? Don't know? Then why are you optimizing that code,
    my friend? When you spend time optimizing software that you're not sure needs
    optimization, if no one complained about it being slow or you do not notice it
    to be slow in daily use, you're probably wasting time with premature optimization.
  prefs: []
  type: TYPE_NORMAL
- en: And so, on to Flask.
  prefs: []
  type: TYPE_NORMAL
- en: Blueprints 101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, our applications have all been flat: beautiful, single-file Web applications
    (templates and static resources not considered). In some cases, that''s a nice
    approach; a reduced need for imports, easy to maintain with simple editors and
    all but…'
  prefs: []
  type: TYPE_NORMAL
- en: As our applications grow, we identify the need to contextually arrange our code.
    Flask Blueprints allow you to modularize your project, sharding your views in
    "app-like" objects called **blueprints** that can be later loaded and exposed
    by your Flask application. Large applications benefit deeply from the use of blueprints,
    as the code gets more organized.
  prefs: []
  type: TYPE_NORMAL
- en: Feature-wise, it also helps you configure the registered view access and resource
    lookup in a more monolithic way. Tests, models, templates and static resources
    can be sorted by blueprint, making your code so much more maintainable. If you're
    familiar with **Django**, think of blueprints as Django apps. This way, a registered
    blueprint has access to the application config and may be registered with different
    routes.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Django apps, blueprints do not enforce a specific structure, just like
    the Flask application itself. You may have a blueprint structured as a module,
    for example, which is kind of convenient, once in a while.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example always helps, right? Let''s see a good example of blueprints. First,
    we installed the required library for the example in our virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we defined our tests (because we love TDD!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we test a single view, `blog.posts_view`, that has two
    routes, one for post detail and another for post listing. If our view receives
    a `slug` parameter, it should return only the first `Post` that has the attribute
    value of slug; if not, it returns up to 10 results.
  prefs: []
  type: TYPE_NORMAL
- en: 'We may now create a view, using blueprints that satisfy our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a blueprint is pretty simple: we provide the blueprint name, which
    is also used as an endpoint prefix to all the blueprint views, the import name
    (usually `__name__`), and any extra arguments we see fit. In the example, we pass
    `template_folder` as the argument because we want to make use of templates. If
    you were coding a service, you could skip this parameter. Another very useful
    parameter is `url_prefix`, which allows us to define a default URL prefix for
    all our paths.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If our blueprint name is `blog` and we register a method `index_view`, our endpoint
    to that view will be `blog.index_view`. An endpoint is a "name reference" to your
    view you may translate into its URL path.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to register our blueprint to our Flask application in order
    to make the views we wrote accessible. A `database.py` module is also created
    to hold our db instance.
  prefs: []
  type: TYPE_NORMAL
- en: Be warned that our Post model will be recognized by `db.create_all` because
    it was defined in `blog.py`; thus it becomes visible when the module is imported.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have a model class defined in a module that is not imported anywhere,
    its tables may not be created because SQLAlchemy will not know of it. One way
    to avoid this situation is to have all your models imported by the module where
    the blueprint is defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: What have we here? An `app_factory` that creates our Flask application sets
    the default database in `/tmp/`, a common Linux folder for temporary files; initiates
    our database manager, defined in `database.py`; and registers our blueprint using
    `register_blueprint`.
  prefs: []
  type: TYPE_NORMAL
- en: We set a routine to verify if we're running or importing the given module (useful
    for `runtests.py` as it imports from `main.py`); if we're running it, we create
    an app, set it to debug mode (because we're developing), create the database inside
    a temporary test context (`create_all` will not run outside a context), and run
    the app.
  prefs: []
  type: TYPE_NORMAL
- en: The templates (`post.html` and `posts.html`) still need to be written. Can you
    write them in order to make the tests pass? I leave it as a job for you!
  prefs: []
  type: TYPE_NORMAL
- en: 'Our current example project structure should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Blueprints 101](img/3863_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Well, our project is still flat; all modules on the same level, contextually
    arranged, but flat. Let''s try moving our blog blueprint into its own module!
    We probably want something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Blueprints 101](img/3863_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Blog templates inside a templates folder inside the blog package, our models
    inside `models.py`, and our views inside `views.py` (much like a Django app, right?).
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s possible to make that change without much effort. Mostly, create a `blog`
    folder and put an `__init__.py` file with the following content inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Move the `Post` class definition and db import into `models.py` and move blog-specific
    templates, `post.html` and `posts.html`, into a `templates` folder inside the
    package. As `template_folder` is relative to the current module directory, there
    is no need to change our blueprint instantiation. Now, run your tests. They should
    work without modification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a sip, put on your war helmet, and let''s move on to the next topic: logging!'
  prefs: []
  type: TYPE_NORMAL
- en: Oh God, please tell me you have the logs…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You never know how much logging is important until you face a mysterious problem
    you can't quite figure out. Understanding why something wrong happened is the
    first, and probably main, reason why people add logging to their projects. But,
    hey, what's logging?
  prefs: []
  type: TYPE_NORMAL
- en: Logging is the act of storing records about events for further later analysis.
    An important concept about logging is related to the logging level, which allows
    you to categorize the information type and relevance.
  prefs: []
  type: TYPE_NORMAL
- en: The Python standard library comes bundled with a logging library that is actually
    pretty powerful and allows you, through handlers and messages, to log to streams,
    files, e-mail, or any other solution you believe will fit. Let's try a few useful
    logging examples, shall we?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, we create two common logging setups: logging to a file and
    logging to mail. Both are very useful in their own way. In `configure_file_logger`
    we define a function that registers a `RotatingFileHandler` to hold all log messages
    with the given level or above. Here, we do not use a regular `FileHandler` class
    because we want to keep our log files manageable (also known as: small). `RotatingFileHandler`
    allows us to define a max size for our log files and, when the log file size is
    close to the `maxBytes` limit, the handler "rotates" to a brand new log file (or
    overwrites an old one).'
  prefs: []
  type: TYPE_NORMAL
- en: Logging to file is pretty straightforward and is used mostly to follow execution
    flows in applications (INFO, DEBUG, and WARN logs, mostly). Basically, file logging
    should be used whenever you have messages that should be recorded but should not
    be immediately read or even read at all (you might want to read a DEBUG log if
    something unexpected happens, but not otherwise). That way, in the case of a problem,
    you just dig out your log files and see what went wrong. Mail logging has another
    goal ...
  prefs: []
  type: TYPE_NORMAL
- en: To configure our mail logger, we define a function called `configure_mail_logger`.
    It creates and registers a `SMTPHandler` to our logger at the given log level;
    that way, whenever a message with that log level or higher is logged, an e-mail
    message is sent to the registered ADMINS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mail logging has one main purpose: to notify someone (or a lot of people) ASAP
    that something important has happened, such as an error that may compromise the
    application. You probably don''t want a logging level below ERROR set for this
    kind of handler, as there would be just too many mails to keep up with.'
  prefs: []
  type: TYPE_NORMAL
- en: As a last piece of advice on logging, sane projects have good logging. It's
    usual to trace back a user issue report or even a mailed error message. Define
    good logging policies and follow them, build tools to analyze your logs, and set
    logging rotation parameters appropriate to the project needs. Projects that produce
    a lot of logging may need larger files while projects that do not have much logging
    could live well with a high value of `backupCount`. Always give it some thought.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging, DebugToolbar, and happiness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When running your Flask project in debug mode (`app.debug = True`), whenever
    Flask detects that your code has changed it will restart your application. If
    the given change breaks your application, Flask will display an error message
    in the console that is actually very simple to analyze. You start reading from
    the bottom up until you find the first line that mentions a file you wrote; that''s
    where the error was generated. Now, read from the top down until you find a line
    telling you exactly what the error was. If this approach is not sufficient and
    if you need to read a variable value—for example, to better understand what is
    going on—you may use `pdb`, the standard Python debugging library, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Whenever `pdb.set_trace` is called, a `pdb` console, which is much like a Python
    console, will be opened. Thus you may consult the value of any values you need
    or even make code evaluations.
  prefs: []
  type: TYPE_NORMAL
- en: Using `pdb` is nice but, if you just want to keep up with what is happening
    with your requests—for example, the template used, CPU time (this can catch you
    out!), logged messages, and so on—Flask-DebugToolbar may be a very handy extension
    at your disposal.
  prefs: []
  type: TYPE_NORMAL
- en: Flask-DebugToolbar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine you could see the CPU time of your requests directly in your rendered
    template, and may be verify which template was used to render that page or even
    edit it on-the-fly. Would that be nice? Would you like to see it come true? Then
    try the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, make sure the extension is installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And on to some fine code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Using Flask-DebugToolbar has no mysteries. Set `debug` to `True`, add a `secret_key`,
    and initialize the extension. When you open `http://127.0.0.1:5000/` in your browser,
    you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flask-DebugToolbar](img/3863_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The collapsible panel on the right is a bit of HTML the debug toolbar inserts
    in each HTML response that allows you to introspect your response without the
    need to use a debugger such as `pdb`. In the example, we set `DEBUG_TB_TEMPLATE_EDITOR_ENABLED`
    to `True`; this option tells DebugToolbar we wish to edit the rendered template
    right from the browser. Just navigate to **Templates** | **Edit Templates** to
    try it out.
  prefs: []
  type: TYPE_NORMAL
- en: Sessions or storing user data between requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you'll have a scenario in your application where data has to be kept
    between requests, but there is no need to persist it in the database, like an
    authentication token that identifies a logged user or which items a user added
    to his shopping cart. At those times of peril, use Flask sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Flask sessions are a solution for transient storage between requests implemented
    using browser cookies and cryptography. Flask uses the secret key value to encrypt
    any values you set in the session before setting it in the cookies; this way,
    even if a malicious person has access to the victim's browser, it won't be possible
    to read the cookie's content.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because the secret key is used to encrypt the session data, it is important
    to have a strong value for your secret key. `os.urandom(24)` will likely create
    a strong secret key for the deploy environment.
  prefs: []
  type: TYPE_NORMAL
- en: The data stored in the session is transient because there is no guarantee it
    will be there at any time, as the user may clean the browser cookies or the cookie
    might just expire, but it will most likely be there if you set it. Always take
    that piece of information into account while developing.
  prefs: []
  type: TYPE_NORMAL
- en: 'One big advantage of a Flask session is its simplicity; you use it as if it
    was a regular dictionary, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example, we define a very simple Product model, with ID, name, a sku
    (a special field used to identify a product in a store), and a view that adds
    the requested product to a cart in the user session. As you can see, we make no
    assumption that there is any data in the session, always playing it safe. We also
    do not need to "save" the session after changing it, because Flask is smart enough
    to notice your session was changed and saves it auto-magically… Actually, there
    is a catch here. Flask sessions can only detect the session was modified if you
    modify its first level values. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now run your project and open the URL `http://localhost:5000/cart/add/010` in
    your browser. See how the counter goes up each time you reload? Well, that's the
    session working!
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How about putting our knowledge to work? Try making a shop web application,
    such as an online pet shop. It should have pet services, for example bathing and
    vet consultations, and also a small store with pet accessories. It should be easy
    enough (lots of work! but easy).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a dense chapter. We overviewed important concepts—such as performance
    and maintainability, productivity, and quality—had a quick discussion about premature
    optimization and overengineering, and focused our efforts on learning how to write
    better code with Flask.
  prefs: []
  type: TYPE_NORMAL
- en: Blueprints, which allow you to create robust large projects with Flask, were
    discussed with a full-range example; we learned about logging to file and mail
    and the importance of each, had a lovely time with Flask-DebugToolbar (so handy!)
    and took the default session setup and usage to heart.
  prefs: []
  type: TYPE_NORMAL
- en: You're now a capable Flask developer. I'm so proud!
  prefs: []
  type: TYPE_NORMAL
- en: As one first learns to drive before trying out drifting, we will begin our Flask
    drifting next chapter. Our focus will be on using the wide extension ecosystem
    available to Flask in order to create amazing projects. It will be lots of fun!
    See you there!
  prefs: []
  type: TYPE_NORMAL
