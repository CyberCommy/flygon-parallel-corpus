- en: Creating Basic Forms with Tkinter and ttk Widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good news! Your design has been reviewed and approved by the director. Now it's
    time to start implementing it!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating your technology choices in light of the design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know our selected Tkinter and `ttk` widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing and testing the form and application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get coding!
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating our technology choices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first implementation of the design will be a very simple application that
    delivers the core functionality of the specification and little else. This is
    known as a **minimum viable product** or **MVP**. Once we've established an MVP,
    we'll have a better understanding of how to develop it into a final product.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get to that, let's take a moment to evaluate our technology choices.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a technology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Naturally, we''re going to build this form using Python and Tkinter. However,
    it''s worth asking whether Tkinter is really a good choice of technology for the
    application. We need to take the following things into consideration when choosing
    the GUI toolkit used to implement this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Your current expertise and knowledge**: Your expertise is in Python, but
    you have little experience in creating GUIs. For the fastest time to deliver,
    you need an option that works well with Python and isn''t complicated to learn.
    You also want something established and stable, as you won''t have time to keep
    up with new developments in the toolkit. Tkinter works here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The target platforms**: You will be developing the application on a Windows
    PC, but it will need to run on Debian Linux, so the choice of GUI should be cross-platform.
    The computer it will run on is old and slow, so your program needs to be frugal
    with resources. Tkinter also works here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application functionality**: Your application needs to be able to display
    basic form fields, validate the data entered, and write it to CSV. Tkinter can
    handle these frontend requirements, and Python can handle the CSV file easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given the options available for Python, Tkinter is a good choice. It's got a
    short learning curve, it's lightweight, it's readily available on both your development
    and target platforms, and it contains the functionality necessary for the form.
  prefs: []
  type: TYPE_NORMAL
- en: Python has other options for GUI development, including **PyQT**, **Kivy**,
    and **wxPython**. These have different strengths and weaknesses compared to Tkinter,
    but if you find Tkinter doesn't fit well for a project, one of these might be
    a better option.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Tkinter widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we designed our application, we picked out a widget class that most closely
    matched each field we needed. These were the `Entry`, `Spinbox`, `Combobox`, `Checkbutton`,
    and `Text` widgets. We also determined that we'd need the `Button` and `LabelFrame` widgets
    to implement the application layout. Before we start writing our class, let's
    take a look at each of these widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Some of our widgets are in Tkinter, others are in the `ttk` themed widget set,
    and a few are in both libraries. We prefer the `ttk` versions wherever they exist,
    since they look better across platforms. Pay careful attention to the library
    from which we import each widget.
  prefs: []
  type: TYPE_NORMAL
- en: The Entry widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ttk.Entry` widget is a basic, one-line character entry, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/93ab1723-3880-43fe-8866-779aeb33dd64.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can create an entry by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the commonly used arguments to `ttk.Entry` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`parent`: This argument sets the `parent` widget for the entry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`textvariable`: This is a Tkinter `StringVar` variable whose value will be
    bound to this `input` widget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show`: This argument determines which character will be displayed when you
    type into the box. By default, it''s the character you type, but this can be replaced
    (for example, for password entry you might specify `*` or dot to be shown instead).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Entry`: This widget, like all the `ttk` widgets, supports additional formatting
    and styling options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Among all the preceding arguments, use of the `textvariable` argument is optional;
    without it, we can extract the value in the `Entry` widget, using its `get()`
    method. Binding a variable to our `input` widget has some advantages, however.
    First, we don't have to keep or pass around a reference to the widget itself.
    This will make it easier to reorganize our software into separate modules in later
    chapters. Also, changes to the value of the input are automatically propagated
    to the variable and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: The Spinbox widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ttk.Spinbox` widget adds increment and decrement buttons to a regular `Entry` widget,
    making it suitable for numerical data.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to Python 3.7, `Spinbox` was only available in Tkinter, not `ttk`. If
    you're using Python 3.6 or an older version, use the `Tkinter.Spinbox` widget
    instead. The sample code uses the Tkinter version for compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Spinbox` widget is created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As seen in the preceding code, the `Spinbox` widget takes some extra constructor
    arguments to control the increment and decrement button behavior, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`from_`**: This argument determines the lowest value to which the arrows
    decrement. The ending underscore is needed because `from` is a Python keyword;
    in Tcl/`Tk` it''s just `from`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`to`**: This argument determines the highest value to which the arrows increment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`increment`**: This argument represents the amount at which arrows increment
    or decrement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`values`**: This argument takes a list of string or number values that can
    be incremented through.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that both `from_` and `to` are required if you use either; that is, you
    cannot just specify a lower limit, doing so will either cause an exception or
    strange behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the `Spinbox` widget in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0af19ce1-0ba8-4436-9c18-41fe6f315936.png)'
  prefs: []
  type: TYPE_IMG
- en: The `Spinbox` widget is not just for numbers, even though that's primarily how
    we'll be using it. It can also take a list of strings, which can be selected using
    the arrow buttons. Because it can be used for strings or numbers, the `textvariable`
    argument takes the `StringVar`, `IntVar`, or `DoubleVar` data types.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that none of these parameters actually limit what can be typed into
    a `Spinbox` widget. It's nothing more than an `Entry` widget with buttons tacked
    on, and you can type not only values outside the valid range, but letters and
    symbols as well. Doing so can cause an exception if you've bound the widget to
    a non-string variable.
  prefs: []
  type: TYPE_NORMAL
- en: The Combobox widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ttk.Combobox` argument is an `Entry` widget that adds a drop-down select
    menu. To populate the drop-down menu, simply pass in a `values` argument with
    a list of the strings, which the user can select.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can execute the following code to create a `Combobox` widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will generate the following widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2b06ad94-ddbd-45f4-8a00-fa095da6b4d9.png)If you''re used to HTML
    `<SELECT>` widgets or drop-down widgets in other toolkits, the `ttk.Combobox` widget
    may seem strange to you. It''s really an `Entry` widget with a drop-down menu
    to select some preset strings. Just like the `Spinbox` widget, it doesn''t limit
    the values that can be typed in.'
  prefs: []
  type: TYPE_NORMAL
- en: The Checkbutton widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ttk.Checkbutton` widget is a labeled checkbox for entering boolean data.
    Unlike `Spinbox` and `Combobox`, it is not derived from the `Entry` widget and
    its arguments are different as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`text`: This argument sets the label for the widget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`variable`: This argument is `BooleanVar`, to which the checked status is bound.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`textvariable`: Unlike the `Entry` based widgets, this argument can be used
    to bind a variable to the label text of the widget. You won''t use this often,
    but you should know it exists in case you mistakenly assign your variable to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can execute the following code to create a `Checkbutton` widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Checkbox` widget appears as a clickable box with a label by it, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8a97f210-253f-438e-afb5-b7f49e04fed9.png)'
  prefs: []
  type: TYPE_IMG
- en: The Text widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Text` widget is much more than just a multiline `Entry` widget. It has
    a powerful tagging system that allows you to implement multicolored text, hyperlink-style
    clickable text, and more. Unlike other widgets, it can't be bound to a Tkinter
    `StringVar`, so setting or retrieving its contents needs to be done through its
    `get()`, `insert()`, and `delete()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'When reading or modifying with these methods, you are required to pass in one
    or two **index** values to select the character or range of characters that you''re
    operating on. These index values are strings that can take any of the following
    formats:'
  prefs: []
  type: TYPE_NORMAL
- en: The line number and character number separated by a dot. Lines are numbered
    from 1 and characters from 0, so the first character on the first line is `1.0`,
    while the twelfth character on the fourth line would be `4.11`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `end` string or Tkinter constant `END`, indicating the end of the field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A numerical index plus one of the words `linestart`, `lineend`, `wordstart`,
    and `wordend`, indicating the start or end of the line or word relative to the
    numerical index. For example, `6.2 wordstart` would be the start of the word containing
    the third character on line 6; `2.0 lineend` would be the end of line 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any of the preceding, a plus or minus operator, and a number of characters or
    lines. For example, `2.5 wordend - 1 chars` would be the character before the
    end of the word containing the sixth character on line 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example shows the basics of working with a `Text` widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding code, you''ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/52c2e54d-1453-4eee-99a0-70c08c082001.png)'
  prefs: []
  type: TYPE_IMG
- en: For the `Notes` field in this form, we just need a simple multiline `Entry`;
    so, we'll only be using the most basic functionality of the `Text` widget for
    now.
  prefs: []
  type: TYPE_NORMAL
- en: The Button widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ttk.Button` widget should also be familiar. It''s just a straightforward
    button that you click with the mouse or spacebar, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/83d80f01-f102-4d59-878d-c674bf8a3d54.png)'
  prefs: []
  type: TYPE_IMG
- en: Just like the `Checkbutton` widget, this widget uses the `text` and `textvariable`
    configuration options to control the label on the button. The `Button` objects
    don't take `variable`, but they do take a `command` argument, which specifies
    a Python function to run when the button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the use of a `Button` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The LabelFrame widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have chosen the `ttk.LabelFrame` widget to group the fields in our application.
    As the name implies, it's `Frame` with `Label` (and a box around it, usually).
    The `LabelFrame` widget takes a `text` argument in the constructor that sets the
    label, positioned in the top-left of the frame.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter and `ttk` contain many more widgets, some of which we'll encounter later
    in this book. Python also ships with a `widget` library called `tix`, which contains
    several dozen widgets. However, `tix` is very outdated, and we won't be covering
    it in this book. You should know that it exists, though.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start our application script, create a folder called `ABQ data entry` and
    a file inside it called `data_entry_app.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with the following boilerplate code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Running this script should give you a blank Tk window.
  prefs: []
  type: TYPE_NORMAL
- en: Saving some time with a LabelInput class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every `input` widget on our form has a label associated with it. In a small
    application, we can just create the label and input separately, then add each
    to the `parent` frame as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That works fine and you could do it that way for your application, but it also
    creates a lot of tedious, repetitious code, and moving inputs around means changing
    twice as much code. Since the `label` and `input` widgets belong together, it
    would be smart to create a small wrapper class to contain both and establish some
    universal defaults.
  prefs: []
  type: TYPE_NORMAL
- en: When coding, be on the lookout for sections that contain a lot of repetitive
    code. You can often abstract this code into a class, function, or loop. Doing
    so won't just save your fingers some typing, it will ensure consistency and reduce
    the total amount of code you have to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll call this class `LabelInput` and define it at the top of our code, just
    under the `Start coding here` comment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll base the class on `Tkinter.Frame`, just as we did with `HelloWidget`.
    Our constructor takes a number of the following arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`parent`: This argument is a reference to the `parent` widget; all widgets
    we create will take this as the first argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`label`: This the text for the label part of the widget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input_class`: This is the class of the widget we want to create. It should
    be an actual callable class object, not a string. If left blank, `ttk.Entry` will
    be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input_var`: This is a Tkinter variable to assign to the input. It''s optional,
    since some widgets don''t use variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input_args`: This is an optional dictionary of any additional arguments for
    the `input` constructor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`label_args`: This is an optional dictionary of any additional arguments for
    the `label` constructor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kwargs`: Finally, we catch any additional keyword arguments in `**kwargs`.
    These will be passed to the `Frame` constructor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first thing we do in the constructor is call `super().__init__()` and pass
    in the `parent` and extra keyword arguments. We then make sure that both `input_args`
    and `label_args` are dictionaries, and save a reference to our input variable
    as `self.variable`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don't be tempted to use an empty dictionary (`{}`) as a default value for a
    method's keyword arguments. If you did so, a dictionary would be created when
    the method definition is evaluated and shared by all objects in the class. This
    would have some very strange effects on your code! The accepted practice is to
    pass `None` for mutable types like dictionaries and lists, then replacing `None`
    with an empty container in the method body.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to be able to take any kind of `input` widget and deal with it appropriately
    in our class; unfortunately, as we learned previously, there are small differences
    between the constructor arguments and behavior in different widget classes, such
    as the way `Combobox` and `Checkbutton` use their `textvariable` argument. At
    the moment, we just need to differentiate between the way button widgets like
    `Button` and `Checkbutton` handle variables and label text. To deal with this,
    we''ll add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For button-type widgets, we do the following tasks differently:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of adding a label, we just set the `text` argument. All buttons use
    this argument to add a `label` to the widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of assigning our variable to `textvariable`, we assign it to `variable`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of other `input` classes, we set `textvariable` and create a `Label`
    widget, adding it to the first row of the `LabelInput` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we need to create the `input` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is pretty straightforward: we call the `input_class` class passed into
    the constructor with the `input_args` dictionary expanded to keyword arguments.
    Then, we add it to the grid at row `1`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, we configure the `grid` layout to expand our lone column across the
    entire widget, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'One nice thing we can do when creating custom widgets that will save us a lot
    of coding is to add defaults to its geometry manager methods. For example, we''re
    going to want all our `LabelInput` objects to fill the entire grid cell that they''re
    placed within. Instead of adding `sticky=(tk.W + tk.E)` to every `LabelInput.grid()`
    call, we can add it as a default value by overriding the method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'By defining it as a default parameter, we can still override it as usual. The
    `input` widgets all have a `get()` method that returns their current value. To
    save some redundant typing later, we''ll implement a `get()` method in our `LabelInput`
    class that will simply pass along the request to the input or its variable. Add
    this method next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re using a `try` block here, because Tkinter variables will throw an exception
    if you call `get()` under certain conditions, such as when a numeric field is
    empty (blank strings can''t convert to a numeric value). In such a case, we''ll
    simply return an empty value from the form. Also, we need to handle the `tk.Text`
    widgets differently, since they require a range to retrieve text. We''re always
    going to want all the text from this form, so we''ll just specify that here. As
    a complement to `get()`, we''ll implement a `set()` method that passes the request
    to the variable or `widget`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.set()` method abstracts away some of the differences between how various
    Tkinter widgets set their values:'
  prefs: []
  type: TYPE_NORMAL
- en: If we have a variable of class `BooleanVar`, cast `value` to `bool` and set
    it. `BooleanVar.set()` will only take a `bool`, not other falsy or truthy values.
    This ensures our variable only gets an actual boolean value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we have any other kind of variable, just pass `value` to its `.set()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we have no variable, and a button-style class, we use the `.select()` and `.deselect()` methods
    to select and deselect the button based on the truthy value of the variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it's a `tk.Text` class, we can use its `.delete` and `.insert` methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, we use the `.delete` and `.insert` methods of `input`, which work
    on the `Entry`, `Spinbox`, and `Combobox` classes. We have to do this separately
    from the `tk.Text` inputs, because the indexing values work differently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This may not account for every possible `input` widget, but it covers the ones
    we plan to use and a few more we may need later. While building the `LabelInput`
    class took a lot of work, we'll see that defining the form is much simpler now.
  prefs: []
  type: TYPE_NORMAL
- en: Building the form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of building our form directly on the main application window, we''re
    going to build our form as its own object. Initially, this makes it easier to
    maintain a nice layout, and later down the road it will make it easier for us
    to expand our application. Let''s perform the following steps for building our
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we''ll subclass `Tkinter.Frame` to build this module. After the
    `LabelInput` class definition, begin a new class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This should be familiar by now. We subclass `Frame`, define our constructor,
    and call `super().__init__()` to initialize the underlying `Frame` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''re going to create a structure to hold references to all the form''s
    `input` widgets, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we create the `input` widgets, we'll store references to them in the dictionary,
    using the field name as a key. This will make it easier later to retrieve all
    our values.
  prefs: []
  type: TYPE_NORMAL
- en: Adding LabelFrame and other widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our form is divided into sections with a label for and a box around each section.
    For each section, we''ll create a `LabelFrame` widget and start adding our `LabelInput`
    widgets to it by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the record information frame by executing the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the `text` argument to `LabelFrame` defines the text of the label.
    This widget will be passed as the `parent` widget to all the inputs in the record
    information group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll add the first line of the `input` widgets, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `Date` and `Technician` inputs are simple text entries; we only need to
    pass the `parent`, `label`, and `input` variables into our `LabelInput` constructor.
    For the `Time` entry, we specify a list of possible values that will be used to
    initialize the `Combobox` widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s work on line 2, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have two more `Combobox` widgets and another `Entry`. These are created
    similarly to those in line 1\. The values for `Plot` just need to be a list of
    numbers from 1 through 20; we can create that with Python''s built-in `range()`
    function. Finished with the record information, we add its `LabelFrame` to the
    form widget with a call to `grid()`. The remaining fields are defined in essentially
    the same way. For example, our environmental data will look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've added the first of our `Spinbox` widgets, specifying the valid ranges
    and increment amount; you can add in the `Light` and `Temperature` inputs in the
    same way. Notice that our `grid()` coordinates have started over with `0, 0`;
    that's because we're starting a new parent object, so the coordinates begin all
    over again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of these nested grids can get confusing. Remember that whenever you call
    `.grid()` on a widget, the coordinates are relative to the top-left corner of
    the widget's parent. The parent's coordinates are relative to its parent, and
    so on, back up to the root window.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section also contains the lone `Checkbutton` widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'There are no real arguments to use with the `Checkbutton`, though note that
    we''re using a `BooleanVar` to store its value. Now, we move on to the plant data
    section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, unlike our decimal `Spinboxes`, we're not setting the increment
    for the integer fields; that's because it defaults to `1.0`, which is what we
    want for integer fields.
  prefs: []
  type: TYPE_NORMAL
- en: We're also using `1000` as a maximum for `Blossoms` although it technically
    shouldn't have a maximum; our `Lab` `Technicians` assured us that it would never
    approach 1,000\. Since `Spinbox` requires both `to` and `from_`, if we use either,
    we'll go ahead and use this value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also specify the strings `infinity` or `-infinity` as values. These
    can be cast to the `float` values, which behave appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Fruit` field and three `Height` fields will be mostly identical to these.
    Go ahead and create them, making sure to follow your data dictionary for the appropriate
    `input_args` values and `input_var` types. We finish our form fields by adding
    the following notes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: There's no need for `LabelFrame` here, so we're just adding the note's `LabelInput`
    frame directly to the form. The `Text` widget takes the `width` and `height` arguments
    to specify the size of the box. We'll give it a nice generous size for note entry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieving data from our form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we're finished with the form, we need a way to retrieve data from it
    so it can be processed by the application. We'll create a method that returns
    a dictionary of the form's data and, as we did with our `LabelInput` objects,
    maintain the Tkinter convention of calling it `get()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to your form class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is simple: we loop through our instance''s `inputs` object containing
    our `LabelInput` objects and build a new dictionary by calling `get()` on each
    variable.'
  prefs: []
  type: TYPE_NORMAL
- en: This code demonstrates the power of both iterable objects and consistent naming
    schemes. If we had stored our inputs as discrete properties of the form, or neglected
    to normalize the `get()` method, our code would be a lot less elegant.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting our form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re almost done with our form class, but there''s one more method needed.
    After each save of the form, we''re going to need to reset it to empty fields;
    so, let''s add a method to do that by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this method to the end of the form class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As with our `get()` method, we're iterating through the `input` dictionary and
    setting each `widget` to an empty value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make sure our application behaves consistently, we should call `reset()`
    immediately after the application loads, clearing out any `Tk` defaults that we
    might not want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back up to the last line of `__init__()` and add the following code line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Building our application class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following steps for building our application class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Move down under the `Application` class doc string (the line that reads `Application
    root window`) and start an `__init__()` method for `Application`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Once again we make the familiar call to `super().__init__()`, passing along
    any arguments or keyword arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that we don't pass in a `parent` widget here, since `Application` is the
    root window.
  prefs: []
  type: TYPE_NORMAL
- en: We call `.title()` to set our application's title string; this isn't required,
    but it will certainly help users who are running multiple applications to find
    our application quickly in their desktop environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We also prohibit resizing of the window with a call to `self.resizable`. This
    also isn''t strictly necessary, but it makes it simpler for us to control our
    layout for the time being. Let''s start adding our application components as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The application will start at the top with a `Label` object showing the name
    of the application in a larger than normal font. Notice that we don''t specify `column`
    here; our main application layout will only have one column, so it''s not strictly
    necessary to specify `column`, as it defaults to `0`. Next, we''ll add our `DataRecordForm` as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We're adding 10 pixels of padding on the left and right using the `padx` argument
    to `grid`. This just adds a little whitespace around the edges of the form, making
    it a bit more readable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s add in the save button next, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We've given the button a `command` value of `self.on_save`; we haven't written
    that method yet, so we'll need to do that before we can run our code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When writing methods or functions to be callbacks for a GUI event, it's conventional
    to use the format `on_EVENTNAME`, where `EVENTNAME` is a string describing the
    event triggering it. We could also name this method `on_save_button_click()`,
    but for now `on_save()` is adequate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s add in the status bar, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We start by creating a string variable called `self.status` and use this as `textvariable`
    for `ttk.Label`. All our application will need to do to update the status is call
    `self.status.set()` anywhere inside the class. Our GUI is completed by adding
    the status bar to the bottom of the application widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Saving to CSV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a user clicks on save, the following chain of events needs to take place:'
  prefs: []
  type: TYPE_NORMAL
- en: A file called `abq_data_record_CURRENTDATE.csv` is opened
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the file doesn't exist, it will be created, and field headers will be written
    to the first line
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The data dictionary is retrieved from `DataEntryForm`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The data is formatted as a CSV row and appended to the file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The form is cleared, and the user is notified that the record was saved
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''re going to need a few more Python libraries to help us out with this:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll need a date string for our filename. Python's `datetime` library
    can help us here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we'll need to be able to check if a file exists. Python's `os` library
    has a function for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to be able to write to a CSV file. Python has a CSV library
    in the standard library that would be perfect here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Back up to the top of the file and add the following imports above the Tkinter
    imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go back to the `Application` class and start the `on_save()` method, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is create our date string. The `datetime.today()` method
    returns a `datetime` at midnight of the current day; we then format this using
    `strftime()` to an ISO date string in the form year-month-day (using numbers 01
    through 12 for the month). This gets plugged into the filename template from our
    specification and saved as `filename`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to determine whether the file already exists; `os.path.exists()`
    will return a boolean value indicating if the file exists; we negate this value
    and store it as `newfile`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s get the data from `DataEntryForm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'With the data acquired, we need to open our file and write the data into it.
    Add in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `with open(filename, 'a') as fh:` statement opens our generated filename
    in append mode and gives us a file handle called `fh`. Append mode means we can't
    read or edit any existing lines in the file, just add to the end of it, which
    is exactly what we want.
  prefs: []
  type: TYPE_NORMAL
- en: The `with` keyword works with **context manager** objects, which our call to
    `open()` returns. Context managers are special objects that define code to run
    before and after the `with` block. By opening files using this method, they'll
    automatically be closed correctly at the end of the block.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a `csv.DictWriter` object using the file handle. This object
    will allow us to write dictionaries of data to the CSV file, matching up the dictionary
    keys with the CSV's header row labels. This will work better for us in the long
    run than the default CSV writer object, which would require the fields in the
    correct order every time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To configure this, we have to first pass in the `fieldnames` argument to the
    `DictWriter` constructor. Our field names are the keys of the `data` dictionary
    that we get from the form. If we're working on a new file, we need to write those
    field names to the first row, which we do by calling `DictWriter.writeheader()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we write our `data` dictionary to a new row, using the `.writerow()`
    method of our `DictWriter` object. At the end of the code block, the file is automatically
    closed and saved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finishing and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, you should be able to run the application, enter data, and save
    it to the CSV file. Try it out! You should see something similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9708ab24-6d9f-4276-935b-454f6110dc31.png)'
  prefs: []
  type: TYPE_IMG
- en: Perhaps the first thing you notice is that clicking Save has no noticeable effect.
    The form stays populated, and there's no indication that anything was done. We
    should fix this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll perform the following two things to help here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, put a notification in our status bar that the record was saved and how
    many records have been saved this session. For the first part, add the following
    code line to the end of the `Application` constructor, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, clear the form after saving, so the next record can be started. Then
    add the following code line to the end of the `on_save()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This code sets up a counter variable that will keep track of the number of records
    we've saved since the application was started.
  prefs: []
  type: TYPE_NORMAL
- en: After saving the file, we increment the value, then set our status to indicate
    how many records have been saved. Users will be able to see this number increase
    and know that their button click has done something.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we''ll reset the form after saving. Append this code to the end of `Application.on_save()`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: That will zero out the form and ready it for the next record to be entered.
  prefs: []
  type: TYPE_NORMAL
- en: Now, run the application again. It should clear out and give you a status indication
    on saving a record.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, we've come a long way in this chapter! You took your design from a specification
    and some drawings to a running application that already covers the basic functionality
    you need. You learned to work with basic Tkinter and `ttk` widgets, and create
    custom widgets to save yourself a lot of repetitive work.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to address the issues with our `input` widgets.
    We'll learn to customize the behavior of our `input` widgets, prevent erroneous
    keystrokes, and validate the data to make sure it's within the tolerances laid
    out in our specification. Along the way, we'll dig deeper into Python classes
    and learn more techniques for efficient and elegant code.
  prefs: []
  type: TYPE_NORMAL
