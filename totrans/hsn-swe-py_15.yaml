- en: Anatomy of a Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next logical chunk of functionality to attack in `hms_sys` is the Artisan
    Gateway Service. This service waits for input from either Artisan or Central Office
    end users, creating or updating object data as needed, and perhaps synchronizing
    that data with the web store system's database. Both of the end user applications
    are expected to communicate with the Artisan Gateway Service on a completely random
    basis; whenever someone wants to make a change to the data, it'll be ready and
    waiting to process that request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can really implement this service, however, we need to work out how
    any service can or should work, written in Python. To that end, we will have to
    examine and understand the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic implementation of the structure of a service, including the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Options for managing the configuration of a service instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How a service can read and respond to requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How and when a service is launched in the following environments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A reasonably modern, POSIX-compliant system (Linux, for example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether there are other, better designs that will work in any OS that Python
    is available on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to better understand these facets of the implementation and execution
    of a service, we'll build a basic service structure from the ground up, which
    can then be used as a foundation for the final Artisan Gateway Service.
  prefs: []
  type: TYPE_NORMAL
- en: What is a service?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Services, at their most basic, are simply programs that run in the background
    on a computer. They typically wait for input from somewhere, perform some actions
    based on that input, and return data that, at a minimum, indicates that the actions
    that were undertaken either succeeded or failed. At the most basic level, the
    input might not even be something that is visible to a user; services that wait
    for network activities, monitor filesystems, or even just run on some sort of
    timer-controlled basis, are very common in many operating systems today.
  prefs: []
  type: TYPE_NORMAL
- en: 'Services should always be available, running continuously, for as long as the
    host machine is running; this has some implications for how they are written and
    implemented, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'They have to be very fault-tolerant: a service that crashes and dies every
    time something unexpected happens, and has to be restarted as a result, is of
    little use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They should, arguably, be as functionally self-contained as is possible; external
    dependencies that could fail (and cause a running service to crash as a result)
    should be examined with a critical eye.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because their operations may be completely invisible to the user, there is a
    lot of potential for a poorly designed or implemented service to overrun system
    resources, which could eventually take down an entire machine. Even if there is
    no multi-processing involved, care needs to be taken and discipline exercised,
    in order to avoid things such as loops that never terminate or functionality that
    leaves orphan objects, data, or functions in memory. If these occur, it's just
    a matter of time (or load on the service) until the memory or available CPU dwindles
    to nothing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All that said, services aren''t necessarily all that complex. If there are
    operating system facilities available to manage the actual code execution (startup
    and shutdown), they might not be any more complex, structurally, than the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When the preceding code is run, it generates no user-visible output, but watching
    the system logs (using `tail -f /var/log/syslog`, on a Linux machine) shows that
    it is doing what it''s supposed to, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It writes the starting message to the log file before entering the main loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In each pass through the loop, it does the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writes a message to the log, with the iteration number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sleeps for 10 seconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increments the iteration counter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The exiting message is not being written to the log file, but that''s expected
    at this point, since the only way to stop the main loop is to kill the program
    itself, and that terminates the program without exiting the loop. A typical log
    output, from startup through a few iterations, looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dca94723-260b-4259-8c2e-6b36f357ca94.png)'
  prefs: []
  type: TYPE_IMG
- en: This isn't much of a service, to be sure, but it illustrates what might be considered
    the bare minimum of the functionality that would be common to any service.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the heart of most services is a loop that runs until the service is shut
    down or killed. Within that loop is where the service will actually check for
    input, in one of several ways. Some of the more common variants include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It could be waiting on a request coming in over a network socket (a web service
    would use this approach).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It could be waiting on incoming data from standard input (`stdin`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It could actively poll for incoming messages from an external queue system,
    such as RabbitMQ, or cloud-based equivalents, such as AWS's SQS or Google Cloud
    Platform's Cloud Pub/Sub.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are only a few of the possibilities for service input. Other mechanisms
    that don't lend themselves to a direct waiting-for-something model could always
    push events into a local queue, and have the service watching or polling from
    that queue mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'In all but the most basic of services, incoming requests will have to be evaluated,
    to determine what functionality has to be called in order to handle the request.
    The most common mechanism for associating incoming request data to a specific
    functionality is probably a large `if…elif…else` structure that passes the responsibility
    for handling a request to specific and dedicated functions, looking something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Each of the `handle_{something}_request` functions, then, would be responsible
    for taking the incoming request, determining what to do with it, and returning
    the resultant data.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a standard Python library, `python-daemon`, that takes this basic
    approach a step further, allowing a function to be wrapped in a basic daemon context.
    The same basic function, with a `python-daemon DaemonContext` wrapped around it,
    is very similar, and is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The terms **service** and **daemon** are, for the purposes of this book, interchangeable;
    they both refer to the same sort of background process program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The execution of this code yields almost identical results (barring the filename
    that appears in the log messages, it is identical, in fact). The actual differences
    are effectively invisible, once the daemon code is running. Using `DaemonContext`
    provides some operational aspects that the bare-bones, function-only code does
    not deal with, which are considered to be best practices for daemon processes:'
  prefs: []
  type: TYPE_NORMAL
- en: Assuring that any open files associated with the command during startup get
    closed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the working directory for the process to a known and/or secure directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the file-creation permissions mask, so that the files created by the
    processes will have a known (and securable) permissions set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing system-level process setup, to allow the process itself to run in
    the background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dissociating the process from any Terminal activity, so that it won't respond
    to Terminal input once the daemon process is launched
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although `python-daemon` is a standard library, it may not be part of a standard
    Python installation. If not, it can be installed with `pip install python-daemon`.
  prefs: []
  type: TYPE_NORMAL
- en: The `python-daemon` module, then, provides a very easy way to manage a lot of
    the best-practice operations for writing daemons and services. There is, however,
    a potential problem with using it. It won't work on systems that don't have a
    Unix-like password database (it depends on the `pwd` module, which is Unix-only).
    That rules it out for services that need to run on Windows systems, at the very
    least.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, though, knowing that a service implementation doesn't have to be
    much more than a single function call with a perpetual loop, the main concern (outside
    of the implementation of the service's logic) is probably how to get the host
    operating system to start, stop, and manage the service instance. We'll examine
    that in considerably more detail at the end of the chapter, but there are a few
    other common service implementation patterns and concerns that bear some examination,
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Services frequently have to be configurable without making changes to the actual
    service code, so that the end users or managers of active services don''t have
    to be developers themselves, in order to be able to effectively manage running
    service instances. There are several options that can be used to read configuration
    and setting values from files, each with its own strengths and weaknesses. In
    order to better compare and contrast them, let''s examine the variations that
    provide the configuration for a service that does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Logs information, warning, error, and critical level messages:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information and warning level messages to a console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything, including information and warning level messages, to a single, common
    log file, whose location is configurable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Listens for input messages from a queue service, such as RabbitMQ, or a cloud-based
    queue service, such as AWS''s SQS or Google Cloud Platform''s Pub/Sub, and needs
    to know the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A queue name or URL to listen to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How often to check for incoming messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The credentials for access to the queue in question
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows-style .ini files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python has a standard package for working with INI files (or, at least, files
    that are similar to basic Windows INI files): `configparser`. A compatible INI-like
    file that provides the configuration for previously listed items might look something
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the advantages of an INI-style configuration file include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The file structure allows for comments to be used. Any line starting with a
    `#` or `;` is a comment, and is not parsed, which allows for configuration files
    to be documented inline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Values specified in the `[DEFAULT]` section are inherited by all of the other
    sections, and are available as specified originally, or to be overridden in later
    sections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The format itself has been around for a long time, so it's very mature and stable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This configuration file''s values can be examined with a simple script, listing
    the available values in each configuration section and showing some of the potential
    disadvantages of the format, as parsed with `configparser` tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/652d2502-74c7-4453-a560-6cb446c03c9f.png)'
  prefs: []
  type: TYPE_IMG
- en: The script that generated this output is in the code for *Iteration 3*, at `hms-gateway/scratch-space/configuration-examples/ini_config.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the potential disadvantages of the format include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The values in the `[DEFAULT]` configuration section are inherited by all other
    sections, even if they are not relevant. The `queue_type` and `queue_check` values
    are available in the `console_log` and `file_log` sections, for example, where
    they aren't really relevant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All configuration values are strings, and would probably have to be converted
    to their real value types: an `int` for `queue_check` and `rabbit_config:port`,
    probably a `list` of `str` values for `console_log:capture`, a conversion to `bool`
    values for any that might appear, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The format only really supports two levels of configuration data (sections and
    their members).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None of these constraints are likely to be too problematic, though. Knowing
    that they exist is generally going to be enough to plan for how they will be accommodated,
    and the shape of that accommodation might be nothing more complicated than having
    no `[DEFAULT]` section, and grouping configuration values into more coherent sections,
    such as `logging` and `queue`.
  prefs: []
  type: TYPE_NORMAL
- en: JSON files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSON data structures are also a viable candidate for storing configuration
    file data. JSON supports data of different types, and complex data structures.
    Both are advantages, however trivial they might be, over the basic INI-file structure.
    There is no predefined organizational structure, though, so figuring out how configuration
    values should be grouped or organized is something that developers will have to
    give some thought to. There is also no inheritance of configuration data across
    sections, because there are no sections to inherit from. Still, it''s a simple,
    robust, and reasonably easy-to-understand option. An approximate JSON equivalent
    of the preceding INI-flavored configuration file might look something such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If JSON has any disadvantages (with respect to its use as a configuration-file
    format), they'd include the fact that there isn't a good way to allow in-file
    comments. The `load` and `loads` functions provided by Python's `json` module (for
    converting a JSON string and a JSON file, respectively) raise an error, `JSONDecodeError`,
    if there is anything other than data structure in the JSON data being parsed.
    That's not a deal-breaker, but there are definitely advantages to having the ability
    to add comments (and thus, documentation) to a configuration file, especially
    if that configuration is going to be managed by someone that isn't a developer,
    or isn't willing (or able) to dig into the code itself, in order to work out how
    to configure some aspect of a system.
  prefs: []
  type: TYPE_NORMAL
- en: YAML files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another good contender for configuration files is YAML. YAML acts like JSON
    in many respects, in that it provides structured and typed data representations,
    and can support complex, nested data structures. In addition, it allows for inline
    comments, and the `pyyaml` module supports hinting for data structures that would
    not be usable at all in a JSON-based approach. YAML, like Python, uses indentation
    as a structural organization mechanism, indicating (in YAML''s case) the key/value
    relationship between items. An equivalent to the preceding JSON configuration
    file (with comments, and breaking all elements (objects, list members, and so
    on) into discrete items in the file), would look  like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We'll build on the idea of using YAML to configure a service later in this chapter.
    YAML obviously isn't the only option, but it's one of the better ones, allowing
    for a good combination of ease of understanding, the ability to comment/document,
    and the availability of more than one value type.
  prefs: []
  type: TYPE_NORMAL
- en: Logging service activities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since services often run invisibly, in the background, they usually log their
    activities in some fashion, if only to provide some visibility into what happened
    during a service call where something went awry. Python provides a module, `logging`,
    that allows for a lot of flexibility for logging events and messages from a running
    program. The following is a very simple, brute-force example of a reasonably complete
    logging process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, the preceding script generates the following log output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d327f806-4d00-4481-a03f-48c932ce127a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A Python `Logger` object (which is what''s returned by the `getLogger` call)
    can be set up to pay attention to log messages of varying priority levels. In
    order from the least to the most critical (from a production-system standpoint),
    the default levels available (and some typical uses for them) are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DEBUG`: Recording information about processes as they run, steps they undertake,
    and the like, with an eye toward providing some visibility into the details of
    how the code was executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INFO`: Informational items, such as the start and end times of request-handling
    processes; and perhaps details or metrics on the processes themselves, such as
    what arguments were passed, or if a given execution took longer than expected,
    but still completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WARNING`: Conditions that didn''t prevent processes or operations from completing,
    but that were suspect for some reason, such as taking a lot longer than expected
    to complete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ERROR`: Actual errors that were encountered as the code executed, perhaps
    including detailed trace-back information that would help a developer figure out
    what actually caused the error in question.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CRITICAL`: Recording information that was intercepted before a critical/fatal
    failure of the running code – something that actually killed the execution. In
    well-designed and implemented code, especially for a service that is intended
    to always be available, this level of message recording should rarely be needed.
    Errors would be captured and logged as `ERROR`-level items, any cleanup that would
    be required after the error was encountered would be undertaken, a response indicating
    that an error occurred would be sent back to the requester, and the service would
    just keep going, waiting for the next request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual handling and recording of the messages of any given level are controlled
    by the `Logger` object, and/or by its various handlers. The `Logger` object itself
    will not accept messages with a priority lower than its set priority. Having `logger.setLevel(logging.DEBUG)` in
    the example code would allow any of the standard message priorities, while changing
    it to `logger.setLevel(logging.ERROR)` would only allow `ERROR` and `CRITICAL`
    messages to be accepted. Similarly, the handlers will ignore any incoming messages
    that fall below the priority they've been configured to accept – `file_handler.setLevel(logging.DEBUG)`, in
    the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: 'By combining detailed logging in the code itself, including `DEBUG`-level items
    wherever it is necessary, and some configuration of the allowed message-priorities,
    the same code can fine-tune its own log output for different environments. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This code set logs the following, depending on the differences in logging priorities
    set up in the `logger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f124f29f-90d6-4d36-9d11-f63cc7ef9c75.png)'
  prefs: []
  type: TYPE_IMG
- en: The complete script that generates this log information is in the *Iteration
    3* code, at `hms-gateway/scratch-space/logging-examples/logging-example.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Like YAML configuration, we'll build on this logging structure later in this
    chapter, as a part of building a reusable base daemon structure.
  prefs: []
  type: TYPE_NORMAL
- en: Handling requests and generating responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most services will follow some sort of a request-response process model. A request
    is received, whether from a human user interacting with the service or some other
    process; the service then reads the request, determines what to do with it, performs
    whatever actions are needed, and generates and returns a response.
  prefs: []
  type: TYPE_NORMAL
- en: There are at least three distinct request types that are common enough to warrant
    a detailed examination – filesystem, HTTP/web message, and queue-based – each
    with its own baseline assumptions about how requests will be presented to a service,
    and each with its own resultant implications for design and execution.
  prefs: []
  type: TYPE_NORMAL
- en: The responses generated for any given request type usually imply a response
    mechanism of the same basic type. That is, a request that comes in from some filesystem
    variant will usually generate a response that is also expressed as some sort of
    filesystem output. That may not always be the case, but the odds are good that
    it will be in many (perhaps most) cases.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem – based
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Requests and responses from and to the local filesystem are typically (and unsurprisingly)
    concerned with reading and writing data from and to local files. The simplest
    request-and-response structure of this type is a service that reads data from
    one file, processes it, and writes the results out to another file, possibly deleting
    or flushing out the incoming file on every read, and either replacing the output
    file on every write, or appending to it as each response is generated and returned.
    Implementations for single input and output files may leverage the `stdin` and
    `stdout` functionality of Python's `sys` module, or override either (or both)
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: Both Windows and POSIX operating systems (Linux, macOS) have special file types,
    called **named pipes,** that reside on the filesystem and act like files, in that
    they can be opened, read from, and written to by using standard file-access code.
    The main difference is that a named pipe file can be opened and written to/read
    from by multiple different processes at the same time. That, then, allows for
    any number of processes to add requests to a file, queuing them up for a service
    to read and handle. Named pipes can also be used for service output.
  prefs: []
  type: TYPE_NORMAL
- en: Another variant is monitoring for changes to files in the local filesystem,
    including the creation of new files, and changes to (or even the deletion of)
    existing files in a given location. At its most basic, this would involve generating
    and maintaining a list of files to keep track of, and periodically checking the
    actual filesystem structure for those files' existence and modified time. An implementation
    that follows this pattern might have a common input-file directory, and, as each
    iteration through the main service loop occurred, it would check for new files,
    read them, execute, and remove the file once processing was complete (in order
    to keep the number of files being monitored reasonably small).
  prefs: []
  type: TYPE_NORMAL
- en: For scenarios where the number of files being monitored is large enough that
    creating and refreshing that list is too computationally expensive to be practical,
    monitoring filesystem events with functionality from the `pyinotify` library is
    a viable alternative, though there have been differences in what's available between
    POSIX/Linux and Windows versions of the library.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP- or web-based
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP-based services (web services), as the name implies, use the HTTP protocol
    to receive requests and transmit responses to those requests. As a subset of network-aware
    services, web services allow access to the service from machines other than the
    one that the service is actually running on. Web services don't have to be accessible
    on the public internet; they can live entirely in a local network, and operate
    just as well inside of those boundaries. They do, however, have to conform to
    some basic minimum standards, and could benefit from adhering to others.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is likely that the most important of those standards is adhering to the
    request methods of the HTTP protocol. The methods that are most commonly seen
    in websites, and that are supported by any web browser worthy of the name, are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: Used to retrieve data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: Used to create data using an attached payload, even though `POST` is
    typically used in web applications, for both `create` and `update` operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several other methods available in the protocol, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PUT` and `PATCH`: Intended to update data using an attached payload, in whole
    or in part, respectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: Intended to delete data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTIONS`: Intended to provide data that indicates what methods are available,
    especially methods that can create or alter data on the receiving system, such
    as `POST`, `PUT`, and `DELETE` requests, and, most especially, if a request is
    being made to the service from somewhere other than the service''s domain itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other methods that might come into play include `HEAD`, `CONNECT`, and `TRACE`. Depending
    on the design and implementation of the service, each HTTP method can be implemented
    as specific functions or methods of a class, allowing each request type to be
    able to enforce any requirements specific to it, while still allowing some functionality
    for common needs, such as the extraction of a payload for `POST`, `PUT`, and `PATCH`
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: A response from a web-service call, even if it's an empty response, is effectively
    required; otherwise, the calling client will wait until the request times out.
    Web service responses are limited to data types that can be transmitted by the
    HTTP protocol, which isn't very limited, but may require some additional development
    effort to support binary-resource responses (for example, images). As things stand,
    at the time of writing this book, most responses that can be represented purely
    in text seem to be returned as JSON data structures, but XML, HTML, and plain-text
    responses are also in the realm of possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it''s certainly possible to write a full-blown web service purely
    in Python, there are a fair number of protocol-related items that might be better
    handled by any of several libraries, packages, or frameworks, if only because
    doing so would reduce the volume of code to be written, tested, and maintained.
    Options include, but are not limited to, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing a web service as a **Web Server Gateway Interface*** (***WSGI**) application
    that is accessible through an Apache or NGINX web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Django REST framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Flask-RESTful extension to the Flask framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A web- server- and framework-based solution will also benefit from security
    updates to the underlying web server and framework software, without requiring
    in-house security audits.
  prefs: []
  type: TYPE_NORMAL
- en: If a web service is expected to be exposed to the public internet, any of these
    are much better options than writing a service from the ground up, for that reason
    alone. It won't eliminate the need to be conscious of potential security concerns,
    but it will reduce the scope of those concerns to the code for the service's functionality
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: Message- queue-based
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Message queue systems, such as RabbitMQ and the various cloud-based options,
    have several advantages going for them for certain types of applications. They
    generally allow pretty much any message format to be used, provided that it can
    be expressed as text, and they allow messages to remain in a pending state until
    they are explicitly retrieved and dealt with, keeping messages safe and ready
    to use until the final consumer of those messages is ready to consume them. By
    way of example, consider the following scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: Two users are sending messages to a service through a distributed queue that
    lives on the Message-Queue Server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'User #1 sends their first message'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The service receives and acts on that message, but may not have deleted it in
    the queue yet
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The service is restarted for some reason – to update it to a new version, perhaps,
    or because the server itself is being rebooted
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In any case, before the service comes back online, User #2 sends their first
    message.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'User #1 sends another message'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before the target service completes its startup, the scenario looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ceb3060d-8151-48d2-afe2-71df72ce3c92.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the target service has completed its startup, all it has to do to fulfill
    the pending requests in those messages is poll the Message-Queue Server to retrieve
    any pending messages, and execute against them, just like it was doing before
    it was restarted.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the perspective of User #1 and User #2, there has been no interruption
    in access to the service (though there may have been a noticeable, or even significant,
    delay in getting their responses back). That would hold true whether the inactive
    period for the target service was a few seconds, or a few hours. Either way, the
    messages/commands that the end users sent were saved until they could be acted
    upon, so no effort was lost.'
  prefs: []
  type: TYPE_NORMAL
- en: If the responses to those requests are also transmitted through a queue-based
    process, the same persistence of messages would hold true. So, as soon as the
    responses have been generated and sent by the target service, the users are able
    to receive them, even if they shut down and went home for the day before they
    were sent. Response messages would wait until the receiving system was active
    again, at which point they'd be delivered and acted upon.
  prefs: []
  type: TYPE_NORMAL
- en: Queue-based request-and-response cycles are, then, *very* well suited for managing
    log running and/or asynchronous processes, provided that the code that's acting
    on the messages takes that possibility into account.
  prefs: []
  type: TYPE_NORMAL
- en: Other request types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python provides access to enough general-purpose networking functionality that
    services can be written from scratch to read and respond to pretty much any sort
    of network traffic desired. The web- and queue-based service types are specific
    applications of that functionality, under the hood, supported to varying degrees
    by additional libraries that address some of the needs specific to each, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Web services will probably make at least some use of the functionality provided
    by the `http.server`, or `socket` modules; the `http.server.HTTPServer` or `socketserver.TCPServer`
    classes are the most likely starting points, but `http.server.ThreadingHTTPServer`
    is also potentially viable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Queue-based services may have libraries available that are specifically built
    to interact with the underlying queue service they''re attached to, including
    the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pika`, for RabbitMQ queue-services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boto3`, for AWS SQS services, starting with creating a `boto3.SQS.Client`
    object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Socket-based services that don't have some sort of supporting library available
    will probably start with the `socketserver.TCPServer` class noted in the previous
    lists, or perhaps with its UDP equivalent, `socketserver.UDPServer`. There are
    also `Threading` and `Forking` mix-in classes available, which can be used to
    provide basic server classes that support threading or (on POSIX-compliant systems)
    forking for servers, in order to handle larger user load levels.
  prefs: []
  type: TYPE_NORMAL
- en: Request and response formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From a purely technical/functional perspective, service implementations can
    be data- and format-agnostic. That is, there's no functional reason why a service
    cannot accept raw binary data input and return raw binary output. Data is data,
    after all. However, even in cases where a service really is concerned with data
    that isn't readily readable by human beings, there are advantages to formatting
    the incoming requests and outgoing responses, to afford some degree of human readability.
    At a minimum, it makes the debugging of requests and responses easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that respect, request and response data share a lot of the concerns that
    were noted about the needs of configuration files, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Being able to pass structured and typed data around is similarly advantageous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing that data structure to be at least somewhat comprehensible to a casual
    reader/observer feels like a good thing, too
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to represent reasonably complex data structures—lists and nested
    objects—also feels advantageous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given the same types of concerns, a similar solution to address them makes sense,
    which means that using a serialization format, such as JSON or YAML, also makes
    sense. Doing so introduces a bit of additional development effort overhead; for
    example, converting incoming data from JSON to a native data structure, or an
    outbound native data structure response to JSON. That effort will generally be
    pretty trivial, though.
  prefs: []
  type: TYPE_NORMAL
- en: Of those two formats, JSON is arguably a better general*-*purpose solution.
    It's well established, and it's directly supported across a wider range of potential
    service clients, if only because it is, essentially, a native data format for
    web browsers. YAML is still a viable alternative, though, particularly in cases
    where there is no web browser client support needed.
  prefs: []
  type: TYPE_NORMAL
- en: A generic service design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given the configuration and logging possibilities that we've explored so far,
    the bare-bones service-as-a-function approach feels less and less viable, unless
    it's reasonable to expect that only one service will ever need to be written.
    Taking that basic approach is still possible, to be sure, but if there's ever
    a need to create another service, it'd be more efficient (and, at least, a somewhat
    more effective use of developer time) if there were a common starting point for
    creating any service, no matter what it's expected to do. To that end, then, we'll
    define a set of **abstract base classes** (**ABC**) that define the lowest common
    denominators of features and functionality that we'll expect from any service
    or daemon going forward, and we'll use that as our starting point for the Artisan
    Gateway Service of `hms_sys`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rationale for defining a service as a class, rather than as a function,
    is centered around the fact that we can reasonably expect at least a handful of
    properties and methods that would be common to all services/daemons, that would
    be difficult, tedious, and/or hard to maintain in a simple, function-based design.
    These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A centralized logging facility, built along the lines of the example logging
    code presented earlier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A strong possibility that configuration values for the service will need to
    be accessible across multiple endpoints, which is probably easier to manage with
    a class-based design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to use what might be called pluggable request, response, and formatting mechanisms
    will almost certainly be a lot easier to develop and maintain, since those would
    be represented by classes that encapsulate all of the necessary functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The classes defined here do not leverage any of the available standard library
    entities that were noted earlier (for example, normal, threaded, or forking variants
    of `socketserver.TCPServer`). They are, instead, a baseline starting point for
    *any* service, at least at one level, and could potentially use any of those server
    classes as additional mix-ins, if desired. At another level, they could be considered
    purely illustrative of the kinds of functionality needed in a service class, though
    they are also viable for use as a service class, for some applications.
  prefs: []
  type: TYPE_NORMAL
- en: These classes are also purely synchronous*.* They handle one request at a time,
    processing it to completion and returning a response, before acquiring the next
    request and handling it. That will probably suffice for low-load scenarios, of
    the sort expected in the context of the `hms_sys` system projects, but might not
    be enough for other use cases, especially if real-time responses and higher computational-cost
    processes get involved. We'll examine some options for dealing with those kinds
    of scenarios in [chapter 19](0f8e550d-d950-4551-ba4b-b652003658a5.xhtml), *Multiprocessing
    and HPC in Python*, while discussing local process-scaling options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The collection of ABCs that we''re going to build is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d8f71825-442b-49b7-82ac-a42364164950.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BaseDaemon` is a starting point for creating classes that actually provide
    the service itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BaseRequestHandler` provides a starting point for defining callable objects
    that will be used to actually handle an incoming request, and that will be responsible
    for formatting the results using an instance of a class derived from `BaseResponseFormatter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BaseResponseFormatter` is a similar, callable-object class that will convert
    a response data structure into a serialized string value, ready to be returned
    as a message in a queue, an HTTP response, or whatever other format is best suited
    for the specific response requirement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The BaseDaemon ABC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The implementation of `BaseDaemon` starts, unsurprisingly, with a standard
    ABC definition, and some class-level attributes/constants, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Since logging is a critical aspect of any service, making sure that some logging
    parameters are always available is a good idea. That starts with setting up a
    class-level constant that stores the default logging configuration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Those defaults are used by a common `_create_logger` method, provided as a
    concrete method by the class, to assure that logging will always be available,
    but that the parameters that control it can be overridden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After checking to see whether a logger name has been specified, the `_logging`
    class attribute is used to define a common log output format, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The same logging settings allow for independent control of the file and console
    output for logging. The file-based log output needs a `logfile` specification,
    and allows for an independent `level`, as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As each logging output is created and attached, the logging level is used to
    reset the `final_level` value, which will eventually allow the setup process to
    fine-tune the logging level for the logger object that the output is being attached
    to. The console logger output setup looks much the same as the file logger output,
    minus the filename, which it doesn''t need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to assure that logging will always be available, all of the setup
    so far executes in a `try…except` structure. If any errors occur during the process
    of setting up logging, a final `RuntimeError` is raised, with the intention of
    stopping all execution, so that whatever''s causing the logging failures must
    be fixed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the instance''s `logger` object property has been created, logging any
    message is simply a matter of calling one of the instance''s various logging methods.
    Those methods – `critical`, `debug`, `error`, `info`, and `warn` – all look more
    or less alike, and will write the message supplied to the various pieces of logger
    output with the appropriate priority, or will fall back to printing the message,
    if the `logger` hasn''t been created yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The properties of the class are, for the most part, typical of the structures
    and patterns that have been used in earlier code, with typical type and value
    checking attached to their related setter methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The setter method for the `config_file` property is worth a closer look, perhaps,
    since it performs some checking, to make sure that the value passed is a readable
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Once the configuration file has been verified as ready for use, another concrete
    method provided by the class, `configure`, can be called to read and apply it
    to an instance of the class. The `configure` method is responsible for reading
    the file, converting it to a common data structure, and handing it off to a required/abstract
    method that actually applies the configuration data to the instance: `_on_configuration_loaded`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This division of responsibilities allows for a single common method, `configure`, to
    be consistently available, while allowing for the specific needs of any given
    class to be abstracted and made the responsibility of the derived class, `_on_configuration_loaded`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_on_configuration_loaded` method can contain some concrete code that other
    classes may choose to use, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If this standard configuration is used, it will be looking for a YAML configuration
    file that might look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It is worth noting that the various configuration methods may well deal with
    logging settings, and need to log messages before logging is complete. That is
    why the logging methods shown earlier have the fall-back-to-printing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default implementation that was just shown does exactly that. That accounts
    for all of the code that executes when an instance of `BaseDaemon` is created.
    The initialization itself is pretty basic, though there are a couple of new and
    noteworthy items in it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first items of note are the calls to `signal.signal()`. These use Python's
    `signal` module to set up signal-event-handling processes, so that a running instance
    of the class, if it's killed at the OS level or interrupted in a Terminal session,
    will not just immediately die. Instead, those calls trap the termination (`SIGTERM`)
    and interruption (`SIGINT`) signals that the OS has issued, and allow the running
    code to react to them before terminating execution. In this case, they both call
    the instance's `stop` method, which gives the service instance the opportunity
    to tell its `main` loop to terminate, and thus allows for a graceful shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way for that to be implemented is to have an instance value (`self._running`,
    in this case) that is used by the main loop of the service to determine whether
    to continue. That flag value is set at the end of the previous `__init__` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the `main` loop method of a service class is the most important aspect
    of the class (without one, the service doesn''t actually do anything, after all),
    that `main` loop is something that is going to be specific to the derived class.
    It''s required, but it cannot really be implemented at the ABC''s level, so it''s
    made an abstract method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to allow for processes that need to fire off before a service starts
    and after it terminates, we''re providing concrete methods for each `preflight`
    and `cleanup`. These methods were made concrete, rather than abstract, so that
    they''d always be available, but could be overridden on an as-needed basis. They
    do nothing more than log that they have been called in their default implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `preflight` method might be useful for implementing a `reload` method (a
    process that, without stopping the service instance, reacquires any local, potentially
    altered data, before resuming), for services that could benefit from one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, service instances need to be able to be started, stopped, and maybe
    restarted, with single, simple commands. The methods that correspond to those
    are quite simple, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This class uses several packages/libraries that need to be included, so we
    have to make sure to include them in the module that the class lives in, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With this code available, creating a new service class (equivalent to the simple,
    function-based example at the start of the chapter) is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output and logged messages from starting
    `testdaemon`, and from killing it after a few iterations. It shows all of the
    behavior we''d expect from the code in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/454e7be8-4bf7-4fda-834d-84cdee59f034.png)'
  prefs: []
  type: TYPE_IMG
- en: This basic service doesn't use any request handler classes—it's just too simple
    to need them—but a more realistic service implementation will almost certainly
    need that ability. Each handler class will need to be registered before the service
    instance is started, and will need a way to associate some property or value from
    an incoming request, to identify a handler class to create, in order to generate
    a response to the request.
  prefs: []
  type: TYPE_NORMAL
- en: During execution, as requests come in, those requests will have to be examined
    in order to identify the key that determines what handler class will be used to
    create an instance. Execution can then be handed off to that instance to create
    the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The handler class registration process is not difficult, but has a fair amount
    of type and value checking within it, to avoid bad, ambiguous, or conflicting
    results later on. It''s implemented as a class method, so that the association
    between the keys (endpoints, commands, message types, or whatever applies to an
    incoming request), and the handler classes behind those keys, can be established
    before the service is even instantiated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The process for finding a class to instantiate to handle a given request, given
    a key, is also not difficult; see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will return an instance of the first class that it can find that
    matches an incoming request key, and it will return for the longest key-match
    it can find, in order to both allow the same class to handle multiple keys, and
    to (hopefully) eliminate the possibility of a bad key-match. Consider a web service
    that interacts with `client` objects that can have subordinate `client` objects,
    allowing access to those clients by using paths that include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/client/{client_id}`: Uses a `client_handler` object to handle requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/client/{client_id}/client/{subordinate_id``}`: Uses a `subordinate_handler`
    object to handle requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to make sure that a request that should be handled by a `subordinate_handler`
    doesn't accidentally acquire and use a `client_handler`, the matching process
    iterates over the list of endpoint keys, from longest to shortest, matches the
    longer one first, and returns the appropriate class.
  prefs: []
  type: TYPE_NORMAL
- en: The BaseRequestHandler and BaseResponseFormatter ABCs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Without a concrete implementation derived from these classes, there's really
    not much to them. They use the same standard property structure that has been
    in play throughout this book for their properties, with typical type checking.
    The only new concept that they present is a combination of abstraction (which
    is nothing new) and the utilization of Python's `__call__` magic method.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at these classes (indirectly, at least) when the concrete implementations
    derived from them are created for the `hms_sys` Artisan Gateway Service, in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a class has a `__call__` method, instances of that class can be called
    as if they were functions, with the required arguments defined in the signature
    of the `__call__` method itself. In effect, callable class-instances can be thought
    of as **configurable functions**. Each instance of a callable class can have completely
    different state data that remains consistent within its own scope. As a simple
    example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose that we create an instance and call it the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a81d4231-db3e-46e7-94f5-9c18aee31e63.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can create additional instances, and call them, too, without affecting the
    results of the first instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code yields the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/19c5d758-3fb6-4d78-bb29-a752e0a99b16.png)'
  prefs: []
  type: TYPE_IMG
- en: By making the `__call__` method of these two classes abstract, we are effectively
    requiring them to implement a `__call__` method that allows each instance to be
    called as if it were a function, while simultaneously allowing each instance to
    access the properties and methods available to any instances of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying that to `BaseRequestHandler`, it means that each instance would have
    a direct reference to the `daemon` instance, with all of its logging facilities,
    its `start`, `stop`, and `restart` methods, and the original configuration file;
    therefore, the following would apply:'
  prefs: []
  type: TYPE_NORMAL
- en: A request handler instance wouldn't have to do anything terribly complicated
    to log process details as a request was being handled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration of individual request handlers would be feasible, and could even
    live in the same configuration file that the daemon itself used, although at present,
    the configuration would still have to be read and acted upon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It'd be possible to write one or more handlers (with appropriate caution, including
    authentication and authorization) that would allow a service request to restart
    the service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other service daemons, with more/other functionality at the level of the service
    instance itself, could also provide a common functionality that would be accessible
    to each endpoint. Structurally, then, a service that uses a full set of these
    request handler and response formatter objects would entail the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A single service instance, derived from `BaseDaemon`, that has the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One to many `BaseRequestHandler`-derived classes registered and available to
    be instantiated and called in response to incoming requests, each of which can,
    in turn, create and call instances of any of several `BaseResponseFormatter`-derived
    classes, to generate the final output data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With an implementation of `main` that determines which class to create and call
    for each request, based on the registration of those classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The flow of a request-response cycle for the Artisan Gateway Service, implemented
    with request handlers for Artisan and product interactions and response formatters,
    might look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/21cd1d0b-25a9-4454-8e6b-92bd69649429.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: A **Request** is sent to the **Artisan Gateway Service**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The service determines, from some predefined `context` in the **Request**, that
    the **Artisan Handler** class should be instantiated and called
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That handler knows that it needs to generate JSON output, so, after performing
    whatever processing is needed to generate a response that can be formatted, it
    acquires a **JSON Formatter** instance and calls the instance to generate the
    final **Response**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Response is returned to the **Artisan Handler**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Artisan Handler** returns the **Response** to the **Artisan Gateway Service**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Artisan Gateway Service** returns the **Response** to the originator of
    the **Request**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Most of that process hinges on concrete implementation that is not provided
    by the `BaseRequestHandler` and `BaseResponseFormatter` classes. They are, as
    shown in the preceding diagram, very simple. `BaseRequestHandler` starts with
    a standard abstract class structure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Each derived class can have a default formatter class associated with it, so
    that the eventual call of the instances of the class doesn''t require a formatter
    to be specified, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Request handlers could benefit from having access to the service/daemon instance
    that they were created by. If nothing else, that allows the handler classes to
    use the daemon''s logging facilities. Accordingly, then, we''ll keep track of
    that daemon as a property of the instance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The initialization of an instance has to provide an argument to set the instance''s
    `daemon` property, but there''s not much else to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the whole point of the ABC is to require instances to be callable by
    the service that created them, we''ll require a `__call__` method. Any time an
    instance is called, it will have an incoming request that needs to be processed
    and responded to. It also feels like a good idea to allow a `formatter` to be
    passed that could override the default `formatter` type, specified as a class
    attribute. As concrete implementations of handler classes are written, some thought
    will need to be given to how to handle cases where the class doesn''t specify
    a `formatter` type, and no `formatter` type is provided in the call itself. That
    may well vary considerably across request types, though, so there''s little point
    in going into any depth on that concern just yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BaseResponseFormatter` ABC also starts as a standard abstract class. It
    also uses the same `daemon` property, and adds a `request_handler` property that
    uses a similar setter method, allowing a formatter instance to access the request
    instance that created it, as well as the daemon instance that the request was
    received by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `request_handler`, then, needs to be required when creating an instance,
    for much the same reason that `daemon` is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, as with `BaseRequestHandler`, we''ll require a `__call__` method to
    be implemented by any derived classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In general, classes (especially if they are concrete classes) that are this
    simple (having only one method, plus their initializer, `__init__`) are not the
    best implementation approach. A class with a single method can usually be handled
    as a single function instead, even if the function has a more complex set of arguments.
    The formatter classes may well end up falling into this category as concrete implementation
    progresses. If they do, refactoring them into (hopefully simple) functions will
    be undertaken, but for now, `BaseResponseFormatter` will be left standing, as
    it has been written.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BaseRequestHandler` ABC is less of a concern on that count. Requests that
    interact with different backend data objects can be grouped into handlers for
    those object types; for example, an `ArtisanHandler` for artisans and a `ProductHandler`
    for products. It''s not a great stretch to anticipate that each of those handlers
    will have, at a minimum, methods for various CRUD operations that will be called,
    as requests are handled by the `__call__` method, but other needs arise in specific
    use cases and service contexts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In a web service context, there could be as many as five additional methods
    to be implemented – one each for `HEAD`, `CONNECT`, `OPTIONS`, `TRACE`, and `PATCH`
    HTTP methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In service contexts that don't have such a rigidly defined set of operations
    as the HTTP methods of a web service, there is even more potential for additional
    methods – even as many as one per business process that requests need to be supported
    for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even with these levels of complexity, implementing functions to handle the request/response
    cycles would be feasible. They'd just be larger, more complex functions, with
    a strong potential for being more difficult to change or maintain on a long-term
    basis.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating a service with the OS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last substantial piece of the service implementation puzzle, before getting
    into the concrete functionality, is getting a service program written in Python,
    to actually execute as a service at the OS level. The specifics of that process
    vary, unsurprisingly, across different operating systems (and even vary, to some
    extent, across different versions of some operating systems – Linux, in particular),
    but there are common operations that must be addressed across the board, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Services need to be started when the machine they run on boots up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services need to stop gracefully, when the machine they run on is powered down
    or rebooted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services need to be able to be restarted (which is generally little more than
    a stop-then-start process)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some service models might also benefit from being able to reload their data
    and/or configurations without interrupting service access in the process, particularly
    if the equivalent reload process that would occur from a restart is time-consuming.
    There may be other useful operations for specific scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: An exploration of these mechanisms will use the `testdaemon` class that was
    shown earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Running a service using systemctl (Linux)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux distributions are moving away from their old System V-style startup processes
    to a newer mechanism, the `systemd` daemon, and its associated `systemctl` command-line
    tool. Services managed by `systemd`/`systemctl` require, at a minimum, a configuration
    file that defines startup and shutdown processes, a type definition that controls
    how those processes will be handled by the OS, and whatever executables are needed
    to start or stop the service processes. A bare-bones `testdaemon.service` configuration
    file could be as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the following apply:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Unit`/`Description` entry is simply a short description of the service,
    often nothing more than a name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Service`/`Type` defines how the startup process will be handled by the `systemd`
    daemon. In this case, the execution will be forked, so that whatever process called
    it is no longer associated with it, and can terminate without stopping the service
    itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Service`/`ExecStart` defines a process for starting the service, in this case,
    by executing the `testdaemon.py` file as a Python script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Service`/`ExecStop` defines a process for stopping the service, in this case,
    by killing all of the processes with `testdaemon.py` in their name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assuming that the actual `testdaemon` class can be imported from some installed
    package, the `testdaemon.py` script that starts the service can be as simple as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'With both of those files in place, the commands for starting, restarting, and
    stopping the service from the command line are, respectively, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The services managed by `systemd` must be enabled in order to start at boot,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command requires that an install specification be added to the
    corresponding `systemd` `.service` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: There are a lot of other options available to `systemd` service configurations,
    but these bare-bones settings will allow a service to be auto-started and managed
    with standard command-line tools.
  prefs: []
  type: TYPE_NORMAL
- en: Running a service using NSSM (Windows)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest way to install services written in Python on a Windows machine
    is to use **Non-Sucking Service Manager** (**NSSM**). NSSM provides a simple way
    to wrap a specific executable (the main `python.exe` file, in this case), along
    with arguments (the `testdaemon.py` script), and make them available as a Windows
    service. Starting NSSM with `nssm install` provides a window with all of the fields
    needed for basic service setup, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ec5bc509-575e-401e-a3f8-7de333ec98cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the Install service button is clicked, the service is available in the
    Windows Services manager, where its Startup Type can be altered, if needed, along
    with all of the other standard Windows service settings and properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d27c76b7-4c6b-4722-b938-fca95ec1b9fa.png)'
  prefs: []
  type: TYPE_IMG
- en: Changes can also be made to the NSSM-created properties of the service, by running
    `nssm install <service-name>`, which presents the same UI that was used to create
    the service entry.
  prefs: []
  type: TYPE_NORMAL
- en: If an NSSM-packaged service fails to start, it will log useful information to
    the standard Windows Event Log; debugging startup problems should start there.
    Odds are good that if there are any issues, they will be permissions-related,
    such as the service's account not having access to the script file, a configuration
    file, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: macOS, launchd, and launchctl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Macintosh operating system** (**macOS**) is, under the hood, a Unix variant,
    so in many respects, there will be fewer issues or differences than there are
    between Linux and Windows service installations. macOS provides approximate equivalents
    to `systemd` and `systemctl`: the `launchd` and `launchctl` programs, respectively.
    They provide the same sort of service startup and shutdown control capabilities,
    at a minimum, with a lot of additional options for handling service processes,
    based on all kinds of system events.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Disclaimer**: While writing this book, no macOS machine was available to
    test with, so, while this section should be complete and usable as it stands,
    there may be issues that weren''t identified before publication'
  prefs: []
  type: TYPE_NORMAL
- en: 'A bare-bones `launchd`-compatible service configuration file needs to contain
    a service label, the program that is executed when the service starts up, and
    any arguments that the program needs: exactly what `systemd` needs, although the
    configuration files for `launchd`-managed services are XML files. A basic starting
    point configuration, using `testdaemon.py` as the script to launch the actual
    service object and providing both run-at-load and keep-alive controls, looks as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'That configuration, once in one of the standard locations for `launchd` files,
    allows the service to be started, restarted, and stopped, respectively, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Managing services on other systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although the current trend for managing service processes in Linux systems
    is, as noted, moving toward `systemd`/`systemctl`, there may be operational systems
    that still use System V-style initialization scripts. A bare-bones starting point
    for such a script would look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In a System V-managed context, the service itself has to take responsibility
    for making sure that it detaches from whatever process called it – a Terminal
    session, or the startup processes of the OS itself. Otherwise, the service process
    may simply start, then terminate before it actually does anything.
  prefs: []
  type: TYPE_NORMAL
- en: Since this scenario should be less and less common as time goes on, but is still
    possible, there is a class in the `daemons` module, `BaseDaemonizable`, that handles
    daemonizing a service class instance, including writing the **process ID** (**PID**)
    to a file in a known location, in case that's needed for some part of a service
    process. Deriving a service class from that, instead of `BaseDaemon`, should take
    care of the majority of the different needs, while still preserving the `BaseDaemon`
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The service foundations that were created in this chapter should provide a solid,
    common starting point for nearly any service, although tweaks to the structure
    or overrides of existing functionality may be required for specific use cases.
    With the foundations in place, the path is clear to actually creating the Artisan
    Gateway Service in `hms_sys`, which will connect the Artisan and Central Office
    data flows in the next chapter.
  prefs: []
  type: TYPE_NORMAL
