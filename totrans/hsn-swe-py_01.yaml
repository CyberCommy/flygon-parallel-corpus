- en: Programming versus Software Engineering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Development shops often have specific levels, grades, or ranks that their developers
    fall into, indicating the levels of experience, expertise, and industry wisdom
    expected of staff at each level. These may vary (perhaps wildly) from location
    to location, but a typical structure looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Junior developers:** A junior developer is typically someone that doesn''t
    have much programming experience. They probably know the basics of writing code,
    but they are not expected to know much beyond that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Developers:** Mid-level developers (referred to by whatever formal title
    might apply) usually have enough experience that they can be relied on to write
    reasonably solid code, with little to no supervision. They probably have enough
    experience to determine implementation details and strategies, and they will often
    have some understanding of how different chunks of code can (and do) interact
    with each other, and what approaches will minimize difficulties in those interactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Senior developers:** Senior developers have enough experience - even if it''s
    focused on a set of specific products/projects - to firmly grasp all of the technical
    skills involved in typical development efforts. At this point in their careers,
    they will almost always have a solid handle on a lot of the non-technical (or
    semi-technical) skills that are involved, as well—especially policies and procedures,
    and strategies and tactics that encourage or enforce business values such as stability
    and the predictability of development efforts. They may not be experts in those
    areas, but they will know when to call out risks, and they will often have several
    options to suggest for mitigating those risks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Above the level of the senior developer, the terminology and definition often
    varies even more wildly, and the skill set usually starts to focus more on business-related
    abilities and responsibilities (scope and influence) than on technical capabilities
    or expertise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dividing line between programming and software engineering falls somewhere
    within the differences between developers and senior developers, as far as technical
    capabilities and expertise are concerned. At a junior level, and sometimes at
    a developer level, efforts are often centered around nothing more than writing
    code to meet whatever requirements apply, and conforming to whatever standards
    are in play. Software engineering, at a senior developer level, has a big-picture
    view of the same end results. The bigger picture involves awareness of, and attention
    paid to, the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Standards, both technical/developmental and otherwise, including best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goals that code is written to accomplish, including the business values
    that are attached to them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shape and scope of the entire system that the code is a part of
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bigger picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what does this bigger picture look like? There are three easily-identifiable
    areas of focus, with a fourth (call it **user interaction**) that either weaves
    through the other three or is broken down into its own groups.
  prefs: []
  type: TYPE_NORMAL
- en: Software engineering must pay heed to standards, especially non-technical (business)
    ones, and also best practices. These may or may not be followed but, since they
    are standards or best practices for a reason, not following them is something
    that should always be a conscious (and defensible) decision. It's not unusual
    for business-process standards and practices to span multiple software components,
    which can make them difficult to track if a certain degree of discipline and planning
    isn't factored into the development process to make them more visible. On the
    purely development-related side, standards and best practices can drastically
    impact the creation and upkeep of code, its ongoing usefulness, and even just
    the ability to find a given chunk of code, when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: It's rare for code to be written simply for the sake of writing code. There's
    almost always some other value associated with it, especially if there's business
    value or actual revenue associated with a product that the code is a part of.
    In those cases, understandably, the people that are paying for the developmental
    effort will be very interested in ensuring that everything works as expected (code-quality)
    and can be deployed when expected (process-predictability).
  prefs: []
  type: TYPE_NORMAL
- en: Code-quality concerns will be addressed during the development of the `hms_sys`
    project a few chapters from now, and process-predictability is mostly impacted
    by the developmental methodologies discussed in [Chapter 5](https://cdp.packtpub.com/hands_on_software_engineering_with_python/wp-admin/post.php?post=29&action=edit), *The
    hms_sys System-Project*.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining policy-and-procedure related concerns are generally managed by
    setting up and following various standards, processes, and best practices during
    the startup of a project (or perhaps a development team). Those items - things
    such as setting up source control, having standard coding conventions, and planning
    for repeatable, automated testing - will be examined in some detail during the
    set up chapter for the `hms_sys` project. Ideally, once these kinds of developmental
    process are in place, the ongoing activities that keep them running and reliable
    will just become habits, a part of the day-to-day process, almost fading into
    the background.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, with more of a focus on the code side, software engineering must, by
    necessity, pay heed to entire systems, keeping a universal view of the system
    in mind. Software is composed of a lot of elements that might be classified as
    **atomic**; they are indivisible units in and of themselves, under normal circumstances.
    Just like their real-world counterparts, when they start to interact, things get
    interesting, and hopefully useful. Unfortunately, that's also when unexpected
    (or even dangerous) behaviors—bugs—usually start to appear.
  prefs: []
  type: TYPE_NORMAL
- en: This awareness is, perhaps, one of the more difficult items to cultivate. It
    relies on knowledge that may not be obvious, documented, or readily available.
    In large or complex systems, it may not even be obvious where to start looking,
    or what kinds of question to ask to try to find the information needed to acquire
    that knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Asking questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There can be as many distinct questions that can be asked about any given chunk
    of code as there are chunks of code to ask about—even very simple code, living
    in a complex system, can raise questions in response to questions, and more questions
    in response to those questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there isn''t an obvious starting point, starting with the following really
    basic questions is a good first step:'
  prefs: []
  type: TYPE_NORMAL
- en: Who will be using the functionality?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What will they be doing with it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When, and where, will they have access to it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What problem is it trying to solve? For example, why do they need it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How does it have to work? If detail is lacking, breaking this one down into
    two separate questions is useful:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What should happen if it executes successfully?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What should happen if the execution fails?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Teasing out more information about the whole system usually starts with something
    as basic as the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What other parts of the system does this code interact with?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does it interact with them?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Having identified all of the moving parts, thinking about "What happens if…"
    scenarios is a good way to identify potential points where things will break,
    risks, and dangerous interactions. You can ask questions such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What happens if this argument, which expects a number, is handed a string?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if that property isn't the object that's expected?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if some other object tries to change this object while it's already
    being changed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever one question has been answered, simply ask, What else? This can be
    useful for verifying whether the current answer is reasonably complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this process in action. To provide some context, a new function
    is being written for a system that keeps track of mineral resources on a map-grid,
    for three resources: gold, silver, and copper. Grid locations are measured in
    meters from a common origin point, and each grid location keeps track of a floating-point
    number, from 0.0 to 1.0, which indicates how likely it is that resource will be
    found in the grid square. The developmental dataset already includes four default
    nodes - at (**0**,**0**), (**0**,**1**), (**1**,**0**), and (**1**,**1**) - with
    no values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c7c4e5f5-abce-47cd-b3b7-9160f48dc08c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The system already has some classes defined to represent individual map nodes,
    and functions to provide basic access to those nodes and their properties, from
    whatever central data store they live in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/db3ca33b-46ea-408d-9aa3-5ad8696b907f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Constants, exceptions, and functions for various purposes already exist, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`node_resource_names`**: This contains all of the resource names that the
    system is concerned with, and can be thought of and treated as a list of strings: `[''gold'',''silver'',''copper'']`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`NodeAlreadyExistsError`**: An exception that will be raised if an attempt
    is made to create a `MapNode` that already exists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`NonexistentNodeError`**: An exception that will be raised if a request is
    made for a `MapNode` that doesn''t exist'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`OutOfMapBoundsError`**: An exception that will be raised if a request is
    made for a `MapNode` that isn''t allowed to exist in the map area'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`create_node(x,y)`**: Creates and returns a new, default `MapNode`, registering
    it in the global dataset of nodes in the process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`get_node(x,y)`**: Finds and returns a `MapNode` at the specified (*x*, *y*)
    coordinate location in the global dataset of available nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A developer makes an initial attempt at writing the code to set a value for
    a single resource at a given node, as a part of a project. The resulting code
    looks as follows (assume that all necessary imports already exist):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is functional, from the perspective that it will do what it''s supposed
    to (and what the developer expected) for a set of simple tests; for example, executing,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0e2284f7-d991-4bb1-bf0b-1da0003f42d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By that measure, there''s nothing wrong with the code and its functions, after
    all. Now, let''s ask some of our questions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Who will be using this functionality?**: The function may be called, by either
    of two different application front-ends, by on-site surveyors, or by post-survey
    assayers. The surveyors probably won''t use it often, but if they see obvious
    signs of a deposit during the survey, they''re expected to log it with a 100%
    certainty of finding the resource(s) at that grid location; otherwise, they''ll
    leave the resource rating completely alone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What will they be doing with it?**: Between the base requirements (to set
    a value for a single resource at a given node) and the preceding answer, this
    feels like it''s already been answered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When, and where, do they have access to it?**: Through a library that''s
    used by the surveyor and assayer applications. No one will use it directly, but
    it will be integrated into those applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How should it work?**: This has already been answered, but raises the question:
    Will there ever be a need to add more than one resource rating at a time? That''s
    probably worth nothing, if there''s a good place to implement it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What other parts of the system does this code interact with?**: There''s
    not much here that isn''t obvious from the code; it uses `MapNode` objects, those
    objects'' resources, and the `get_node` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What happens if an attempt is made to alter an existing** **MapNode?**: With
    the code as it was originally written, this behaves as expected. This is the happy
    path that the code was written to handle, and it works.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What happens if a node doesn''t already exist?**: The fact that there is
    a `NonexistentNodeError` defined is a good clue that at least some map operations
    require a node to exist before they can complete. Execute a quick test against
    that by calling the existing function, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c3b6bb6d-1640-4d53-8198-55949df63780.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the result because the development data doesn't have a MapNode at that
    location yet.
  prefs: []
  type: TYPE_NORMAL
- en: '**What happens if a node can''t exist at a given location?**: Similarly, there''s
    an `OutOfMapBoundsError` defined. Since there are no out-of-bounds nodes in the
    development data, and the code won''t currently get past the fact that an out-of-bounds
    node doesn''t exist, there''s no good way to see what happens if this is attempted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What happens if the *z*-value isn''t known at the time?**: Since the `create_node`
    function doesn''t even expect a *z*-value, but MapNode instances have one, there''s
    a real risk that calling this function on an existing node would overwrite an
    existing z-altitude value, on an existing node. That, in the long run, could be
    a critical bug.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Does this meet all of the various developmental standards that apply?**:
    Without any details about standards, it''s probably fair to assume that any standards
    that were defined would probably include, at a minimum, the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming conventions for code elements, such as function names and arguments;
    an existing function at the same logical level as `get_node`, using `SetNodeResources`
    as the name of the new function, while perfectly legal syntactically, may be violating
    a naming convention standard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At least some of the effort towards documentation, of which there's none.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some inline comments (maybe), if there is a need to explain parts of the code
    to future readers—there are none of these also, although, given the amount of
    code in this version and the relatively straightforward approach, it's arguable
    whether there would be any need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What should happen if the execution fails?**: It should probably throw explicit
    errors, with reasonably detailed error messages, if something fails during execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What happens if an invalid value is passed for any of the arguments?**: Some
    of them can be tested by executing the current function (as was done previously),
    while supplying invalid arguments—an out-of -range number first, then an invalid
    resource name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following code, executed with an invalid number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a403a49e-0273-43ed-960c-53c5da369780.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, consider the following code, with an invalid resource type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a13f61c6-b316-4290-9afb-81b7b0e9fd56.png)'
  prefs: []
  type: TYPE_IMG
- en: The function itself can either succeed or raise an error during execution, judging
    by these examples; so, ultimately, all that really needs to happen is that those
    potential errors have to be accounted for, in some fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other questions may come to mind, but the preceding questions are enough to
    implement some significant changes. The final version of the function, after considering
    the implications of the preceding answers and working out how to handle the issues
    that those answers exposed, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Stripping out the comments and documentation for the moment, this may not look
    much different from the original code—only nine lines of code were added—but the
    differences are significant, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It doesn't assume that a node will always be available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the requested node doesn't exist, it creates a new one to operate on, using
    the existing function defined for that purpose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn't assume that every attempt to add a new resource will succeed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When such an attempt fails, it raises an error that shows what happened.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these additional items are direct results of the questions asked earlier,
    and of making conscious decisions on how to deal with the answers to those questions.
    That kind of end result is where the difference between the programming and software
    engineering mindsets really appears.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's more to software engineering than just writing code. Experience; attention
    to detail; and asking questions about how the code functions, interacts with the
    rest of a system, and so on; are important aspects of evolving from a programming
    to a software engineering mindset. The time required to acquire experience can
    be shortened, perhaps significantly, by simply asking the right questions.
  prefs: []
  type: TYPE_NORMAL
- en: There are also factors completely outside the realm of creating and managing
    code that require examination and questioning. They mainly focus on what can,
    or should, be expected from the pre-development planning around a developmental
    effort, and that starts with understanding a typical software development life
    cycle.
  prefs: []
  type: TYPE_NORMAL
