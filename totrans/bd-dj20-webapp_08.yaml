- en: Testing Answerly
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapter, we added search to Answerly, our question and answer
    site. However, as our site's functionality grows, we need to avoid breaking the
    existing functionality. To make sure that our code keeps working, we will take
    a closer look at testing our Django project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following things:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Install Coverage.py to measure code coverage
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measure code coverage for our Django project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a unit test for our model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a unit test for a view
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a Django integration tests for a view
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a Selenium integration test for a view
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by installing Coverage.py.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Installing Coverage.py
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Coverage.py** is the most popular Python code coverage tool at the time of
    writing. It’s very easy to install as it’s available from PyPI. Let''s add it
    to our `requirements.txt` file:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then we can install Coverage.py using pip:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we have Coverage.py installed, we can start measuring our code coverage.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Creating a unit test for Question.save()
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django helps you write unit tests to test individual units of code. If our code
    relies on an external service, then we can use the standard `unittest.mock` library
    to mock that API, preventing requests to outside systems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a test for the `Question.save()` method to verify that when we
    save a `Question` it will be upserted into Elasticsearch. We''ll write the test
    in `django/qanda/tests.py`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code sample, we created a `TestCase` with a single test method.
    The method creates a user, saves a new `Question`, and then asserts that the mock
    has behaved correctly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Like most `TestCase` s, `QuestionSaveTestCase` uses both Django's testing API
    and code from Python's `unittest` library (for example, `unittest.mock.patch()`).
    Let's look more closely at how Django's testing API makes testing easier.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '`QuestionSaveTestCase` extends `django.test.TestCase` instead of `unittest.TestCase`
    because Django''s `TestCase` offers lots of useful features, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The entire test case and each test are atomic database operations
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django takes care of clearing the database before and after each test
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestCase` offers convenient `assert*()` methods such as `self.assertInHTML()`
    (discussed more in the *Creating a unit test for a view* section)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A fake HTTP client to create integration tests (discussed more in the *Creating
    an integration test for a view* section)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since Django's `TestCase` extends `unittest.TestCase`, it still understands
    and performs correctly when it hits a regular `AssertionError`. So, if `mock_client.update.assert_called_once_with()`
    raises an `AssertionError` exception, Django's test runner knows how to handle
    it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run our tests with `manage.py`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we know how to test a model, we can move on to testing views. As we're
    testing our views, though, we will need to create model instances. Using model's
    default managers to create model instances will become too verbose. Next, let's
    make it easier to create the models necessary for testing with Factory Boy.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Creating models for tests with Factory Boy
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our preceding test, we made a `User` model using `User.models.create_user`.
    However, that required us to provide a username and password, neither of which
    we really cared about. We just need a user, not a particular user. For many of
    our tests, the same principle will hold true for `Question` s and `Answer` s.
    The Factory Boy library will help us concisely create models in tests.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Factory Boy is particularly useful for Django developers because it knows how
    to create models based from Django `Model` classes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install Factory Boy:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this section, we'll use Factory Boy to create a `UserFactory` class and a
    `QuestionFactory` class. Since a `Question` model must have a user in its `user`
    field, the `QuestionFactory` will show us how `Factory` classes can reference
    each other.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the `UserFactory`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Creating a UserFactory
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both `Question` s and `Answer` s are related to users. This means that we'll
    need to create users in almost all our tests. Generating all the related models
    for each test using model managers is very verbose and distracting from point
    of our tests. Django offers an out-of-the-box support for fixtures of our tests.
    However, Django's fixtures are separate JSON/YAML files that need to be manually
    maintained or they will grow out of sync and cause problems. Factory Boy will
    help us by letting use code, a `UserFactory` that can concisely create users model
    instances at runtime based on the state of the current User model.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Our `UserFactory` will be derived from Factory Boy's `DjangoModelFactory` class,
    which knows how to deal with Django models. We'll use an inner `Meta` class to
    tell `UserFactory` which model it's creating (note how this is similar to the
    `Form` API). We'll also add class attributes to tell Factory Boy how to set values
    of the model's fields. Finally, we'll override the `_create` method to make `UserFactory`
    use the manager's `create_user()` method instead of the default `create()` method.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our `UserFactory` in `django/users/factories.py`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `UserFactory` subclasses the `DjangoModelFactory`. The `DjangoModelFactory`
    will look at our class's `Meta` inner class (which follows the same pattern as
    `Form`  classes).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at attributes of `UserFactory`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '`password = ''unittest''`: This sets the password for each user to be of the
    same value.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username = factory.Sequence(lambda n: ''user %d'' % n)`: `Sequence` sets a
    different value for a field each time the factory creates a model. `Sequence()`
    takes callable, passes it however many times the factory has been used, and use
    the callable''s return value as the new instance''s field value. In our case,
    our users will have usernames such as `user 0` and `user 1`.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we overrode the `_create()` method because the `django.contrib.auth.models.User`
    model has an unusual manager. The default `_create` method of `DjangoModelFactory`
    will use the model's manager's `create()` method. This is fine for most models,
    but won't work well for the `User` model. To create a user, we should really use
    the `create_user` method so that we can pass a password in plain text and have
    it hashed for storage. This will let us authenticate as that `User`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try out our factory using the Django shell:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this Django shell session, we will note how we can use `UserFactory`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: We can create new models using a single no-argument call, `UserFactory()`
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each call leads to a unique username, `assert user.username != user2.username`
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can change values the factory used by providing them as arguments, `UserFactory(username='custom')`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let's create a `QuestionFactory`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Creating the QuestionFactory
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lots of our tests will require multiple `Question` instances. However, each
    `Question` must have a user. This can lead to lots of brittle and verbose code.
    Creating a `QuestionFactory` will solve this problem.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we saw how we can use `factory.Sequence` to give each
    new model's attribute a distinct value. Factory Boy also offers `factory.SubFactory`,
    in which we can indicate that a field's value is the result of another factory.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add `QuestionFactory` to `django/qanda/factories.py`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our `QuestionFactory` is very similar to our `UserFactory`. They have the following
    things in common:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Derived from the `factory.DjangoModelFactory`
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a `Meta` class
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `factory.Sequence` to give a field a custom value
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a hardcoded value
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two important differences:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: The `user` field of `QuestionFactory` uses `SubFactory` to give each `Question`
    a new user created with the `UserFactory`.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `_create` method of `QuestionFactory` mocks the Elasticsearch service so
    that when the model is created, it doesn't try to connect to that service. Otherwise,
    it calls the default `_create()` method.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To see our `QuestionFactory` in practice, let's write a unit test for our `DailyQuestionList`
    view.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Creating a unit test for a view
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll write a view unit test for our `DailyQuestionList` view.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing a view means directly passing the view a request and asserting
    that the response matches our expectations. Since we're passing the request directly
    to the view, we also need to directly pass any arguments the view would ordinarily
    receive parsed out of the request's URL. Parsing values out of URL paths is the
    responsibility of the request routing, which we don't use in a view unit test.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at our `DailyQuestionListTestCase` class in `django/qanda/tests.py`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s take a closer look at the new APIs we''ve seen:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '`RequestFactory().get(path=...)`: `RequestFactory` is a utility for creating
    HTTP requests for testing views. Note that our request''s `path` is arbitrary
    here, as it won''t be used for routing.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DailyQuestionList.as_view()(...)`: We''ve discussed that each class-based
    view has an `as_view()` method that returns a callable, but we haven''t used it
    before. Here, we pass in the request, year, month, and day to execute the view.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`response.context_data[''object_list''].count()`: The response returned by
    our view still has its context. We can use this context to assert whether the
    view worked correctly more easily than if we had to evaluate the HTML.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`response.rendered_content`: The `rendered_content` property lets us access
    the rendered template of the response.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.assertInHTML(needle, rendered_content)`: `TestCase.assertInHTML()` lets
    us assert whether one HTML fragment is inside another. `assertInHTML()` knows
    how to parse HTML and doesn''t care about attribute order or whitespace. In testing
    views, we frequently have to check whether a particular bit of HTML is present
    in a response.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've created a unit test for a view, let's look at creating an integration
    test for a view by creating an integration test for `QuestionDetailView`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Creating a view integration test
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: View integration tests use the same `django.test.TestCase` class that a unit
    test does. An integration test will tell us if our project can route the request
    to the view and return the correct response. An integration test request will
    have to go through all the middleware and URL routing that a project is configured
    with. To help us write integration tests, Django provides `TestCase.client`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '`TestCase.client` is a utility offered by `TestCase` to let us send HTTP requests
    to our project (it can''t send external HTTP requests). Django processes these
    requests normally. `client` also offers us convenience methods such as `client.login()`,
    a way of starting an authenticated session. A `TestCase` class also resets its
    `client` between each test.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write an integration test for `QuestionDetailView` in `django/qanda/tests.py`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this sample, we log in and then request a detail view of `Question`. We make
    multiple assertions about the result to confirm that it is correct (including
    checking the name of the templates used).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine some of this code in greater detail:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '`self.client.login(...)`: This begins an authenticated session. All future
    requests will be authenticated as that user until we call `client.logout()`.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.client.get(''/q/{}''.format(question.id))`: This makes an HTTP `GET`
    request using our client. Unlike when we used `RequestFactory`, the path we provide
    is to route our request to a view (note that we never reference the view directly
    in the test). This returns the response created by our view.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[t.name for t in response.templates]`: When one of the client''s responses
    renders, the client updates the response with a list of templates used. In the
    case of the detail view, we used multiple templates. In order to check whether
    we''re showing the UI for posting an answer, we will check whether the `qanda/common/post_answer.html` file
    is one of the templates used.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this kind of test, we can gain a lot of confidence that our view works
    when a user makes a request. However, it does couple the test to the project's
    configuration. Integration tests make sense even for views coming from third-party
    apps to confirm that they're being used correctly. If you're making an app that
    is a library, you may find it better to use a unit test.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's look at testing that our Django and frontend code are both working
    correctly by testing and creating a live server test case using Selenium.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Creating a live server integration test
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final type of test we'll write is a live server integration test. In this
    test, we'll start up a test Django server and make requests to it using Google
    Chrome controlled by Selenium.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Selenium is a tool with bindings for many languages (including Python) that
    lets you control a web browser. This lets you test exactly how a real browser
    behaves when it's using your project, because you are testing your project with
    a real browser.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some limitations imposed by this kind of test:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Live tests often have to run in sequence
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's easy to leak state across tests
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a browser is much slower than `TestCase.client()` (the browser makes real
    HTTP requests)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Despite all these downsides, live server tests can be an invaluable tool at
    a time when the client side of a web app is so powerful.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by setting up Selenium.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Selenium
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add Selenium to our project by installing with `pip`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we will need the particular webdriver that tells Selenium how to talk
    to Chrome. Google provides a **chromedriver** at [https://sites.google.com/a/chromium.org/chromedriver/](https://sites.google.com/a/chromium.org/chromedriver/).
    In our case, let''s save it at the root of our project directory. Then, let''s
    add the path to that driver in `django/conf/settings.py`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finally, make sure that you have Google Chrome installed on your computer. If
    not, you can download it at [https://www.google.com/chrome/index.html](https://www.google.com/chrome/index.html).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: All major browsers claim to have some level of support for Selenium. If you
    don't like Google Chrome, you can try one of the others. Refer to Selenium's docs
    ([http://www.seleniumhq.org/about/platforms.jsp](http://www.seleniumhq.org/about/platforms.jsp))
    for details.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Testing with a live Django server and Selenium
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have Selenium set up, we can create our live server test. A live
    server test is particularly useful when our project has a lot of JavaScript. Answerly,
    though, doesn't have any JavaScript. However, Django's forms do take advantage
    of HTML5 form attributes that most browsers (including Google Chrome) support.
    We can still test whether that functionality is being correctly used by our code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: In this test, we will check whether a user can submit an empty question. The
    `title` and `question` fields should each be marked `required` so that a browser
    won't submit the form if those fields are empty.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a new test to `django/qanda/tests.py`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s take a look at some of the new Django features introduced in this test.
    Then, we''ll review our Selenium code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '`class AskQuestionTestCase(StaticLiveServerTestCase)`: `StaticLiveServerTestCase`
    starts a Django server and also ensures that static files are served correctly.
    You don''t have to run `python manage.py collectstatic`. The files will be routed
    correctly just like if you''re running `python manage.py runserver`.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def setUpClass(cls)`: All the Django test cases support the `setUpClass()`,
    `setup()`, `teardown()`, and `teardownClass()` methods as usual. `setUpClass` and `tearDownClass()`
    are run only once per `TestCase` (before and after, respectively). This makes
    them ideal for expensive operations, such as connecting to Google Chrome with
    Selenium.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.live_server_url`: This is the URL to the live server.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Selenium lets us interact with a browser using an API. This book is not focused
    on Selenium, but let''s cover some key methods of the `WebDriver` class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium允许我们使用API与浏览器进行交互。本书不侧重于Selenium，但让我们来介绍一些`WebDriver`类的关键方法：
- en: '`cls.selenium = WebDriver(executable_path=settings.CHROMEDRIVER)`: This instantiates
    a WebDriver instance with the path to the `ChromeDriver` executable (that we downloaded
    in the preceding *Setting Up Selenium* section). We stored the path to the `ChromeDriver`
    executable in our settings to let us easily reference it here.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cls.selenium = WebDriver(executable_path=settings.CHROMEDRIVER)`: 这实例化了一个WebDriver实例，其中包含到`ChromeDriver`可执行文件的路径（我们在前面的*设置Selenium*部分中下载了）。我们将`ChromeDriver`可执行文件的路径存储在设置中，以便在这里轻松引用它。'
- en: '`selenium.find_element_by_name(...)`: This returns an HTML element whose `name`
    attribute matches the provided argument. `name`s attributes are used by all `<input>`
    elements whose value is processed by a form, so this is particularly useful for
    data entry.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selenium.find_element_by_name(...)`: 这返回一个其`name`属性与提供的参数匹配的HTML元素。`name`属性被所有值由表单处理的`<input>`元素使用，因此对于数据输入特别有用。'
- en: '`self.selenium.find_element_by_id(...)`: This is like the preceding step, except
    find the matching element by its `id` attribute.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.selenium.find_element_by_id(...)`: 这与前面的步骤类似，只是通过其`id`属性查找匹配的元素。'
- en: '`self.selenium.current_url`: This is the browser''s current URL. This is useful
    for confirming that we''re on the page we expect.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.selenium.current_url`: 这是浏览器的当前URL。这对于确认我们是否在预期的页面上很有用。'
- en: '`username_input.send_keys(...)`: The `send_keys()` method lets us type the
    passed string into the an HTML element. This is particularly useful for `<input
    type=''text''>`and `<input type=''password''>` elements.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`username_input.send_keys(...)`: `send_keys()`方法允许我们将传递的字符串输入到HTML元素中。这对于`<input
    type=''text''>`和`<input type=''password''>`元素特别有用。'
- en: '`submit_btn.click()`: This triggers a click on the element.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`submit_btn.click()`: 这会触发对元素的点击。'
- en: This test logs in as a user, tries to submit a form, and asserts that it is
    still on the same page. Unfortunately, while a form with an empty required `input`
    elements won't submit itself, there is no API to confirm that directly. Instead,
    we confirm that we haven't submitted because the browser is still at the same
    URL (according to `self.selenium.current_url`) as before we hit submit.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试以用户身份登录，尝试提交表单，并断言仍然在同一个页面上。不幸的是，虽然带有空的必填`input`元素的表单不会自行提交，但没有API直接确认这一点。相反，我们确认我们没有提交，因为浏览器仍然在与之前点击提交之前相同的URL上（根据`self.selenium.current_url`）。
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to measure code coverage in Django projects
    and how to write four different types of tests—unit tests for testing any function
    or class, including models and forms; and view unit tests for testing views using
    `RequestFactory`. We covered how to view integration tests for testing that request
    route to a view and return correct responses and Live server integration tests
    for testing that your client and server-side code work together correctly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在Django项目中测量代码覆盖率，以及如何编写四种不同类型的测试——用于测试任何函数或类的单元测试，包括模型和表单；以及用于使用`RequestFactory`测试视图的视图单元测试。我们介绍了如何查看集成测试，用于测试请求路由到视图并返回正确响应，以及用于测试客户端和服务器端代码是否正确配合工作的实时服务器集成测试。
- en: Now that we have some tests, let's deploy Answerly into a production environment.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一些测试，让我们将Answerly部署到生产环境中。
