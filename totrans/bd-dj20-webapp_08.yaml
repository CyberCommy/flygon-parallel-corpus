- en: Testing Answerly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapter, we added search to Answerly, our question and answer
    site. However, as our site's functionality grows, we need to avoid breaking the
    existing functionality. To make sure that our code keeps working, we will take
    a closer look at testing our Django project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Coverage.py to measure code coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measure code coverage for our Django project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a unit test for our model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a unit test for a view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a Django integration tests for a view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a Selenium integration test for a view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by installing Coverage.py.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Coverage.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Coverage.py** is the most popular Python code coverage tool at the time of
    writing. It’s very easy to install as it’s available from PyPI. Let''s add it
    to our `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can install Coverage.py using pip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have Coverage.py installed, we can start measuring our code coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a unit test for Question.save()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django helps you write unit tests to test individual units of code. If our code
    relies on an external service, then we can use the standard `unittest.mock` library
    to mock that API, preventing requests to outside systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a test for the `Question.save()` method to verify that when we
    save a `Question` it will be upserted into Elasticsearch. We''ll write the test
    in `django/qanda/tests.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code sample, we created a `TestCase` with a single test method.
    The method creates a user, saves a new `Question`, and then asserts that the mock
    has behaved correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Like most `TestCase` s, `QuestionSaveTestCase` uses both Django's testing API
    and code from Python's `unittest` library (for example, `unittest.mock.patch()`).
    Let's look more closely at how Django's testing API makes testing easier.
  prefs: []
  type: TYPE_NORMAL
- en: '`QuestionSaveTestCase` extends `django.test.TestCase` instead of `unittest.TestCase`
    because Django''s `TestCase` offers lots of useful features, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The entire test case and each test are atomic database operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django takes care of clearing the database before and after each test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestCase` offers convenient `assert*()` methods such as `self.assertInHTML()`
    (discussed more in the *Creating a unit test for a view* section)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A fake HTTP client to create integration tests (discussed more in the *Creating
    an integration test for a view* section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since Django's `TestCase` extends `unittest.TestCase`, it still understands
    and performs correctly when it hits a regular `AssertionError`. So, if `mock_client.update.assert_called_once_with()`
    raises an `AssertionError` exception, Django's test runner knows how to handle
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run our tests with `manage.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how to test a model, we can move on to testing views. As we're
    testing our views, though, we will need to create model instances. Using model's
    default managers to create model instances will become too verbose. Next, let's
    make it easier to create the models necessary for testing with Factory Boy.
  prefs: []
  type: TYPE_NORMAL
- en: Creating models for tests with Factory Boy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our preceding test, we made a `User` model using `User.models.create_user`.
    However, that required us to provide a username and password, neither of which
    we really cared about. We just need a user, not a particular user. For many of
    our tests, the same principle will hold true for `Question` s and `Answer` s.
    The Factory Boy library will help us concisely create models in tests.
  prefs: []
  type: TYPE_NORMAL
- en: Factory Boy is particularly useful for Django developers because it knows how
    to create models based from Django `Model` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install Factory Boy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we'll use Factory Boy to create a `UserFactory` class and a
    `QuestionFactory` class. Since a `Question` model must have a user in its `user`
    field, the `QuestionFactory` will show us how `Factory` classes can reference
    each other.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the `UserFactory`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a UserFactory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both `Question` s and `Answer` s are related to users. This means that we'll
    need to create users in almost all our tests. Generating all the related models
    for each test using model managers is very verbose and distracting from point
    of our tests. Django offers an out-of-the-box support for fixtures of our tests.
    However, Django's fixtures are separate JSON/YAML files that need to be manually
    maintained or they will grow out of sync and cause problems. Factory Boy will
    help us by letting use code, a `UserFactory` that can concisely create users model
    instances at runtime based on the state of the current User model.
  prefs: []
  type: TYPE_NORMAL
- en: Our `UserFactory` will be derived from Factory Boy's `DjangoModelFactory` class,
    which knows how to deal with Django models. We'll use an inner `Meta` class to
    tell `UserFactory` which model it's creating (note how this is similar to the
    `Form` API). We'll also add class attributes to tell Factory Boy how to set values
    of the model's fields. Finally, we'll override the `_create` method to make `UserFactory`
    use the manager's `create_user()` method instead of the default `create()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our `UserFactory` in `django/users/factories.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `UserFactory` subclasses the `DjangoModelFactory`. The `DjangoModelFactory`
    will look at our class's `Meta` inner class (which follows the same pattern as
    `Form`  classes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at attributes of `UserFactory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`password = ''unittest''`: This sets the password for each user to be of the
    same value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username = factory.Sequence(lambda n: ''user %d'' % n)`: `Sequence` sets a
    different value for a field each time the factory creates a model. `Sequence()`
    takes callable, passes it however many times the factory has been used, and use
    the callable''s return value as the new instance''s field value. In our case,
    our users will have usernames such as `user 0` and `user 1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we overrode the `_create()` method because the `django.contrib.auth.models.User`
    model has an unusual manager. The default `_create` method of `DjangoModelFactory`
    will use the model's manager's `create()` method. This is fine for most models,
    but won't work well for the `User` model. To create a user, we should really use
    the `create_user` method so that we can pass a password in plain text and have
    it hashed for storage. This will let us authenticate as that `User`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try out our factory using the Django shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this Django shell session, we will note how we can use `UserFactory`:'
  prefs: []
  type: TYPE_NORMAL
- en: We can create new models using a single no-argument call, `UserFactory()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each call leads to a unique username, `assert user.username != user2.username`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can change values the factory used by providing them as arguments, `UserFactory(username='custom')`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let's create a `QuestionFactory`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the QuestionFactory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lots of our tests will require multiple `Question` instances. However, each
    `Question` must have a user. This can lead to lots of brittle and verbose code.
    Creating a `QuestionFactory` will solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we saw how we can use `factory.Sequence` to give each
    new model's attribute a distinct value. Factory Boy also offers `factory.SubFactory`,
    in which we can indicate that a field's value is the result of another factory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add `QuestionFactory` to `django/qanda/factories.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `QuestionFactory` is very similar to our `UserFactory`. They have the following
    things in common:'
  prefs: []
  type: TYPE_NORMAL
- en: Derived from the `factory.DjangoModelFactory`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a `Meta` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `factory.Sequence` to give a field a custom value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a hardcoded value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two important differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The `user` field of `QuestionFactory` uses `SubFactory` to give each `Question`
    a new user created with the `UserFactory`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `_create` method of `QuestionFactory` mocks the Elasticsearch service so
    that when the model is created, it doesn't try to connect to that service. Otherwise,
    it calls the default `_create()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To see our `QuestionFactory` in practice, let's write a unit test for our `DailyQuestionList`
    view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a unit test for a view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll write a view unit test for our `DailyQuestionList` view.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing a view means directly passing the view a request and asserting
    that the response matches our expectations. Since we're passing the request directly
    to the view, we also need to directly pass any arguments the view would ordinarily
    receive parsed out of the request's URL. Parsing values out of URL paths is the
    responsibility of the request routing, which we don't use in a view unit test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at our `DailyQuestionListTestCase` class in `django/qanda/tests.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at the new APIs we''ve seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RequestFactory().get(path=...)`: `RequestFactory` is a utility for creating
    HTTP requests for testing views. Note that our request''s `path` is arbitrary
    here, as it won''t be used for routing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DailyQuestionList.as_view()(...)`: We''ve discussed that each class-based
    view has an `as_view()` method that returns a callable, but we haven''t used it
    before. Here, we pass in the request, year, month, and day to execute the view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`response.context_data[''object_list''].count()`: The response returned by
    our view still has its context. We can use this context to assert whether the
    view worked correctly more easily than if we had to evaluate the HTML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`response.rendered_content`: The `rendered_content` property lets us access
    the rendered template of the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.assertInHTML(needle, rendered_content)`: `TestCase.assertInHTML()` lets
    us assert whether one HTML fragment is inside another. `assertInHTML()` knows
    how to parse HTML and doesn''t care about attribute order or whitespace. In testing
    views, we frequently have to check whether a particular bit of HTML is present
    in a response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've created a unit test for a view, let's look at creating an integration
    test for a view by creating an integration test for `QuestionDetailView`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a view integration test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: View integration tests use the same `django.test.TestCase` class that a unit
    test does. An integration test will tell us if our project can route the request
    to the view and return the correct response. An integration test request will
    have to go through all the middleware and URL routing that a project is configured
    with. To help us write integration tests, Django provides `TestCase.client`.
  prefs: []
  type: TYPE_NORMAL
- en: '`TestCase.client` is a utility offered by `TestCase` to let us send HTTP requests
    to our project (it can''t send external HTTP requests). Django processes these
    requests normally. `client` also offers us convenience methods such as `client.login()`,
    a way of starting an authenticated session. A `TestCase` class also resets its
    `client` between each test.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write an integration test for `QuestionDetailView` in `django/qanda/tests.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this sample, we log in and then request a detail view of `Question`. We make
    multiple assertions about the result to confirm that it is correct (including
    checking the name of the templates used).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine some of this code in greater detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`self.client.login(...)`: This begins an authenticated session. All future
    requests will be authenticated as that user until we call `client.logout()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.client.get(''/q/{}''.format(question.id))`: This makes an HTTP `GET`
    request using our client. Unlike when we used `RequestFactory`, the path we provide
    is to route our request to a view (note that we never reference the view directly
    in the test). This returns the response created by our view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[t.name for t in response.templates]`: When one of the client''s responses
    renders, the client updates the response with a list of templates used. In the
    case of the detail view, we used multiple templates. In order to check whether
    we''re showing the UI for posting an answer, we will check whether the `qanda/common/post_answer.html` file
    is one of the templates used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this kind of test, we can gain a lot of confidence that our view works
    when a user makes a request. However, it does couple the test to the project's
    configuration. Integration tests make sense even for views coming from third-party
    apps to confirm that they're being used correctly. If you're making an app that
    is a library, you may find it better to use a unit test.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's look at testing that our Django and frontend code are both working
    correctly by testing and creating a live server test case using Selenium.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a live server integration test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final type of test we'll write is a live server integration test. In this
    test, we'll start up a test Django server and make requests to it using Google
    Chrome controlled by Selenium.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium is a tool with bindings for many languages (including Python) that
    lets you control a web browser. This lets you test exactly how a real browser
    behaves when it's using your project, because you are testing your project with
    a real browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some limitations imposed by this kind of test:'
  prefs: []
  type: TYPE_NORMAL
- en: Live tests often have to run in sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's easy to leak state across tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a browser is much slower than `TestCase.client()` (the browser makes real
    HTTP requests)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Despite all these downsides, live server tests can be an invaluable tool at
    a time when the client side of a web app is so powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by setting up Selenium.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Selenium
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add Selenium to our project by installing with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will need the particular webdriver that tells Selenium how to talk
    to Chrome. Google provides a **chromedriver** at [https://sites.google.com/a/chromium.org/chromedriver/](https://sites.google.com/a/chromium.org/chromedriver/).
    In our case, let''s save it at the root of our project directory. Then, let''s
    add the path to that driver in `django/conf/settings.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Finally, make sure that you have Google Chrome installed on your computer. If
    not, you can download it at [https://www.google.com/chrome/index.html](https://www.google.com/chrome/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: All major browsers claim to have some level of support for Selenium. If you
    don't like Google Chrome, you can try one of the others. Refer to Selenium's docs
    ([http://www.seleniumhq.org/about/platforms.jsp](http://www.seleniumhq.org/about/platforms.jsp))
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with a live Django server and Selenium
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have Selenium set up, we can create our live server test. A live
    server test is particularly useful when our project has a lot of JavaScript. Answerly,
    though, doesn't have any JavaScript. However, Django's forms do take advantage
    of HTML5 form attributes that most browsers (including Google Chrome) support.
    We can still test whether that functionality is being correctly used by our code.
  prefs: []
  type: TYPE_NORMAL
- en: In this test, we will check whether a user can submit an empty question. The
    `title` and `question` fields should each be marked `required` so that a browser
    won't submit the form if those fields are empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a new test to `django/qanda/tests.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at some of the new Django features introduced in this test.
    Then, we''ll review our Selenium code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`class AskQuestionTestCase(StaticLiveServerTestCase)`: `StaticLiveServerTestCase`
    starts a Django server and also ensures that static files are served correctly.
    You don''t have to run `python manage.py collectstatic`. The files will be routed
    correctly just like if you''re running `python manage.py runserver`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def setUpClass(cls)`: All the Django test cases support the `setUpClass()`,
    `setup()`, `teardown()`, and `teardownClass()` methods as usual. `setUpClass` and `tearDownClass()`
    are run only once per `TestCase` (before and after, respectively). This makes
    them ideal for expensive operations, such as connecting to Google Chrome with
    Selenium.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.live_server_url`: This is the URL to the live server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Selenium lets us interact with a browser using an API. This book is not focused
    on Selenium, but let''s cover some key methods of the `WebDriver` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cls.selenium = WebDriver(executable_path=settings.CHROMEDRIVER)`: This instantiates
    a WebDriver instance with the path to the `ChromeDriver` executable (that we downloaded
    in the preceding *Setting Up Selenium* section). We stored the path to the `ChromeDriver`
    executable in our settings to let us easily reference it here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selenium.find_element_by_name(...)`: This returns an HTML element whose `name`
    attribute matches the provided argument. `name`s attributes are used by all `<input>`
    elements whose value is processed by a form, so this is particularly useful for
    data entry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.selenium.find_element_by_id(...)`: This is like the preceding step, except
    find the matching element by its `id` attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.selenium.current_url`: This is the browser''s current URL. This is useful
    for confirming that we''re on the page we expect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username_input.send_keys(...)`: The `send_keys()` method lets us type the
    passed string into the an HTML element. This is particularly useful for `<input
    type=''text''>`and `<input type=''password''>` elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`submit_btn.click()`: This triggers a click on the element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This test logs in as a user, tries to submit a form, and asserts that it is
    still on the same page. Unfortunately, while a form with an empty required `input`
    elements won't submit itself, there is no API to confirm that directly. Instead,
    we confirm that we haven't submitted because the browser is still at the same
    URL (according to `self.selenium.current_url`) as before we hit submit.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to measure code coverage in Django projects
    and how to write four different types of tests—unit tests for testing any function
    or class, including models and forms; and view unit tests for testing views using
    `RequestFactory`. We covered how to view integration tests for testing that request
    route to a view and return correct responses and Live server integration tests
    for testing that your client and server-side code work together correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some tests, let's deploy Answerly into a production environment.
  prefs: []
  type: TYPE_NORMAL
