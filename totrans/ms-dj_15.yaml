- en: Chapter 15. Django Sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine you had to log back in to a website every time you navigated to another
    page, or your favorite websites forgot all of your settings and you had to enter
    them again each time you visited?
  prefs: []
  type: TYPE_NORMAL
- en: Modern websites could not provide the usability and convenience we are used
    to without some way of remembering who you are and your previous activities on
    the website. HTTP is, by design, *stateless*-there is no persistence between one
    request and the next, and there is no way the server can tell whether successive
    requests come from the same person.
  prefs: []
  type: TYPE_NORMAL
- en: This lack of state is managed using *sessions*, which are a semi-permanent,
    two-way communication between your browser and the web server. When you visit
    a modern website, in the majority of cases, the web server will use an *anonymous
    session* to keep track of data relevant to your visit. The session is called anonymous
    because the web server can only record what you did, not who you are.
  prefs: []
  type: TYPE_NORMAL
- en: We have all experienced this when we have returned to an e-commerce site at
    a later date and found the items we put in the cart are still there, despite not
    having provided any personal details. Sessions are most often persisted using
    the often maligned, but rarely understood *cookie*. Like all other web frameworks,
    Django also uses cookies, but does so in a more clever and secure manner, as you
    will see.
  prefs: []
  type: TYPE_NORMAL
- en: Django provides full support for anonymous sessions. The session framework lets
    you store and retrieve arbitrary data on a per-site-visitor basis. It stores data
    on the server side and abstracts the sending and receiving of cookies. Cookies
    contain a session ID-not the data itself (unless you're using the cookie based
    backend); a more secure way of implementing cookies than some other frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sessions are implemented via a piece of middleware. To enable session functionality,
    edit the `MIDDLEWARE_CLASSES` setting and make sure it contains `'django.contrib.sessions.middleware.SessionMiddleware'`.
    The default `settings.py` created by `django-admin startproject` has `SessionMiddleware`
    activated.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't want to use sessions, you might as well remove the `SessionMiddleware`
    line from `MIDDLEWARE_CLASSES` and `'django.contrib.sessions'` from your `INSTALLED_APPS`.
    It'll save you a small bit of overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the session engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Django stores sessions in your database (using the model `django.contrib.sessions.models.Session`).
    Though this is convenient, in some setups it's faster to store session data elsewhere,
    so Django can be configured to store session data on your filesystem or in your
    cache.
  prefs: []
  type: TYPE_NORMAL
- en: Using database-backed sessions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to use a database-backed session, you need to add `'django.contrib.sessions'`
    to your `INSTALLED_APPS` setting. Once you have configured your installation,
    run `manage.py migrate` to install the single database table that stores session
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Using cached sessions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For better performance, you may want to use a cache-based session backend. To
    store session data using Django's cache system, you'll first need to make sure
    you've configured your cache; see the cache documentation for details.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should only use cache-based sessions if you're using the Memcached cache
    backend. The local-memory cache backend doesn't retain data long enough to be
    a good choice, and it'll be faster to use file or database sessions directly instead
    of sending everything through the file or database cache backends. Additionally,
    the local-memory cache backend is NOT multi-process safe, therefore probably not
    a good choice for production environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have multiple caches defined in `CACHES`, Django will use the default
    cache. To use another cache, set `SESSION_CACHE_ALIAS` to the name of that cache.
    Once your cache is configured, you''ve got two choices for how to store data in
    the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set `SESSION_ENGINE` to `"django.contrib.sessions.backends.cache"` for a simple
    caching session store. Session data will be stored directly in your cache. However,
    session data may not be persistent: cached data can be evicted if the cache fills
    up or if the cache server is restarted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For persistent, cached data, set `SESSION_ENGINE` to `"django.contrib.sessions.backends.cached_db"`.
    This uses a write-through cache-every write to the cache will also be written
    to the database. Session reads only use the database if the data is not already
    in the cache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both session stores are quite fast, but the simple cache is faster because it
    disregards persistence. In most cases, the `cached_db` backend will be fast enough,
    but if you need that last bit of performance, and are willing to let session data
    be expunged from time to time, the `cache` backend is for you. If you use the
    `cached_db` session backend, you also need to follow the configuration instructions
    for the using database-backed sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Using file-based sessions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use file-based sessions, set the `SESSION_ENGINE` setting to `"django.contrib.sessions.backends.file"`.
    You might also want to set the `SESSION_FILE_PATH` setting (which defaults to
    output from `tempfile.gettempdir()`, most likely `/tmp`) to control where Django
    stores session files. Be sure to check that your web server has permissions to
    read and write to this location.
  prefs: []
  type: TYPE_NORMAL
- en: Using cookie-based sessions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use cookies-based sessions, set the `SESSION_ENGINE` setting to `"django.contrib.sessions.backends.signed_cookies"`.
    The session data will be stored using Django's tools for cryptographic signing
    and the `SECRET_KEY` setting.
  prefs: []
  type: TYPE_NORMAL
- en: It's recommended to leave the `SESSION_COOKIE_HTTPONLY` setting on `True` to
    prevent access to the stored data from JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**If the `SECRET_KEY` is not kept secret and you are using the** `PickleSerializer`,
    **this can lead to arbitrary remote code execution.**'
  prefs: []
  type: TYPE_NORMAL
- en: An attacker in possession of the `SECRET_KEY` can not only generate falsified
    session data, which your site will trust, but also remotely execute arbitrary
    code, as the data is serialized using pickle. If you use cookie-based sessions,
    pay extra care that your secret key is always kept completely secret, for any
    system which might be remotely accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The session data is signed but not encrypted**'
  prefs: []
  type: TYPE_NORMAL
- en: When using the cookies backend, the session data can be read by the client.
    A MAC (Message Authentication Code) is used to protect the data against changes
    by the client, so that the session data will be invalidated when being tampered
    with. The same invalidation happens if the client storing the cookie (for example,
    your user's browser) can't store all of the session cookie and drops data. Even
    though Django compresses the data, it's still entirely possible to exceed the
    common limit of 4096 bytes per cookie.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**No freshness guarantee**'
  prefs: []
  type: TYPE_NORMAL
- en: Note also that while the MAC can guarantee the authenticity of the data (that
    it was generated by your site, and not someone else), and the integrity of the
    data (that it is all there and correct), it cannot guarantee freshness that is,
    you are being sent back the last thing you sent to the client. This means that
    for some uses of session data, the cookie backend might open you up to replay
    attacks. Unlike other session backends which keep a server-side record of each
    session and invalidate it when a user logs out, cookie-based sessions are not
    invalidated when a user logs out. Thus if an attacker steals a user's cookie,
    they can use that cookie to login as that user even if the user logs out. Cookies
    will only be detected as 'stale' if they are older than your `SESSION_COOKIE_AGE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, assuming the above warnings have not discouraged you from using cookie
    based sessions: the size of a cookie can also have an impact on the speed of your
    site.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Sessions in Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When `SessionMiddleware` is activated, each `HttpRequest` object-the first argument
    to any Django view function-will have a `session` attribute, which is a dictionary-like
    object. You can read it and write to `request.session` at any point in your view.
    You can edit it multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'All session objects inherit from the base class `backends.base.SessionBase`.
    It has the following standard dictionary methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__getitem__(key)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__setitem__(key, value)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__delitem__(key)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__contains__(key)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get(key, default=None)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pop(key)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keys()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`items()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setdefault()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It also has these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: flush()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Delete the current session data from the session and delete the session cookie.
    This is used if you want to ensure that the previous session data can't be accessed
    again from the user's browser (for example, the `django.contrib.auth.logout()`
    function calls it).
  prefs: []
  type: TYPE_NORMAL
- en: set_test_cookie()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sets a test cookie to determine whether the user's browser supports cookies.
    Due to the way cookies work, you won't be able to test this until the user's next
    page request. See *Setting test cookies* below for more information.
  prefs: []
  type: TYPE_NORMAL
- en: test_cookie_worked()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Returns either `True` or `False`, depending on whether the user's browser accepted
    the test cookie. Due to the way cookies work, you'll have to call `set_test_cookie()`
    on a previous, separate page request. See *Setting test cookies* below for more
    information.
  prefs: []
  type: TYPE_NORMAL
- en: delete_test_cookie()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deletes the test cookie. Use this to clean up after yourself.
  prefs: []
  type: TYPE_NORMAL
- en: set_expiry(value)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sets the expiration time for the session. You can pass a number of different
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: If `value` is an integer, the session will expire after that many seconds of
    inactivity. For example, calling `request.session.set_expiry(300)` would make
    the session expire in 5 minutes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `value` is a `datetime` or `timedelta` object, the session will expire at
    that specific date/time. Note that `datetime` and `timedelta` values are only
    serializable if you are using the `PickleSerializer`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `value` is `0`, the user's session cookie will expire when the user's web
    browser is closed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `value` is `None`, the session reverts to using the global session expiry
    policy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading a session is not considered activity for expiration purposes. Session
    expiration is computed from the last time the session was modified.
  prefs: []
  type: TYPE_NORMAL
- en: get_expiry_age()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Returns the number of seconds until this session expires. For sessions with
    no custom expiration (or those set to expire at browser close), this will equal
    `SESSION_COOKIE_AGE`. This function accepts two optional keyword arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`modification`: last modification of the session, as a `datetime` object. Defaults
    to the current time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expiry`: expiry information for the session, as a `datetime` object, an `int`
    (in seconds), or `None`. Defaults to the value stored in the session by `set_expiry()`,
    if there is one, or `None`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: get_expiry_date()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Returns the date this session will expire. For sessions with no custom expiration
    (or those set to expire at browser close), this will equal the date `SESSION_COOKIE_AGE`
    seconds from now. This function accepts the same keyword arguments as `get_expiry_age()`.
  prefs: []
  type: TYPE_NORMAL
- en: get_expire_at_browser_close()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Returns either `True` or `False`, depending on whether the user's session cookie
    will expire when the user's web browser is closed.
  prefs: []
  type: TYPE_NORMAL
- en: clear_expired()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Removes expired sessions from the session store. This class method is called
    by `clearsessions`.
  prefs: []
  type: TYPE_NORMAL
- en: cycle_key()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creates a new session key while retaining the current session data. `django.contrib.auth.login()`
    calls this method to mitigate against session fixation.
  prefs: []
  type: TYPE_NORMAL
- en: Session object guidelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use normal Python strings as dictionary keys on `request.session`. This is more
    of a convention than a hard-and-fast rule.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Session dictionary keys that begin with an underscore are reserved for internal
    use by Django.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't override `request.session` with a new object, and don't access or set
    its attributes. Use it like a Python dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Session serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before version 1.6, Django defaulted to using `pickle` to serialize session
    data before storing it in the backend. If you're using the signed cookie session
    backend and `SECRET_KEY` is known by an attacker (there isn't an inherent vulnerability
    in Django that would cause it to leak), the attacker could insert a string into
    their session which, when unpickled, executes arbitrary code on the server. The
    technique for doing so is simple and easily available on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Although the cookie session storage signs the cookie-stored data to prevent
    tampering, a `SECRET_KEY` leak immediately escalates to a remote code execution
    vulnerability. This attack can be mitigated by serializing session data using
    JSON rather than `pickle`. To facilitate this, Django 1.5.3 introduced a new setting,
    `SESSION_SERIALIZER`, to customize the session serialization format. For backwards
    compatibility, this setting defaults to using `django.contrib.sessions.serializers.PickleSerializer`
    in Django 1.5.x, but, for security hardening, defaults to `django.contrib.sessions.serializers.JSONSerializer`
    from Django 1.6 onwards.
  prefs: []
  type: TYPE_NORMAL
- en: Even with the caveats described in custom-serializers, we highly recommend sticking
    with JSON serialization *especially if you are using the cookie backend*.
  prefs: []
  type: TYPE_NORMAL
- en: Bundled serializers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: serializers.JSONSerializer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A wrapper around the JSON serializer from `django.core.signing`. Can only serialize
    basic data types. In addition, as JSON supports only string keys, note that using
    non-string keys in `request.session` won''t work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: See the custom-serializers section for more details on limitations of JSON serialization.
  prefs: []
  type: TYPE_NORMAL
- en: serializers.PickleSerializer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Supports arbitrary Python objects, but, as described above, can lead to a remote
    code execution vulnerability if `SECRET_KEY` becomes known by an attacker.
  prefs: []
  type: TYPE_NORMAL
- en: Write your own serializer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note that unlike `PickleSerializer`, the `JSONSerializer` cannot handle arbitrary
    Python data types. As is often the case, there is a trade-off between convenience
    and security. If you wish to store more advanced data types including `datetime`
    and `Decimal` in JSON backed sessions, you will need to write a custom serializer
    (or convert such values to a JSON serializable object before storing them in `request.session`).
  prefs: []
  type: TYPE_NORMAL
- en: While serializing these values is fairly straightforward (`django.core.serializers.json.DateTimeAwareJSONEncoder`
    may be helpful), writing a decoder that can reliably get back the same thing that
    you put in is more fragile. For example, you run the risk of returning a `datetime`
    that was actually a string that just happened to be in the same format chosen
    for `datetime`).
  prefs: []
  type: TYPE_NORMAL
- en: Your serializer class must implement two methods, `dumps(self, obj)` and `loads(self,
    data)`, to serialize and deserialize the dictionary of session data, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Setting test cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a convenience, Django provides an easy way to test whether the user's browser
    accepts cookies. Just call the `set_test_cookie()` method of `request.session`
    in a view, and call `test_cookie_worked()` in a subsequent view-not in the same
    view call.
  prefs: []
  type: TYPE_NORMAL
- en: This awkward split between `set_test_cookie()` and `test_cookie_worked()` is
    necessary due to the way cookies work. When you set a cookie, you can't actually
    tell whether a browser accepted it until the browser's next request. It's good
    practice to use `delete_test_cookie()` to clean up after yourself. Do this after
    you've verified that the test cookie worked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a typical usage example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using sessions out of views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The examples in this section import the `SessionStore` object directly from
    the `django.contrib.sessions.backends.db` backend. In your own code, you should
    consider importing `SessionStore` from the session engine designated by `SESSION_ENGINE`,
    as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'An API is available to manipulate session data outside of a view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to mitigate session fixation attacks, sessions keys that don''t exist
    are regenerated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re using the `django.contrib.sessions.backends.db` backend, each session
    is just a normal Django model. The `Session` model is defined in `django/contrib/sessions/models.py`.
    Because it''s a normal model, you can access sessions using the normal Django
    database API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When sessions are saved
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, Django only saves to the session database when the session has
    been modified-that is if any of its dictionary values have been assigned or deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last case of the above example, we can tell the session object explicitly
    that it has been modified by setting the `modified` attribute on the session object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To change this default behavior, set the `SESSION_SAVE_EVERY_REQUEST` setting
    to `True`. When set to `True`, Django will save the session to the database on
    every single request. Note that the session cookie is only sent when a session
    has been created or modified. If `SESSION_SAVE_EVERY_REQUEST` is `True`, the session
    cookie will be sent on every request. Similarly, the `expires` part of a session
    cookie is updated each time the session cookie is sent. The session is not saved
    if the response's status code is 500.
  prefs: []
  type: TYPE_NORMAL
- en: Browser-length sessions vs. persistent sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can control whether the session framework uses browser-length sessions vs.
    persistent sessions with the `SESSION_EXPIRE_AT_BROWSER_CLOSE` setting. By default,
    `SESSION_EXPIRE_AT_BROWSER_CLOSE` is set to `False`, which means session cookies
    will be stored in users' browsers for as long as `SESSION_COOKIE_AGE`. Use this
    if you don't want people to have to log in every time they open a browser.
  prefs: []
  type: TYPE_NORMAL
- en: If `SESSION_EXPIRE_AT_BROWSER_CLOSE` is set to `True`, Django will use browser-length
    cookies-cookies that expire as soon as the user closes their browser.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some browsers (Chrome, for example) provide settings that allow users to continue
    browsing sessions after closing and re-opening the browser. In some cases, this
    can interfere with the `SESSION_EXPIRE_AT_BROWSER_CLOSE` setting and prevent sessions
    from expiring on browser close. Please be aware of this while testing Django applications
    which have the `SESSION_EXPIRE_AT_BROWSER_CLOSE` setting enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Clearing the session store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As users create new sessions on your website, session data can accumulate in
    your session store. Django does not provide automatic purging of expired sessions.
    Therefore, it''s your job to purge expired sessions on a regular basis. Django
    provides a clean-up management command for this purpose: `clearsessions`. It''s
    recommended to call this command on a regular basis, for example as a daily cron
    job.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the cache backend isn't vulnerable to this problem, because caches
    automatically delete stale data. Neither is the cookie backend, because the session
    data is stored by the users' browsers.
  prefs: []
  type: TYPE_NORMAL
- en: What's next
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we will be continuing our look into more advanced Django topics by examining
    Django's caching backend.
  prefs: []
  type: TYPE_NORMAL
