- en: Development Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging—how to leverage the Python built-in debugger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing—writing test suites with the Python standard library test framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking—patching objects to simulate fake behaviors in tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reporting errors in production—getting crashes reported by email
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarking—how to benchmark functions with the standard library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspection—inspecting the type, attributes, and methods provided by an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code evaluation—running Python code within Python code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracing—how to trace which lines of code were executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling—how to trace bottlenecks in code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing software, you need tools that make achieving your goal easier and
    tools that help you to manage the complexity of the code base, which can get millions
    of line of code and can involve other people's code that you are not experienced
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Even for small projects, if you are involving third-party libraries, frameworks,
    and tools, you are, in fact, bringing other people's code into yours and you will
    need a set of tools to understand what's going on when you rely on this code and
    to keep your own code under control and free from bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Here is where techniques such as testing, debugging, profiling, and tracing
    can come in handy to verify the code base, understand what's going on, spot bottlenecks,
    and see what was executed and when.
  prefs: []
  type: TYPE_NORMAL
- en: The Python standard library comes with many of the tools you will need during
    daily development to implement most best practices and techniques in software
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While developing, you might face an unexpected behavior of your code or a crash,
    and you will want to dive into it, see the state of the variables, and check what's
    going on to understand how to handle the unexpected situation so that the software
    behaves properly.
  prefs: []
  type: TYPE_NORMAL
- en: This is typically part of debugging and usually requires dedicated tools, debuggers,
    to make your life easier (ever found yourself throwing `print` statements everywhere
    around the code just to see value of some variable?).
  prefs: []
  type: TYPE_NORMAL
- en: The Python standard library comes with a very powerful debugger, and while other
    third-party solutions exist, the internal `pdb` debugger is very powerful and
    is able to help you in nearly all situations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to stop code execution at a specific point and interactively move
    it forward while checking how your variables change and what flow the execution
    takes, you just want to set a tracing point where you want to stop, so that you
    will enter an interactive session in the shell where your code is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we call the `divide` function, we will enter an interactive debugger
    that lets us see the value of `x` and `y` and move forward with the execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `pdb` module exposes a `set_trace` function which, when called, stops execution
    and enters the interactive debugger.
  prefs: []
  type: TYPE_NORMAL
- en: From here on, your prompt will change (to `Pdb`) and you can send commands to
    the debugger or print variable values just by writing their name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pdb` debugger has many commands; the most useful ones are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`next`: To continue execution of code one line at a time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`continue`: To continue execution of code until the next breakpoint is reached'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list`: To print the code that is currently being executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To see a complete list of commands, you can use the `help` command, which will
    list all the available commands. And you can use the `help` command to get help
    on a specific command.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since version 3.7 of Python, it is no longer required to do the odd `import
    pdb`; `pdb.set_trace()` dance. You can just write `breakpoint()` and you will
    enter `pdb`.
  prefs: []
  type: TYPE_NORMAL
- en: Even better, if you have more advanced debuggers configured on your system,
    you will rely on those as `breakpoint()` uses the currently configured debugger
    instead of only relying on `pdb`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To ensure that your code is correct and doesn't break on future changes, writing
    tests is usually one of the best things you can do.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, there are a few frameworks to implement test suites that can automatically
    verify code reliability, implement different patterns such as **behavior-driver
    development** (**BDD**), or even automatically find corner cases for you.
  prefs: []
  type: TYPE_NORMAL
- en: But simple automatic tests can be written just by relying on the standard library
    itself, so that you will need third-party testing frameworks only if you need
    specific plugins or patterns.
  prefs: []
  type: TYPE_NORMAL
- en: The standard library has the `unittest` module, which allows us to write tests
    for our software, run them, and report the state of the test suite.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, the following steps are to be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we have a `divide` function we want to write tests for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to create a file named `test_divide.py` (it''s important that files
    containing tests are named `test_*.py` or the tests won''t run). Within the `test_divide.py` file,
    we can put all our tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, given that the `test_divide.py` module is within the same directory,
    we can run our tests with `python -m unittest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to also see which tests are running, we can also provide the `-v`
    option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `unittest` module provides two major features:'
  prefs: []
  type: TYPE_NORMAL
- en: The `unittest.TestCase` class, which provides foundations to write tests and
    fixtures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `unittest.TestLoader` class, which provides the foundation for finding and
    running multiple tests from multiple sources, in a single run; the result can
    then be provided to a runner to run them all and report their progress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By creating a `unittest.TestCase` class, we can gather multiple tests under
    the same set of fixtures, which are provided by the class as the `setUp` and `setUpClass`
    methods. The `setUpClass` method is performed once for the whole class, while
    the `setUp` method is performed once for every test. Tests are all the class methods
    whose name starts with `test*`.
  prefs: []
  type: TYPE_NORMAL
- en: Once the tests have been completed, the `tearDown` and `tearDownClass` methods
    can be used to clean up the state.
  prefs: []
  type: TYPE_NORMAL
- en: 'So our `TestDivision` class will provide a `self.num` attribute for each test
    declared within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And then will have three tests, two of which (`test_int_division` and `test_float_division`)
    assert that the result of the division is the expected one (through `self.assertEqual`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the third test (`test_divide_zero`) checks that our `divide` function
    actually raises the expected exception when a `0` is provided as the divisor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: And then checks that the exception message is also the expected one.
  prefs: []
  type: TYPE_NORMAL
- en: Those tests are then saved in a file named `test_divide.py`, so that `TestLoader`
    is able to find them.
  prefs: []
  type: TYPE_NORMAL
- en: When `python -m unittest` is executed, what actually happens is that `TestLoader.discover`
    is called. This looks for all modules and packages named `test*` in the local
    directory and runs all the tests declared in those modules.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard library `unittest` module provides nearly all you need to write
    tests for your libraries or applications.
  prefs: []
  type: TYPE_NORMAL
- en: But if you find you need more features, such as retrying flaky tests, reporting
    in more formats, and support for driving browsers, you might want to try a testing
    framework such as `pytest`. Those usually provide a plugin infrastructure that
    permits you to expand their behavior with additional features.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When testing your code, you might face the need to replace the behavior of an
    existing function or class and to track whether a function was called or not with
    the proper arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say you have a function such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To test it, we don't want to go to the screen and check the output, but we still
    want to know whether the printed value was the expected one.
  prefs: []
  type: TYPE_NORMAL
- en: So a possible approach might be to replace `print` with something that doesn't
    print anything, but allows us to track the provided argument (which is the value
    that would be printed).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is exactly the meaning of mocking: replacing an object or function in
    the code base with one that does nothing but allows us to inspect the call.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to perform the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `unittest` package provides a `mock` module that allows us to create `Mock`
    objects and to `patch` existing objects, so we can rely on it to replace the behavior
    of `print`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we know that the mocked `print` was actually called with `2`, which is
    the value we expected, we can go even further and print all the arguments that
    it received:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this case, it's not very helpful as there was a single argument, but in cases
    where you only want to check some arguments instead of the whole call, it might
    be convenient to be able to access some of the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`mock.patch` replaces, within the context, the specified object or class with
    a `Mock` instance.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Mock` will do nothing when called, but will track their arguments and will
    allow you to check that they were called as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So with `mock.patch`, we replace `print` with `Mock` and we keep a reference
    to `Mock` as `mprint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to check that `print` was called with the expected arguments,
    through `Mock`, later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Mock` objects are actually not constrained to doing nothing.
  prefs: []
  type: TYPE_NORMAL
- en: By providing the `side_effect` argument to `mock.patch`, you can have them raise
    exceptions when called. This is helpful in simulating failures in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Or you can even replace their behavior with a totally different object by providing
    `new` to `mock.patch`, which is great to inject fake objects in place of the real
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: So, generally, `unittest.mock` can be used to replace the behavior of existing
    classes and objects with anything else, from mock objects, to fake objects, to
    different implementations.
  prefs: []
  type: TYPE_NORMAL
- en: But pay attention when using them, because if the caller had a reference to
    the original object saved aside, `mock.patch` might be unable to replace the function
    for it, as it's still constrained to the fact that Python is a reference-based
    language and if you have a reference to an object, there is no easy way for third-party
    code to hijack that reference.
  prefs: []
  type: TYPE_NORMAL
- en: So always make sure you apply `mock.patch` before using the things you are patching,
    to reduce the risk of references to the original object to be around.
  prefs: []
  type: TYPE_NORMAL
- en: Reporting errors in production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important aspects of production software is being notified in
    case of errors. As we are not the user of the software itself, we can only know
    that something is wrong if the software notifies us (or when it's too late and
    users are complaining).
  prefs: []
  type: TYPE_NORMAL
- en: Based on the Python standard library, we can easily build a solution that notifies
    developers in case of a crash by email.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `logging` module has a way to report exceptions by email, so we can set
    up a logger and trap the exceptions to log them by email:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the two functions are in place, we can configure `logging` and then decorate
    our main code base entry point so that all exceptions in our code base are reported
    by email:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `logging` module is able to send messages to any handler attached to logger,
    and has a feature to explicitly log crashes by logging an exception and its traceback
    through `.exception`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So the root of our solution to send exceptions by email is to wrap the main
    function of our code base with a decorator that traps all exceptions and invokes
    the logger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `crashlogger.exception` method will build a message that contains our custom
    text (which reports the name of the decorated function) plus the traceback for
    the crash, and will send it to the associated handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Through the `configure_crashreport` method, we provided a custom handler for
    `crashlogger`. A handler then sends the messages by email:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The additional `_configured` flag is used as a guard to prevent the handler
    from being added twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we just have to invoke `configure_crashreport` to provide the credentials
    for the email service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: And all exceptions in the function will be logged in `crashlogger` and thus
    sent by email through the associated handler.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing software, it's frequently important to ensure that some performance
    constraints are guaranteed. The standard library has most of the tools needed
    to ensure the timing and resource consumption of the functions we write.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we have two functions and we want to know which one is faster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `timeit` module provides a bunch of utilities to time a function or whole
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: From the reported timing, we know that `function2` is twice as fast as `function1`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally, such a function would run in a few milliseconds, but the reported
    timings are in the order of seconds.
  prefs: []
  type: TYPE_NORMAL
- en: That's because, by default, `timeit.timeit` will run the benchmarked code 1
    million times to provide a result where any temporary change in speed of the execution
    won't impact the final result much.
  prefs: []
  type: TYPE_NORMAL
- en: Inspection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being a powerful dynamic language, Python allows us to change its runtime behavior
    based on the state of objects it's working with.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the state of objects is the foundation of every dynamic language,
    and the standard library `inspect` module has most of the features needed for
    such a case.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, the following steps are to be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the `inspect` module, we can quickly create a helper function that
    will tell us major object properties and type for most objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, if we apply it to any object, we will get the details about its type,
    attributes, methods, and, if it''s a function, its arguments. We can even make
    a custom type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We inspect its methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'An instance of that type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Or the class itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`inspect_object` relies on `inspect.isfunction`, `inspect.ismethod`, and `inspect.isclass`
    to decide the kind of argument that was provided.'
  prefs: []
  type: TYPE_NORMAL
- en: Once it's clear that the object provided fits into one of those types, it provides
    the more reasonable information for that kind of object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For functions and methods, it looks at the signature of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `inspect.signature` function returns a `Signature` object that contains
    all the details about arguments accepted by the given method.
  prefs: []
  type: TYPE_NORMAL
- en: 'When printed, those arguments are listed on screen, which is what we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In case of a class, we are mostly interested in the methods that the class
    exposes. So we are going to use `inspect.getmembers` to grab all attributes of
    the class, and then `inspect.isfunction` to filter those only for functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The second argument of `inspect.getmembers` can be any predicate that will be
    used to filter the members.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of objects, we want to show the attributes and methods of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Objects usually have tens of methods that are provided by default in Python
    to support the standard operators and behaviors. Those are the so-called magic
    methods, which we usually don''t care about. So we have to only list the public
    methods and attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As we know, `inspect.getmembers` accepts a predicate to filter which members
    to return. But the predicate can only act on the member itself; it has no way
    to know its name. So we have to filter the result of `inspect.getmembers` ourselves
    with a list comprehension that removes any attribute whose name starts with a
    `dunder (__)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are the public attributes and methods of the provided object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We also printed the `__class__` of the object itself to provide a hint about
    what kind of object we are looking at.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `inspect` module has tens of functions that can be used to dive deep into
    Python objects.
  prefs: []
  type: TYPE_NORMAL
- en: It can be a really powerful tool when investigating third-party code or when
    implementing heavily dynamic code that has to cope with objects of unknown shape
    and type.
  prefs: []
  type: TYPE_NORMAL
- en: Code evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is an interpreted language, and the interpreter features are exposed
    in the standard library too.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we can evaluate expressions and statements coming from files
    or text sources and have them run as Python code within Python code itself.
  prefs: []
  type: TYPE_NORMAL
- en: It's also possible to evaluate code in a fairly safe way that allows us to create
    objects from expressions but prevents the execution of any function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps for this recipe are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `eval`, `exec`, and `ast` functions and modules provide most of the machinery
    needed for execution of code from strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `run_python` function in `evalsafe` mode allows us to run basic Python
    expressions in a safe way. This means that we can create Python objects from their
    literal representation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can''t run functions or perform more advanced commands such as indexing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to run those, we need to `eval` in a non-safe manner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This is discouraged, because it allows execution of malicious code in the current
    interpreter session. But even if it allows more widespread execution, it still doesn''t
    allow more complex statements such as definition of functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To allow full Python support, we need to use the `exec` mode, which will allow
    execution of all Python code, but won''t give us back the result of the expression
    anymore (as the provided code might not be an expression at all):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Tracing code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `trace` module provides a powerful and easy tool to trace which lines of
    code were executed during a run.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing can be used both to ensure testing coverage and to see the behavior
    of our software or third-party function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to perform the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement a function that traces the execution of a provided function
    and returns the modules that were executed and the lines for each module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, once we have the tracing, we need to actually print it so that it''s
    human-readable. To do that, we are going to read the source code for each traced
    module and print it with a `+` marker that is going to signal whether a line was
    executed or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Given any function, we can see which lines of code are being executed in various
    conditions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we can print the tracing for the function with `should_print=False`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can check what happens with `should_print=True`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You can see that line `0005` is now marked with the `+` sign as it was executed.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `report_tracing` function is the one actually in charge of tracing the execution
    of another function.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, as the execution is per module, it creates `defaultdict`, where
    the tracing can be stored. The key will be the module, and the value will be a
    list containing information for each line of that module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it creates the actual tracing machinery. The `trace=False` option is
    especially important to avoid the tracing being printed on screen. Right now,
    we want to save it aside, not print it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the tracer is available, we can use it to run the provided function with
    any given argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the tracing is saved into the tracer itself, so we can access
    it with `tracing.results()`. What we are interested in is whether a line of code
    was executed at least once, so we are going to look for the counts, and add each
    line of code that was executed to the set of executed lines of code for the given
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The resultant `traced` dictionary contains all the lines of code that were actually
    executed for a given module. It doesn't, by the way, contain any detail about
    those that were not executed.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we only have the line number, and no other detail about the executed
    lines of code. We, of course, also want the line of code itself, and we want to
    have all lines of code, not just the executed ones, so we can print back the source
    code with no gaps.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s why `report_tracing` then opens the source code for each executed module
    and reads its content. For each line, it checks whether it''s in the set of the
    executed ones for that module and stores aside a tuple containing the line number,
    a Boolean value that states whether it was executed or not, and the line content
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the resultant dictionary contains all modules that were executed,
    with their source code, annotated with details about the line number and whether
    it was executed or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`print_traced_execution` is then far easier: its only purpose is to take the
    data we gathered and print it on screen, so that a human being can see the source
    code and what was executed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function iterates on every traced module and prints the `filename` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, for each module, it iterates over the tracing details and prints the
    line number (as a four-digit number, so that code is indented properly for any
    line number up to 9999), a `+` sign if the line was executed, and the line content
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using tracing, you can easily check whether the code you wrote was executed
    or not by your tests. You just have to limit the tracing to the modules you wrote
    and you are interested in.
  prefs: []
  type: TYPE_NORMAL
- en: There are third-party modules that specialize in coverage reporting of tests;
    the most widespread one is probably the `coverage` module twhich has support for
    the most common testing frameworks, such as `pytest` and `nose`.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you need to speed up your code or understand where a bottleneck is, profiling
    is one of the most effective techniques.
  prefs: []
  type: TYPE_NORMAL
- en: The Python standard library provides a built-in profiler that traces the execution
    and timing for each function and allows you to spot the functions that are more
    expensive or that run too many times, consuming most of the execution time.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, the following steps are to be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take any function we want to profile (which can even be the main entry
    point of the program):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can profile it using the `cProfile` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'That will print the timing for the function and the slowest functions called
    by the profiled one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `cProfile.Profile` object is able to run any function with provided arguments
    and gather execution statistics with a minor overload.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `runcall` function is the one that actually runs the function providing
    the passed arguments (in this case, `True` is provided as the first function argument,
    which means `goslow=True`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the profiling data is gathered, we can print it on screen to provide details
    about what was executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The printed output includes the list of functions executed during the call,
    the total time it took for each of those functions, the time each function took
    on each call, and the total number of calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the major bottleneck of `slowfunc` was the `time.sleep` call:
    it took `1.181` out of the total `1.183` time it took to run whole `slowfunc`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can try to call `slowfunc` with `goslow=False` and see how the timing changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'And, in this case, we see that the whole function runs in `0.000` instead of
    `1.183` and there is no more reference to `time.sleep`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
