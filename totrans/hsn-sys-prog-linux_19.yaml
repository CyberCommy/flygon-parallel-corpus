- en: Troubleshooting and Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A brief overview on newer Linux troubleshooting tools and utilities, as well
    as industry best practices to follow when designing, developing, and deploying
    real-world Linux systems apps, is the focus of this chapter. We wish to make it
    very clear, though, that this is a book on Linux systems programming; the troubleshooting
    tips and best practices described here are exclusively with regard to the system-level
    development of applications (typically written in C/C++) on a Linux system; we
    do not deal with generic troubleshooting on Linux (topics such as troubleshooting
    network or configuration issues, system administration tips, and tricks).
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter in particular (mainly due to the vast scope and size of the
    content it only mentions in passing), we have provided several useful online articles
    and books in the *Further reading *section on the GitHub repository. Please do
    browse through them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter serves to round off this book; here, with respect to Linux systems
    programming, the reader will be given the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of (newer) troubleshooting tools and techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of industry best practices—in terms of design, software engineering,
    programming implementation, and testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will mention several tools and utilities that can help
    the application developer identify system bottlenecks and performance issues.
    (Note that here, to save space and time, we do not delve into the dozens of usual
    suspects—well-known system monitoring utilities on Linux such as `ps`, `pstree`,
    `top`, `htop`, `pidstat`, `vmstat`, `dstat`, `sar`, `nagios`, `iotop`, `iostat`,
    `ionice`, `lsof`, `nmon`, `iftop`, `ethtool`, `netstat`, `tcpdump`, `wireshark`—and
    instead mention the newer ones). Here is an important thing to remember when performing
    data collection (or benchmarking) for later analysis: take the trouble to set
    up a test rig and, when using it, change (as far as is possible) only one variable
    at a time for a given run so that you can see its impact.'
  prefs: []
  type: TYPE_NORMAL
- en: perf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance measurement and analysis is an enormous topic; the identification,
    analysis, and determination of the root cause for performance issues is no trivial
    task. In recent years, the `perf(1)` and `htop(1)` utility has emerged as the
    fundamental tool for performance measurement and analysis on the Linux platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, all you need is to see what is consuming the most CPU; traditionally,
    we use the well-known `top(1)` utility to do so. Try, instead, the very useful
    `perf` variant, like so: `sudo perf top`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you can exploit some of the features with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Essentially, this is the `perf` workflow: record a session (data files get
    saved) and generate a report. (See the links in *Further reading* section on the
    GitHub repository.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Excellent diagrams available on Brendan Gregg''s blog clearly show the dozens
    of tools available for performing observation, performance analysis, and dynamic
    tracing on Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: Linux performance tools: [http://www.brendangregg.com/Perf/linux_perf_tools_full.png](http://www.brendangregg.com/Perf/linux_perf_tools_full.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux performance observability tools: [http://www.brendangregg.com/Perf/linux_observability_tools.png](http://www.brendangregg.com/Perf/linux_observability_tools.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to its visual impact, Brendan Gregg's Flame Graph scripts are very interesting
    too; check out the links in the *Further reading *section on the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Brendan Gregg also leads the development of a project called perf-tools. Here
    are some words from the project: performance analysis tools based on Linux `perf_events`
    *(*aka perf) and Ftrace. Several very useful shell script wrappers (over Perf,
    Ftrace, and Kprobes) make up the tools; do clone the GitHub repository and try
    them out.* (*[https://github.com/brendangregg/perf-tools](https://github.com/brendangregg/perf-tools).)'
  prefs: []
  type: TYPE_NORMAL
- en: Tracing tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In-depth tracing often has the desirous side effect of having the developer
    or tester spot performance bottlenecks as well as debug systems-level latencies
    and issues. Linux has a plethora of frameworks and tools available for tracing,
    both at user space and at the level of the kernel; some of the more relevant ones
    are mentioned here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User space**: `ltrace(1)` (trace library APIs), `strace(1)` (trace system
    calls; also try doing `sudo perf trace`), LTTng-ust, uprobes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kernel space**: LTTng, ftrace (plus several frontends such as `tracecmd(1)`,
    kernelshark GUIm), Kprobes—(including Jprobes—up to Kernel Version 4.14), Kretprobes;
    SystemTaprm) eBPF.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Linux proc filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux has a very rich and powerful filesystem called **procfs**—`proc` for
    process. It is usually mounted under `/proc`, and it contains pseudo-files and
    directories that contain valuable runtime-generated information on processes and
    internals information. In a nutshell, procfs serves as a UI for two key purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: It serves as a viewport into detailed process, thread, OS, and hardware information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It serves as the place to query and set kernel-level tunables (switches and
    values for the core kernel, scheduling, memory, and network parameters).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking the trouble to study and use the Linux proc filesystem is well worth
    it. Pretty much all the user space monitoring and analysis tools are ultimately
    based on procfs. Find further information in the links provided in *Further reading *section
    on the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we briefly enumerate what we consider to be industry best practices,
    though they are mostly generic and thus broad in scope; we will particularly look
    at them through the lens of the Linux systems programmer.
  prefs: []
  type: TYPE_NORMAL
- en: The empirical approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The word *empirical* (according to the *Cambridge English dictionary*) means
    based on what is experienced or seen, rather than on theory. This is perhaps the
    critical principle to be followed. A fascinating article by Gustavo Duarte (mentioned
    here: [https://www.infoq.com/news/2008/02/realitydrivendevelopment](https://www.infoq.com/news/2008/02/realitydrivendevelopment))
    states: "*Action and experimentation are the cornerstones of empiricism. No attempt
    is made to subdue reality by extensive analysis and copious documentation. Reality
    is invited in via experiments. Instead of agonizing over market research, an empirical
    company hires interns and develops a product in one summer. A non-empirical company
    has 43 people planning an off-button design for one year."* Throughout this book,
    too, we have always tried to consciously follow an empirical approach; we definitely
    urge the reader to cultivate and embed the empirical principle in design and development.'
  prefs: []
  type: TYPE_NORMAL
- en: Software engineering wisdom in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Frederick P Brooks wrote his famous treatise *The Mythical Man-Month: Essays
    on Software Engineering* back in 1975, and this book is to date billed as the
    most influential book on software project management. This is no wonder: certain
    truths are just that—truths. Here are a few gems from this volume:'
  prefs: []
  type: TYPE_NORMAL
- en: Plan to throw one away; you will anyway.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no silver bullet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good cooking takes time. If you are made to wait, it is to serve you better,
    and to please you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bearing of a child takes nine months, no matter how many women are assigned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good judgment comes from experience, and experience comes from bad judgment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interestingly, and, of course, the design philosophy of the venerable Unix OS
    indeed incorporates great design principles, principles that remain in effect
    to this day on Linux. We covered this in [Chapter 1](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml), *Linux
    System Architecture*, in the section, *The Unix philosophy in a nutshell*.
  prefs: []
  type: TYPE_NORMAL
- en: Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now move on to the more mundane but really important things to be kept
    in mind by the developer.
  prefs: []
  type: TYPE_NORMAL
- en: A programmer’s checklist – seven rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We suggest seven rules as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule #1 : Check all APIs for their failure case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rule #2 : Compile with warnings on (`-Wall -Wextra`) and eliminate all warnings
    as far as is possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rule #3 : Never trust (user) input; validate it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rule #4 : Use assertions in your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rule #5 : Eliminate unused (or dead) code from the codebase immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rule #6 : Test thoroughly; 100% code coverage is the objective. Take the time
    and trouble to learn to use powerful tools: memory checkers (Valgrind, the sanitizer
    toolset), static and dynamic analyzers, security checkers (checksec), fuzzers (see
    the following explanation).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rule #7 : Do not assume anything (*assume* makes an *ass* out of *u* and *me*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples of how serious failures can result from not following
    the rules: An Ariane 5 unmanned rocket crashed early in its launch (June 4, 1996);
    the bug was ultimately traced to a register overflow issue, a single type casting
    error (rule #5). The Knight Capital Group lost $460 million in 45 minutes. Don’t
    assume the size of a page. Use the `getpagesize(2)` system call or the `sysconf(3)`
    to obtain it. Further along these lines, see the blog article entitled *Low-Level
    Software Design* (there are links to these in the *Further reading* section on
    GitHub repository).'
  prefs: []
  type: TYPE_NORMAL
- en: Better testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is a critical activity; thorough and continual testing (including regression
    testing) leads to a stable product in which both the engineering team and the
    customer have deep confidence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an often-overlooked truth: complete code coverage testing is critical!
    Why? Simple—there are often hidden defects lurking in sections of code that never
    actually get tested (error handling being the typical example); the fact is though,
    they will be hit one fine day, and this can cause terrible failures.'
  prefs: []
  type: TYPE_NORMAL
- en: Then again, unfortunately, testing can only reveal the presence of errors, not
    their absence; nevertheless, good and thorough testing is absolutely critical. Most
    testing performed (test cases written) tends to be positive test cases; interestingly,
    the majority of software (security) vulnerabilities escape unnoticed by this kind
    of testing. Negative test cases help catch these failures; a class of software
    testing called **fuzzing** helps greatly in this regard. Testing code on different
    machine architectures can help expose hidden defects as well.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Linux kernel's control groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the Linux kernel''s **cgroups** (control groups) technology to specify
    and constrain resource allocation and bandwidth. The cgroup controllers on a modern
    Linux system include the following: CPU (limits on CPU usage), CPU set (the modern
    way to perform CPU affinity  constraining a group of processes to a set of CPUs),
    blkio (limits on I/O), devices (limits on which processes can use which devices),
    freezer (suspend/resume task execution), memory (limits on memory usage), `net_cls`
    (network packets tagging with classid), `net_prio` (limit network traffic per
    interface), **namespaces** (**ns**), `perf_event` (for performance analysis).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Limiting resources is critical not only from a requirements angle, but from
    a security perspective too (think about malicious attackers dreaming up [D]DoS
    attacks). Incidentally, containers (essentially a lightweight virtualization technique),
    a hot topic nowadays, are largely a reality because of the combination of two
    Linux kernel technologies that have sufficiently evolved: cgroups and namespaces.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Question: What''s the biggest room in the world?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: The room for improvement!'
  prefs: []
  type: TYPE_NORMAL
- en: This, in general, should sum up the attitude you should have when working on
    enormous projects, and keep learning for life topics such as Linux. We, again,
    urge the reader to not only read for conceptual understanding—that's important!—but
    to also get their hands dirty and write the code. Make mistakes, fix them, and
    learn from them. Contributing to open source is a fantastic way to do so.
  prefs: []
  type: TYPE_NORMAL
