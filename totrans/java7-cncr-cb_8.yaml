- en: Chapter 8. Testing Concurrent Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring a `Lock` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring a `Phaser` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring an Executor framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring a Fork/Join pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing effective log messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing concurrent code with FindBugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Eclipse for debugging concurrency code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring NetBeans for debugging concurrency code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing concurrency code with MultithreadedTC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing an application is a critical task. Before the application is ready for
    end users, you have to demonstrate its correctness. You use a test process to
    prove that correctness is achieved and errors are fixed. The testing phase is
    a common task in any software development and also **quality assurance** processes.
    You can find a lot of literature about testing processes and the different approaches
    you can apply to your developments. There are also a lot of libraries, such as
    `JUnit`, and applications, such as Apache `JMetter` that you can use to test your
    Java applications in an automated way. It's even more critical in a concurrent
    application development.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that concurrent applications have two or more threads that share data
    structures and interact with each other adds more difficulty to the testing phase.
    The biggest problem you will face when you test concurrent applications is that
    the execution of threads is non-deterministic. You can't guarantee the order of
    the execution of the threads, so it's difficult to reproduce errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to obtain information about the elements you have in your concurrent applications.
    This information can help you test your concurrent applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use an IDE (Integrated Development Environment) and other tools such
    as FindBugs to test your concurrent applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use libraries such as MultithreadedTC to automate your tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring a Lock interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `Lock` interface is one of the basic mechanisms provided by the Java concurrency
    API to get the synchronization of a block of code. It allows the definition of
    a **critical section**. A critical section is a block of code that accesses a
    shared resource and can't be executed by more than one thread at the same time.
    This mechanism is implemented by the `Lock` interface and the `ReentrantLock`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn what information you can obtain about a `Lock`
    object and how to obtain that information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `MyLock` that extends the `ReentrantLock` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `getOwnerName()` method. This method returns the name of the thread
    that has the control of a lock (if any) using the protected method of the `Lock`
    class `getOwner()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `getThreads()` method. This method returns a list of threads queued
    in a lock using the protected method of the `Lock` class`getQueuedThreads()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `Task` that implements the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `Lock` attribute named `lock`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Implement a constructor of the class to initialize its attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. Create a loop with five steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Acquire the lock using the `lock()` method and print a message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Put the thread to sleep for 500 milliseconds. Free the lock using the `unlock()`
    method and print a message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Create the main class of the example by creating a class named `Main` with a
    `main()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Create a `MyLock` object named `lock`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Create an array for five `Thread` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Create and start five threads to execute five `Task` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Create a loop with 15 steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Write in the console the name of the owner of the lock.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Display the number and the name of the threads queued for the lock.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Display information about the fairness and the status of the `Lock` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Put the thread to sleep for 1 second and close the loop and the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, you have implemented the `MyLock` class that extends the `ReentrantLock`
    class to return information that otherwise wouldn''t have been available – it''s
    protected data of the `ReentrantLock` class. The methods implemented by the `MyLock`
    class are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getOwnerName()`: Only one thread can execute a critical section protected
    by a `Lock` object. The lock stores the thread that is executing the critical
    section. This thread is returned by the protected `getOwner()` method of the `ReentrantLock`
    class. This method uses the `getOwner()` method to return the name of that thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getThreads()`: While a thread is executing a critical section, the other threads
    that try to enter it are put to sleep until they can continue executing that critical
    section. The protected method `getQueuedThreads()` of the `ReentrantLock` class
    returns the list of threads that are waiting to execute the critical section.
    This method returns the result returned by the `getQueuedThreads()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have also used other methods that are implemented in the `ReentrantLock`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hasQueuedThreads()`: This method returns a `Boolean` value indicating if there
    are threads waiting to acquire this lock'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getQueueLength()`: This method returns the number of threads that are waiting
    to acquire this lock'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isLocked()`: This method returns a `Boolean` value indicating whether this
    lock is owned by a thread'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isFair()`: This method returns a `Boolean` value indicating if this lock has
    the fair mode activated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are other methods in the `ReentrantLock` class that can be used to obtain
    information about a `Lock` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getHoldCount()`: Returns the number of times that the current thread has acquired
    the lock'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isHeldByCurrentThread()`: Returns a `Boolean` value indicating if the lock
    is owned by the current thread'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Synchronizing a block of code with a lock* recipe in [Chapter 2](ch02.html
    "Chapter 2. Basic Thread Synchronization"), *Basic Thread Synchronization*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing a custom Lock class* recipe in [Chapter 7](ch07.html "Chapter 7. Customizing
    Concurrency Classes"), *Customizing Concurrency Classes*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring a Phaser class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most complex and powerful functionalities offered by the Java Concurrency
    API is the ability to execute concurrent phased tasks using the `Phaser` class.
    This mechanism is useful when we have some concurrent tasks divided in steps.
    The `Phaser` class provides us the mechanism to synchronize the threads at the
    end of each step, so no thread starts its second step until all the threads have
    finished the first one.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn what information about the status of a `Phaser`
    class you can obtain and how to obtain that information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `Task` that implements the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `int` attribute named `time`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `Phaser` attribute named `phaser`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. First, instruct the `phaser` attribute that the
    task starts its execution with the `arrive()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Write a message in the console indicating the start of phase one, put the thread
    to sleep for the number of seconds specified by the `time` attribute, write in
    the console a message indicating the end of phase one, and synchronize with the
    rest of the tasks using the `arriveAndAwaitAdvance()` method of the `phaser` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Repeat the behavior for the second and third phases. At the end of the third
    phase, use the `arriveAndDeregister()` method instead of `arriveAndAwaitAdvance()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Create a new `Phaser` object named `phaser` with three participants.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Create and launch three threads to execute three task objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Create a loop with 10 steps to write information about the `phaser` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Write information about the registered parties, the phase of the phaser, the
    arrived parties, and the un-arrived parties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Put the thread to sleep for 1 second and close the loop and the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we have implemented a phased task in the `Task` class. This
    phased task has three phases and uses a `Phaser` interface to synchronize with
    other `Task` objects. The main class launches three tasks and while these tasks
    are executing their phases, it prints information about the status of the `phaser`
    object to the console. We have used the following methods to get the status of
    the `phaser` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getPhase()`: This method returns the actual phase of a `phaser` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getRegisteredParties()`: This method returns the number of tasks that use
    a `phaser` object as a mechanism of synchronization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getArrivedParties()`: This method returns the number of tasks that have arrived
    at the end of the actual phase'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getUnarrivedParties()`: This method returns the number of tasks that haven''t
    yet arrived at the end of the actual phase'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Running concurrent phased tasks* recipe in [Chapter 3](ch03.html "Chapter 3. Thread
    Synchronization Utilities"), *Thread Synchronization Utilities*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring an Executor framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Executor framework provides a mechanism that separates the implementation
    of tasks from the thread creation and management to execute those tasks. If you
    use an executor, you only have to implement the `Runnable` objects and send them
    to the executor. It is the responsibility of an executor to manage threads. When
    you send a task to an executor, it tries to use a pooled thread for the execution
    of this task, to avoid creating new threads. This mechanism is offered by the
    `Executor` interface and its implementing classes as the `ThreadPoolExecutor`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you're going to learn what information you can obtain about
    the status of a `ThreadPoolExecutor` executor and how to obtain it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `Task` that implements the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `long` attribute named `milliseconds`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. Put the thread to sleep for the number of milliseconds
    specified by the `milliseconds` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Create a new `Executor` object using the `newCachedThreadPool()` method of the
    `Executors` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Create and submit 10 `Task` objects to the executor. Initialize the objects
    with a random number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Create a loop with five steps. In each step, write information about the executor
    calling the `showLog()` method and put the thread to sleep for a second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Shut down the executor using the `shutdown()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Create another loop with five steps In each step, write information about the
    executor calling the `showLog()` method and put the thread to sleep for a second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the finalization of the executor using the `awaitTermination()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Display a message about the end of the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `showLog()` method that receives `Executor` as parameter. Write
    information about the size of the pool, the number of tasks, and the status of
    the executor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, you have implemented a task that blocks its execution thread
    for a random number of milliseconds. Then, you have sent 10 tasks to an executor
    and while you''re waiting for their finalization, you have written information
    about the status of the executor to the console. You have used the following methods
    to get the status of the `Executor` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getCorePoolSize()`: This method returns an `int` number, which is the core
    number of threads. It''s the minimum number of threads that will be in the internal
    thread pool when the executor is not executing any task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getPoolSize()`: This method returns an `int` value, which is the actual size
    of the internal thread pool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getActiveCount()`: This method returns an `int` number, which is the number
    of threads that are currently executing tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getTaskCount()`: This method returns a `long` number, which is the number
    of tasks that have been scheduled for execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getCompletedTaskCount()`: This method returns a `long` number, which is the
    number of tasks that have been executed by this executor and have finished their
    execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isShutdown()`: This method returns a `Boolean` value when the `shutdown()`
    method of an executor has been called to finish its execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isTerminating()`: This method returns a `Boolean` value when the executor
    is doing the `shutdown()` operation, but it hasn''t finished it yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isTerminated()`: This method returns a `Boolean` value when this executor
    has finished its execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a thread executor* recipe in [Chapter 4](ch04.html "Chapter 4. Thread
    Executors"), *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Customizing the ThreadPoolExecutor class* recipe in [Chapter 7](ch07.html
    "Chapter 7. Customizing Concurrency Classes"), *Customizing Concurrency Classes*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing a priority-based Executor class* recipe in [Chapter 7](ch07.html
    "Chapter 7. Customizing Concurrency Classes"), *Customizing Concurrency Classes*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring a Fork/Join pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Executor framework provides a mechanism that allows the separation of the
    task implementation from the creation and management of the threads that execute
    those tasks. Java 7 includes an extension of the Executor framework for a specific
    kind of problem that will improve the performance of other solutions (as using
    `Thread` objects directly or the Executor framework). It's the Fork/Join framework.
  prefs: []
  type: TYPE_NORMAL
- en: This framework is designed to solve those problems that can be broken into smaller
    tasks using the divide and conquer technique using the `fork()` and `join()` operations.
    The main class that implements this behavior is the `ForkJoinPool` class.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you're going to learn what information you can obtain about
    a `ForkJoinPool` class and how to obtain it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `Task` that extends the `RecursiveAction` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `int` array attribute named `array` to store the array of
    elements you want to increment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Declare two private `int` attributes named `start` and `end` to store the start
    and end positions of the block of elements this task has to process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `compute()` method with the main logic of the task. If the task
    has to process more than 100 elements, divide that set of elements in two parts,
    create two tasks to execute those parts, start its execution with the `fork()`
    method, and wait for its finalization with the `join()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If the task has to process 100 elements or less, increment those elements by
    putting the thread to sleep for 5 milliseconds after each operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Create a `ForkJoinPool` object named `pool`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Create an array of integer numbers named `array` with 10,000 elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Create a new `Task` object to process the whole array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Send the task for execution in the pool using the `execute()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: While the task doesn't finish its execution, call the `showLog()` method to
    write information about the status of the `ForkJoinPool` class and put the thread
    to sleep for a second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Shut down the pool using the `shutdown()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the finalization of the pool using the `awaitTermination()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Call the `showLog()` method to write information about the status of the `ForkJoinPool`
    class and write a message in the console indicating the end of the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `showLog()` method. It receives a `ForkJoinPool` object as a parameter
    and writes information about its status and the threads and tasks that are executing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, you have implemented a task that increments elements of an
    array using a `ForkJoinPool` class and a `Task` class that extends the `RecursiveAction`
    class; one of the kind of tasks that you can execute in a `ForkJoinPool` class.
    While the tasks are processing the array, you print information about the status
    of the `ForkJoinPool` class to the console. You have used the following methods
    to get the status of the `ForkJoinPool` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getPoolSize()`: This method returns an `int` value, which is the number of
    worker threads of the internal pool of a fork join pool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getParallelism()`: This method returns the desired level of parallelism established
    for a pool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getActiveThreadCount()`: This method returns the number of threads that are
    currently executing tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getRunningThreadCount()`: This method returns the number of working threads
    that are not blocked in any synchronization mechanism'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getQueuedSubmissionCount()`: This method returns the number of tasks that
    have been submitted to a pool that haven''t started their execution yet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getQueuedTaskCount()`: This method returns the number of tasks that have been
    submitted to a pool that have started their execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hasQueuedSubmissions()`: This method returns a `Boolean` value indicating
    if this pool has queued tasks that haven''t started their execution yet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getStealCount()`: This method returns a `long` value with the number of times
    a worker thread has stolen a task from another thread'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isTerminated()`: This method returns a `Boolean` value indicating if the fork/join
    pool has finished its execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a Fork/Join pool* recipe in [Chapter 5](ch05.html "Chapter 5. Fork/Join
    Framework"), *Fork/Join Framework*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing the ThreadFactory interface to generate custom threads for
    the Fork/Join framework* recipe in [Chapter 7](ch07.html "Chapter 7. Customizing
    Concurrency Classes"), *Customizing Concurrency Classes*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Customizing tasks running in the Fork/Join framework* recipe in [Chapter
    7](ch07.html "Chapter 7. Customizing Concurrency Classes"), *Customizing Concurrency
    Classes*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing effective log messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **log system** is a mechanism that allows you to write information to one
    or more destinations. A **Logger** has the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**One or more handlers**: A handler will determine the destination and the
    format of log messages. You can write log messages to the console, a file, or
    a database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A name**: Usually, the name of a Logger used in a class that''s based on
    the class name and its package name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A level**: Log messages have a level associated that indicates its importance.
    A Logger also has a level used to decide what messages it is going to write. It
    only writes the messages that are as important as, or more important, than its
    level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You should use the log system with the following two main purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Write as much information as you can when an exception is caught. This will
    help to localize the error and resolve it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write information about the classes and methods that the program is executing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the classes provided by the `java.util.logging`
    package to add a log system to your concurrent application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `MyFormatter` that extends the `java.util.logging.Formatter`
    class. Implement the abstract `format()` method. It receives a `LogRecord` object
    as a parameter and returns a `String` object with the log message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `MyLogger`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private static `Handler` attribute named `handler`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Implement the public static method `getLogger()` to create the `Logger` object
    that you're going to use to write the log messages. It receives a `String` parameter
    named `name`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Get `java.util.logging.Logger` associated with the name received as a parameter
    using the `getLogger()` method of the `Logger` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Establish the log level to write all the log messages using the `setLevel()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: If the handler attribute has the `null` value, create a new `FileHandler` object
    to write the log messages in the `recipe8.log` file. Assign to that handler a
    `MyFormatter` object as a formatter using the `setFormatter()` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: If the `Logger` object does not have a handler associated to it, assign the
    handler using the `addHandler()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Return the `Logger` object created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `Task` that implements the `Runnable` interface. It will
    be the task used to test your `Logger` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: First, declare a `Logger` object named `logger`. Initialize it using the `getLogger()`
    method of the `MyLogger` class passing the name of this class as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Write a log message indicating the beginning of the execution of the method
    using the `entering()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Write a log message indicating the end of the execution of the method using
    the `exiting()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Declare a `Logger` object named `logger`. Initialize it using the `getLogger()`
    method of the `MyLogger` class passing the string `Core` as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Write a log message indicating the start of the execution of the main program
    using the `entering()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Create a `Thread` array to store five threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Create five `Task` objects and five threads to execute them. Write log messages
    to indicate that you're going to launch a new thread and to indicate that you
    have created the thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Write a log message to indicate that you have created the threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the finalization of the five threads using the `join()` method. After
    the finalization of each thread, write a log message indicating that the thread
    has finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Write a log message to indicate the end of the execution of the main program
    using the `exiting()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, you have used the `Logger` class provided for the Java logging
    API to write log messages in a concurrent application. First of all, you have
    implemented the `MyFormatter` class to give a format to the log messages. This
    class extends the `Formatter` class that declares the abstract method `format()`.
    This method receives a `LogRecord` object with all the information of the log
    message and returns a formatted log message. In your class, you have used the
    following methods of the `LogRecord` class to obtain information about the log
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getLevel()`: Returns the level of a message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getMillis()`: Returns the date when a message was sent to a `Logger` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getSourceClassName()`: Returns the name of a class that sent the message to
    the Logger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getSourceMessageName()`: Returns the name of a method that sent the message
    to the Logger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getMessage()` returns the log message. The `MyLogger` class implements the
    static method `getLogger()` that creates a `Logger` object and assigns a `Handler`
    object to write log messages of the application to the `recipe8.log` file using
    the `MyFormatter` formatter. You create the `Logger` object with the static method
    `getLogger()` of that class. This method returns a different object per name that
    is passed as a parameter. You only have created one `Handler` object, so all the
    `Logger` objects will write its log messages in the same file. You also have configured
    the logger to write all the log messages, regardless of its level.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you have implemented a `Task` object and a main program that writes
    different log messages in the logfile. You have used the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`entering()`: Write a message with the `FINER` level indicating that a method
    starts its execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exiting()`: Write a message with the `FINER` level indicating that a method
    ends its execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log()`: Write a message with the specified level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you work with a log system, you have to take into consideration two important
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Write the necessary information**: If you write too little information, the
    logger won''t be useful because it won''t fulfil its purpose. If you write too
    much information, you will generate too large logfiles that will be unmanageable
    and make it difficult to get the necessary information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use the adequate level for the messages**: If you write information messages
    with the higher level or error messages with a lower level, you will confuse the
    user who looks at the logfiles. It will be more difficult to know what happened
    in an error situation or you will have too much information to know the main cause
    of the error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other libraries that provide a log system more complete than the `java.util.logging`
    package, such as the Log4j or slf4j libraries. But the `java.util.logging` package
    is part of the Java API and all its methods are multi-thread safe, so we can use
    it in concurrent applications without problems.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using non-blocking thread-safe lists* recipe in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Collections"), *Concurrent Collections*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using blocking thread-safe lists* recipe in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Collections"), *Concurrent Collections*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using blocking thread-safe lists ordered by priority* recipe in [Chapter
    6](ch06.html "Chapter 6. Concurrent Collections"), *Concurrent Collections*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using thread-safe lists with delayed elements* recipe in [Chapter 6](ch06.html
    "Chapter 6. Concurrent Collections"), *Concurrent Collections*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using thread-safe navigable maps* recipe in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Collections"), *Concurrent Collections*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Generating concurrent random numbers* recipe in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Collections"), *Concurrent Collections*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing concurrent code with FindBugs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **static code analysis tools** are a set of tools that analyze the source
    code of an application looking for potential errors. These tools, such as Checkstyle,
    PMD, or FindBugs have a set of predefined rules of good practices and parse the
    source code looking for violations of those rules. The objective is to find errors
    or places causing poor performance early, before it will be executed in production.
    Programming languages usually offer such tools and Java is not an exception. One
    of these tools to analyze Java code is FindBugs. It's an open source tool that
    includes a series of rules to analyze Java-concurrent code.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use this tool to analyze your Java-concurrent
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before stating this recipe, you should download FindBugs from the project's
    web page ([http://findbugs.sourceforge.net/](http://findbugs.sourceforge.net/)).
    You can download a standalone application or an Eclipse plugin. In this recipe,
    you will use the standalone version.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `Task` that extends the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `ReentrantLock` attribute named `Lock`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Implement a constructor of the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. Get the control of the lock, put the thread to
    sleep for 2 seconds and free the lock.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Create the main class of the example by creating a class named `Main` with a
    `main()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Declare and create a `ReentrantLock` object named `lock`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Create 10 `Task` objects and 10 threads to execute those tasks. Start the threads
    calling the `run()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Export the project as a `jar` file. Call it `recipe8.jar`. Use the menu option
    of your IDE or the `javac` and `jar` commands to compile and compress your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the FindBugs standalone application running the `findbugs.bat`**command
    in Windows or the `findbugs.sh` command in Linux.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Create a new project with the **New Project** option of the **File** menu
    in the menu bar.![How to do it...](img/7881_08_02.jpg)**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The **FindBugs** application shows a window to configure the project. In
    the **Project Name** field introduce the text `Recipe08`. In the **Classpath for
    analysis** field add the `jar` file with the project and in the **Source directories**
    field add the directory with the source code of the example. Refer to the following
    screenshot:![How to do it...](img/7881_08_03.jpg)**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Click on the **Analyze** button to create the new project and analyze its
    code.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The **FindBugs** application shows the result of the analysis of the code.
    In this case,it has found two bugs.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Click one of the bugs and you''ll see the source code of the bug in the right-hand
    side panel and the description of the bug in the panel of the bottom of the screen.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**How it works...**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**The following screenshot shows the result of the analysis by FindBugs:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**![How it works...](img/7881_08_04.jpg)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The analysis has detected the following two potential bugs in the application:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**One in the `run()` method of the class `Task`. If an `InterruptedExeption`
    exception is thrown, the task doesn''t free the lock because it won''t execute
    the `unlock()` method. This will probably cause a deadlock situation in the application.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The other is in the `main()` method of the `Main` class because you have
    called the `run()` method of a thread directly , but not the `start()` method
    to begin the execution of the thread.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**If you make a double-click in one of the two bugs, you will see detailed
    information about it. As you have included the source-code reference in the configuration
    of the project, you also will see the source code where the bug was detected.
    The following screenshot shows you an example of this:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**![How it works...](img/7881_08_05.jpg)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**There''s more...**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Be aware that FindBugs can only detect some problematic situations (related
    or not with the concurrency code). For example, if you delete the `unlock()` call
    in the `run()` method of the `Task` class and repeat the analysis, FindBugs won''t
    alert you that you get the lock in the task but you never free it.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use the tools for the static code analysis as a help to improve the quality
    of your code, but do not expect to detect all the bugs in your code.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**The *Configuring NetBeans for debugging concurrency code* recipe in [Chapter
    8](ch08.html "Chapter 8. Testing Concurrent Applications"), *Testing Concurrency
    Applications***'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**# Configuring Eclipse for debugging concurrency code'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, almost every programmer, regardless of the programming language in
    use, create their applications with an IDE. They provide lots of interesting functionalities
    integrated in the same application, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Project management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic code generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic documentation generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with control version systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A debugger to test the applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different wizards to create projects and elements of the applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the most helpful features of an IDE is a debugger. You can execute your
    application step-by-step and analyze the values of all the objects and variables
    of your program.
  prefs: []
  type: TYPE_NORMAL
- en: If you work with the Java programming language, Eclipse is one of the most popular
    IDEs. It has an integrated debugger that allows you to test your applications.
    By default, when you debug a concurrent application and the debugger finds a breakpoint,
    it only stops the thread that has that breakpoint while the rest of the threads
    continue with their execution.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to change that configuration to help you
    to test concurrent applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You must have installed the Eclipse IDE. Open it and select a project with a
    concurrent application implemented in it, for example, one of the recipes implemented
    in the book.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the menu option **Window** | **Preferences**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the left-hand side menu, expand the **Java** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the left-hand side menu, select the **Debug** option. The following screenshot
    shows the appearance of that window:![How to do it...](img/7881_08_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the value of the **Default suspend policy for new breakpoints** from
    **Suspend Thread** to **Suspend VM** (marked in red in the screenshot).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **OK**button to confirm the change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned in the introduction of this recipe, by default, when you debug
    a concurrent Java application in Eclipse and the debug process finds a breakpoint,
    it only suspends the thread that hit the breakpoint first while the other threads
    continue with their execution. The following screenshot shows an example of that
    situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see that only the **worker-21** is suspended (marked in red in the
    screenshot) while the rest of the threads are running. However, if you change
    **Default suspend policy for new breakpoints** to **Suspend VM**, all the threads
    suspend their execution while you''re debugging a concurrent application and the
    debug process hits a breakpoint. The following screenshot shows an example of
    this situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With the change, you can see that all the threads are suspended. You can continue
    debugging any thread you want. Choose the suspend policy that best suits your
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring NetBeans for debugging concurrency code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today's world, software is necessary to develop applications that work properly,
    that meet the quality standards of the company, and that will be easily modified
    in the future, in a limited time and with a cost as low as possible. To achieve
    this goal, it is essential to use an IDE that integrates under one common interface
    several tools (compilers and debuggers) that facilitate the development of applications.
  prefs: []
  type: TYPE_NORMAL
- en: If you work with the Java programming language, NetBeans is one of the most
    popular IDEs. It has an integrated debugger that allows you to test your application.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to change that configuration to help you
    to test concurrent applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should have the NetBeans IDE installed. Open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `Task1` and specify that it implements the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Declare two private `Lock` attributes named `lock1` and `lock2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. First, get the control of the `lock1` object using
    the `lock()` method and write a message in the console indicating that you have
    got it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Then, get the control of the `lock2` object using the `lock()` method and write
    a message in the console indicating that you have got it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `Task2` and specify that it implements the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Declare two private `Lock` attributes named `lock1` and `lock2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. First, get the control of the `lock2` object using
    the `lock()` method and write a message in the console indicating that you have
    got it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Then, get the control of the `lock1` object using the `lock()` method and write
    a message in the console indicating that you have got it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Finally, release the two lock objects. First, the `lock1` object and then the
    `lock2` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Create two lock objects named `lock1` and `lock2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Create a `Task1` object named `task1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Create a `Task2` object named `task2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Execute both tasks using two threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: While the two tasks haven't finished their execution, write a message in the
    console every 500 milliseconds. Use the `isAlive()` method to check if a thread
    has finished its execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Add a breakpoint in the first call to the `println()` method of the `run()`
    method of the `Task1` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Debug the program. You will see the **Debugging** window in the top left-hand
    side corner of the main NetBeans window. The next screenshot presents the appearance
    of that window with the thread that executes the `Task1` object slept because
    they have arrived at the breakpoint and the other threads running:![How to do
    it...](img/7881_08_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pause the execution of the main thread. Select that thread, right-click, and
    select the **Suspend** option. The following screenshot shows the new appearance
    of the **Debugging** window. Refer to the following screenshot:![How to do it...](img/7881_08_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resume the two paused threads. Select each thread, right-click, and select the
    **Resume** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While debugging a concurrent application using NetBeans, when the debugger hits
    a breakpoint, it suspends the thread that hit the breakpoint and shows the **Debugging**
    window in the top left-hand side corner with the threads that are currently running.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the window to pause or resume the threads that are currently running
    using the **Pause** or **Resume** options. You can also see the values of the
    variables or attributes of the threads using the **Variables** tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'NetBeans also includes a deadlock detector. When you select the **Check for
    Deadlock** option in the **Debug** menu, NetBeans performs an analysis of the
    application that you''re debugging to determine if there''s a deadlock situation.
    This example presents a clear deadlock. The first thread gets the lock `lock1`
    first and then the lock `lock2`. The second thread gets the locks just in a reverse
    manner. The breakpoint inserted provokes the deadlock, but if you use NetBeans
    deadlock detector, you''ll not find anything, so this option should be used with
    caution. Change the locks used in both tasks by the `synchronized` keyword and
    debug the program again. The code of the `Task1` will be presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The code of the `Task2` class will be analogous to this, but changes the order
    of the locks. If you debug the example again, you will obtain a deadlock again,
    but in this case, it''s detected by the deadlock detector, as you can see in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are options to control the debugger. Select the **Options** option in
    the **Tools** menu. Then, select the **Miscellaneous** option and the **Java Debugger**
    tab. The following screenshot shows the appearance of that window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/7881_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are two options on that window that control the behavior described earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '**New breakpoints suspend**: With this option, you can configure the behavior
    of NetBeans, which finds a breakpoint in a thread. You can suspend only the thread
    that has the breakpoint or all the threads of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Steps resume**: With this option, you can configure the behavior of NetBeans
    when you resume a thread. You can resume only the current thread or all the threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both options have been marked in the screenshot presented earlier.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Configuring Eclipse for debugging concurrency code* recipe in [Chapter
    8](ch08.html "Chapter 8. Testing Concurrent Applications"), *Testing Concurrent
    Applications*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing concurrency code with MultithreadedTC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MultithreadedTC is a Java library for testing concurrent applications. Its main
    objective is to solve the problem of concurrent applications being non-deterministic.
    You can't control their order of execution. For this purpose, it includes an internal
    **metronome** to control the order of execution of the different threads that
    form the application. Those testing threads are implemented as methods of a class.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the MultithreadedTC library to implement
    a test for `LinkedTransferQueue`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You must also download the MultithreadedTC library from [http://code.google.com/p/multithreadedtc/](http://code.google.com/p/multithreadedtc/)
    and the JUnit library, Version 4.10 from [http://www.junit.org/](http://www.junit.org/).
    Add the files `junit-4.10.jar` and `MultithreadedTC-1.01.jar` to the libraries
    of the project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `ProducerConsumerTest` that extends the `MultithreadedTestCase`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `LinkedTransferQueue` attribute parameterized with the `String`
    class named `queue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `initialize()` method. This method won't receive any parameters
    and returns no value. It calls the `initialize()` method of its parent class and
    then initializes the queue attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `thread1()` method. It will implement the logic of the first consumer.
    Call the `take()` method of the queue and then write the returned value in the
    console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `thread2()` method. It will implement the logic of the second
    consumer. First, wait until the first thread has slept in the `take()` method
    using the `waitForTick()` method. Then, call the `take()` method of the queue
    and then write the returned value in the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `thread3()` method. It will implement the logic of a producer.
    First, wait until the two consumers are blocked in the `take()` method using the
    `waitForTick()` method twice. Then, call the `put()` method of the queue to insert
    two `Strings` in the queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Finally, implement the `finish()` method. Write a message in the console to
    indicate that the test has finished its execution. Check that the two events have
    been consumed (so the size of the queue is `0`) using the `assertEquals()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Create a `ProducerConsumerTest` object named `test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Execute the test using the `runOnce()` method of the `TestFramework` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you have implemented a test for the `LinkedTransferQueue` class
    using the MultithreadedTC library. You can implement a test to any concurrent
    application or class using this library and its metronome. In the example, you
    have implemented the classical producer/consumer problem with two consumers and
    a producer. You want to test that the first `String` object introduced in the
    buffer is consumed by the first consumer that arrives at the buffer and the second
    `String` object introduced in the buffer is consumed by the second consumer that
    arrives at the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: The MultithreadedTC library is based on the JUnit library, which is the most
    often used library to implement unit tests in Java. To implement a basic test
    using the MultithreadedTC library, you have to extend the `MultithreadedTestCase`
    class. This class extends the `junit.framework.AssertJUnit` class that includes
    all the methods to check the results of the test. It doesn't extend the `junit.framework.TestCase`
    class, so you can't integrate the MultithreadedTC tests with other JUnit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you can implement the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`initialize()`: The implementation of this method is optional. It''s executed
    when you start the test, so you can use it to initialize objects that are using
    the test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`finish()`: The implementation of this method is optional. It''s executed when
    the test has finished. You can use it to close or release resources used during
    the test or to check the results of the test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods that implement the test: These methods have the main logic of the test
    you implement. They have to start with the `thread` keyword followed by a string.
    For example, `thread1()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To control the order of execution of threads, you use the `waitForTick()` method.
    This method receives an `integer` type as a parameter and puts the thread that
    is executing the method to sleep until all threads that are running in the test
    are blocked. When they are blocked, the MultithreadedTC library resumes the threads
    that are blocked by a call to the `waitForTick()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The integer you pass as a parameter of the `waitForTick()` method is used to
    control the order of execution. The metronome of the MultithreadedTC library has
    an internal counter. When all the threads are blocked, the library increments
    that counter to the next number specified in the `waitForTick()` calls that are
    blocked.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, when the MultithreadedTC library has to execute a test, first it
    executes the `initialize()` method. Then, it creates a thread per method that
    starts with the `thread` keyword (in your example, the methods `thread1()`, `thread2()`,
    and `thread3()`) and when all the threads have finished their execution, it executes
    the `finish()` method. To execute the test, you have used the `runOnce()` method
    of the `TestFramework` class.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the MultithreadedTC library detects that all the threads of the test are
    blocked, but none of them are blocked in the `waitForTick()` method, the test
    is declared to be in a deadlock state and a `java.lang.IllegalStateException`
    exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Analyzing concurrent code with FindBugs* recipe in [Chapter 8](ch08.html
    "Chapter 8. Testing Concurrent Applications"), *Testing Concurrent Applications***
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
