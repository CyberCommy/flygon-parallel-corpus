- en: Chapter 10. Troubleshooting Network Issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'No network is perfect. Regardless of how well we plan and implement our infrastructure,
    problems can and will happen. The most important skill you will need in order
    to be successful as a network administrator is your ability to troubleshoot issues.
    When problems occur, your ability to think rationally and narrow down the issue
    by the process of elimination will carry you through. While it can certainly be
    stressful when things go haywire, network administrators enjoy the job security.
    In this chapter, we''ll work through troubleshooting some common issues that may
    come up in Linux networks. In the final chapter of our journey, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Tracing routing issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting DHCP issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting DNS issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying connection statistics with netstat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning your network with nmap and Zenmap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing missing firmware on Debian systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting issues with Network Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracing routing issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The entire purpose of a network is to get data from point A to point B. If for
    some reason we aren't able to get data where we need it, it can sometimes be a
    pain to pinpoint exactly where the issue manifests itself. But through the process
    of elimination, pinpointing where routing issues manifest themselves shouldn't
    be too difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever I experience issues with a node being unable to communicate to a specific
    server or network, I like to work my way from their workstation back to the switch
    stack until I find the issue. To start, I check the obvious things, such as what
    the IP address is (or if the machine even has one) and then I also check the routing
    table. If the problem is intermittent, you would likely want to test the cable.
    For some reason, I've come across quite a few instances where a problem resulted
    from a bad cable. I don't know why, but it seems that other administrators I know,
    don't have this luck. But it never hurts to run a cable tester on the network
    cable to check, just in case.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that you've already tried the easy stuff, next you would want to determine
    whether or not you can reach the default gateway. If you know the IP address of
    your local default gateway, simply ping it to see if you can reach it, and note
    the result. Does your attempt time out, or does it get through just fine? If you
    don't know the IP address of your gateway, run `route -n` in your terminal emulator
    to find out. If you can reach your default gateway by IP, try to reach it by hostname
    as well as the IP address of the target node you were trying to connect to in
    the first place. If you're able to reach resources by IP and not their hostname,
    this would most likely be a DNS issue. We'll talk about troubleshooting DNS later
    in this chapter. But for now, determining whether or not you can reach your DNS
    server and/or gateway would be good first steps. If you can't, you may have a
    resource that is down, and a line of angry co-workers waiting for you back at
    your desk.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the problem is intermittent, we can start our troubleshooting by interrogating
    the local machine. The `ip address show` command will give us some details about
    the IP address of the local machine. We can actually shorten this command by abbreviating
    it to `ip addr show`, or if you really don''t like typing, you can simplify it
    down further to just `ip a`. The following shows the output of `ip addr show`
    from an example system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tracing routing issues](img/b03919_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Investigating the IP address on a local machine
  prefs: []
  type: TYPE_NORMAL
- en: At this point in the book, there shouldn't be anything too surprising about
    the output of `ip a`. However, the output from my machine may look unique to what
    you may see in the wild, so it's worth going over. First, you can see that the
    Debian machine I used for testing has five network interfaces on it. The first
    is the local loopback adapter, `lo`; and the second is `eth0`. Since this machine
    is currently using Wi-Fi, it's no surprise that `eth0` doesn't have an IP address.
    The next interface, `wlan0`, has an IP address of `192.168.1.106`. The last two
    interfaces are unique; they exist as bridges for Docker and KVM virtualization
    to be able to perform their own networking. Even though Docker and KVM aren't
    within the scope of this book, I bring up the fact that they do their own networking
    because when one of these services is installed, you may see your Linux desktop
    environment report that you are connected to a network, even when technically
    you aren't. On my machine, if I disconnect `wlan0`, it would still show that I'm
    connected. This is because the GUI version of Network Manager that most graphical
    distributions ship with, does a terrible job of reporting an accurate status in
    regards to your connectivity, and this could confuse the situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you''ve determined that the machine has an IP address, another step
    you can take is to use the `traceroute` command. Those of you that have used Windows,
    may be familiar with this concept already, as the Windows utility `tracert` works
    pretty much the same way. The `traceroute` utility is not always installed by
    default when you set up a Linux distribution, so you may need to install the `traceroute`
    package. From here, you should be able to use `traceroute` along with the hostname
    or IP of a resource, to see where the process drops out. You can also use `traceroute`
    against the URL of a website, if the issue is that your workstation isn''t able
    to access the public Internet. In the following screenshot, a `traceroute` against
    `google.com` is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tracing routing issues](img/b03919_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Running traceroute to troubleshoot accessing the public Internet
  prefs: []
  type: TYPE_NORMAL
- en: In the previous screenshot, I ran a `traceroute` to [www.google.com](http://www.google.com).
    From the output, we can tell several things right away. First, we can see that
    the first `hop` our command tries to reach is a device called `m0n0wall.local`
    at an IP address of `192.168.1.1`. If I run `route -n`, I see that this is the
    default gateway of the network I'm currently using. The `m0n0wall` is a firewall
    distribution of FreeBSD, which is in use on this network. I discovered this when
    I ran the command. Next, we can see that we made it through the `m0n0wall` device
    to another private network of `172.21.0.1` and then `198.111.175.120`, but output
    stops when my request reaches `198.108.22.150`. After that, we just see asterisks,
    but we're not going beyond that. In a hypothetical example of my machine not being
    able to access the Internet, I may want to investigate the device at `198.108.22.150`
    and find out why it's not letting my traffic through. However, in my case this
    device is dropping ICMP packets, which is causing the `traceroute` command itself
    to fail.
  prefs: []
  type: TYPE_NORMAL
- en: One of the things you would definitely want to check when troubleshooting routing
    issues is your routing table. We covered routing in [Chapter 8](ch08.html "Chapter 8. Understanding
    Advanced Networking Concepts"), *Understanding Advanced Networking Concepts*,
    and the routing table as well as adding routes was covered. But as a refresher,
    you can use `route -n` to print the routing table onto your shell. If the machine
    you're troubleshooting doesn't have a route to the network it needs to access,
    then the root-cause is easily apparent. You would then need to add a default gateway
    in order to allow the machine to reach that network.
  prefs: []
  type: TYPE_NORMAL
- en: '![Tracing routing issues](img/b03919_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Viewing the local routing table
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting DHCP issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If for some reason you have a machine that refuses to obtain an IP address,
    then this section is for you. DHCP issues aren't incredibly common, and thankfully
    aren't too hard to troubleshoot.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common issues I've seen with DHCP servers is the date and time
    of either the server or the client being wrong. In the Linux world, NTP is crucial
    and should always be working. In the case of DHCP, it only waits so long before
    the service times out a request for an IP address. If the clock is off by an hour
    and the incoming request is timestamped an hour ago, that confuses the server
    and the client will not receive an address. Always ensure that NTP is working
    on all your clients and servers. DHCP isn't the only service that would suffer
    with incorrect time on either end. Lot's of strange things can happen in this
    situation.
  prefs: []
  type: TYPE_NORMAL
- en: A reason for failure is the lack of available IP addresses. This may sound obvious,
    but you'd be surprised how often this happens. Even a `/24` network of `254` available
    IP addresses can become saturated quickly these days, as everything from mobile
    devices to refrigerators (yes, refrigerators) want to claim an IP address these
    days. It's not uncommon for the average person to use three IP addresses without
    even noticing. A problem such as this can become increasingly annoying if you
    set your DHCP lease time to something greater than a day. In most cases, a lease
    time of 24 hours is adequate for most networks. Devices that need access will
    renew their lease when the time comes, while temporary devices won't attempt to
    renew the IP they were issued, which will cause it return to the pool.
  prefs: []
  type: TYPE_NORMAL
- en: I wish that I had a magic command you could run that would give you a printout
    of just how many IP addresses you have available. Unfortunately, I've never been
    able to find one, aside from possibly constructing a cumbersome Bash or Python
    script. The best thing for you to do while experiencing any issues with DHCP is
    to watch the log file and have the client try to connect again.
  prefs: []
  type: TYPE_NORMAL
- en: '![Troubleshooting DHCP issues](img/b03919_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The output of a working DHCP server
  prefs: []
  type: TYPE_NORMAL
- en: In Debian, you can investigate by running `cat /var/log/syslog |grep dhcp` for
    messages relating to your DHCP server. On CentOS, you can use `journalctl -u dhcpd`
    to view these messages. What's better is to follow these logs in real time as
    the client tries to connect, so you can see the output as it happens. To do this,
    use `tail -f /var/log/syslog` in Debian or `journalctl -f -u dhcpd` in CentOS.
    Errors from your DHCP server should be fairly easy to follow, as the server is
    usually specific regarding what it is doing. You'll likely see it offer addresses
    to the client, or complain that there aren't enough IP addresses available. If
    you see the server offer an IP address to the client but the client never seems
    to finish the connection, then definitely check your NTP server on the client.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting DNS issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DNS issues are typically rare, except in the case of an invalid configuration.
    In most cases, any troubleshooting you do would be done on your local DNS servers,
    as public DNS servers on the Internet are outside of your control. In the case
    of an external DNS server failing, such as that from your ISP, your only recourse
    might be to use a different DNS provider, such as utilizing Google's public DNS
    addresses of `8.8.8.8` and `8.8.4.4`. But in the case of your local DNS server
    failing, you have more control.
  prefs: []
  type: TYPE_NORMAL
- en: As always, you would start troubleshooting DNS issues by checking whether or
    not you can reach the DNS server. First, check `/etc/resolv.conf` to see which
    DNS server your machine is using. Is it the correct server? If not, correct this
    in your network scripts and restart networking. If it is the correct server, can
    you reach it? Try a simple ping, and as long as the server is configured to respond
    to ICMP echo requests, you should see a response. If you can reach the server,
    SSH into it and check its logs. Perhaps the daemon (`bind` in Debian, and `named`
    in CentOS) isn't running.
  prefs: []
  type: TYPE_NORMAL
- en: Moving beyond the simple things, there is a specific utility we can use to help
    troubleshoot bind-specific issues, and that utility is `nslookup`. Use the `nslookup`
    command along with the name of the resource you're trying to find, such as a hostname
    or the URL of a website.
  prefs: []
  type: TYPE_NORMAL
- en: '![Troubleshooting DNS issues](img/b03919_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The output of a working DHCP server
  prefs: []
  type: TYPE_NORMAL
- en: The output of `nslookup` tells us a few useful things we can use to troubleshoot
    further. First, it will give us the IP address of the server that answered our
    request. In my case, `10.10.96.1` answered via port 53\. Then, I can see the result
    of my query for `packtpub.com`, which gave me an external IP address of `83.166.169.231`.
    So far, so good. If your DNS server is reachable, the daemon is running and your
    local workstation is configured to point to it, a very common gotcha is the serial
    number in your domain record. If you've added a resource to your DNS server but
    forgot to increment the serial number, that can cause a lookup to fail even though
    you did add the configuration for that host. This may seem like common knowledge,
    but you'd be surprised how easy it is to forget.
  prefs: []
  type: TYPE_NORMAL
- en: In the event that `nslookup` doesn't return a record, check that you have actually
    added that record to the server. If it does respond with a record, then everything
    should be running smoothly as long as you have configured your local workstation
    to point to the correct server.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying connection statistics with netstat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `netstat` command is a useful utility to allow you to view some statistics
    regarding your current connection. We touched on it a bit in the last chapter.
    This command allows you to show useful networking information, such as showing
    you services that are listening for connections on your network card, and printing
    your routing table, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: In the last chapter, I gave the example of `netstat -tulpn` to allow you to
    view currently connected and listening services. This command shows everything
    that's listening, as well as the port that it's listening on. Breaking this command
    down, we passed along some parameters. The first, `-t`, identifies that we would
    like to view information pertaining to TCP, `-u` represents UDP, `-l` requests
    listening sockets, `-p` attempts to show the name of the program, and `-n` also
    shows numeric values. Putting it all together, we get `netstat -tulpn`. In the
    industry, this is the most common usage of `netstat` that I've seen.
  prefs: []
  type: TYPE_NORMAL
- en: Other uses of `netstat` include showing your routing table (`netstat -r`), which
    gives you similar output as `route -n`. To view connection statistics, use `netstat
    -s`. Finally, you can also view a list of network interfaces on your system with
    `netstat -i`. For the most part though, this command is something you would use
    most often to print networking information to your terminal, that you would use
    for further analysis when trying to troubleshoot an issue or lock down a node.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning your network with Nmap and Zenmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `nmap` utility is a network scanner that can give you a great deal of information
    regarding network resources. All you should have to do is install the `nmap` package.
    Once you have this utility in your arsenal, you can do some pretty neat things
    on your network. In most cases, `nmap` is used to interrogate systems and extract
    information. While `nmap` itself doesn't solve any actual problems, it helps you
    discover information you can use in order to build an understanding of what's
    happening on your network at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: It also needs to be used with great care, as `nmap` is capable of disclosing
    information regarding a network that may be private, and unless you have express
    permission to use it, you should exercise discretion. Since `nmap` can be used
    for purposes of hacking, it's definitely a red flag to a network administrator
    (if that person isn't you) if they see this type of activity on the network. But
    in real-world scenarios, `nmap` can really be a life saver. In my experience,
    I found it quite useful in tracking down and interrogating machines that come
    up as hosting malware on the network, which strangely, always seems to be those
    that run Windows (go figure). If a vulnerability report only shows the IP address
    of an infected machine, it can be hard to track down whose machine it is. But
    with `nmap`, I can find out things such as which OS is running on that host, the
    hostname of the machine (which may even include the name of the user), and possibly
    the MAC address of that machine's network card.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many uses of `nmap`, but I''ll start with some of my favorites. First,
    as I just mentioned, you can use `nmap` to try to determine which operating system
    a particular host is using. This will allow you to fine-tune further commands
    to specifically target the machine, as how you investigate nodes differs based
    on the OS they are running. To use `nmap` to attempt to find this information,
    use it with the `-O` parameter and the IP address of a host. Basically, execute
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful use case for `nmap` is scanning an entire subnet to determine
    which hosts are connected. If you''re attempting to see which IP addresses are
    free, this is one way to do it (assuming no nodes have any firewalls that are
    blocking the scan):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With the previous example, we can also use the `--exclude` option if we prefer
    a particular IP address not be scanned or included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If a machine is behind a firewall, we can attempt to scan it anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As if we didn''t already have enough utilities that can show us routing and
    interface information of our local machine, `nmap` can do that as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In addition to using `nmap` commands in a terminal, there is also Z**enmap**,
    which is more or less a GUI equivalent. Using it, we can do pretty much the same
    things as `nmap`, but in addition it allows you to save your scans, open previously
    saved scans, compare results between two saved scans, and even save command profiles
    for later use. If you find yourself using `nmap` on a usual basis, it may be useful
    for you to benefit from the added features of Zenmap.
  prefs: []
  type: TYPE_NORMAL
- en: '![Scanning your network with Nmap and Zenmap](img/b03919_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Zenmap with a scan of a local network
  prefs: []
  type: TYPE_NORMAL
- en: One easy way to start testing Zenmap is to try it with any of the examples I've
    given in this chapter. You should be able to paste any of those commands in the
    third textbox at the top of the window, which reads **Command**. From here, you
    can click **Scan** to begin the scan. Once it's finished, you can save the results
    by clicking **Scan** and then **Save Scan**. As mentioned earlier, you can also
    compare scans to each other. This can be useful if you're curious which new devices
    were added to your network. You can run a scan of a subnet (using the `nmap -sP
    10.10.98.0/24` example I gave earlier) on one day, and then run the scan again
    the next day. If you saved the results each time, you can compare them and then
    determine immediately if a new device was added to your network. This is a good
    practice to perform periodically anyway (especially if you're the person who is
    designated to approve new devices) to determine if there are any rogue or unauthorized
    devices present.
  prefs: []
  type: TYPE_NORMAL
- en: '![Scanning your network with Nmap and Zenmap](img/b03919_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Comparing network scans in Zenmap
  prefs: []
  type: TYPE_NORMAL
- en: Deciding between using `nmap` and Zenmap is just a matter of preference. The
    features of Zenmap are quite nice, but the only thing it provides is ease of use.
    In `nmap`, for example, you can simply pipe the results into a text file yourself,
    and then you can run the `diff` command against the results of two output files
    without using a GUI application to perform this task.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: On a typical network administrator's desktop, you'd be using either a Linux
    or Windows installation with a graphical user interface; in this case, Zenmap
    may be a good fit to add to your tool set.
  prefs: []
  type: TYPE_NORMAL
- en: Installing missing firmware on Debian systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many distributions of Linux prefer to include only free software and drivers
    by default, and Debian falls into that category. The reason for this can be due
    to moral decisions or licensing restrictions, but the result may be that a specific
    network card or hardware device ceases to function out of the box. Commonly, this
    is very typical with wireless cards. One example of this is Intel wireless cards.
    While these typically work without any tinkering needed when it comes to end-user
    distributions (Ubuntu, Linux Mint, and so on), Enterprise distributions such as
    Debian often don't include these and force you to jump through additional hoops.
    The reason for this is because the software required for these cards to function
    isn't open-source, so the decision was made to not include it in the default repositories.
    Thankfully, this usually isn't too difficult to rectify providing you know the
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Debian systems, there is a non-free parameter that can be added to your
    APT sources that tells the distribution that you would like such packages included
    when you search for and install software. But before you do this, make sure that
    you actually do need additional firmware. One dead giveaway is if Debian complains
    about missing firmware while booting. Without rebooting, you may see errors in
    the logs complaining about a lack of firmware for a hardware device. To view any
    output on your system that may be complaining about missing firmware, try the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To add the non-free component of your APT sources in Debian, first make a backup
    of your original `sources.list` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the non-free parameter to the main repository. On my Debian Jessie
    system, the line looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once that''s done, refresh your sources with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'From this point forward, the non-free binary packages should be available to
    you. You can confirm this by searching for and listing available firmware packages
    on your system. The output should contain several `nonfree` packages. To perform
    this search, try the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For example, if `firmware-linux-nonfree` shows up in your list of available
    packages, then you've performed these steps correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, detailing a full list of hardware compatibility for Debian and
    the required firmware for each would be beyond the scope of this book. However,
    the logs should give you a general idea of what firmware is missing, allowing
    you to search your package database for specific packages. Typically, copying
    a line of output from `dmesg` regarding failure to load firmware and doing a Google
    search will take you right to what package is needed to resolve the situation.
    In my case, the most commonly needed firmware package I run into is `firmware-iwlwifi`.
    Additionally, `firmware-atheros` and `firmware-b43-installer` are also common.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting issues with Network Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Network Manager** is a tool that is used to manage network connections in
    Linux. It consists of a daemon that runs in the background, as well as an optional
    graphical utility that most desktop distributions include to show you your connection
    status at any given time. Network Manager is not required by any means, but it
    simplifies the management of your network interfaces and their configuration.
    In a lot of real-world networks, Network Manager is typically disabled and static
    IP addresses are used instead. As I''ve mentioned probably a hundred times so
    far, I always prefer static leases over static IPs. With a static IP, you do not
    have the central point of management, and would need to track down and change
    a server''s IP address manually. It is for this reason that I recommend you to
    keep Network Manager running. It will watch for connections, activate your DHCP
    client, and then receive an IP address lease from your DHCP server. If you''ve
    set up a static lease (reservation) then you''re already all set to go as soon
    as Network Manager initiates your connection.'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of networking issues that you've troubleshooted to be an issue local
    to Network Manager itself, there are several things you can do in order to pinpoint
    the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, on CentOS systems, ensure that your network interface is configured
    to come up on boot. For some reason I cannot understand, CentOS actually defaults
    to turning your network interface off during installation. Unless you turn it
    on while running the installer, it will also be disabled by default after you
    boot as well. If the interface is not enabled, then Network Manager wouldn''t
    be able to manage it. Correcting this is simply a matter of editing the init script
    for the interface. You''ll find init scripts for your network interface cards
    in CentOS at the following location: `/etc/sysconfig/network-scripts`. On my system,
    I find the `init` script for my interface card at `/etc/sysconfig/network-scripts/ifcfg-enp0s3`,
    though the name of your interface will of course differ.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the last line, where you should see `ONBOOT="yes"`. If you don''t see
    that, modify that line and then restart networking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, on Debian and CentOS systems, check to make sure that Network Manager
    is running. This is one of those rare occasions where the command to do something
    is the same in both distributions. With the following command, we can check the
    status of the NetworkManager daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: While troubleshooting issues, `systemctl` can be very useful as it not only
    tells you whether or not the service is started, it also gives you a handful of
    lines from the logs that may be able to point you in the right direction if you're
    experiencing an issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'To peruse Network Manager logs in their entirety, you can use `journalctl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the `-f` flag to follow the log, so you'll see new entries
    as they happen. This is especially useful while troubleshooting why a machine
    isn't able to connect to a wireless network. Errors will appear as the user attempts
    to connect. The following example shows how to follow the output of NetworkManager
    output that gets written to the journal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As with most systemd units, we can restart Network Manager with one simple
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The previous command may seem like a no-brainer, but for some reason, I've had
    to restart Network Manager more times than I would like. This is especially true
    while switching a machine from one network to another, or resuming from suspend
    (though those issues primarily only come up on end-user workstations).
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, issues with Network Manager are rare and troubleshooting
    it is relatively straightforward. Using systemd's `journalctl`, we can watch Network
    Manager's output and determine the root cause. In most cases, the issue will come
    down to a misconfigured network card.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered some ways of troubleshooting issues that may come
    up on our Linux-based networks. While it's impossible to detail every possible
    thing that can go wrong, this chapter serves as a starting point for common issues
    that you might face. We started off by looking at routing issues as well as DHCP
    and DNS troubleshooting. In addition, we looked at useful troubleshooting tools
    such as `nmap`, as well as an overview of installing missing firmware that may
    be required to set up network cards in Debian. We closed off with information
    pertaining to troubleshooting Network Manager.
  prefs: []
  type: TYPE_NORMAL
- en: With this, this book comes to a close. Thank you for taking this journey through
    the world of Linux network administration with me. I hope that book has resonated
    with you and helped you get a better understanding. Working with Linux has been
    the single best career choice I have made, and I would like to thank all of my
    readers and colleagues for making it such a wonderful experience. To all of you,
    I wish for you, success, and it is my hope that your journey through Linux be
    as beneficial to you as it has been for me.
  prefs: []
  type: TYPE_NORMAL
