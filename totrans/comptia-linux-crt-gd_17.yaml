- en: Performing Administrative Security Tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we covered IPv4, IPv6, the client-side DNS, and network
    troubleshooting. We worked with IPv4 and discussed IPv4 routing, and then, we
    did the same for IPv6\. This lead into the client-side DNS and network troubleshooting;
    we covered a number of command-line tools that assist in troubleshooting potential
    network connectivity issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on security: host security, SSH, and encryption.
    First, we will cover host security; the `/etc/sudoers`, `/etc/hosts.allow`, and
    `/etc/.hosts.deny` files will be our main focus. Next, we will work with SSH.
    We will focus on the steps involved in setting up SSH, and the steps for generating
    a key. We will also look at logging in to a remote system using SSH. Additionally,
    we will work with the various SSH files that are available to us. Encryption will
    be our next focal point; we will look at ways to encrypt and decrypt files. This
    will be an important chapter, in terms of securing a Linux system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Host security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Host security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Linux, we can perform a range of security tasks to safeguard our system.
    Up to this point in the book, we''ve been performing most of our administrative
    tasks as the root user. Can we perform some of these tasks as a regular user,
    instead? Well, we can use a regular user account and give it certain root privileges,
    without having to actually log in as the root user. This is made possible with
    the `/etc/sudoers` file. We''ll work with the Fedora 28 system in this demo. If
    we try to view the boot files inside of `/boot/grub2/`, we will be presented with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the preceding information, the user does not have sufficient permission
    to view the contents of `/boot/grub2`; we have received a `Permission denied`
    message. Adding to this, if we try to make a change (such as adding an IP address),
    we will be presented with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Based on the preceding information, we will execute the first command—the `IP`
    command, with the `a` and `s` options (`a` for address, `s` for show)—but when
    we attempt to add an IP address, we get an `Operation not permitted` message.
    The message will vary, depending on whether you're trying to view, as this is
    a case with the `ls` command, as opposed to making a change in the latter demo.
  prefs: []
  type: TYPE_NORMAL
- en: The su command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One technique to work around the standard user permission problem is to use
    the `su` command; the `su` means **substitute user**. The basic syntax of the
    `su` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the preceding command, we can also use the `su` command without using
    any options, as seen in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! When we use the `su` command without any options, it prompts us for
    the root password, and then logs us in as the root user. However, this might not
    be ideal, due to security concerns. A better approach would be for us to execute
    a command, but not stay signed in as the root user; this can be accomplished by
    passing the `-l` option, which expects the user account''s name, and the `-c`
    option, which expects the command. The following command shows how we can use
    the `su` command to effectively display the contents of the `/boot/grub2/` directory,
    and, at the same time, stay logged in as the standard user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! The contents of the `/boot/grub2/` directory will now be displayed.
    However, the contents will be displayed without any color (other than white);
    we can pass the `--color` option to instruct the `ls` command to display the colors,
    just like if we were logged in as the root user. This is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00164.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Awesome! We can see the difference when we omit the `--color` option, as opposed
    to including it with the `ls` command. Also, when the command has spaces between,
    we have to enclose the entire command with a single quote (`''`). Another useful
    option is the `-s` option; this tells the `su` command to use the specified shell
    provided by the user, as indicated by the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00165.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Wonderful! When we used the `-s` option and specified the shell (in our case,
    `/usr/sbin/sh`), we did not to specify the `--color` option with the `ls` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to use the `su` command is to pass the `-` option, which implies
    the root user, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect! The contents are displayed, and we did not specify the login `root`.
    We can see a list of shells that are available by looking inside of the `/etc/shells`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! We can see the various shells that can be used with the `-s` option
    of the `su` command. So far, we''ve only viewed content with the `su` command,
    but we can also make changes with it. The following command shows how we can make
    a change using the `su` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! The IP address was added successfully.
  prefs: []
  type: TYPE_NORMAL
- en: A major drawback of using the `su` command is that every user has to know the
    root password in order to execute it.
  prefs: []
  type: TYPE_NORMAL
- en: The sudo command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `sudo` command solves the dilemma of standard users needing the root password,
    as long as the user''s account resides in the `/etc/sudoers` configuration file.
    The basic syntax of the `sudo` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Along with the preceding command, we simply specify the command that we would
    like to execute, which would normally require root privileges. Let''s try the
    `sudo` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! When we executed the `sudo` command and passed the command that
    required root privileges, we were prompted for the password of the standard user,
    not the root user. Afterwards, we can pass another command with the `sudo` command,
    and we won''t be prompted for our password, as you can see in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! The command executed successfully, without requiring the user''s password.
    This is possible because there is a timeout setting that saves the user''s password;
    after the time has elapsed, we will be prompted to enter the user''s password
    again. However, this does not hold true in the event that the user opens another
    Terminal, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00166.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Awesome! We can see that the timeout value does not affect a new Terminal, because
    the user was prompted to enter their password.
  prefs: []
  type: TYPE_NORMAL
- en: 'There may be times when we prefer to increase the timeout value, especially
    when we''re going to be working for a long period of time. Rest assured; we can
    increase the timeout value by searching for `env_reset` inside of the `/etc/sudoers`
    file and appending the `timestamp_timeout` option alongside it. The contents of
    the `/etc/sudoers` file are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, some output has been omitted for brevity. There are
    a number of options that we can change. For instance, to increase the timeout
    value, we can edit `/etc/sudoers` using the visudo editor; it is highly recommended
    to not use any editor other than visudo, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! We''ve added `timestamp_timeout=60`; this tells `sudo` to save the
    user''s password for 60 minutes. Another useful option to set is to see the output
    as we type the user''s password; it is possible to display asterisks (`*`) for
    each key typed by the user. This is made possible by appending the `pwfeedback`
    option alongside the `env_reset` option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the preceding command, when the user first tries to use the `sudo`
    command, the password will be represented with asterisks, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! We can now see asterisks that represent the typed password.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we add a new user, the new user will not automatically be added to the
    `/etc/sudoers` file. We have to add the user manually, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can switch users, either by logging out and back in on the computer,
    or by using the `su` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve successfully logged in as the new user; now, when we try to issue the
    `sudo` command, the results will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re given a notification message, but when we enter the new user''s password,
    we get the dreaded `teddy is not in the sudoers file` message, along with, `This
    incident will be reported`. This basically tells us that we have to add the new
    user to the `/etc/sudoer` file. This can be done in a number of ways; one way,
    which may be the simplest, is to add the new user to the `wheel` group. The `wheel`
    group can execute all of the commands, as can be seen in the `/etc/sudoer` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `wheel` group exists, with full access; we can use the
    `usermod` command and pass the `-a` and `-G` options (`a` for appends, `G` for
    group), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need root privileges to modify another user''s properties; we can use
    the `sudo` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! The new user is now capable of using the `sudo` command. Let''s
    examine the syntax for adding an entry inside of `/etc/sudoer`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define an entry for one particular user or group (we have to put a `%`
    in front of a group''s name); we can then specify which system we want the entry
    for, which user we want to allow to execute the commands, and, finally, the actual
    commands. Let''s give this a try; we will remove the `wheel` group from the new
    user and create an entry for the new user, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Wonderful! We''ve restricted the new user to executing only the `ls` and `cat`
    commands; this can be proven as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! The new user can only use the `ls` command with root privileges,
    and is unable to make any other changes with the `sudo` command. Additionally,
    we can grant the new user the ability to execute as many commands as we specify,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! We added the `cat` command for the new user, making it possible for
    the new user to execute the `cat` command with root privileges. The thing to remember,
    when placing multiple commands alongside each other, is that you have to place
    tabs by pressing the *Tab* key between the commands. Another option that we can
    use with the `sudo` command is the `-l` option; this lists the privileges of the
    current user, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the user `philip` can run all of the commands with the `sudo`
    command. However, if we run the `sudo` command with `-l` for the other user, `teddy`,
    we will see that user''s access, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! We can only see two commands that `teddy` can execute with root privileges.
    It is also possible to pass the username with the `-u` option and specify which
    command to be executed with `sudo`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! Another useful option is `-v`, which resets the authentication timeout
    for the user, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, it is possible to kill the authentication session immediately by
    passing the `-k` option with `sudo`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! In the preceding code, the user had to provide their password when
    they attempted to execute the `sudo` command with the `-k` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we''ve been providing the user''s password the first time we execute
    `sudo`; it is possible to run `sudo` without entering a password. We add the `NOPASSWD`
    option in the entry that we added for the new user, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Wonderful! Whenever the user `teddy` tries to execute the `sudo` command, they
    will no longer be prompted for their password.
  prefs: []
  type: TYPE_NORMAL
- en: TCP wrappers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can add another layer of security within a Linux system by using TCP wrappers.
    **TCP wrappers** filter traffic as it enters the system. The TCP wrappers check
    the traffic against two files: `/etc/hosts.allow` and `/etc/hosts.deny`. The rules
    are applied with a top-down approach, meaning that the first rule is always applied
    before all other rules. We can view the contents of `/etc/hosts.allow` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The file only contains comments that start with `#`. The basic syntax for creating
    a rule is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add a rule using a text editor, such as vi or nano, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding command, we added a rule for the `vsftpd`; this is a secure
    version of FTP. We then specified the client list—the subnet `172.16.175.`. The
    `.` means that any IP addresses within that subnet will be able to access the
    `vsftpd`. Another way to define the rule is to specify a domain, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! Anyone from within `.packtpub.com` will be able to access the `vsftpd`
    on the local system. Adding to this, we can use the keyword `ALL` inside a rule;
    this matches everything, and it can be placed at the daemon or in the client list
    section, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! Everyone can access the Telnet Service on the local system. It is
    also possible to execute another command, by passing the `spawn` option. This
    is useful when we want to log who is attempting to access a given service on the
    local system. We use the `spawn` option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! The `spawn` option creates a message containing the current date
    (`/bin/date`), which is then appended with the hostname (`%h`) of the system attempting
    to access the `vsftpd`; this then gets appended inside of `/var/log/vsftp.log`.
    We can then take a look at the `/etc/hosts.deny` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding command, `/etc/hosts.deny` only contains comments (`#`). It
    is recommended to deny everything in this file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! We've specified `ALL:ALL:`, to deny everything except the rules that
    are listed in `/etc/hosts.allow`.
  prefs: []
  type: TYPE_NORMAL
- en: SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We mainly use SSH for the purpose of securely logging in to a remote system.
    Most Linux distributions come with the SSH package, by default. In order to verify
    whether SSH is currently running, we use the `systemctl` command; we pass the
    `status` option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00167.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The SSH daemon `ssh.service` is currently running (particularly, the Secure
    Shell server). Another method that we can use to verify that the SSH service is
    running is the `netstat` command; we pass the `ntlp` options (`n` for display
    port numbers, `t` for TCP protocol, `l` for currently listening, and `p` for program
    ID/program name), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the SSH server daemon is currently running on TCP port `22`.
    The basic syntax for establishing a connection to a remote system is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can simply run the `ssh` command and pass only the remote system; we will
    use the `ssh` command from the Fedora 28 system and try to connect to the Ubuntu
    18 system, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding command, some output has been omitted for brevity. If you specify
    the command without any options, the SSH program used the current user, `philip`,
    and a fingerprint identifying the server was presented. This added the user `philip`
    to `~/.ssh/known_hosts` in the Fedora 28 system. We can take a look at the file,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! We have Ubuntu''s system information inside of `~/.ssh/known_hosts`
    for the user `philip` on the Fedora 28 system. It is also possible to use a different
    username with the `ssh` command; we specify the `-l` option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We were able to log in using a different user, via SSH. Also, notice that we
    were presented with the earlier message identifying the server''s fingerprint.
    This is because the information was previously stored in `~/.ssh/known_hosts`.
    If we were to remove the contents using a text editor, such as vi or nano, we
    would be presented with the identity message again, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! We removed the contents, and we were once again presented with the
    identity message.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we''ve been prompted to enter a password every time that we''ve attempted
    to start an SSH session. However, it is possible to bypass the password prompt
    and log in to the system without any hindrance. We use SSH keys to authenticate;
    this is known as **key-based authentication**. Key-based authentication involves
    the creation of a pair of keys: a private key and a public key. The private key
    is stored on the client''s system, and the public key is stored on the destination
    system(s). Particularly, we generate an SSH key using the `ssh-keygen` command
    on the destination system. Next, we copy over the client system; we use the `ssh-copy-id`
    command to copy the keys. When you first connect using key-based authentication,
    the servers transmit a message, using the public key, over to the client''s system,
    which can then be interpreted using the private key, which resides on the client''s
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s generate the SSH keys using the `ssh-keygen` command on the client system
    from where we need to log in; it will be the Fedora 28 system, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the algorithm is `rsa`, and the location to store the key pair
    is inside of the current user''s home directory (`~/.ssh/id_rsa`). We accept the
    defaults and press *Enter*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to specify a `passphrase`; we will use a super secret `passphrase`,
    and then press *Enter*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! The key was generated using a 2,048-bit key size. Now, we can run
    the `ls` command on the user''s home directory and look inside of `~/.ssh`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Wonderful! Apart from the `known_hosts` file, which we covered earlier, we
    now have two additional files: `id_rsa` (this is the private key) and `id_rsa.pub` (this
    is the public key). We can look at the contents by using the `cat` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! The next step is to copy the public key from the client''s system
    to the destination server, using the `ssh-copy id` command; in our case, the server
    is the Ubuntu system. Before we run the `ssh-copy-id` command, let''s check the
    `~/.ssh` directory on the Ubuntu system, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `~/.ssh` is currently empty. Now, let''s execute the `ssh-copy-id`
    command on the client system, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! The public key `~/.ssh/id_rsa.pub` was securely transferred to the
    server''s system. Now, let''s check the `~/.ssh` directory on the Ubuntu system
    again, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! We now have an `authorized_keys` file, located in the `~/.ssh` directory.
    We can use the `cat` command to verify that the public key is indeed the same
    as the public key on the client''s system, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! The last step is to run the `ssh` command on the client system (Fedora
    28) and verify that we are able to log in to the server (Ubuntu 18) without using
    a password, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! We started the `ssh agent`, which created the necessary variables
    and started the process. Next, we will run the `ssh-add` command with the `-l`
    option; this will list all of the identities that the `ssh agent` is aware of,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding command, there are no identities known by the
    agent; we will now add the identity that we created earlier, by using the `ssh-add`
    command without any options, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Wonderful! You can now see the identity for the private key that we generated
    earlier. Now, we will try to initiate an SSH session, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! We successfully logged in, without having to enter the user''s password
    or the `passphrase`. The SSH configuration is stored in `/etc/ssh/ssh_config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, some output has been omitted for brevity. All of the
    settings are using their defaults.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another location where the `known_hosts` are kept is `/etc/ssh/known_hosts`;
    this allows administrators to add the identities of all servers inside of a LAN.
    This method prevents the identity message from appearing every time a new user
    attempts to initiate an SSH session to a server. We can copy the contents of `~./ssh/known_hosts` to
    `/etc/ssh/known_hosts`, and, if we try to log in as another user, we won''t see
    the identity message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Excellent. Neither of the users were presented with the identity message. Note
    that they were prompted for their respective passwords, because we only set up
    the key-based authentication for the `philip` user; we have to generate the keys
    for each of the users.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today's environment, it's critical to safeguard our data. We can use various
    methods of encryption; in our environment, we will use the **GNU Privacy Guard**
    (**GnuPG**, or **GPG**) for encrypting and decrypting our files and folders. We
    will use the `gpg` command when working with encryption and decryption.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will encrypt a file using the most basic form, **symmetric encryption**;
    this uses a password. The following command shows how we can perform symmetric
    encryption using the `gpg` command, with either the `-c` or `--symmetric` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to enter a password/passphrase, then reenter it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! A new file was created, with a `.gpg` extension; this is the encrypted
    file. We can try to view the contents by using the `cat` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00168.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The content is encrypted, and we can now remove the original content and leave
    the encrypted content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, only the encrypted file remains. We can decrypt this file by passing the
    `-d` option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We must provide the passphrase in order to decrypt the file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! The contents of the file are displayed, but, as we can see, when
    we ran the `ls` command, we still only had the encrypted file, and no new file
    was generated. Rest assured; we can pass the `-o` option to save the output to
    a file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! Now, we have both the encrypted and the unencrypted file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also encrypt and decrypt is by using private/public key pairs. First,
    we have to generate the key pairs by using `gpg` with the `--gen-key` option,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to choose the type of key, `RSA and RSA` being the default; we will
    accept the default, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have to specify the size of the key, the default being `2048`; we will
    choose `4096`, because a longer key is much more secure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have to specify when the key will expire, the default being `0`, which
    means that it will never expire. We will choose `1y`, which means that it will
    expire in one year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to confirm the expiration date and specify the `Real Name`; we
    will fill in the information as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have to confirm by typing `O`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have to protect our secret keys, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! We have successfully generated our key pairs; we can verify this
    by passing the `--list-keys` option with the `gpg` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Wonderful! As you can see, our public key information is in `/home/philip/.gnupg/pubring.gpg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now see our public key information. Next, we will check for our private
    key information; we will pass the `--list-secret-keys` option with the `gpg` command,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! We can see information pertaining to the private key; namely, that
    the private key is in `/home/philip/.gnupg/secring.gpg`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! We can now encrypt by using the public key that we just created, passing
    the `-r` option with the `gpg` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We did not specify a user ID with the command, so we were prompted to specify
    the user ID; we then pressed *Enter* to move to the second line, `Enter the user
    ID`. End with an empty line: `""`, we simply pressed *Enter* to generate an empty
    line. Following this, we have to confirm whether we want to overwrite the file
    that was encrypted earlier, when we performed symmetric encryption. We can also
    specify the `user ID` with the `-r` option. Let''s give this a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! We weren''t prompted to enter the `user ID`, because we specified
    it using the `-r` option. In order to decrypt the file, we pass the `-d` option,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we ran into the same problem that we did during symmetric
    decryption; the displayed content is not being saved. We can solve this quickly
    by passing the `-o` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! The file was decrypted successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to edit a key; we pass the `--edit-key` option with the
    `gpg` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding command, we can make a number of changes. For instance, if
    we want to disable the key, we can type `disable`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding command, we changed the key says `*** This key has been disabled`;
    let''s see the effect of this by saving and exiting, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'When we try to use the key to encrypt the file, we are given an error. We can
    fix this quickly by changing the `disable` to `enable` inside of the `gpg` console,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Excellent!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a wide array of security features that are available
    to us in the Linux environment. First, we covered accessing commands with root
    privileges; particularly, we looked at the `su` and `sudo` commands. We then moved
    on to TCP wrappers, focusing on the `/etc/hosts.allow` and `/etc/hosts.deny` files.
    We looked at how the two files can complement each other, by allowing access via
    the `/etc/hosts.allow` file and denying everything in the `/etc/hosts.deny` file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we covered SSH; we looked at setting up SSH access between a client and
    a server, allowing for a seamless login without entering a password, and we covered
    using a passphrase. We then cached the passphrase, so that the user would not
    have to enter a passphrase when logging in to the server. Finally, we covered
    encryption in depth. We focused on symmetric encryption, which involves a passphrase;
    we then took it up a notch by working with key pairs in encryption. We finished
    by looking at how we can edit properties of the key.
  prefs: []
  type: TYPE_NORMAL
- en: In the next (and final) chapter, we will finish the book by focusing on shell
    scripting and SQL data management. It is crucial to understand some shell scripting
    and SQL management skills while working in a Linux environment.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the following commands can launch another command each time a rule
    is activated in `/etc/hosts.allow`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. ALL
  prefs: []
  type: TYPE_NORMAL
- en: B. deny
  prefs: []
  type: TYPE_NORMAL
- en: C. spawn
  prefs: []
  type: TYPE_NORMAL
- en: D. log
  prefs: []
  type: TYPE_NORMAL
- en: What does `su` stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Superuser
  prefs: []
  type: TYPE_NORMAL
- en: B. Substitute user
  prefs: []
  type: TYPE_NORMAL
- en: C. Switch user
  prefs: []
  type: TYPE_NORMAL
- en: D. None of the above
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following users' password is requested when we use the `su` command
    without any options?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Root user
  prefs: []
  type: TYPE_NORMAL
- en: B. Current user
  prefs: []
  type: TYPE_NORMAL
- en: C. SSH passphrase
  prefs: []
  type: TYPE_NORMAL
- en: D. None of the above
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following options allows for a command to be executed without logging
    in, using the `su` command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `-a`
  prefs: []
  type: TYPE_NORMAL
- en: B. `-c`
  prefs: []
  type: TYPE_NORMAL
- en: C. `-d`
  prefs: []
  type: TYPE_NORMAL
- en: D. `-l`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following symbols has to be in front of a group when being declared
    in `/etc/sudoers`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `-`
  prefs: []
  type: TYPE_NORMAL
- en: B. `^`
  prefs: []
  type: TYPE_NORMAL
- en: C. `-$`
  prefs: []
  type: TYPE_NORMAL
- en: D. `%`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following commands is used to create an SSH key pair?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `ssh-keygen`
  prefs: []
  type: TYPE_NORMAL
- en: B. `ssh-key-gen`
  prefs: []
  type: TYPE_NORMAL
- en: C. `ssh-create-key`
  prefs: []
  type: TYPE_NORMAL
- en: D. `ssh-key`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following commands is used to add an identity to the SSH agent?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `ssh-add`
  prefs: []
  type: TYPE_NORMAL
- en: B. `ssh-agent`
  prefs: []
  type: TYPE_NORMAL
- en: C. `ssh.service`
  prefs: []
  type: TYPE_NORMAL
- en: D. `ssh-daemon`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following commands copies over the SSH public key securely?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `ssh-copy`
  prefs: []
  type: TYPE_NORMAL
- en: B. `ssh-copy-id`
  prefs: []
  type: TYPE_NORMAL
- en: C. `ssh-cp`
  prefs: []
  type: TYPE_NORMAL
- en: D. `ssh-id-copy`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following options is used to encrypt a file with the `gpg` command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `-d`
  prefs: []
  type: TYPE_NORMAL
- en: B. `-e`
  prefs: []
  type: TYPE_NORMAL
- en: C. `-r`
  prefs: []
  type: TYPE_NORMAL
- en: D. `-a`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following options is used to provide the identity with the `gpg`
    command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `-f`
  prefs: []
  type: TYPE_NORMAL
- en: B. `-e`
  prefs: []
  type: TYPE_NORMAL
- en: C. `-r`
  prefs: []
  type: TYPE_NORMAL
- en: D. `-a`
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following site provides useful information about `sudo`: [https://www.computerhope.com/unix/sudo.htm](https://www.computerhope.com/unix/sudo.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following site provides useful information about SSH: [https://www.ssh.com](https://www.ssh.com)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following site provides useful information about encryption: [http://linuxaria.com](http://linuxaria.com)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
