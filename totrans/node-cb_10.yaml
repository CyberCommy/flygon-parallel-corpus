- en: Chapter 10. Taking It Live
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to a server environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic crash recovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hosting with a Platform as a Service provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node is an excellent platform of choice for constructing and providing online
    services. Whether it's a simple, lean website, a highly versatile web app, or
    services that transcend beyond HTTP, at some point we must deploy our creations.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focuses on what it takes to bring our Node apps live.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to a server environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Virtual Private Servers (VPS), Dedicated Servers, or Infrastructure as a Service
    (IaaS for example, the likes of Amazon EC2 or Rackspace) and owning our own server
    machines all have one thing in common: total control over the server environment.'
  prefs: []
  type: TYPE_NORMAL
- en: However, with great power comes great responsibility, and there are a few challenges
    we need to be aware of. This recipe will demonstrate how to overcome these challenges
    as we safely initialize a Node web app on port `80`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will, of course, need a remote server environment (or our own setup). It's
    important to research the best package for our needs.
  prefs: []
  type: TYPE_NORMAL
- en: Dedicated Servers can be expensive. The hardware to software ratio is one to
    one, we're literally renting a machine.
  prefs: []
  type: TYPE_NORMAL
- en: VPS can be cheaper since they share the resources of a single machine (or cluster),
    so we're only renting out the resources it takes to host an instance of an operating
    system. However, if we begin to use resources beyond those assigned, we could
    hit penalties (downtime, excessive charges) since over usage can affect other
    VPS users.
  prefs: []
  type: TYPE_NORMAL
- en: IaaS can be relatively cheap, particularly when up-scaling is involved (when
    we need more resources), though IaaS tends to contain a pay-as-you-go element
    to its pricing which means the costs aren't fixed and could require extra monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Our recipe assumes the usage of a Unix/Linux server with the `sshd` (SSH Service)
    running. Furthermore, we should have a domain pointed at our server. In this recipe,
    we'll assume the domain name as `nodecookbook.com`. Finally, we must have Node
    installed on our remote server. If difficulties arise, we can use the instructions
    available at [https://www.github.com/joyent/node/wiki/Installation](https://www.github.com/joyent/node/wiki/Installation),
    or for installing via a package manager we can use the instructions at [https://www.github.com/joyent/node/wiki/Installing-Node.js-via-package-manager](https://www.github.com/joyent/node/wiki/Installing-Node.js-via-package-manager).
  prefs: []
  type: TYPE_NORMAL
- en: We'll be deploying the `login` app from the second-to-last recipe of[Chapter
    6](ch06.html "Chapter 6. Accelerating Development with Express"), *Accelerating
    Development with Express*, so we need this at hand.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To ready our app for transfer to the remote server, we''ll remove the `node_modules`
    folder (we can rebuild it on the server):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we compress the `login` directory by executing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will generate a compressed archive named after the app's name and version
    as given in the `package.json` file, which will generate the filename `application-name-0.0.1.tgz`
    for an untouched Express generated `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever `npm pack` called it, let's rename it to `login.tgz:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we upload `login.tgz` to our server. For example, we could use SFTP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once logged in to the via SFTP, we can issue the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It's not necessary to upload to the `/var/www` directory, it's just a natural
    place to put a website.
  prefs: []
  type: TYPE_NORMAL
- en: This assumes that we have SFTPed into our server from the directory holding
    `login.tgz`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we SSH into the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we''re using a Windows desktop, we could SFTP and SSH into our server using
    putty: [http://www.chiark.greenend.org.uk/~sgtatham/putty/](http://www.chiark.greenend.org.uk/~sgtatham/putty/).'
  prefs: []
  type: TYPE_NORMAL
- en: Once logged in to the remote server, we navigate to `/var/www` and decompress
    `login.tar.gz:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As `login.tar.gz` decompresses, it recreates our `login` folder on the server.
  prefs: []
  type: TYPE_NORMAL
- en: To rebuild the `node_modules` folder, we enter the `login` folder and use `npm`
    to regenerate the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Most servers have a shell-based editor, such as `nano, vim`, or `emacs`. We
    can use one of these editors to change one line in `app.js` (or otherwise SFTP
    over a modified `app.js):`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We're now listening on the standard HTTP port, meaning we can access our app
    without suffixing a port number to its web address. However, since we'll be starting
    the app as `root` (necessary in order to bind to port `80)`, we also pass a callback
    to the `listen` method which changes access privileges of the app from `root`
    to `www-data`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, dependent upon file permissions, reading or writing to files
    from our app may no longer work. We can fix this by changing ownership:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can start our app with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can ensure that our app is running as `www-data` with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We modified `app.listen` to bind to port `80` and added a callback function
    that resets the user ID from `root` to `www-data`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a callback to `listen` isn't limited to Express, it works the same way
    with a plain `httpServer` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Running a web server as `root` is bad practice. If our app was compromised by
    an attacker, they would have `root` access to our system via our app's privileged
    status.
  prefs: []
  type: TYPE_NORMAL
- en: To demote our app, we call `process.setuid` and pass in `www-data. process.setuid`.
    This takes either the name of a user, or the user's UID. By passing in a name,
    we cause `process.setuid` to block the event loop (essentially freezing operations)
    while it cross-references the user string to its UID. This eliminates the potential
    sliver of time where the app is bound to port `80` and also running as `root`.
    In essence, passing a string to `process.setuid` instead of the underlying UID
    means nothing can happen until the app is no longer `root`.
  prefs: []
  type: TYPE_NORMAL
- en: We call our process with `nohup` and follow up with the ampersand (&). This
    means we freely end our SSH session without causing our app to terminate along
    with the session.
  prefs: []
  type: TYPE_NORMAL
- en: The ampersand turns our process into a background task, so we can do other things
    (like `exit)` while it runs. `nohup` means ignore the hangup signal (HUP). HUP
    is sent to any running processes initiated via SSH whenever the SSH session is
    terminated. Essentially, using `nohup` allows our web app to outlive the SSH session.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are other ways to start our app independent from our session, and to bind
    to port `80` without running the app as `root`. Plus, we can also run multiple
    apps and proxy them to port `80` with `http-proxy`.
  prefs: []
  type: TYPE_NORMAL
- en: Using screen instead of nohup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An alternative to using `nohup` to achieve independence from our SSH session
    is `screen`. We would use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This would give us a virtual terminal, from which we could say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we could leave the virtual terminal by pressing `Ctrl + A` followed by
    `D`. We would return to our initial terminal. The virtual terminal would continue
    to run after we had logged out of SSH. We could also log back in to SSH at any
    time and say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Where we would be able to see any console output and stop `(Ctrl + C)` and start
    the app.
  prefs: []
  type: TYPE_NORMAL
- en: Using authbind for privileged ports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this example, we should SSH into our server as a non-root user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative way to bind to port `80` is with `authbind`, which can be installed
    via our server''s package manager. For instance, if our package manager is `apt-get`
    we could say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`authbind` works by preempting the operating system policies on port binding
    and exploiting an environment variable called `LD_PRELOAD` upon execution. Therefore,
    it never needs to be run with `root` privileges.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get it working for us we have to perform some simple configuration work
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This tells `authbind` to allow the user `dave` to bind processes to port `80`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We no longer need to change the process UID, so we edit the penultimate line
    of `app.js` to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We should also change ownership of the `login` folder as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can start our server without touching the `root` access at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`authbind` can cause our app to work out of the box, no modifications necessary.
    However, it currently lacks IPv6 support so it''s not yet future-proof.'
  prefs: []
  type: TYPE_NORMAL
- en: Hosting multiple processes from port 80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What about serving multiple processes with the default HTTP port?
  prefs: []
  type: TYPE_NORMAL
- en: We can achieve this with the third-party `http-proxy` module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let's say we have two apps one (our `login` app) to be hosted at `login.nodecookbook.com`
    and the other (the `server.js` file from the very first recipe of this book) to
    be simply at `nodecookbook.com`. Both domains point to the same IP.
  prefs: []
  type: TYPE_NORMAL
- en: '`server.js` will be listening on port `8080`, and we''ll modify `login/app.js`
    to listen again to port `3000` as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We also added a second argument defining what address to bind to (rather than
    any address). This prevents our server from being accessed by port.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a file in a new folder, call it `proxy.js`, and write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The object passed to `createServer` contains a router property, which in turn
    is an object instructing `http-proxy` to route incoming traffic on a particular
    domain to the correct locally-hosted process according to its port.
  prefs: []
  type: TYPE_NORMAL
- en: We finish off by binding to port `80` and degrading from `root` to `www-data`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To initialize, we must do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Since we're binding our proxy server to port `80`, these commands must be run
    as `root`. If we're operating SSH with a non-root account, we simply prefix these
    three commands with `sudo`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Automatic crash recovery* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Continuous deployment* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hosting with a Platform as a Service provider* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic crash recovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create a site, server and site logic is all tied up in one process.
    Whereas with other platforms, the server code is already in place. If our site
    code has bugs, the server is very unlikely to crash, and thus in many cases the
    site can stay active even if one part of it is broken.
  prefs: []
  type: TYPE_NORMAL
- en: With a Node-based website, a small bug can crash the entire process, and this
    bug may only be triggered once in a blue moon.
  prefs: []
  type: TYPE_NORMAL
- en: As a hypothetical example, the bug could be related to character encoding on
    POST requests. When someone like Felix Geisendörfer completes and submits a form,
    suddenly our entire server crashes because it can't handle umlauts.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll look at using Upstart, an event-driven init service available
    for Linux servers, which isn't based upon Node, but is nevertheless a very handy
    accomplice.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will need Upstart installed on our server. [http://upstart.ubuntu.com](http://upstart.ubuntu.com)
    contains instructions on how to download and install. If we're already using an
    Ubuntu or Fedora remote server then Upstart will already be integrated.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s make a new server that purposefully crashes when we access it via HTTP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: After the first page loads, the server will crash and the site goes offline.
  prefs: []
  type: TYPE_NORMAL
- en: Let's call this code `server.js` placing it on our remote server under `/var/www/crashingserver`
  prefs: []
  type: TYPE_NORMAL
- en: Now we create our Upstart configuration file, saving it on our server as `/etc/init/crashingserver.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we initialize our server as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When we access `http://nodecookbook.com:8080` and refresh the page, our site
    is still accessible. A quick look at `/var/log/crashingserver.log` reveals that
    the server did indeed crash. We could also check our inbox to find the server
    restart notification.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The name of the Upstart service is taken from the particular Upstart configuration
    filename. We initiate the `/etc/init/crashingserver.conf` Upstart service with
    `start crashingserver`.
  prefs: []
  type: TYPE_NORMAL
- en: The first line of the configuration ensures our web server automatically recovers
    even when the operating system on our remote server is restarted (for example,
    due to a power failure or required reboot, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: '`respawn` is declared twice, once to turn on respawning and then to set a `respawn
    limit — a` maximum of 100 restarts every 5 seconds. The limit must be set according
    to our own scenario. If the website is low traffic this number might be adjusted
    to say 10 restarts in 8 seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: We want to stay alive if at all possible, but if an issue is persistent we can
    take that as a red flag that a bug is having a detrimental effect on user experience
    or system resources.
  prefs: []
  type: TYPE_NORMAL
- en: The next line initializes our server as the `www-data` user, and sends output
    to `/var/log/crashingserver.log`.
  prefs: []
  type: TYPE_NORMAL
- en: The final line sends out an email just after our server has been started, or
    restarted. This is so we can be notified that there are probably issues to address
    with our server.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's implement another Upstart script that notifies us if the server crashes
    beyond its `respawn limit`, plus we'll look at another way to keep our server
    alive.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting a respawn limit violation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If our server exceeds the `respawn limit`, it's likely there is a serious issue
    that should be solved as soon as possible. We need to know about it immediately.
    To achieve this in Upstart, we can create another Upstart configuration file that
    monitors the `crashingserver` daemon, sending an email if the `respawn limit`
    is transgressed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Let's save this to `/etc/init/sitedownmon.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We define this Upstart process as a task (it only has one thing to do, after
    which it exits). We don't want it to stay alive after our server has crashed.
  prefs: []
  type: TYPE_NORMAL
- en: The task is performed when the `crashingserver` daemon has stopped during a
    respawn (for example, when the `respawn limit` has been broken).
  prefs: []
  type: TYPE_NORMAL
- en: Our script stanza (directive) contains a small bash script that checks for the
    existence of the `JOB` environment variable (in our case, it would be set to `crashingserver)`
    and then sends an email accordingly. If we don't check its existence, a `sitedownmon`
    seems to trigger false positives when it is first started and sends an email with
    an empty `JOB` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could later extend this script to include more web servers, simply by adding
    one line to `sitedownmon.conf` per server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Staying up with forever
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a simpler Node-based alternative to Upstart called `forever:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we simply initiate our server with `forever` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And then access our site, some of the terminal output will contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: But we'll still be able to access our site (although it will have crashed and
    been restarted).
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy our site on a remote server, we log in to our server via SSH, install
    `forever` and say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: While this technique is certainly less complex, it's also less robust. Upstart
    provides core kernel functionality and is therefore system critical. If Upstart
    fails, the kernel panics and the whole server restarts.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, `forever` is used widely in production on Nodejitsu's PaaS stack,
    and its attractive simplicity may be viable for less mission-critical production
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Deploying to a server environment* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hosting with a Platform as a Service provider* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Continuous deployment* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The more streamlined our processes, the more productive we can be. Continuous
    deployment is about committing small ongoing improvements to a production server
    in a time saving, efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous deployment is especially relevant to team collaboration projects.
    Instead of working on separate forks of the code and spending extra time, money,
    and effort on integration, everyone works on the same code base so integration
    is seamless.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll create a deployment flow using Git as a version control
    tool. While this may not be Node, it can certainly boost productivity for coding,
    deploying, and managing Node projects.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we're a little unfamiliar with Git, we can gain insight from Github's help
    documents, [http://help.github.com](http://help.github.com).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll need Git installed on both our server and desktop systems, instructions
    for different systems can be found here [http://book.git-scm.com/2_installing_git.html](http://book.git-scm.com/2_installing_git.html).
    If we''re using Linux with the `apt-get` package manager we can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are installing Git for the first time, we''ll have to set the personal
    information configuration settings as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We'll be using our `login` app, which we deployed to our server in the first
    recipe. So let's SSH into our server and enter the `/var/www/login` directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Since we'll not be running our app as root, we'll keep things simple and change
    the listening port in `login/app.js` to `8000:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we''ve logged in to our server and installed Git (see *Getting ready)*
    in the `login` folder, we say the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Next, we create a bare repository (it has a record of all the changes but no
    actual working files) which we'll be pushing changes to. This helps to keep things
    consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll call the bare repository `repo`, because this is the repository we''ll
    be pushing our changes to and we''ll create it within the `login` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Next. we hook up our bare `repo` to the `login` app repository, and push all
    the commits to `repo`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now we'll write a Git hook that instructs the `login` repository to pull any
    changes from the bare `repo` repository, then restarts our `login` app whenever
    `repo` is updated via a remote Git push.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'With the file open in `nano`, we write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Saving our hook with *Ctrl* + *O*, then exit with *Ctrl* + *X*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we ever make Git commits to the `login` repository, the two repositories
    could go out of sync. To fix this, we create another hook for the `login` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We store this in `login/.git/hooks/post-commit`, ensuring it has been made executable
    using `chmod +x post-commit`.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be making commits to the `repo` remotely via the SSH protocol. Ideally,
    we want to create a system user just for Git interactions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve also created home directories for the `git` user to make it easy for
    `forever` to store logs and PID files. We''ll need to make `git` the owner of
    the `login` app, allowing us to manage it using Git through SSH:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Finally (for the server-side setup), we log in as the `git` user and start our
    app using `forever`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Assuming our server is hosted at `nodecookbook.com`, we could now access the
    `login` app at `http://nodecookbook.com:8000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back on our desktop, we clone the `repo` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This will give us a `repo` directory, containing all the generated files perfectly
    matching our original `login` folder. We can then enter the `repo` folder and
    make a change to our code (say, altering the port in `app.js)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Then we commit the change and push to our server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: On the server side, our app should have automatically restarted, resulting in
    our app now being hosted from `http://nodecookbook.com:9000` instead of `http://nodecookbook.com:8000`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created two Git repositories. The first is the `login` app itself. When we
    ran `git init`, a `.git` directory was added to the `login` folder. `git add *`
    adds all of the files in the folder and `commit -m "initial commit"` plants our
    additions into Git's version control system. So now our entire code base is recognized
    by Git.
  prefs: []
  type: TYPE_NORMAL
- en: The second is `repo`, which is a created with the `--bare` flag. This is a sort
    of skeleton repository providing all of the expected Git functionality, but lacking
    the actual files (it has no working tree).
  prefs: []
  type: TYPE_NORMAL
- en: While it may seem overly complex to use two repositories, it actually simplifies
    things greatly. Since Git does not allow pushes to a branch that is currently
    checked in, we would have to create a separate dummy branch so we can checkout
    of the master and into the dummy branch. This creates problems with the Git hooks
    and restarting our app. The hooks try to start the app for the wrong branch. The
    branches can also quickly become out of sync, and the hooks only add fuel to the
    fire.
  prefs: []
  type: TYPE_NORMAL
- en: As `repo` is within the `login` directory, we create a `.gitignore` file telling
    Git to disregard this subdirectory. Even though `login` and `repo` are on the
    same server, we add `repo` as a `remote` repository. This puts some necessary
    distance between the repositories and allows us to later use our first Git hook
    to cause `login` to pull changes from `repo`. A Git push from `repo` to `login`
    wouldn't cause `login` to update its working directory, whereas pulling from `repo`
    into `login` does initiate a merge.
  prefs: []
  type: TYPE_NORMAL
- en: After our `remote add`, we perform an initial push from the master branch (login)
    to `repo`, now they're singing off the same hymn sheet.
  prefs: []
  type: TYPE_NORMAL
- en: Then we created our hooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Git hooks are executable files which reside in the repository''s `hook` folder.
    There are a variety of available hooks (already in the folder, but suffixed with
    `.sample)`. We used two: `post-update` and `post-commit`. One executes after an
    update (for example, once changes have been pulled and integrated into `repo)`,
    and one after a commit.'
  prefs: []
  type: TYPE_NORMAL
- en: The first hook, `login/repo/hooks/post-update`, essentially provides our continuous
    deployment functionality. It changes its working directory from `repo` to `login`
    using `cd`, and commands a `git pull`. The `git pull` command is prefixed with
    `env -i`. This prevents problems with certain Git functionality that would otherwise
    execute the Git commands on behalf of `repo` no matter what directory we sent
    our hook script to. Git utilizes a `$GIT_DIR` environment variable to lock us
    in to the repository that the hook is called from. `env -i` deals with this by
    telling `git pull` to ignore (`-i`) all environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Having updated the working directory, our hook then goes on to call `forever
    restart`, thus causing our app to reinitialize with the committed changes in place.
  prefs: []
  type: TYPE_NORMAL
- en: Our second hook is little more than a polyfill to ensure code base consistency
    in the event that commits are made directly to the `login` repository. Making
    commits directly to the `login` directory won't update the working tree, nor will
    it cause our app to restart but the code between `login` and `repo` will at least
    maintain synchronicity.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of damage limitation (if we were ever compromised), we create a
    specific account for handling Git updates over SSH, giving it a home directory,
    taking ownership of the `login` app and executing the primary initialization of
    our app.
  prefs: []
  type: TYPE_NORMAL
- en: Once the server is configured it's plain sailing. After cloning the `repo` repository
    to our local development environment, we simply make a change, add and commit
    that change, then push to the server.
  prefs: []
  type: TYPE_NORMAL
- en: The server receives our push request, updates `repo`, initiates the `post-update`
    hook which makes `login` pull the changes from `repo`, after which the `post-update`
    hook uses `forever` to restart `app.js`, and thus we have a continuous deployment
    work flow.
  prefs: []
  type: TYPE_NORMAL
- en: We can potentially have as many clones from as many locations as we like, so
    this method lends itself well to geographically-independent team collaboration
    projects both large and small.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We could avoid uploading modules by using `npm install` in the post-update hook.
    Also, Git hooks don't have to be written in shell script, we can write them in
    Node!
  prefs: []
  type: TYPE_NORMAL
- en: Building module dependencies on update
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some Node modules are written in pure JavaScript, others have C or C++ bindings.
    Those with C or C++ bindings have to be built from source — a task which is system
    specific. Unless our live server environment is identical to our development environment,
    we shouldn't simply push code build for one system onto another.
  prefs: []
  type: TYPE_NORMAL
- en: Further, to save on transfer bandwidth and have faster synchronizations, we
    could have our Git hooks install all modules (native bindings and JavaScript)
    and have Git ignore the `node_modules` folder entirely.
  prefs: []
  type: TYPE_NORMAL
- en: 'So in our local repository, let''s do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll change the `post-update` hook in our bare remote repository (login/repo/hooks)
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We've added`&& npm rebuild && npm install` to the `git pull` line (using`&&`
    to ensure they benefit from the `env -i` command).
  prefs: []
  type: TYPE_NORMAL
- en: Now if we added a module to `package.json`, and did a `git commit -a` followed
    by `git push`, our local `repo` would push the `package.json` to the remote `repo`.
    This would trigger the `post-update` hook to pull changes into the main `login`
    repository, and follow this up with an `npm rebuild` (to rebuild any C / C++ dependencies)
    and an `npm install` (to install any new modules).
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Node Git hook for integrated testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Continuous deployment is an extension of continuous integration which generally
    carries the expectation that a thorough test suite is run against any code changes
    for quality assurance.
  prefs: []
  type: TYPE_NORMAL
- en: Our `login` app (being a basic demonstration site) doesn't have a test suite
    (for info on test suites, see[Chapter 9](ch09.html "Chapter 9. Writing Your Own
    Node Modules"), *Writing Your Own Node Modules)*, but we can still write a hook
    that executes any tests that could be added to `login` in the future.
  prefs: []
  type: TYPE_NORMAL
- en: What's more, we can write it in Node, which has the added bonus of functioning
    cross platform (on Windows, for example).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We would place this code on the server into `login/repo/hooks/pre-commit` and
    make it executable (`chmod +x pre-commit)`.
  prefs: []
  type: TYPE_NORMAL
- en: The first line sets `node` as the scripts interpreter directive (much as `#!/bin/sh`
    sets the `sh` shell for shell scripts). Now we're in Node country.
  prefs: []
  type: TYPE_NORMAL
- en: We use `npm` programmability, to load the `package.json` file for our app, and
    then run the test script (if any is specified).
  prefs: []
  type: TYPE_NORMAL
- en: 'We then add the following to our `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Then do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever we push to `repo`, any changes will only be committed if they pass
    the tests. As long as we have a well-written test suite, this is a great way to
    maintain good code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For our `scripts.test` property, we used `node test` (as In [Chapter 9](ch09.html
    "Chapter 9. Writing Your Own Node Modules"), *Writing Your Own Node Modules)*.
    However, there are more advanced test frameworks available to us, such as Mocha
    [http://visionmedia.github.com/mocha/](http://visionmedia.github.com/mocha/).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This Node Git hook is adapted (with permission) from a gist by Domenic Denicola,
    which can be found at [https://gist.github.com/2238951](https://gist.github.com/2238951).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Deploying to a server environment* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Automatic crash recovery* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a test-driven module API discussed In [Chapter 9](ch09.html "Chapter 9. Writing
    Your Own Node Modules"),Writing Your Own Node Modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hosting with a Platform as a Service provider* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hosting with a Platform as a Service provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Platform as a Service Provider (PaaS)** for Node incorporates all of the
    concepts discussed in the previous three chapters and boils deployment down to
    a very basic, yet powerful, set of commands. When it comes to deployment, PaaS
    can make our lives very easy. With one simple command our app is deployed, and
    with another we can seamlessly update and reinitialize.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we'll learn how to deploy to Nodejitsu, one of the leading
    Node hosting platform providers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we'll install `jitsu`, Nodejitsu's deployment and app management command-line
    app.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we proceed, we must sign up for an account as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The app will take us through the trivial signup process and create an account
    for us, which we must confirm by email.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nodejitsu is not the only Node PaaS, there are others such as no.de, Nodester,
    and Cloud Foundry which follow similar processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve received our email, we use the provided voucher, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As in the first recipe, we'll use the `login` app from the *Initializing and
    using a session* recipe of[Chapter 6](ch06.html "Chapter 6. Accelerating Development
    with Express"),Accelerating Development with Express
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, we enter the `login` folder and make some modifications to `package.json:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: And now we deploy!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: If we navigate to our specified subdomain at `http://login.nodejitsu.com`, or
    alternatively `http://login.jit.su`, we will see our `login` app (if a subdomain
    isn't available `jitsu` will suggest alternatives).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We made some modifications to `package.json`. The name of our app is the only
    alteration that is necessarily made by directly editing `package.json`. The other
    additions could have been made on our behalf by the `jitsu` executable. It is
    important to set the name of the app because in `jitsu` apps are managed by their
    name.
  prefs: []
  type: TYPE_NORMAL
- en: If we had not appended the `subdomain, scripts`, and `engines` properties to
    `package.json, jitsu` would have asked for the particulars when we ran `jitsu
    deploy` and regenerated `package.json` on our behalf.
  prefs: []
  type: TYPE_NORMAL
- en: '`subdomain` specifies the label prefix to `nodejistu.com`, from where we host
    our app (for example, `login.nodejitsu.com). scripts`, with the `start` sub-property
    informs Nodejitsu of our ignition script, the file that starts the app. `engines`
    defines which versions of Node our app is designed for.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's find out how to access our Nodejitsu app via a custom domain, and how
    to provision a database backend through the `jitsu` executable.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning custom domains to Nodejitsu apps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To prepare our app for serving through a custom domain, we make an amendment
    to `package.json` as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we push our changes with `jitsu` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The app is now ready to receive traffic via [http://login.nodecookbook.com](http://login.nodecookbook.com),
    but before traffic can reach it, we must match our domain's A records with those
    of Nodejitsu.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get the current list of Nodejitsu A records with `dig` (or a similar
    command-line app):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The process for changing A records depends upon our domain providers. We can
    generally find it in the DNS area of our provider's control panel/administration
    area.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning a database with jitsu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the last recipe of[Chapter 6](ch06.html "Chapter 6. Accelerating Development
    with Express"), *Accelerating Development with Express*, we built a MongoDB backed
    Express app. Now we're going to take the `profiler` app live with Nodejitsu, making
    use of the database provisioning capabilities of `jitsu`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s provision a Mongo database for the profiler database as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '`jitsu` will provision our database through a third-party database PaaS provider
    (in Mongo''s case, PaaS provider is MongoHQ). The second-to-last line of output
    provides us with the MongoDB URI for our new database, which will look something
    like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'So we update the second line of `profiler/tools/prepopulate.js` to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we run it from the `profiler/tools` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This fills our remote database with profiles and login data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We update our database URI in two other places `profiler/profiles.js` and `profiler/login/login.js`,
    in both places the second line is altered to say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '`jitsu` will ask us for certain settings `(subdomain, scripts.start`, and `engines)`,
    we can just press *Enter* and stick with the defaults (unless of course `profiler.nodejitsu.com`
    is already taken, in which case we should choose a different URL).'
  prefs: []
  type: TYPE_NORMAL
- en: '`jitsu` will then deploy our app, we should be able to access it at `profiler.nodejitsu.com.`'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Deploying to a server environment* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Automatic crash recovery* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Continuous deployment* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
